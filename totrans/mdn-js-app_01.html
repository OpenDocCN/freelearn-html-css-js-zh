<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Breaking into Microservices Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Breaking into Microservices Architecture</h1></div></div></div><p>The architecture of server-side application development for complex and large applications (applications with huge number of users and large volume of data) shouldn't just involve faster response and providing web services for wide variety of platforms. It should be easy to scale, upgrade, update, test, and deploy. It should also be highly available, allowing the developers write components of the server-side application in different programming languages and use different databases. Therefore, this leads the developers who build large and complex applications to switch from the common monolithic architecture to microservices architecture that allows us to do all this easily. As microservices architecture is being widely used in enterprises that build large and complex applications, it's really important to learn how to design and create server-side applications using this architecture. In this chapter, we will discuss how to create applications based on microservices architecture with Node.js using the Seneca toolkit.</p><p>In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding monolithic architecture</li><li class="listitem" style="list-style-type: disc">Scaling, upgrading, deploying, and writing applications based on monolithic architecture</li><li class="listitem" style="list-style-type: disc">Discussing microservices architecture in depth</li><li class="listitem" style="list-style-type: disc">Scaling, upgrading, deploying, and writing applications based on microservices architecture</li><li class="listitem" style="list-style-type: disc">Getting started with Seneca</li><li class="listitem" style="list-style-type: disc">Creating and calling services using Seneca</li></ul></div><div class="section" title="What is monolithic architecture?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>What is monolithic architecture?</h1></div></div></div><p>To understand <a id="id0" class="indexterm"/>microservices architecture, it's important to first understand monolithic architecture, which is its opposite.</p><p>In monolithic architecture, different functional components of the server-side application, such as payment processing, account management, push notifications, and other components, all blend together in a single unit.</p><p>For example, applications are usually divided into three parts. The parts are HTML pages or native UI that run on the user's machine, server-side application that runs on the server, and database that also runs on the server. The server-side application is responsible for handling HTTP requests, retrieving and storing data in a database, executing algorithms, and so on. If the server-side application is a single executable (that is, running is a single process) that does all these tasks, then we say that the server-side application is monolithic.</p><p>This is a common way of building server-side applications. Almost every major CMS, web servers, server-side frameworks, and so on are built using monolithic architecture.</p><p>This architecture may seem successful, but problems are likely to arise when your application is large and complex.</p><div class="section" title="Demerits of monolithic architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Demerits of monolithic architecture</h2></div></div></div><p>The following <a id="id1" class="indexterm"/>are some of the issues caused by server-side applications built using the monolithic architecture.</p><div class="section" title="Scaling monolithic architecture"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Scaling monolithic architecture</h3></div></div></div><p>As traffic <a id="id2" class="indexterm"/>to your server-side application increases, you will need to scale your server-side application to handle the traffic.</p><p>In case of monolithic architecture, you can scale the server-side application by running the same executable on multiple servers and place the servers behind a load balancer or you can use round robin DNS to distribute the traffic among the servers:</p><div class="mediaobject"><img src="graphics/B05154_01_01.jpg" alt="Scaling monolithic architecture"/></div><p>In the preceding diagram, all the servers will be running the same server-side application.</p><p>Although <a id="id3" class="indexterm"/>scaling is easy, scaling monolithic server-side application ends up with scaling all the components rather than the components that require greater resource. Thus, causing unbalanced utilization of resources sometimes, depending on the quantity and types of resources the components need.</p><p>Let's consider some examples to understand the issues caused while scaling monolithic server-side applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Suppose there is a component of server-side application that requires a more powerful or special kind of hardware, we cannot simply scale this particular component as all the components are packed together, therefore everything needs to be scaled together. So, to make sure that the component gets enough resources, you need to run the server-side application on some more servers with powerful or special hardware, leading to consumption of more resources than actually required.</li><li class="listitem" style="list-style-type: disc">Suppose we have a component that requires to be executed on a specific server <a id="id4" class="indexterm"/>operating system that is not free of charge, we cannot simply run this particular component in a non-free operating system as all the components are packed together and therefore, just to execute this specific component, we need to install the non-free operating system on all servers, increasing the cost greatly.</li></ul></div><p>These are just some examples. There are many more issues that you are likely to come across while scaling a monolithic server-side application.</p><p>So, when we scale monolithic server-side applications, the components that don't need more powerful or special kind of resource starts receiving them, therefore deceasing resources for the component that needs them. We can say that scaling monolithic server-side application involves scaling all components that are forcing to duplicate everything in the new servers.</p></div><div class="section" title="Writing monolithic server-side applications"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Writing monolithic server-side applications</h3></div></div></div><p>Monolithic <a id="id5" class="indexterm"/>server-side applications are written in a particular programming language using a particular framework. Enterprises usually have developers who are experts in different programming languages and frameworks to build server-side applications; therefore, if they are asked to build a monolithic server-side application, then it will be difficult for them to work together.</p><p>The components of a monolithic server-side application can be reused only in the same framework using, which it's built. So, you cannot reuse them for some other kind of project that's built using different technologies.</p></div><div class="section" title="Other issues of monolithic architecture"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Other issues of monolithic architecture</h3></div></div></div><p>Here are <a id="id6" class="indexterm"/>some other issues that developers might face, depending on the technology that is used to build the monolithic server-side application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It may need to be completely rebuild and redeployed for every small change made to it. This is a time-consuming task and makes your application inaccessible for a long time.</li><li class="listitem" style="list-style-type: disc">It may completely fail if any one of the components fails. It's difficult to build a monolithic application to handle failure of specific components and degrade application features accordingly.</li><li class="listitem" style="list-style-type: disc">It may be difficult to find how much resources are each components consuming.</li><li class="listitem" style="list-style-type: disc">It may be difficult to test and debug individual components separately.</li></ul></div></div></div></div></div>
<div class="section" title="Microservices architecture to the rescue"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Microservices architecture to the rescue</h1></div></div></div><p>We saw the problems <a id="id7" class="indexterm"/>caused by monolithic architecture. These problems lead developers to switch from monolithic architecture to microservices architecture.</p><p>In microservices architecture, the server-side application is divided into services. A service (or microservice) is a small and independent process that constitutes a particular functionality of the complete server-side application. For example, you can have a service for payment processing, another service for account management, and so on; the services need to communicate with each other via a network.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>What do you mean by "small" service?</strong></span>
</p><p>You must be wondering how small a service needs to be and how to tell whether a service is small or not. Well, it actually depends on many factors such as the type of application, team management, availability of resources, size of application, and how small you think is small. However, a small service doesn't have to be the one that is written is fewer lines of code or provides a very basic functionality. A small service can be the one on which a team of developers can work independently, which can be scaled independently to other services, scaling it doesn't cause unbalanced utilization of recourses, and overall they are highly decoupled (independent and unaware) of other services.</p></div></div><p>You don't have to run each service in a different server, that is, you can run multiple services in a single computer. The ratio of server to services depends on different factors. A common factor is the amount and type of resources and technologies required. For example, if a service needs a lot of RAM and CPU time, then it would be better to run it individually on a server. If there are some services that don't need much resources, then you can run them all in a single server together.</p><p>The following diagram shows an example of the microservices architecture:</p><div class="mediaobject"><img src="graphics/B05154_01_02.jpg" alt="Microservices architecture to the rescue"/></div><p>Here, you <a id="id8" class="indexterm"/>can think of <span class="strong"><strong>Service 1</strong></span> as the web server with which a browser communicates and other services providing APIs for various functionalities. The web services communicate with other services to get data.</p><div class="section" title="Merits of microservices architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Merits of microservices architecture</h2></div></div></div><p>Due to <a id="id9" class="indexterm"/>the fact that services are small and independent and communicate via network, microservices architecture solves many problems that monolithic architecture had. Here are some of the benefits of microservices architecture:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As the services communicate via a network, they can be written in different programming languages using different frameworks</li><li class="listitem" style="list-style-type: disc">Making a change to a service only requires that particular service to be redeployed instead of all the services, which is a faster procedure</li><li class="listitem" style="list-style-type: disc">It becomes easier to measure how much resources are consumed by each service as each service runs in a different process</li><li class="listitem" style="list-style-type: disc">It becomes easier to test and debug, as you can analyze each service separately</li><li class="listitem" style="list-style-type: disc">Services can be reused by other applications as they interact via network calls</li></ul></div></div><div class="section" title="Scaling services"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Scaling services</h2></div></div></div><p>Apart <a id="id10" class="indexterm"/>from the preceding benefits, one of the major benefits of microservices architecture is that you can scale individual services that require scaling instead of all the services, therefore preventing duplication of resources and unbalanced utilization of resources.</p><p>Suppose we want to scale <span class="strong"><strong>Service 1</strong></span> in the preceding diagram. Here is a diagram that shows how it can be scaled:</p><div class="mediaobject"><img src="graphics/B05154_01_03.jpg" alt="Scaling services"/></div><p>Here, we are running two instances of <span class="strong"><strong>Service 1</strong></span> on two different servers kept behind a load <a id="id11" class="indexterm"/>balancer, which distributes the traffic between them. All other services run the same way, as scaling them wasn't required. If you wanted to scale <span class="strong"><strong>Service 3</strong></span>, then you can run multiple instances of <span class="strong"><strong>Service 3</strong></span> on multiple servers and place them behind a load balancer.</p></div><div class="section" title="Demerits of microservices architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Demerits of microservices architecture</h2></div></div></div><p>Although <a id="id12" class="indexterm"/>there are a lot of merits of using microservices architecture compared to monolithic architecture, there are some demerits of microservices architecture as well:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As the server-side application is divided into services, deploying, and optionally, configuring each service separately is a cumbersome and time-consuming task.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Note that developers often use some sort automation technology (such as AWS, Docker, and so on) to make deployment somewhat easier; however, to use it, you still need a good level of experience and expertise with that technology.</p></div></div></li><li class="listitem" style="list-style-type: disc">Communication between services is likely to lag as it's done via a network.</li><li class="listitem" style="list-style-type: disc">This sort of server-side applications more prone to network security vulnerabilities as services communicate via a network.</li><li class="listitem" style="list-style-type: disc">Writing code for communicating with other services can be harder, that is, you need to make network calls and then parse the data to read it. This also requires more processing. Note that although there are frameworks to build server-side applications using microservices that make fetching and parsing data easier, it still doesn't deduct the processing and network wait time.</li><li class="listitem" style="list-style-type: disc">You will surely need some sort of monitoring tool to monitor services as they may go down due to network, hardware, or software failure. Although you may use the monitoring tool only when your application suddenly stops, to build the monitoring software or use some sort of service, monitoring software needs some level of extra experience and expertise.</li><li class="listitem" style="list-style-type: disc">Microservices-based server-side applications are slower than monolithic-based server-side applications as communication via networks is slower compared to memory.</li></ul></div></div><div class="section" title="When to use microservices architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>When to use microservices architecture</h2></div></div></div><p>It may <a id="id13" class="indexterm"/>seem like its difficult to choose between monolithic and microservices architecture, but it's actually not so hard to decide between them.</p><p>If you are building a server-side application using monolithic architecture and you feel that you are unlikely to face any monolithic issues that we discussed earlier, then you can stick to monolithic architecture. In future, if you are facing issues that can be solved using microservices architecture, then you should switch to microservices architecture.</p><p>If you are switching from a monolithic architecture to microservices architecture, then you don't have to rewrite the complete application, instead you can only convert the components that are causing issues to services by doing some code refactoring. This sort of server-side applications where the main application logic is monolithic but some specific functionality is exposed via services is called microservices architecture with monolithic core. As issues increase further, you can start converting more components of the monolithic core to services.</p><div class="mediaobject"><img src="graphics/B05154_01_04.jpg" alt="When to use microservices architecture"/></div><p>If you are building a server-side application using monolithic architecture and you feel that <a id="id14" class="indexterm"/>you are likely to face any of the monolithic issues that we discussed earlier, then you should immediately switch to microservices architecture or microservices architecture with monolithic core, depending on what suits you the best.</p></div><div class="section" title="Data management"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Data management</h2></div></div></div><p>In microservices architecture, each <a id="id15" class="indexterm"/>service can have its own database to store data and can also use a centralized database.</p><p>Some developers don't use a centralized database at all, instead all services have their own database to store the data. To synchronize the data between the services, the services omit events when their data is changed and other services subscribe to the event and update the data. The problem with this mechanism is that if a service is down, then it may miss some events. There is also going to be a lot of duplicate data, and finally, it is difficult to code this kind of system.</p><p>Therefore, it's a good idea to have a centralized database and also let each service to maintain their own database if they want to store something that they don't want to share with others. Services should not connect to the centralized database directly, instead there should be another service called <span class="strong"><strong>database service</strong></span> that provides APIs to work with the centralized database. This extra layer has many advantages, such as the underlying schema can be changed without updating and redeploying all the services that are dependent on the schema, we can add a caching layer without making changes to the services, you can change the type of database without making any changes to the services and there are many other benefits. We can also have multiple database services if there are multiple schemas, or if there are different types of database, or due to some other reason that benefits the overall architecture and decouples the services.</p></div></div>
<div class="section" title="Implementing microservices using Seneca"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Implementing microservices using Seneca</h1></div></div></div><p>Seneca <a id="id16" class="indexterm"/>is a Node.js framework for creating server-side applications using microservices architecture with monolithic core.</p><p>Earlier, we discussed that in microservices architecture, we create a separate service for every component, so you must be wondering what's the point of using a framework for creating services that can be done by simply writing some code to listen to a port and reply to requests. Well, writing code to make requests, send responses, and parse data requires a lot of time and work, but a framework like Seneca makes all this easy. Also, converting the components of a monolithic core to services is also a cumbersome task as it requires a lot of code refactoring, but Seneca makes it easy by introducing the concepts of actions and plugins. Finally, services written in any other programming language or framework <a id="id17" class="indexterm"/>will be able to communicate with Seneca services.</p><p>In <a id="id18" class="indexterm"/>Seneca, an action represents a particular operation. An action is a function that's identified by an object literal or JSON string called the action pattern.</p><p>In Seneca, these operations of a component of monolithic core are written using actions, which we may later want to move from monolithic core to a service and expose it to other services and monolithic cores via a network.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Why actions?</strong></span>
</p><p>You might be wondering what is the benefit of using actions instead of functions to write operations and how actions make it easy to convert components of monolithic core to services? Suppose you want to move an operation of monolithic core that is written using a function to a separate service and expose the function via a network, then you cannot simply copy and paste the function to the new service, instead you need to define a route (if you are using Express). To call the function inside the monolithic core, you will need to write code to make an HTTP request to the service. To call this operation inside the service, you can simply call a function so that there are two different code snippets depending from where you are executing the operation. Therefore, moving operations requires a lot of code refactoring. However, if you would have written the preceding operation using the Seneca action, then it would have been really easy to move the operation to a separate service.</p><p>In case the operation is written using action, and you want to move the operation to a separate service and expose the operation via a network, then you can simply copy and paste the action to the new service. That's it. Obviously, we also need to tell the service to expose the action via the network and tell the monolithic core where to find the action, but all these require just couple of lines of code.</p></div></div><p>A Seneca service exposes actions to other services and monolithic cores. While making requests to a service, we need to provide a pattern matching an action's pattern to be called in the service.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Why patterns?</strong></span>
</p><p>Patterns make it easy to map a URL to an action. Patterns can overwrite other patterns for specific conditions, therefore it prevents editing the existing code, as editing the existing code in a production site is not safe and has many other disadvantages.</p></div></div><p>Seneca also has a concept of plugins. A <code class="literal">seneca</code> plugin is actually a set of actions that can be <a id="id19" class="indexterm"/>easily distributed and plugged in to a <a id="id20" class="indexterm"/>service or monolithic core.</p><p>As our monolithic core becomes larger and complex, we can convert components to services. That is, move actions of certain components to services.</p><div class="section" title="Creating your first Seneca application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Creating your first Seneca application</h2></div></div></div><p>Let's create <a id="id21" class="indexterm"/>a basic application using Seneca to demonstrate how to use it. We will create an application that allows users to log in and register. This will be a demo application just to demonstrate how actions, plugins, and services can be created, and not how login and registration functionality works.</p><p>Before you proceed further, create a directory named <code class="literal">seneca-example</code> and place a file named <code class="literal">package.json</code> in it. Inside the <code class="literal">seneca-example</code> directory, we will place our services and monolithic core. Inside the <code class="literal">package.json</code> file, place the following code so that npm will be able to download the dependencies for our application:</p><div class="informalexample"><pre class="programlisting">{
  "name": "seneca-example",
  "dependencies": {
    "seneca": "0.6.5",
    "express" : "latest"
  }
}</pre></div><p>Here we are using Seneca version 0.6.5. Make sure that you are also using the same version to avoid code incompatibility.</p><p>Now run the <code class="literal">npm install</code> command inside the <code class="literal">seneca-example</code> directory to install Seneca and other packages locally.</p><p>Now create a file named <code class="literal">main.js</code> that will be the monolithic core of our server side application.</p><p>The monolithic core and services are all <code class="literal">seneca</code> instances programmatically. Place this code in the <code class="literal">main.js</code> file to create a <code class="literal">seneca</code> instance:</p><div class="informalexample"><pre class="programlisting">var seneca = require("seneca")();</pre></div><p>Now using this <code class="literal">seneca</code> object, we are going to add actions, call actions, add plugins, and everything.</p><div class="section" title="Creating actions"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Creating actions</h3></div></div></div><p>Let's create <a id="id22" class="indexterm"/>actions for login and registration functionality and place them in the <code class="literal">main.js</code> file. To create actions, we need to use the <code class="literal">add</code> method of the <code class="literal">seneca</code> object. The first argument of the <code class="literal">add</code> method takes a JSON string or object that is the action identifier (called <span class="strong"><strong>pattern</strong></span> to identify the action). The second <a id="id23" class="indexterm"/>argument is a callback that will be executed when the action is invoked.</p><p>Place this code in the <code class="literal">main.js</code> file that creates two actions for login and registration, as follows:</p><div class="informalexample"><pre class="programlisting">seneca.add({role: "accountManagement", cmd: "login"}, function(args, respond){
});

seneca.add({role: "accountManagement", cmd: "register"}, function(args, respond){
});</pre></div><p>We will see the code for the body of the actions later in this chapter.</p><p>There is nothing special about <code class="literal">role</code> and <code class="literal">cmd</code> properties. You can use any property names you wish too.</p><p>The second argument is a callback, which will be invoked when the action is called.</p><p>If there are multiple actions with the same pattern, then the later overrides the others.</p><p>We need to use the <code class="literal">act</code> method of the <code class="literal">seneca</code> object to invoke an action that's local to the instance or resides on some other service. The first argument of the <code class="literal">act</code> method is a pattern to match an action, and the second argument is a callback that will be executed once the action has been invoked.</p><p>Here is an example code that shows how to call the preceding two actions:</p><div class="informalexample"><pre class="programlisting">seneca.act({role: "accountManagement", cmd: "register", username: "narayan", password: "mypassword"}, function(error, response){
});

seneca.act({role: "accountManagement", cmd: "login", username: "narayan", password: "mypassword"}, function(error, response){
});</pre></div><p>The callback passed to the <code class="literal">act</code> method is executed asynchronously once the result of the action arrives.</p><p>Here, the object we passed to the <code class="literal">act</code> method has two extra properties than the action's pattern it is supposed to match. However, the action is still matched and invoked because in case the pattern passed to the <code class="literal">act</code> method has more properties than the action's pattern it is supposed to match, Seneca finds all the action's patterns whose properties are in the pattern passed to the <code class="literal">act </code>method and invokes the one that has the highest number of matching properties.</p><p>If Seneca <a id="id24" class="indexterm"/>finds multiple action patterns with equal number of matching properties, then they are matched in ascending alphabetical order.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>You can learn more about Seneca pattern matching at <a class="ulink" href="http://senecajs.org/getting-started.html#patterns-unique-override">http://senecajs.org/getting-started.html#patterns-unique-override</a>.</p></div></div></div><div class="section" title="Creating plugins"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Creating plugins</h3></div></div></div><p>A Seneca <a id="id25" class="indexterm"/>plugin is just a set of related actions packed together. Programmatically, a <code class="literal">seneca</code> plugin can be created using a function or module.</p><p>A plugin makes it easy to distribute a set of actions among applications. You will also find <code class="literal">seneca</code> plugins in online public package registry maintained by npm. For example, there is a <code class="literal">seneca</code> plugin that provides actions to work with the MongoDB database. This plugin can be inserted into monolithic cores or services with just a single line of code.</p><p>By default, Seneca <a id="id26" class="indexterm"/>installs <a id="id27" class="indexterm"/>four <a id="id28" class="indexterm"/>built-in plugins <a id="id29" class="indexterm"/>when we create a <code class="literal">seneca</code> instance. These plugins are <span class="strong"><strong>basic</strong></span>, <span class="strong"><strong>transport</strong></span>, <span class="strong"><strong>web</strong></span>, and <span class="strong"><strong>mem-store</strong></span>.</p><p>Let's first create a plugin using a function. The function name is the plugin name, and a plugin can also have an initialization action, which will be invoked as soon as the plugin is attached to the <code class="literal">seneca</code> instance.</p><p>So, let's create a plugin named <code class="literal">account</code> and place the login and register actions in that, as later on, we will be creating a service and moving the actions there. Remove the actions we defined earlier in the <code class="literal">main.js</code> file and place the following code instead:</p><div class="informalexample"><pre class="programlisting">function account(options)
{
  this.add({init: "account"}, function(pluginInfo, respond){
    console.log(options.message);
    respond();
  })

  this.add({role: "accountManagement", cmd: "login"}, function(args, respond){
  });

  this.add({role: "accountManagement", cmd: "register"}, function(args, respond){
  });
}

seneca.use(account, {message: "Plugin Added"});</pre></div><p>Here we defined a function named <code class="literal">account</code> and attached it using the <code class="literal">use</code> method of the <code class="literal">seneca</code> <a id="id30" class="indexterm"/>object. To attach multiple plugins, we <a id="id31" class="indexterm"/>can call the <code class="literal">use</code> method multiple times.</p><p>The<code class="literal"> init:account</code> action is the initialization action invoked by Seneca once the plugin is added. This can be used to do things such as establishing database connection or other things that the actions of the plugin depend on.</p><p>The<code class="literal"> this</code> keyword inside the plugin refers to the <code class="literal">seneca</code> instance.</p><p>Let's create the same plugin using a module so that it's easily distributable and can be put up in the <code class="literal">npm</code> registry. Create a file named <code class="literal">account.js</code> and place it in the <code class="literal">seneca-example</code> directory. <code class="literal">account.js</code> is the plugin module. Place this code inside the <code class="literal">account.js</code> file:</p><div class="informalexample"><pre class="programlisting">module.exports = function(options)
{
  this.add({init: "account"}, function(pluginInfo, respond){

    console.log(options.message);

    respond();
  })

  this.add({role: "accountManagement", cmd: "login"}, function(args, respond){
  });

  this.add({role: "accountManagement", cmd: "register"}, function(args, respond){
  });

  return "account";
}</pre></div><p>Here is the plugin name in the string returned by the anonymous function.</p><p>Remove <a id="id32" class="indexterm"/>the plugin code that we previously defined in the <code class="literal">main.js</code> file and place the following code instead:</p><div class="informalexample"><pre class="programlisting">seneca.use("./account.js", {message: "Plugin Added"});</pre></div><p>Here, to attach the plugin, we are providing the module path.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>You can learn more about creating Seneca plugins at <a class="ulink" href="http://senecajs.org/write-a-plugin.html">http://senecajs.org/write-a-plugin.html</a>, and you can find all the Seneca plugins at <a class="ulink" href="http://senecajs.org/plugins.html">http://senecajs.org/plugins.html</a>.</p></div></div></div><div class="section" title="Creating services"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Creating services</h3></div></div></div><p>A service <a id="id33" class="indexterm"/>is a seneca instance that exposes some actions via network. Let's create a service that exposes the login and register actions.</p><p>Create an <code class="literal">account-service.js</code> file in the <code class="literal">seneca-example</code> directory that will act as the service. Then place the following code in it to create a service that exposes the login and register actions:</p><div class="informalexample"><pre class="programlisting">var seneca = require("seneca")();

seneca.use("./account.js", {message: "Plugin Added"});

seneca.listen({port: "9090", pin: {role: "accountManagement"}});</pre></div><p>Here, we first created a <code class="literal">seneca</code> instance. Then we added actions via a plugin. You can also manually add actions using the <code class="literal">add</code> method of the <code class="literal">seneca</code> object. Finally, we exposed the actions via an HTTP protocol. Seneca also supports other protocols, but we will stick to HTTP, as it's the most commonly used one.</p><p>
<code class="literal">seneca.listen</code> creates an HTTP server to listen to requests. We also provided the port number and pin, which are optional. The default port is <code class="literal">10101</code>, and by default, there is no pin if not provided.</p><p>You must be wondering what is a pin and what is it used for? Well, you may not always want to expose all the actions of the service via a network. In that case, you can provide a pattern to the <code class="literal">pin</code> property and the server will handle these requests that match the <code class="literal">pin</code> pattern.</p><p>Now, for other services or monolithic cores to be able to call the actions of this service, they need to register this service.</p><p>Remove the previous plugin attachment code from the <code class="literal">main.js</code> file and add the following code to register the service:</p><div class="informalexample"><pre class="programlisting">seneca.client({port: "9090", pin: {role: "accountManagement"}});</pre></div><p>Here we are registering the service by providing the <code class="literal">port</code> number and <code class="literal">pin</code>. Both of them are optional. In case if we don't use any port number, then it defaults to <code class="literal">10101</code>. In case the service is on different server, then you should use the <code class="literal">host</code> property to provide the IP address.</p><p>The <code class="literal">pin</code> attached to the <code class="literal">client</code> method is used to tell the <code class="literal">seneca</code> instance about what actions <a id="id34" class="indexterm"/>are exposed by the service. It's completely optional. Seneca won't send requests to a service that doesn't match the <code class="literal">pin</code> pattern.</p><p>You can add as many services as you want by calling the client method multiple times.</p><p>When you call the <code class="literal">act</code> method to invoke an action, the <code class="literal">seneca</code> instance first looks for the action locally before requesting services. If it's not found locally, then it checks for the services that have a pin to see if it matches any. If a pin matches, then it sends request to this particular service. Finally, if any of the pin doesn't match, it sends the requests one by one to all other services that don't have a pin till it gets a valid response from one of them.</p><p>You can also manually call an action of a service by sending the GET request to these types of URL:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">http://localhost:9090/act?role=accountManagement&amp;cmd=login&amp;username=narayan&amp;password=mypassword</code>
</pre></div><p>You can also call a service by using the POST request. Here is how to do it using CURL:</p><div class="informalexample"><pre class="programlisting">curl -d '{"role":"accountManagement","cmd":"login","username":"narayan","password":"mypassword"}' -v http://localhost:9090/act</pre></div></div><div class="section" title="Storing data"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Storing data</h3></div></div></div><p>Seneca <a id="id35" class="indexterm"/>provides a built-in mechanism to store data. Seneca provides some built-in actions that allow us to store data. The built-in actions use <code class="literal">mem-store</code> to store data by default. <span class="strong"><strong>mem-store</strong></span> is an asynchronous in-memory storage system.</p><p>You can create your application using the default storing mechanism. In case you want to change the underlying store system, you just need to install plugin for this particular storage system that will overwrite the built-in storage actions, therefore you will not have to refactor any code.</p><p>The built-in actions to do the CRUD operations are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">role:entity,cmd:load,name:&lt;entity-name&gt;</code>: This is used to retrieve an entity using its ID. An entity can be thought of as a row in MySQL. Every entity gets a unique ID.</li><li class="listitem" style="list-style-type: disc"><code class="literal">role:entity,cmd:save,name:&lt;entity-name&gt;</code>: This is used to update (if you provide entity ID) or add an entity if it does not exist. Entities are stored and retrieved in form of objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">role:entity,cmd:list,name:&lt;entity-name&gt;</code>: This is used to list all the entities that are matching a query.</li><li class="listitem" style="list-style-type: disc"><code class="literal">role:entity,cmd:remove,name:&lt;entity-name&gt;</code>: This is used to remove an entity using its ID.</li></ul></div><p>Seneca also provides some wrapper functions that extract these actions and make it easy <a id="id36" class="indexterm"/>to call these actions. These functions are <code class="literal">load$</code>, <code class="literal">save$</code>, <code class="literal">list$</code>, and <code class="literal">remove$</code>.</p><p>Let's implement the login and register actions to allow us to log in and also register new accounts.</p><p>Here is the implementation of the account action. Update this code in the <code class="literal">account.js</code> file:</p><div class="informalexample"><pre class="programlisting">this.add({role: "accountManagement", cmd: "login"}, function(args, respond){
  var accounts = this.make("accounts");

  accounts.list$({username: args.username, password: args.password}, function(error, entity){
    if(error) return respond(error);

    if(entity.length == 0)
    {
      respond(null, {value: false});
    }
    else
    {
      respond(null, {value: true});
    }
  });
});</pre></div><p>The first argument of the callback passed to the <code class="literal">add</code> method holds reference to the object that matched against the pattern of the action.</p><p>Here we are first calling the <code class="literal">make</code> method of the <code class="literal">seneca</code> object. It's used to get reference of an entity's store. For example, in case of MySQL, the <code class="literal">make</code> method gets reference to a table.</p><p>Then, we will find whether there are any entities with the username and password passed by the <code class="literal">act</code> method. As entities are added as objects, to query for entities, we need to pass an object. Now <code class="literal">list$</code> looks for all entities with the same username and password.</p><p>We are passing a callback to the <code class="literal">$list</code> method that will be invoked asynchronously once the data is retrieved. This callback takes two parameters, that is, the first parameter is an <code class="literal">error</code> object if there is an error, otherwise <code class="literal">null</code>.<code class="literal"> </code>Similarly, the second parameter is an array of entities found matching the given object.</p><p>For the action to respond back, it needs to call the second parameter of the action callback <a id="id37" class="indexterm"/>by passing it an object as the second argument. In case an error has occurred, we need to pass the error in the first argument.</p><p>Similarly, now let's write the code for the register action, as follows:</p><div class="informalexample"><pre class="programlisting">this.add({role: "accountManagement", cmd: "register"}, function(args, respond){
  var accounts = this.make("accounts");

  accounts.list$({username: args.username}, function(error, entity){
    if(error) return respond(error);

    if(entity.length == 0)
    {
      var data = accounts.data$({username: args.username, password: args.password})

      data.save$(function(error, entity){
        if(error) return respond(error);

        respond(null, {value: true});
      });
    }
    else
    {
      respond(null, {value: false});
    }
  });
});</pre></div><p>Here, most of the code is understandable as it works the same way as the previous action. To store data, we <a id="id38" class="indexterm"/>are creating a new entity store reference using the <code class="literal">data$</code> method by passing the entity we want to store. Then we are calling the <code class="literal">save$</code> method to save the entity.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>To learn more about storing data in Seneca, visit <a class="ulink" href="http://senecajs.org/data-entities.html">http://senecajs.org/data-entities.html</a>.</p></div></div></div><div class="section" title="Integrating Express and Seneca"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Integrating Express and Seneca</h3></div></div></div><p>We have <a id="id39" class="indexterm"/>completed creating our login and <a id="id40" class="indexterm"/>register actions. Now, as our backend will be used by an app or it may represent as a website, we need to provide URLs to the clients who will use them to talk to the server.</p><p>Monolithic core is the part of our server-side application that the client interacts with for most of the functionality. Clients can also interact with services directly for some specific functionality if required.</p><p>So, we <a id="id41" class="indexterm"/>need to use some sort of website development <a id="id42" class="indexterm"/>framework in the monolithic core and services of our server-side application. We will be using Express, as it's the most popular one.</p><p>Seneca also provides a built-in way to map the URLs to actions, that is, requests made to an HTTP server can be automatically mapped to a particular action to invoke them. This is done using a definition object whose properties define a route mapping from URLs to action patterns. This built-in method defines route mapping independent of the framework being used. Once we have defined the definition objects, we need a plugin specific to the web server framework that will capture and resolve the URLs to action patterns using the definition objects. Definition object allows you to attach callbacks that will get the response of the action via a parameter, and then the callbacks can return the data to the user in whatever format they want. This can be useful in case you are creating a plugin for distribution that exposes a few actions that need to be called for specific URL requests, then you will have to use the built-in method, as it defines route mapping independent <a id="id43" class="indexterm"/>of the framework being used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>You can learn more about how to use the built-in way to integrate Seneca and Express at <a class="ulink" href="https://github.com/rjrodger/seneca-web">https://github.com/rjrodger/seneca-web</a>.</p></div></div><p>Add the following code to the <code class="literal">main.js</code> file to start the Express server in it:</p><div class="informalexample"><pre class="programlisting">var app = require("express")();
app.use(seneca.export("web"))
app.listen(3000);</pre></div><p>On the second line, we are exporting a middleware function provided by the <code class="literal">seneca-web</code> plugin. <code class="literal">seneca-web</code> is the plugin to integrate Seneca and Express directly, that is, to translate URLs into action patterns using the definition object for Express framework. This is only required if we use the definition object to define route mapping. We won't be using definition objects, but we should still use <code class="literal">seneca-web</code>, as some third-party plugins may use definition objects if we are using these plugins. For example, if you are using the <code class="literal">seneca-auth</code> plugin, then you will have to include second line.</p><p>We want the user to be able to log in using the <code class="literal">/account/login</code> path and register using the <code class="literal">/account/register</code> path. The user will provide a username and password via query string. Here is the code to define routes to handle HTTP requests for login and registration:</p><div class="informalexample"><pre class="programlisting">app.get('/account/register', function(httpRequest, httpResponse, next){
  httpRequest.seneca.act({role: "accountManagement", cmd: "register", username: httpRequest.query.username, password: httpRequest.query.password}, function(error, response){
    if(error) return httpResponse.send(error);

    if(response.value == true)
    {
      httpResponse.send("Account has been created");
    }
    else
    {
      httpResponse.send("Seems like an account with same username already exists");
    }
  });
});

app.get('/account/login', function(httpRequest, httpResponse, next){
  httpRequest.seneca.act({role: "accountManagement", cmd: "login", username: httpRequest.query.username, password: httpRequest.query.password}, function(error, response){
    if(error) return httpResponse.send(error);

    if(response.value == true)
    {
      httpResponse.send("Logged in!!!");
    }
    else
    {
      httpResponse.send("Please check username and password");
    }
  });
});</pre></div><p>Here <a id="id44" class="indexterm"/>we are calling the appropriate actions <a id="id45" class="indexterm"/>depending on the path of the URL request.</p><p>Here, instead of using <code class="literal">seneca.act</code>, we are using <code class="literal">httpRequest.seneca.act</code> as the middleware function that we exported earlier adds a new <code class="literal">seneca</code> property to request the object of every HTTP requests. This property inherits the actual <code class="literal">seneca</code> instance. Actions in the third-party plugins add information in form of properties to the <code class="literal">seneca</code> property in order to share information related to a particular HTTP request with other route handers. The preceding code will behave in the same way even if we use <code class="literal">seneca.act</code>, but it's a good practice to use <code class="literal">httpRequest.seneca.act</code> as we may use such types of plugins. Your own route handlers can also use <code class="literal">httpRequest.seneca.act</code> to pass <a id="id46" class="indexterm"/>information related to <code class="literal">seneca</code> to each other.</p><p>Now, to <a id="id47" class="indexterm"/>run the application, first run the <code class="literal">account-service.js</code> file and then the <code class="literal">main.js </code>file. You can then log in and register using the following URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">http://localhost:8080/account/login?username=narayan&amp;password=mypassword</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">http://localhost:8080/account/register?username=x&amp;password=mypassword</code></li></ul></div><p>Here, we saw how to create a web interface, which can be used by an app or to serve HTML pages in case it's a website.</p><p>We can also move the routes of Express to a service if we want a different service to handle certain requests.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>In this chapter, we saw the difference between monolithic and microservices architecture. Then we discussed what microservices architecture with monolithic core means and its benefits. Finally, we jumped into the Seneca framework for implementing microservices architecture with monolithic core and discussed how to create a basic login and registration functionality to demonstrate various features of the Seneca framework and how to use it.</p><p>In the next chapter, we will create a fully functional e-commerce website using Seneca and Express frameworks.</p></div></body></html>