- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Framework Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our framework development journey, we have reached the point where we can
    discuss framework maintenance in detail. So far, we have completed an initial
    version of the full stack framework in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the framework maintenance topics will guide you toward future
    frameworks to develop. These are the topics related to the framework release process,
    the continuous development cycles, and, finally, the long-term maintenance of
    large framework projects. In more detail about framework maintenance, we shall
    learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development cycle**: We’ll learn about the concepts and paradigms that help
    develop formal feature definitions and figure out how to seek framework user feedback.
    First, we shall recap the analysis and design steps of the framework development
    process. Then, we’ll move on to formal feature definitions, as well as ways to
    seek user feedback and keep these users informed about changes in the framework.
    Being adept at these concepts will help you keep your framework relevant, user-friendly,
    and competitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release process**: Getting accustomed to the release process involves several
    logistical tasks, such as defining the versioning and licensing terms, combined
    with a pipeline that can release and deliver your project to the public. This
    entails creating automated pipelines to build, test, and deploy your framework.
    This process also teaches you how to smoothly transition from code completion
    to a published product that users can easily adopt and benefit from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-term maintenance**: This part revolves around broader aspects that extend
    beyond typical coding tasks. The long-term framework management tasks include
    monitoring a project’s health, keeping it secure, managing dependencies, and making
    necessary improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding these three aspects – the development cycle, the release process,
    and long-term maintenance – will significantly enhance the success of the frameworks
    you build and maintain. It will ensure that your project stays relevant, secure,
    and robust and is of the highest quality, ultimately leading to a better response
    from its stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like in the other chapters, we will continue to use the repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    The `chapter9` directory for this chapter consists of several sample projects
    that showcase tools related to framework maintenance. Most of these have a similar
    structure to a common Node.js project. For each child directory in `chapter9`,
    you can explore the maintenance tool examples. Refer to the `chapter9/README.md`
    files for extra information about the included projects.
  prefs: []
  type: TYPE_NORMAL
- en: The development cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand the framework maintenance tasks, we will rely on the **Software
    Development Life Cycle** (**SDLC**) to partition some of the important milestones
    of our framework development, such as building features and releasing them for
    your stakeholders. Our goal is to take the broad themes of SDLC and apply them
    to our framework projects, focusing on specific examples that will help you build
    better projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The software development life cycle](img/Figure_9.1_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The software development life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.1* shows a simplified diagram of the SDLC, which we can apply to
    our framework projects. In this book, we have performed these steps in detail,
    except we need to focus further on the **Deployment** and **Maintenance** steps
    to complete the cycle. We have taken care of the first **Analysis** step by learning
    about the organization of other frameworks and planning out each large portion
    of the *Componium* full stack framework. We have performed useful examinations
    of the existing abstractions, popular patterns, and types of frameworks in *Chapters
    2 and 3*. To further reinforce this **Analysis** step, we brainstormed with potential
    stakeholders and the feature set of the testing, backend, and frontend parts of
    *Componium*. In this chapter, we will look at other strategies that help framework
    developers make framework projects more successful.'
  prefs: []
  type: TYPE_NORMAL
- en: About SDLC
  prefs: []
  type: TYPE_NORMAL
- en: The **Software Development Life Cycle** (**SDLC**), in some cases also called
    the **Systems Development Life cycle**, is a term that originated in the 1960s.
    At the time, it was used to help develop complex business systems. Later, it was
    used further in software projects, combined with different development models
    such as waterfall. This term defines the systematic process of building large
    systems and software, providing the methodology for a development process, and
    focusing on quality and programming efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Software developers usually use this model as a foundation and evolve their
    approach to building software, based on what works works better in their organization.
    The introduction of agile software development methods is an extension of an approach
    to SDLC. In the instance of JavaScript application development, development teams
    can use these life cycle concepts to build new projects, with the use of framework
    tooling and libraries. Simultaneously, framework developers can also rely on the
    SDLC methodology to craft a high-quality, performant framework experience.
  prefs: []
  type: TYPE_NORMAL
- en: The **Design** stage, following the **Analysis** step, is what we discussed
    in when building a framework in *Chapters 6*, *7*, and *8*, and it outlines the
    architecture parts of a framework. This is where framework authors focus on bridging
    the gap between requirements and the start of writing code. The **Design** step
    is particularly interesting when working with the JavaScript ecosystem. Due to
    the multifaceted nature of web development, including different aspects of JavaScript,
    runtimes, and web APIs, there is an opportunity to create innovative design approaches,
    combining the existing and newly built components. For example, in *Chapters 6*,
    *7*, and *8*, we had to make careful decisions about the combination of abstractions
    and the choice of libraries that we intended to use within the full stack framework.
    Going beyond the choice of libraries, the elements of the **Design** stage require
    making concrete decisions about the combination of technologies that will be used
    in the framework projects and how these technologies communicate together. This
    is where we strike a balance of strong opinions versus a flexible framework.
  prefs: []
  type: TYPE_NORMAL
- en: However, the whole concept of the SDLC process is a *cycle*, which means the
    design decisions will return to a developer in a cyclical manner. This conveys
    that not all decisions are set in stone and can be changed over time as a project
    progresses. However, some decisions are harder to change than others. For example,
    changing the API structure in the *Componium* testing framework will require all
    the consumers of the framework to rewrite or migrate their tests to a newer API.
    Most likely, the API change is for the benefit of the framework and its users,
    but it still creates friction for the projects utilizing the framework. This can
    result in framework users being stuck on certain versions of the project or moving
    off to use something else entirely.
  prefs: []
  type: TYPE_NORMAL
- en: As a framework developer, you will reach the **Design** stage again after a
    project’s initial release. When that happens, the framework SDLC will be more
    narrowly focused on feature development and larger refactoring of code. In the
    real world, an example of this stage would be in the Vue.js project. The major
    versions of Vue.js introduced changes to the renderer, made it easier to work
    with template directives, and changed the API of components. More details on that
    migration can be found at [v3-migration.vuejs.org/breaking-changes](https://v3-migration.vuejs.org/breaking-changes).
    With cases like these, the framework authors go back to the drawing board or find
    ways to drastically redesign certain public-facing and underlying structures of
    a framework.
  prefs: []
  type: TYPE_NORMAL
- en: This cycle of coming back to the **Design** stage is common in the evolution
    of a framework, particularly when it’s in active development or has a thriving
    user base. While potentially disruptive to the existing users, this iterative
    process is key to the framework’s long-term success and sustainability. Frameworks
    that fail to adapt or evolve can quickly become outdated and lose relevance. Consider
    the evolution of the Angular framework project. A complete rewrite was undertaken
    in its evolution from AngularJS to modern versions of Angular. While initially
    disruptive to the developers, this transition allowed the framework to modernize
    its architecture and take advantage of the latest JavaScript features. It also
    set the foundation for a more future-proof growth path, ensuring Angular’s position
    as one of the top frontend JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Another area where the **Design** stage reoccurs is the introduction of performance
    improvements, specifically those affecting JavaScript projects. Given the nature
    of the JavaScript language and ever-evolving web technologies, performance optimization
    is often an ongoing endeavor. The team behind the React library has consistently
    revisited its design phase to make performance improvements, leading to significant
    enhancements such as the introduction of Hooks, concurrent mode, and the new JSX
    transform. The SDLC **Design** stage keeps you busy, as it is a continuous activity
    that enables a framework to stay relevant, performant, and useful to its users.
    The key is handling these design changes in such a way that it minimizes disruptions
    and provides clear paths for users to adapt to the changes. Continuing on a similar
    theme, in the following sections, we will learn more about what framework authors
    can do to safely implement and maintain new features.
  prefs: []
  type: TYPE_NORMAL
- en: Seeking user feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most exciting parts of framework development is getting some stakeholders
    to use what you have developed. These stakeholders could be teams within your
    company, external open source users, or even your own team. The framework product
    that you produce needs an efficient feedback loop. This loop will consist of finding
    ways to get the best feedback you can from as many stakeholders as possible. After
    successfully acquiring the required input, a framework developer can outline the
    required changes to adapt to that feedback. These changes can include fixes to
    issues, the addition of new features, improvement of the developer experience,
    or overall organizational tweaks. Once these changes are in place, we reach another
    exciting part of the framework development process – delivering the newly updated
    version of the framework to the users.
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the chapter, let's focus on the first part of seeking user feedback,
    which is properly gathering feedback. Depending on the scale of your project and
    organization, you may end up interacting with large groups of stakeholders or
    having a one-on-one interaction with just a few users. For larger groups, it is
    beneficial to utilize a system that can facilitate discussion and the ability
    to have different discussions related to various aspects of a framework. The most
    simplistic approach is to maintain an issue or feature request tracking system.
    This is very similar to other software projects, but with a framework, investing
    more time in managing the aspects of this system is more important. With a framework,
    you want to be able to clearly separate the issue and feature discussions, slating
    the feedback for different releases of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The framework can also provide opportunities to direct feedback to the right
    place. For instance, gathering developer feedback can be embedded within the developer
    experience of a project. This is where the executable that developers use daily
    can provide links to the feature request tracker. In [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108),
    the `componium` executable had mechanisms to generate scaffolding of certain common
    components, and the feedback direction could be built right into that executable.
    Overall, you must rely on tools and systems to gather feedback and avoid spending
    too much time manually managing all of it. Most importantly, it is important to
    be respectful of all types of feedback. In some cases, the features built and
    described within a framework may not work well for some stakeholders. Therefore,
    it is essential to appreciate each piece of feedback as a unique perspective that
    brings with it the prospect of innovation and expansion of your project. In the
    next part, we will discuss a formal feature definition process that worked well
    across open source and private framework projects.
  prefs: []
  type: TYPE_NORMAL
- en: Formal feature definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Request for Comments** (**RFC**) and **Request for Proposals** (**RFP**)
    processes are commonly used across many industries to define new features or get
    feedback. These same processes work really well in software framework development
    as well. Many frameworks have implemented their own approach to this process of
    formal feature definition, with stakeholder feedback built in. For example, Ember.js
    hosts its RFCs at [github.com/emberjs/rfcs](https://github.com/emberjs/rfcs),
    and Vue.js hosts RFCs at [github.com/vuejs/rfcs](https://github.com/vuejs/rfcs),
    keeping track of all new, pending, and archived proposals for feature additions
    and drastic changes to the project. With the open source nature of those frameworks,
    anyone can chime in as new feature proposals arrive in those repositories. The
    proposals get reviewed in a similar manner to code contributions. Conveniently,
    these feature definitions are stored in a code repository so that they can be
    logged and referenced in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Including a process for formal feature definition helps organize both framework
    developers and users to participate in the **Design** stage of the **Framework
    Development Lifecycle** (**FDLC**). As a framework developer, you are free to
    choose how involved this process can be. For example, if we added a new feature
    to Componium to get native WebSocket support, we could create an RFC explaining
    the gist of the feature, propose an API for it, and state why it would be beneficial
    to the full stack framework overall. Depending on the complexity of our organization,
    the proposal to add this particular feature can transition through the following
    stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proposed**: When the new WebSocket feature is described in full detail. At
    this stage, other framework developers and potential stakeholders get the opportunity
    to provide initial feedback. In our example, this is where the public API, frontend
    and backend integration, and the coverage of the WebSocket feature are proposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploring**: The stage where framework developers get to explore technical
    prototypes and explore the potential architecture of the feature. During this
    stage, implementation details can be refined. For a framework project, it is also
    a good idea to share the feature with the teams that have a stake in the framework
    to seek further feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accepted**: If the feature is deemed sufficient, then the framework can proceed
    with the implementation and merge the code into the main code base at this stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for release**: The pre-release stage is a good opportunity to create
    a new **release candidate** (**RC**) for the latest improvements to the framework.
    There is another opportunity to get useful feedback on how the feature works with
    the existing projects and integrations. In terms of maintenance, user documentation
    can be introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Released**: The final stage is where the feature is launched and made available.
    This is the point at which the RFC can finally be tagged as complete and released.
    Future proposals can also reference this feature to help with feedback and the
    technical architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a formal process like this helps structure a well-organized approach
    to feature development and user feedback. However, it is worth noting that many
    features can get stuck at the **Proposal** and **Exploration** stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-world example of a simple RFC that was accepted and merged is the removal
    of Internet Explorer 11 support in Vue.js: [github.com/vuejs/rfcs/pull/294/files](https://github.com/vuejs/rfcs/pull/294/files).
    The documentation mentions the motivation behind the change, including the concerns
    about the maintenance burden and how the change affected the consumers of the
    framework. Over 50 replies were contributed to the discussion thread of that proposal,
    including members of the framework’s core team and other developers passionate
    about the change.'
  prefs: []
  type: TYPE_NORMAL
- en: The RFP process can work in a similar way to trigger interest or a bid from
    another entity to help contribute to the framework. If there is some feature that
    you would like to add to your framework but are not able to, then through this
    process, you can find a vendor that will do it for you. This process is more common
    in corporate proprietary environments.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these approaches create a structure around feature development and help
    us follow the SDLC in our own way that fits well with the project. As your framework
    evolves and develops, you might choose to tweak how these formal feature definition
    processes perform best for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: With the feature development cycle in place, in the next section, we can now
    highlight the ways a JavaScript framework approaches the release process, including
    providing the ability to report to its stakeholders about all the new improvements
    and features shipping in the new versions.
  prefs: []
  type: TYPE_NORMAL
- en: Release process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the SDLC diagram in *Figure 9**.1*, the **Deployment** step signifies when
    software can be utilized by consumers. In the context of framework development,
    this means a new release that is made available. This is where newly crafted features
    become available, and to make them available, developers need to go through the
    **release process**. In this part of the chapter, we shall explore the topics
    related to the initial and subsequent release of JavaScript framework projects.
    This will include showcasing some of the existing tools, licensing options, versioning,
    and continuous delivery. To follow the *The development cycle* section, where
    we discussed the introduction of new features, we will begin by learning how to
    keep everyone informed of the changes to a framework. Later, the *Simplifying
    releases* section will discuss the opportunities to make the release chores more
    approachable.
  prefs: []
  type: TYPE_NORMAL
- en: Change logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Framework developers already have to spend a lot of time planning, architecting,
    and developing features. Luckily, for the final step of releasing those features,
    the process of collecting the details of all the newly built framework components
    can be standardized and automated. To make this happen, projects rely on existing
    tooling, such as release utilities and change log generation tools, to support
    publishing new releases of a framework. The first thing that is useful to maintain
    and generate is a log of changes in every release. The change log is useful in
    any framework setting and should be the way you communicate with stakeholders
    about the impact of every new release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some good examples of change log structures from other popular projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electron**: The application framework project hosts its change log at [releases.electronjs.org/releases/stable](https://releases.electronjs.org/releases/stable),
    with very detailed information on changes in stable releases and upcoming pre-releases.
    It gives you the ability to filter by major framework versions and integrates
    with landed code by linking directly to the source at GitHub. The calendar of
    releases at [releases.electronjs.org/history](https://releases.electronjs.org/history)
    also provides a great visual of all the newly tagged versions. This example could
    be overkill for a newly created framework but works well for an established project
    with a large user base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changesets` automation tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next.js**: The framework uses the *GitHub Releases* feature to outline the
    changes in [github.com/vercel/next.js/](https://github.com/vercel/next.js/) releases.
    Using GitHub’s interface allows the project to document the changes, including
    the contributors, assets, and source code on the same page. GitHub’s tooling allows
    you to run comparisons across releases to get a series of commits that have changed
    from a previous release. The creation of the change log itself is done with manual
    scripts within the framework at [github.com/vercel/next.js/blob/canary/release.js](https://github.com/vercel/next.js/blob/canary/release.js).
    These scripts are automated using *GitHub Actions* when triggered by framework
    maintainers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The common theme around these change logs is that, often, the change logs are
    automatically generated, based on certain code commit message structures and with
    the use of different automated tools, which are published for users to browse
    through. Depending on your requirements, you can benefit from the following tools
    or similar in your JavaScript framework projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<type>(<scope>): <summary>`. These conventions either become more complex
    or simpler, depending on the choice of the framework developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**commitlint** ([github.com/conventional-changelog/commitlint](https://github.com/conventional-changelog/commitlint)):
    Another tool that helps validate the commit message structure and adheres to a
    certain commit convention. It is capable of validating the messages as strings
    through an interactive CLI or programmatic usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changesets** ([github.com/changesets/changesets](https://github.com/changesets/changesets)):
    A more involved solution to generate change sets for simple and multi-package
    code bases. This helps when a framework is spread across many sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you look into using these tools for your framework projects, you will
    find that there are common themes to all of them. Most of the time, these tools
    have different approaches to configuration and structures. However, with so many
    options to choose from, using any of these can help you save time by providing
    important information about the progress of your framework to your users. For
    instance, the Ember.js project has an easy-to-follow change log ([github.com/emberjs/ember.js/blob/main/CHANGELOG.md](https://github.com/emberjs/ember.js/blob/main/CHANGELOG.md))
    that helps developers keep up with updates. If you explore some of the change
    logs, including the Ember.js one, you will see different types of versioning that
    are maintained throughout the development cycle, which is what we will cover in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maintaining proper versioning for your framework can be a challenge. Keeping
    proper versioning schemes helps stakeholders understand the compatibility of their
    code with new iterations of the framework. If a project is properly versioned
    and is strict in defining its versions, then downstream consumers can be confident
    when they update the framework dependency. Any changes in the upstream framework
    versions can cause breakages in the existing components and cause havoc in the
    already-built applications. There are many cases, especially in older software,
    where framework users are asked to be cautious updating to the latest versions
    of a framework, even if projects are known to have security vulnerabilities. Some
    examples include drastic changes from AngularJS to modern versions of Angular
    or major version changes of JavaScript tooling, such as **webpack**. In addition,
    if a project frequently breaks a versioning contract, then the users of the framework
    will slow down their upgrade cycles and potentially avoid using particular projects
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the software community has created standards around versioning, such
    as **SemVer** ([semver.org](https://semver.org)) and **Calendar Versioning** (**CalVer**)
    ([calver.org](https://calver.org)), which can help define proper versioning contracts.
    These standards can help define the framework release process and should be documented
    somewhere in the framework documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Semantic versioning](img/Figure_9.2_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Semantic versioning'
  prefs: []
  type: TYPE_NORMAL
- en: '**Semantic versioning**, as shown in *Figure 9**.2*, is the most common system
    adopted across many projects nowadays. It consists of three required and one optional
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the **Major** version, which signifies changes that are incompatible
    if a user updates from an earlier major version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Minor** version means new features are available, and the release is still
    backward-compatible with earlier versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last required component is the **Patch** version, which means that there
    a bug fixes that are also backward-compatible with earlier versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optional** component toward the end of the version can consist of pre-release
    names, with the addition of metadata or build numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `semantic-release` ([npmjs.com/package/semantic-release](https://npmjs.com/package/semantic-release))
    package uses SemVer and attempts to simplify versioning for JavaScript projects
    by utilizing the code base commit history, determining whether a version of the
    project should be a *major*, *minor*, or a *patch* release. It works as a utility
    during an automated release step.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative CalVer format defines its structure using dates in the `YYYY.MM.DD`
    format. It can be useful if project releases are based on the calendar year. Ultimately,
    the framework maintainer decides the set version, and it is a big responsibility
    to correctly set these versions and ensure that downstream users do not have their
    application builds broken.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen many tools that automate different parts of the release
    process. We focused on versioning, feature feedback, and change logs. We can introduce
    tools to simplify our framework’s new release workflow further. This type of tooling
    aims to ensure that all the release process tasks are successfully executed and
    requires releases to be consistent across the board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Publishing a new release](img/Figure_9.3_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Publishing a new release'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools such as **release-it** ([github.com/release-it/release-it](https://github.com/release-it/release-it))
    and **np** ([github.com/sindresorhus/np](https://github.com/sindresorhus/np))
    make it possible to ensure that the release process goes smoothly. *Figure 9**.3*
    shows the np tool in action when publishing a new version of the Componium test.
    These tools ensure that the following tasks are completed for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Any prerequisite scripts are executed, which could include formatting and linting
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The required release tests run and pass. If the tests fail, then the release
    process is aborted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bumping the version number using the maintainer choice or based on some other
    criteria, such as using the *semantic-release* package that we saw earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing code to a specific registry. For internal projects, this could be
    an internal source; for public projects, this means uploading the source code
    to a public registry. This will probably be the source from which the framework
    users get the latest code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing the necessary tags to the code repository with the same version number
    as the one published to the registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the steps that are generally run, but for more complex
    projects, many of the steps can be tweaked to accommodate the needs of the code
    base. Usage of these tools depends on how well they fit into your workflows. It’s
    a good idea to start simple and find tools that work right outside of the box.
    As the framework project grows, you will find yourself mixing and matching different
    tools to craft your own approach to the release process. For example, [*Chapter
    3*](B19014_03.xhtml#_idTextAnchor051) mentioned the *ng-dev* tool used for internal
    Angular development. In the internals of that tool, the team utilizes the *np*
    command-line tool for the release process. The `release-it` package offers some
    extra features, suitable for projects that live inside a mono-repo code base or
    require further configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance tool showcase
  prefs: []
  type: TYPE_NORMAL
- en: The book code repository in the `chapter9` includes a collection of tools that
    you can quickly try out and see how effective they are. Your framework projects
    can integrate the included or similar tools, thus improving the framework development
    workflow. The `chapter9/commitizen` directory consists of a project that uses
    the Commitizen package to enforce Git commit guidelines for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: The `maintenance-tools` directory showcases several Node.js utilities used for
    framework maintenance. To see the available scripts, make sure to run `npm install`
    and then `npm` `run dev`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will reach the final milestone of the release process,
    which is combining the tools we have seen so far and the continuous integration
    environment, making it possible to publish a new release of a framework with a
    single click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring and maintaining the infrastructure for framework release and other
    tasks involves following best practices and adapting tools from the DevOps methodology
    space. This involves mixing software development tasks and IT operations to improve
    software releases, making them much more easily manageable. Often, integrating
    with DevOps systems will require learning new technical skills outside of the
    core technologies used in the framework that you are working on. This includes
    learning about the latest approaches to automation, secure release processes,
    and application deployment in DevOps environments.
  prefs: []
  type: TYPE_NORMAL
- en: These days, it is ubiquitous and effortless to set up the **Continuous Integration**
    (**CI**) step for software projects, and it is important to do so for framework
    projects. It is important to use the CI environment to make sure that the required
    framework tests run in an isolated environment. The CI steps also ensure code
    quality and help create a good framework development workflow. The **Continuous
    Delivery** (**CD**) pipeline is designed to deliver the framework product. It
    is configured alongside the CI steps to prepare the code changes to be inspected,
    built, and tested. These pipelines are also configured in both open source and
    internal environments.
  prefs: []
  type: TYPE_NORMAL
- en: The **Delivery** part ensures that maintainers can prepare new releases of a
    project, which includes executing the set of tools that were part of the simplified
    release routines. In the delivery phases, the internal development scripts can
    run all the relevant tasks to the release, which could include generating project
    documentation and publishing other artifacts. This release environment also has
    access to the required credentials to publish code to the relevant registries.
    During the delivery stages, maintainers can configure all the different types
    of tools that we have seen in this chapter to automate the process of publishing
    a new version of the framework software that is produced.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be a workflow set up with *GitHub Actions* to release
    new versions of Next.js. These workflows can be seen executing at [github.com/vercel/next.js/actions/workflows/trigger_release.yml](https://github.com/vercel/next.js/actions/workflows/trigger_release.yml),
    triggered by the maintainers of the framework. Configuring these automated workflows
    will give you a massive boost in productivity, as it will avoid a lot of manual
    tasks. This will also give you more confidence in your product because these workflows
    enforce the high-quality bar for all framework maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration sample
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the information shared about the maintenance tool in the *Simplifying
    releases* section, you can find a sample of CI configuration in the `chapter9/ci`
    directory. This configuration can be used for your own projects with the GitHub
    Actions ([github.com/features/actions](https://github.com/features/actions)) and
    Circle CI ([circleci.com](https://circleci.com)) infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: To test out these configurations, you can copy the files from the chapter into
    your own repository, where you have full access to edit the source of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Another relevant aspect of releasing is licensing, wherein framework authors
    need to explain the terms of use and distribution for their creations. This is
    what we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your framework develops, you will find you need to set an appropriate license
    for the code base. This release procedure can apply to both internally developed
    projects and open source initiatives. In both cases, you can choose from many
    different types of license types. For private business-related projects, you can
    choose a **proprietary license**, restricting the use of the framework outside
    of the control of the company. This type grants exclusive ownership of the code
    base and internal projects. A **commercial license** can be useful if you want
    to sell or restrict the redistribution to only the users who paid for the use
    of your code. For example, you can find some JavaScript frameworks distributing
    different editions of their frameworks, such as **Sencha Ext JS** ([store.sencha.com](https://store.sencha.com)),
    which includes community and enterprise versions. The extended enterprise versions
    can include more support, custom features, and dedicated developer attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'For open source use cases, there are licensing options as well. The website
    at [choosealicense.com](https://choosealicense.com) supports software developers
    and helps them figure out the needs behind open sourcing their work. You will
    find many popular open source projects using the following licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MIT**: This is a very permissive license that allows commercial use, distribution,
    modification, and private use. It’s based on the conditions that you retain copyright
    notices and avoid any liability or warranty from your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The GNU General Public License (GPL)**: This is a copyleft license that offers
    similar commercial permissions to the MIT license but is more detailed around
    patent and distribution rules. However, with this license, there are conditions
    for disclosing the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache License 2.0**: This is a permissive license similar to MIT but with
    additional limitations on trademarks and providing patent use cases. If anyone
    changes the code of your framework under the Apache license, then they need to
    declare the changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a framework author, it is important to decide on the license that all contributors
    will adhere to while contributing to a project. The process of changing the licenses
    down the road takes quite a bit of effort because all the contributors have to
    re-license their code under the new license. It is also important to remember
    the license types of libraries you use within your framework.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on release process items, which included gathering
    feedback, notifying users of new releases, and helping optimize those releases.
    Now, we are ready to move on to additional topics of maintenance that focus on
    the long term.
  prefs: []
  type: TYPE_NORMAL
- en: Long-term maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have looked at maintenance tasks that occur as a
    framework progresses through the development life cycle, covering topics around
    the initial or following feature updates. However, there are additional unique
    aspects of framework development that are part of the longer-term upkeep. To focus
    on a few, we will explore the topics of security, dependency management, evolving
    feature compatibility, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach to web application security has changed in recent years. More tools
    and solutions are now available in the security space that try to protect the
    whole development workflow. When users choose a framework to suit their needs,
    they also have certain security expectations from it, especially if the framework
    is built for purposes that handle critical data and user input. As you maintain
    your framework, you can expect to receive security bugs and patches that address
    security vulnerabilities. The bug bounty programs websites, such as **HackerOne**
    ([hackerone.com](https://hackerone.com)) and **Huntr** ([huntr.dev](https://huntr.dev)),
    focus on protecting software and can reach out with vulnerability reports filed
    against your framework. Both internal and open source frameworks can receive reports,
    and as a maintainer, the expectation is to fix the known vulnerabilities to maintain
    a strong security posture.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerabilities that are created could be assigned a **Common Vulnerabilities
    and Exposures** (**CVE**) identifier. For example, look at Electron’s *CVE-2022-29247*
    ([nvd.nist.gov/vuln/detail/CVE-2022-29247](https://nvd.nist.gov/vuln/detail/CVE-2022-29247)),
    which reports a vulnerability in the framework’s process communication. It outlines
    the fixed versions of the framework and the risk score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stay on the offensive and reduce the risk of vulnerability, you can follow
    the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document dangerous APIs**: Invest time in writing up documentation to highlight
    potential APIs that can present danger when misused. In a server framework, this
    can involve explaining how to protect against dangerous request payloads. In the
    frontend, issues can result from unsafely rendering HTML or failure to sanitize
    URLs or other types of input. For instance, the Vue.js project has a best practices
    guide that includes information on this topic: [vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you](https://vuejs.org/guide/best-practices/security.html#what-vue-does-to-protect-you).
    This strategy also applies to non-application frameworks as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security audits**: These types of audits can help run a framework against
    common attack vectors or specific vulnerabilities that can affect the framework
    feature set. During this process, your code can be audited by an internal security
    team or a third party to find potential issues. The goal is to find attack vectors
    that could make your framework cause harm even when used properly. For application-level
    frameworks, there exists the **OWASP Application Security Verification Standard**
    (**ASVS**), which outlines 70+ pages of technical security controls to ensure
    secure development. These controls can be found in several languages at [owasp.org/www-project-application-security-verification-standard](https://owasp.org/www-project-application-security-verification-standard).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update dependencies**: Relying on external modules and libraries introduces
    security risks when vulnerabilities get discovered in the underlying code. From
    what we have seen in Componium and other JavaScript frameworks, there are a lot
    of external dependencies that projects count on. Recently, more and more security
    scanners, such as Socket ([socket.dev](https://socket.dev)) and Dependabot ([github.com/features/security](https://github.com/features/security)),
    have become available to track down JavaScript vulnerabilities in particular and
    inform the maintainers to fix them. However, these scanners cannot fix the issues
    and create releases, so it is still up to framework developers to keep up with
    all the dependency updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECURITY.md` file, where the security policy is documented. It can usually
    be found in the root directory of the project; the one for the `express.js` project
    is at [github.com/expressjs/express/blob/master/Security.md](https://github.com/expressjs/express/blob/master/Security.md).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is always a lot to keep track of in terms of framework security maintenance,
    but even investing a bit of time into the security posture can help reduce your
    burden and improve sufficiently benefit your project. Keeping up with security
    tasks is also relevant for the dependencies of your project. The next section
    focuses on managing the dependencies that can affect your project in different
    ways, including the security aspects of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the long term, managing the dependencies of a JavaScript framework can be
    a very involved task. The libraries and modules that are relied upon can become
    outdated or unmaintained, and this goes beyond being affected by security issues.
    As an ecosystem moves forward, framework developers need to keep an eye on some
    of the stale modules that are used internally. The lack of updates to dependencies
    can be limiting when a lingering bug fix depends on a component outside of the
    framework code base. If the dependent package is fully abandoned, creating your
    own copy and attempting to fix the issue is a good idea. The other option is to
    migrate to a similar package or rewrite it independently. Dependencies can also
    break compatibility in some way, and it will be a maintenance task for the framework
    author to refactor the usage of that module to restore compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: A more positive turn of events can be additional features being added to the
    libraries that are used within a framework project. In such cases, the project
    and its users can benefit from the improvements. These enhancements can come with
    the addition of new, exciting features or potential performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Running npm-check-updates](img/Figure_9.4_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Running npm-check-updates'
  prefs: []
  type: TYPE_NORMAL
- en: We can count on some dependency management tooling to keep track of dependencies
    for us. For example, *Figure 9**.4* shows the `ncu` command line, which tracks
    down some of the dependencies that have newer versions. Alternatively, automated
    CI tools can also produce a similar report.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of the ecosystem, keeping track of dependencies in JavaScript
    projects is especially hard, so having a certain strategy, either through using
    tools or minimizing the number of dependencies, can be quite useful for a framework
    project of any size.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management fits into the larger theme of feature coverage. As a project
    progresses, framework designers alter how features are structured and remove the
    unused ones. This is something every maintainer needs to consider for the long-term
    strategy of their framework project.
  prefs: []
  type: TYPE_NORMAL
- en: Feature coverage and deprecation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, in the *Development cycle* part of the chapter, we used the SDLC and
    defined processes to drive feature development. With the long-term outlook of
    a framework project, it is useful to keep a good coverage of features that are
    practical and features that are not used by any stakeholders. When we consider
    user feedback, we also need to make sure that a feature is worth adding from a
    long-term maintenance point of view. This is where it is worth considering the
    quick wins of adding more features versus the project’s long-term vision. In a
    similar fashion, deprecating features of a framework might mean cleaning up the
    less relevant components. Usually, this would involve a lengthy process of creating
    a migration path for existing users and providing an alternative solution. Otherwise,
    the project would lose some of its credibility over time. To avoid expanding the
    hurdles of complex feature management, frameworks create extension interfaces
    that allow for feature expansion without bloating up the core functionality. We
    have seen examples of this in several projects. For instance, the Componium server
    allows custom middleware functions to intercept the requests based on the `express.js`
    behavior. Vue.js is a frontend framework example that offers a plugin interface
    for functionality, which cannot be bundled in the core framework: [vuejs.org/guide/reusability/plugins.html](https://vuejs.org/guide/reusability/plugins.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimizations are a type of feature optimization that often end
    up spanning over a long term. Frameworks may find bottlenecks or slowdowns through
    user feedback or particular use cases. This is where performance initiatives,
    which span many releases and large refactorings, can be useful to develop a more
    optimized product.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered some of the long-term issues and tasks that may
    come up during the lifespan of frameworks. Other maintenance undertakings that
    we did not cover could be solved by familiar patterns, including introducing particular
    tooling, utilizing an external service, or relying on existing software methodologies
    to reduce the maintenance burden.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter on framework maintenance, we learned and reviewed some new and
    familiar topics – the development cycle, the release process, and maintenance
    tasks. These three topics enable us to successfully maintain a JavaScript software
    project over long periods of time. Part of the reason we dived into the details
    of these subjects is to enable you to create your own maintenance workflow, with
    your choice of tools and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at the steps of the development cycle, we scoped it down to the
    specificities of JavaScript framework development. Alongside that topic, we learned
    about the RFC process and found ways to get valuable feedback from the users of
    our frameworks. Furthermore, we focused on the release process, which included
    learning about structuring our approach to versioning, licensing, documentation,
    and so on. Finally, the long-term maintenance tasks included preparing for events
    that occurred previously in other JavaScript projects. These included topics such
    as dependency management, dealing with security incidents, and handling out-of-date
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we have captured the essence of framework maintenance, and this should
    give you a good foundation to explore the other aspects of maintenance that are
    present in other projects. I encourage you to examine other frameworks. For instance,
    by looking at the open source frameworks from [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    you can find other examples of tools and techniques used in the maintenance of
    those projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we shall circle back to all the key fundamentals
    from this book and conclude our JavaScript development adventure by discussing
    the best practices of this topic.
  prefs: []
  type: TYPE_NORMAL
