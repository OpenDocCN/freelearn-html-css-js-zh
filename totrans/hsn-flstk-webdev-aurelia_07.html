<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Features on Aurelia</h1>
                
            
            
                
<p class="mce-root">Congratulations! Finally, we are here. Welcome to the last chapter of the second section of this book! At this point, we are really sure that you know how to plan and develop, and now we will add some cool features to make our application more interesting and scalable. Maybe you were thinking about how to share some properties or trigger events across all the components, or make your application understandable for people from different countries speaking different languages. Well, internationalization is a great concept that you are going to meet in this chapter. What if you need to perform operations to convert dates, numbers, or currency? Well, these kinds of situations (and so much more) are very common in a real application, so you need to be prepared to deal with it. You know what? We have good news! Aurelia is prepared with a great solution for every case (and so much more too!). In this chapter, you will learn the following topics:</p>
<ul>
<li>Event Aggregator</li>
<li>Internationalization</li>
<li>Logging</li>
<li>Aurelia dialog</li>
<li>Value converters</li>
<li>Custom binding behaviors</li>
<li>Validators</li>
<li>Custom attributes</li>
<li>Computed properties</li>
</ul>
<p class="mce-root">Let's start with this awesome chapter; I assure you that you will find it very useful and interesting. We promise.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Subscribing and publishing events – Event Aggregator at the rescue!</h1>
                
            
            
                
<p>In our current application, we have different components and views. Some of them need to retrieve data from the server, others just need to process data provided for other components, and yet others just help our user interface be more elegant and understandable. Okay, all looks good at this point. Note that at this point, our application supports different kinds of processing—data load, transformation, and how this is displayed. Each one implies a different cost of performance, and because of that one could take longer than others. That being said, let's describe a common scenario—the user enters our application and navigates to the page listing all the matches for this month. There is a lot of data to be retrieved, and you need to calculate the time between today and the match date (for each one).</p>
<p>The time remaining for the cost of all of this operation will depend on the amount of data returned by the server, so you need to remember something—when you design an application, design it while taking into consideration the most extreme cases.</p>
<p>Getting back to our application case, we can find two scenarios:</p>
<ul>
<li>The most convenient one is where the user knows that the application is retrieving data and waits patiently until the page is completely loaded. Honestly, based on our experience, this scenario represents 5% of the common user behaviors with digital applications.</li>
<li>The second and most probable scenario is an impatient user, who thinking that their internet connection is lost, refreshes the page constantly, or presses some button, or, worse yet, leaves our application forever.</li>
</ul>
<p>We need to take action to tell the user "Hey! I'm working on something, please wait!" and at the same time, block every button that can trigger an event causing more waiting time. We are sure you know the answer, the famous loading bar icon.</p>
<div><img src="img/2a0f994f-c817-4178-be27-e0981dceecaf.png" style="width:7.50em;height:6.33em;"/></div>
<p>We have two options to implement it:</p>
<ul>
<li>Put a loading bar icon on every view/component and manage its behavior inside each one</li>
<li>Put just one loading bar icon in our main application template and call it from other components</li>
</ul>
<p>Maybe you are wondering, how can I call one event from another child component? Well, without Aurelia, of course, it could be a hard task to perform, but luckily, it won't be that case. Aurelia comes with an incredible and easy-to-learn/understand feature—Event Aggregator.</p>
<p>Like choosing to use anything, the decision to use the Event Aggregator module should be dictated by your application requirements. In most cases, it's for dealing with <em>cross-cutting concerns.</em></p>
<p>Let's take an over view of what cross-cutting concerns are.</p>
<p>If there is some method that should be triggered at some event of the application/components lifetime and not have any relationship with it, we are talking about a cross-cutting concern. Some generic examples are as listed:</p>
<ul>
<li>Application loading</li>
<li>Session validation</li>
<li>Logging</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Event Aggregator</h1>
                
            
            
                
<p>The Event Aggregator class is not hard to understand. Incredibly, it just has three exposed methods. Like any other Aurelia module, you just need to import and inject it into your view model before using it:</p>
<pre>import { inject } from 'aurelia-framework';
import { EventAggregator } from 'aurelia-event-aggregator';

@inject(EventAggregator)
export class ExampleClass {
    constructor(EventAggregator) {
        this.ea = EventAggregator;
    }
}</pre>
<p>Now, let's explore the Event Aggregator methods in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">publish(event, data)</h1>
                
            
            
                
<p>This method allows you to fire events. Remember that our <kbd>EventAggregator</kbd> will be placed in some parent component, so you know which components will be subscribed to it. So, because of that, this method does not have a specific target; they are just events triggered to space and doesn't matter if they have zero or more subscribers.</p>
<p>The first argument is the event name. You can choose any name for this, as it is your custom event. It will be used as an identifier to call it from external components across our application. In this case, you can use <kbd>EventAggregator</kbd> to configure our loading bar, so it would be right to name our event according to it. We will call it <kbd>dataRetrievingEvent</kbd>.</p>
<p>The second argument is the data you want to pass to the event (to supply some data, for example) and it's completely optional. Most of the time, it will be an array or an object of data. You can even pass through a string value if you like. However, not all events need to receive new data.</p>
<p>We will call this method using our class definition variable for <kbd>EventAggregator</kbd>:</p>
<pre>this.ea.publish('dataRetrievingEvent', {message: 'Loading...don't close the window!' </pre>
<p>That was very easy. We have our first custom event configured and ready to be called from any component in our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">subscribe(event, callbackFunction)</h1>
                
            
            
                
<p>If we published an event at the first method, now it's time to listen to it. The first parameter is the event name we want to subscribe, and the second is a callback function that can be used to get the value sent by the event publisher. This data can be a simple string, or, like in our case, an object.</p>
<p>Like the preceding example, we can access this method through our <kbd>EventAggregator</kbd> class instance in our component:</p>
<pre>let subscription = this.ea.subscribe('dataRetrievingEvent', response =&gt; {
    console.log(response);
    // This should yield: Object {message: "Loading...don't close the window!"}
});</pre>
<p>We have defined a <kbd>subscriber</kbd> object which is basically a method call. This object will make a direct reference to the subscribed event and allows us to execute directly a child function called <kbd>dispose</kbd>. This function is used to delete the existing subscription, generally used when our component is destroyed. Keep in mind that even the Event Aggregator is a great feature; a little cost in performance will be paid, so don't abuse it.</p>
<p>Here's an example of a subscription that is removed when the view model is detached:</p>
<pre>import { inject } from 'aurelia-framework';
import { EventAggregator } from 'aurelia-event-aggregator';

@inject(EventAggregator)
export class ExampleClass {
    constructor(EventAggregator) {
        this.ea = EventAggregator;
    }

    attached() {
        this.subscriber = this.ea.subscribe('dataRetrievingEvent', response =&gt; {
            console.log(response.message);
        });
    }

    detached() {
        this.subscriber.dispose();
    }
}</pre>
<p>This is a garbage collection measure and ensures that your app does not use resources that it no longer requires.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">subscribeOnce(event, callbackFunction)</h1>
                
            
            
                
<p>This method is exactly the same as the <kbd>subscribe()</kbd> method, but with just one difference—it automatically unsubscribes the event once the callback is raised. Maybe in some cases, you will find some situations that just require a <em>one-time</em> subscription, such as our loading bar. The example is very similar to the <kbd>subscribe()</kbd> method example:</p>
<pre>attached() {
     this.subscriber = this.ea.subscribeOnce('dataRetrievingEvent', response =&gt; {
         console.log(response.message);
     });
}</pre>
<p>We are sure that you will find this feature really useful. This is just the beginning! Let's explore other awesome APIs!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding more languages to our application – Internationalization!</h1>
                
            
            
                
<p class="mce-root">One of the more interesting (and useful) features for every web application is internationalization. We are developing an application for the FIFA World Cup Russia 2018, so, based on that, it would be awesome if our application supported multiple languages for all the users worldwide.</p>
<p>For this purpose, we will use the official <kbd>aurelia-i18n</kbd> plugin; this will be used to get the current app location. This plugin is based on the <kbd>i18next</kbd> library, with some very interesting characteristics such as those listed:</p>
<ul>
<li>Translation loaders</li>
<li>Language detection</li>
<li>Product localization</li>
<li>Flexibility and scalability </li>
</ul>
<p>The last one is the most important feature. With scalability in mind, you can implement internationalization with just one configuration file for smaller projects, and if you need to implement it on a bigger project, just create multiple translation files and load them according to the user's need.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation and configuration</h1>
                
            
            
                
<p>Depending on which build tool you've chosen to create and configure your application, you will find many ways to install and get ready with the <kbd>aurelia-i18n</kbd> plugin. At this point, we've used the Aurelia CLI, but let's explore how to configure it in case we had chosen a different option, remember them?</p>
<ul>
<li>Webpack</li>
<li>JSPM</li>
<li>Aurelia CLI</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">For Webpack users</h1>
                
            
            
                
<p>We need to retrieve the plugin from the <kbd>npm</kbd> repository, so just type the following command to get the latest:</p>
<pre class="language-powershell"><strong> npm install aurelia-i18n --save</strong></pre>
<p>It will download and save the plugin in your project dependencies. As we said earlier, <kbd>aurelia-i18n</kbd> is based on <kbd>i18n</kbd> framework, so you should install a backend plugin. One of the most famous is <kbd>i18next-xhr-backend</kbd>, a simple <kbd>i18next</kbd> backend to be used in the browser. How does it work? Easy, using <kbd>XHR</kbd>, it will load resources from some backend server. Yes, your translation files! If you want to use the built-in <kbd>aurelia-loader</kbd> backend, the same plugin Aurelia use to get resources, it's okay, you can ignore the next step.</p>
<p>You know what to do now.</p>
<pre class="language-powershell"><strong>npm install i18next i18next-xhr-backend --save</strong></pre>
<p>We are almost ready. In your Webpack configuration file, you must add <kbd>aurelia-i18n</kbd> to your project's Aurelia bundles list (on the Aurelia section):</p>
<pre class="language-javascript">const coreBundles = {
    bootstrap: [/* many options here */],
    aurelia: [<br/>      /* many options here too*/
      'aurelia-i18n' // add aurelia-i18n to the array
    ]
  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">JSPM users</h1>
                
            
            
                
<p>Similar way as the first two steps, but instead of using the known NPM, we will use JSPM. First, we will download the <kbd>aurelia-i18n</kbd> plugins:</p>
<pre class="language-powershell"><strong> jspm install aurelia-i18n</strong></pre>
<p>For the backend, type this:</p>
<pre class="language-powershell"><strong>jspm install npm:i18next-xhr-backend</strong></pre>
<p>Since we will use the built-in <kbd>aurelia-i18n-loader</kbd>, we don't need to add any additional configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aurelia CLI users</h1>
                
            
            
                
<p>Almost the same as we explained in the Webpack user section, we need to retrieve the <kbd>aurelia-i18n</kbd> plugin and backend server from the <kbd>npm</kbd> repositories:</p>
<pre class="language-powershell"><strong>npm install aurelia-i18n --save</strong><br/><strong>npm install i18next i18next-xhr-backend --save</strong></pre>
<p>Now, we need to tell our project that we have new dependencies to be configured. Open your Aurelia configuration file (<kbd>aurelia.json</kbd>) and look for the <kbd>dependencies</kbd> section. You must add the following entries:</p>
<pre class="language-javascript">{
    "name": "i18next",
    "path": "../node_modules/i18next/dist/umd",
    "main": "i18next"
  },
  {
    "name": "aurelia-i18n",
    "path": "../node_modules/aurelia-i18n/dist/amd",
    "main": "aurelia-i18n"
  },
  {
    "name": "i18next-xhr-backend",
    "path": "../node_modules/i18next-xhr-backend/dist/umd",
    "main": "i18nextXHRBackend"
  }</pre>
<p>If your application was created using the <kbd>Aurelia CLI 0.33.1</kbd>, you can omit this last step.</p>
<p>Finally, we are done with the plugins. Now, let's configure it to our application!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring and defining our first translation files</h1>
                
            
            
                
<p>Our application is ready to start using the <kbd>i18n</kbd> framework. There are some steps to get ready with the plugin, so let's explore them.</p>
<p>The first thing we need is to locate our <kbd>index.html</kbd> file. This should be located in our main root application folder. Ensure that your <kbd>&lt;body&gt;</kbd> section is the same as the following:</p>
<pre class="language-markup"> &lt;body aurelia-app="main"&gt;
      /* Some content */
 &lt;/body&gt;</pre>
<p>If you are a <kbd>Webpack</kbd> user, locate the <kbd>index.js</kbd> file instead of <kbd>index.html</kbd>.</p>
<p>Then, in your root app location, create a folder called <kbd>locales</kbd>. It will be used to store all your location files. Create one folder per language you want to support. Then, inside each folder, create a file called <kbd>translation.json</kbd>. This file will contain all your text translation structures, depending on your application.</p>
<p>Your application folder structure must look like this:</p>
<div><img src="img/72d55340-b07d-4dd7-9e9e-d1edb6a939f5.png" style="width:14.00em;height:18.67em;"/></div>
<p><kbd>i18next</kbd> works based on a predefined transaction-file schema. Look at the following example of our en-EN transaction file:</p>
<pre class="language-javascript"> {
    "welcome": "Welcome to FIFA WC 18!",<br/>    "user_male": "Mr.",<br/>    "user_female": "Mss.",<br/>    "time_remaining": "Time Remaining : {{time}}"
  }</pre>
<p>Now, one for es-ES language support:</p>
<pre class="language-javascript"> {
    "welcome": "Bienvenido a FIFA WC 18!",<br/>    "user_male": "Sr.",<br/>    "user_female": "Sra.",<br/>    "time_remaining": "Tiempo pendiente : {{time}}"
  }</pre>
<p>So these are simply for example purposes and very useful to understand how this plugin works. Now, it's time to configure the plugin backend. Do you remember that we created the <kbd>src/main.js</kbd> file to define our configuration function? Well, it's time to open this file and add some new configuration. If you haven't created this file yet, this is a good time to do that.</p>
<p>For those who have chosen the <kbd>i18next-xhr-backend</kbd> support, first of all, open the <kbd>main.js</kbd> file and find the Aurelia's configuration section. In the first lines of the file, you must import the following files:</p>
<pre class="language-javascript">import {I18N, TCustomAttribute} from 'aurelia-i18n';
import Backend from 'i18next-xhr-backend'; </pre>
<p>Then, create a new plugin pipe:</p>
<pre>aurelia.use<br/>  .standardConfiguration()<br/>  .plugin('aurelia-materialize-bridge', b =&gt; b.useAll())<br/>  .plugin()/* &lt;&lt;&lt;&lt;  You must create a new plugin pipe*/<br/>  .feature('resources');</pre>
<p>Now, inside the new plugin pipe, add the following configuration:</p>
<pre class="language-javascript">.plugin('aurelia-i18n', (instance) =&gt; {
            let aliases = ['t', 'i18n'];
            TCustomAttribute.configureAliases(aliases);
            instance.i18next.use(Backend);

            return instance.setup({
              backend: {                                  
                loadPath: './locales/{{lng}}/{{ns}}.json',
              },
              attributes: aliases,
              lng : 'es',
              fallbackLng : 'en',
              debug : false
            });<br/>});</pre>
<p>Let's explain a little of what are we doing in this file.</p>
<p>First, we need to configure our <kbd>i18n</kbd> aliases, so just declare them on a simple string array and pass it as a parameter to the static <kbd>configureAliases()</kbd> method. This will map the defined values in our <kbd>&lt;html&gt;</kbd> tags to call the correct values. It may sound a little confusing at this time, but don't worry, you are very near to seeing the whole picture:</p>
<pre class="language-javascript">let aliases = ['t', 'i18n'];
TCustomAttribute.configureAliases(aliases);</pre>
<p>Next, we register the imported backend plugin (<kbd>i18next-xhr-backend</kbd>) into our <kbd>aurelia-i18n</kbd> instance:</p>
<pre class="language-javascript">instance.i18next.use(Backend);</pre>
<p>Finally, we need to add some configuration. This is completely based on the <kbd>i18n</kbd> configuration documents, so you can find more information about this at <a href="https://www.i18next.com/configuration-options.html">http://i18next.com/docs/options</a>. That <kbd>promise</kbd> configuration must be returned; because of that, we are adding the <kbd>return</kbd> statement before the <kbd>instance.setup()</kbd> declaration:</p>
<pre class="language-javascript">backend: {  // &lt;-- configure backend
   loadPath: './locales/{{lng}}/{{ns}}.json', // &lt;-- Our location files path
},</pre>
<p>The last options are used to map fallback language, default language and so on:</p>
<pre class="language-javascript">attributes: aliases, &lt;&lt;-- Predefined aliases
lng : 'es', // &lt;&lt;-- Default language to use (overrides language detection).
fallbackLng : 'en',// &lt;&lt;-- Language to use is current location language is not available
debug : false // &lt;&lt;-- Log info level in console output</pre>
<p>We are ready to start using the plugin. Good job!</p>
<p>If your are a Webpack user, don't forget to put the PLATFORM prefix before the plugin name. Example:    .plugin(PLATFORM.moduleName('aurelia-i18n'), (instance) =&gt; {......});</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the plugin – Multilanguage support!</h1>
                
            
            
                
<p>To start using our files, you must tell your <kbd>ViewModel</kbd> components which language to use. We will perform this operation at constructor method; check out this example:</p>
<pre class="language-javascript">import {I18N} from 'aurelia-i18n';<br/>import { inject } from 'aurelia-dependency-injection';<br/><br/>@inject(I18n) export class WelcomePageComponent { constructor(i18n) { this.i18n = i18n; this.i18n<br/> .setLocale('es-ES')<br/> .then( () =&gt; {}); } ... }</pre>
<p>What if you want to get the active locale? Easy, change the configuration file to look like this:</p>
<pre class="language-javascript">import {I18N} from 'aurelia-i18n';<br/>
@inject(I18n)
export class WelcomePageComponent {
     constructor(i18n) {
       this.i18n = i18n;
     }
      ...
}</pre>
<p>Similar to <kbd>setLocale()</kbd>, we have the <kbd>getLocale()</kbd> method. You can retrieve the active locale by typing the following:</p>
<pre class="language-javascript">console.log(this.i18n.getLocale());</pre>
<p>Now, on the HTML file, we just need to call our translation aliases to map the properties we have defined in our <kbd>translation.json</kbd> files:</p>
<pre class="language-markup">&lt;h2 t="welcome"&gt;Welcome to FIFA WX 18&lt;/h2&gt;</pre>
<p>Optionally, we are able to use our second alias to map values:</p>
<pre>&lt;h2 i18n="welcome"&gt;Welcome to FIFA WX 18&lt;/h2&gt;</pre>
<p>Now you are ready to start adding multiple language support for your application! There are so many other advanced hints to get the best results using this plugin. We will show you one of them up next.</p>
<p>Imagine that you need to map <kbd>&lt;html&gt;</kbd> tags in your translation files. Is that possible? Yes. Imagine you need to render some long test (a product description, for example) and need to bold just a few words like price or discount. What do we need to do? Very easy, just add the HTML tag you need:</p>
<pre class="language-markup">"time_remaining": "Time remaining : &lt;b&gt;{{time}}&lt;/b&gt;"</pre>
<p>Now, let's use this in our <kbd>View</kbd> file:</p>
<pre class="language-markup">&lt;label t="time_remaining"&gt;Time remaining : {{time}}&lt;/label&gt;</pre>
<p>If you look at your window, you'll see something like <kbd>&amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;</kbd>; don't be scared, it's normal. It's because we didn't set the correct markup to make our HTML tag correctly interpreted. You must know that there are four main attributes to add custom behavior to our translation file variables:</p>
<ul>
<li><kbd>[text]</kbd>: Default attribute, escapes the tag value as simple text</li>
<li><kbd>[html]</kbd>: Tells our translation file "Hey, this contains HTML tags, render it as them!"</li>
<li><kbd>[append]</kbd>: Appends the translation to the current content already present in the element (allows HTML)</li>
<li><kbd>[prepend]</kbd>: Prepends the translation to the current content already present in the element (allows HTML)</li>
</ul>
<p>This attribute has to be before our translation identifier key. You know what to do next:</p>
<pre class="language-markup">&lt;label t="[html]time_remaining"&gt;Time remaining : {{time}}&lt;/label&gt;</pre>
<p>Awesome? Yes, it is. It's up to you to research about other more advanced features; we are very sure you will enjoy all the options that <kbd>i18n</kbd> offers. That's all for this chapter? Of course, no. Let's keep exploring!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracking method calls and user actions – Logging</h1>
                
            
            
                
<p>As a developer, you know how important it is to know what is happening in your application. Some information about the user clicks, event triggers, or error messages, having a good logging tool by your side telling you whether your application is okay (or really bad) is good practice. Commonly, developers use the common <kbd>console.log()</kbd> statement and when it's time to deploy it to UAT or production, they comment all these lines.</p>
<p>Aurelia knows how important this feature is, and guess what—yes, it has its own plugin for this purpose. Let's explore!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring your log manager</h1>
                
            
            
                
<p>By default, Aurelia has the logging API already in their dependencies, so you don't need to run any <kbd>npm</kbd> command at this point. Of course, if for some reason that library is missing, you know how to deal with it.</p>
<p>First, we need to create a file to configure our log levels. In the <kbd>resources</kbd> folder, create a file called <kbd>custom-log-appender.js</kbd>. This name is completely optional; you can name it in the most convenient way.</p>
<p>First, let's configure all our log levels:</p>
<pre>export class CustomLogAppender {<br/><br/>  constructor(){}<br/>  debug(logger, message, ...rest){
    console.debug(`DEBUG [${logger.id}] ${message}`, ...rest);
  }
  info(logger, message, ...rest){
    console.info(`INFO [${logger.id}] ${message}`, ...rest);
  }
  warn(logger, message, ...rest){
    console.warn(`WARN [${logger.id}] ${message}`, ...rest); 
  }
  error(logger, message, ...rest){
    console.error(`ERROR [${logger.id}] ${message}`, ...rest);
  }
}</pre>
<p>We are almost ready. Now, open the main configuration file (<kbd>main.js</kbd>) and import the logging dependencies from Aurelia:</p>
<pre>import {LogManager} from 'aurelia-framework';</pre>
<p>Also, import our recently created <kbd>CustomLogAppender</kbd>:</p>
<pre>import {CustomLogAppender} from './resources/custom-log-appender';</pre>
<p>Now, configure the Aurelia's <kbd>LogManager</kbd> with your created <kbd>CustomLogAppender</kbd>:</p>
<pre>LogManager.addAppender(new CustomLogAppender());
LogManager.setLevel(LogManager.logLevel.debug);</pre>
<p>Look for the <kbd>configure()</kbd> function. Just need to add one single line:</p>
<pre>export function configure(aurelia) {
  aurelia.use
    .standardConfiguration()
    .developmentLogging() // &lt;-- Logging activated for development env!
    .plugin('aurelia-animator-css');</pre>
<p>Note that this kind of configuration will apply for all the environments (dev, test, prod). Commonly, logging is most used to detect error on development phase, so let's add some improvement to the previous configuration:</p>
<p>First, let's create a file called <kbd>environment.js</kbd>. This file will contain our current activated environments:</p>
<pre>//environment.js<br/>export default {<br/>  debug: true,<br/>  testing: false<br/>};</pre>
<p>Then, we need to import that file into our <kbd>src/main.js</kbd> file:</p>
<pre>import environment from './environment';<br/><br/>export function configure(aurelia) {<br/> aurelia.use<br/>     .standardConfiguration()<br/>     .plugin('aurelia-anumator-css');<br/><br/>if (environment.debug) { <br/>     aurelia.use.developmentLogging();<br/>}<br/>    .<br/>    .<br/>    .<br/>}</pre>
<p>You are ready to start using the logger! Let's open one <kbd>ViewModel</kbd> file and start recording what is happening inside:</p>
<pre>import {LogManager} from 'aurelia-framework';
let logger = LogManager.getLogger('homePage');
logger.debug('me');

export class HomePage() {<br/>    activate(){
       logger.debug(“Enter to home page!!!”);<br/>    }
}</pre>
<p>This is so easy and so useful. Of course, we have so many more special features to show you. Keep reading man!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modal configuration – Aurelia dialog at rescue!</h1>
                
            
            
                
<p>Every application needs to show different kinds of information to the final user. Does that information need to be displayed on one page? Not necessarily. The final user is very familiarized with the bootstrap dialog (commonly called <kbd>Modal</kbd>), which is a custom JavaScript <kbd>alert()</kbd> element. More elegant and more friendly to add custom behavior, it could now be used only to show alerts information, also you can configure entire forms or confirmation dialogs. In our FIFA World Cup application, the <kbd>Aurelia-materialize</kbd> plugin has already configured this feature for the modal component, but let's explore how this works and how we can improve it. Let's go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the Aurelia-dialog plugin</h1>
                
            
            
                
<p>If you are using JSPM manager, type the following command:</p>
<pre class="language-powershell"><strong>jspm install aurelia-dialog</strong></pre>
<p>Else, for <kbd>Webpack</kbd> / <kbd>Aurelia CLI</kbd> users, use the known <kbd>npm install</kbd> command:</p>
<pre class="language-powershell"><strong>  npm install aurelia-dialog --save</strong></pre>
<p>Remember to save this dependency into your <kbd>project dependencies</kbd> section. It's very important, because it will be used in the final application build.</p>
<p>Now, let's tell our application that we have a new plugin. Like other plugins seen earlier, open your Aurelia configuration file (<kbd>aurelia.json</kbd>) and add a new plugin section:</p>
<pre class="language-javascript">{
    dependencies: [
    // Some content here
      {
        "name": "aurelia-dialog",
        "path": "../node_modules/aurelia-dialog/dist/amd",
        "main": "aurelia-dialog"
      }
    // Some content here too
    ]
  }</pre>
<p>We have already configured our <kbd>index.html</kbd> file to use manual bootstrapping; if not, just ensure that it has the <kbd>&lt;body&gt;</kbd> element with the <kbd>aurelia-app="main"</kbd> tag inside:</p>
<pre class="language-markup">&lt;body aurelia-app="main"&gt;<br/>&lt;/body&gt;</pre>
<p>In your application config file (<kbd>main.js</kbd>), add a new <kbd>plugin()</kbd> entry:</p>
<pre class="language-javascript">export function configure(aurelia) {
    aurelia.use
      .standardConfiguration()
      .developmentLogging()
      .plugin('aurelia-dialog'); // &lt;&lt;-- Add this plugin!</pre>
<p>Also, if you want to add a more customized behavior to your <kbd>modal</kbd>, you can implement some configuration inside this <kbd>plugin()</kbd> pipe. Optionally, you can configure the <kbd>aurelia-dialog</kbd> plugin as follows:</p>
<pre class="language-javascript">.plugin(PLATFORM.moduleName('aurelia-dialog'), config =&gt; { // &lt;&lt;-- PLATFORM.moduleName is mandatory if you are using webpack
        config.useDefaults();
        config.settings.lock = true;
        config.settings.centerHorizontalOnly = false;<br/>        config.settings.startingZIndex = 5;
        config.settings.keyboard = true;
});</pre>
<p>You are ready! Now, it's time to listen to our plugin!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding dialog components to our application</h1>
                
            
            
                
<p>Let's create a <kbd>UserRegister</kbd> modal for our application. This will look something like this:</p>
<pre>import { inject } from 'aurelia-framework'<br/>import { DialogController } from 'aurelia-dialog'<br/><br/>@inject(DialogController)<br/>export class UserForm {
  user = { firstName: '',    <br/>           lastName: '',<br/>           age: 0<br/> };

  activate(user){
    user = user;
  }
}</pre>
<p>This is very simple by now. Remember that this component will be the modal itself. The modals are displayed over the main content, so now we will configure this behavior into our <kbd>Home</kbd> component. Pay attention to this section; it's a little tricky, but we are sure that you will find it easy to implement.</p>
<p>First, let's import <kbd>DialogService</kbd> from our recently imported <kbd>aurelia-dialog</kbd> plugin:</p>
<pre>import {DialogService} from 'aurelia-dialog';</pre>
<p>Also, let's import our recently created <kbd>UserForm</kbd> component:</p>
<pre>import {UserForm} from './user-form';</pre>
<p>Now, let's configure the dialog behavior:</p>
<pre>export class HomeComponent {<br/>  static inject = [DialogService]; // &lt;&lt;-- Same as use the @inject annotation<br/><br/>  user = { firstName: 'Diego', lastName: 'Arguelles', age: 26 }<br/><br/>  constructor(dialogService) {
    this.dialogService = dialogService; &lt;&lt;-- We need to inject the service into our component
  }<br/><br/>  openModal(){
    this.dialogService.open({ viewModel: UserForm, model: this.user}).whenClosed(response =&gt; {
      if (!response.wasCancelled) {
        console.log('good - ', response.output);
      } else {
        console.log('bad');
      }
    });
  }
}</pre>
<p>In addition, the <kbd>&lt;template&gt;</kbd> file needs to contain one <kbd>&lt;button&gt;</kbd> to trigger the <kbd>openModal()</kbd> method:</p>
<pre class="prettyprint notranslate prettyprinted">&lt;template&gt;
   &lt;button click.trigger = "openModal()"&gt;New user&lt;/button&gt;
&lt;template&gt;</pre>
<p>Let's explain the <kbd>openModal()</kbd> method:</p>
<p>First, we need to open the modal. We will set some default values for our recently created user object. This method will return a <kbd>promise</kbd> object. Why? So simple, with this <kbd>promise</kbd>, we will be able to handle any event triggered inside the modal:</p>
<pre>this.dialogService.open({ viewModel: UserForm, model: this.user}).then();</pre>
<p>Inside the <kbd>then()</kbd> statement, our <kbd>promise</kbd> will be defined in such a way:</p>
<pre>response =&gt; {<br/>    //We will get the response value returned by the modal<br/>    if (!response.wasCancelled) { <br/>        console.log('All OK - ', response.output); //Should output the recently created user info<br/>    } else { <br/>        console.log('Something get wrong!'); <br/>    } console.log(response.output);<br/>}</pre>
<p>Now, let's look at our <kbd>&lt;template&gt;</kbd> file:</p>
<pre class="prettyprint notranslate prettyprinted">&lt;template&gt;
   &lt;ux-dialog&gt;
      &lt;ai-dialog-body&gt;
         &lt;h2&gt;User registration&lt;/h2&gt;<br/>         &lt;input placeholder="User name" model.bind="user.firstName" /&gt;<br/>         &lt;input placeholder="User last name" model.bind="user.lastName" /&gt;<br/>         &lt;input placeholder="User age" model.bind="user.age" /&gt; <br/>      &lt;/ai-dialog-body&gt; <br/>      &lt;ai-dialog-footer&gt; <br/>         &lt;button click.trigger = "controller.cancel()"&gt;Cancel&lt;/button&gt; <br/>         &lt;button click.trigger = "controller.ok(message)"&gt;Ok&lt;/button&gt; <br/>      &lt;/ai-dialog-footer&gt; <br/>   &lt;/ux-dialog&gt; <br/>&lt;/template&gt;</pre>
<p>Of course, we can customize how our modal is displayed. For example, bootstrap by default adds 50% opacity in the modal background. To get the same result, include this CSS class in an existing or new style sheet. Depending on which CSS preprocessor you are using, don't forget to import it if necessary:</p>
<pre class="language-javascript">ai-dialog-overlay.active {
      background-color: black;
      opacity: .5;
}</pre>
<p>Remember that we are overwriting an existing class from Aurelia dialog, so you don't need to specify this class in the <kbd>&lt;html&gt;</kbd> component.</p>
<p>Now, you are ready to add a more user-friendly behavior to your application with the use of dynamic dialogs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dynamic value converters – Less code, more functionality</h1>
                
            
            
                
<p>As we said at the beginning of this chapter, our application should be available for all the users worldwide. You are completely free to model the application according to your own purposes. Maybe you want to implement premium features that would need you to pay to access them, so you will need to express the cost in the user currency. Another good thing could be to have a custom formatted date, or simply add some number conversion, decimal rounds, and so on.</p>
<p>You already know how to bind and interpolate values between Aurelia <kbd>View</kbd> and <kbd>ViewModel</kbd> components. Now we will see how to improve that data binding. Come on!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The problem – Data is not exposed as we need</h1>
                
            
            
                
<p>One of the common problems we could have is the date formatting. In other code languages such as Java, you have a utility class like <kbd>SimpleDateFormat</kbd>, which converts the <kbd>Date()</kbd> object to a more friendly human reading format. In JavaScript, we have some libraries to do that job, but they are not so simple to call. Let's see an example.</p>
<p>You get the current date in your <kbd>ViewModel</kbd> component; then, you pass that value to the <kbd>View</kbd> layer:</p>
<pre class="language-javascript">export class Example {
      constructor() {
        this.changeDate();
        setInterval(() =&gt; this.changeDate(), 3000); //&lt;&lt;-- This method will be executed each 3 seconds
      }

      changeDate() {
        this.currentDate = new Date(); //&lt;&lt;-- Get the current date
      }
}</pre>
<p>In our <kbd>View</kbd> file, we map the <kbd>currentDate</kbd> value to be displayed:</p>
<pre class="language-markup">&lt;template&gt;
      ${currentDate}<br/>&lt;/template&gt;</pre>
<p>When you run the example, you will be displayed in your screen the following output:</p>
<pre>Sun Feb 25 2018 14:06:37 GMT-0300 (-03) </pre>
<p>Okay, we can do better; it's time to call our value-converters, but exactly, what is a value converter? The Aurelia documents explain it really good:</p>
<p>"A value converter is a class whose responsibility is to convert view-model values into values that are appropriate to display in the view and vice versa."</p>
<p>That being said, let's create one value-converter file just for example purposes. Since we are working with a <kbd>Date()</kbd> value, we will work with the <kbd>moment</kbd> plugin.</p>
<p>If you don't have it in your dependencies tree, just import it from <kbd>npm</kbd> repositories:</p>
<pre><strong>npm install moment --save</strong> </pre>
<p>Then, first of all, import this library in our value-converter file:</p>
<pre class="language-javascript">import moment from 'moment';

export class DateFormatValueConverter {
     toView(value) {
       return moment(value).format('M/D/YYYY h:mm:ss a');
     }
}</pre>
<p>Okay, now let's explain how this works:</p>
<ul>
<li>You know that Aurelia is a convention over configuration-based framework. With that being said, if you name this class terminating it <kbd>ValueConverter</kbd>, the framework will use this class as a custom value converter without any more configuration.</li>
<li>The <kbd>toView()</kbd> method is inherited from the Aurelia <kbd>ValueConverter</kbd> interface. It defines the data flow direction, if it comes to <kbd>ViewModel</kbd> to <kbd>View</kbd>, or vice versa, you have the <kbd>fromView()</kbd> method.</li>
<li>Those value-converter methods could receive more than one parameter.</li>
</ul>
<p>Now, we just need to import this value-converter in our <kbd>View</kbd> file like any other dependency, using the <kbd>&lt;require&gt;</kbd> tag:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;require from="./date-format"&gt;&lt;/require&gt; &lt;&lt;-- Path to your value converter</pre>
<p>Now, we need to add the converter to our binding syntax:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;require from="./date-format"&gt;&lt;/require&gt;
      ${currentDate | dateFormat} &lt;br/&gt; &lt;&lt;-- Name mapped for our value converter
&lt;/template&gt;</pre>
<p>Now, refresh your browser window:</p>
<pre>2/25/2018 2:25:36 pm</pre>
<p>So much better, right? Well, this same dynamic can be applied to number format converters, currency, and so on. Let's make the example a little more advanced—what if we need to show multiple date formats across our entire application? Should we define a value-converter file per format we need? It's a valid option, but not the most effective. Do you remember when we said that value-converter interface methods can receive more than one parameter? Well, what if we send the date format as parameter too? Let's try to see what happens:</p>
<pre class="language-javascript">toView(value, format) {
        return moment(value).format(format);
}</pre>
<p>You can specify a default format in case no one was provided: <kbd>toView(value, format = 'M/D/YYYY'){ ... }</kbd></p>
<p>Nice, our formatter now accepts the <kbd>format</kbd> pattern as a parameter. It's not the magic of Aurelia; it's because we are using <kbd>moment.js</kbd> a nice JavaScript library, which allows us to perform this kind of operations.</p>
<p>Now, in our <kbd>View</kbd> file, we can add as many time formats as we need:</p>
<pre class="language-markup"><br/>${currentDate | dateFormat:'h:mm:ss a'} &lt;br/&gt;<br/>${currentDate | dateFormat:'M/D/YYYY h:mm:ss a'} &lt;br/&gt;
${currentDate | dateFormat:'MMMM Mo YYYY'} &lt;br/&gt;</pre>
<p>Now, look at your browser window:</p>
<pre>2:33:11 pm <br/>2/25/2018 2:33:11 pm <br/>February 2nd 2018 </pre>
<p>That was very nice. Now it's time to take a look at a little more complicated example but with a more common usage—arrays order.</p>
<p>You know how to retrieve data from one backend service; often this data is retrieved as an <kbd>array</kbd> object and shown as a list in the <kbd>View</kbd> file. That's all okay, but what if we need to order these values according to some property? Look at the code example:</p>
<pre class="language-javascript">export class ArraySortingValueConverter {
      toView(array, config) {
        let sorter = (config.direction || 'ascending') === 'ascending' ? 1 : -1;
        return array.sort((a, b) =&gt; {
          return (a[config.propertyName] - b[config.propertyName]) * sorter;
        });
      }
}</pre>
<p>What are we doing? Let's explain.</p>
<p>We are receiving two parameters, one array, and one config property. The config property is an object with two values: <kbd>config.direction</kbd>, which can be one of these two options: ascending or any other string. Depending on that, the sorter can order the list incrementing values <kbd>1</kbd>, or decreasing with <kbd>-1</kbd> in descending order. Then, in the return statement, we are using the sort function of the array itself, and we are sending as parameter the anonymous function to compare the mapped <kbd>config.propertyName</kbd> values in the config object.</p>
<p>This is how we are retrieving the data from some backend service:</p>
<pre class="language-javascript">import {HttpClient} from 'aurelia-http-client';

export class Example {
      users = [];
      activate() {
        return new HttpClient()
          .get('https://api.ourorganization.com/users')
          .then(response =&gt; this.users = response.content);
      }
}</pre>
<p>There's nothing weird at this point. Now, let's check the <kbd>View</kbd> file:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;require from="./array-sort"&gt;&lt;/require&gt; &lt;&lt;-- Import your value converter

      &lt;div class="row"&gt;
        &lt;div class="col-sm-3" repeat.for="user of users | arraySorting: { propertyName: 'code', direction: 'descending' }"&gt;
            ${user.firstName}
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
&lt;/template&gt;</pre>
<p>It's beautiful. We don't need to add any JavaScript function or weird configuration to start using this very useful functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding custom behaviors to our application</h1>
                
            
            
                
<p>Let's continue with our Aurelia special features exploration. In the last section, we saw value-converters, and it's impossible to not make a relationship between this feature and the binding engine of Aurelia framework. Maybe you think that both features have much in common, well, not so much really. Let's start explaining how the binding engine works.</p>
<p>The view resources in Aurelia framework can be divided into four categories:</p>
<ul>
<li>Value converters</li>
<li>Custom attributes</li>
<li>Custom elements</li>
<li>Binding behaviors</li>
</ul>
<p>We will focus only on the last one. It's not because the others are less important but because it will be better for us to understand how this works first and then explore the other categories. Don't worry, value-converters are already covered, and you will have a clearer idea about the difference between both features.</p>
<p>The value-converter acts just as a bridge interceptor between <kbd>View</kbd> and <kbd>ViewModel</kbd> (or vice versa). The binding behavior goes beyond—it has full access to the binding instance across the complete component life-cycle. This allows us to make changes in the binding behavior, such as modifying the binding throttle time, or adding customization to how the values are updated.</p>
<p>Remember that Aurelia is a two-way binding framework, so you don't need to worry about the data synchronization between <kbd>View</kbd> and <kbd>ViewModel</kbd>. How is this performed? Aurelia has a predefined throttle mechanism that updates values each 200 ms, by default. Could it be updated? Yes, Aurelia left us free to manage this value according to our needs. Similar to the <kbd>value-converters</kbd> syntax, we need to call the binding behavior in the <kbd>&lt;template&gt;</kbd> file, where we need it:</p>
<pre class="language-markup">    &lt;input type="text" value.bind="query &amp; throttle:850"&gt;</pre>
<p>Did you note the <kbd>&amp;</kbd> symbol? It's the first difference with the already covered value-converters. When we need to define a binding behavior, we tell this to the framework using the <kbd>&amp;</kbd> wildcard. Another thing you must note is that we can send parameters to the binding behaviors. Just need to add the <kbd>:</kbd> symbol after the behavior declaration and send the value. Its possible to send multiple params? Yes. How? Look at the example:</p>
<pre>&lt;input type="text" value.bind="query &amp; customBehavior:arg1:arg2:arg3"&gt;</pre>
<p>Also, you are allowed to declare more than one behavior in one element:</p>
<pre>${value | upperCase &amp; throttle:800 &amp; anotherBehavior:arg1:arg2}</pre>
<p>In the same way, you can define the updating time period between <kbd>View</kbd> and <kbd>ViewModel</kbd>; you have another interesting binding behavior called <strong>debounce</strong>. We can refer to this behavior in the same category of <em>throttle</em>, but the difference is that instead of calculating updating time, it prevents the binding from being updated until a specified interval has passed without any changes.</p>
<p>Maybe you will find this feature more useful; let's explain it through a real use case.</p>
<p>In our FIFA World Cup application, one of the most demanded features could be a search input, more specifically, an autocomplete. You already know that autocomplete component should retrieve data according to the users' input value. The big question when you develop this feature is "when should we trigger the <kbd>searchByKey()</kbd> method of the autocomplete? On every keypress? When the input length is greater than <kbd>2</kbd> or <kbd>3</kbd>?". Really, this is a hard question; your application performance is directly compromised.</p>
<p>This is a good moment to think about <em>debounce</em>. Instead of triggering the <kbd>searchByKey()</kbd> method each time the user enters a value, trigger it some time after the user enters their search key:</p>
<pre class="language-markup">&lt;input type="text" value.bind="teamCountry &amp; debounce:1000"&gt;</pre>
<p>Other really useful binding behavior you can use is <kbd>oneTime</kbd>. By default, Aurelia set the preconfigured two-way binding to each <kbd>ViewModel</kbd> property. The big question is "do we really need this two-way binding activated for each property in our components?". Most of the time, the answer is no. Here's where <kbd>oneTime</kbd> comes and becomes our performance optimization partner. Really, it has a direct impact on application performance? Yes. To enable double binding, Aurelia needs to implement multiple observers looking for any changes in your component properties. With <kbd>oneTime</kbd>, we just tell the app—map this property to my view and forget it:</p>
<pre class="language-markup"> &lt;span&gt;${score &amp; oneTime}&lt;/span&gt;</pre>
<p>Of course, there are many more predefined binding behaviors to explore, but if you remember, we used one binding behavior defined as <kbd>customBehavior</kbd> in our first example. Did you note that? Guess what, Aurelia allows you to define your own binding behavior, and now it's time to learn how.</p>
<p>Similar to custom value-converters, you can create custom binding behaviors. Check the following example:</p>
<pre>export class DynamicExpressionBindingBehavior {  

  bind(binding, source, rawExpression) {
    console.log('Binding : '+rawExpression)
  }

  unbind(binding, source) {
    console.log('Unbinding ')
  }
}</pre>
<p>Like the last examples, let's explain what the code is doing.</p>
<p>First, you must know that similar to the <kbd>toView()</kbd> and <kbd>fromView()</kbd> methods from value-converters, custom binding behaviors need to implement two methods: <kbd>bind(binding, src, expressions...)</kbd> and <kbd>unbind(binding, src)</kbd>.</p>
<p>On the <kbd>bind()</kbd> method, we are manipulating the user input value passed as a parameter. Something you must know is that on the <kbd>bind()</kbd> method, the first two parameters are sent by Aurelia. The other params can be one or more custom parameters; in this case, <kbd>rawExpresions</kbd>.</p>
<p>The <kbd>unbind()</kbd> method just ensures that our binding behavior returns to normal when our data processing ends.</p>
<p>Looks simple? Yes, the example looks easy, but a real implementation will be harder to understand. Don't worry, the predefined set of binding behavior commonly provided by Aurelia framework is enough for every application's purposes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving our application forms – Validators</h1>
                
            
            
                
<p class="mce-root">We know how the binding engine of Aurelia works. Also, we know how to intercept and customize that binding behavior. We know too how to transform data between <kbd>View</kbd>-<kbd>ViewModel</kbd> layer according to our needs. Just some things are pending, and the <kbd>aurelia-validation</kbd> plugin is one of them. When you need data provided by the user, you have to expect anything. The user didn't know your app. He will do anything he wants, and you need to be prepared for that. You need to ensure that data provided by the user is, at least, in the right format your back service is expecting. You need to filter just the right values and send alerts to the user telling which values are wrong and how they can fix it. We often need to put ourselves on the user's side. Software development is more than just programming, more than just creating forms and storing/retrieving data. We need to make our application fault-tolerant and as we said earlier, think always in the worst case. Just imagine something like this—you are developing an application that needs to perform some calculations. You have three inputs: <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>c</kbd>; you need to calculate the sum. Well, that sounds easy, right? We have two users who type the following:</p>
<pre>User 1 : value for a)33; b)23; c)32</pre>
<p>You press the Submit button and get the correct sum—<kbd>88</kbd>. Fine, the application accomplished their purpose. Let's see what second user puts:</p>
<pre>User 2: value for a)49 b)34j c)12</pre>
<p>As you can see, the last user presses by error the <kbd>j</kbd> character. Will it rely on an application error? No. Our operation will be performed, JavaScript is not a typed language, so it will operate in the following way:</p>
<pre>49 + "34j" + 12 = "4934j12"</pre>
<p>The user will see that value, and we are sure they will never use your application again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing for war – Getting the validation plugin</h1>
                
            
            
                
<p>Like other plugins we could have installed, the installation and configuration steps are very similar. If this is the first time you are performing this operation, just carry out the following steps:</p>
<p>If you are using NPM as package manager, use this:</p>
<pre><strong>npm install aurelia-validation --save</strong></pre>
<p>Alternatively, if you are a JSPM user, use this:</p>
<pre><strong>jspm install aurelia-validation</strong></pre>
<p>Now, open your <kbd>main.js</kbd> file where we had configured our application plugins. In the <kbd>configure()</kbd> function, add the new plugin:</p>
<pre class="language-javascript">export function configure(aurelia) {
    aurelia.use
      .standardConfiguration()
      .developmentLogging()
      .plugin('aurelia-validation'); // &lt;&lt;-- Add this plugin!</pre>
<p>Finally, open your <kbd>aurelia.json</kbd> file and add the following plugin declaration:</p>
<pre class="language-javascript">    {
      "name": "aurelia-validation",
      "path": "../node_modules/aurelia-validation/dist/amd",
      "main": "aurelia-validation"
    }</pre>
<p>We are ready. Let's go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">First steps – Defining our rules</h1>
                
            
            
                
<p>The Aurelia validation plugin is based on standard rules. We need to define our own set of rules using the <kbd>ValidationRules</kbd> class. This class has some static methods that receive our values and verify that the input value meet our requirements. Also, one validation rule must have one predefined format. The first method we will explain is <kbd>ensure()</kbd>:</p>
<pre class="language-javascript"> ValidationRules.ensure('myValidatedProperty')</pre>
<p>This method accepts one argument that will be our property name that we want to validate. Also, in case you were validating an object, you are allowed to pass anonymous functions as a parameter:</p>
<pre class="language-javascript"> ValidationRules.ensure(u =&gt; u.firstName)</pre>
<p>The second method we will explain is <kbd>displayName()</kbd>. This is not required but is useful if you need to show this property in one predefined format in your validation messages; consider this example:</p>
<pre class="language-javascript"> ValidationRules.ensure(u =&gt; u.firstName).displayName('User name')<br/>Error message: The user name is required.</pre>
<p>Finally, we need to define our set of rules that will apply to that field; some of the most used are as follows:</p>
<ul>
<li><kbd>required()</kbd> prevents the user from submitting null or blank values</li>
<li><kbd>matches(regex)</kbd> helps us ensure that the input value meets a predefined format, and is common on date fields</li>
<li><kbd>email()</kbd> is an easy way to ensure that the email is in the right format</li>
<li><kbd>minLength(length)</kbd> and <kbd>maxLength(length)</kbd> validate the length of string properties</li>
</ul>
<p>If our user's first name should never be null, the validation rule will be this:</p>
<pre class="language-javascript">    ValidationRules.ensure('u =&gt; u.firstName').displayName('First name')
        .required().withMessage(`\${$firstName} cannot be blank.`);</pre>
<p>Did you note something different? Yes, we are using the <kbd>withMessage()</kbd> method to customize our validation error message. The thing becomes more interesting.</p>
<p>What if you need these validation rules to apply just for one object? Don't worry, Aurelia has the problem solved. You need to tag the object you want to apply the rule on; the example is self-explanatory:</p>
<pre class="language-javascript">   // User.js class inside our models folder<br/>    export class User {
      firstName = '';
      lastName = '';
    }

   export const UserRules = ValidationRules
      .ensure('firstName').required()
      .ensure('lastName').required()
      .on(User);</pre>
<p>We are almost ready. Now, we need to configure our form controller with the recently created validation rules:</p>
<pre class="language-javascript">import { inject, NewInstance } from 'aurelia-dependency-injection';
import { ValidationController } from 'aurelia-validation';<br/>import { User, UserRules } from '../models/User'

@inject(NewInstance.of(ValidationController))
export class UserRegisterForm {
    constructor(userValidationController) {<br/>      this.user = new User(); // 1
      this.formValidator = userValidationController; //2<br/>      this.formValidator.addObject(this.user, UserRules); //3
    }
}</pre>
<p>Maybe you are wondering why we need this <kbd>NewInstance.of()</kbd> statement? Well, for each validation rule we are applying, we need a single controller to validate it. So, with this statement, we just ensure that a new <kbd>ValidationController</kbd> instance is created.</p>
<p>Now let's explain what is occurring inside our constructor method:</p>
<ul>
<li>Line 1: We are creating a new instance of the <kbd>User</kbd> object to use his properties in our form.</li>
<li>Line 2: We are assigning the new <kbd>ValidatorController</kbd> instance into our <kbd>formValidator</kbd> object.</li>
<li>Line 3: We are saying to our <kbd>formValidator</kbd> that the evaluated object is our user instance, and will use the imported <kbd>UserRules</kbd>.</li>
</ul>
<p> </p>
<p>Other way to configure our <kbd>formValidator</kbd> is defining the properties and rules inside the <kbd>validate()</kbd> method: </p>
<pre class="language-javascript">formValidator.validate({ object: user, propertyName: 'firstName', rules: myRules });</pre>
<p>In our <kbd>submit()</kbd> method, we just need to add the following:</p>
<pre class="language-javascript">formValidator.validate()
      .then(result =&gt; {<br/>        if (result.valid) {
        // validation succeeded
      } else {</pre>
<pre class="language-javascript">        // validation failed
      }
});</pre>
<p>Lastly, we need to tell our template where the validators will be placed:</p>
<pre class="language-markup">    &lt;input type="text" value.bind="user.firstName &amp; validate"&gt;

    &lt;input type="text" value.bind="user.lastName &amp; validate"&gt;</pre>
<p>The first value will be passed as a parameter to the <kbd>ensure()</kbd> function. Hey, wait a second! We need to specify where our error messages will be placed! Well, that's really simple, we would implement an error list like this:</p>
<pre class="language-markup">&lt;form&gt;
      &lt;ul if.bind="formValidator.errors"&gt;
        &lt;li repeat.for="error of formValidator.errors"&gt;
          ${error.message}
        &lt;/li&gt;
      &lt;/ul&gt;
&lt;/form&gt;</pre>
<p>Alternatively, if you want to display the message beside the wrong <kbd>input</kbd> element, you can use the <kbd>&lt;span&gt;</kbd> tag and other very interesting custom attribute: <kbd>validation-errors</kbd></p>
<pre class="language-markup">&lt;div validation-errors.bind="firstNameErrors"&gt; <br/>    &lt;label for="firstName"&gt;First Name&lt;/label&gt;
    &lt;input type="text" class="form-control" id="firstName"
               placeholder="First Name"
               value.bind="user.firstName &amp; validate"&gt;
    &lt;span class="help-block" repeat.for="errorInfo of firstNameErrors"&gt;
       ${errorInfo.error.message}
    &lt;/span&gt;<br/>&lt;/div&gt;</pre>
<p>The <kbd>validation-errors</kbd> attribute contains all validation errors regarding to the specified element (in this case <kbd>firstNameErrors</kbd>).</p>
<p>Now, start putting validation rules across your application forms! See you in the next section!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Manipulating the DOM – Custom attributes</h1>
                
            
            
                
<p>We are almost done with the most used advanced features of Aurelia. Now, it's time to explore other categories belonging to binding engine plugins—what exactly are custom attributes? Let's explain that in a very easy way—you know the <kbd>HTML</kbd> tags, such as <kbd>&lt;div&gt;</kbd>, <kbd>&lt;input&gt;</kbd>, and <kbd>&lt;span&gt;</kbd>. Also, you know that each element has attributes such as <kbd>class</kbd>, <kbd>type</kbd>, and <kbd>style</kbd>. Well, now we can add more attributes to make the element more customizable and add a more advanced behavior. Let's look at an example.</p>
<p>We had also seen the value-converters, but don't you think it would be awesome if we implement a custom attribute to perform this operation on any element? Consider something like this:</p>
<pre class="graf graf--pre graf-after--p">&lt;label datetime=”format:YYYY-MM-DD HH:mm”&gt;${match.date}&lt;/label&gt;</pre>
<p>Also, <kbd>match.date</kbd> will be a simple <kbd>Date()</kbd> JavaScript object without any format. Why do we need to accomplish this? Pay attention, we are sure that at this point, knowing the basic binding concepts, you will find it very easy.</p>
<p>First, create a class to configure your <kbd>customAttribute</kbd>:</p>
<pre class="graf graf--pre graf-after--p"><strong>import </strong>{customAttribute, bindable, inject} <strong>from </strong>'aurelia-framework';<br/><strong>import </strong>moment <strong>from </strong>'moment';<br/><br/>@inject(Element, moment); &lt;&lt;-- We already know how moment js works<br/>@customAttribute('datetime'); &lt;&lt;-- The attribute name to refer it<br/>@bindable('format'); &lt;&lt;-- The property we pass as parameter<br/><strong>export class </strong>Datetime {<br/><br/>    constructor(element, moment) {<br/>        <strong>this</strong>.element = element;<br/>        <strong>this</strong>.moment = moment;<br/>    }<br/><br/>    bind() {<br/>        <strong>this</strong>.element.innerHTML = moment(<strong>this</strong>.element.innerHTML).format(<strong>this</strong>.format);<br/>    }<br/>}</pre>
<p>What is <kbd>Element</kbd> doing? That's simple—it helps us point to the right element we want to apply the custom attribute to. Next, we just need to call our file into the template we need.</p>
<p>Another very interesting way to define your custom attribute is using the already known convention over configuration feature:</p>
<pre class="graf graf--pre graf-after--p"><strong>import </strong>{bindable, inject} <strong>from </strong>'aurelia-framework';<br/><strong>import </strong>moment <strong>from </strong>'moment';<br/><br/>@inject(Element, moment);<br/><strong>export class </strong>DatetimeCustomAttribute {<br/><br/>    @bindable format; // &lt;&lt;-- The value property can also be placed inside the class declaration<br/><br/>    constructor(element, moment) {<br/>        <strong>this</strong>.element = element;<br/>        <strong>this</strong>.moment = moment;<br/>    }<br/><br/>    bind() {<br/>        <strong>this</strong>.element.innerHTML = moment(<strong>this</strong>.element.innerHTML).format(<strong>this</strong>.format);<br/>    }<br/>}</pre>
<p>Now, in our <kbd>View</kbd> file:</p>
<pre class="graf graf--pre graf-after--p">&lt;require from="./datetime"&gt;&lt;/require&gt;<br/>&lt;label datetime="format:YYYY-MM-DD HH:mm"&gt;${match.date}&lt;/label&gt;</pre>
<p>What if we need this custom attribute available for all my application components? Well, we have a very good news—you can configure it as a global resource into your application configuration file (<kbd>main.js</kbd>).</p>
<p>Identify the <kbd>configure</kbd> method and add a global resource pointing to our recently created custom attribute:</p>
<pre class="graf graf--pre graf-after--p"><strong>export function </strong>configure(aurelia) {<br/>    aurelia.globalResources(<br/>        "./datetime"<br/>    )<br/>}</pre>
<p>At this time, you must find all these features very easy to learn, and this is because you know more advanced features that helped us understand how the framework works. See you in the last section!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding how computed properties work</h1>
                
            
            
                
<p>Welcome to the last section of this chapter! You can consider yourself a full stack programmer with strong knowledge on frontend technologies. If you note, the concepts that Aurelia uses to implement the different features are based on common problems that every web application needs to deal with, no matter which framework it is using. Also, as open source tools, the different plugins are based on other tools that actually give support to other framework plugins, such as Angular.</p>
<p>Now, the last feature that we will explain is about computed properties. We can resume it in a single line:</p>
<p>Computed properties are those that are preprocessed on the <kbd>ViewModel</kbd> layer in a JavaScript function.</p>
<p>Let's see a very simple practical use—you are developing a page that shows the <kbd>${firstName}</kbd> and <kbd>${lastName}</kbd> as a single value—<kbd>${completeName}</kbd>.</p>
<p>A common solution should create a JavaScript function to concatenate both values and map it into a <kbd>ViewModel</kbd> property. This is valid, but Aurelia comes with a better solution—the <kbd>aurelia-computed</kbd> plugin. This improves the efficiency of data-binding computed properties.</p>
<p>Do you remember the <kbd>getter</kbd>/<kbd>setter</kbd> function we mentioned in the first chapter? Well, it's time to use them.</p>
<p>This plugin uses Aurelia's JavaScript parser to parse the body of the property's getter function and check the result for observability purposes. If the getter function is observable, a specialized observer is returned to Aurelia's binding system. The observer publishes change events when properties accessed by the getter function change.</p>
<p>Let's look at an example:</p>
<pre>// "firstName" and "lastName" will be observed.
get completeName() {
  return `${this.firstName} ${this.lastName}`;
}</pre>
<p>There's nothing special yet. This function is using <kbd>dirty-checking</kbd> to bind the <kbd>completeName</kbd> computed property.</p>
<p>Why dirty? It's because the observer strategy wont be waiting for any change performed in the two values needed to retrieve the <kbd>completeName</kbd> property. It means the getter function will be executed many times across your component life cycle. Should we consider it as an issue? Really no, but if your application is becoming bigger and you have many computed properties, your performance could be directly impacted. So, what's Aurelia's solution? Just one annotation—<kbd>@computedFrom</kbd>:</p>
<pre class="language-javascript">import {computedFrom} from 'aurelia-framework';

    export class User {
      firstName = 'Diego';
      lastName = 'Arguelles';

      @computedFrom('firstName', 'lastName')
      get completeName() {
        return `${this.firstName} ${this.lastName}`;
      }
    }</pre>
<p>Aurelia's binding system will observe the specified properties and reevaluate bindings when any of the properties change. The <kbd>aurelia-computed</kbd> plugin simply automates the dependency identification and is able to support more complex scenarios such as observing property paths.</p>
<p>Another common use for this feature is to retrieve the current logged user data. We can define a Boolean property to tell our component whether the user is logged in or not, and based on this, show the real username or just <kbd>Visitor</kbd>:</p>
<pre>// "isLoggedIn", "user" and "user.userName" will be observed.<br/>@computedFrom('userName')
get userName() {
  return this.isLoggedIn ? this.userName : '(Visitor)';
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Definitely this was a very extensive chapter. We recommend to have a second read in the topics you consider more important, also as be said before, remember that if you want a complete understanding of each feature explained, you must research and do proof of concept to get the best option and experience. Due to the nature of our application, the FIFA World Cup is a worldwide event, so you need to make it available for all countries, <kbd>i18n</kbd> help us a lot to deal with internationalization with a very easy implementation. If you need to share properties or trigger events between your components, <kbd>EventAggregator</kbd> is the best choice. Aurelia offers a very usable variety of binding behaviors, making your code more clean, understandable and maintainable. Value converters, validators, computed properties are just a few binding behaviors that allows developer to reduce code. Remember that many of these features have dependence on third party libraries, so don't forget to download them and configure it into your project bundle. </p>
<p>We are really sure that this chapter was the most interesting...until this moment! See you in the next chapter!</p>


            

            
        
    </body></html>