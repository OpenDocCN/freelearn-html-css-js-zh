["```js\nclass Person {\n\n    public readonly name: string;\n    public readonly age: number;\n\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n}\n\nconst person = new Person(\"Remo\", 29);\nperson.age = 30; // Error\nperson.name = \"Remo Jansen\"; // Error\n```", "```js\nclass Street {\n\n    public readonly num: number;\n    public readonly name: string;\n\n    public constructor(num: number, name: string) {\n        this.num = num;\n        this.name = name;\n    }\n\n}\n\nclass Address {\n\n    public readonly city: string;\n    public readonly street: Street;\n\n    public constructor(city: string, street: Street) {\n        this.city = city;\n        this.street = street;\n    }\n\n}\n\nclass Company {\n\n    public readonly name: string;\n    public readonly addresses: Address[];\n\n    public constructor(name: string, addresses: Address[]) {\n        this.name = name;\n        this.addresses = addresses;\n    }\n\n}\n```", "```js\nconst company1 = new Company(\n   \"Facebook\",\n   [\n       new Address(\n           \"London\",\n           new Street(1, \"rathbone square\")\n       ),\n       new Address(\n           \"Dublin\",\n           new Street(5, \"grand canal square\")\n       )\n   ]\n);\n```", "```js\ncompany1.addresses = company1.addresses.map(a => R.toUpper(a.street.name)); // Error\n```", "```js\nconst company2 = new Company(\n   company1.name,\n   company1.addresses.map((a) =>\n       new Address(\n           a.city,\n           new Street(\n               a.street.num,\n               R.toUpper(a.street.name)\n           )\n       )\n   )\n);\n```", "```js\ninterface Lens<T1, T2> {\n    get(o: T1): T2;\n    set(o: T2, v: T1): T1;\n}\n```", "```js\nconst streetLens: Lens<Address, Street> = {\n    get: (o: Address) => o.street,\n    set: (v: Street, o: Address) => new Address(o.city, v)\n};\n```", "```js\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst street = streetLens.get(address);\n```", "```js\nconst address2 = streetLens.set(\n    new Street(\n        address.street.num,\n        R.toUpper(address.street.name)\n    ),\n    address\n);\n```", "```js\nfunction composeLens<A, B, C>(\n    ab: Lens<A, B>,\n    bc: Lens<B, C>\n): Lens<A, C> {\n    return {\n        get: (a: A) => bc.get(ab.get(a)),\n        set: (c: C, a: A) => ab.set(bc.set(c, ab.get(a)), a)\n    };\n}\n```", "```js\nconst streetLens: Lens<Address, Street> = {\n    get: (o: Address) => o.street,\n    set: (v: Street, o: Address) => new Address(o.city, v)\n};\n\nconst nameLens: Lens<Street, string> = {\n    get: (o: Street) => o.name,\n    set: (v: string, o: Street) => new Street(o.num, v)\n};\n\nconst streetNameLens = composeLens(streetLens, nameLens);\n```", "```js\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst streetName = streetNameLens.get(address);\n```", "```js\nconst address2 = streetNameLens.set(R.toUpper(address.street.name), address);\n```", "```js\nfunction overLens<S, A>(\n    lens: Lens<S, A>,\n    func: (a: A) => A,\n    s: S\n): S {\n    return lens.set(func(lens.get(s)), s)\n}\n```", "```js\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst address2 = overLens(streetNameLens, R.toUpper, address);\n```", "```js\ntype Prop<T, K extends keyof T> = (o: T) => T[K];\ntype Assoc<T, K extends keyof T> = (v: T[K], o: T) => T;\n```", "```js\nconst propStreet: Prop<Address, \"street\"> = (o: Address) => o.street;\n\nconst assocStreet: Assoc<Address, \"street\"> = (v: Address[\"street\"], o: Address) => {\n    return new Address(o.city, v);\n};\n```", "```js\nconst lens = <T1, K extends keyof T1>(\n    getter: Prop<T1, K>,\n    setter: Assoc<T1, K>,\n): Lens<T1, T1[K]> => {\n    return {\n        get: (obj: T1) => getter(obj),\n        set: (val: T1[K], obj: T1) => setter(val, obj),\n    };\n}\n```", "```js\nconst streetLens = lens(propStreet, assocStreet);\n```", "```js\nconst view = <T1, T2>(lens: Lens<T1, T2>, obj: T1) => lens.get(obj);\n\nconst set = <T1, K extends keyof T1>(\n    lens: Lens<T1, T1[K]>,\n    val: T1[K],\n    obj: T1\n) => lens.set(val, obj);\n```", "```js\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst street = view(streetLens, address);\n```", "```js\nconst address2 = set(\n    streetLens,\n    new Street(\n        address.street.num,\n        R.toUpper(address.street.name)\n    ),\n    address\n);\n```", "```js\ntype Maybe<T> = T | null;\n\ninterface Prism<T1, T2> {\n    get(o: T1): Maybe<T2>,\n    set(a: T2, o: T1): T1;\n}\n```", "```js\nfunction composePrism<A, B, C>(ab: Prism<A, B>, bc: Prism<B, C>): Prism<A, C> {\n    return {\n        get: (a: A) => {\n            const b = ab.get(a)\n            return b == null ? null : bc.get(b)\n        },\n        set: (c: C, a: A) => {\n            const b = ab.get(a)\n            return b == null ? a : ab.set(bc.set(c, b), a)\n        }\n    }\n}\n```", "```js\nfunction overPrism<S, A>(\n    prism: Prism<S, A>,\n    func: (a: A) => A,\n    s: S\n): S {\n    const a = prism.get(s)\n    return a ? prism.set(func(a), s) : s\n}\n```", "```js\nconst firstCharacterPrism: Prism<string, string> = {\n    get: s => s ? s.substring(0, 1) : null,\n    set: (a, s) => s.length ? a + s.substring(1) : \"\"\n}\n\nconst streetPrism: Prism<Address, Street> = {\n    get: (o: Address) => o.street,\n    set: (v: Street, o: Address) => new Address(o.city, v)\n};\n\nconst namePrism: Prism<Street, string> = {\n    get: (o: Street) => o.name,\n    set: (v: string, o: Street) => new Street(o.num, v)\n};\n\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst streetNameFirstCharacterPrism = composePrism(\n    composePrism(streetPrism, namePrism),\n    firstCharacterPrism\n);\n\nconst address2 = overPrism(streetNameFirstCharacterPrism, R.toUpper, address);\n```", "```js\ntype Either<T1, T2> = T1 | T2;\n\ntype Domicile = Either<\n    { type: \"office\", address: Address },\n    { type: \"personal\", address: string }\n>;\n\nconst addressPrism: Prism<Domicile, Address> = {\n    get: d => d.type === \"office\" ? d.address : null,\n    set: (address, d) => d.type === \"office\" ? { type: \"office\", address } : d\n}\n```", "```js\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst domicile1: Domicile = { type: \"office\", address: address };\nconst domicile2: Domicile = { type: \"personal\", address: \"23 high street\" };\n\nconst address1 = addressPrism.get(domicile1);\nconst address2 = addressPrism.get(domicile2);\n```", "```js\ninterface Dog {\n   size: \"L\" | \"S\";\n   age: number;\n   name: string;\n}\n\nconst dogs: Dog[] = [\n   { size: \"S\", age: 4, name: \"Alice\" },\n   { size: \"L\", age: 2, name: \"Bob\", },\n   { size: \"S\", age: 7, name: \"Carol\" },\n   { size: \"L\", age: 6, name: \"Dan\" },\n   { size: \"L\", age: 2, name: \"Eve\" },\n   { size: \"S\", age: 2, name: \"Frank\" },\n   { size: \"S\", age: 1, name: \"Grant\" },\n   { size: \"S\", age: 9, name: \"Hans\" },\n   { size: \"L\", age: 8, name: \"Inga\" },\n   { size: \"L\", age: 4, name: \"Julia\" }\n];\n\nconst isLarge = (dog: Dog) => dog.size === \"L\";\nconst isOld = (dog: Dog) => dog.age > 5;\ndogs.filter(isLarge).find(isOld); // Dan\n```", "```js\nconst filter = <T>(f: (item: T) => boolean) => {\n   return function* (arr: T[]) {\n       for (const item of arr) {\n           if (f(item)) {\n               yield item;\n           }\n       }\n   };\n};\n\nconst find = <T>(f: (item: T) => boolean) =>(arr: IterableIterator<T>) => {\n   for (const item of arr) {\n       if (f(item)) {\n           return item;\n       }\n   }\n};\n```", "```js\nconst findLargeOldDog = R.compose(find(isOld), filter(isLarge));\nfindLargeOldDog(dogs);\n```"]