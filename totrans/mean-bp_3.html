<html><head></head><body>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Job Board</h1></div></div></div><p class="calibre8">In this chapter, we will build a job board application. Users will be able to create a profile and fill it with different types of <a id="id241" class="calibre1"/>information, such as job experience, projects they worked on, certifications, or even information related to education. Also, companies will be able to post job vacancies, for which users can apply.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec28" class="calibre1"/>Setting up the base application</h1></div></div></div><p class="calibre8">In many cases, most <a id="id242" class="calibre1"/>developers will have already set up their own boilerplate code that they use for Node applications. One reason for this could be that there is more than one right way of doing things. Usually, your boilerplate will cover the initial functionalities of your application, such as user schema, sign-in, and registration.</p><p class="calibre8">Because we already have a solid base from the initial two chapters, we can reuse a lot of the code base. I've already put together a simple base application that we can start with. Just follow these steps to clone the project:</p><div><ol class="orderedlist"><li class="listitem" value="1">Clone the <a id="id243" class="calibre1"/>project from GitHub at <a class="calibre1" href="https://github.com/robert52/express-api-starter">https://github.com/robert52/express-api-starter</a>.</li><li class="listitem" value="2">Rename your boilerplate project to <code class="email">jobboard</code>.</li><li class="listitem" value="3">If you want, you can stop pointing to the initial Git repository by running the following command:<div><pre class="programlisting">
<strong class="calibre2">git remote remove origin</strong>
</pre></div></li><li class="listitem" value="4">Jump to your working directory:<div><pre class="programlisting">
<strong class="calibre2">cd jobboard</strong>
</pre></div></li><li class="listitem" value="5">Install all dependencies:<div><pre class="programlisting">
<strong class="calibre2">npm install</strong>
</pre></div></li><li class="listitem" value="6">Create a development configuration file:<div><pre class="programlisting">
<strong class="calibre2">cp config/environments/example.js config/environments/development.js</strong>
</pre></div></li></ol><div></div><p class="calibre8">Your configuration <a id="id244" class="calibre1"/>file, <code class="email">jobboard/config/environments/development.js</code>, should look similar to the following:</p><div><pre class="programlisting">'use strict';

module.exports = {
  port: 3000,
  hostname: '127.0.0.1',
  baseUrl: 'http://localhost:3000',
  mongodb: {
    uri: 'mongodb://localhost/jobboard_dev_db'
  },
  app: {
    name: 'Job board'
  },
  serveStatic: true,
  session: {
    type: 'mongo',                          
    secret: 'someVeRyN1c3S#cr3tHer34U',
    resave: false,                          
    saveUninitialized: true                 
  }
};</pre></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Modifying the user backend</h1></div></div></div><p class="calibre8">The user backend <a id="id245" class="calibre1"/>logic needs to change a little to fit our <a id="id246" class="calibre1"/>needs. For example, we need roles for our users. We will detail this when we talk about the user model. We must add authorization policies. We also need a profile for our users.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec65" class="calibre1"/>Modifying the user model</h2></div></div></div><p class="calibre8">We need to make <a id="id247" class="calibre1"/>a few changes to the user model in order to support multiple account types and eventually assign roles to users. This will tell us whether the user is registered for a simple account, where they can define a profile with work experience, or to create a company that wants to post job opportunities.</p><p class="calibre8">The roles are going to define what actions the user can perform. For example, for a company we can have a company owner that has full control over the account, or we can have a user that is a member of that company and posts available job openings.</p><p class="calibre8">Let's modify the user schema from <code class="email">jobboard/app/models/user.js</code> with the following:</p><div><pre class="programlisting">var UserSchema = new Schema({
  email:  {
    type: String,
    required: true,
    unique: true
  },
  name: {
    type: String
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  passwordSalt: {
    type: String,
    required: true,
    select: false
  },
  active: {
    type: Boolean,
    default: true
  },
  roles: {
    type: [
      {
        type: String,
        enum: ['user', 'member', 'owner']
      }
    ],
    default: ['user']
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});</pre></div><p class="calibre8">We added an extra <a id="id248" class="calibre1"/>field to our user schema, more precisely <code class="email">roles</code>, which holds what the user can do. You can add any type of role to the list of valid roles defined by the enum validation.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec66" class="calibre1"/>An authorization policy</h2></div></div></div><p class="calibre8">In order to <a id="id249" class="calibre1"/>authorize our users to perform a requested action, we must check whether they can do it. For example, only a company owner can change the company information or add new members.</p><p class="calibre8">In the initial phase of a project, I like to keep my policies as simple and as separated as possible. In other words, I don't like to create something that manages everything, but instead use simple functions for my policies to check different scenarios. </p><p class="calibre8">Let's take a look at an authorization policy. Create a file called <code class="email">jobboard/app/middlewares/authorization.js</code> and add the following:</p><div><pre class="programlisting">module.exports.onlyMembers = authorizeOnlyToCompanyMembers;

function authorizeOnlyToCompanyMembers(req, res, next) {
  // check if user is member of company
  const isMember = req.resources.company.members.find((member) =&gt; {
    return member.toString() === req.user._id.toString();
  });

  if (!isMember) {
    return res.status(403).json({ message: 'Unauthorized' });
  }

  next();
}</pre></div><p class="calibre8">This simple function will check whether the owner of a company is the authenticated user. The preceding policy can be used in the following way:</p><div><pre class="programlisting">router.put(
  '/companies/:companyId',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyOwner,
  companyCtrl.update,
  response.toJSON('company')
);</pre></div><p class="calibre8">The preceding code ensures that a user is authenticated, grabs a company by ID from MongoDB, and checks whether the policy that we implemented earlier authorizes the user to update the company or not.</p></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>The company backend module</h1></div></div></div><p class="calibre8">We are going to <a id="id250" class="calibre1"/>implement our first backend module <a id="id251" class="calibre1"/>for our application. This module will handle everything that is related to a company.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec67" class="calibre1"/>The company model</h2></div></div></div><p class="calibre8">We are going to <a id="id252" class="calibre1"/>add a simple but interesting functionality to the company model, which will create a so-called slug from the company name. A <code class="email">slug</code>, in our context, is generated from the name of the company to be accepted as a valid URL. It will be used to reference the company in a meaningful way. For example, if we have a company named <code class="email">Your Awesome Company</code> in the system, the resulting slug will be <code class="email">your-awesome-company</code>.</p><p class="calibre8">To generate the slug, we'll implement a simple helper function so that we can reuse it later if necessary. Create a file called <code class="email">app/helpers/common.js</code> and add the following lines of code:</p><div><pre class="programlisting">'use strict';

module.exports.createSlug = createSlug;

function createSlug(value) {
   return value
   .toLowerCase()
   .replace(/[^\w\s]+/g,'')
   .trim()
   .replace(/[\s]+/g,'-');
}</pre></div><p class="calibre8">Now that we have the <code class="email">helper</code> function, we can define the <code class="email">company</code> model and the necessary schema for it. Create a file called <code class="email">app/models/company.js</code> and add the following code to it:</p><div><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const commonHelper = require('../helpers/common');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

let CompanySchema = new Schema({
  name: {
    type: String,
    required: true
  },
  slug: {
    type: String
  },
  owner: {
    type: ObjectId,
    required: true,
    ref: 'User'
  },
  members: {
    type: Array,
    default: []
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

CompanySchema.pre('save', (next) =&gt; {
  this.slug = commonHelper.createSlug(this.name);
  next();
});

// compile Company model
module.exports = mongoose.model('Company', CompanySchema);</pre></div><p class="calibre8">We defined the <a id="id253" class="calibre1"/>company's mongoose schema and added a pre-save hook in order to generate the slug. In this pre-save hook, we are using the <code class="email">createSlug()</code> method from the common helper. The middleware is running in series, so we need to call <code class="email">next()</code> in order to signal the completion of the execution.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec68" class="calibre1"/>The company controller</h2></div></div></div><p class="calibre8">Through <a id="id254" class="calibre1"/>the company controller, we are going to expose all of the business logic needed to manage companies. We are going to take the functionalities one by one and discuss them all.</p><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec29" class="calibre1"/>Creating a company</h3></div></div></div><p class="calibre8">After a user <a id="id255" class="calibre1"/>has successfully registered with a company type account, they can create a new company and become the owner. We'll implement a simple create functionality and mount it on an Express route. Let's create the controller file, called <code class="email">jobboard/app/controllers/company.js</code>, with the following content:</p><div><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const Company = mongoose.model('Company');

module.exports.create = createCompany;

function createCompany(req, res, next) {
  let data = _.pick(req.body, ['name', 'country', 'address']);
  data.owner = req.user._id;
  data.members = [req.user._id];
  
  Company.create(data, (err, company) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(company);
  });
}</pre></div><p class="calibre8">Validation was added to the company model when we defined the schema. One thing we added is <a id="id256" class="calibre1"/>picking the necessary data for the create method. The owner of the company will by default be the user who creates it. Also, we add the user to the members list. After we have successfully created a new company, we return a JSON containing the information related to the freshly created company.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec30" class="calibre1"/>Getting a company by ID</h3></div></div></div><p class="calibre8">Now <a id="id257" class="calibre1"/>that we can create a company, it's time to retrieve one by ID. We'll append the following code to the <code class="email">app/controller/company.js</code> controller file:</p><div><pre class="programlisting">module.exports.findById = findCompanyById;

function findCompanyById(req, res, next) {
  if (!ObjectId.isValid(id)) {
    res.status(404).send({ message: 'Not found.'});
  }

  Company.findById(req.params.companyId, (err, company) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.company = company;
    next();
  });
}</pre></div><p class="calibre8">In the preceding lines of code, we used the <code class="email">findById</code> method provided by mongoose from the company model. Before we search for a company in MongoDB, we want to ensure that the ID is a valid <code class="email">ObjectId</code>.</p><p class="calibre8">Another <a id="id258" class="calibre1"/>interesting thing we added here is a global <code class="email">resource</code> object on the request. Instead of returning a JSON this time, we add it as a property to an object that we'll carry on the callback pipe of an Express route. This will come in handy when we want to reuse the same functionality in other situations.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec31" class="calibre1"/>Getting all companies</h3></div></div></div><p class="calibre8">We <a id="id259" class="calibre1"/>also want to get all the companies stored in MongoDB. A simple query should be enough for this use case. We can add a simple filter by country and, by default, return up to 50 companies. The following code will implement this functionality:</p><div><pre class="programlisting">module.exports.getAll = getAllCompanies;

function getAllCompanies(req, res, next) {
  const limit = +req.query.limit || 50;
  const skip = +req.query.skip || 0;
  let query = _.pick(req.query, ['country']);

  Company
  .find(query)
  .limit(limit)
  .skip(skip)
  .exec((err, companies) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.companies = companies;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec32" class="calibre1"/>Updating a company</h3></div></div></div><p class="calibre8">When <a id="id260" class="calibre1"/>updating a company, we only want some of the fields to be updated from the company model. We don't want to change the owner or add new members when updating a company. The change owner functionality will not be implemented; only add new member functionality will be, but it will be handled by a different module.</p><p class="calibre8">Append the following lines of code to <code class="email">jobboard/app/controllers/company.js</code>:</p><div><pre class="programlisting">module.exports.update = updateCompany;

function updateCompany(req, res, next) {
  let data = _.pick(req.body, ['name', 'country', 'address']);
  _.assign(req.resources.company, req.body);

  req.resources.company.save((err, updatedCompany) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.company = updatedCompany;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec33" class="calibre1"/>Adding a company member</h3></div></div></div><p class="calibre8">A <a id="id261" class="calibre1"/>company member will have limited access to the company. They can post vacant positions and screen profiles of users who applied for an available position. We are going to add this functionality to the same company controller, located at <code class="email">jobboard/app/controllers/company.js</code>:</p><div><pre class="programlisting">module.exports.addMember = addCompanyMember;

function addCompanyMember(req, res, next) {
  let includes = _.includes(req.resources.company.members, req.body.member);

  if (includes) {
    return res.status(409).json({
      message: 'User is already a member of your company',
      type: 'already_member'
    });
  }

  req.resources.company.members.push(req.body.member);
  req.resources.company.save((err, updatedCompany) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.company = updatedCompany;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec34" class="calibre1"/>Removing a company member</h3></div></div></div><p class="calibre8">We also need <a id="id262" class="calibre1"/>to handle how we remove members from a company. We'll append this functionality after the add member logic:</p><div><pre class="programlisting">module.exports.removeMember = removeCompanyMember;

function removeCompanyMember(req, res, next) {
  let includes = _.includes(req.resources.company.members, req.body.member);

  if (!includes) {
    return res.status(409).json({
      message: 'User is not a member of your company',
      type: 'not_member'
    });
  }

  _.pull(req.resources.company.members, req.body.member);
  req.resources.company.save((err, updatedCompany) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.company = updatedCompany;
    next();
  });
}</pre></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec69" class="calibre1"/>Company routes</h2></div></div></div><p class="calibre8">Next, we are <a id="id263" class="calibre1"/>going to define all the necessary routes to access the previously implemented functionalities from the company controller. Let's create our router file, called <code class="email">jobboard/app/routes/companies.js</code>, and add the following:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const companyCtrl = require('../controllers/company');
const auth = require('../middlewares/authentication');
const authorize = require('../middlewares/authorization');
const response = require('../helpers/response');</pre></div><p class="calibre8">Follow these <a id="id264" class="calibre1"/>steps to define the endpoints:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a company:<div><pre class="programlisting">router.post(
  '/companies',
  auth.ensured,
  companyCtrl.checkUserCompany,
  companyCtrl.create
);</pre></div><p class="calibre22">We make sure that the user has no company already in the system.</p></li><li class="listitem" value="2">Get all companies:<div><pre class="programlisting">router.get(
  '/companies',
  companyCtrl.getAll,
  response.toJSON('companies')
);</pre></div></li><li class="listitem" value="3">Get a company by ID:<div><pre class="programlisting">router.get(
  '/companies/:companyId',
  companyCtrl.findById,
  response.toJSON('company')
);</pre></div></li><li class="listitem" value="4">Update a company:<div><pre class="programlisting">router.put(
  '/companies/:companyId',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyOwner,
  companyCtrl.update,
  response.toJSON('company')
);</pre></div><p class="calibre22">Updates to the company can only be made by the owner.</p></li><li class="listitem" value="5">Add company members:<div><pre class="programlisting">router.post(
  '/companies/:companyId/members',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyOwner,
  companyCtrl.addMember,
  response.toJSON('company')
);</pre></div><p class="calibre22">Only the owner of the company can add a member.</p></li><li class="listitem" value="6">Remove a <a id="id265" class="calibre1"/>company member:<div><pre class="programlisting">router.delete(
  '/companies/:companyId/members',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyOwner,
  companyCtrl.removeMember,
  response.toJSON('company')
);</pre></div><p class="calibre22">We are also restricting this action to only the company's owner.</p></li><li class="listitem" value="7">Export the router:<div><pre class="programlisting">module.exports = router;</pre></div></li></ol><div></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec31" class="calibre1"/>The job backend module</h1></div></div></div><p class="calibre8">This module <a id="id266" class="calibre1"/>will implement all of the backend logic <a id="id267" class="calibre1"/>related to jobs. We are going to define the necessary models and controllers. Only the most important parts of the module will be explained.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec70" class="calibre1"/>The job model</h2></div></div></div><p class="calibre8">The job model will <a id="id268" class="calibre1"/>define a single entity from the <code class="email">Jobs</code> collection and is going to handle the necessary validation when creating a new job. As for the company model, we are going to use a custom variable file for job industries and types. The two files will be located at <code class="email">jobboard/config/variables/industries.js</code> and <code class="email">jobboard/config/variables/jobtypes.js</code>, respectively. Both export a list of objects.</p><p class="calibre8">In order to <a id="id269" class="calibre1"/>implement the <code class="email">job</code> model, we are going to follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create the model file, called <code class="email">jobboard/app/models/job.js</code>.</li><li class="listitem" value="2">Add the necessary dependencies:<div><pre class="programlisting">const mongoose = require('mongoose');
const commonHelper = require('../helpers/common');
const Industries = require('../../config/variables/industries');
const Countries = require('../../config/variables/countries');
const Jobtypes = require('../../config/variables/jobtypes');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;</pre></div></li><li class="listitem" value="3">Retrieve only a list of validation values from the variable files:<div><pre class="programlisting">const indEnum = Industries.map(item =&gt; item.slug);
const cntEnum = Countries.map(item =&gt; item.code);
const jobEnum = Jobtypes.map(item =&gt; item.slug);</pre></div></li><li class="listitem" value="4">Define the Mongoose schema:<div><pre class="programlisting">let JobSchema = new Schema({
  title: {
    type: String,
    required: true
  },
  slug: {
    type: String,
    required: true
  },
  summary: {
    type: String,
    maxlength: 250
  },
  description: {
    type: String
  },
  type: {
    type: String,
    required: true,
    enum: jobEnum
  },
  company: {
    type: ObjectId,
    required: true,
    ref: 'Company'
  },
  industry: {
    type: String,
    required: true,
    enum: indEnum
  },
  country: {
    type: String,
    required: true,
    enum: cntEnum
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});</pre></div></li><li class="listitem" value="5">Add a pre-save hook:<div><pre class="programlisting">JobSchema.pre('save', (next) =&gt; {
  this.slug = commonHelper.createSlug(this.name);
  next();
});</pre></div></li><li class="listitem" value="6">And finally <a id="id270" class="calibre1"/>compile the model:<div><pre class="programlisting">module.exports = mongoose.model('Job', JobSchema);	</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec71" class="calibre1"/>Job controller</h2></div></div></div><p class="calibre8">Our controller will integrate all the necessary business logic to handle all job CRUD operations. Afterwards, we can mount the exposed methods from the controller on specific routes, so that external clients can communicate with our backend.</p><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec35" class="calibre1"/>Adding a new job for a company</h3></div></div></div><p class="calibre8">When creating a new <a id="id271" class="calibre1"/>job, it <a id="id272" class="calibre1"/>should be created for a specific company, because a job represents a vacant position at a company. Because of this, we are going to need the company context when creating a job.</p><p class="calibre8">Create a controller file called <code class="email">jobboard/app/controllers/job.js</code> and add the following create logic:</p><div><pre class="programlisting">const MAX_LIMIT = 50;
const JOB_FIELDS = ['title', 'summary', 'description', 'type', 'industry', 'country'];

const _ = require('lodash');
const mongoose = require('mongoose');
const Job = mongoose.model('Job');
const ObjectId = mongoose.Types.ObjectId;

module.exports.create = createJob;

function createJob(req, res, next) {
  let data = _.pick(req.body, JOB_FIELDS);
  data.company = req.company._id;

  Job.create(data, (err, job) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(job);
  });
}</pre></div><p class="calibre8">As we said <a id="id273" class="calibre1"/>earlier, we need the company context to which we add the job. For that, we are going to add a get company by ID to our Express router request pipe. Don't worry; you 'll see this when we define our routes.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec36" class="calibre1"/>Finding a job by ID</h3></div></div></div><p class="calibre8">We should <a id="id274" class="calibre1"/>also retrieve a job by ID from Mongo. A similar logic will be used here as was used in the company controller. Append the following code to the job controller:</p><div><pre class="programlisting">module.exports.findById = findJobById;

function findJobById(req, res, next) {
  if (!ObjectId.isValid(id)) {
    res.status(404).send({ message: 'Not found.'});
  }

  Job.findById(req.params.jobId, (err, job) =&gt; {
    if (err) {
      return next(err);
    }

    res.resources.job = job;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec37" class="calibre1"/>Getting all jobs</h3></div></div></div><p class="calibre8">When retrieving <a id="id275" class="calibre1"/>all available jobs, there should be the possibility to apply some filters, such as type of job, to which industry it is assigned, or the country where the job is available. Beside these filters, we also need to get all available opening positions in a company. All of this logic will be implemented using the following code:</p><div><pre class="programlisting">module.exports.getAll = getAllJobs;

function getAllJobs(req, res, next) {
  const limit = +req.query.limit || MAX_LIMIT;
  const skip = +req.query.skip || 0;
  let query = _.pick(req.query, ['type', 'country', 'industry']);

  if (req.params.companyId) {
    query.company = req.params.companyId;
  }

  Job
  .find(query)
  .limit(limit)
  .skip(skip)
  .exec((err, jobs) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.jobs = jobs;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec38" class="calibre1"/>Updating a specific job</h3></div></div></div><p class="calibre8">We also <a id="id276" class="calibre1"/>want to update a job posted by a company, but only by the company members. This restriction will be handled by middleware; for now, we are only going to implement the update functionality. Append the following code to <code class="email">app/controllers/job.js</code>:</p><div><pre class="programlisting">module.exports.update = updateJob;
function updateJob(req, res, next) {
  var data = _.pick(req.body, JOB_FIELDS);
  _.assign(req.resources.job, data);

  req.resources.job.save((err, updatedJob) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(job);
  });
}</pre></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec72" class="calibre1"/>Job routes</h2></div></div></div><p class="calibre8">For a start, we are <a id="id277" class="calibre1"/>going to create the route file, called <code class="email">app/routes/jobs.js</code>, with the following code:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const companyCtrl = require('../controllers/company');
const jobCtrl = require('../controllers/job');
const auth = require('../middlewares/authentication');
const authorize = require('../middlewares/authorization');
const response = require('../helpers/response');</pre></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec39" class="calibre1"/>Getting one and all jobs</h3></div></div></div><p class="calibre8">Now that we <a id="id278" class="calibre1"/>have the base, we can start defining our routes. The first pair of routes will be available for public access, so no authentication is required to retrieve one or all jobs from the system. Append the following code:</p><div><pre class="programlisting">router.get(
  '/jobs',
  jobCtrl.getAll,
  response.toJSON('jobs')
);

router.get(
  '/jobs/:jobId',
  jobCtrl.findById,
  response.toJSON('job')
);</pre></div><p class="calibre8">Bonus—getting the jobs of a certain company!</p><div><pre class="programlisting">router.get(
  '/companies/:companyId/jobs',
  jobCtrl.getAll,
  response.toJSON('jobs')
);</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec40" class="calibre1"/>Creating a route</h3></div></div></div><p class="calibre8">Now, things <a id="id279" class="calibre1"/>get a little tricky when creating and updating a job. To create a job, append the following code:</p><div><pre class="programlisting">router.post(
  '/companies/:companyId/jobs',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyMembers,
  jobCtrl.create
);</pre></div><p class="calibre8">When creating a job, a user must be signed in and must be a member of the company under which he/she is posting the job. For this, we are retrieving a company from the database and using an authorization middleware. We compare and check whether the authenticated user is present in the members list. If everything goes well, the user can create a new job opening.</p><p class="calibre8">There are probably other ways to do all of this, but this solution can be beneficial because we request resources only when we need them. For example, we could have added the company object on the <code class="email">req.user</code> object for each request if the user is authenticated, but that would have meant extra I/O for each request.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec41" class="calibre1"/>Updating a route</h3></div></div></div><p class="calibre8">For the update <a id="id280" class="calibre1"/>functionality, append the following code:</p><div><pre class="programlisting">router.put(
  '/companies/:companyId/jobs/:jobId',
  auth.ensured,
  companyCtrl.findById,
  authorize.onlyMembers,
  jobCtrl.findById,
  jobCtrl.update
);</pre></div><p class="calibre8">As you can see, the same restriction principles are present here as for the create route. The only extra thing that we added is retrieving a job by ID, which is needed by the update functionality.</p><p class="calibre8">With this, we <a id="id281" class="calibre1"/>have finished implementing the backend logic for the <code class="email">job</code> module.</p></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec32" class="calibre1"/>Job applications</h1></div></div></div><p class="calibre8">Each user can apply for <a id="id282" class="calibre1"/>a job, and a company would also <a id="id283" class="calibre1"/>like to know who has applied to their available job position. To handle such scenarios, we are going to store all applications for a job in a separate collection in MongoDB. We are going to describe the backend Node.js application logic.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec73" class="calibre1"/>The application model</h2></div></div></div><p class="calibre8">The application model <a id="id284" class="calibre1"/>will be pretty simple and straightforward. We could have gone with an embedded data model. In other words, we could have saved all applications in the job entity. From my point of view, separate collections gives you more flexibility.</p><p class="calibre8">Let's create a file called <code class="email">app/models/application.js</code> and add the following code to define the schema:</p><div><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

let ApplicationSchema = new Schema({
  user: {
    type: ObjectId,
    required: true,
    ref: 'User'
  },
  status: {
    type: String,
    default: 'pending',
    enum: ['pending', 'accepted', 'processed']
  },
  job: {
    type: ObjectId,
    required: true,
    ref: 'Job'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Application', ApplicationSchema);</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec74" class="calibre1"/>Controller logic</h2></div></div></div><p class="calibre8">The backend controller <a id="id285" class="calibre1"/>will handle all of the logic that is necessary to manage incoming requests on endpoints related to job applications. We will mount each exported method from the controller to a specific route.</p><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec42" class="calibre1"/>Applying for a job</h3></div></div></div><p class="calibre8">When a candidate <a id="id286" class="calibre1"/>applies for a job, we store a reference of that application in MongoDB. We defined the <code class="email">Application</code> schema earlier. To persist an application, we are going to use the following backend logic in our <code class="email">app/controllers/application.js</code> controller file:</p><div><pre class="programlisting">module.exports.create = createApplication;

function createApplication(req, res, next) {
  Application.create({
    user: req.user._id,
    job: req.params.jobId
  }, (err, application) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(application);
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec43" class="calibre1"/>Finding a given application by ID</h3></div></div></div><p class="calibre8">We will need <a id="id287" class="calibre1"/>to find an application by its ID when updating and deleting it from the database. It's good to have a common logic to retrieve data; it can be reused in different scenarios. Append this code to the controller file:</p><div><pre class="programlisting">module.exports.findById = findApplicationById;

function findApplicationById(req, res, next) {
  if (!ObjectId.isValid(id)) {
    res.status(404).send({ message: 'Not found.'});
  }

  Application.findById(req.params.applicationId, (err, application) =&gt; {
    if (err) {
      return next(err);
    }

    res.resources.application = application;
    next();
  });
}</pre></div><p class="calibre8">Once again, we <a id="id288" class="calibre1"/>are using the <code class="email">resource</code> property on the request object to populate it with the result from the query.</p></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec44" class="calibre1"/>Getting all job applications</h3></div></div></div><p class="calibre8">Each company will <a id="id289" class="calibre1"/>want to see all the applications for the jobs they listed. In order to provide that functionality, the job controller must return a list of applications, with the ability to filter them by status. The following code will implement this functionality:</p><div><pre class="programlisting">module.exports.getAll = getAllApplications;

function getAllApplications(req, res, next) {
  const limit = +req.query.limit || 50;
  const skip = +req.query.skip || 0;
  let query = {
    job: req.params.jobId
  };

  if (req.query.status) {
    query.status = req.query.status;
  }

  Application
  .find(query)
  .limit(limit)
  .skip(offset)
  .exec((err, applications) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.applications = applications;
    next();
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec45" class="calibre1"/>Updating an application</h3></div></div></div><p class="calibre8">In order to change the <a id="id290" class="calibre1"/>status of an application, we must update it with the specific status value. The <code class="email">update</code> method from the controller will handle this use case. Append the update logic to the controller file:</p><div><pre class="programlisting">module.exports.update = updateApplication;

function updateApplication(req, res, next) {
  req.resources.application.status = req.body.status;

  req.resources.application.save((err, updatedApplication) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(updatedApplication);
  });
}</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch03lvl3sec46" class="calibre1"/>Removing an application from a job</h3></div></div></div><p class="calibre8">A candidate <a id="id291" class="calibre1"/>should have the ability to remove an application for a vacant job. We will not let anybody else remove the application except the candidate. This restriction will be handled by middleware. The backend logic for deletion should look similar to this:</p><div><pre class="programlisting">module.exports.remove = removeApplication;

function removeApplication(req, res, next) {
  req.resources.application.remove((err) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(req.resources.application);
  });
}</pre></div><p class="calibre8">Now, we are not going to talk about how to add the routes. You can find all the available routes in the final source code of the application.</p></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec33" class="calibre1"/>Creating a new company</h1></div></div></div><p class="calibre8">After a successful <a id="id292" class="calibre1"/>sign-up, a new company can be <a id="id293" class="calibre1"/>created by the user. We have already implemented the backend logic using Node.js, and we should be able to store the company in the companies collection in MongoDB.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec75" class="calibre1"/>The company service</h2></div></div></div><p class="calibre8">Although we are <a id="id294" class="calibre1"/>discussing the create company functionality, we are going to add all the endpoints to the service:</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's create the service file, called <code class="email">jobboard/public/src/company/company.service.ts</code>.</li><li class="listitem" value="2">Import the necessary dependencies:<div><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { AuthHttp } from '../auth/index';
import { contentHeaders } from '../common/index';
import { Company } from './company.model';</pre></div></li><li class="listitem" value="3">Create the <code class="email">service</code> class:<div><pre class="programlisting">@Injectable()
export class CompanyService {
  private _http: Http;
  private _authHttp: AuthHttp;
}</pre></div></li><li class="listitem" value="4">Add the <code class="email">constructor</code>:<div><pre class="programlisting">  constructor(http: Http, authHttp: AuthHttp) {
    this._http = http;
    this._authHttp = authHttp;
  }</pre></div></li><li class="listitem" value="5">Append the <code class="email">create</code> method:<div><pre class="programlisting">  create(company) {
    let body = JSON.stringify(company);

    return this._authHttp
    .post('/api/companies', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())  
  }</pre></div></li><li class="listitem" value="6">Define the <code class="email">findByid()</code> function:<div><pre class="programlisting">  findById(id) {
    return this._http
    .get(`/api/companies/${id}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li><li class="listitem" value="7">Retrieve all companies from the backend:<div><pre class="programlisting">  getAll() {
    return this._http
    .get('/api/companies', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li><li class="listitem" value="8">Update a <a id="id295" class="calibre1"/>company:<div><pre class="programlisting"> update(company) {
    let body = JSON.stringify(company);

    return this._authHttp
    .put(`/api/companies/${company._id}`, body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec76" class="calibre1"/>Creating a company component</h2></div></div></div><p class="calibre8">Now that we have a <a id="id296" class="calibre1"/>fully functioning service that communicates with the backend, we can start implementing our components. The create company component will be the first one.</p><p class="calibre8">Let's create a new file, called <code class="email">public/src/company/components/company-create.component.ts</code>, and add the component's class and dependencies:</p><div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { CompanyService } from '../company.service';
import { Company } from '../company.model';
export class CompanyCreateComponent implements OnInit {
  public company: Company;
  private _router: Router;
  private _companyService: CompanyService;

  constructor(companyService: CompanyService, router: Router) {
    this._router = router;
    this._companyService = companyService;
  }

  ngOnInit() {
    this.company = new Company();
  }
}</pre></div><p class="calibre8">The <a id="id297" class="calibre1"/><code class="email">Component</code> annotation should be similar to this:</p><div><pre class="programlisting">@Component({
    selector: 'company-create',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="login jumbotron center-block"&gt;
        &lt;h1&gt;Register&lt;/h1&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;form role="form" (submit)="onSubmit($event)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="name"&gt;Company name&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="company.name" class="form-control" id="name"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="email"&gt;Country&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="company.country" class="form-control" id="country"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="email"&gt;Address&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="company.address" class="form-control" id="address"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="password"&gt;Summary&lt;/label&gt;
            &lt;textarea [(ngModel)]="company.summary" class="form-control" id="summary"&gt;&lt;/textarea&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre8">To bind the company data properties to each form input control, we used the <code class="email">ngModel</code> two-way data binding. When submitting the form, the <code class="email">onSubmit()</code> method is executed. Let's add the preceding method:</p><div><pre class="programlisting">  onSubmit(event) {
    event.preventDefault();

    this._companyService
    .create(this.company)
    .subscribe((company) =&gt; {
      if (company) {
        this.goToCompany(company._id, company.slug);
      }
    }, err =&gt; console.error(err));
  }</pre></div><p class="calibre8">This will try to create a new company through our service. If a company is successfully created, we <a id="id298" class="calibre1"/>navigate to the company details page. The <code class="email">goToCompany()</code> method is described as follows:</p><div><pre class="programlisting">  goToCompany(id, slug) {
    this._router.navigate(['CompanyDetail', { id: id, slug: slug}]);
  }</pre></div><p class="calibre8">We use the router to navigate to the company's details. The router will construct the desired path needed for the navigation. Error handling is not covered. You can also add validation as an improvement.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec34" class="calibre1"/>Displaying companies</h1></div></div></div><p class="calibre8">We have had a <a id="id299" class="calibre1"/>good start for the company module from earlier, when we implemented the "add new company" functionality. So, we can jump in and create and implement the rest of the files to display all companies.</p><p class="calibre8">In order to display a list of companies in our application, we create a new component file, called <code class="email">public/src/company/components/company-list.component.ts</code>:</p><div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { CompanyService } from '../company.service';
import { Company } from '../company.model';

@Component({})
export class CompanyListComponent implements OnInit {
  public companies: Array&lt;Company&gt;;
  private _router: Router;
  private _companyService: CompanyService;

  constructor(companyService: CompanyService, router: Router) {
    this._router = router;
    this._companyService = companyService;
  }

  ngOnInit() {
    this._companyService
    .getAll()
    .subscribe((companies) =&gt; {
      this.companies = companies;
    });
  }
}</pre></div><p class="calibre8">As you can see, we have a pretty basic component. On initialization, the companies are retrieved from the backend using <code class="email">CompanyService</code>. We subscribed directly to the returned <code class="email">Observable</code> to update the component's <code class="email">companies</code> property.</p><p class="calibre8">Now all that is left <a id="id300" class="calibre1"/>is to add the <code class="email">Component</code> annotation:</p><div><pre class="programlisting">@Component({
    selector: 'company-list',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="jumbotron center-block"&gt;
        &lt;h2&gt;Companies list&lt;/h2&gt;
        &lt;p class="lead"&gt;Here you can find all the registered companies.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div&gt;
      &lt;div *ngFor="#company of companies" class="col col-25"&gt;
        &lt;img src="img/208x140?text=product+image&amp;txtsize=18"/&gt;
        &lt;h3&gt;
          &lt;a href="#"
            [routerLink]="['CompanyDetail', { id: company._id, slug: company.slug }]"&gt;
            {{ company.name }}
          &lt;/a&gt;
          &lt;/h3&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre8">Using <code class="email">ngFor</code>, we iterate over the companies data and display it accordingly. You can display additional <a id="id301" class="calibre1"/>data, but for now, the company name should be enough. Also, when clicking on the name, we use <code class="email">RouterLink</code> to navigate to the desired company.</p></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec35" class="calibre1"/>The job module</h1></div></div></div><p class="calibre8">We are going to continue <a id="id302" class="calibre1"/>with the <code class="email">job</code> module. The reason for this is that the <code class="email">company</code> module uses a component from the <code class="email">job</code> module in order to display a list of available jobs for a company.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec77" class="calibre1"/>The job service</h2></div></div></div><p class="calibre8">The job service will <a id="id303" class="calibre1"/>handle communication with the backend, mostly for CRUD operations. We are going to create an Angular factory to accomplish this. Create a new file called <code class="email">public/app/job/job.service.js</code> and follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Define the base structure and exposed methods:<div><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { AuthHttp } from '../auth/index';
import { contentHeaders, serializeQuery } from '../common/index';
import { Job } from './job.model';

@Injectable()
export class JobService {
  private _http: Http;
  private _authHttp: AuthHttp;

  constructor(http: Http, authHttp: AuthHttp) {
    this._http = http;
    this._authHttp = authHttp;
  }
}</pre></div></li><li class="listitem" value="2">Implement the <code class="email">create job</code> method:<div><pre class="programlisting">  create(job) {
    let body = JSON.stringify(job);

    return this._authHttp
    .post('/api/jobs', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div><p class="calibre22">We are using the <code class="email">AuthHttp</code> service because creating endpoints requires an authenticated user.</p></li><li class="listitem" value="3">Add the <a id="id304" class="calibre1"/>code for finding a job by ID:<div><pre class="programlisting">  findById(id) {
    return this._http
    .get(`/api/jobs/${id}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li><li class="listitem" value="4">Query all jobs from the backend:<div><pre class="programlisting">  getAll(criteria) {
    let query = '';
    let str = serializeQuery(criteria);

    if (str) {
      query = `?${str}`;
    }

    return this._http
    .get(`/api/jobs${query}`, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
  }</pre></div></li></ol><div></div><p class="calibre8">The <code class="email">getAll()</code> method accepts a criteria as a parameter to filter the jobs. On some occasions, we only want to get a list of jobs for a given company. We construct our query strings using the <code class="email">serializeQuery</code> function, which can be found under <code class="email">public/src/common/query.ts</code> with the following content:</p><div><pre class="programlisting">export function serializeQuery(query): string {
  var chunks = [];
  for(var key in query)
    if (query.hasOwnProperty(key)) {
      let k = encodeURIComponent(key);
      let v = encodeURIComponent(query[key]);
      chunks.push(`${k}=${v}`);
    }
  return chunks.join('&amp;');
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec78" class="calibre1"/>The job base component</h2></div></div></div><p class="calibre8">We are going <a id="id305" class="calibre1"/>to build a base component for our <code class="email">job</code> module. It will hold all the necessary <code class="email">RouteConfig</code> to display the child components. Create a new file, called <code class="email">public/src/job/components/job-base.component.ts</code>:</p><div><pre class="programlisting">import { Component } from 'angular2/core';
import { RouterOutlet, RouteConfig } from 'angular2/router';
import { JobService } from '../job.service';
import { JobListComponent } from './job-list.component';
import { JobDetailComponent } from './job-detail.component';
import { JobCreateComponent } from './job-create.component';

@RouteConfig([
  { path: '/', as: 'JobList', component: JobListComponent, useAsDefault: true },
  { path: '/:id/:slug', as: 'JobDetail', component: JobDetailComponent },
  { path: '/create', as: 'JobCreate', component: JobCreateComponent }
])
@Component({
    selector: 'job-base',
    directives: [
      RouterOutlet
    ],
    template: `
      &lt;router-outlet&gt;&lt;/router-outlet&gt;
    `
})
export class JobBaseComponent {
  constructor() {}
} </pre></div><p class="calibre8">We mounted each child component to a specific path. We are going to use the same URL structure for <code class="email">JobDetail</code> as for <code class="email">CompanyDetail</code>. I think it has a nice, clean look and feel with the use of the slug in the URL.</p><p class="calibre8">Next, we are going to define the components one by one.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec79" class="calibre1"/>The jobs component</h2></div></div></div><p class="calibre8">The <code class="email">jobs</code> component will be reused across the application. Its purpose will be to display a list of jobs based on a few factors.</p><p class="calibre8">Create a file called <code class="email">public/src/job/components/jobs.component.ts</code> with the following content:</p><div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { JobService } from '../job.service';
import { Job } from '../job.model'; 

export class JobsComponent implements OnInit {
  public company: any;
  public jobs: Array&lt;Job&gt;;
  private _jobsService: JobService;
  private _router: Router;

  constructor(jobsService: JobService, router: Router) {
    this._router = router;
    this._jobsService = jobsService;
  }
}</pre></div><p class="calibre8">Add the <code class="email">ngOnInit</code> <a id="id306" class="calibre1"/>method to retrieve the necessary data from the Express application, as follows:</p><div><pre class="programlisting">  ngOnInit() {
    let query: any = {};

    if (this.company) {
      query.company = this.company;
    }

    this._jobsService
    .getAll(query)
    .subscribe((jobs) =&gt; {
      this.jobs = jobs;
    });
  }</pre></div><p class="calibre8">Our component has a <code class="email">company</code> property, which will be used when we want to query all jobs related to a company. Also, don't forget to add the following annotation:</p><div><pre class="programlisting">@Component({
    selector: 'jobs',
    inputs: ['company'],
    directives: [RouterLink],
    template: `
      &lt;div *ngFor="#job of jobs" class="col"&gt;
        &lt;h3&gt;
          &lt;a href="#"
            [routerLink]="['/Jobs', 'JobDetail', { id: job._id, slug: job.slug }]"&gt;
            {{ job.title }}
          &lt;/a&gt;
        &lt;/h3&gt;
        &lt;p&gt;
          &lt;a href="#"
            [routerLink]="['/Companies', 'CompanyDetail', { id: job.company._id, slug: job.company.slug }]"&gt;
            {{ job.company.name }}
          &lt;/a&gt;
          &lt;span&gt;·&lt;/span&gt;
          &lt;span&gt;{{ job.industry }}&lt;/span&gt;
          &lt;span&gt;·&lt;/span&gt;
          &lt;span&gt;{{ job.type }}&lt;/span&gt;
          &lt;span&gt;·&lt;/span&gt;
          &lt;span&gt;{{ job.createdAt }}&lt;/span&gt;
        &lt;/p&gt;
        &lt;p&gt;{{ job.summary }}&lt;/p&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre8">Our component <a id="id307" class="calibre1"/>also has an input data bound property called <code class="email">company</code>. This will reference a company's ID. Also create a link to the company's page.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec80" class="calibre1"/>The job list component</h2></div></div></div><p class="calibre8">In this component, we <a id="id308" class="calibre1"/>can use the previously built <code class="email">jobs</code> component in order to list all the available openings from the system. As all of the main logic can be found in the <code class="email">jobs</code> component, we just need to include it.</p><p class="calibre8">Create a new file called <code class="email">public/src/job/componets/job-list.component.ts</code> and add this code:</p><div><pre class="programlisting">import { Component } from 'angular2/core';
import { JobService } from '../job.service';
import { Job } from '../job.model';
import { JobsComponent } from './jobs.component';

@Component({
    selector: 'job-list',
    directives: [JobsComponent],
    template: `
      &lt;div class="login jumbotron center-block"&gt;
        &lt;h2&gt;Job openings&lt;/h2&gt;
        &lt;p class="lead"&gt;Take a look, maybe you will find something for you.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;jobs&gt;&lt;/jobs&gt;
      &lt;/div&gt;
    `
})
export class JobListComponent {
  public jobs: Array&lt;Job&gt;;
  private _jobsService: JobService;

  constructor(jobsService: JobService) {
    this._jobsService = jobsService;
  }
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec81" class="calibre1"/>Job details</h2></div></div></div><p class="calibre8">The job details page is <a id="id309" class="calibre1"/>going to display all the necessary information about the required job for the user. We are going to use the same user-friendly route as we did in the company details. Luckily, we already have a service to communicate with the backend API.</p><p class="calibre8">Create a file called <code class="email">public/src/job/components/job-detail.component.ts</code> and add the following code:</p><div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouteParams, RouterLink } from 'angular2/router';
import { JobService } from '../job.service';
import { Job } from '../job.model';

@Component({})
export class JobDetailComponent implements OnInit {
  public job: Job;
  private _routeParams: RouteParams;
  private _jobService: JobService;

  constructor(jobService: JobService, routerParams: RouteParams) {
    this._routeParams = routerParams;
    this._jobService = jobService;
  }

  ngOnInit() {
    const id: string = this._routeParams.get('id');
    this.job = new Job();
    this._jobService
    .findById(id)
    .subscribe((job) =&gt; {
      this.job = job;
    });
  }
}</pre></div><p class="calibre8">The logic inside <a id="id310" class="calibre1"/>the component is pretty much the same as in <code class="email">CompanyDetailComponent</code>. Using the <code class="email">id</code> router parameter, we fetch the desired job from the backend.</p><p class="calibre8">The <code class="email">Component</code> annotation should contain the necessary templates and directives used:</p><div><pre class="programlisting">@Component({
    selector: 'job-detail',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="job-header"&gt;
        &lt;div class="col content"&gt;
          &lt;p&gt;Added on: {{ job.createdAt }}&lt;/p&gt;
          &lt;h2&gt;{{ job.name }}&lt;/h2&gt;
          &lt;div class="job-description"&gt;
            &lt;h4&gt;Description&lt;/h4&gt;
            &lt;div&gt;{{ job.description }}&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="sidebar"&gt;
          &lt;h4&gt;Country&lt;/h4&gt;
          &lt;p&gt;{{ job.country }}&lt;/p&gt;
          &lt;h4&gt;Industry&lt;/h4&gt;
          &lt;p&gt;{{ job.industry }}&lt;/p&gt;
          &lt;h4&gt;Job type&lt;/h4&gt;
          &lt;p&gt;{{ job.type }}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
})</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec82" class="calibre1"/>Adding new jobs</h2></div></div></div><p class="calibre8">Now that we can list <a id="id311" class="calibre1"/>all the available jobs, we can implement the add new job functionality. This will be similar to the one that we implemented in the company module. </p><p class="calibre8">It probably feels like you are doing the same thing over and over again, but the purpose of the chapter is to create an application focused on CRUD operations. Many enterprise-graded apps have tremendous modules implementing those operations. So don't worry! We are going to have chapters in which we experiment with different technologies and architectures.</p><p class="calibre8">Let's continue and create a file called <code class="email">public/src/job/components/job-create.component.ts</code>:</p><div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { JobService } from '../job.service';
import { Job } from '../job.model';

export class JobCreateComponent implements OnInit {
  public job: Job;
  private _router: Router;
  private _jobService: JobService;

  constructor(jobService: JobService, router: Router) {
    this._router = router;
    this._jobService = jobService;
  }

  ngOnInit() {
    this.job = new Job();
  }

  onSubmit(event) {
    event.preventDefault();

    this._jobService
    .create(this.job)
    .subscribe((job) =&gt; {
      if (job) {
        this.goToJob(job._id, job.slug);
      }
    });
  }

  goToJob(id, slug) {
    this._router.navigate(['JobDetail', { id: id, slug: slug}]);
  }
}</pre></div><p class="calibre8">Prepend the <a id="id312" class="calibre1"/>following annotation to the <code class="email">Component</code> class:</p><div><pre class="programlisting">@Component({
    selector: 'job-create',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="jumbotron center-block"&gt;
        &lt;h1&gt;Post a new job&lt;/h1&gt;
        &lt;p&gt;We are happy to see that you are growing.&lt;/p&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;form role="form" (submit)="onSubmit($event)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="title"&gt;Job title&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="job.title" class="form-control" id="title"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="industry"&gt;Industry&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="job.industry" class="form-control" id="industry"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="country"&gt;Country&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="job.country" class="form-control" id="country"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="type"&gt;Job type&lt;/label&gt;
            &lt;input type="text" [(ngModel)]="job.type" class="form-control" id="type"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="summary"&gt;Summary&lt;/label&gt;
            &lt;textarea [(ngModel)]="job.summary" class="form-control" id="summary"&gt;&lt;/textarea&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="description"&gt;Description&lt;/label&gt;
            &lt;textarea [(ngModel)]="job.description" class="form-control" id="description"&gt;&lt;/textarea&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Create a job&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec36" class="calibre1"/>Company details</h1></div></div></div><p class="calibre8">Probably, you have <a id="id313" class="calibre1"/>already observed that earlier, when we listed all the companies, we created some nice URLs. We are going to use that path to display all the details of a company together with the available jobs.</p><p class="calibre8">The URL also contains the company slug, which is a URL-friendly representation of the company name. It has no benefit for the user, it's just URL sugar we added to display the name of the company nicely. Only the company ID is used when querying the backend for data.</p><p class="calibre8">As we have all the necessary components and services, we can implement our details component by following these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new file, called <code class="email">public/src/company/components/company-detail.component.ts</code>.</li><li class="listitem" value="2">Add the necessary dependencies:<div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouteParams, RouterLink } from 'angular2/router';
import { CompanyService } from '../company.service';
import { Company } from '../company.model';
import { JobsComponent } from '../../job/index';</pre></div></li><li class="listitem" value="3">Append the <code class="email">Component</code> annotation:<div><pre class="programlisting">@Component({
    selector: 'company-detail',
    directives: [
      JobsComponent,
      RouterLink
    ],
    template: `
      &lt;div class="company-header"&gt;
        &lt;h2&gt;{{ company.name }}&lt;/h2&gt;
        &lt;p&gt;
          &lt;span&gt;{{ company.country }}&lt;/span&gt;
          &lt;span&gt;·&lt;/span&gt;
          &lt;span&gt;{{ company.address }}&lt;/span&gt;
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;div class="company-description"&gt;
        &lt;h4&gt;Description&lt;/h4&gt;
      &lt;/div&gt;
      &lt;div class="company-job-list"&gt;
        &lt;jobs [company]=company._id&gt;&lt;/jobs&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre22">In the template, we are using the <code class="email">jobs</code> component that we implemented earlier to list all the available jobs of a company, by sending the company's <code class="email">id</code>.</p></li><li class="listitem" value="4">Declare the <a id="id314" class="calibre1"/><code class="email">component</code> class:<div><pre class="programlisting">export class CompanyDetailComponent implements OnInit {
  public company: Company;
  private _routeParams: RouteParams;
  private _companyService: CompanyService;

  constructor(companyService: CompanyService, routerParams: RouteParams) {
    this._routeParams = routerParams;
    this._companyService = companyService;
  }

  ngOnInit() {
    const id: string = this._routeParams.get('id');
    this.company = new Company();
    this._companyService
    .findById(id)
    .subscribe((company) =&gt; {
      this.company = company;
    });
  }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec37" class="calibre1"/>User profile</h1></div></div></div><p class="calibre8">In our system, we have <a id="id315" class="calibre1"/>no account type. We only define roles for users, such as a company owner, a member of a company, or a candidate. So, any registered user can fill out their profile with different information.</p><p class="calibre8">Remember that we defined a <code class="email">profile</code> property on the User schema. It will hold all the information regarding a user's work experience, education, or any other relevant data that the user wants to add.</p><p class="calibre8">The user's profile will be constructed using blocks. Each block will group a certain domain, such as experience, allowing the user to add new entries to each block.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec83" class="calibre1"/>Profile backend</h2></div></div></div><p class="calibre8">The backend <a id="id316" class="calibre1"/>logic for managing profile data has not been implemented yet. I wanted to give a feeling that we are extending our existing backend with new functionalities. So, we are going to start by creating a new controller file, <code class="email">app/controllers/profile.js</code>. Then add the following code:</p><div><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const User = mongoose.model('User');
const ProfileBlock = mongoose.model('ProfileBlock');
const ObjectId = mongoose.Types.ObjectId;

module.exports.getProfile = getUserProfile;
module.exports.createProfileBlock = createUserProfileBlock;
module.exports.updateProfile = updateUserProfile;</pre></div><p class="calibre8">We'll export three functions to manage profile data. Let's define them by following these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Get the current authenticated user and the whole profile data:<div><pre class="programlisting">function getUserProfile(req, res, next) {
  User
  .findById(req.user._id)
  .select('+profile')
  .exec((err, user) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.user = user;
    next();
  });
}</pre></div></li><li class="listitem" value="2">Create a new profile block for the user:<div><pre class="programlisting">function createUserProfileBlock(req, res, next) {
  if (!req.body.title) {
    return res.status(400).json({ message: 'Block title is required' });
  }

  var block = new ProfileBlock(req.body);
  req.resources.user.profile.push(block);

  req.resources.user.save((err, updatedProfile) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.block = block;
    next();
  });
}</pre></div><p class="calibre22">We are using a custom schema for a <code class="email">ProfileBlock</code> schema to create a new profile block and push it to the user's profile data. We are going to get back to our schema and define it.</p></li><li class="listitem" value="3">Update an <a id="id317" class="calibre1"/>existing profile block:<div><pre class="programlisting">function updateUserProfile(req, res, next) {
  // same as calling user.profile.id(blockId)
  // var block = req.resources.user.profile.find(function(b) {
  //   return b._id.toString() === req.params.blockId;
  // });

  let block = req.resources.user.profile.id(req.params.blockId);

  if (!block) {
    return res.status(404).json({ message: '404 not found.'});
  }

  if (!block.title) {
    return res.status(400).json({ message: 'Block title is required' });
  }

  let data = _.pick(req.body, ['title', 'data']);
  _.assign(block, data);

  req.resources.user.save((err, updatedProfile) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.block = block;
    next();
  });
}</pre></div></li></ol><div></div><p class="calibre8">When updating a profile block, we need to search for that specific block and update it with the new data. After that, the changes will be saved and persisted in MongoDB.</p><p class="calibre8">Let's take a look at <a id="id318" class="calibre1"/>our <code class="email">ProfileBlock</code> schema, which is found under <code class="email">app/models/profile-block.js</code>:</p><div><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const commonHelper = require('../helpers/common');
const Schema = mongoose.Schema;

let ProfileBlock = new Schema({
  title: {
    type: String,
    required: true
  },
  slug: String,
  data: []
});

ProfileBlock.pre('save', function(next) {
  this.slug = commonHelper.createSlug(this.title);
  next();
});

module.exports = mongoose.model('ProfileBlock', ProfileBlock);</pre></div><p class="calibre8">The preceding document schema will be embedded inside the user's document <code class="email">profile</code> property. The <code class="email">data</code> property will hold all the profile blocks, containing their own data.</p><p class="calibre8">In order to <a id="id319" class="calibre1"/>expose the functionalities we implemented earlier, let's create a profile routes file, called <code class="email">app/routes/profile.js</code>:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const profileCtrl = require('../controllers/profile');
const auth = require('../middlewares/authentication');
const response = require('../helpers/response');

router.get(
  '/profile',
  auth.ensured,
  profileCtrl.getProfile,
  response.toJSON('user')
);

router.post(
  '/profile/blocks',
  auth.ensured,
  profileCtrl.getProfile,
  profileCtrl.createProfileBlock,
  response.toJSON('block')
);

router.put(
  '/profile/blocks/:blockId',
  auth.ensured,
  profileCtrl.getProfile,
  profileCtrl.updateProfile,
  response.toJSON('block')
);

module.exports = router;</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec84" class="calibre1"/>Synchronizing profile data</h2></div></div></div><p class="calibre8">In order to <a id="id320" class="calibre1"/>store and retrieve profile data related to a user, we are going to create an Angular service that will handle the communication with the backend.</p><p class="calibre8">The frontend <code class="email">profile</code> module will be inside the <code class="email">user</code> module, as they are related, and we can group them by their domain context. Create a file called <code class="email">public/src/user/profile/profile.service.ts</code> and add the following baseline code:</p><div><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { contentHeaders } from '../../common/index';
import { AuthHttp } from '../../auth/index';
import { Block } from './block.model';

@Injectable()
export class ProfileService {
  public user: Subject&lt;any&gt; = new BehaviorSubject&lt;any&gt;({});
  public profile: Subject&lt;Array&lt;any&gt;&gt; = new BehaviorSubject&lt;Array&lt;any&gt;&gt;([]);
  private _http: Http;
  private _authHttp: AuthHttp;
  private _dataStore: { profile: Array&lt;Block&gt; };
}</pre></div><p class="calibre8">This time, we <a id="id321" class="calibre1"/>are going to use <code class="email">Observables</code> and <code class="email">Subject</code> for the data flow. They are more suitable in this case because there are many moving parts. The profile data can be updated from many different sources, and the changes need to travel to all subscribers.</p><p class="calibre8">To have a local copy of the data, we are going to use a data store in the service. Now let's implement each method one by one:</p><div><ol class="orderedlist"><li class="listitem" value="1">Add a class constructor:<div><pre class="programlisting">  constructor(http: Http, authHttp: AuthHttp) {
    this._http = http;
    this._authHttp = authHttp;
    this._dataStore = { profile: [] };
    this.profile.subscribe((profile) =&gt; {
      this._dataStore.profile = profile;
    });
  }</pre></div></li><li class="listitem" value="2">Get the profile information about the user:<div><pre class="programlisting">  public getProfile() {
    this._authHttp
    .get('/api/profile', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .subscribe((user: any) =&gt; {
      this.user.next(user);
      this.profile.next(user.profile);
    });
  }</pre></div></li><li class="listitem" value="3">Create a new profile block:<div><pre class="programlisting">  public createProfileBlock(block) {
    let body = JSON.stringify(block);

    this._authHttp
    .post('/api/profile/blocks', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .subscribe((block: any) =&gt; {
      this._dataStore.profile.push(block);
      this.profile.next(this._dataStore.profile);
    }, err =&gt; console.error(err));
  }</pre></div></li><li class="listitem" value="4">Update an <a id="id322" class="calibre1"/>existing profile block:<div><pre class="programlisting">  public updateProfileBlock(block) {
    if (!block._id) {
      this.createProfileBlock(block);
    } else {
      let body = JSON.stringify(block);

      this._authHttp
      .put(`/api/profile/blocks/${block._id}`, body, { headers: contentHeaders })
      .map((res: Response) =&gt; res.json())
      .subscribe((block: any) =&gt; {
        this.updateLocalBlock(block);
      }, err =&gt; console.error(err));
    }
  }</pre></div><p class="calibre22">When updating a profile block, we check whether an ID exists for that block. If not, it means that we want to create a new block and so we'll use <code class="email">createProfileBlock()</code>.</p></li><li class="listitem" value="5">Update a block from the local store:<div><pre class="programlisting">  private updateLocalBlock(data) {
    this._dataStore.profile.forEach((block) =&gt; {
      if (block._id === data._id) {
        block = data;
      }
    });

    this.profile.next(this._dataStore.profile);
  }</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec85" class="calibre1"/>Editing profile data</h2></div></div></div><p class="calibre8">To edit the user's <a id="id323" class="calibre1"/>profile, we are going to create a separate component. The user profile is built using blocks. For this reason, we should create another component just for the profile block.</p><p class="calibre8">Follow these steps to implement <code class="email">ProfileEditComponent</code>:</p><div><ol class="orderedlist"><li class="listitem" value="1">Add the necessary dependencies:<div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { ProfileBlockComponent } from './profile-block.component';
import { ProfileService } from '../profile.service';
import { Block } from '../block.model';</pre></div></li><li class="listitem" value="2">Place the <code class="email">Component</code> annotation:<div><pre class="programlisting">@Component({
    selector: 'profile-edit',
    directives: [ProfileBlockComponent],
    template: `
    &lt;section&gt;

      &lt;div class="jumbotron"&gt;
        &lt;h2&gt;Hi! {{user.name}}&lt;/h2&gt;
        &lt;p class="lead"&gt;Your public e-mail is &lt;span&gt;{{user.email}}&lt;/span&gt; &lt;br&gt; and this is your profile&lt;/p&gt;
      &lt;/div&gt;

      &lt;div class="row"&gt;
        &lt;div class="col-md-12"&gt;
          &lt;div class="profile-block" *ngFor="#block of profile"&gt;
            &lt;profile-block [block]="block"&gt;&lt;/profile-block&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;form class="form-horizontal col-md-12"&gt;
          &lt;div class="form-group"&gt;
            &lt;div class="col-md-12"&gt;
              &lt;input [(ngModel)]="newBlock.title" type="text" class="form-control" placeholder="Block title"&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;div class="col-md-12"&gt;
              &lt;button (click)="onClick($event)" class="button"&gt;New block&lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;

    &lt;/section&gt;
    `
})</pre></div></li><li class="listitem" value="3">Add the <a id="id324" class="calibre1"/>properties and constructor:<div><pre class="programlisting">export class ProfileEditComponent implements OnInit {
  public user: any;
  public profile: any;
  public newBlock: Block;
  private _profileService: ProfileService;

  constructor(profileService: ProfileService) {
    this._profileService = profileService;
  }
}</pre></div></li><li class="listitem" value="4">Append the <code class="email">ngOnInit()</code> method:<div><pre class="programlisting">  ngOnInit() {
    this.user = {};
    this.newBlock = new Block();
    this._profileService.user.subscribe((user) =&gt; {
      this.user = user;
    });
    this._profileService.profile.subscribe((profile) =&gt; {
      this.profile = profile;
    });
    this._profileService.getProfile();
  }</pre></div></li><li class="listitem" value="5">Define how the user can add new blocks:<div><pre class="programlisting">  onClick(event) {
    event.preventDefault();
    let profile = this.profile.slice(0);  // clone the profile
    let block = Object.assign({}, this.newBlock); // clone the new block

    profile.push(block);
    this._profileService.profile.next(profile);
    this.newBlock = new Block();
  }</pre></div></li></ol><div></div><p class="calibre8">We'll subscribe to the profile data stream and display all the blocks. To display the profile blocks, we use a separate component. This component gets the block as a data input.</p><p class="calibre8">When the user adds a new block, we push the freshly created block to the profile. This is fairly easy to do <a id="id325" class="calibre1"/>because we are using a <code class="email">Subject</code> from RxJS. In this way, we can synchronize our profile data with all our components.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec86" class="calibre1"/>The profile block component</h2></div></div></div><p class="calibre8">Because the <a id="id326" class="calibre1"/>profile is made out of blocks, we can create a separate component that is reusable and encapsulates all of the block's functionality. Let's create our component, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new file, called <code class="email">public/src/user/profile/components/profile-block.component.ts</code>.</li><li class="listitem" value="2">Add the necessary dependencies:<div><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { ProfileService } from '../profile.service';
import { Block } from '../block.model';
import { Entry } from '../entry.model';</pre></div></li><li class="listitem" value="3">Configure the <code class="email">Component</code> annotation:<div><pre class="programlisting">@Component({
    selector: 'profile-block',
    inputs: ['block'],
    template: `
      &lt;div class="panel panel-default"&gt;
        &lt;div class="panel-heading"&gt;
          &lt;h3 class="panel-title"&gt;{{block.title}}&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class="panel-body"&gt;
          &lt;div class="profile-block-entries"&gt;
            &lt;div *ngFor="#entry of block.data"&gt;
              &lt;div class="form-group"&gt;
                &lt;label&gt;Title&lt;/label&gt;
                &lt;input class="form-control" type="text"
                  (keydown.enter)="onEnter($event)"
                  [(ngModel)]="entry.title"&gt;
              &lt;/div&gt;
              &lt;div class="form-group"&gt;
                &lt;label&gt;Sub title&lt;/label&gt;
                &lt;input class="form-control" type="text"
                  (keydown.enter)="onEnter($event)"
                  [(ngModel)]="entry.subTitle"&gt;
              &lt;/div&gt;
              &lt;div class="form-group"&gt;
                &lt;label&gt;Description&lt;/label&gt;
                &lt;textarea class="form-control"
                  (keydown.enter)="onEnter($event)"
                  [(ngModel)]="entry.description"&gt;&lt;/textarea&gt;
              &lt;/div&gt;
              &lt;hr&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;button class="btn btn-default btn-xs btn-block" (click)="addEntry($event)"&gt;
            &lt;i class="glyphicon glyphicon-plus"&gt;&lt;/i&gt; Add new entry
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Define the <a id="id327" class="calibre1"/><code class="email">ProfileBlockComponent</code> class:<div><pre class="programlisting">export class ProfileBlockComponent implements OnInit {
  public block: any;
  private _profileService: ProfileService;

  constructor(profileService: ProfileService) {
    this._profileService = profileService;
  }

  ngOnInit() {
    console.log(this.block);
  }

  addEntry(event) {
    event.preventDefault();
    this.block.data.push(new Entry());
  }

  onEnter(event) {
    event.preventDefault();
    this._profileService.updateProfileBlock(this.block);
  }
}</pre></div></li></ol><div></div><p class="calibre8">Using the <code class="email">addEntry()</code> method, we can add more entries to our block. It's a simple operation that pushes a <a id="id328" class="calibre1"/>new entry to the block's data. In order to save the changes, we bind to the keydown event, which matches the <em class="calibre11">Enter</em> key to call the <code class="email">onEnter()</code> method. This method will update the profile block using the service implemented earlier.</p><p class="calibre8">If a block was freshly added and has no <code class="email">id</code>, <code class="email">ProfileService</code> will handle this situation, so we don't need to add different method calls in our component.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec87" class="calibre1"/>Extra models</h2></div></div></div><p class="calibre8">We used a few <a id="id329" class="calibre1"/>extra models—ones that are not found on the backend—in order to help us with the Angular part. They come in handy when creating initial values or when having default values for properties.</p><p class="calibre8">The <code class="email">Entry</code> model described a single entry from a profile block. The model can be found under <code class="email">public/src/user/profile/entry.model.ts</code>:</p><div><pre class="programlisting">export class Entry {
  title: string;
  subTitle: string;
  description: string;

  constructor(
    title?: string,
    subTitle?: string,
    description?: string
  ) {
    this.title = title || '';
    this.subTitle = subTitle || '';
    this.description = description || '';
  }
}</pre></div><p class="calibre8">We also used a second helper model in our module—<code class="email">public/src/user/profile/block.model.ts</code>:</p><div><pre class="programlisting">import { Entry } from './entry.model';

export class Block {
  _id: string;
  title: string;
  slug: string;
  data: Array&lt;any&gt;;

  constructor(
    _id?: string,
    title?: string,
    slug?: string,
    data?: Array&lt;any&gt;
  ) {
    this._id = _id;
    this.title = title;
    this.slug = slug;
    this.data = data || [new Entry()];
  }
}</pre></div><p class="calibre8">The preceding model used the <code class="email">Entry</code> model to initialize the <code class="email">data</code> property with an initial value in case no data was present. You can also add validation to your models. This depends on the complexity of the application.</p><p class="calibre8">The remaining <a id="id330" class="calibre1"/>functionalities can be found in the <a id="id331" class="calibre1"/>final project repository found at the following link: <a class="calibre1" href="https://github.com/robert52/mean-blueprints-jobboard">https://github.com/robert52/mean-blueprints-jobboard</a>
</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec38" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Finally, we have reached the end of this chapter.</p><p class="calibre8">In this chapter, we started building an application from a boilerplate, extended some of its functionalities, and added our own new functionalities. We created a system with multiple user types and added authorization policies. Also, in the final steps, we extended our backend API with new functionalities and added an extra module to our Angular 2 application.</p><p class="calibre8">In the next chapter, we will use real-time communication and see how users can interact with each other in an application.</p></div></body></html>