["```js\ninputField = await getValidElement(inputField, \"field\");\n```", "```js\n // Extract the element type if not provided\n if (elementType === \"\") {\n let index: number = selector.indexOf(\"[\");\nelementType = selector.substring(0, index);\n }else{\n elementText = normalizeElementType(elementType);\n}\n```", "```js\nfunction normalizeElementType(elementType: string)\n{\n  // Pessimistic: return all matches if the type is unknown\n  let elementText = \"//*\"\n  switch (elementType)\n  {\n    case \"link\":\n      elementText = \"//a\";\n      break;\n    case \"button\":\n      elementText = \"//button\";\n      break;\n    // Support different terms of the same field type\n    case \"field\": // plain English reference to a type input field\n    case \"input\": // type input\n      elementText = \"//input\";\n      break;\n    case \"list\":\n      elementText = \"//select\";\n      break;\n    case \"text\":\n      elementText = \"//p\";\n      break;\n    default:\n      log (`WARNING: Unable to normalize element type ${elementType}`)\n  }\n  return elementText;\n}\n```", "```js\ncase \"//*\":\nelementText = selector.match(/=\".*\"/)[0].slice(2, -1);\nnewSelector = `//*[contains(text(), '${elementText}'])`;\nfound = await isElementVisible(await $(newSelector));\nbreak;\n```", "```js\n <!DOCTYPE html>\n<html>\n<head>\n    <title>Dynamic Loading Example</title>\n    <script>\n        function embeddedCarriageReturn() {\n            var paragraph = document.getElementById(\"change-me\");\n            paragraph.innerHTML = \"You clicked the Embedded Carriage             Return link!\";\n        }\n    </script>\n</head>\n<body>\n    <h1>Weblink Challenge!</h1>\n    <p>Can you framework click the link below</p>\n    <a href=\"#\" onclick=\"embeddedCarriageReturn()\">Embedded <br>        Carriage  Return</a>\n    <p id=\"change-me\"></p>\n</body>\n</html>\n```", "```js\n  public get btnEmbeddedCarriageReturn() {\n    return $(\"//a[text()='Embedded Carriage Return']\");\n  }\n```", "```js\n  public get btnEmbeddedCarriageReturn () {\n    return $(\"//a[contains(normalize-space(),'Embedded Carriage     Return')] \");\n  }\n```", "```js\nexport async function setValueAdv(\n  inputField: ChainablePromiseElement<WebdriverIO.Element>,\n  text: string) {\n//Custom setValue wrapper code here\nawait element.setValue(newValue);\n}\n```", "```js\n//Custom setValue wrapper code here\ntry{\n    if (text.length === 0) {\n        log (`      Warning: Attempted to enter \"\" into ${element.selector}`)\n    return true;\n}\n}catch (error){\n    log (`      Warning: Attempted to enter NULL into ${element.selector}`)\n    log (`      Check if there was a query column to a missing column in a data file `)\n    return false;\n}\n```", "```js\n\"Tomorrow is: <today+1>\"\n\"Tomorrow is: 6/22/2023\"\n```", "```js\n\"Last week was: <today-7>\"\n\"Last week was: 6/14/2023\"\n```", "```js\n\"Yesterday in European format: <today-1 dd/mm/yyyy>\"\n\"Yesterday in European format: 20/6/2023\"\n```", "```js\nfunction replaceTags(text: string) {\n  //check if the passed tag is in the format of \"<someTag>\"\n  let newText: string = text;\n  // Capture anything that is not a space\n  let match = newText.match(/\\<(.*?)\\>/);\n```", "```js\n  while (match) {\n    let tag = match[0].toLowerCase();\n    let tagType = match[1].toLowerCase();\n```", "```js\n    switch (true) {\n      case tag.includes(\"<today\"):\n```", "```js\n        let format: string = tagType.split(\" \")[1] ? tagType.split(\" \")[1] : \"\";\n        let days: number = 0;\n        const match = tag.match(/[+-](\\d+)/);\n```", "```js\n        if (match) {\n          const days = parseInt(match[0]);\n        }\n```", "```js\n        newText = newText.replace(tag, getToday(days, format));\n        break;\n      default:\n        log(`ERROR: Unknown tag <${tag}>`);\n        break;\n    }\n    match = newText.match(/\\<(.*?)\\>/);\n  }\n```", "```js\n  if (newText !== text) {\n    log(`    Replaced tags in '${text}' with '${newText}'`);\n  }\n  return newText;\n}\n```", "```js\nexport function getToday(offset: number = 0, format: string = \"MM-dd-yyyy\") {\n  const currentDate = new Date();\n  currentDate.setDate(currentDate.getDate() + offset);\n```", "```js\n  return currentDate.toLocaleDateString(undefined, {\n    year: format.includes(\"yyyy\") ? \"numeric\" : undefined,\n    month: format.includes(\"MM\")\n      ? \"2-digit\"\n      : format.includes(\"M\")\n      ? \"numeric\"\n      : undefined,\n    day: format.includes(\"dd\")\n      ? \"2-digit\"\n      : format.includes(\"d\")\n      ? \"numeric\"\n      : undefined,\n  });\n}\n```", "```js\nawait inputField.setValue(newValue);\n```", "```js\nawait inputField.addValue(newValue);\n```", "```js\nawait highlightOn(inputField);\nawait inputField.click();\n```", "```js\nif (await inputField.getAttribute('value') !== '') {\nawait inputField.clear();\n}\n```", "```js\nawait browser.keys(['Meta', 'a']);\nawait browser.keys(['\\ue003']);\n```", "```js\nawait browser.keys(text);\n```", "```js\n// type text letter by letter\nfor (let letter = 0; letter < text.length; letter++){\nawait pause(10); // control the typing speed\nawait inputField.addValue(text[letter]);\n}\n```", "```js\nawait browser.keys(['tab']);\n```", "```js\nawait browser.keys(['\\ue007']);\n```", "```js\nfunction maskString(str: string): string {\n  let maskedStr = '';\n  for (let charIndex = 0; charIndex < str.length; charIndex++) {\n    if (charIndex > 1 && charIndex < str.length - 2) {\n      maskedStr += '*';\n    } else {\n      maskedStr += str[charIndex];\n    }\n  }\n  return maskedStr;\n}\n```", "```js\nlet originalString = \"SuperSecretPassword!\";\nlet maskedString = maskString(originalString);\nconsole.log(originalString); // Output: 'SuperSecretPassword! '\nconsole.log(maskedString); // Output: 'se**********ation'\n```", "```js\nscrubbedtext = maskString (text)\n```", "```js\n/**\n* Returns the first non-null property from the prioritized list: 'name', 'id', 'type', and 'class'. Can be amended to add other attributes such as \"aria-label\"\n* @param {WebdriverIO.Element} element - The WebdriverIO element to get the name of the field\n* @returns {string | null} The field name, or null if no properties have a value\n*/\nasync function getFieldName(element: WebdriverIO.Element) {\n// Add any custom properties here, e.g.:\n// const customPropertyName = await element.getAttribute(\"aria-label\");\n// if (customPropertyName) return custom;\n// Get the 'name' property of the element\n  const name = await element.getAttribute(\"name\");\n  if (name) return name;\n  // Get the 'id' property of the element\n  const id = await element.getAttribute(\"id\");\n  if (id) return id;\n  // Get the 'type' property of the element\n  const type = await element.getAttribute(\"type\");\n  if (type) return type;\n  // Get the 'class' property of the element if others are null\n  const className = await element.getAttribute(\"class\");\n  return className;\n}\n```", "```js\nexport async function setValueAdv(\n  inputField: WebdriverIO.Element,\n  text: string\n) {\n  let success: boolean = false;\n  inputField = await getValidElement(inputField, \"field\");\n  const SELECTOR = await inputField.selector;\n  let newValue: string = replaceTags(text);\n  let scrubbedValue: string = newValue\n  let fieldName: string = await getFieldName(inputField)\n  //Mask Passwords in output\n  if (fieldName.includes(\"ssword\") ){\n    scrubbedValue = maskValue(scrubbedValue)\n  }\n  await log(`Entering '${scrubbedValue}' into ${SELECTOR}`);\n  try {\n    // await element.waitForDisplayed();\n    if (!(await isElementInViewport(inputField))) {\n      await scrollIntoView(inputField);\n      await waitForElementToStopMoving(inputField);\n    }\n    await highlightOn(inputField);\n    //Check if text was entered\n    // Clear input field\n    await inputField.click();\n    // Do we need to clear the field?\n    if (await inputField.getValue()) await inputField.setValue(newValue);\n    // Send text to input field\n    for (const letter of text) {\n      await inputField.addValue(letter);\n    }\n    success = true;\n  } catch (error: any) {\n    await log(`  ERROR: ${SELECTOR} was not populated with ${scrubbedValue}.\\n       ${error.message}`\n    );\n    expect(`to be editable`).toEqual(SELECTOR);\n    // Throw the error to stop the test, still masking password\n    await inputField.setValue(scrubbedValue);\n  }\n  return success;\n}\n```", "```js\n[0-0] ---> Logging in with user role 'tomsmith'\n[0-0] ---> Entering 'tomsmith' into #username\n[0-0] ---> Entering 'Su****************d!' into #password\n```"]