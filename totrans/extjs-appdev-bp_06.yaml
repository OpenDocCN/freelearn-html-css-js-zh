- en: Chapter 6. Practical – Monitoring Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've started applying the things we've learned to a real-world application,
    we're going to gradually ramp up the complexity of the projects we build. By designing
    and creating a code base that imitates something an actual customer might pay
    money for, we're not coding abstract examples that exist in isolation. We're building
    something that showcases some of the design decisions you will likely face as
    a software architect.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll build a monitoring dashboard that can be used to view
    metrics from an application server. Developers and system administrators will
    use applications like this to visualize the performance of their servers and monitor
    load at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an application could be used for internal monitoring, or it could be deployed
    as a **Software as a Service** (**SaaS**) that could be resold to other users.
    Either way, it will serve as a great demonstration of the power of view models;
    we''ll be expanding what we already know and will be using it in a more advanced
    way to shape the data we receive from the server. In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our data layer from the `Ext.data.Model` through to the view models
    needed to support our UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple view controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building components that are reused across views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routing to allow users to bookmark each screen of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view model filters to focus our view of the underlying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we'll have fleshed out the concepts we've already
    begun to cover and introduced some new features (such as routing). These are important
    when designing the user experience for an application.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to approach this as if we're designing an internal program, one
    that monitors another application in our theoretical software development shop.
    Although this means we're not bound by external customer requirements, it's still
    important that we follow all of the design guidelines we've already learned. This
    maybe an internal application, but it's still got to be robust, meet the expectations
    of stakeholders, and be maintained in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This application will have several screens to view the various properties of
    the app being monitored. We''ll have a dashboard screen that shows an overview
    of the important metrics being monitored. Then, for each of these metrics, we''ll
    have individual screens that allow the user to drill down and filter the data.
    As each of these screens will be variations on a common theme, we''ll only build-out
    a couple to demonstrate the concepts, but the framework we''ll build with this
    application means it would be trivial to add more. The **Dashboard** tab can be
    seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Web** tab is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As users, what do we want to see in this monitoring application? We want information
    at a glance, but with the ability to easily get detailed information. Our primary
    concerns are the response times of web requests and queries to the database, so
    we want both these metrics available to us. Let''s think about the user interface
    that supplies this information and what it might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the **Dashboard** tab, we're using charts to convey trend information—about
    both the short-term and the longer term—and this provides our at a glance view
    of the data. The top two charts update in real time to show the average response
    time, whereas the bottom charts show historical trends for comparison. How about
    getting details on this data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we''ve added tabs on the left-hand side of the screen that allow you
    to switch between log types. In this application, we''ve just got **SQL** and
    **Web** in addition to the initial **Dashboard** view, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the main part of the screen, we've got a set of controls to filter the data.
    The chart and grid underneath will update depending on the results of the filter.
    This gives the user the ability to view data within a particular date range. It
    also gives the user the ability to pick the category of detail to drill down.
  prefs: []
  type: TYPE_NORMAL
- en: 'What sort of categories? It could be extended in future, but here''s our current
    list for the **Web** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're displaying information on the web requests in our date range to provide
    more insight on who is visiting our application. Are we getting lots of visitors
    from Japan? Are they experiencing unacceptably high response times? Maybe we need
    to add a server somewhere in Asia to meet their requirements. Are we seeing a
    lot of tablet users? Do we need to improve our responsive design to better cope
    with a tablet screen size?
  prefs: []
  type: TYPE_NORMAL
- en: 'On the SQL front, we''ve got:'
  prefs: []
  type: TYPE_NORMAL
- en: Query type (select, insert, update, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slowest queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is just general information; you could see whether your application
    was read-heavy or write-heavy here, which would inform how your technology stack
    changes over time. The other two go hand in hand, showing the slowest queries
    and which pages in the application issue most queries.
  prefs: []
  type: TYPE_NORMAL
- en: These metrics are useful to increase transparency in an application. In some
    cases, they won't be enough to diagnose subtle issues, but they will be invaluable
    in showing the trends of how your application and users are behaving.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've established the ideal UI for our application, but how does this translate
    into technical requirements?
  prefs: []
  type: TYPE_NORMAL
- en: We want line charts to show trends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want these charts to be able to update when they receive new data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be able to choose a date range and update charts and grids accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be able to choose a data category and have grids update accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at each of these in the context of Ext JS:'
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS charts have area, line, scatter series, and so on, so we can plot the
    data in a way that allows you to visualize a trend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `load` method of `Ext.data.Store` can accept an `addRecords` parameter,
    which when set to `true` will cause newly loaded records to be appended to the
    store rather than overwriting the existing data. This will allow us to provide
    update data to a chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS provides a date field component that can be linked to a view model to
    filter data based on a date range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grids have a reconfigure method that allows you to change the columns of the
    grid on the fly if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Message received and understood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've set out our own criteria for this project, but we're still being explicit
    at spelling out what we need before we start coding, and we're making sure that
    our technical framework will support what we need. Why not just get on with the
    job and put fingers to keyboards?
  prefs: []
  type: TYPE_NORMAL
- en: Although this isn't a job that has an explicit paying customer, it's still something
    that needs accountability. It's not enough as a professional developer to say
    that it'll be "done when it's done" because this attitude won't wash with the
    people who pay your salary. We must plan our projects in as much detail as to
    give us confidence in the delivery of our work—both from a time and quality perspective—as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: No matter who we are building software for, we must always strive to create
    something robust, something that meets or exceeds expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make an assumption in this chapter, that is, we have a friendly backend
    developer on our team who's able to provide us data in the format we need. Let's
    flesh out our requirements for the data that will power our application.
  prefs: []
  type: TYPE_NORMAL
- en: Another assumption is that we're looking for trends and statistics here, so
    we're going to be basically aggregating logs into something more suitable for
    user consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Live charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We planned to have two "live" charts on the dashboard (one to show SQL queries
    as they come in, and one to show web requests). In order for this to work, we
    need a URL we can poll every second or so. This will provide us with data on the
    last second of activity. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A `GET` request to `/logs/all/live` gives us an array of objects, one for each
    log type. As mentioned, we're restricting ourselves to SQL and the Web only. The
    `ms` property is the average response time of the operations that occurred in
    the past second. The `count` property is the number of operations that took place.
    We designed the API with a little bit of flexibility in mind, so it could be extended,
    for example, replace `"all"` in the URL with `"sql"` to filter on one log type.
  prefs: []
  type: TYPE_NORMAL
- en: Historical logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the dashboard and the subpages of our application, we also need to show
    graphs of historical data. On the dashboard, it''ll be from the past 30 days,
    but on the subpages, it could be an arbitrary time frame. Here''s our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to rely on a feature of `Ext.data.Store: remoteFilter`. When this
    is set to `true`, Ext JS will defer filtering to the server and pass through the
    filter criteria as a JSON array. We can set an arbitrary number of filters, so
    in order to get SQL data within a date range, we''d be passing something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our kind server-side developer will combine these filters into something that
    returns the correct response.
  prefs: []
  type: TYPE_NORMAL
- en: Log statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as general aggregated information about Web and SQL operations, we
    also want to display a grid of further detail on our tab pages. Again, these will
    be filterable based on the date range as well as the category of information we
    want to view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `remoteFilter` feature again, meaning that Ext JS just passes
    the JSON filter straight through to the server as well as the `type` and `time`
    parameter from before. This time, we will add a `category` parameter to specify
    what subset of information—such as location for web logs or query source for SQL—we'd
    like to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: In response, we get an array of all of the items within the chosen category
    and the percentages allocated to each one over the specified time frame.
  prefs: []
  type: TYPE_NORMAL
- en: Model behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve got our API. How does this translate into the JavaScript data models
    we''ll need? Well, we only need two—look at the API responses we just documented—the
    `/logs` returns one type and `/statistics` returns another type. They''ll look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s this `BaseModel` all about? In order to share schema configuration
    between models, we can use a base model from which all other models inherit. It
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the model for statistics is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `percentage` field represents the proportion of operations that are represented
    by this statistic. For example, if `category` is `location` and `label` is `Japan`,
    then the percentage could be something like `5 percent` (5 percent of our requests
    come from Japan). This is flexible enough to be used for all the data categories
    we'd like to view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need one for the live log stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The log stream has the same fields as the `LogEntry` model, but we have it as
    a separate class, so its class name can affect the schema configuration. We'll
    go into more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're lucky with this theoretical API; in this, we are allowed to shape our
    requirements. In the real world, it might not be that simple, but having a friendly
    backend developer will always make our lives as frontend developers much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Our API has strongly informed our data layer. While it's great to keep things
    simple—as we've been able to here—it's important not to mistake simplicity for
    naivety or inflexibility. In this case, our UI components will happily work with
    our data layer, which in turn works with our API without having to shoehorn any
    one piece into working with the others.
  prefs: []
  type: TYPE_NORMAL
- en: The view from the top
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the fuel for our application; the data will bring life to the coding
    engine we''re about to build. We now need to establish controllers that will constitute
    this engine and views that will give us a user interface to control and visualize
    it. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The view from the top](img/5308OT_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the outer area marked as **1**, we have a main view that provides a container
    for other views. This will have a corresponding view controller that will manage
    any cross-application concerns from the main's subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: For the inner section marked as **2**, we have the dashboard view, a container
    for four charts. Its view controller will manage the live updates of the top two
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each subpage will add an additional view (see **3**), for example, a **Web**
    view and an associated view controller. It will present and control the historical
    log chart, the statistics grid, and user input to the filtering date fields and
    button, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The view from the top](img/5308OT_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s how all our classes interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The view from the top](img/5308OT_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve got the general picture of our application classes. Let''s drill down
    and look at the details of each class in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main view is a tab panel that contains all subpages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned, the main controller deals with things that concern the whole
    application. It''s responsible for swapping between the dashboard and subpages
    `onTabChange` and decides what action to take if the URL changes `onNavigate`.
    Four instances of `Ext.chart.CartesianChart` to display the various line charts
    that we need on the dashboard, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need some code to set up our live-updating charts, so we do this in `initializeChartRefresh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ext.app.ViewModel` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The view model for the dashboard sets out four separate sources of data, one
    for each of the charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated view controller is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah! This is a pretty sparse view controller for a view, which is actually doing
    quite a lot. Let''s look at the view model and things might become a bit clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The plan is to pull the historical log data and the statistics about this log
    data from a couple of stores. We'll have another that holds the categories that
    the user can use to filter the grid view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's arguable that the categories could be held in the part of the user interface
    that filters the data in a completely separate store. However, it also makes sense
    to hold the data for a view in one place—the view model—and not over complicate
    things by adding another unnecessary store class.
  prefs: []
  type: TYPE_NORMAL
- en: The key part of this view model comes when we think about the current state
    of the application. For this subpage, it'll be stored in the `currentCategory`,
    `currentStartDate`, and `currentEndDate` variables.
  prefs: []
  type: TYPE_NORMAL
- en: As we're keeping all of the state in the view model, we can bind to the UI controls
    that set this state and in turn bind these values to a `store` filter. This means
    that changing the value using the UI will automatically change the filter value
    without requiring any glue code in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation requires a strong understanding of the power of view models
    and a thoughtful eye for the design of the application. We'll go into detail on
    this later when we write the code for this section.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the application is the SQL subpage. This is essentially the
    same as the web subpage, but displaying a different set of information, so we
    won't go into detail about its design.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility and pragmatism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that we're yet to discuss in detail is how a design can change over
    time. We're setting out our thoughts on what we think our application should look
    like, but until we write it, we won't know all of the ins-and-outs of the exact
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to undertake a constant re-evaluation of the work that's taking
    place to ensure that the quality of what's being written remains high. We've documented
    our design earlier, but in one key place, we've also had the realization that
    subpages will be very similar to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how these similarities are fleshed out in code, there could be
    scope for refactoring and reusing in a way that isn't immediately clear when drawing
    up the design document. However, if the implementation does turn out to be sufficiently
    similar with only minor variations between each subpage, then we need to look
    at extracting this code into a reusable class.
  prefs: []
  type: TYPE_NORMAL
- en: Code duplication—and even worse, copying and pasting code—is a very good way
    of ending up with a messy code base. In the event you need to change something,
    tweak behavior, add a feature, or fix a bug, you'll have to do the same thing
    in several places, increasing the overhead of the change and increasing the chance
    that more mistakes will creep into your code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copy and pasting is a blight on your code base. By blindly duplicating code,
    your developers are not applying any critical analysis. They are increasing the
    size of your code base unnecessarily and could well be introducing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we'll begin building out the code for this application.
    We'll also keep a close eye out for anything that looks like it might be duplicating
    what went before. In these cases, we'll take some time out to see whether there's
    functionality we can encapsulate and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS provides multiple methods to structure code—such as inheritance and mixins—and
    taking advantage of these methods will result in an application that is much easier
    to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Does this hurt?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've got our design in place, from top to bottom, so now it's time to cast
    a critical eye over it. Are there any unknown aspects of the design or are there
    any potential pain points? The live-updating chart is a little bit of a black
    box right now. While we know that charts support animation (via the `animate`
    **configuration** option), we want to be certain that the axis on the chart can
    update as the new data comes in. It's worth doing a very simple test to make certain
    this'll work. To do this, we're going to go a little bit retro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using Sencha Cmd and the whole Bootstrap process, we''re going
    to link directly to the files we need and use `Ext.onReady` to run our code. Here''s
    the empty template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created an HTML page that links to the JS files for Ext JS and Sencha
    Charts as well as the CSS for one of the Ext JS Themes. In the body of the HTML,
    we will create a div with an ID of "chart" to render into and then an `Ext.onReady`
    block where we''ll place the bulk of our code. First, let''s set up a store in
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables for the current time "from" and "to" times for the chart axis is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the chart itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some data to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Every second, we add a new record to the store with the current time and a random
    value. After running this code, we get a line chart that updates every second,
    fantastic! However, while this is pretty close to what we need, there is a problem.
    As the line approaches the right-hand side of the chart, it just disappears off
    the canvas. We need to somehow update the bottom axis of the chart when we update
    its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chart has a `redraw` event that we can use for just this purpose. What
    we''ll try to do is move the `from` date and the `to` date located at the bottom
    axis forward by `15` seconds. As the `redraw` event will be triggered every second,
    thanks to our store updating via the `setInterval` call, every fifteenth time
    the `redraw` event is fired, we update the axes. This is how it looks in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We use a variable called `redrawCounter` to keep track of how many times the
    redraw event has fired since our last axis adjustment. The rest of the code should
    be fairly straightforward. Grab the bottom and set its dates 15 seconds ahead.
  prefs: []
  type: TYPE_NORMAL
- en: This was all fairly painless, although there were some unexpected hurdles in
    having to hook into the `redraw` event. Now that we've assured ourselves that
    this particular issue can be solved, we can move on to building the rest of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Onwards and upwards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all of our example applications, we''ll use Sencha Cmd and build an
    application template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove all of the cruft and example files that the generator creates and use
    the `watch` command to fire up a web server. We can then proceed to create the
    first real code for our application: the data layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Data first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our models will inherit from a base model, which will be used to specify
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've assumed that we have an API server running at localhost on port `3000`
    and supplied this information as the URL prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `schema` configuration in the last chapter, but now that we''re
    about to use it with multiple models, it really comes into its own. In each of
    the models that inherit from `BaseModel`, the model''s name will be inserting
    into the proxy URL in place of the `entityName` token. This avoids duplicating
    the URL configuration across multiple models. We can now create our `LogEntry`
    model as per our design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Via the schema, this will result in the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than this, we''re just implementing the fields, we specified in the design,
    on to the `LogStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This was simple. The `LogStream` class inherits all of the fields from the
    `LogEntry` class, but thanks to the use of the schema configuration in the `BaseClass`,
    `LogStream` will have a URL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the `Statistics` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just the three fields from the design here and it gives us a model that produces
    this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Nothing in our data layer is particularly taxing, as we thought through the
    implementation during our design phase. By having an awareness of the features
    Ext JS provides before sitting down to write code, we were able to reduce code
    duplication by having the proxy configuration in a base class.
  prefs: []
  type: TYPE_NORMAL
- en: We should always look for places, either via refactoring or through the initial
    design, where we can reduce duplicated code. In this example, we could have had
    the same functionality by setting the proxy configuration on each of `LogEntry`,
    `LogStream`, and `Statistic`, but in the event where we want to change some part
    of the config, such as the hostname of the API, we'd have to change it in multiple
    locations. By centralizing in the way that we have, we will have less code to
    maintain and it's easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note in the model classes earlier is the way we define the fields.
    There are two options in Ext JS, one option is to pass a field definition as an
    object literal as we have in our code, and the second option is to pass a string
    containing the field name. To use the `Statistic` class as an example, the field
    config will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Why choose one over the other? The answer is for consistency. This is a perfect
    example of something that could go in the programming style guide for your team,
    so rather than having one class declared using one method and a second class using
    another method, we have a unified approach. No alarms and no surprises for a new
    developer who opens up your model files and finds the field definitions well organized.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third approach for field definitions; not bothering with them. Ext
    JS allows you to leave out the field definitions and will create them on the fly
    based on the data the model is consuming.
  prefs: []
  type: TYPE_NORMAL
- en: We're all for reducing the amount of code to maintain, but sometimes, it's better
    to be explicit. If we needed to use one of the other configuration options in
    a field, such as convert, then we'd have to manually define that field anyway,
    and so on, and then be left with some fields explicit in the model and some created
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: This is a matter of preference, but for our purposes, we'll always define the
    full field definitions. It's consistent and self-documenting; we're always aware
    of the fields it's consuming when looking at a model file.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stores in this project are as simple as it can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These classes are fairly boilerplate (define the model, define the alias, and
    that's it). There's an argument to be heard that these stores could actually be
    defined on individual view models, reducing the number of files in our code base.
    However, in this application, we'll reuse the stores in multiple view models,
    so it makes sense to keep their configuration in a centralized location.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the UI layer of our application.
  prefs: []
  type: TYPE_NORMAL
- en: With a view to a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this application, we have a "main" view, which acts as the application''s
    viewport, and an associated controller, which deals with user interactions with
    this viewport and handles routing. Let''s look at the UI portion first: `view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are a few interesting bits in this code. We use the `header` config option
    to give us fine control over the panel's header, allowing us to add some formatting
    to the title.
  prefs: []
  type: TYPE_NORMAL
- en: We then change the default configuration of the panel's tabs to put them on
    the left-hand side of the screen (as opposed to the top of the screen). As tabs
    on the left-hand side default to displaying from top to bottom, we adjust `tabRotation`
    too, making them read from left to right. The tab selected by default is automatically
    the first component in the items array, so we can avoid setting any configuration
    to stipulate this.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set out the items that will be included in this tab panel, just the
    dashboard, the web logs subpage, and the SQL logs subpage, as dictated in our
    design. The only interesting part of this configuration is the addition of `reference`
    for each component and its utility will become clear when we look at the view
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: The main view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There isn''t a lot of code in this view controller, but the functionality it
    enables is very important. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Not much code, to be sure, but a lot going on. This is the part of the application
    that deals with routing, so let's take a bit of time out to discuss what routing
    actually is.
  prefs: []
  type: TYPE_NORMAL
- en: Rootin-Tootin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a pretty comprehensive description of routing in the Ext JS Guides,
    but let''s cover it in brief here anyway. Routing allows you to keep the application''s
    state in the page URL via the URL''s hash (the hash is everything after the `#`
    symbol in a URL). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us we''re on a page about bananas. Likewise, look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This shows that we're on a page about car number `56`. The beauty of using the
    hash is that it can be manipulated with JavaScript without reloading the page.
    Also, any change made to the hash symbol will be remembered by the browser's history.
    This means that we can navigate around our application and use the back button
    to retrace our steps. It also means that if we can bookmark a specific page in
    the application when it reloads the app, it will navigate to the state specified
    in the hash symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Back to business
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How do we implement routes in the `Instrumatics` app? The first step is to
    actually define a route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first part is the hash we're trying to match. Nothing's been specified apart
    from `:viewReference`, so in this case, everything in the hash symbol gets captured
    and passed on to a method called `onNavigate`. The name of the `:viewReference`
    token is arbitrary, in this it doesn't affect anything else, but in more complex
    routes, it's useful to name it in a descriptive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are we trying to achieve here? When the hash symbol changes, we want to
    detect it and redirect the user to the correct page. The route definition does
    the detection part, so now let''s look at how we move the user to the right page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The route definition means that all matching routes will be consumed by `onNavigate`.
    In this method, we can assume that the token passed in is a valid reference to
    a component on the view controller's view, so we just lookup the component using
    this reference and set it as the active tab on the "main" view.
  prefs: []
  type: TYPE_NORMAL
- en: We're missing something though, that is, how does the hash get set in the first
    place?
  prefs: []
  type: TYPE_NORMAL
- en: Route to nowhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the listen configuration for the view controller, we handle the "main" tab
    panel''s `tabchange` event with the `onTabChange` method. This grabs the reference
    config from the tab the user is changing to and passes it to the view controller''s
    `redirectTo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `redirectTo` method simply changes the hash in the URL, in this case, to
    the reference of the new component. It's a simple approach that gives us a powerful
    way to improve the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the application infrastructure in place, so it's time to build out the
    components that are going to rest on this infrastructure. First up is the dashboard,
    something that requires us to carefully consider how to implement the rest of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashboard consists of two live charts and two historical charts. The live
    charts are very similar to each other, as are the historical charts (just some
    minor formatting and binding configuration between them). However, in order to
    build a chart, you also have to build the axes and the series being drawn on it,
    which results in a fairly long-winded configuration object. Here''s what the historical
    log chart from the dashboard will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We have configured a chart with a line series that has a numeric
    left axis and a time-base bottom axis. This is exactly what we need for the dashboard,
    so where's the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Duplication is the problem. The majority of this configuration object would
    be duplicated, one copy for the web logs and one copy for the SQL logs. We've
    mentioned before in this chapter that we'd like to battle duplication where possible,
    so in this case, we will create a new class that we can reuse in places where
    we need a chart to plot historical requests from the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It combines the basic definition of the chart, such as the axes and series,
    with things we know we'll reuse across the application, such as the title on the
    left axis.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're putting this class in a different location from anything we've
    seen so far in our example applications, but one that we discussed in [Chapter
    3](ch03.html "Chapter 3. Application Structure"), *Application Structure*. The
    `ux` namespace and corresponding directory is a fairly standard location for reusable
    classes in the Ext JS community, so we will follow this convention here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create another reusable class, this time for the live request chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that this code has a lot in common with the code from our code
    investigation earlier in the chapter. It's just that we've wrapped it up into
    a reusable class.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these new classes ready to go, creating the dashboard is just a matter
    of piecing together what we''ve already written, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Rather than duplication of the configuration that forms the charts, we'll just
    put together the containers—which use the `vbox` and `hbox` layouts—and set up
    titles, formatting, and bindings.
  prefs: []
  type: TYPE_NORMAL
- en: This is great. Rather than duplicating code and having lots of unnecessary configuration
    in the dashboard view itself, we've moved this code to a more logical location,
    promoting reuse and making for a tidier code base.
  prefs: []
  type: TYPE_NORMAL
- en: Constant evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, let''s look at what we''ve built in comparison with our design.
    It matches our implementation so far, but there wasn''t any mention of these reusable
    classes. There are two ways of looking at this:'
  prefs: []
  type: TYPE_NORMAL
- en: We didn't go far enough in our design and missed an opportunity to spell out
    exactly what we needed to build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw an opportunity to refactor our code after we found ourselves duplicating
    something we'd already written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's something to be said for both these viewpoints; however, in [Chapter
    5](ch05.html "Chapter 5. Practical – a CMS Application"), *Practical – a CMS Application*,
    we discussed YAGNI—you aren't going to need it—which dictates that there's little
    point in planning for reuse if the component in question is never going to be
    reused.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the implementation process revealed that we'd have some duplication,
    so we refactored. While taking careful consideration at the design stage is important,
    re-evaluating our decisions and code should be an ongoing process, so it's critical
    to realize that even if there's a feeling that something should have been noticed
    in the design phase, nothing is set in stone. We can always change things as long
    as we understand why they need to change and use it as a learning experience.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard view model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the four charts in the dashboard has its own data source and these
    are specified in the bind configuration for each. The definitions for these sources
    are in the dashboard view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We're setting up the data sources for the dashboard. If you look back at the
    associated store definitions, you'll see matching aliases and also the `remoteFilter`
    option set to `true`. This enables us to set the filter on the store definition
    in the view model and have these passed through to the server as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This makes for a very simple method to set up stores to retrieve filtered data
    from the server side (just pass over an array of filters and let the backend take
    care of it).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve put together nearly all the pieces of the dashboard with one exception:
    the view controller. Let''s look at this now.'
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard view controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There isn''t any interactivity on the dashboard, so there''s not much for the
    view controller to do. We''ll use it to control the live refresh aspect of the
    charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as this; every second, grab the store powering the live chart
    and call its load method with the `addRecords` option set to `true`. This will
    cause new records to be appended to the store rather than overwriting old records.
  prefs: []
  type: TYPE_NORMAL
- en: While there's not much code here, there are a couple of discussion points. We
    could have avoided using a view controller at all for the dashboard and baked
    this refresh behavior directly in the `LiveRequestChart` class, maybe setting
    the refresh rate via a configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: By doing it in the controller, we get the chance to centralize the place in
    which the refresh rate is set. This isn't a massive win though. There's definitely
    a case to be made for moving this into the UI class. It's another situation where
    there's no right or wrong way of doing things; multiple options are available
    and it's better to pick one and move on than be paralyzed with the choices on
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: We've got the first page of our application, so let's now move on to the subpages,
    starting with the web logs.
  prefs: []
  type: TYPE_NORMAL
- en: Web logs subpage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already built part of this screen already. We can reuse `Instrumatics.ux.chart.HistoricalRequestChart`
    we created earlier to display the trend for a specified date range. As this data''s
    coming from the store, we can simply filter the store and don''t have to do anything
    on the component itself. With this in mind, the **Web** view looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It's a fair amount of code, but nothing other than component configuration is
    happening here. Let's break it down step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, there's the configuration of the panel itself where we set up a `vbox`
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add our first item, an instance of the `HistoricalRequestChart` we built
    earlier, and add `To` and `From` date fields to its header. The values of these
    are bound to values (`currentStartDate` and `currentEndDate`) in the view model,
    and the chart itself is bound to `logData` in the view model.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the configuration of the statistics grid. Its store is bound
    to `logStatistics` and in its header, we add a combo box that has its value bound
    to `currentCategory` in the view model and its store—to provide the combo box
    options—bound to categories. The combo box allows the user to choose which statistics
    category they'd like to view.
  prefs: []
  type: TYPE_NORMAL
- en: Onwards and upwards to the view model!
  prefs: []
  type: TYPE_NORMAL
- en: A view on the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Web view model follows our design and fleshes it out with some implementation
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note the bindings on the filters. This enables us to link the filters with a
    value on the view model, which in turn links through to values on the form controls
    in the view. This means that as soon as the user updates a form control, it'll
    update the filter on the store automatically, reloading the store, and redrawing
    the chart and grid.
  prefs: []
  type: TYPE_NORMAL
- en: We've also got a `categories` store, which is simply a way of holding data for
    the categories combo, nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well here's a thing, this view has no corresponding view controller! In previous
    versions of Ext JS, we'd be listening for change events on the date fields and
    combo box, then grabbing the changed value and reloading the store with it.
  prefs: []
  type: TYPE_NORMAL
- en: In the brave new world of view models though, we don't need to do this. When
    a date field updates, it automatically updates the corresponding view model value,
    which in turn updates the store's filter.
  prefs: []
  type: TYPE_NORMAL
- en: We're already setting up the stores and the form components, so by adding an
    extra sprinkle of magic in the form of bind configurations, Ext JS will power
    all of this for us. This means less custom code for us to write, which can only
    be a good thing!
  prefs: []
  type: TYPE_NORMAL
- en: More and more subpages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that the other subpage in our application, the SQL log page, is going
    to be very similar to the web log page. This should be raising an eyebrow with
    regard to code duplication. We could pull out the grid and the chart header from
    the **Web** view into separate classes and turn them into reusable components,
    but is this the right thing to do? These components won't be reused! They have
    their place in only one location in the application to power the subpages. Unlike
    `HistoricalRequestChart`, which is used in both the dashboard and the subpages,
    these are only needed for one job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another approach: *subclassing*. We could create a new component
    that contains the chart, form fields, and grid from the **Web** view, and add
    some configuration options that give us the customization we need. This might
    look like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve pulled the entire configuration from the **Web** view into this base
    class called `SubPage` and separated out the key components, namely, the chart
    and the grid. We''re also harnessing the power of the Ext JS class system by wrapping
    these in the config section, which not only generates get and set methods for
    `gridCfg` and `chartCfg`, but also provides us with a shortcut to override parts
    of these config objects. Let''s demonstrate by showing the **SQL** view, which
    is powered by our new `SubPage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Yep, that's it! We've managed to get the same functionality that the **Web**
    view had, but reusing lots of the code. Note that `chartCfg` is exposed for us
    to configure, which means that all we have to do is set `viewModel` and the chart's
    title configuration and we're all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turns out we can do the same for the view model too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following SQL view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The **Web** and **SQL** views now share code in a logical way without polluting
    our UX namespace with classes that don't belong there. In future, we could easily
    add on more views like this, but for now, we've got a fantastic way to avoid code
    duplication and keep our application well structured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've built a second practical application and talked a lot
    about how a design can change as an application develops. While we produce an
    initial application architecture with the best of intentions and the knowledge
    we have hand as the application develops, it's important to be flexible in order
    to produce a successful final product. We also introduced routing, more on data
    binding, and showed how code can be reused in a variety of ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll build an application that will be familiar to most
    readers: an e-mail client. It''ll be a responsive app tailored for both desktop
    and tablet, and we''ll once again take the ideas we''ve already discussed and
    develop them even further.'
  prefs: []
  type: TYPE_NORMAL
