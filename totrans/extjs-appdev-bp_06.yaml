- en: Chapter 6. Practical – Monitoring Dashboard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 实践 - 监控仪表板
- en: Now that we've started applying the things we've learned to a real-world application,
    we're going to gradually ramp up the complexity of the projects we build. By designing
    and creating a code base that imitates something an actual customer might pay
    money for, we're not coding abstract examples that exist in isolation. We're building
    something that showcases some of the design decisions you will likely face as
    a software architect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始将所学应用到实际应用中，我们将逐步增加我们构建的项目复杂性。通过设计和创建一个模仿实际客户可能付费的代码库，我们不是编写孤立存在的抽象示例代码。我们正在构建一些可以展示作为软件架构师你可能会面临的一些设计决策的东西。
- en: In this chapter, we'll build a monitoring dashboard that can be used to view
    metrics from an application server. Developers and system administrators will
    use applications like this to visualize the performance of their servers and monitor
    load at any given time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个监控仪表板，可以用来查看应用程序服务器的指标。开发人员和系统管理员将使用此类应用程序来可视化其服务器的性能，并在任何给定时间监控负载。
- en: 'Such an application could be used for internal monitoring, or it could be deployed
    as a **Software as a Service** (**SaaS**) that could be resold to other users.
    Either way, it will serve as a great demonstration of the power of view models;
    we''ll be expanding what we already know and will be using it in a more advanced
    way to shape the data we receive from the server. In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用可以用于内部监控，或者它可以作为**软件即服务**（**SaaS**）部署，可以被其他用户转售。无论哪种方式，它都将作为视图模型强大功能的绝佳展示；我们将扩展我们已知的内容，并以更高级的方式使用它来塑造我们从服务器接收到的数据。在本章中，我们将涵盖以下内容：
- en: Designing the user interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Designing our data layer from the `Ext.data.Model` through to the view models
    needed to support our UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Ext.data.Model`到支持我们UI所需的视图模型的数据层设计
- en: Using multiple view controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个视图控制器
- en: Building components that are reused across views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建跨视图可重用的组件
- en: Adding routing to allow users to bookmark each screen of the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路由以允许用户将应用程序的每一屏添加到书签
- en: Using view model filters to focus our view of the underlying data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图模型过滤器来聚焦我们对底层数据的视图
- en: By the end of the chapter, we'll have fleshed out the concepts we've already
    begun to cover and introduced some new features (such as routing). These are important
    when designing the user experience for an application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将完善我们已经开始介绍的概念，并引入一些新功能（例如路由）。这些在为应用程序设计用户体验时非常重要。
- en: We're going to approach this as if we're designing an internal program, one
    that monitors another application in our theoretical software development shop.
    Although this means we're not bound by external customer requirements, it's still
    important that we follow all of the design guidelines we've already learned. This
    maybe an internal application, but it's still got to be robust, meet the expectations
    of stakeholders, and be maintained in the future.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像设计一个内部程序一样来处理这个问题，这个程序监控我们理论上的软件开发店中的另一个应用程序。虽然这意味着我们不受外部客户需求约束，但遵循我们已学到的所有设计指南仍然很重要。这可能是一个内部应用，但它仍然需要健壮，满足利益相关者的期望，并在未来得到维护。
- en: Application design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: 'This application will have several screens to view the various properties of
    the app being monitored. We''ll have a dashboard screen that shows an overview
    of the important metrics being monitored. Then, for each of these metrics, we''ll
    have individual screens that allow the user to drill down and filter the data.
    As each of these screens will be variations on a common theme, we''ll only build-out
    a couple to demonstrate the concepts, but the framework we''ll build with this
    application means it would be trivial to add more. The **Dashboard** tab can be
    seen in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将有几个屏幕来查看被监控应用程序的各种属性。我们将有一个仪表板屏幕，显示正在监控的重要指标概览。然后，对于这些指标中的每一个，我们将有单独的屏幕，允许用户深入挖掘和筛选数据。由于这些屏幕将是同一主题的变体，我们只构建几个来展示概念，但这个应用我们将构建的框架意味着添加更多将变得非常简单。以下截图显示了**仪表板**选项卡：
- en: '![Application design](img/5308OT_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_06_01.jpg)'
- en: 'The **Web** tab is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络**选项卡如下：'
- en: '![Application design](img/5308OT_06_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_06_02.jpg)'
- en: 'As users, what do we want to see in this monitoring application? We want information
    at a glance, but with the ability to easily get detailed information. Our primary
    concerns are the response times of web requests and queries to the database, so
    we want both these metrics available to us. Let''s think about the user interface
    that supplies this information and what it might look like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，我们希望在监控应用程序中看到什么？我们希望一目了然的信息，但同时又能够轻松获取详细信息。我们主要关注的是Web请求和数据库查询的响应时间，因此我们希望这两个指标都可用。让我们考虑提供这些信息的用户界面及其可能的外观：
- en: '![Application design](img/5308OT_06_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_06_03.jpg)'
- en: On the **Dashboard** tab, we're using charts to convey trend information—about
    both the short-term and the longer term—and this provides our at a glance view
    of the data. The top two charts update in real time to show the average response
    time, whereas the bottom charts show historical trends for comparison. How about
    getting details on this data?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在**仪表板**选项卡上，我们使用图表来传达趋势信息——关于短期和长期的趋势——这为我们提供了数据的快速查看。前两个图表实时更新以显示平均响应时间，而底部的图表显示历史趋势以供比较。关于这些数据的详细信息如何？
- en: 'Also, we''ve added tabs on the left-hand side of the screen that allow you
    to switch between log types. In this application, we''ve just got **SQL** and
    **Web** in addition to the initial **Dashboard** view, as shown in the following
    screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在屏幕左侧添加了标签页，允许您在日志类型之间切换。在这个应用程序中，我们除了初始的**仪表板**视图外，还有**SQL**和**Web**，如下面的截图所示：
- en: '![Application design](img/5308OT_06_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_06_04.jpg)'
- en: In the main part of the screen, we've got a set of controls to filter the data.
    The chart and grid underneath will update depending on the results of the filter.
    This gives the user the ability to view data within a particular date range. It
    also gives the user the ability to pick the category of detail to drill down.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的主要部分，我们有一组控件来过滤数据。下面的图表和网格将根据过滤结果进行更新。这使用户能够查看特定日期范围内的数据。它还使用户能够选择要深入查看的详细类别。
- en: 'What sort of categories? It could be extended in future, but here''s our current
    list for the **Web** tab:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些类别？未来可能会扩展，但以下是当前**Web**标签页的列表：
- en: Location
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: Browser
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: Type of device
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备类型
- en: We're displaying information on the web requests in our date range to provide
    more insight on who is visiting our application. Are we getting lots of visitors
    from Japan? Are they experiencing unacceptably high response times? Maybe we need
    to add a server somewhere in Asia to meet their requirements. Are we seeing a
    lot of tablet users? Do we need to improve our responsive design to better cope
    with a tablet screen size?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的日期范围内显示Web请求的信息，以提供更多关于谁访问我们应用程序的洞察。我们是否有很多来自日本的访客？他们是否遇到了无法接受的响应时间？也许我们需要在亚洲某处添加服务器以满足他们的需求。我们是否看到了很多平板用户？我们是否需要改进我们的响应式设计以更好地应对平板屏幕大小？
- en: 'On the SQL front, we''ve got:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL方面，我们有：
- en: Query type (select, insert, update, and so on)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型（选择、插入、更新等）
- en: Slowest queries
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最慢的查询
- en: Query sources
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询来源
- en: The first is just general information; you could see whether your application
    was read-heavy or write-heavy here, which would inform how your technology stack
    changes over time. The other two go hand in hand, showing the slowest queries
    and which pages in the application issue most queries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是基本信息；您可以看到应用程序是读多写少还是写多读少，这将告知您的技术堆栈如何随时间变化。其他两项相辅相成，显示了最慢的查询以及应用程序中哪些页面发出最多的查询。
- en: These metrics are useful to increase transparency in an application. In some
    cases, they won't be enough to diagnose subtle issues, but they will be invaluable
    in showing the trends of how your application and users are behaving.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标有助于提高应用程序的透明度。在某些情况下，它们可能不足以诊断微妙的问题，但它们在显示应用程序和用户行为趋势方面将非常有价值。
- en: Requirements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: We've established the ideal UI for our application, but how does this translate
    into technical requirements?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的应用程序确定了理想的用户界面，但这是如何转化为技术要求的？
- en: We want line charts to show trends
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望折线图显示趋势
- en: We want these charts to be able to update when they receive new data
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望这些图表能够在接收到新数据时更新
- en: We want to be able to choose a date range and update charts and grids accordingly
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够选择日期范围，并相应地更新图表和网格
- en: We want to be able to choose a data category and have grids update accordingly
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够选择数据类别，并相应地更新网格
- en: 'Let''s look at each of these in the context of Ext JS:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Ext JS 的背景下看看这些：
- en: Ext JS charts have area, line, scatter series, and so on, so we can plot the
    data in a way that allows you to visualize a trend.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 图表具有区域、线、散点系列等，因此我们可以以允许您可视化趋势的方式绘制数据。
- en: The `load` method of `Ext.data.Store` can accept an `addRecords` parameter,
    which when set to `true` will cause newly loaded records to be appended to the
    store rather than overwriting the existing data. This will allow us to provide
    update data to a chart.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.data.Store` 的 `load` 方法可以接受一个 `addRecords` 参数，当设置为 `true` 时，将导致新加载的记录被追加到存储中，而不是覆盖现有数据。这将使我们能够向图表提供更新数据。'
- en: Ext JS provides a date field component that can be linked to a view model to
    filter data based on a date range.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 提供了一个日期字段组件，可以链接到视图模型以根据日期范围筛选数据。
- en: Grids have a reconfigure method that allows you to change the columns of the
    grid on the fly if necessary.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格有一个重新配置的方法，允许你在必要时动态地更改网格的列。
- en: Looks good!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！
- en: Message received and understood
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息已接收并理解
- en: We've set out our own criteria for this project, but we're still being explicit
    at spelling out what we need before we start coding, and we're making sure that
    our technical framework will support what we need. Why not just get on with the
    job and put fingers to keyboards?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这个项目制定了我们自己的标准，但在开始编码之前，我们仍然在明确地列出我们需要的东西，并确保我们的技术框架将支持我们的需求。为什么不直接开始工作，把手指放在键盘上呢？
- en: Although this isn't a job that has an explicit paying customer, it's still something
    that needs accountability. It's not enough as a professional developer to say
    that it'll be "done when it's done" because this attitude won't wash with the
    people who pay your salary. We must plan our projects in as much detail as to
    give us confidence in the delivery of our work—both from a time and quality perspective—as
    possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个有明确付费客户的工作，但这仍然是需要问责的事情。作为一个专业的开发者，仅仅说“完成时完成”是不够的，因为这种态度不会得到支付你薪水的人的认可。我们必须尽可能详细地规划我们的项目，以便从时间和质量的角度对我们工作的交付有信心。
- en: No matter who we are building software for, we must always strive to create
    something robust, something that meets or exceeds expectations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们为谁构建软件，我们都必须始终努力创造一些稳健的东西，一些能够满足或超出期望的东西。
- en: Data structure
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: We will make an assumption in this chapter, that is, we have a friendly backend
    developer on our team who's able to provide us data in the format we need. Let's
    flesh out our requirements for the data that will power our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做出一个假设，即我们团队有一个友好的后端开发者，他能够以我们需要的格式提供数据。让我们具体说明我们将为驱动我们应用程序的数据提出的要求。
- en: Another assumption is that we're looking for trends and statistics here, so
    we're going to be basically aggregating logs into something more suitable for
    user consumption.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个假设是我们在这里寻找趋势和统计数据，因此我们将基本上将日志聚合为更适合用户消费的东西。
- en: Live charts
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时图表
- en: 'We planned to have two "live" charts on the dashboard (one to show SQL queries
    as they come in, and one to show web requests). In order for this to work, we
    need a URL we can poll every second or so. This will provide us with data on the
    last second of activity. Something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在仪表板上有两个“实时”图表（一个用于显示传入的 SQL 查询，另一个用于显示网络请求）。为了使这可行，我们需要一个每秒或大约一秒可以轮询的 URL。这将为我们提供关于过去一秒钟活动数据。类似于这样：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `GET` request to `/logs/all/live` gives us an array of objects, one for each
    log type. As mentioned, we're restricting ourselves to SQL and the Web only. The
    `ms` property is the average response time of the operations that occurred in
    the past second. The `count` property is the number of operations that took place.
    We designed the API with a little bit of flexibility in mind, so it could be extended,
    for example, replace `"all"` in the URL with `"sql"` to filter on one log type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `/logs/all/live` 的 `GET` 请求给我们一个对象数组，每个日志类型一个。如前所述，我们只限制在 SQL 和网络。`ms` 属性是过去一秒钟发生的操作的平均响应时间。`count`
    属性是发生的操作数量。我们设计这个 API 时考虑到了一点灵活性，所以它可以扩展，例如，将 URL 中的 `"all"` 替换为 `"sql"` 以过滤单个日志类型。
- en: Historical logs
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史日志
- en: 'On the dashboard and the subpages of our application, we also need to show
    graphs of historical data. On the dashboard, it''ll be from the past 30 days,
    but on the subpages, it could be an arbitrary time frame. Here''s our API:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的仪表板和子页面上，我们还需要显示历史数据的图表。在仪表板上，它将是过去 30 天的数据，但在子页面上，可能是一个任意的时间范围。这是我们的
    API：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''re going to rely on a feature of `Ext.data.Store: remoteFilter`. When this
    is set to `true`, Ext JS will defer filtering to the server and pass through the
    filter criteria as a JSON array. We can set an arbitrary number of filters, so
    in order to get SQL data within a date range, we''d be passing something like
    this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将依赖于`Ext.data.Store: remoteFilter`功能。当此设置为`true`时，Ext JS将延迟过滤到服务器，并将过滤条件作为JSON数组传递。我们可以设置任意数量的过滤器，因此为了在日期范围内获取SQL数据，我们将传递类似以下内容：'
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our kind server-side developer will combine these filters into something that
    returns the correct response.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们那位友好的服务器端开发者会将这些过滤器组合成返回正确响应的东西。
- en: Log statistics
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志统计
- en: 'As well as general aggregated information about Web and SQL operations, we
    also want to display a grid of further detail on our tab pages. Again, these will
    be filterable based on the date range as well as the category of information we
    want to view:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于Web和SQL操作的一般聚合信息外，我们还想在我们的标签页上显示更详细的网格。同样，这些信息将可以根据日期范围以及我们想要查看的信息类别进行筛选：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're using the `remoteFilter` feature again, meaning that Ext JS just passes
    the JSON filter straight through to the server as well as the `type` and `time`
    parameter from before. This time, we will add a `category` parameter to specify
    what subset of information—such as location for web logs or query source for SQL—we'd
    like to retrieve.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`remoteFilter`功能，这意味着Ext JS将直接将JSON过滤器以及之前的`type`和`time`参数传递到服务器。这次，我们将添加一个`category`参数来指定我们想要检索的信息子集——例如，对于Web日志是位置，对于SQL是查询源。
- en: In response, we get an array of all of the items within the chosen category
    and the percentages allocated to each one over the specified time frame.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，我们得到一个数组，其中包含所选类别中的所有项目以及它们在指定时间段内分配的百分比。
- en: Model behavior
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型行为
- en: 'We''ve got our API. How does this translate into the JavaScript data models
    we''ll need? Well, we only need two—look at the API responses we just documented—the
    `/logs` returns one type and `/statistics` returns another type. They''ll look
    something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了我们的API。这如何转化为我们需要的JavaScript数据模型？嗯，我们只需要两个——看看我们刚刚记录的API响应——`/logs`返回一种类型，`/statistics`返回另一种类型。它们看起来可能像这样：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What''s this `BaseModel` all about? In order to share schema configuration
    between models, we can use a base model from which all other models inherit. It
    looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这`BaseModel`究竟是怎么回事？为了在模型之间共享模式配置，我们可以使用一个基模型，其他所有模型都从这个基模型继承。它看起来像这样：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the model for statistics is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，统计模型的如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `percentage` field represents the proportion of operations that are represented
    by this statistic. For example, if `category` is `location` and `label` is `Japan`,
    then the percentage could be something like `5 percent` (5 percent of our requests
    come from Japan). This is flexible enough to be used for all the data categories
    we'd like to view.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`percentage`字段表示由这个统计数字表示的操作比例。例如，如果`category`是`location`且`label`是`Japan`，那么百分比可能类似于`5
    percent`（我们5%的请求来自日本）。这足够灵活，可以用于我们想要查看的所有数据类别。'
- en: 'Finally, we need one for the live log stream:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要一个用于实时日志流：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The log stream has the same fields as the `LogEntry` model, but we have it as
    a separate class, so its class name can affect the schema configuration. We'll
    go into more detail later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 日志流具有与`LogEntry`模型相同的字段，但我们将其作为一个单独的类，因此其类名可以影响模式配置。我们将在稍后详细介绍。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We're lucky with this theoretical API; in this, we are allowed to shape our
    requirements. In the real world, it might not be that simple, but having a friendly
    backend developer will always make our lives as frontend developers much easier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个理论上的API，我们很幸运；在这里，我们可以塑造我们的需求。在现实世界中，事情可能不会那么简单，但有一个友好的后端开发者将始终使我们的前端开发者生活变得更加容易。
- en: Our API has strongly informed our data layer. While it's great to keep things
    simple—as we've been able to here—it's important not to mistake simplicity for
    naivety or inflexibility. In this case, our UI components will happily work with
    our data layer, which in turn works with our API without having to shoehorn any
    one piece into working with the others.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API对我们的数据层产生了强烈的影响。虽然保持简单是很好的——正如我们在这里所做的那样——但重要的是不要将简单误认为是天真或缺乏灵活性。在这种情况下，我们的UI组件将愉快地与我们的数据层一起工作，而我们的数据层反过来又与我们的API一起工作，无需将任何单个组件强行与其他组件一起工作。
- en: The view from the top
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从高处看
- en: 'We have the fuel for our application; the data will bring life to the coding
    engine we''re about to build. We now need to establish controllers that will constitute
    this engine and views that will give us a user interface to control and visualize
    it. Consider the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的应用程序提供了燃料；数据将为我们将要构建的编码引擎带来生命。我们现在需要建立构成这个引擎的控制器和将为我们提供用户界面以控制和可视化的视图。考虑以下截图：
- en: '![The view from the top](img/5308OT_06_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![从顶部看](img/5308OT_06_05.jpg)'
- en: For the outer area marked as **1**, we have a main view that provides a container
    for other views. This will have a corresponding view controller that will manage
    any cross-application concerns from the main's subcomponents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标记为**1**的外部区域，我们有一个主要视图，为其他视图提供容器。这将有一个相应的视图控制器，用于管理主子组件的任何跨应用程序关注点。
- en: For the inner section marked as **2**, we have the dashboard view, a container
    for four charts. Its view controller will manage the live updates of the top two
    charts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标记为**2**的内部部分，我们有仪表板视图，四个图表的容器。其视图控制器将管理顶部两个图表的实时更新。
- en: 'Each subpage will add an additional view (see **3**), for example, a **Web**
    view and an associated view controller. It will present and control the historical
    log chart, the statistics grid, and user input to the filtering date fields and
    button, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子页面都会添加一个额外的视图（见**3**），例如，一个**Web**视图和相关视图控制器。它将展示并控制历史日志图表、统计网格以及用户输入到过滤日期字段和按钮，如下所示：
- en: '![The view from the top](img/5308OT_06_06.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![从顶部看](img/5308OT_06_06.jpg)'
- en: 'Here''s how all our classes interact:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了我们所有课程之间的交互方式：
- en: '![The view from the top](img/5308OT_06_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![从顶部看](img/5308OT_06_07.jpg)'
- en: 'We''ve got the general picture of our application classes. Let''s drill down
    and look at the details of each class in turn:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了应用程序类的大致情况。让我们深入挖掘，依次查看每个类的详细信息：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main view is a tab panel that contains all subpages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 主要视图是一个标签面板，包含所有子页面：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we mentioned, the main controller deals with things that concern the whole
    application. It''s responsible for swapping between the dashboard and subpages
    `onTabChange` and decides what action to take if the URL changes `onNavigate`.
    Four instances of `Ext.chart.CartesianChart` to display the various line charts
    that we need on the dashboard, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，主要控制器处理与应用程序整体相关的事务。它负责在`onTabChange`时在仪表板和子页面之间切换，并在URL更改时决定采取什么行动`onNavigate`。四个`Ext.chart.CartesianChart`实例用于显示仪表板上所需的各类折线图，如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need some code to set up our live-updating charts, so we do this in `initializeChartRefresh`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些代码来设置我们的实时更新图表，所以我们在这`initializeChartRefresh`中这样做：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Ext.app.ViewModel` is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.app.ViewModel`如下所示：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The view model for the dashboard sets out four separate sources of data, one
    for each of the charts:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板的视图模型概述了四个独立的数据源，每个图表一个：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The associated view controller is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的视图控制器如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ah! This is a pretty sparse view controller for a view, which is actually doing
    quite a lot. Let''s look at the view model and things might become a bit clearer:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！这是一个相当稀疏的视图控制器，实际上它做了很多工作。让我们看看视图模型，事情可能会变得稍微清晰一些：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The plan is to pull the historical log data and the statistics about this log
    data from a couple of stores. We'll have another that holds the categories that
    the user can use to filter the grid view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 计划从几个存储中提取历史日志数据和关于此日志数据的统计信息。我们还将有一个存储用户可以使用来过滤网格视图的类别。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's arguable that the categories could be held in the part of the user interface
    that filters the data in a completely separate store. However, it also makes sense
    to hold the data for a view in one place—the view model—and not over complicate
    things by adding another unnecessary store class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有争议的是，类别可以存储在用户界面的一部分，该界面完全独立地过滤数据，在完全分开的存储中。然而，将视图的数据存储在一个地方——视图模型中——并且不通过添加另一个不必要的存储类来使事情复杂化也是有意义的。
- en: The key part of this view model comes when we think about the current state
    of the application. For this subpage, it'll be stored in the `currentCategory`,
    `currentStartDate`, and `currentEndDate` variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑应用程序的当前状态时，这个视图模型的关键部分出现了。对于这个子页面，它将存储在`currentCategory`、`currentStartDate`和`currentEndDate`变量中。
- en: As we're keeping all of the state in the view model, we can bind to the UI controls
    that set this state and in turn bind these values to a `store` filter. This means
    that changing the value using the UI will automatically change the filter value
    without requiring any glue code in the controller.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在视图模型中保持所有状态，我们可以将UI控件绑定到设置此状态，并反过来将这些值绑定到一个`store`过滤器。这意味着使用UI更改值将自动更改过滤器值，而无需在控制器中添加任何粘合代码。
- en: This implementation requires a strong understanding of the power of view models
    and a thoughtful eye for the design of the application. We'll go into detail on
    this later when we write the code for this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现需要深刻理解视图模型的力量，以及对应用程序设计的深思熟虑。我们将在编写这一部分的代码时详细说明这一点。
- en: The last part of the application is the SQL subpage. This is essentially the
    same as the web subpage, but displaying a different set of information, so we
    won't go into detail about its design.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最后一部分是SQL子页面。这基本上与Web子页面相同，但显示不同的信息集，所以我们不会详细说明其设计。
- en: Flexibility and pragmatism
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性和实用主义
- en: Something that we're yet to discuss in detail is how a design can change over
    time. We're setting out our thoughts on what we think our application should look
    like, but until we write it, we won't know all of the ins-and-outs of the exact
    implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未详细讨论的是设计如何随时间变化。我们正在阐述我们认为我们的应用程序应该是什么样子，但直到我们编写它，我们不会知道确切实现的全部细节。
- en: It's important to undertake a constant re-evaluation of the work that's taking
    place to ensure that the quality of what's being written remains high. We've documented
    our design earlier, but in one key place, we've also had the realization that
    subpages will be very similar to each other.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对正在进行的工作进行持续的再评估非常重要，以确保所写内容的品质保持高标准。我们之前已经记录了我们的设计，但在一个关键的地方，我们也意识到子页面之间将非常相似。
- en: Depending on how these similarities are fleshed out in code, there could be
    scope for refactoring and reusing in a way that isn't immediately clear when drawing
    up the design document. However, if the implementation does turn out to be sufficiently
    similar with only minor variations between each subpage, then we need to look
    at extracting this code into a reusable class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些相似性在代码中的具体实现，可能存在重构和重用的空间，这在设计文档绘制时并不明显。然而，如果实现确实足够相似，每个子页面之间只有细微的差异，那么我们需要考虑将此代码提取到一个可重用的类中。
- en: Code duplication—and even worse, copying and pasting code—is a very good way
    of ending up with a messy code base. In the event you need to change something,
    tweak behavior, add a feature, or fix a bug, you'll have to do the same thing
    in several places, increasing the overhead of the change and increasing the chance
    that more mistakes will creep into your code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重复——甚至更糟，复制和粘贴代码——是导致代码库混乱的非常好的方式。在你需要更改某些内容、调整行为、添加功能或修复错误的情况下，你必须在几个地方做同样的事情，这会增加更改的开销，并增加更多错误渗入代码的机会。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Copy and pasting is a blight on your code base. By blindly duplicating code,
    your developers are not applying any critical analysis. They are increasing the
    size of your code base unnecessarily and could well be introducing bugs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复制和粘贴是代码库的祸害。通过盲目地复制代码，你的开发者没有进行任何批判性分析。他们正在不必要地增加代码库的大小，并且很可能会引入错误。
- en: Later in this chapter, we'll begin building out the code for this application.
    We'll also keep a close eye out for anything that looks like it might be duplicating
    what went before. In these cases, we'll take some time out to see whether there's
    functionality we can encapsulate and reuse.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将开始构建这个应用程序的代码。我们还将密切关注任何可能重复之前内容的迹象。在这些情况下，我们会花些时间看看是否可以封装和重用某些功能。
- en: Ext JS provides multiple methods to structure code—such as inheritance and mixins—and
    taking advantage of these methods will result in an application that is much easier
    to maintain and extend.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS提供了多种方法来结构化代码——例如继承和混入——利用这些方法将导致一个易于维护和扩展的应用程序。
- en: Does this hurt?
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这会伤害吗？
- en: We've got our design in place, from top to bottom, so now it's time to cast
    a critical eye over it. Are there any unknown aspects of the design or are there
    any potential pain points? The live-updating chart is a little bit of a black
    box right now. While we know that charts support animation (via the `animate`
    **configuration** option), we want to be certain that the axis on the chart can
    update as the new data comes in. It's worth doing a very simple test to make certain
    this'll work. To do this, we're going to go a little bit retro.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计已经从上到下完成，现在是对其进行批判性审视的时候了。设计中是否有任何未知方面，或者是否有潜在的痛点？实时更新的图表现在有点像黑盒。虽然我们知道图表支持动画（通过`animate`
    **配置**选项），但我们想确保图表的轴可以随着新数据的到来而更新。进行一个非常简单的测试以确保它能工作是值得的。为此，我们将稍微回到过去。
- en: 'Rather than using Sencha Cmd and the whole Bootstrap process, we''re going
    to link directly to the files we need and use `Ext.onReady` to run our code. Here''s
    the empty template:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接链接到所需的文件，并使用`Ext.onReady`来运行我们的代码，而不是使用Sencha Cmd和整个Bootstrap过程。以下是空模板：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve created an HTML page that links to the JS files for Ext JS and Sencha
    Charts as well as the CSS for one of the Ext JS Themes. In the body of the HTML,
    we will create a div with an ID of "chart" to render into and then an `Ext.onReady`
    block where we''ll place the bulk of our code. First, let''s set up a store in
    here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个HTML页面，其中链接到Ext JS和Sencha Charts的JS文件以及一个Ext JS主题的CSS。在HTML的主体中，我们将创建一个ID为"chart"的div来渲染，然后是一个`Ext.onReady`块，我们将在这里放置大部分代码。首先，让我们在这里设置一个存储：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Variables for the current time "from" and "to" times for the chart axis is
    shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前时间“from”和图表轴的“to”时间变量在此处显示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And then the chart itself:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是图表本身：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s add some data to the store:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向存储中添加一些数据：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Every second, we add a new record to the store with the current time and a random
    value. After running this code, we get a line chart that updates every second,
    fantastic! However, while this is pretty close to what we need, there is a problem.
    As the line approaches the right-hand side of the chart, it just disappears off
    the canvas. We need to somehow update the bottom axis of the chart when we update
    its data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟，我们向存储中添加一条包含当前时间和随机值的记录。运行此代码后，我们得到一个每秒更新的折线图，非常棒！然而，虽然这已经很接近我们需要的了，但有一个问题。当线条接近图表的右侧时，它就消失在画布之外了。我们需要在更新数据时以某种方式更新图表的底部轴。
- en: 'The chart has a `redraw` event that we can use for just this purpose. What
    we''ll try to do is move the `from` date and the `to` date located at the bottom
    axis forward by `15` seconds. As the `redraw` event will be triggered every second,
    thanks to our store updating via the `setInterval` call, every fifteenth time
    the `redraw` event is fired, we update the axes. This is how it looks in code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图表有一个`redraw`事件，我们可以用它来达到这个目的。我们将尝试将底部轴上的`from`日期和`to`日期向前移动`15`秒。由于我们的存储通过`setInterval`调用进行更新，`redraw`事件每秒会被触发一次，因此每当`redraw`事件被触发第15次时，我们就会更新轴。这就是代码中的样子：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We use a variable called `redrawCounter` to keep track of how many times the
    redraw event has fired since our last axis adjustment. The rest of the code should
    be fairly straightforward. Grab the bottom and set its dates 15 seconds ahead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`redrawCounter`的变量来跟踪自上次轴调整以来`redraw`事件触发了多少次。其余的代码应该相当直接。获取底部并设置其日期为15秒之后。
- en: This was all fairly painless, although there were some unexpected hurdles in
    having to hook into the `redraw` event. Now that we've assured ourselves that
    this particular issue can be solved, we can move on to building the rest of the
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很顺利，尽管在需要挂钩到`redraw`事件的过程中遇到了一些意外的障碍。现在我们已经确信这个问题可以解决，我们可以继续构建应用程序的其余部分。
- en: Onwards and upwards
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奋进向前
- en: 'As with all of our example applications, we''ll use Sencha Cmd and build an
    application template as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们所有的示例应用程序一样，我们将使用Sencha Cmd并按照以下方式构建一个应用程序模板：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remove all of the cruft and example files that the generator creates and use
    the `watch` command to fire up a web server. We can then proceed to create the
    first real code for our application: the data layer.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 移除生成器创建的所有冗余文件和示例文件，并使用`watch`命令启动一个网络服务器。然后我们可以继续创建我们应用程序的第一个真实代码：数据层。
- en: Data first
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据先行
- en: 'All our models will inherit from a base model, which will be used to specify
    the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有我们的模型都将继承自一个基础模型，该模型将用于指定以下命令：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've assumed that we have an API server running at localhost on port `3000`
    and supplied this information as the URL prefix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们有一个运行在本地的 `3000` 端口的 API 服务器，并提供了这个信息作为 URL 前缀。
- en: 'We used the `schema` configuration in the last chapter, but now that we''re
    about to use it with multiple models, it really comes into its own. In each of
    the models that inherit from `BaseModel`, the model''s name will be inserting
    into the proxy URL in place of the `entityName` token. This avoids duplicating
    the URL configuration across multiple models. We can now create our `LogEntry`
    model as per our design:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中使用了 `schema` 配置，但现在我们即将在多个模型中使用它，它真正地发挥了作用。在从 `BaseModel` 继承的每个模型中，模型名称将被插入到代理
    URL 中以替换 `entityName` 标记。这避免了在多个模型之间重复 URL 配置。现在我们可以根据我们的设计创建 `LogEntry` 模型：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Via the schema, this will result in the following URL:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 schema，这将导致以下 URL：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Other than this, we''re just implementing the fields, we specified in the design,
    on to the `LogStream` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，我们只是在 `LogStream` 类上实现了我们在设计中指定的字段：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This was simple. The `LogStream` class inherits all of the fields from the
    `LogEntry` class, but thanks to the use of the schema configuration in the `BaseClass`,
    `LogStream` will have a URL like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。`LogStream` 类从 `LogEntry` 类继承了所有字段，但多亏了在 `BaseClass` 中使用 schema 配置，`LogStream`
    将有一个这样的 URL：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, here''s the `Statistics` model:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 `Statistics` 模型：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just the three fields from the design here and it gives us a model that produces
    this URL:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有设计中的三个字段，它给我们提供了一个生成此 URL 的模型：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Nothing in our data layer is particularly taxing, as we thought through the
    implementation during our design phase. By having an awareness of the features
    Ext JS provides before sitting down to write code, we were able to reduce code
    duplication by having the proxy configuration in a base class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据层中，没有任何特别复杂的地方，因为我们已经在设计阶段深思熟虑了实现方式。在坐下来编写代码之前，我们对 Ext JS 提供的功能有所了解，这使得我们能够通过在基类中配置代理来减少代码重复。
- en: We should always look for places, either via refactoring or through the initial
    design, where we can reduce duplicated code. In this example, we could have had
    the same functionality by setting the proxy configuration on each of `LogEntry`,
    `LogStream`, and `Statistic`, but in the event where we want to change some part
    of the config, such as the hostname of the API, we'd have to change it in multiple
    locations. By centralizing in the way that we have, we will have less code to
    maintain and it's easier to work with.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终寻找地方，无论是通过重构还是通过初始设计，来减少重复的代码。在这个例子中，我们可以在 `LogEntry`、`LogStream` 和 `Statistic`
    的每个实例上设置相同的配置，但如果我们想要更改配置的某些部分，比如 API 的主机名，我们就需要在多个位置进行更改。通过以我们这样的方式集中化，我们将有更少的代码需要维护，并且更容易与之合作。
- en: 'One thing to note in the model classes earlier is the way we define the fields.
    There are two options in Ext JS, one option is to pass a field definition as an
    object literal as we have in our code, and the second option is to pass a string
    containing the field name. To use the `Statistic` class as an example, the field
    config will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的模型类中，有一点需要注意，那就是我们定义字段的方式。在 Ext JS 中有两种选择，一种是将字段定义作为一个对象字面量传递，就像我们在代码中所做的那样，另一种是将包含字段名称的字符串传递。以
    `Statistic` 类为例，字段配置将如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why choose one over the other? The answer is for consistency. This is a perfect
    example of something that could go in the programming style guide for your team,
    so rather than having one class declared using one method and a second class using
    another method, we have a unified approach. No alarms and no surprises for a new
    developer who opens up your model files and finds the field definitions well organized.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择其中一种而不是另一种？答案是保持一致性。这是一个非常适合作为团队编程风格指南的例子，所以我们不是让一个类使用一种方法声明，而另一个类使用另一种方法，而是采用统一的方法。对于打开你的模型文件并发现字段定义组织良好的新开发者来说，不会有任何警报和惊喜。
- en: There is a third approach for field definitions; not bothering with them. Ext
    JS allows you to leave out the field definitions and will create them on the fly
    based on the data the model is consuming.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字段定义，还有一种第三种方法；不去管它们。Ext JS 允许你省略字段定义，并且会根据模型消耗的数据动态创建它们。
- en: We're all for reducing the amount of code to maintain, but sometimes, it's better
    to be explicit. If we needed to use one of the other configuration options in
    a field, such as convert, then we'd have to manually define that field anyway,
    and so on, and then be left with some fields explicit in the model and some created
    on the fly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都支持减少维护的代码量，但有时，明确一些更好。如果我们需要在字段中使用其他配置选项，例如转换，那么我们无论如何都需要手动定义该字段，等等，然后我们会在模型中留下一些显式的字段，一些在运行时创建。
- en: This is a matter of preference, but for our purposes, we'll always define the
    full field definitions. It's consistent and self-documenting; we're always aware
    of the fields it's consuming when looking at a model file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个人的偏好问题，但为了我们的目的，我们将始终定义完整的字段定义。这是连贯且自我说明的；当我们查看模型文件时，我们总是知道它正在消耗的字段。
- en: Storing the data
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储数据
- en: 'The stores in this project are as simple as it can be:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中的存储库尽可能简单：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These classes are fairly boilerplate (define the model, define the alias, and
    that's it). There's an argument to be heard that these stores could actually be
    defined on individual view models, reducing the number of files in our code base.
    However, in this application, we'll reuse the stores in multiple view models,
    so it makes sense to keep their configuration in a centralized location.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类相当是模板化的（定义模型、定义别名，然后就是这些）。有人可能会提出，这些存储库实际上可以在单个视图模型中定义，从而减少我们的代码库中的文件数量。然而，在这个应用程序中，我们将在多个视图模型中重用存储库，因此将它们的配置保留在集中位置是有意义的。
- en: Let's move on to the UI layer of our application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们应用程序的UI层。
- en: With a view to a controller
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对控制器视图
- en: 'In this application, we have a "main" view, which acts as the application''s
    viewport, and an associated controller, which deals with user interactions with
    this viewport and handles routing. Let''s look at the UI portion first: `view`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们有一个“主”视图，它充当应用程序的视口，以及一个相关的控制器，它处理用户与该视口的交互并处理路由。让我们首先看看UI部分：`view`：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are a few interesting bits in this code. We use the `header` config option
    to give us fine control over the panel's header, allowing us to add some formatting
    to the title.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有几个有趣的部分。我们使用`header`配置选项来精细控制面板的标题，允许我们在标题中添加一些格式化。
- en: We then change the default configuration of the panel's tabs to put them on
    the left-hand side of the screen (as opposed to the top of the screen). As tabs
    on the left-hand side default to displaying from top to bottom, we adjust `tabRotation`
    too, making them read from left to right. The tab selected by default is automatically
    the first component in the items array, so we can avoid setting any configuration
    to stipulate this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将面板标签的默认配置更改为将它们放置在屏幕的左侧（而不是屏幕顶部）。由于左侧的标签默认从上到下显示，我们也将`tabRotation`进行调整，使它们从左到右阅读。默认选中的标签自动是项目数组中的第一个组件，因此我们可以避免设置任何配置来指定这一点。
- en: Then, we set out the items that will be included in this tab panel, just the
    dashboard, the web logs subpage, and the SQL logs subpage, as dictated in our
    design. The only interesting part of this configuration is the addition of `reference`
    for each component and its utility will become clear when we look at the view
    controller.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置将包含在这个标签面板中的项目，即仪表板、Web日志子页面和SQL日志子页面，正如我们的设计所规定。这个配置中唯一有趣的部分是为每个组件添加`reference`，其效用将在我们查看视图控制器时变得清晰。
- en: The main view controller
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要视图控制器
- en: 'There isn''t a lot of code in this view controller, but the functionality it
    enables is very important. Let''s take a look:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器中的代码并不多，但它所启用的功能非常重要。让我们看看：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Not much code, to be sure, but a lot going on. This is the part of the application
    that deals with routing, so let's take a bit of time out to discuss what routing
    actually is.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，代码不多，但内容很多。这是处理路由的应用程序部分，所以让我们花点时间讨论一下路由实际上是什么。
- en: Rootin-Tootin
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根到顶
- en: 'There''s a pretty comprehensive description of routing in the Ext JS Guides,
    but let''s cover it in brief here anyway. Routing allows you to keep the application''s
    state in the page URL via the URL''s hash (the hash is everything after the `#`
    symbol in a URL). For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS指南中有一份相当全面的关于路由的描述，但无论如何，我们在这里简要介绍一下。路由允许您通过URL的哈希（URL中`#`符号之后的所有内容）在页面URL中保持应用程序的状态。例如：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows us we''re on a page about bananas. Likewise, look at the following
    example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们正在一个关于香蕉的页面上。同样，看看以下示例：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This shows that we're on a page about car number `56`. The beauty of using the
    hash is that it can be manipulated with JavaScript without reloading the page.
    Also, any change made to the hash symbol will be remembered by the browser's history.
    This means that we can navigate around our application and use the back button
    to retrace our steps. It also means that if we can bookmark a specific page in
    the application when it reloads the app, it will navigate to the state specified
    in the hash symbol.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们正在一个关于车号`56`的页面上。使用哈希的优点在于，它可以不重新加载页面就用JavaScript进行操作。此外，对哈希符号所做的任何更改都将被浏览器的历史记录记住。这意味着我们可以在我们应用程序中导航，并使用后退按钮来追踪我们的步骤。这也意味着，如果我们可以在应用程序重新加载时将特定页面设置为书签，那么它将导航到哈希符号中指定的状态。
- en: Back to business
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到正事
- en: 'How do we implement routes in the `Instrumatics` app? The first step is to
    actually define a route as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在`Instrumatics`应用程序中实现路由？第一步是实际定义一个路由如下：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first part is the hash we're trying to match. Nothing's been specified apart
    from `:viewReference`, so in this case, everything in the hash symbol gets captured
    and passed on to a method called `onNavigate`. The name of the `:viewReference`
    token is arbitrary, in this it doesn't affect anything else, but in more complex
    routes, it's useful to name it in a descriptive way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是我们试图匹配的哈希。除了`:viewReference`之外，没有指定任何内容，所以在这种情况下，哈希符号中的所有内容都会被捕获并传递给一个名为`onNavigate`的方法。`:viewReference`标记的名称是任意的，在这个例子中，它不影响其他任何东西，但在更复杂的路由中，用描述性的方式命名它是很有用的。
- en: 'What are we trying to achieve here? When the hash symbol changes, we want to
    detect it and redirect the user to the correct page. The route definition does
    the detection part, so now let''s look at how we move the user to the right page:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里试图实现什么？当哈希符号改变时，我们想要检测它并将用户重定向到正确的页面。路由定义执行检测部分，所以现在让我们看看我们如何将用户移动到正确的页面：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The route definition means that all matching routes will be consumed by `onNavigate`.
    In this method, we can assume that the token passed in is a valid reference to
    a component on the view controller's view, so we just lookup the component using
    this reference and set it as the active tab on the "main" view.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义意味着所有匹配的路由都将被`onNavigate`消耗。在这个方法中，我们可以假设传入的标记是对视图控制器视图上组件的有效引用，所以我们只需使用这个引用查找组件并将其设置为“主”视图上的活动标签页。
- en: We're missing something though, that is, how does the hash get set in the first
    place?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎遗漏了某些东西，那就是，哈希是如何首先被设置的？
- en: Route to nowhere
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由到无地
- en: 'In the listen configuration for the view controller, we handle the "main" tab
    panel''s `tabchange` event with the `onTabChange` method. This grabs the reference
    config from the tab the user is changing to and passes it to the view controller''s
    `redirectTo` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图控制器的监听配置中，我们使用`onTabChange`方法处理“主”标签面板的`tabchange`事件。这从用户更改到的标签中获取引用配置并将其传递给视图控制器的`redirectTo`方法：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `redirectTo` method simply changes the hash in the URL, in this case, to
    the reference of the new component. It's a simple approach that gives us a powerful
    way to improve the user experience.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirectTo`方法只是简单地更改URL中的哈希，在这种情况下，到新组件的引用。这是一个简单的方法，它为我们提供了一种强大的方式来改进用户体验。'
- en: The dashboard
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表盘
- en: We have the application infrastructure in place, so it's time to build out the
    components that are going to rest on this infrastructure. First up is the dashboard,
    something that requires us to carefully consider how to implement the rest of
    our application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了应用程序基础设施，所以现在是时候构建将建立在基础设施之上的组件了。首先是仪表盘，这需要我们仔细考虑如何实现我们应用程序的其余部分。
- en: 'The dashboard consists of two live charts and two historical charts. The live
    charts are very similar to each other, as are the historical charts (just some
    minor formatting and binding configuration between them). However, in order to
    build a chart, you also have to build the axes and the series being drawn on it,
    which results in a fairly long-winded configuration object. Here''s what the historical
    log chart from the dashboard will look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘由两个实时图表和两个历史图表组成。实时图表之间非常相似，历史图表也是如此（它们之间只有一些微小的格式化和绑定配置）。然而，为了构建图表，你还必须构建图表上的轴和绘制的系列，这导致了一个相当冗长的配置对象。以下是仪表板中的历史日志图表将看起来像这样：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Excellent! We have configured a chart with a line series that has a numeric
    left axis and a time-base bottom axis. This is exactly what we need for the dashboard,
    so where's the problem?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 极好！我们配置了一个带有数值左侧轴和时间基准底部轴的折线系列图表。这正是仪表板所需要的，那么问题在哪里？
- en: Duplication is the problem. The majority of this configuration object would
    be duplicated, one copy for the web logs and one copy for the SQL logs. We've
    mentioned before in this chapter that we'd like to battle duplication where possible,
    so in this case, we will create a new class that we can reuse in places where
    we need a chart to plot historical requests from the logs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是问题所在。这个配置对象的大部分内容都会被复制，一份用于Web日志，一份用于SQL日志。我们之前在本章中提到，我们希望在可能的情况下与复制作斗争，因此在这种情况下，我们将创建一个新的类，我们可以在需要从日志中绘制历史请求图表的地方重用它。
- en: 'Here''s the class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个类：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It combines the basic definition of the chart, such as the axes and series,
    with things we know we'll reuse across the application, such as the title on the
    left axis.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它结合了图表的基本定义，如坐标轴和系列，以及我们知道将在整个应用程序中重用的东西，如左侧轴上的标题。
- en: Note that we're putting this class in a different location from anything we've
    seen so far in our example applications, but one that we discussed in [Chapter
    3](ch03.html "Chapter 3. Application Structure"), *Application Structure*. The
    `ux` namespace and corresponding directory is a fairly standard location for reusable
    classes in the Ext JS community, so we will follow this convention here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将这个类放在了我们示例应用程序中迄今为止所见到的任何地方之外，但我们讨论过的地方是[第三章](ch03.html "第三章. 应用结构")“应用结构”。`ux`命名空间和相应的目录是Ext
    JS社区中可重用类的相当标准的存放位置，因此我们将遵循这一惯例。
- en: 'We will create another reusable class, this time for the live request chart:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个可重用的类，这次是为实时请求图表：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You'll notice that this code has a lot in common with the code from our code
    investigation earlier in the chapter. It's just that we've wrapped it up into
    a reusable class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这段代码与本章前面代码调查中的代码有很多相似之处。只是我们将它封装成了一个可重用的类。
- en: 'With these new classes ready to go, creating the dashboard is just a matter
    of piecing together what we''ve already written, as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这些新类后，创建仪表板只需将我们已编写的内容拼接在一起，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Rather than duplication of the configuration that forms the charts, we'll just
    put together the containers—which use the `vbox` and `hbox` layouts—and set up
    titles, formatting, and bindings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是复制构成图表的配置，我们只需组合容器——这些容器使用`vbox`和`hbox`布局——并设置标题、格式和绑定。
- en: This is great. Rather than duplicating code and having lots of unnecessary configuration
    in the dashboard view itself, we've moved this code to a more logical location,
    promoting reuse and making for a tidier code base.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这太好了。我们不是在仪表板视图中复制代码和有很多不必要的配置，而是将这段代码移动到了一个更合理的位置，促进了重用，并使代码库更加整洁。
- en: Constant evaluation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续评估
- en: 'At this point, let''s look at what we''ve built in comparison with our design.
    It matches our implementation so far, but there wasn''t any mention of these reusable
    classes. There are two ways of looking at this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们看看我们构建的内容与我们的设计相比。它与我们的实现相匹配，但并没有提到这些可重用的类。对此有两种看法：
- en: We didn't go far enough in our design and missed an opportunity to spell out
    exactly what we needed to build
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在设计上没有做得足够深入，错过了明确说明我们需要构建的内容的机会
- en: We saw an opportunity to refactor our code after we found ourselves duplicating
    something we'd already written
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在发现自己重复编写了已经编写过的内容后，看到了重构代码的机会
- en: There's something to be said for both these viewpoints; however, in [Chapter
    5](ch05.html "Chapter 5. Practical – a CMS Application"), *Practical – a CMS Application*,
    we discussed YAGNI—you aren't going to need it—which dictates that there's little
    point in planning for reuse if the component in question is never going to be
    reused.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种观点都有其可取之处；然而，在[第五章](ch05.html "第五章. 实际应用 – CMS 应用")“实际应用 – CMS 应用”中，我们讨论了YAGNI——你不会需要它——这规定，如果所讨论的组件永远不会被重用，那么为其规划重用几乎是没有意义的。
- en: In this case, the implementation process revealed that we'd have some duplication,
    so we refactored. While taking careful consideration at the design stage is important,
    re-evaluating our decisions and code should be an ongoing process, so it's critical
    to realize that even if there's a feeling that something should have been noticed
    in the design phase, nothing is set in stone. We can always change things as long
    as we understand why they need to change and use it as a learning experience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，实现过程揭示了我们会有些重复，所以我们进行了重构。虽然在设计阶段仔细考虑很重要，但重新评估我们的决策和代码应该是一个持续的过程，因此，认识到即使有在设计阶段应该注意到的感觉，也没有什么是固定不变的。只要我们理解为什么需要改变，并将其作为学习经验，我们就可以随时改变事物。
- en: The dashboard view model
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板视图模型
- en: 'Each of the four charts in the dashboard has its own data source and these
    are specified in the bind configuration for each. The definitions for these sources
    are in the dashboard view model:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板中的四个图表各自有自己的数据源，这些源在各自的绑定配置中指定。这些源的定义在仪表板视图模型中：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We're setting up the data sources for the dashboard. If you look back at the
    associated store definitions, you'll see matching aliases and also the `remoteFilter`
    option set to `true`. This enables us to set the filter on the store definition
    in the view model and have these passed through to the server as JSON.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置仪表板的数据源。如果你回顾一下相关的存储定义，你会看到匹配的别名，以及`remoteFilter`选项设置为`true`。这使我们能够在视图模型中设置存储定义的过滤器，并将其作为JSON传递到服务器。
- en: This makes for a very simple method to set up stores to retrieve filtered data
    from the server side (just pass over an array of filters and let the backend take
    care of it).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这为设置存储以从服务器端检索过滤数据提供了一个非常简单的方法（只需传递一个过滤器数组，让后端处理即可）。
- en: 'We''ve put together nearly all the pieces of the dashboard with one exception:
    the view controller. Let''s look at this now.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经用除了视图控制器之外的所有部件拼凑了仪表板。现在让我们来看看这个视图控制器。
- en: The dashboard view controller
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板视图控制器
- en: 'There isn''t any interactivity on the dashboard, so there''s not much for the
    view controller to do. We''ll use it to control the live refresh aspect of the
    charts:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板上没有交互性，所以视图控制器没有什么可做的。我们将用它来控制图表的实时刷新功能：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It's as simple as this; every second, grab the store powering the live chart
    and call its load method with the `addRecords` option set to `true`. This will
    cause new records to be appended to the store rather than overwriting old records.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；每秒钟，获取驱动实时图表的存储，并调用其加载方法，将`addRecords`选项设置为`true`。这将导致新记录被追加到存储中，而不是覆盖旧记录。
- en: While there's not much code here, there are a couple of discussion points. We
    could have avoided using a view controller at all for the dashboard and baked
    this refresh behavior directly in the `LiveRequestChart` class, maybe setting
    the refresh rate via a configuration option.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里没有多少代码，但有几个讨论点。我们本可以完全避免在仪表板上使用视图控制器，并将这种刷新行为直接嵌入到`LiveRequestChart`类中，也许通过配置选项设置刷新率。
- en: By doing it in the controller, we get the chance to centralize the place in
    which the refresh rate is set. This isn't a massive win though. There's definitely
    a case to be made for moving this into the UI class. It's another situation where
    there's no right or wrong way of doing things; multiple options are available
    and it's better to pick one and move on than be paralyzed with the choices on
    offer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在控制器中这样做，我们有机会集中设置刷新率的位置。但这并不是一个巨大的胜利。确实有理由将此移动到UI类中。这是另一个没有正确或错误做法的情况；有多种选择，选择一个并继续比被提供的选项所瘫痪要好。
- en: We've got the first page of our application, so let's now move on to the subpages,
    starting with the web logs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了应用程序的第一页，现在让我们继续到子页面，首先是网络日志页面。
- en: Web logs subpage
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络日志子页面
- en: 'We''ve already built part of this screen already. We can reuse `Instrumatics.ux.chart.HistoricalRequestChart`
    we created earlier to display the trend for a specified date range. As this data''s
    coming from the store, we can simply filter the store and don''t have to do anything
    on the component itself. With this in mind, the **Web** view looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了这部分屏幕的一部分。我们可以重用之前创建的`Instrumatics.ux.chart.HistoricalRequestChart`来显示指定日期范围的趋势。由于这些数据来自存储，我们可以简单地过滤存储，而无需在组件本身上做任何事情。考虑到这一点，**Web**视图看起来是这样的：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's a fair amount of code, but nothing other than component configuration is
    happening here. Let's break it down step-by-step.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有相当多的代码，但这里发生的除了组件配置之外没有其他事情。让我们一步一步地分解它。
- en: Firstly, there's the configuration of the panel itself where we set up a `vbox`
    layout.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是面板本身的配置，我们在其中设置了 `vbox` 布局。
- en: Then we add our first item, an instance of the `HistoricalRequestChart` we built
    earlier, and add `To` and `From` date fields to its header. The values of these
    are bound to values (`currentStartDate` and `currentEndDate`) in the view model,
    and the chart itself is bound to `logData` in the view model.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了第一个项目，一个我们之前构建的 `HistoricalRequestChart` 的实例，并在其标题中添加了 `To` 和 `From`
    日期字段。这些字段的值绑定到视图模型中的值（`currentStartDate` 和 `currentEndDate`），而图表本身绑定到视图模型中的 `logData`。
- en: Finally, we have the configuration of the statistics grid. Its store is bound
    to `logStatistics` and in its header, we add a combo box that has its value bound
    to `currentCategory` in the view model and its store—to provide the combo box
    options—bound to categories. The combo box allows the user to choose which statistics
    category they'd like to view.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有统计网格的配置。它的存储绑定到 `logStatistics`，在其标题中，我们添加了一个组合框，其值绑定到视图模型中的 `currentCategory`，其存储绑定到类别，以提供组合框选项。组合框允许用户选择他们想要查看的统计类别。
- en: Onwards and upwards to the view model!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 向上前进到视图模型！
- en: A view on the Web
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Web的一种看法
- en: 'Our Web view model follows our design and fleshes it out with some implementation
    details:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Web 视图模型遵循我们的设计，并使用一些实现细节来完善它：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note the bindings on the filters. This enables us to link the filters with a
    value on the view model, which in turn links through to values on the form controls
    in the view. This means that as soon as the user updates a form control, it'll
    update the filter on the store automatically, reloading the store, and redrawing
    the chart and grid.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意过滤器上的绑定。这使我们能够将过滤器与视图模型上的一个值链接起来，反过来又链接到视图中的表单控件上的值。这意味着一旦用户更新了一个表单控件，它将自动更新存储上的过滤器，重新加载存储，并重新绘制图表和网格。
- en: We've also got a `categories` store, which is simply a way of holding data for
    the categories combo, nothing more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 `categories` 存储，它只是用来保存类别组合框数据的一种方式，没有更多。
- en: Controlling the Web
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制Web
- en: Well here's a thing, this view has no corresponding view controller! In previous
    versions of Ext JS, we'd be listening for change events on the date fields and
    combo box, then grabbing the changed value and reloading the store with it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里有一个问题，这个视图没有对应的视图控制器！在 Ext JS 的早期版本中，我们会监听日期字段和组合框上的更改事件，然后获取更改的值并使用它重新加载存储。
- en: In the brave new world of view models though, we don't need to do this. When
    a date field updates, it automatically updates the corresponding view model value,
    which in turn updates the store's filter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在视图模型的新世界中，我们不需要这样做。当一个日期字段更新时，它会自动更新相应的视图模型值，反过来又更新存储的过滤器。
- en: We're already setting up the stores and the form components, so by adding an
    extra sprinkle of magic in the form of bind configurations, Ext JS will power
    all of this for us. This means less custom code for us to write, which can only
    be a good thing!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了存储和表单组件，所以通过在表单中添加一些魔法般的绑定配置，Ext JS 将为我们提供所有这些功能。这意味着我们需要编写的自定义代码更少，这只能是一件好事！
- en: More and more subpages
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 越来越多的子页面
- en: We know that the other subpage in our application, the SQL log page, is going
    to be very similar to the web log page. This should be raising an eyebrow with
    regard to code duplication. We could pull out the grid and the chart header from
    the **Web** view into separate classes and turn them into reusable components,
    but is this the right thing to do? These components won't be reused! They have
    their place in only one location in the application to power the subpages. Unlike
    `HistoricalRequestChart`, which is used in both the dashboard and the subpages,
    these are only needed for one job.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们应用程序中的另一个子页面，SQL日志页面，将非常类似于Web日志页面。这应该会让我们对代码重复产生疑问。我们可以将网格和图表标题从 **Web**
    视图中提取出来，并将它们转换为可重用的组件，但这是正确的事情吗？这些组件不会被重用！它们只在应用程序的一个位置有它们的位置，用于驱动子页面。与 `HistoricalRequestChart`
    不同，它在仪表板和子页面中都被使用，这些组件只需要完成一项工作。
- en: 'Let''s consider another approach: *subclassing*. We could create a new component
    that contains the chart, form fields, and grid from the **Web** view, and add
    some configuration options that give us the customization we need. This might
    look like the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种方法：*继承*。我们可以创建一个新的组件，它包含来自**Web**视图的图表、表单字段和网格，并添加一些配置选项，以提供我们需要的定制化。这可能看起来像以下命令：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ve pulled the entire configuration from the **Web** view into this base
    class called `SubPage` and separated out the key components, namely, the chart
    and the grid. We''re also harnessing the power of the Ext JS class system by wrapping
    these in the config section, which not only generates get and set methods for
    `gridCfg` and `chartCfg`, but also provides us with a shortcut to override parts
    of these config objects. Let''s demonstrate by showing the **SQL** view, which
    is powered by our new `SubPage` class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将整个配置从**Web**视图拉取到这个名为`SubPage`的基类中，并将关键组件分离出来，即图表和网格。我们还通过将这些组件包裹在配置部分来利用Ext
    JS类系统的力量，这不仅为`gridCfg`和`chartCfg`生成了获取和设置方法，还为我们提供了覆盖这些配置对象部分内容的快捷方式。让我们通过展示由我们新的`SubPage`类驱动的**SQL**视图来演示：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Yep, that's it! We've managed to get the same functionality that the **Web**
    view had, but reusing lots of the code. Note that `chartCfg` is exposed for us
    to configure, which means that all we have to do is set `viewModel` and the chart's
    title configuration and we're all set.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，就是这样！我们已经实现了与**Web**视图相同的功能，但重用了大量的代码。请注意，`chartCfg`被暴露出来供我们配置，这意味着我们只需要设置`viewModel`和图表的标题配置，一切就绪。
- en: 'Turns out we can do the same for the view model too:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们也可以对视图模型做同样的事情：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And the following SQL view model:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个SQL视图模型：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The **Web** and **SQL** views now share code in a logical way without polluting
    our UX namespace with classes that don't belong there. In future, we could easily
    add on more views like this, but for now, we've got a fantastic way to avoid code
    duplication and keep our application well structured.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**Web**和**SQL**视图以逻辑方式共享代码，而没有用不属于那里的类污染我们的UX命名空间。在未来，我们可以轻松地添加更多类似这样的视图，但到目前为止，我们已经找到了一种避免代码重复并保持应用程序结构良好的绝佳方法。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've built a second practical application and talked a lot
    about how a design can change as an application develops. While we produce an
    initial application architecture with the best of intentions and the knowledge
    we have hand as the application develops, it's important to be flexible in order
    to produce a successful final product. We also introduced routing, more on data
    binding, and showed how code can be reused in a variety of ways.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了第二个实际应用，并讨论了很多关于设计如何随着应用程序的发展而变化的内容。虽然我们带着最好的意图和手头拥有的知识来构建初始应用程序架构，但随着应用程序的发展，保持灵活性以生产成功的产品是很重要的。我们还介绍了路由、更多关于数据绑定，以及展示了代码可以以各种方式重用。
- en: 'In the next chapter, we''ll build an application that will be familiar to most
    readers: an e-mail client. It''ll be a responsive app tailored for both desktop
    and tablet, and we''ll once again take the ideas we''ve already discussed and
    develop them even further.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个大多数读者都熟悉的应用程序：电子邮件客户端。它将是一个响应式应用程序，适用于桌面和平板电脑，我们还将再次将我们已经讨论过的想法进一步发展。
