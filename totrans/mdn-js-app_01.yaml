- en: Chapter 1. Breaking into Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture of server-side application development for complex and large
    applications (applications with huge number of users and large volume of data)
    shouldn't just involve faster response and providing web services for wide variety
    of platforms. It should be easy to scale, upgrade, update, test, and deploy. It
    should also be highly available, allowing the developers write components of the
    server-side application in different programming languages and use different databases.
    Therefore, this leads the developers who build large and complex applications
    to switch from the common monolithic architecture to microservices architecture
    that allows us to do all this easily. As microservices architecture is being widely
    used in enterprises that build large and complex applications, it's really important
    to learn how to design and create server-side applications using this architecture.
    In this chapter, we will discuss how to create applications based on microservices
    architecture with Node.js using the Seneca toolkit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding monolithic architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling, upgrading, deploying, and writing applications based on monolithic
    architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing microservices architecture in depth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling, upgrading, deploying, and writing applications based on microservices
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Seneca
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and calling services using Seneca
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is monolithic architecture?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand microservices architecture, it's important to first understand
    monolithic architecture, which is its opposite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In monolithic architecture, different functional components of the server-side
    application, such as payment processing, account management, push notifications,
    and other components, all blend together in a single unit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: For example, applications are usually divided into three parts. The parts are
    HTML pages or native UI that run on the user's machine, server-side application
    that runs on the server, and database that also runs on the server. The server-side
    application is responsible for handling HTTP requests, retrieving and storing
    data in a database, executing algorithms, and so on. If the server-side application
    is a single executable (that is, running is a single process) that does all these
    tasks, then we say that the server-side application is monolithic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This is a common way of building server-side applications. Almost every major
    CMS, web servers, server-side frameworks, and so on are built using monolithic
    architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This architecture may seem successful, but problems are likely to arise when
    your application is large and complex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Demerits of monolithic architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some of the issues caused by server-side applications built
    using the monolithic architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Scaling monolithic architecture
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As traffic to your server-side application increases, you will need to scale
    your server-side application to handle the traffic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of monolithic architecture, you can scale the server-side application
    by running the same executable on multiple servers and place the servers behind
    a load balancer or you can use round robin DNS to distribute the traffic among
    the servers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构的情况下，你可以通过在多个服务器上运行相同的可执行文件来扩展服务器端应用程序，并将服务器放置在负载均衡器后面，或者你可以使用轮询DNS在服务器之间分配流量：
- en: '![Scaling monolithic architecture](img/B05154_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![扩展单体架构](img/B05154_01_01.jpg)'
- en: In the preceding diagram, all the servers will be running the same server-side
    application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，所有服务器都将运行相同的服务器端应用程序。
- en: Although scaling is easy, scaling monolithic server-side application ends up
    with scaling all the components rather than the components that require greater
    resource. Thus, causing unbalanced utilization of resources sometimes, depending
    on the quantity and types of resources the components need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扩展很简单，但扩展单体服务器端应用程序最终会导致扩展所有组件，而不是需要更多资源的组件。因此，有时会导致资源利用不平衡，这取决于组件需要的资源和类型。
- en: 'Let''s consider some examples to understand the issues caused while scaling
    monolithic server-side applications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子，以了解在扩展单体服务器端应用程序时产生的问题：
- en: Suppose there is a component of server-side application that requires a more
    powerful or special kind of hardware, we cannot simply scale this particular component
    as all the components are packed together, therefore everything needs to be scaled
    together. So, to make sure that the component gets enough resources, you need
    to run the server-side application on some more servers with powerful or special
    hardware, leading to consumption of more resources than actually required.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设有一个需要更强大或特殊类型硬件的服务器端应用程序组件，我们不能简单地扩展这个特定的组件，因为所有组件都打包在一起，因此，所有东西都需要一起扩展。所以，为了确保该组件获得足够的资源，你需要运行具有强大或特殊硬件的更多服务器上的服务器端应用程序，从而导致消耗比实际所需的更多资源。
- en: Suppose we have a component that requires to be executed on a specific server
    operating system that is not free of charge, we cannot simply run this particular
    component in a non-free operating system as all the components are packed together
    and therefore, just to execute this specific component, we need to install the
    non-free operating system on all servers, increasing the cost greatly.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个需要在特定服务器操作系统上执行的组件，而这个操作系统并非免费，我们不能简单地在这个非免费操作系统上运行这个特定的组件，因为所有组件都打包在一起，因此，仅仅为了执行这个特定的组件，我们需要在所有服务器上安装非免费操作系统，这大大增加了成本。
- en: These are just some examples. There are many more issues that you are likely
    to come across while scaling a monolithic server-side application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是其中的一些例子。在扩展单体服务器端应用程序的过程中，你可能会遇到更多的问题。
- en: So, when we scale monolithic server-side applications, the components that don't
    need more powerful or special kind of resource starts receiving them, therefore
    deceasing resources for the component that needs them. We can say that scaling
    monolithic server-side application involves scaling all components that are forcing
    to duplicate everything in the new servers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们扩展单体服务器端应用程序时，不需要更多强大或特殊类型资源的组件开始接收它们，因此减少了需要这些资源的组件的资源。我们可以这样说，扩展单体服务器端应用程序涉及扩展所有被迫在新服务器上重复一切组件的组件。
- en: Writing monolithic server-side applications
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单体服务器端应用程序
- en: Monolithic server-side applications are written in a particular programming
    language using a particular framework. Enterprises usually have developers who
    are experts in different programming languages and frameworks to build server-side
    applications; therefore, if they are asked to build a monolithic server-side application,
    then it will be difficult for them to work together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单体服务器端应用程序是用特定的编程语言和框架编写的。企业通常有精通不同编程语言和框架的开发者来构建服务器端应用程序；因此，如果要求他们构建单体服务器端应用程序，那么他们合作起来将会很困难。
- en: The components of a monolithic server-side application can be reused only in
    the same framework using, which it's built. So, you cannot reuse them for some
    other kind of project that's built using different technologies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单体服务器端应用程序的组件只能在构建它的相同框架中使用，因此，你不能将它们用于使用不同技术构建的其他类型的项目。
- en: Other issues of monolithic architecture
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单体架构的其他问题
- en: 'Here are some other issues that developers might face, depending on the technology
    that is used to build the monolithic server-side application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的问题，开发者可能会根据用于构建单体服务器端应用程序的技术遇到这些问题：
- en: It may need to be completely rebuild and redeployed for every small change made
    to it. This is a time-consuming task and makes your application inaccessible for
    a long time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于对其所做的每一个小改动，可能都需要完全重建和重新部署。这是一个耗时的工作，并且会使你的应用程序在长时间内不可用。
- en: It may completely fail if any one of the components fails. It's difficult to
    build a monolithic application to handle failure of specific components and degrade
    application features accordingly.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个组件失败，它可能会完全失败。构建一个能够处理特定组件失败并相应降低应用程序功能的单体应用程序是困难的。
- en: It may be difficult to find how much resources are each components consuming.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难找到每个组件消耗了多少资源。
- en: It may be difficult to test and debug individual components separately.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难单独测试和调试各个组件。
- en: Microservices architecture to the rescue
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的拯救
- en: We saw the problems caused by monolithic architecture. These problems lead developers
    to switch from monolithic architecture to microservices architecture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了单体架构带来的问题。这些问题导致开发者从单体架构转向微服务架构。
- en: In microservices architecture, the server-side application is divided into services.
    A service (or microservice) is a small and independent process that constitutes
    a particular functionality of the complete server-side application. For example,
    you can have a service for payment processing, another service for account management,
    and so on; the services need to communicate with each other via a network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务器端应用程序被划分为服务。一个服务（或微服务）是一个小型且独立的进程，构成了完整服务器端应用程序的特定功能。例如，你可以有一个用于支付处理的服务，另一个用于账户管理的服务，等等；服务需要通过网络相互通信。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What do you mean by "small" service?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**“小”服务是什么意思？**'
- en: You must be wondering how small a service needs to be and how to tell whether
    a service is small or not. Well, it actually depends on many factors such as the
    type of application, team management, availability of resources, size of application,
    and how small you think is small. However, a small service doesn't have to be
    the one that is written is fewer lines of code or provides a very basic functionality.
    A small service can be the one on which a team of developers can work independently,
    which can be scaled independently to other services, scaling it doesn't cause
    unbalanced utilization of recourses, and overall they are highly decoupled (independent
    and unaware) of other services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一个服务需要多小，以及如何判断一个服务是否小。好吧，实际上这取决于许多因素，如应用程序的类型、团队管理、资源的可用性、应用程序的大小，以及你认为多小才算小。然而，一个小服务不一定是代码行数较少或提供非常基本功能的服务。一个小服务可以是开发者团队可以独立工作的服务，它可以独立扩展到其他服务，扩展它不会导致资源利用不平衡，并且它们在整体上与其他服务高度解耦（独立且不知情）。
- en: You don't have to run each service in a different server, that is, you can run
    multiple services in a single computer. The ratio of server to services depends
    on different factors. A common factor is the amount and type of resources and
    technologies required. For example, if a service needs a lot of RAM and CPU time,
    then it would be better to run it individually on a server. If there are some
    services that don't need much resources, then you can run them all in a single
    server together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必在每个不同的服务器上运行每个服务，也就是说，你可以在单个计算机上运行多个服务。服务器与服务的比例取决于不同的因素。一个常见的因素是所需资源和技术的数量和类型。例如，如果一个服务需要大量的RAM和CPU时间，那么最好是在服务器上单独运行它。如果有一些服务不需要太多资源，那么你可以将它们全部在单个服务器上一起运行。
- en: 'The following diagram shows an example of the microservices architecture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了微服务架构的一个示例：
- en: '![Microservices architecture to the rescue](img/B05154_01_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![微服务架构的拯救](img/B05154_01_02.jpg)'
- en: Here, you can think of **Service 1** as the web server with which a browser
    communicates and other services providing APIs for various functionalities. The
    web services communicate with other services to get data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以将**服务1**视为与浏览器通信的Web服务器，以及其他提供各种功能API的服务。Web服务与其他服务通信以获取数据。
- en: Merits of microservices architecture
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的优点
- en: 'Due to the fact that services are small and independent and communicate via
    network, microservices architecture solves many problems that monolithic architecture
    had. Here are some of the benefits of microservices architecture:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: As the services communicate via a network, they can be written in different
    programming languages using different frameworks
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a change to a service only requires that particular service to be redeployed
    instead of all the services, which is a faster procedure
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes easier to measure how much resources are consumed by each service
    as each service runs in a different process
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes easier to test and debug, as you can analyze each service separately
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can be reused by other applications as they interact via network calls
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling services
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the preceding benefits, one of the major benefits of microservices
    architecture is that you can scale individual services that require scaling instead
    of all the services, therefore preventing duplication of resources and unbalanced
    utilization of resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to scale **Service 1** in the preceding diagram. Here is a
    diagram that shows how it can be scaled:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling services](img/B05154_01_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Here, we are running two instances of **Service 1** on two different servers
    kept behind a load balancer, which distributes the traffic between them. All other
    services run the same way, as scaling them wasn't required. If you wanted to scale
    **Service 3**, then you can run multiple instances of **Service 3** on multiple
    servers and place them behind a load balancer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Demerits of microservices architecture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although there are a lot of merits of using microservices architecture compared
    to monolithic architecture, there are some demerits of microservices architecture
    as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As the server-side application is divided into services, deploying, and optionally,
    configuring each service separately is a cumbersome and time-consuming task.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that developers often use some sort automation technology (such as AWS,
    Docker, and so on) to make deployment somewhat easier; however, to use it, you
    still need a good level of experience and expertise with that technology.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Communication between services is likely to lag as it's done via a network.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sort of server-side applications more prone to network security vulnerabilities
    as services communicate via a network.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code for communicating with other services can be harder, that is, you
    need to make network calls and then parse the data to read it. This also requires
    more processing. Note that although there are frameworks to build server-side
    applications using microservices that make fetching and parsing data easier, it
    still doesn't deduct the processing and network wait time.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will surely need some sort of monitoring tool to monitor services as they
    may go down due to network, hardware, or software failure. Although you may use
    the monitoring tool only when your application suddenly stops, to build the monitoring
    software or use some sort of service, monitoring software needs some level of
    extra experience and expertise.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你肯定需要某种监控工具来监控服务，因为它们可能会因为网络、硬件或软件故障而停止。尽管你可能只在应用程序突然停止时使用监控工具，但要构建监控软件或使用某种服务，监控软件需要一定程度的额外经验和专业知识。
- en: Microservices-based server-side applications are slower than monolithic-based
    server-side applications as communication via networks is slower compared to memory.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的服务器端应用程序比基于单体架构的服务器端应用程序要慢，因为通过网络进行通信比通过内存要慢。
- en: When to use microservices architecture
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用微服务架构
- en: It may seem like its difficult to choose between monolithic and microservices
    architecture, but it's actually not so hard to decide between them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择单体和微服务架构可能看起来很困难，但实际上决定它们并不那么难。
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are unlikely to face any monolithic issues that we discussed
    earlier, then you can stick to monolithic architecture. In future, if you are
    facing issues that can be solved using microservices architecture, then you should
    switch to microservices architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用单体架构构建服务器端应用程序，并且你认为你不太可能遇到我们之前讨论过的任何单体问题，那么你可以坚持使用单体架构。将来，如果你遇到可以用微服务架构解决的问题，那么你应该切换到微服务架构。
- en: If you are switching from a monolithic architecture to microservices architecture,
    then you don't have to rewrite the complete application, instead you can only
    convert the components that are causing issues to services by doing some code
    refactoring. This sort of server-side applications where the main application
    logic is monolithic but some specific functionality is exposed via services is
    called microservices architecture with monolithic core. As issues increase further,
    you can start converting more components of the monolithic core to services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从单体架构切换到微服务架构，那么你不必重写整个应用程序，而是可以通过进行一些代码重构，将导致问题的组件转换为服务。这种主要应用程序逻辑是单体但某些特定功能通过服务公开的服务器端应用程序称为具有单体核心的微服务架构。随着问题的进一步增加，你可以开始将更多单体核心的组件转换为服务。
- en: '![When to use microservices architecture](img/B05154_01_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![何时使用微服务架构](img/B05154_01_04.jpg)'
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are likely to face any of the monolithic issues that we
    discussed earlier, then you should immediately switch to microservices architecture
    or microservices architecture with monolithic core, depending on what suits you
    the best.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用单体架构构建服务器端应用程序，并且你认为你可能会遇到我们之前讨论过的任何单体问题，那么你应该立即切换到微服务架构或具有单体核心的微服务架构，具体取决于最适合你的选择。
- en: Data management
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管理
- en: In microservices architecture, each service can have its own database to store
    data and can also use a centralized database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都可以有自己的数据库来存储数据，也可以使用集中式数据库。
- en: Some developers don't use a centralized database at all, instead all services
    have their own database to store the data. To synchronize the data between the
    services, the services omit events when their data is changed and other services
    subscribe to the event and update the data. The problem with this mechanism is
    that if a service is down, then it may miss some events. There is also going to
    be a lot of duplicate data, and finally, it is difficult to code this kind of
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者根本不使用集中式数据库，而是所有服务都有自己的数据库来存储数据。为了在服务之间同步数据，当它们的数据发生变化时，服务会省略事件，而其他服务则订阅事件并更新数据。这种机制的问题在于，如果某个服务宕机，它可能会错过一些事件。还可能会有大量的重复数据，最后，编写这种系统也相当困难。
- en: Therefore, it's a good idea to have a centralized database and also let each
    service to maintain their own database if they want to store something that they
    don't want to share with others. Services should not connect to the centralized
    database directly, instead there should be another service called **database service**
    that provides APIs to work with the centralized database. This extra layer has
    many advantages, such as the underlying schema can be changed without updating
    and redeploying all the services that are dependent on the schema, we can add
    a caching layer without making changes to the services, you can change the type
    of database without making any changes to the services and there are many other
    benefits. We can also have multiple database services if there are multiple schemas,
    or if there are different types of database, or due to some other reason that
    benefits the overall architecture and decouples the services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有一个集中式数据库并允许每个服务在需要存储不希望与他人共享的数据时维护自己的数据库是一个好主意。服务不应直接连接到集中式数据库，而应该有一个名为
    **数据库服务** 的其他服务，它提供与集中式数据库交互的 API。这个额外的层有许多优点，例如，可以更改底层模式而无需更新和重新部署依赖于该模式的全部服务，我们可以在不更改服务的情况下添加缓存层，可以更改数据库类型而不对服务进行任何更改，并且还有许多其他好处。如果存在多个模式，或者有不同类型的数据库，或者由于其他有利于整体架构并解耦服务的其他原因，我们还可以拥有多个数据库服务。
- en: Implementing microservices using Seneca
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Seneca 实现微服务
- en: Seneca is a Node.js framework for creating server-side applications using microservices
    architecture with monolithic core.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 是一个用于使用微服务架构和单体核心创建服务器端应用的 Node.js 框架。
- en: Earlier, we discussed that in microservices architecture, we create a separate
    service for every component, so you must be wondering what's the point of using
    a framework for creating services that can be done by simply writing some code
    to listen to a port and reply to requests. Well, writing code to make requests,
    send responses, and parse data requires a lot of time and work, but a framework
    like Seneca makes all this easy. Also, converting the components of a monolithic
    core to services is also a cumbersome task as it requires a lot of code refactoring,
    but Seneca makes it easy by introducing the concepts of actions and plugins. Finally,
    services written in any other programming language or framework will be able to
    communicate with Seneca services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了在微服务架构中，我们为每个组件创建一个独立的服务，所以你可能想知道使用框架来创建服务（这些服务可以通过简单地编写一些代码来监听端口并回复请求来完成）有什么意义。好吧，编写代码来发起请求、发送响应和解析数据需要花费很多时间和精力，但像
    Seneca 这样的框架可以让这一切变得简单。此外，将单体核心的组件转换为服务也是一个繁琐的任务，因为它需要大量的代码重构，但 Seneca 通过引入动作和插件的概念使其变得容易。最后，用任何其他编程语言或框架编写的服务都将能够与
    Seneca 服务进行通信。
- en: In Seneca, an action represents a particular operation. An action is a function
    that's identified by an object literal or JSON string called the action pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Seneca 中，一个动作代表一个特定的操作。动作是一个通过称为动作模式的对象字面量或 JSON 字符串来标识的函数。
- en: In Seneca, these operations of a component of monolithic core are written using
    actions, which we may later want to move from monolithic core to a service and
    expose it to other services and monolithic cores via a network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Seneca 中，这些单体核心组件的操作是通过动作编写的，我们可能希望以后将这些操作从单体核心移动到服务，并通过网络将其暴露给其他服务和单体核心。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why actions?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么是动作？**'
- en: You might be wondering what is the benefit of using actions instead of functions
    to write operations and how actions make it easy to convert components of monolithic
    core to services? Suppose you want to move an operation of monolithic core that
    is written using a function to a separate service and expose the function via
    a network, then you cannot simply copy and paste the function to the new service,
    instead you need to define a route (if you are using Express). To call the function
    inside the monolithic core, you will need to write code to make an HTTP request
    to the service. To call this operation inside the service, you can simply call
    a function so that there are two different code snippets depending from where
    you are executing the operation. Therefore, moving operations requires a lot of
    code refactoring. However, if you would have written the preceding operation using
    the Seneca action, then it would have been really easy to move the operation to
    a separate service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In case the operation is written using action, and you want to move the operation
    to a separate service and expose the operation via a network, then you can simply
    copy and paste the action to the new service. That's it. Obviously, we also need
    to tell the service to expose the action via the network and tell the monolithic
    core where to find the action, but all these require just couple of lines of code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A Seneca service exposes actions to other services and monolithic cores. While
    making requests to a service, we need to provide a pattern matching an action's
    pattern to be called in the service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why patterns?**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Patterns make it easy to map a URL to an action. Patterns can overwrite other
    patterns for specific conditions, therefore it prevents editing the existing code,
    as editing the existing code in a production site is not safe and has many other
    disadvantages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Seneca also has a concept of plugins. A `seneca` plugin is actually a set of
    actions that can be easily distributed and plugged in to a service or monolithic
    core.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: As our monolithic core becomes larger and complex, we can convert components
    to services. That is, move actions of certain components to services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Seneca application
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a basic application using Seneca to demonstrate how to use it.
    We will create an application that allows users to log in and register. This will
    be a demo application just to demonstrate how actions, plugins, and services can
    be created, and not how login and registration functionality works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you proceed further, create a directory named `seneca-example` and place
    a file named `package.json` in it. Inside the `seneca-example` directory, we will
    place our services and monolithic core. Inside the `package.json` file, place
    the following code so that npm will be able to download the dependencies for our
    application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we are using Seneca version 0.6.5\. Make sure that you are also using the
    same version to avoid code incompatibility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Now run the `npm install` command inside the `seneca-example` directory to install
    Seneca and other packages locally.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now create a file named `main.js` that will be the monolithic core of our server
    side application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The monolithic core and services are all `seneca` instances programmatically.
    Place this code in the `main.js` file to create a `seneca` instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now using this `seneca` object, we are going to add actions, call actions, add
    plugins, and everything.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Creating actions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's create actions for login and registration functionality and place them
    in the `main.js` file. To create actions, we need to use the `add` method of the
    `seneca` object. The first argument of the `add` method takes a JSON string or
    object that is the action identifier (called **pattern** to identify the action).
    The second argument is a callback that will be executed when the action is invoked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code in the `main.js` file that creates two actions for login and
    registration, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will see the code for the body of the actions later in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special about `role` and `cmd` properties. You can use any
    property names you wish too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a callback, which will be invoked when the action is
    called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple actions with the same pattern, then the later overrides
    the others.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the `act` method of the `seneca` object to invoke an action that's
    local to the instance or resides on some other service. The first argument of
    the `act` method is a pattern to match an action, and the second argument is a
    callback that will be executed once the action has been invoked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code that shows how to call the preceding two actions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The callback passed to the `act` method is executed asynchronously once the
    result of the action arrives.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Here, the object we passed to the `act` method has two extra properties than
    the action's pattern it is supposed to match. However, the action is still matched
    and invoked because in case the pattern passed to the `act` method has more properties
    than the action's pattern it is supposed to match, Seneca finds all the action's
    patterns whose properties are in the pattern passed to the `act` method and invokes
    the one that has the highest number of matching properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If Seneca finds multiple action patterns with equal number of matching properties,
    then they are matched in ascending alphabetical order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Seneca pattern matching at [http://senecajs.org/getting-started.html#patterns-unique-override](http://senecajs.org/getting-started.html#patterns-unique-override).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Creating plugins
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Seneca plugin is just a set of related actions packed together. Programmatically,
    a `seneca` plugin can be created using a function or module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: A plugin makes it easy to distribute a set of actions among applications. You
    will also find `seneca` plugins in online public package registry maintained by
    npm. For example, there is a `seneca` plugin that provides actions to work with
    the MongoDB database. This plugin can be inserted into monolithic cores or services
    with just a single line of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: By default, Seneca installs four built-in plugins when we create a `seneca`
    instance. These plugins are **basic**, **transport**, **web**, and **mem-store**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create a plugin using a function. The function name is the plugin
    name, and a plugin can also have an initialization action, which will be invoked
    as soon as the plugin is attached to the `seneca` instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a plugin named `account` and place the login and register
    actions in that, as later on, we will be creating a service and moving the actions
    there. Remove the actions we defined earlier in the `main.js` file and place the
    following code instead:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we defined a function named `account` and attached it using the `use` method
    of the `seneca` object. To attach multiple plugins, we can call the `use` method
    multiple times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `init:account` action is the initialization action invoked by Seneca once
    the plugin is added. This can be used to do things such as establishing database
    connection or other things that the actions of the plugin depend on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The `this` keyword inside the plugin refers to the `seneca` instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the same plugin using a module so that it''s easily distributable
    and can be put up in the `npm` registry. Create a file named `account.js` and
    place it in the `seneca-example` directory. `account.js` is the plugin module.
    Place this code inside the `account.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is the plugin name in the string returned by the anonymous function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the plugin code that we previously defined in the `main.js` file and
    place the following code instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, to attach the plugin, we are providing the module path.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about creating Seneca plugins at [http://senecajs.org/write-a-plugin.html](http://senecajs.org/write-a-plugin.html),
    and you can find all the Seneca plugins at [http://senecajs.org/plugins.html](http://senecajs.org/plugins.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Creating services
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A service is a seneca instance that exposes some actions via network. Let's
    create a service that exposes the login and register actions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `account-service.js` file in the `seneca-example` directory that
    will act as the service. Then place the following code in it to create a service
    that exposes the login and register actions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first created a `seneca` instance. Then we added actions via a plugin.
    You can also manually add actions using the `add` method of the `seneca` object.
    Finally, we exposed the actions via an HTTP protocol. Seneca also supports other
    protocols, but we will stick to HTTP, as it's the most commonly used one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`seneca.listen` creates an HTTP server to listen to requests. We also provided
    the port number and pin, which are optional. The default port is `10101`, and
    by default, there is no pin if not provided.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering what is a pin and what is it used for? Well, you may not
    always want to expose all the actions of the service via a network. In that case,
    you can provide a pattern to the `pin` property and the server will handle these
    requests that match the `pin` pattern.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Now, for other services or monolithic cores to be able to call the actions of
    this service, they need to register this service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the previous plugin attachment code from the `main.js` file and add
    the following code to register the service:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are registering the service by providing the `port` number and `pin`.
    Both of them are optional. In case if we don't use any port number, then it defaults
    to `10101`. In case the service is on different server, then you should use the
    `host` property to provide the IP address.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `pin` attached to the `client` method is used to tell the `seneca` instance
    about what actions are exposed by the service. It's completely optional. Seneca
    won't send requests to a service that doesn't match the `pin` pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You can add as many services as you want by calling the client method multiple
    times.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `act` method to invoke an action, the `seneca` instance first
    looks for the action locally before requesting services. If it's not found locally,
    then it checks for the services that have a pin to see if it matches any. If a
    pin matches, then it sends request to this particular service. Finally, if any
    of the pin doesn't match, it sends the requests one by one to all other services
    that don't have a pin till it gets a valid response from one of them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also manually call an action of a service by sending the GET request
    to these types of URL:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also call a service by using the POST request. Here is how to do it
    using CURL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Storing data
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Seneca provides a built-in mechanism to store data. Seneca provides some built-in
    actions that allow us to store data. The built-in actions use `mem-store` to store
    data by default. **mem-store** is an asynchronous in-memory storage system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: You can create your application using the default storing mechanism. In case
    you want to change the underlying store system, you just need to install plugin
    for this particular storage system that will overwrite the built-in storage actions,
    therefore you will not have to refactor any code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in actions to do the CRUD operations are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`role:entity,cmd:load,name:<entity-name>`: This is used to retrieve an entity
    using its ID. An entity can be thought of as a row in MySQL. Every entity gets
    a unique ID.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role:entity,cmd:save,name:<entity-name>`: This is used to update (if you provide
    entity ID) or add an entity if it does not exist. Entities are stored and retrieved
    in form of objects.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role:entity,cmd:list,name:<entity-name>`: This is used to list all the entities
    that are matching a query.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role:entity,cmd:remove,name:<entity-name>`: This is used to remove an entity
    using its ID.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seneca also provides some wrapper functions that extract these actions and make
    it easy to call these actions. These functions are `load$`, `save$`, `list$`,
    and `remove$`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement the login and register actions to allow us to log in and also
    register new accounts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the account action. Update this code in the `account.js`
    file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument of the callback passed to the `add` method holds reference
    to the object that matched against the pattern of the action.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Here we are first calling the `make` method of the `seneca` object. It's used
    to get reference of an entity's store. For example, in case of MySQL, the `make`
    method gets reference to a table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will find whether there are any entities with the username and password
    passed by the `act` method. As entities are added as objects, to query for entities,
    we need to pass an object. Now `list$` looks for all entities with the same username
    and password.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We are passing a callback to the `$list` method that will be invoked asynchronously
    once the data is retrieved. This callback takes two parameters, that is, the first
    parameter is an `error` object if there is an error, otherwise `null`.Similarly,
    the second parameter is an array of entities found matching the given object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For the action to respond back, it needs to call the second parameter of the
    action callback by passing it an object as the second argument. In case an error
    has occurred, we need to pass the error in the first argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, now let''s write the code for the register action, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, most of the code is understandable as it works the same way as the previous
    action. To store data, we are creating a new entity store reference using the
    `data$` method by passing the entity we want to store. Then we are calling the
    `save$` method to save the entity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about storing data in Seneca, visit [http://senecajs.org/data-entities.html](http://senecajs.org/data-entities.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Express and Seneca
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have completed creating our login and register actions. Now, as our backend
    will be used by an app or it may represent as a website, we need to provide URLs
    to the clients who will use them to talk to the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic core is the part of our server-side application that the client interacts
    with for most of the functionality. Clients can also interact with services directly
    for some specific functionality if required.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to use some sort of website development framework in the monolithic
    core and services of our server-side application. We will be using Express, as
    it's the most popular one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Seneca also provides a built-in way to map the URLs to actions, that is, requests
    made to an HTTP server can be automatically mapped to a particular action to invoke
    them. This is done using a definition object whose properties define a route mapping
    from URLs to action patterns. This built-in method defines route mapping independent
    of the framework being used. Once we have defined the definition objects, we need
    a plugin specific to the web server framework that will capture and resolve the
    URLs to action patterns using the definition objects. Definition object allows
    you to attach callbacks that will get the response of the action via a parameter,
    and then the callbacks can return the data to the user in whatever format they
    want. This can be useful in case you are creating a plugin for distribution that
    exposes a few actions that need to be called for specific URL requests, then you
    will have to use the built-in method, as it defines route mapping independent
    of the framework being used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 还提供了一种内置方式将 URL 映射到动作，即发送到 HTTP 服务器的请求可以自动映射到特定的动作以调用它们。这是通过一个定义对象完成的，其属性定义了从
    URL 到动作模式的路由映射。这个内置方法定义了独立于所使用的框架的路由映射。一旦我们定义了定义对象，我们需要一个特定于 Web 服务器框架的插件来捕获并解析
    URL 到动作模式，使用定义对象。定义对象允许你附加回调函数，这些回调函数将通过参数获取动作的响应，然后回调函数可以以他们想要的任何格式将数据返回给用户。如果你正在创建一个需要公开一些特定
    URL 请求的调用动作的插件进行分发，那么你将不得不使用内置方法，因为它定义了独立于所使用的框架的路由映射。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about how to use the built-in way to integrate Seneca and
    Express at [https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web)了解更多如何使用内置方式将
    Seneca 和 Express 集成。
- en: 'Add the following code to the `main.js` file to start the Express server in
    it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main.js` 文件中，以在其中启动 Express 服务器：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the second line, we are exporting a middleware function provided by the `seneca-web`
    plugin. `seneca-web` is the plugin to integrate Seneca and Express directly, that
    is, to translate URLs into action patterns using the definition object for Express
    framework. This is only required if we use the definition object to define route
    mapping. We won't be using definition objects, but we should still use `seneca-web`,
    as some third-party plugins may use definition objects if we are using these plugins.
    For example, if you are using the `seneca-auth` plugin, then you will have to
    include second line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们导出由 `seneca-web` 插件提供的中间件函数。`seneca-web` 是用于直接集成 Seneca 和 Express 的插件，即使用
    Express 框架的定义对象将 URL 转换为动作模式。如果我们使用定义对象来定义路由映射，则这是必需的。我们不会使用定义对象，但我们应该仍然使用 `seneca-web`，因为如果使用这些插件，一些第三方插件可能会使用定义对象。例如，如果你使用
    `seneca-auth` 插件，那么你将不得不包含第二行。
- en: 'We want the user to be able to log in using the `/account/login` path and register
    using the `/account/register` path. The user will provide a username and password
    via query string. Here is the code to define routes to handle HTTP requests for
    login and registration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够通过 `/account/login` 路径登录，并通过 `/account/register` 路径注册。用户将通过查询字符串提供用户名和密码。以下是定义处理登录和注册
    HTTP 请求路由的代码：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we are calling the appropriate actions depending on the path of the URL
    request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据 URL 请求的路径调用适当的动作。
- en: Here, instead of using `seneca.act`, we are using `httpRequest.seneca.act` as
    the middleware function that we exported earlier adds a new `seneca` property
    to request the object of every HTTP requests. This property inherits the actual
    `seneca` instance. Actions in the third-party plugins add information in form
    of properties to the `seneca` property in order to share information related to
    a particular HTTP request with other route handers. The preceding code will behave
    in the same way even if we use `seneca.act`, but it's a good practice to use `httpRequest.seneca.act`
    as we may use such types of plugins. Your own route handlers can also use `httpRequest.seneca.act`
    to pass information related to `seneca` to each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是使用 `seneca.act`，而是使用 `httpRequest.seneca.act` 作为我们之前导出的中间件函数，它为每个 HTTP
    请求对象添加一个新的 `seneca` 属性。这个属性继承实际的 `seneca` 实例。第三方插件中的动作通过将属性添加到 `seneca` 属性中，以便与其他路由处理器共享与特定
    HTTP 请求相关的信息。即使我们使用 `seneca.act`，前面的代码也会以相同的方式运行，但使用 `httpRequest.seneca.act`
    是一个好习惯，因为我们可能会使用这种类型的插件。你自己的路由处理器也可以使用 `httpRequest.seneca.act` 来传递与 `seneca`
    相关的信息。
- en: 'Now, to run the application, first run the `account-service.js` file and then
    the `main.js` file. You can then log in and register using the following URLs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行应用程序，首先运行 `account-service.js` 文件，然后运行 `main.js` 文件。您可以使用以下 URL 登录和注册：
- en: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
- en: '`http://localhost:8080/account/register?username=x&password=mypassword`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/register?username=x&password=mypassword`'
- en: Here, we saw how to create a web interface, which can be used by an app or to
    serve HTML pages in case it's a website.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了如何创建一个网页界面，它可以被应用程序使用，或者如果是一个网站，可以用来提供 HTML 页面。
- en: We can also move the routes of Express to a service if we want a different service
    to handle certain requests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望不同的服务来处理某些请求，我们也可以将 Express 的路由移动到该服务中。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the difference between monolithic and microservices
    architecture. Then we discussed what microservices architecture with monolithic
    core means and its benefits. Finally, we jumped into the Seneca framework for
    implementing microservices architecture with monolithic core and discussed how
    to create a basic login and registration functionality to demonstrate various
    features of the Seneca framework and how to use it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了单体架构和微服务架构之间的区别。然后我们讨论了具有单体核心的微服务架构的含义及其优势。最后，我们探讨了使用 Seneca 框架实现具有单体核心的微服务架构，并讨论了如何创建基本的登录和注册功能来展示
    Seneca 框架的各种特性以及如何使用它。
- en: In the next chapter, we will create a fully functional e-commerce website using
    Seneca and Express frameworks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Seneca 和 Express 框架创建一个功能齐全的电子商务网站。
