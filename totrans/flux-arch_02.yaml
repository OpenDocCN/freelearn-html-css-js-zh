- en: Chapter 2. Principles of Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you were introduced at a 10,000 foot level to some
    of the core Flux principles. For example, unidirectional data-flow is central
    to Flux's existence. The aim of this chapter is to go beyond the simplistic view
    of Flux principles.
  prefs: []
  type: TYPE_NORMAL
- en: We'll kick things off with a bit of an MVC retrospective—to identify where it
    falls apart when we're trying to scale a frontend architecture. Following this,
    we'll take a deeper look at at unidirectional data-flow and how it solves some
    of the scaling issues we've identified in MVC architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll address some high-level compositional issues faced by Flux architectures,
    such as making everything explicit and favoring layers over deep hierarchies.
    Finally, we'll compare the various kinds of state found in a Flux architecture
    and introduce the concept of an update round.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with MV*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MV* is the prevailing architectural pattern of frontend JavaScript applications.
    We're referring to this as MV* because there's a number of accepted variations
    on the pattern, each of which have models and views as core concepts. For our
    discussions in this book, they can all be considered the same style of JavaScript
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: MV* didn't gain traction in the development community because it's a terrible
    set of patterns. No, MV* is popular because it works. Although Flux can be thought
    of as a sort of MV* replacement, there's no need to go out and tear apart a working
    application.
  prefs: []
  type: TYPE_NORMAL
- en: There's no such thing as a perfect architecture, and Flux is by no means immune
    to this fact. The goal of this section isn't to downplay MV* and all the things
    it does well, but rather to look at some of the MV* weaknesses and see how Flux
    steps in and improves the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing MV* is really good at is establishing a clear separation of concerns.
    That is, a component has one responsibility, while another component is responsible
    for something else, and so on, all throughout the architecture. Complementary
    to the *separation of concerns* principle is the *single responsibility* principle,
    which enforces a clear separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care though? The simple answer is that when we separate responsibilities
    into different components, different parts of the system are naturally decoupled
    from one another. This means that we can change one thing without necessarily
    impacting the other. This is a desired trait of any software system, regardless
    of the architecture. But, is this really what we get with MV*, and is this actually
    something we should shoot for?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, maybe there''s no clear advantage in dividing a feature into five
    distinct responsibilities. Maybe the decoupling of the feature''s behavior doesn''t
    actually achieve anything because we would have to touch all five components every
    time we want to change something anyway. So rather than help us craft a robust
    architecture, the separation of concerns principle has amounted to nothing more
    than needles indirection that hampers productivity. Here''s an example of a feature
    that''s broken down into several pieces of focused responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separation of concerns](img/B05419_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Anytime a developer needs to pull apart a feature so that they can understand
    how it works, they end up spending more time jumping between source code files.
    The feature feels fragmented, and there''s no obvious advantage to structuring
    the code like this. Here''s a look at the moving parts that make up a feature
    in a Flux architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separation of concerns](img/B05419_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Flux feature decomposition leaves us with a feeling of predictability. We've
    left out the potential ways in which the view itself could be decomposed, but
    that's because the views are outside Flux. All we care about in terms of our Flux
    architecture is that the correct information is always passed to our views when
    state changes occur.
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that the logic and state of a given Flux feature are tightly coupled
    with one another. This is in contrast to MV*, where we want application logic
    to be a standalone entity that can operate on any data. The opposite is true with
    Flux, where we'll find the logic responsible for change state in close proximity
    to that state. This is an intentional design trait, with the implication being
    that we don't need to get carried away with separating concerns from one another,
    and that this activity can sometimes hurt rather than help.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see in the coming chapters, this tight coupling of data and logic is
    characteristic of Flux stores. The preceding diagram shows that with complex features,
    it's much easier to add more logic and more state, because they're always near
    the surface of the feature, rather than buried in a nested tree of components.
  prefs: []
  type: TYPE_NORMAL
- en: Cascading updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s nice when we have a software component that *just works*. This could
    mean any number of things, but it''s meaning is usually centered around automatically
    handling things for us. For instance, instead of manually having to invoke this
    method, followed by that method, and so on, everything is handled by the component
    for us. Let''s take a look at the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cascading updates](img/B05419_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we pass input into a larger component, we can expect that it will do the
    right thing automatically for us. What's compelling about these types of components
    is that it means less code for us to maintain. After all, the component knows
    how to update itself by orchestrating the communication between any subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the cascading effect begins. We tell one component to perform
    some behavior. This, in turn, causes another component to react. We give it some
    input, which causes another component to react, and so on. Soon, it's very difficult
    to comprehend what's going on in our code. This is because the things that are
    *taken care of* for us are hidden from view. Intentional by design, with unintended
    consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous diagram isn''t too bad. Sure, it might get a little difficult
    to follow depending on how many subcomponents get added to the larger component,
    but in general, it''s a tractable problem. Let''s look at a variation of this
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cascading updates](img/B05419_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened? Three more boxes and four more lines just happened, resulting
    in an explosion of cascading update complexity. The problem is no longer tractable
    because we simply cannot handle this type of complexity, and most MV* applications
    that rely on this type of automatic updating have way more than six components.
    The best we can hope for is that once it works the way we want it to, it keeps
    working.
  prefs: []
  type: TYPE_NORMAL
- en: This is the naive assumption that we make about automatically updating components—this
    is something we want to encapsulate. The problem is that this generally isn't
    true, at least not if we ever plan to maintain the software. Flux sidesteps the
    problem of cascading updates because only a store can change it's own state, and
    this is always in response to an action.
  prefs: []
  type: TYPE_NORMAL
- en: Model update responsibilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an MV* architecture, state is stored within models. To initialize model
    state, we could fetch data from the backend API. This is clear enough: we create
    a new model, then tell that model to go fetch some data. However, MV* doesn''t
    say anything about who is responsible for updating these models. One might think
    it''s the controller component that should have total control over the model,
    but does this ever happen in practice?'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, what happens in view event handlers, called in response to user
    interactivity? If we only allow controllers to update the state of our models,
    then the view event handler functions should talk directly to the controller in
    question. The following diagram is a visualization of a controller changing the
    state of models in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model update responsibilities](img/B05419_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance, this controller setup makes perfect sense. It acts as a wrapper
    around the models that store state. It's a safe assumption the anything that wants
    to mutate any of these models needs to go through the controller. That's its responsibility
    after all—to control things. Data that comes from the API, events triggered by
    the user and handled by the view, and other models—these all need to talk to the
    controller if they want to change the state of the models.
  prefs: []
  type: TYPE_NORMAL
- en: As our controller grows, making sure that model state changes are handled by
    the controller will produce more and more methods that change the model state.
    If we step back and look at all of these methods as they accumulate, we'll start
    to notice a lot of needless indirection. What do we stand to gain by proxying
    these state changes?
  prefs: []
  type: TYPE_NORMAL
- en: Another reason the controller is a dead-end for trying to establish consistent
    state changes in MV* is the changes that models can make to themselves. For example,
    setting one property in a model could end up changing other model properties as
    a side-effect. Worse, our models could have listeners that respond to state changes,
    somewhere else in the system (the cascading updates problem).
  prefs: []
  type: TYPE_NORMAL
- en: Flux stores deal with the cascading updates problem by only allowing state changes
    via actions. This same mechanism solves the MV* challenges discussed here; we
    don't have to worry about views or other stores directly changing the state of
    our store.
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectional data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cornerstone of any Flux architecture is unidirectional data-flow. The idea
    being data flows from point A to point B, or from point A to B to C, or from point
    A to C. It's the direction that's important with unidirectional data-flow, and
    to a lesser extent, the ordering. So when we say that our architecture uses a
    unidirectional data-flow, we can say that data never flows from point B to point
    A. This is an important property of Flux architectures.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous section, MV* architectures have no discernible direction
    with their data-flows. In this section, we'll talk though some of the properties
    that make a unidirectional data-flow worth implementing. We'll begin with a look
    at the starting points and completion points of our data-flows, and then we'll
    think about how side-effects can be avoided when data flows in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: From start to finish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If data-flows in only one direction, there has to be both a starting point
    and a finish point. In other words, we can''t just have an endless stream of data,
    which arbitrarily affects the various components the data-flows through. When
    data-flows are unidirectional with clearly defined start and finish points, there''s
    no way we can have circular flows. Instead, we have one big data-flow cycle in
    Flux, as visualized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![From start to finish](img/B05419_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is obviously an over-simplification of any Flux architecture, but it does
    serve to illustrate the start and finish points of any given data-flow. What we're
    looking at is called an **update round**. A round is atomic in the sense that
    it's run-to-completion—there's no way to stop an update round from completing
    (unless an exception is thrown).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a run-to-completion language, meaning that once a block of code
    starts running, it's going to finish. This is good because it means that once
    we start updating the UI, there's no way a callback function can interrupt our
    update. The exception to this is when our own code interrupts the updating process.
    For example, our store logic that's meant to mutate the state of the store dispatches
    an action. This would be bad news for our Flux architecture because it would violate
    the unidirectional data-flow. To prevent this, the dispatcher can actually detect
    when a dispatch takes place inside of an update round. We'll have more on this
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update rounds are responsible for updating the state of the entire application,
    not just the parts that have subscribed to a particular type of action. This means
    that as our application grows, so do our update rounds. Since an update round
    touches every store, it may start to feel as though the data is flowing sideways
    through all of our stores. Here''s an illustration of the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![From start to finish](img/B05419_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the perspective of unidirectional data-flow, it doesn't actually matter
    how many stores there are. The important thing to remember is that the updates
    will not be interrupted by other actions being dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: No side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw with MV* architectures, the nice thing about automatic state changes
    is also their demise. When we program by hidden rules, we're essentially programming
    by stitching together a bunch of side-effects. This doesn't scale well, mainly
    due to the fact that it's impossible to hold all these hidden connections in our
    head at a given point in time. Flux likes to avoid side-effects wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about stores for a moment. These are the arbiters of state in
    our application. When something changes state, it has the potential to cause another
    piece of code to run in response. This does indeed happen in Flux. When a store
    changes state, views may be notified about the change, if they''ve subscribed
    to the store. This is the only place where side-effects happen in Flux, which
    is inevitable since we do need to update the DOM at some point when state changes.
    But what''s different about Flux is how it avoids side-effects when there''s data
    dependencies involved. The typical approach to dealing with data dependencies
    in user interfaces is to notify the dependent model that something has happened.
    Think cascading updates, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![No side-effects](img/B05419_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When there's a dependency between two stores in Flux, we just need to declare
    this dependency in the dependent store. What this does is it tells the dispatcher
    to make sure that the store we depend on is always updated first. Then, the dependent
    store can just directly use the store data it depends on. This way, all of the
    updates can still take place within the same update round.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit over implicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With architectural patterns, the tendency is to make things easier by veiling
    them behind abstractions that grow more elaborate with time. Eventually, more
    and more of the system's data changes automatically and developer convenience
    is superseded by hidden complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This is a real scalability issue, and Flux handles it by favoring explicit actions
    and data transformations over implicit abstractions. In this section, we'll explore
    the benefits of explicitness along with the trade-offs to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Updates via hidden side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen already, in this chapter, how difficult it can be to deal with
    hidden state changes that hide behind abstractions. They help us avoid writing
    code, but they also hurt by making it difficult to comprehend an entire work-flow
    when we come back and look at the code later. With Flux, state is kept in a store,
    and the store is responsible for changing its own state. What''s nice about this
    is that when we want to inquire about how a given store changes state, all the
    state transformation code is there, in one place. Let''s look at an example store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a store with a simple `state` object. In the constructor, the
    store registers a callback function with the `dispatcher`. All state transformations
    take place, explicitly, in one function. This is where data turns into information
    for our user interface. We don't have to hunt down the little bits and pieces
    of data as they change state across multiple components; this doesn't happen in
    Flux.
  prefs: []
  type: TYPE_NORMAL
- en: So the question now becomes, how do views make use of this monolithic state
    data? In other types of frontend architecture, the views get notified whenever
    any piece of state changes. In the preceding example, a view gets notified when
    the `clickable` property changes, and again when the `display` property changes.
    The view has logic to render these two changes independently of one another. However,
    views in Flux don't get fine-grained updates like these. Instead, they're notified
    when the store state changes and the state data is what's given to them.
  prefs: []
  type: TYPE_NORMAL
- en: The implication here is that we should lean toward view technology that's good
    at re-rendering whole components. This is what makes React a good fit for Flux
    architectures. Nonetheless, we're free to use any view technology we please, as
    we'll see later on in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Data changes state in one place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the preceding section, the store transformation code is encapsulated
    within the store. This is intentional. The transformation code that mutates a
    store's state is supposed to live nearby. Close proximity drastically reduces
    the complexity of figuring out where state changes happen as systems grow more
    complex. This makes state changes explicit, instead of abstract and implicit.
  prefs: []
  type: TYPE_NORMAL
- en: One potential trade-off with having a store manage all of the state transformation
    code is that there could be a lot of it. The code we looked at used a single `switch`
    statement to handle all of the state transform logic. This would obviously cause
    a bit of a headache later on when there's a lot of cases to handle. We'll think
    about this more later in the book, when the time comes to consider large, complex
    stores. Just know that we can re-factor our stores to elegantly handle a large
    number of cases, while keeping the coupling of business logic and state tight.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us right back to the separation of concerns principle. With Flux
    stores, the data and the logic that operates on it isn't separated at all. Is
    this actually a bad thing though? An action is dispatched, a store is notified
    about it, and it changes its state (or does nothing, ignoring the action). The
    logic that changes the state is located in the same component because there's
    nothing to gain by moving it somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Too many actions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions make everything that happens in a Flux architecture explicit. By everything,
    I mean everything—if it happens, it was the result of an action being dispatched.
    This is good because it's easy to figure out where actions are dispatched from.
    Even as the system grows, action dispatches are easy to find in our code, because
    they can only come from a handful of places. For example, we won't find actions
    being dispatched within stores.
  prefs: []
  type: TYPE_NORMAL
- en: Any feature we create has the potential to create dozens of actions, if not
    more. We tend to think that more means bad, from an architectural perspective.
    If there's more of something, it's going to be more difficult to scale and to
    program with. There's some truth to this, but if we're going to have a lot of
    something, which is unavoidable in any large system, it's good that it's actions.
    Actions are relatively lightweight in that they describe something that happens
    in our application. In other words, actions aren't heavyweight items that we need
    to fret over having a lot of.
  prefs: []
  type: TYPE_NORMAL
- en: Does having a lot of actions mean that we need to cram them all into one huge
    monolithic actions module? Thankfully, we don't have to do this. Just because
    actions are the entry point into any Flux system, doesn't mean that we can't modularize
    them to our liking. This is true of all the Flux components we develop, and we'll
    keep an eye open for ways that we can keep our code modular as we progress through
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Layers over hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User interfaces are hierarchical in nature, partly because HTML is inherently
    hierarchical and partly because of the way that we structure the information presented
    to users. For example, this is why we have nested levels of navigation in some
    applications—we can't possibly fit everything on the screen at once. Naturally,
    our code starts to reflect this hierarchical structure by becoming a hierarchy
    itself. This is good in the sense that it reflects what the user sees. It's bad
    in the sense that deep hierarchies are difficult to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at hierarchical structures in frontend architectures
    and how Flux is able to avoid complex hierarchies. We'll first cover the idea
    of having several top-level components, each with their own hierarchies. Then,
    we'll look at the side-effects that happen within hierarchies and how data-flows
    through Flux layers.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple component hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A given application probably has a handful of major features. These are often
    implemented as the top-level components or modules in our code. These aren''t
    monolithic components; they''re decomposed into smaller and smaller components.
    Perhaps some of these components share the smaller multipurpose components. For
    example, a top-level component hierarchy might be composed of models, views, and
    controllers as is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple component hierarchies](img/B05419_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This makes sense in terms of the structure of our application. When we look
    at pictures of component hierarchies, it's easy to see what our application is
    made of. Each of these hierarchies, with the top-level component as their root,
    are like a little universes that exist independently of one anothers. Again, we're
    back to the notion of separation of concerns. We can develop one feature without
    impacting another.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that user interface features often depend
    on other features. In other words, the state of one component hierarchy will likely
    depend on the state of another. How do we keep these two component trees synchronized
    with one another when there's no mechanism in place to control when state can
    change? What ends up happening is that a component in one hierarchy will introduce
    an arbitrary dependency to a component in another hierarchy. This serves a single
    purpose, so we have to keep introducing new inter-hierarchy dependencies to make
    sure everything is synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy depth and side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge with hierarchies is depth. That is, how far down will a given
    hierarchy extend? The features of our application are constantly changing and
    expanding in scope. This can lead to our component trees growing taller. But they
    also grow wider. For example, let's say that our feature uses a component hierarchy
    that's three levels deep.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add a new level. Well, we''ll probably have to add several new components
    to this new level and in higher levels. So to build upon our hierarchies, we have
    to scale in multiple directions—horizontally and vertically. This idea is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy depth and side-effects](img/B05419_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling components in multiple directions is difficult, especially in component
    hierarchies where there's no data-flow direction. That is, input that ends up
    changing the state of something can enter the hierarchy at any level. Undoubtedly,
    this has some sort of side-effect, and if we're dependent on components in other
    hierarchies, all hope is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Data-flow and layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flux has distinct architectural layers, which are more favorable to scaling
    architectures than hierarchies are. The reason is simple—we only need to scale
    components horizontally, within each layer of the architecture. We don''t need
    to add new components to a layer and add new layers. Let''s take a look at what
    scaling a Flux architecture looks like in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data-flow and layers](img/B05419_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: No matter how large an application gets, there's no need to add new architectural
    layers. We simply add new components to these layers. The reason we're able to
    do this without creating a tangled mess of component connections within a given
    layer is because all three layers play a part in the update round. An update round
    starts with an action and completes with the last view that is rendered. The data-flows
    through our application from layer to layer, in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: Application data and UI state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a separation of concerns that sticks presentation in one place
    and application data in another, we have two distinct places where we need to
    manage state. Except in Flux, the only place where there's state is within a store.
    In this section, we'll compare application data and UI data. We'll then address
    the transformations that ultimately lead to changes in the user interface. Lastly,
    we'll discuss the feature-centric nature of Flux stores.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the same thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, application data that''s fetched from an API is fed into some
    kind of view layer. This is also known as the presentation layer, responsible
    for transforming application data into something of value for the user—from data
    to information in other words. In these layers, we end up with state to represent
    the UI elements. For example, is the checkbox checked? Here is an illustration
    of how we tend to group the two types of state within our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two of the same thing](img/B05419_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This doesn''t really fit well with Flux architectures, because stores are where
    state belongs, including the UI. So, can a store have both application and UI
    state within it? Well, there isn''t a strong argument against it. If everything
    that has a state is self-contained within a store, it should be fairly simple
    to discern between application data and state that belongs to UI elements. Here''s
    an illustration of the types of state found in Flux stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two of the same thing](img/B05419_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fundamental misconception with trying to separate UI state from other state
    is that components often depend on UI state. Even UI components in different features
    can depend on each other's state in unpredictable ways. Flux acknowledges this
    and doesn't try to treat UI state as something special that should be split off
    from application data.
  prefs: []
  type: TYPE_NORMAL
- en: The UI state that ultimately ends up in a store can be derived from a number
    of things. Generally, two or more items from our application data could determine
    a UI state item. A UI state could be derived from another UI state, or from something
    more complex, like a UI state and other application data. In other cases, the
    application data is simple enough that it can be consumed directly by the view.
    The key is that the view has enough information that it can render itself without
    having to track its own state.
  prefs: []
  type: TYPE_NORMAL
- en: Tightly coupled transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application data and UI state are tightly coupled together in Flux stores. It
    only makes sense that the transformations that operate on this data be tightly
    coupled to the store as well. This makes it easy for us to change the state of
    the UI based on other application data or based on the state of other stores.
  prefs: []
  type: TYPE_NORMAL
- en: If our business logic code wasn't in the store, then we'd need to start introducing
    dependencies to the components containing the logic needed by the store. Sure,
    this would mean generic business logic that transforms the state, and this could
    be shared in several stores, but this seldom happens at a high level. Stores are
    better off keeping their business logic that transforms the state of the store
    tightly coupled. If we need to reduce repetitive code, we can introduce smaller,
    more fine-grained utility functions to help with data transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can get generic with our stores as well. These stores are abstract and don't
    directly interface with views. We'll go into more detail on this advanced topic
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Feature centric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the data transformations that change the state of a store are tightly coupled
    to the store itself, does this mean that the store is tailored for a specific
    feature? In other words, do we care about stores being reused for other features?
    Sure, in some cases we have generic data that doesn't make much sense in repeating
    several times across stores. But generally speaking, stores are feature specific.
    Features are synonymous with domains in Flux parlance—everyone divides up the
    capabilities of their UI in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: This is a departure from other architectures that base their data models on
    the data model of the API. Then, they use these models to create more specific
    view models. Any given MV* framework will have loads of features in their model
    abstractions, things like data bindings and automatic API fetching. They're only
    worried about storing state and publishing notifications when this state changes.
  prefs: []
  type: TYPE_NORMAL
- en: When stores encourage us to create and store new state that's specific to the
    UI, we can more easily design for the user. This is the fundamental difference
    between stores in Flux and models in other architectures—the UI data model comes
    first. The transformations within stores exist to ensure that the correct state
    is published to views—everything else is secondary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the driving principles of Flux. These should
    be in the back your mind as you work on any Flux architecture. We started the
    chapter off with a brief retrospective of MV* style architectures that permeate
    frontend development. Some challenges with this style of architecture include
    cascading model updates and a lack of data-flow direction. We then looked at the
    prize concept of Flux—unidirectional data-flow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered how Flux favors explicit actions over implicit abstractions.
    This makes things easier to comprehend when reading Flux code, because we don't
    have to go digging around for the root cause of a state change. We also looked
    at how Flux utilizes architectural layers to visualize how data-flows in one direction
    through the system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we compared application data with state that's generally considered
    specific to UI elements. Flux stores tend to focus on state that's relevant to
    the feature it supports, and doesn't distinguish between application data and
    UI state. Now that we have a handle on the principles that drive Flux architectures,
    it's time for us to code one. In the next chapter, we'll implement our skeleton
    Flux architecture, allowing us to focus on information design.
  prefs: []
  type: TYPE_NORMAL
