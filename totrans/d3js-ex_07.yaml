- en: Chapter 7. Creating Animated Visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to look at using D3.js transitions to represent changes in
    the information underlying a visual. We will start with examples for examining
    several concepts involved in using D3.js to animate the properties of visual elements
    from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will extend the bubble visualization from [Chapter
    6](ch06.html "Chapter 6. Creating Scatter and Bubble Plots"), *Creating Scatter
    and Bubble Plots*, to demonstrate how we can animate our bubbles as we move through
    multiple years of data. This will demonstrate the construction of a relatively
    complex animation through which a user can easily deduce trends in the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics through examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating using transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the fill color of a rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating multiple properties simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaying an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating chained transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the start and end events of transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the content and size of text using tweening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using timers to schedule the steps of an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding a fifth dimension to a bubble chart through animation: time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3.js provides extensive capabilities for animating your visualizations. Through
    the use of animation, we can provide the viewer with a means to understanding
    how data changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: Animation in D3.js is all about changing the properties of the visual objects
    over time. When these properties are changed, the DOM is updated and the visual
    is modified to represent the new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To animate properties, D3.js provides the following capabilities that we will
    examine:'
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolators and tweenings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating using transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3.js animations are implemented via the concept of **transitions**. Transitions
    provide instructions and information to D3.js for changing one or more visual
    attribute values over a specific duration of time.
  prefs: []
  type: TYPE_NORMAL
- en: When D3.js starts a transition on a visual, it calculates the initial style
    and ending style for the element that is being transitioned. These are often referred
    to as the start and end **keyframes**. Each keyframe is a set of styles and other
    properties that you can specify as part of the animation. D3.js will then animate
    those properties from the start values to the end values.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the fill color of a rectangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate a transition in action, we will start with an example and animate
    the color of a rectangle from one color to another. The code for this example
    is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.1): [http://goo.gl/oNJOQ9](http://goo.gl/oNJOQ9)'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we start by creating the following SVG rectangle and setting
    its initial `fill` to `red`, followed by transitioning the fill color to `blue`
    over a period of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the example, you will see a single rectangle that changes from
    red to blue over a period of five seconds. During that time, it smoothly animates
    through intermediate colors such as purple, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating the fill color of a rectangle](img/B04230_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The primary part of this code that does the animation is the following; it
    starts by creating the rectangle and setting its initial color to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The call to `.transition()` informs D3.js that we we want to transition one
    or more properties of the `rect` element that are made to the attributes of the
    rect element using calls to .style() or .attr().
  prefs: []
  type: TYPE_NORMAL
- en: The call to `.transition()` instructs D3.js to track any changes that are made
    to the attributes of the SVG element using calls to `.style()` or `.attr()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we specify that the `fill` of the rectangle should be `blue` at
    the end of the transition. D3.js uses this to calculate the starting and ending
    keyframes, which tracks the fill on the rectangle should change from red to blue
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: When the rendering of these elements begins, D3.js also starts the animation
    and smoothly changes the fill property over the specified period.
  prefs: []
  type: TYPE_NORMAL
- en: Animating multiple properties simultaneously
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiple properties can be animated on an object during a transition. To accomplish
    this, all that is required is to set multiple attributes after the call to `.transition()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code animates the position of the rectangle and
    its size over the five-second period:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.2): [http://goo.gl/2qG0EV](http://goo.gl/2qG0EV)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code extends the previous example by animating not only the fill, but also
    by changing the position to move the rectangle along a diagonal, and modifying
    the size to make the rectangle half the width and height at the end of the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting animation looks like the following image, where the rectangle
    moves along the path of the arrows, while changing both, color and size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating multiple properties simultaneously](img/B04230_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delaying a transition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not want an animation to start instantaneously, you can use a delay.
    A delay defers the start of the transition for the specified period of time.
  prefs: []
  type: TYPE_NORMAL
- en: The following example defers the start of the transition for one second, then
    runs the transition for four seconds, completing the transition in an overall
    time of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.3): [http://goo.gl/Vyd6Pd](http://goo.gl/Vyd6Pd)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the preceding example is the same as the previous one except for
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating chained transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A single transition changes the properties between only one set of keyframes.
    However, it is possible to chain transitions together for providing multiple sequences
    of animations. The following example demonstrates the chaining of two transitions
    (and also a delay at the start).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.4): [http://goo.gl/IfYJmY](http://goo.gl/IfYJmY)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first transition is executed for two seconds and animates the size, color,
    and position of the rectangle to the middle of the SVG area. The second transition
    then moves the rectangle to the upper-right corner for another two seconds while
    still continuing to change its color and size. The total execution time remains
    five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating chained transitions](img/B04230_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling the start and end events of transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to handle the start and end events of a transition using the
    `.each()` function. This is useful for ensuring that the starting or ending style
    is exactly what you desire at the start or end of the transition. This can be
    an issue when interpolators (covered in the next section) are at and exact expected
    value, where the start values are not known until the animation is running, or
    there are browser-specific issues that need to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of a browser issue is that of transparent colors being represented
    by `rgba(0,0,0,0)`. This is black but completely transparent. However, an animation
    using this will always start with fully opaque black. The start event can be used
    to patch up the color at the start of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates hooking on to the start event of the first
    transition and the end event of the second transition by modifying the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.5): [http://goo.gl/746hLo](http://goo.gl/746hLo)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two fundamental changes in this example. The hooking on to the start
    event of the first transition changes the color of the rectangle to green. This
    causes the rectangle to flash from red to green just after the delay finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the second change, which reforms the rectangle to
    yellow at the end of the second animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using the `.each()` function, the function that is called loses
    the context of the selection, and does not know the current item. We can get that
    back using the call to `d3.select(this)`, which will return the current datum
    that the functions are being applied to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In my experience, I have found that the setting of attributes before and after
    transitions must use a consistent notation. If you use `.style()` prior to the
    transition, and then `.attr()` later, even on the same attribute, the transition
    will not work for that attribute. So, if you use `.style()` before `.transition()`,
    make sure to use `.style()` after (and vice versa for `.attr()`).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the content and size of text using tweening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tweening** provides a means of telling D3.js the way to calculate property
    values during transitions without D3.js tracking the keyframes. Keyframes can
    be a performance issue when animating a large quantity of items, so tweening can
    help out in such situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Tweening gives us the opportunity to connect in our own **interpolator** for
    providing values at each step during an animation. An interpolator is a function
    that is passed a single value between 0.0 and 1.0, which represents the current
    percentage of the transition completed. The implementation of the interpolator
    then uses this value to calculate the value at that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at two examples of tweening. The first example, available at the
    following link, animates the value of a text item from 0 to 10 over a period of
    ten seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.6): [http://goo.gl/SlWBdp](http://goo.gl/SlWBdp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually something that cannot be done using attribute animation. We
    must call the `.text()` function of the DOM element to set the text, so we cannot
    use that technique to animate the change in content. We have to use tweening.
    The following snippet from the example creates the tween that sets the text content
    during the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter to `.tween()` is simply a name for this tween. The second
    parameter is a factory function which returns another function to D3.js that will
    be called at each step during the transition, passing it the current percentage
    of transition completed.
  prefs: []
  type: TYPE_NORMAL
- en: The factory function is called once for each datum at the start of the animation.
    The function it returns is called repeatedly, and uses the `d3.interpolateRound()`
    function to return rounded numbers between 0 and 10 based upon the value of `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of interpolation functions provided by D3.js, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.interpolateNumber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateRound`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateRgb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateHsl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateLab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateHcl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateArray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateObject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateTransform`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.interpolateZoom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'D3.js also has a function `d3.interpolate(a, b)`, which returns the appropriate
    interpolation function from the previous list based upon the type of the end value
    `b`, using the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: If `b` is a color, `interpolateRgb` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `b` is a string, `interpolateString` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `b` is an array, `interpolateArray` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `b` is an object and not coercible to a number, `interpolateObject` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `interpolateNumber` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a demonstration of `d3.interpolate()` and some of the underlying smarts,
    open the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.7): [http://goo.gl/792lpH](http://goo.gl/792lpH)'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the `.styleTween()` function to change the font property of
    the style for the piece of text, increasing the size of the font from 12 px to
    36 px over five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the content and size of text using tweening](img/B04230_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `.styleTween()` function operates in a way similar to `.tween()` except
    that the first parameter specifies the name of the property that will be set to
    the value which is returned by the interpolation function provided by the factory
    method. There is also a `.attrTween()` function that does the same but on an attribute
    instead of a style.
  prefs: []
  type: TYPE_NORMAL
- en: The function `d3.interpolate()` is smart enough to determine that it should
    use `d3.interpolateString()`, and to identify that the two strings represent a
    font size and name besides performing the appropriate interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3.js manages transitions using timers that internally schedule the code to
    be run at a specific time. These timers are also exposed for your use.
  prefs: []
  type: TYPE_NORMAL
- en: A timer can be created using `d3.timer(yourFunction, [delay], [mark])`, which
    takes a function to be called, a delay, and a starting time. This starting time
    is referred to as the **mark**, and it has a default value of `Date.now`.
  prefs: []
  type: TYPE_NORMAL
- en: D3.js timers are not executed at regular intervals—they are not periodic timers.
    Timers start execution at the time specified by `mark + delay`. The function will
    then be called as frequently as possible by D3.js, until the function it calls
    returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `mark` and `delay` can allow very specific declaration of time for
    starting execution. As an example, the following command schedules an event four
    hours prior to September 1, 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To implement a one-shot timer, simply return `true` from the first call of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on timers, if you want to use a timer to alert you on a regular
    basis, it is often better to use the JavaScript built-in function `setInterval()`.
    We will examine using a timer on a periodic basis in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a fifth dimension to a bubble plot – time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's apply everything we have learned about animation to some real data.
    We are going to revisit our bubble plot visualization from [Chapter 6](ch06.html
    "Chapter 6. Creating Scatter and Bubble Plots"), C*reating Scatter and Bubble
    Plots*, expanding the set of data from a single year (2013) to all the available
    years (1960 through 2013). We will modify the rendering of the visual to periodically
    update and animate the bubbles into new position and sizes based upon the change
    in the values of the data.
  prefs: []
  type: TYPE_NORMAL
- en: The expanded data set is available at [https://goo.gl/rC5WS0](https://goo.gl/rC5WS0).
    The fundamental difference is the inclusion of a year column, and data covering
    54 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for and the demo of the example is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (7.7): [http://goo.gl/iYCNbG](http://goo.gl/iYCNbG)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this, you will see a smooth animation of the data over the years.
    It is obviously impossible to show this effectively in a static medium such as
    a book. But for demonstration, I have provided screenshots of the visualization
    at the start of each decade, except for 2010, which is substituted with the year
    2013:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a fifth dimension to a bubble plot – time](img/B04230_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the years advance, there is a strong tendency for all the countries towards
    an increased lifespan as well as decrease in fertility. This happens at a different
    pace for different countries. But it gives you a really good sense that something
    is going on that is causing this effect. Deciphering the plot is further made
    easier due to the addition of this extra dimension of time to the bubble plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s examine how this is implemented in the example. A good portion of
    the code is identical to that of the example from [Chapter 6](ch06.html "Chapter 6. Creating
    Scatter and Bubble Plots"), *Creating Scatter and Bubble Plots*, which it is based
    upon. The loading and cleansing of the data is slightly different due to a different
    URL and the need to process the `Year` column in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be rendering each year of data one at a time. As a part of this, we
    will need to extract only the data for each specific year. There are a number
    of ways that we can go about this. D3.js provides a very powerful function to
    do this for us: `d3.nest()`. This function pivots the `Year` column into the index
    of an associative array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can then access all the data for a particular year using array semantics
    such as `nested[1975]`, which will give us the data (only the rows) for just 1975.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more info on `d3.nest()`, see [https://github.com/mbostock/d3/wiki/Arrays#-nest](https://github.com/mbostock/d3/wiki/Arrays#-nest).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is then identical through the creation of the axes. The next new piece
    of code is to add a text label on the graph to show the year that the data represents.
    This is positioned in the lower-left corner of the area where the bubbles will
    be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a group is created to contain the bubbles. The rendering function will
    select this group each time it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This marks the beginning of the code that renders and animates the bubbles.
    It starts by declaring the interval for which each year should be drawn (10 times
    per second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the bubbles must be repeatedly rendered, we create a function that can
    be called to render the bubbles for just a specified year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function first extracts the rows for the specific year, and then binds
    the data to the circles in the `bubblesHolder` group. The call to `.data()` also
    specifies that `CountryCode` will be used as the key. This is very important,
    because as we move from year to year, D3.js will use this to map the existing
    bubbles to the new data, making decisions based on this the key on which to enter-update-exit
    the circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statement executes the enter function creating new circles and calling
    a function to set the various attributes of the circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use a function, as this is also used by the code to update. Finally, there
    is a case where occasionally a country disappears from the data, so we will remove
    any bubbles in the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we need to do is perform the time animation. This is done by
    iterating through each year at the specified interval. To do this, we need to
    know the start and ending year, which we can obtain with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows with setting a variable for the current year and rendering that
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a function to be called by a timer. This function returns another
    function which increments the year, and if the year is less than the max year,
    calls render again, and then schedules another timer instance to run at an interval
    of milliseconds. This pattern effectively uses a series of D3.js timers for implementing
    the periodic timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this code returns `true` every time it is called. This makes it a
    one-shot timer. But before returning `true`, if we need to render another year,
    we start another timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to be done is to start the timer for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamentals of animation in D3.js, and by
    the end of the chapter, applied these simple concepts to make what appears to
    be a very complex data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: We started with examples of transitions, using them to animate attributes from
    one state to another across an interval of time, and chaining animations together.
    Next we looked at handling animation without keyframes using tweening. We also
    took a quick look at interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: We finished by examining timers, and then applied all the concepts of the chapter
    to progressively render a large set of data, giving the viewer of the visualization
    a sense of how data changes by animating time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine changing the visuals when the user interacts
    with the application, learning concepts such as the dragging and filtering of
    data based upon interactive events.
  prefs: []
  type: TYPE_NORMAL
