<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Working with Databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Working with Databases</h1></div></div></div><p>Database queries <a id="id254" class="indexterm"/>are also written directly with Opa. Opa currently (Opa 1.1.1) supports the NoSQL databases MongoDB and CouchDB<a id="id255" class="indexterm"/> as well as the SQL database Postgres. Postgres<a id="id256" class="indexterm"/> is still a work in progress and more databases are planned for future releases. Opa provides many unique advanced operators and automates the database queries<a id="id257" class="indexterm"/> for maximal productivity. In this chapter, we will talk briefly about how to work with MongoDB.</p><div class="section" title="A quick start to MongoDB"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec35"/>A quick start to MongoDB</h1></div></div></div><p>First, we need to <a id="id258" class="indexterm"/>download (<a class="ulink" href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a>), install, and run (<a class="ulink" href="http://docs.mongodb.org/manual/installation/">http://docs.mongodb.org/manual/installation/</a>) the MongoDB server. After MongoDB has been<a id="id259" class="indexterm"/> installed properly, let's get started with a simple example:</p><div class="informalexample"><pre class="programlisting">database int /counter = 0;
function page(){
    &lt;h1 id="text"&gt;Hello {/counter}&lt;/h1&gt;
    &lt;input type="button" value="click" onclick={function(_){
          /counter++
          #text = "Hello {/counter}"	
    }}/&gt;}
Server.start(Server.http, {title:"Opa Packt", ~page})</pre></div><p>In the first line of the preceding code, we define a <code class="literal">/counter</code> database path that holds an integer. A database path<a id="id260" class="indexterm"/> describes a position in the database, and we can read, write, update, and delete the data through a database path. Note that the data type of the path cannot be omitted.</p><p>The preceding database is unnamed; we can give a name to the database, for example:</p><div class="informalexample"><pre class="programlisting">database testdb {
    int /counter = 0;
}</pre></div><p>In this way, we should read data from the path <code class="literal">/testdb/counter</code>. Now, let's compile and run the code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ opa 701.opa --</strong></span>
</pre></div><p>When the application starts, it will try to launch the MongoDB server if the server is not already running, and it will store data on the default location <code class="literal">~/.opa/mongo/data</code>. If the server is already running, the application will try to connect to the server. However, we can also use the options <code class="literal">--db-local</code> and <code class="literal">--db-remote</code> to let the program connect to specific databases as we want:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">--db-local:dbname [/path/to/db]</code>: This uses a local database stored at the specified location in the file-system</li><li class="listitem" style="list-style-type: disc"><code class="literal">--db-remote:dbname [username:password@]hostname[:port]</code>: This uses a remote database accessible at a given remote location</li></ul></div><p>For example:</p><div class="informalexample"><pre class="programlisting">$./701.js --db-local:testdb
$./701.js --db-local:testdb ~/data/mongo
$./701.js --db-remote:testdb localhost:27017
$./701.js --db-remote:testdb admin:admin@localhost:27017</pre></div></div></div>
<div class="section" title="Database manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Database manipulation</h1></div></div></div><p>We<a id="id261" class="indexterm"/> can <a id="id262" class="indexterm"/>manipulate data <a id="id263" class="indexterm"/>through database paths. The following piece of code declares a <code class="literal">testdb</code> database and defines several paths: </p><div class="informalexample"><pre class="programlisting">type Student = {int id, string name, int age}
database testdb {
    int               /basic/i     //Basic type int
    float             /basic/f     //Basic type float
    string            /basic/s     //Basic type string
    Student           /stu         //Record
    list(string)      /lst         //List
    intmap(Student)   /stumap      //Map
    Student           /stuset[{id}]     //Set
<code class="literal">}</code>
</pre></div><p>Type student that we defined ourselves. In addition to this type, our example covers the datatypes that are most frequently used in databases.</p><p>Each database path has a default value. Whenever we attempt to read a value that does not exist (either because it was never initialized or it has been removed), the default value is returned. The following list shows the default values for different types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The default value for an integer (int) is 0</li><li class="listitem" style="list-style-type: disc">The default value for a floating-point number (float) is 0.0</li><li class="listitem" style="list-style-type: disc">The default value for a string is ""</li><li class="listitem" style="list-style-type: disc">The default value for a record is the record of default values</li><li class="listitem" style="list-style-type: disc">The default value for a sum type is the value that best resembles the empty case (for example, {none} for option, {nil} for list, and so on)</li></ul></div><p>We can <a id="id264" class="indexterm"/>define an application-specific default value by assigning a value when we declare a path, for example:</p><div class="informalexample"><pre class="programlisting">    database testdb {
        int      /basic/i = 10
        string   /basic/s = "default"
        Student  /stu = {id: 0, name: "unknown", age: 25}
    }</pre></div><p>To read <a id="id265" class="indexterm"/>data from the database, just use a database path, for example:</p><div class="informalexample"><pre class="programlisting">int i = /testdb/basic/i
Student stu = /testdb/stu</pre></div><p>We can<a id="id266" class="indexterm"/> prefix the path with a question mark (<code class="literal">?</code>) then give the path a value that is one of two options, whereby <code class="literal">{some: x}</code> indicates that the value of that path is <code class="literal">x</code>, and <code class="literal">{none}</code> indicates that the path has not been written to yet, for instance:</p><div class="informalexample"><pre class="programlisting">match (?/testdb/basic/i) {
case {none}: println("unknown");
case {some: x}: println("{x}");
}</pre></div><p>The preceding example prints <span class="strong"><strong>unknown</strong></span> if the path <code class="literal">/testdb/basic/i</code> has not been written to yet or has been removed, otherwise it prints the value of the path.</p><p>To write or update the database path, use a operator <code class="literal">=</code>. We can also use <code class="literal">&lt;-</code> to assign the value, it's the same as <code class="literal">=</code>. For example:</p><div class="informalexample"><pre class="programlisting">/testdb/basic/i = 10
/testdb/basic/i &lt;- 10 //the same as above
/testdb/basic/s = "my new string"
/testdb/stu = {id: 1, name: "Li", age: 28}In addition, you can also use the following shortcuts to update integers in database:
/testdb/basic/i++;     //add the integer i by 1
/testdb/basic/i += 5;  //add the integer i by 5
/testdb/basic/i -= 10;	 //minus the integer i by 10</pre></div><p>To delete<a id="id267" class="indexterm"/> data held at a path, use the <code class="literal">Db.remove(@path)</code> function, <a id="id268" class="indexterm"/>where <code class="literal">@path</code> is a reference to a path. We can get a path reference by adding an <code class="literal">@</code> sign before the path, for example:</p><div class="informalexample"><pre class="programlisting">Db.remove(@/testdb/basic/i)
Db.remove(@/testdb/stu)</pre></div><div class="section" title="Records"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Records</h2></div></div></div><p>With <a id="id269" class="indexterm"/>records, we can do complete reads and updates in the same manner as for basic types:</p><div class="informalexample"><pre class="programlisting">stu = /testdb/stu;                         //read record
/testdb/stu = {id: 1, name: "Li", age: 28} //update record</pre></div><p>Sometimes, we need to enforce that the record should be modified only as a whole. This is known as <span class="strong"><strong>full modification</strong></span><a id="id270" class="indexterm"/>. If a record is declared as being subject to full modification, we must update all fields at once when performing modifications. We add the <code class="literal">full</code> keyword after a database path in order to indicate that this path is subject to full modification. If a given path has not been declared for full modification, we can cross record boundaries and access or update only chosen fields by including them in the path. Consider the following example:</p><div class="informalexample"><pre class="programlisting">type Student = {int id, string name, int age}
database testdb {
    Student /stu1
    Student /stu2
    /stu2 full           //declare /stu2 as full modification
}
/testdb/stu1/name = "Li" //OK
/testdb/stu2 = {id:1, name: "Li", age: 28} //OK
/testdb/stu2/name = "Li" //error: will not compile</pre></div><p>We<a id="id271" class="indexterm"/> declared <code class="literal">/stu2</code> for full modification by adding the <code class="literal">/stu2 full</code> statement. Therefore, the compiler reported an error for the last line (<code class="literal">/testdb/stu2/name = "Li"</code>) of the preceding code, in which we tried modifying a single field of the record, namely the <code class="literal">name</code> field.</p></div><div class="section" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Lists</h2></div></div></div><p>As <a id="id272" class="indexterm"/>mentioned in the <span class="emphasis"><em>Lists</em></span> section of <a class="link" href="ch02.html" title="Chapter 2. Basic Syntax">Chapter 2</a>, <span class="emphasis"><em>Basic Syntax</em></span>, lists in Opa are just recursive records. We can manipulate lists in the same manner as records. However, as the datatype list is used frequently, Opa provides shortcuts that are specific to lists:</p><div class="informalexample"><pre class="programlisting">/testdb/lst = ["I", "Love", "Opa", "!"] //Update an entire list
/testdb/lst pop             // Removes first element of a list
/testdb/lst shift           // Removes last element of a list
/testdb/lst &lt;+ "element"    // Append an element
/testdb/lst &lt;++ ["How", "about", "you"] // Append several elements
/testdb/lst &lt;--* "element"              // Remove an element
/testdb/lst &lt;-- ["How", "about", "you"] // Remove several elements</pre></div></div><div class="section" title="Sets and maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Sets and maps</h2></div></div></div><p>We can update <a id="id273" class="indexterm"/>sets and maps in the same way as lists, however, the way we access the elements is different. We can fetch a single value from a given set or map by referencing it by its primary key, for example:</p><div class="informalexample"><pre class="programlisting">stu = /testdb/stuimap[1] //find element whose key is 1
stu = /testdb/stuset[1]  //find element whose primary key is 1
stu = /testdb/stuset[{id:1}] //the same as above
/testdb/stuset[{id:1}] = {name: "Li"}  //update the chosen item</pre></div><p>Furthermore, we can query a set of values by adding the query condition inside the square bracket, for example:</p><div class="informalexample"><pre class="programlisting">/testdb/stuset[id &lt; 10] &lt;- {age: 25}
/testdb/stuset[age &gt;= 25] &lt;- {age++}</pre></div><p>We will look at queries in more detail in the following section.</p></div></div>
<div class="section" title="Querying data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Querying data</h1></div></div></div><p>As we <a id="id274" class="indexterm"/>mentioned<a id="id275" class="indexterm"/> in the previous section, database sets and maps are two types of collections that allows the organization of multiple instances of data in the database. We can query a set of values using the following operators:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>== expr</strong></span>: equals expr
<span class="strong"><strong>!= expr</strong></span>: not equals expr
<span class="strong"><strong>&lt; expr</strong></span>:  lesser than expr
<span class="strong"><strong>&lt;= expr</strong></span>: lesser than or equals expr
<span class="strong"><strong>&gt; expr</strong></span>:  greater than expr
<span class="strong"><strong>&gt;= expr</strong></span>: greater than or equals expr
<span class="strong"><strong>in expr</strong></span>: "belongs to" expr, where expr is a list
<span class="strong"><strong>q1 or q2</strong></span>: satisfy query q1 or q2
<span class="strong"><strong>q1 and q2</strong></span>: satisfy both queries, q1 and q2
<span class="strong"><strong>not q</strong></span>: does not satisfy q
<span class="strong"><strong>{f1 q1, f2 q2, ...}</strong></span>: the database field f1 satisfies q1, field f2 satisfies q2 etc.</pre></div><p>Furthermore, <a id="id276" class="indexterm"/>we can <a id="id277" class="indexterm"/>specify some querying options as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">skip n</code>: Here <code class="literal">expr</code> should be an expression of type <code class="literal">int</code> and it skip the first <span class="emphasis"><em>n</em></span> results.</li><li class="listitem" style="list-style-type: disc"><code class="literal">limit n</code>: Here <code class="literal">expr</code> should be an expression of type <code class="literal">int</code>, returns a maximum of <span class="emphasis"><em>n</em></span> results.</li><li class="listitem" style="list-style-type: disc"><code class="literal">order fld (, fld)+</code>: Here <code class="literal">fld</code> specifies an order. <code class="literal">fld</code> can be a single identifier or a list of identifiers specifying the fields on which the ordering should be based. Identifiers can optionally be prefixed with <code class="literal">+</code> or <code class="literal">-</code> to specify the ascending or descending order. Finally, it is possible to choose the order dynamically with <code class="literal">&lt;ident&gt;=&lt;expr&gt;</code>, where <code class="literal">&lt;expr&gt;</code> should be of type <code class="literal">{up}</code> or <code class="literal">{down}</code>.</li></ul></div><p>The following piece of code gets the next 50 results for students whose age is above 20 and below 45, and they will be ordered by age (ascending) first and then ordered by <code class="literal">id</code> (descending):</p><div class="informalexample"><pre class="programlisting">dbset(Student, _) stus = /testdb/stuset[age &gt;= 20 and age &lt;= 45; skip 50; limit 50; order +age, -id]</pre></div><p>We can create even more complicated query conditions by combining query expressions together. The query operation returns a <code class="literal">dbset</code>. A <code class="literal">dbset</code> is a collection that holds the query result. Therefore, we can iterate over the <code class="literal">dbset</code>. Consider the following code fragment. It queries all students whose name is <code class="literal">Li</code> and prints them out:</p><div class="informalexample"><pre class="programlisting">dbset(Student,_) lis = /testdb/stuset[name == "Li"]
iter it = DbSet.iterator(lis)
Iter.iter(function(li){
println("{li}")
},it) </pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we toured the basic techniques of working with databases. We first gave a very simple example. Then, we discussed how to manipulate data, including retrieving data from databases, writing or updating data, and removing data. We covered both basic types and complex types such as record, list, map, and set. Finally, we talked about how to query data from sets and maps.</p></div></body></html>