- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time for a more advanced topic. You''re ready! We are going to deal with
    the topic of asynchronous code and some options for multitasking with code. This
    concept is called concurrency. Don''t worry if you find this chapter a bit of
    a struggle; this is programming in JavaScript at a high level. These are the topics
    we''ll be dealing with:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async`/`await`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, this is tough, but understanding how to leverage concurrency can really
    enhance the performance of your program by speeding up the process, which is more
    than enough reason to dive into this advanced topic!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Concurrency** is whenever things are happening "at the same time" or *in
    parallel*. To give a non-code example, let''s talk about managing my household.
    When I come home on a Friday night, I have a series of tasks: the kids need to
    eat, to shower, and to be brought to bed, the laundry needs to be folded and laundry
    needs to be put in the machine, and to be fair, a lot more, but this is enough
    to illustrate the example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to do this without being able to do multiple things at once, it would
    be a very tough night and get very late. I would first make dinner—put a pizza
    in the oven and wait next to it—feed the kids, shower them afterward, then bring
    them to bed, and then fold the laundry afterward, turn the machine on again, and
    wait until it''s done. Luckily, I can multitask, so it looks more like this: I
    put the pizza in the oven, in the meantime, I turn the washing machine on and
    maybe fold a few pieces of laundry, then I feed the kids, do the rest of the laundry
    while they shower, and I''m done a lot quicker.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same for your computer and the applications that you use. If it
    weren't able to do multiple things at the same time, you would probably be very
    annoyed. You wouldn't be able to check your mail while you are writing code, you
    wouldn't be able to listen to music while writing code, and a lot more. This is
    your computer switching between different tasks. The same thing can happen at
    the application level. For example, we can do a call to some API and not wait
    for the reply but do something useful in the meantime instead. We can do so using
    the concept of **concurrency**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three strategies in JavaScript that you''ll need to know of when
    working with concurrency: **callbacks**, **Promises**, and the **async** and **await**
    keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Callbacks** are the first thing we should understand when we are talking
    about concurrency. The good news is that the `callback` principle is not too hard
    to understand. It is just a function that takes another function as an argument,
    which is then called when the rest of the initial function has finished. In other
    words, it''s just a function calling a function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the `callback` principle actually doing something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two functions here: `judge()` and `getGrade()`. We call the function
    `getGrade()` with two arguments: `85` and the function `judge()`. Note that when
    calling the function as an argument, we do not include the parantheses. The `judge()`
    function gets stored in a `callback`. After determining the grade, the function
    that is stored in a callback (`judge()` in this case) gets called with the grade.'
  prefs: []
  type: TYPE_NORMAL
- en: This could also be another function that does something more useful than judging,
    for example, sending a certain email based on test results. If we wanted that,
    we actually wouldn't need to change the `getGrade()` function; we just need to
    write a new function to do this and call `getGrade()` with the new function as
    a second argument.
  prefs: []
  type: TYPE_NORMAL
- en: You might be very disappointed right now, because this is not too exciting.
    Callbacks become really valuable in an asynchronous context, for example, when
    one function is still waiting for the results of a call to the database before
    calling the `callback` function that is going to process the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some JavaScript built-in functions work with this callback principle, for example,
    the `setTimeOut()` and `setInterval()` functions. They will take a function that
    is executed after a certain time in the case of a timeout and every certain amount
    of time for the specified interval. We have seen these already, but just as a
    reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The functions that are inserted as arguments are called callbacks here. Understanding
    concurrency really starts with callbacks, but multiple nested callbacks make code
    difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: When this is all written as one function with anonymous functions inside, this
    gets very indented as well. We call this **callback hell** or the **Christmas
    tree problem** (because the code gets nested so much, it looks like a Christmas
    tree on its side).
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are a great concept, but they can create ugly code very fast. There
    is often a better solution, we promise.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 13.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will demonstrate how to use a callback function, creating a way
    to pass a value from one function to another by invoking a callback function.
    We will create a greeting callback using a full name in a string.
  prefs: []
  type: TYPE_NORMAL
- en: Create a function named `greet()` that takes one argument, `fullName`. That
    argument should be an array. Output the items of the array into the console interpolated
    into a greeting message string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a second function that has two arguments: the first one is a string
    for the user''s full name, and the second is the `callback` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split the string into an array using the `split()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the full-name array to the `greet()` function created in the first step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the process of the `callback` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With **Promises**, we can organize the sequence of our code in a slightly easier-to-maintain
    way. A Promise is a special object that connects code that needs to produce a
    result and the code that needs to use this result in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a Promise, we give it a function. In the following example, we
    use a convention that we have seen a lot; we are creating a function on the spot.
    So, inside the argument list we are defining the function, often done using arrow
    functions as well. This function needs two parameters, and these parameters are
    callbacks. We have called them `resolve` and `reject` here.
  prefs: []
  type: TYPE_NORMAL
- en: You can call these parameters anything you want, but `resolve` or `res` and
    `reject` or `rej` are most common.
  prefs: []
  type: TYPE_NORMAL
- en: When `resolve()` is called, the Promise is presumed to be successful and whatever
    is between the arrows is returned and used as input for the `then` method on the
    `Promise` object. If `reject()` is called, the `Promise` failed and the `catch()`
    method on the `Promise` object (if present) is executed with the argument of the
    `reject()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a lot of information that can be hard to understand at first, so here
    is an example of a Promise to help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We first create a Promise. When creating a `Promise`, we don't know what the
    value of the Promise is going to be. This value is whatever is sent as an argument
    to the resolve function. It is a sort of placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when we call then on the Promise, we basically say: figure out what the
    value of the Promise is, and when you know, execute one function if the Promise
    was resolved or a different function if it was rejected. When a Promise is neither
    resolved nor rejected, we say that the Promise is pending.'
  prefs: []
  type: TYPE_NORMAL
- en: '`then()` is a Promise itself, so when it returns we can use the result for
    the next `then()` instance. This means we can chain the `then()` instances, which
    can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resolve functions are implemented with an arrow function. The `return`
    statement is the `value` input for the next function. You can see that the last
    block is a `catch()` function. If any of the functions were to result in a rejection
    and the Promise were therefore rejected, this `catch()` block would be executed
    and print whatever the `reject()` function sent to the `catch()` method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will just log `oops…` because the first Promise was rejected instead of
    resolved. This is great for creating asynchronous processes that need to wait
    till another process is complete. We can try to do a certain set of actions and
    when something goes wrong, use a `catch()` method to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 13.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a counter that will output the values in sequence
    using Promises.
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Promise that resolves with a value of `Start Counting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function named `counter()` that has one argument that gets the value
    and outputs it into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the next function in the Promise with four `then()` instances, which
    should output a value into the counter function, and return a value which will
    provide input for the subsequent `then()` instance. The returned values should
    be `one`, then `two`, then `three`. The screen output in the console should be
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just seen the `Promise` syntax. With the `async` keyword, we can make
    a function return a Promise. This makes the Promises nicer to read and look a
    lot like synchronous (non-concurrent) code. We can use this Promise just like
    we learned in the previous section, or we can use the more powerful `await` keyword
    to wait until the Promise is done. `await` only works in an asynchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an asynchronous context, we can await other Promises as well, as can be
    seen in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Can you figure out what this code does? We call the asynchronous function `talk()`
    three times in a row with no break. Each of these function calls is awaiting the
    `saySomething()` function. The `saySomething()` function contains a new Promise
    that is being resolved with a `setTimeout()` function that waits two seconds before
    resolving with the value of `something` plus `x`. So after two seconds, the three
    functions are done at the same time (or so it seems to the human eye).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `talk()` function were not asynchronous, it would throw a `SyntaxError`
    because of the `await` keyword. `await` is only valid in asynchronous functions,
    so `talk()` must be asynchronous. Without the `async` and the `await` in this
    example, it would store the result of the function `saySomething()`, a pending
    `Promise`, in words and log that once for every function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen the basic building blocks of concurrency. This should prepare
    you for working with concurrency in real life. Concurrency really is an advanced
    topic; debugging it is troublesome, but it is really worth while in terms of performance
    when applied at the right moment.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 13.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will demonstrate how to use `await` to wait on a `Promise` inside
    an `async` function. Using `await` and `async`, create a counter with `timeout()`,
    and increment a global counter value.
  prefs: []
  type: TYPE_NORMAL
- en: Create a global value for a counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that takes one argument. Return the result of a new Promise,
    setting a `setTimeout()` function that will contain the resolve instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the counter within `setTimeout()`, adding one every second. Resolve
    the Promise with the value of the counter and the value of the variable that was
    in the function argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an asynchronous function that outputs into the console the value of the
    global counter and the value of the argument of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable to capture the returned resolve value from the `await` function.
    Output that result into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a loop to iterate 10 times, incrementing the value and invoking the `async`
    function, passing the value of the increment variable as the parameter in the
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The results should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would like to end this chapter by explaining how JavaScript handles asynchrony
    and concurrency under the hood. JavaScript is a single-threaded language. A thread
    in this context means a *path of execution*. If there is only a single path, this
    means that tasks will have to wait for one another and only one thing can happen
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This single executor is the **event loop**. It's a process that executes the
    actual work. You may wonder about this, because you've just learned about concurrency
    and doing things asynchronously and at the same time. Well, even though JavaScript
    is single-threaded, it doesn't mean that it cannot outsource some tasks and wait
    for them to come back. This is exactly how JavaScript manages to do things in
    a multithreaded manner.
  prefs: []
  type: TYPE_NORMAL
- en: Call stack and callback queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript works with a **call stack**, and all the actions that it has to execute
    are queued up here. The event loop is a process that is constantly monitoring
    this call stack, and whenever there are tasks to do, the event loop does them
    one by one. The tasks on top get executed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a tiny script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here's a visualization of the call stack and event loop for this script.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_13_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: Visualization of the event loop and the call stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'No multithreading is going on here. But it is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setTimeout()` task gets outsourced to the browser''s web API (more on
    APIs in *Chapter 15*, *Next Steps*). When it''s done, this appears in a special
    place: the **callback queue**. When the call stack is empty (and only then!),
    the event loop will check the callback queue for work to do. If there are any
    callbacks waiting, they''ll be executed, one by one. After every action, the event
    loop will check the call stack for work first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a visualization of the situation with the outsourcing of `setTimeout()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, square'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_13_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Visualization of the setTimeout being outsourced'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `setTimeout()` expires, the event loop will have done whatever was on
    the **call stack** already, and will check the callback queue and execute any
    tasks on there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, square'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_13_03.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Visualization of the task on the callback queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is what it will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's see if you read the above text well. What do you think will happen when
    we set the timer to `0`, like here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will output the exact same thing. `setTimeout()` will also be outsourced
    when the timer is at `0`. The callback is placed in the callback queue right away,
    but the event loop won't even check the callback queue until the callstack is
    empty. So it will still print `Sorry I'm late` after `9`, even though the timer
    is at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password checker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using an array of allowed passwords, this exercise will create an application
    to check if one of these password string values exists in an array that lists
    all the accepted passwords. Set a Promise to check if the password is valid, and
    upon the result either resolve with the status of true or reject with the status
    of false. Return the check results.
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of allowed passwords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a login function that will check if the argument is a value that is included
    in the passwords array. You can use `indexof()` or the `includes()` method to
    check the array for a value and return a Boolean value of the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `includes()` method is an array method that can check whether a certain
    value is included among the items in the array. It will return a Boolean value
    depending on the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a function that returns a Promise. Using `resolve` and `reject`, return
    a JavaScript object with the Boolean of `true` or `false` to indicate the password
    validity status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks the password, sending it to the login function,
    and using `then()` and `catch()`, outputs the result of either the rejected password
    or the resolved password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send several passwords, some within the array, others not, to the checker function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fix the error in the following code to use the `callback` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write down the result of the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What line(s) of code need to be added to the preceding function so that there
    is always a result after the function runs that ensures the word `done` is output
    into the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the below code to make the function return a Promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed concurrency. Concurrency enables our code to
    do multiple things at the same time and we can determine the order of things using
    callbacks, Promises, and the `async` and `await` keywords. Implementing these
    in your applications and pages will improve the user experience a lot! Users are
    quite demanding nowadays; if a website isn't loading fast enough, they bounce
    (go back to, for example, Google). Concurrency helps to deliver results faster.
  prefs: []
  type: TYPE_NORMAL
- en: The next two chapters are about using JavaScript for modern web development
    and will be dealing with HTML5 and JavaScript and modern JavaScript frameworks
    that are real game-changers.
  prefs: []
  type: TYPE_NORMAL
