<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Reacting to User and Application Interactions</h1></div></div></div><p>Developing effective applications with Ext JS requires a solid understanding of event-driven programming and how actions are performed, based on user and application interactions. Ext JS is an event-driven framework and uses events to control the flow of the application.</p><p>Events can be raised by user input, internally by the framework or by our own application code. For example, when a user clicks a button with their mouse, a click event will be fired by the button's instance. We can then attach a listener to this event and execute our handler code when it is fired. Have a look at the following diagram:</p><div><img src="img/6626_03_01.jpg" alt="Reacting to User and Application Interactions"/></div><p>This chapter <a id="id77" class="indexterm"/>will explore in detail the events in Ext JS. The topics covered in this chapter include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Listening for events</li><li class="listitem" style="list-style-type: disc">Raising custom events</li><li class="listitem" style="list-style-type: disc">Attaching event handlers to components</li><li class="listitem" style="list-style-type: disc">Listening <a id="id78" class="indexterm"/>for user input via mouse, keyboard, and touch screens</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Background</h1></div></div></div><p>Applications <a id="id79" class="indexterm"/>built with Ext JS will make use of events at numerous points throughout their lifecycle. Even if you're unaware of it, in the background, the framework will raise events when something interesting happens. As developers, we want our application code to respond to these events, either to process something or to give the user feedback on what has happened.</p><p>Ext JS implements an <code class="literal">Ext.mixin.Observable</code> class that provides a common interface for publishing events. Let's look at the options we have to listen to events.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Defining event handlers in config objects</h1></div></div></div><p>A <a id="id80" class="indexterm"/>common way to define listeners is to use the <code class="literal">listeners</code> config option, which allows us to define an object containing event handlers. This object should be defined in the <code class="literal">config</code> object of the Ext JS component.</p><p>Let's jump straight into the <code class="literal">BizDash.view.main.Main</code> class that was created automatically when we generated our application in <a class="link" href="ch01.html" title="Chapter 1. Getting to Know Ext JS">Chapter 1</a>, <em>Getting to Know Ext JS</em>.</p><p>We will bind an event listener to the <code class="literal">afterrender</code> event of the Tab Panel component. The function is executed when the event is fired. In this case, the output of the handler is a simple console message:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  ...
  items: [{
    region: 'center',
    xtype: 'tabpanel',
    listeners: {
      afterrender: function(component, eOpts) {
        console.log('Center tabpanel has rendered.')
      }
    }
  }]
});</pre></div><p>It is also possible to attach handlers to multiple events at once. This example has both, a <code class="literal">beforerender</code> and <code class="literal">afterrender</code> handler for events fired by the Tab Panel component:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  ...
  items: [{
    region: 'center',
    xtype: 'tabpanel',
    listeners: {
      afterrender: function(component, eOpts) {
        console.log('Center tabpanel has rendered.')
      },
      beforerender: function(component, eOpts) {
        console.log('Center tabpanel before rendering.')
      }
    }
  }]
});</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Button handlers</h2></div></div></div><p>The<a id="id81" class="indexterm"/> framework provides a shortcut to define a handler to a button as it's highly likely you'll want your buttons to respond to a mouse click. The <code class="literal">handler</code> in this case is bound to the <code class="literal">onClickButton</code> method in the view's ViewController, <code class="literal">BizDash.view.main.MainController</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.Main', {
  extend: 'Ext.container.Container',
  ...
  items: [{
    ...
    tbar: [{
      text: 'Button',
      handler: 'onClickButton'
    }]
  }]
});</pre></div><p>It's considered good practice to keep your business logic out of views instead of putting it in global controllers or ViewControllers.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>The on method</h2></div></div></div><p>Alternatively, we <a id="id82" class="indexterm"/>can use the <code class="literal">on</code> method, which is an alias of the <code class="literal">addListener</code> method. This method comes from the mixed in <code class="literal">Ext.mixin.Observable</code> class and enables us to add listeners to a class, or component after the class is instantiated:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  ...
  init: function () {
    var button = this.getView().query('button[text="Button"]')[0];
    button.on('mouseover', 'onMouseOver');
    button.on({ mouseover: 'onMouseOver' });
  },
  onMouseOver: function () {
    console.log('Button Mouseover Event Fired');
  }
});</pre></div><p>The preceding example shows how to use an Ext JS Component Query to search for the button in our application and add a <code class="literal">mouseover</code> listener bound to the method <code class="literal">onMouseOver</code> in our ViewController. We will go into Component Queries in more detail in <a class="link" href="ch07.html" title="Chapter 7. Constructing Common UI Widgets">Chapter 7</a>, <em>Constructing Common UI Widgets</em>.</p><p>As with the listeners <code class="literal">config</code> object, the <code class="literal">on</code> method also accepts an alternative parameter set that allows multiple event handlers to be assigned at once. By providing a JavaScript object as the first parameter, with name/value pairs specifying the event name and its handling function, the listeners will all be assigned at once. By defining a <code class="literal">scope</code> property within this object, the handler functions will all be executed within the scope of the specified object (or what <code class="literal">this</code> will refer to within the function):</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  ...
  init: function () {
    var button = this.getView().query('button[text="Button"]')[0];
    button.on({
      mouseover: 'onMouseOver',
      mouseout: 'onMouseOut',
      scope: this
    });
  },
  onMouseOver: function () {
    console.log('Button Mouseover Event Fired');
  },
  onMouseOut: function () {
    console.log('Button Mouseout Event Fired');
  }
});</pre></div><p>
<strong>Scope</strong> defaults to<a id="id83" class="indexterm"/> the object that fires the event. In our case, that would be the button. You can customize this with the <code class="literal">scope</code> option if you require the handler function to be executed in a different scope. The preceding example demonstrates this using the <code class="literal">this</code> reference to alter the scope to that of the <code class="literal">BizDash.view.main.MainController</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Listener options</h1></div></div></div><p>There <a id="id84" class="indexterm"/>are numerous listener options for you to configure as well. For example, you can buffer an event that fires in quick succession or target an event to a specific element rather than the entire component. Event delegation like this is useful during component construction to add DOM event listeners to elements of components, which will exist only after the component is rendered.</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  ...
  onClickButton: function () {
    Ext.Msg.confirm('Confirm', 'Are you sure?', 'onConfirm', this); 
    this.getView().getButton().disable();
  },
  ...
  init: function () {
    var button = this.getView().query('button[text="Button"]')[0];
    button.on({
      mouseover: 'onMouseOver',
      mouseout: 'onMouseOut',
      click: {fn: 'onClickButton', single: true},
      scope: this
    });
  },
  ...
});</pre></div><p>This example shows the <code class="literal">single</code> option added to the click event. This option automatically removes the click event after the first time it's fired. We've further enhanced the <code class="literal">onClickButton</code> method to disable the button too.</p><p>The documentation for <code class="literal">Ext.mixin.Observable</code> contains useful examples and further information on configuring events. You can find it at <a class="ulink" href="http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable">http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Firing events</h1></div></div></div><p>The <code class="literal">Ext.mixin.Observable</code> class also provides a way to fire events, whether these are framework <a id="id85" class="indexterm"/>events or custom events. The <code class="literal">fireEvent</code> method will fire any event we require and pass parameters for consumption by the handler function. The following example shows us how to fire a custom <code class="literal">confirmed</code> event, passing the <code class="literal">choice</code> parameter on the button, and binding it to an <code class="literal">onConfirmed</code> handler:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  onConfirm: function (choice) {
    if (choice === 'yes') {
      var button = this.getView().getButton();
      button.fireEvent('confirmed', choice)
    }
  },
  onConfirmed: function(choice){
    console.log('The CONFIRMED event was fired');
  },
  init: function () {
    button.on({
      mouseover: 'onMouseOver',
      mouseout: 'onMouseOut',
      click: {
        fn: 'onClickButton',
        single: true
      },
      confirmed: 'onConfirmed',
      scope: this
    });
  }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Listening for events on elements</h1></div></div></div><p>As some <a id="id86" class="indexterm"/>events, for example click, aren't available on all components, it's possible to attach event handlers directly to any element. The <code class="literal">Ext.dom.Element</code> class, a framework class that wraps DOM elements, will relay all of the underlying DOM events, and its documentation contains a full list of these.</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  init: function () {
    var el = this.getView().getEl();
    el.on('tap', function() {
      console.log('The Viewport was tapped/clicked.');
    });
  }
});</pre></div><p>The preceding example shows how to listen for a tap event on the entire <code class="literal">Viewport</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Event delegation</h2></div></div></div><p>Event<a id="id87" class="indexterm"/> handlers, however, are a common cause of memory leaks and can cause performance degradation when not managed carefully. The more event handlers we create, the more likely we are to introduce such problems; so, we should try to avoid creating huge numbers of handlers when we don't have to.</p><p>Event delegation is a technique where a single event handler is created on a parent element, which leverages the fact that the browser will bubble any events raised on one of its children to this parent element. If the target of the original event matches the delegate's selector, then it will execute the event handler; otherwise nothing will happen.</p><p>This means<a id="id88" class="indexterm"/> that instead of attaching an event handler to each individual child element, we only have to create a single handler on the parent element, and then, within the handler, query which child element was actually clicked and react appropriately. To achieve this, we use the delegate option available to the <code class="literal">listeners</code> config.</p><p>The following example shows how you might use event delegation with an element containing multiple links:</p><div><pre class="programlisting">/* assume navigationEl is an Ext.Element instance containing multiple &lt;a&gt; tags */
navigationEl.on('click', function(e){
  /* Handle a click on any element inside the 'navigationElement'. Use e.getTarget to determine which link was clicked.*/

}, {
  delegate: 'a'
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Mouse events</h1></div></div></div><p>The <a id="id89" class="indexterm"/>mouse events the framework can handle are <code class="literal">mousedown</code>, <code class="literal">mousemove</code>, <code class="literal">mouseup</code>, <code class="literal">mouseover</code>, <code class="literal">mouseout</code>, <code class="literal">mouseenter</code>, and <code class="literal">mouseleave</code>. The <code class="literal">Ext.event.Event</code> class handles the cross-browser and cross-device differences for us to ensure our application behaves the same on all supported browsers.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Keyboard events</h1></div></div></div><p>The<a id="id90" class="indexterm"/> <code class="literal">Ext.event.Event</code> class also provides a list of key constants:</p><div><pre class="programlisting">var constants = {
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  RETURN: 13,
  SHIFT: 16,
  ...
}</pre></div><p>We can, for instance, get a reference to the enter key's code using <code class="literal">Ext.event.Event.ENTER</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>KeyMap</h2></div></div></div><p>The <code class="literal">Ext.util.KeyMap</code> class is used to bind keyboard strokes to a handling function. Using this, you<a id="id91" class="indexterm"/> can enable the user to control the application using their keyboard:</p><div><pre class="programlisting">Ext.define('BizDash.view.main.MainController', {
  extend: 'Ext.app.ViewController',
  init: function () {
    var map = new Ext.util.KeyMap({
      target: this.getView().getEl(),
      key: Ext.event.Event.ENTER,
      fn: this.onEnterPress,
      scope: this
    });
  },
  onEnterPress: function() {
    console.log('ENTER key was pressed');
  }
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Touch events</h1></div></div></div><p>Not only<a id="id92" class="indexterm"/> do we often have to support multiple browsers, but most of the time we need our applications to be device agnostic. Ext JS enables us to support users with other types of pointers, such as a mouse, pen, or finger.</p><p>Ext JS 5 provides support for <code class="literal">touchstart</code>, <code class="literal">touchmove</code>, and <code class="literal">touchend</code> events.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Event normalization</h2></div></div></div><p>To <a id="id93" class="indexterm"/>support touch-screen devices, the framework automatically translates touch-screen events into their equivalent mouse events for us. This is called event normalization.</p><p>As developers, we don't need to worry about the extra coding. All we have to do is consider the event being used by a mouse. For instance, <code class="literal">mousedown</code> will seamlessly be translated to <code class="literal">touchdown</code> and <code class="literal">pointerdown</code> for us.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Gestures</h2></div></div></div><p>While<a id="id94" class="indexterm"/> normalization saves us coding, we still need to understand the gesture the user carries out on our application. Ext JS does almost all the heavy lifting for us. It will interpret gestures such as tap, swipe, drag, and double tap on any element and raise events for us to listen for.</p><p>In order to do this, the framework builds upon the Sencha Touch gesture system, which interprets the sequence and timing of three primary events: <code class="literal">touchstart</code>, <code class="literal">touchmove</code>, and <code class="literal">touchend</code>. Ext JS 5 translates these to the equivalent pointer and mouse events (for example, <code class="literal">pointerdown</code> or <code class="literal">mousedown</code>) so that gestures are understood regardless of the device being used for input.</p><p>For example, gestures such as tap and swipe will work for both touch and mouse input.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we learned how to work with events in an Ext JS application. You should now feel more comfortable with:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Listening for events</li><li class="listitem" style="list-style-type: disc">Raising custom events</li><li class="listitem" style="list-style-type: disc">Attaching event handlers to components</li><li class="listitem" style="list-style-type: disc">Listening for user input via mouse, keyboard, and touch screens</li></ul></div><p>The next chapter builds on your knowledge of classes and events to cover the entire application and its architecture. Ext JS 5 now provides support for MVVM as well as MVC. While the chapter's focus is these paradigms, we also explore other considerations it's worth making early in the development cycle.</p></div></body></html>