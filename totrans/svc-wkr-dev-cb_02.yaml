- en: Chapter 2. Working with Resource Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a custom offline page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading images offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading CSS offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading fonts offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing multiple fetch handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching remote resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have encountered, from time to time, having broken images appear
    on certain websites. This could be because of a number of reasons: the image might
    not have existed, it might not have been named properly, or the file path in the
    code might have been incorrect. Whatever the reason it might be, it could impact
    your website, and could lead the user to think that your website is broken.'
  prefs: []
  type: TYPE_NORMAL
- en: Images are not the only resources that are essential to your website. **Cascading
    style sheets** (**CSS**), JavaScript files, and font files are also necessary
    to make your website appear functional. In this chapter, we are going to look
    at how to load these resources offline.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start working on loading resources offline, let's find out how we
    can notify the user that the network is unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a custom offline page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the scenario from the first chapter where you are on a train,
    traveling home from work, and you are reading an important news article on the
    web using your mobile device. At the same moment that you click on a link to view
    more details, the train suddenly disappears into a tunnel. You''ve just lost connectivity,
    and are presented with the **Unable to connect to the Internet** message. Well,
    you will not doubt be less annoyed if you can still play the dinosaur game by
    hitting the spacebar on your desktop/laptop, or by tapping on your phone, but
    this can be an area where you can significantly enhance a client''s user experience
    by using a service worker. One of the great features of service workers is that
    they allow you to intercept network requests and decide how you want to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a custom offline page](img/B05381_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we are going to use a service worker to check whether a user
    has connectivity, and respond with a really simple offline page if they aren't
    connected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `service-worker.js` in the same folder as the
    `index.html` file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second HTML file called `offline.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up a browser and go to `index.html`. You will see the **Registration status:
    successful** message:![How to do it...](img/B05381_02_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open up DevTools (*Cmd* + *Alt* + *I* or *F12*), go to the **Network** tab,
    click on the dropdown displaying **No throttling**, and select **Offline**:![How
    to do it...](img/B05381_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now refresh your browser, and you will see the offline message and the following
    image:![How to do it...](img/B05381_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the registration is successful, we are instructing the service worker
    to intercept a request and provide resources from the cached content using the
    fetch event, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05381_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `index.html` file, when the registration is successful, we inspect
    the state of the registration and print it to the browser. Otherwise, we are printing
    the error message returned by the service worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The service worker script file will intercept network requests, check for connectivity,
    and provide the content to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by adding our offline page to the cache when we install the service
    worker. In the first few lines, we are specifying the cache version and the URL
    for the offline page. If we had different versions of our cache, you would simply
    update this version number, so a new version of the file will take effect. We
    call this **cache busting**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an event listener to the install event and inside the callback, we make
    a request for this offline page and its resources; when we have a successful response,
    it gets added to the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the offline page is stored in the cache, we can retrieve it whenever
    we need to. In the same service worker, we need to add the logic to return the
    offline page if we have no connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding listing, we are listening out for the fetch event, and if we
    detect that the user is trying to navigate to another page, and there is an error
    while doing so, we simply return the offline page from the cache. And there you
    go, we have our offline page working.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `waitUntil` event extends the lifetime of the install event, until all the
    caches are populated. In other words, it delays treating the installing worker
    as installed, until all the resources we specify are cached and the passed promise
    resolves successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw an HTML and an image file get cached, and then being retrieved when
    our website is offline. We can cache other resources as well, including CSS and
    JavaScript files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Registering a service worker in detail* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating mock responses* recipe of [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading images offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are a resource that almost all websites in the world today use. Just
    like your HTML, CSS, and JavaScript, you can cache images to be viewed offline
    with service workers. In this chapter, we are going to look at how to load images
    offline, as well as handling responsive images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to create a JavaScript file `service-worker.js`, in the same folder
    as the `index.html` file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download an image file and save it in the same folder as the `index.html` file.
    In this example, I am calling it `packt-logo.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up Chrome Developer Tools (*Cmd* + *Alt* + *I* or *F12*), select the **Network**
    tab, and click **Offline**:![How to do it...](img/B05381_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the page by pressing *Cmd* + *R* or *F5*, and you will see the image
    looks the same as it did online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `index.html` file, we are linking the image we have downloaded inside
    an `img` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the service worker script file, we add our offline page to the cache when
    we install the service worker. In the first few lines, we specify the cache version
    and the URL for the offline page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache `index.html` and the font file, in our case, `webfont-serif.woff`. The
    `cache.addAll` function takes an array of files to be cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, the page will be displayed as it was online.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we were to develop our website following a mobile-first strategy, having
    responsive images would greatly benefit it. Let's look at how we can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Handling responsive images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of ways to enable the responsive behavior for images. One
    of the older methods (not recommended) is by simply scripting, but this leads
    to a couple of problems. First, if a script determines which image to download,
    but the script itself is loaded after the images specified in the HTML have been
    downloaded, you may potentially end up with two downloaded images. Second, if
    you don't specify any image in HTML, and want to load only the image defined by
    the script, you'll end up with no image at all for browsers that have scripting
    disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we need a better way to deal with responsive images. And thankfully,
    there is one! The recommended way is to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`srcset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`picture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The srcset attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we explore how `srcset` is actually used, let's understand a few terms.
  prefs: []
  type: TYPE_NORMAL
- en: Device-pixel ratio
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The device-pixel ratio is the number of device pixels per CSS pixel. Two key
    conditions contribute to the device-pixel ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel density of the device (number of physical pixels per inch)**: A high
    resolution device will have a higher pixel density and hence, for the same zoom
    level, it will have a high device-pixel ratio compared to a lower resolution device.
    For example: a high-end Lumia 950 phone will have a higher resolution than a budget
    Lumia 630 phone, and therefore it will have a higher device-pixel ratio for the
    same zoom level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zoom level of the browser**: For the same device, a higher zoom level means
    a higher number of device pixels per CSS pixel, and hence a higher device-pixel
    ratio. For example, consider this figure:![Device-pixel ratio](img/B05381_02_08.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you zoom in on your browser (*Ctrl* + *+*), the number of CSS pixels for
    your `div` remains the same, but the number of device pixels it occupies increases.
    So, you have a higher number of device pixels per CSS pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to display separate images (or usually, a separate asset of the
    same image) based on the device-pixel ratio, you''d go with a basic `srcset` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `x` descriptor in the `srcset` attribute is used to define the device-pixel
    ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: For a device-pixel ratio of 1, the `image-src.png` image will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a device-pixel ratio of 2, the `image-2x.png` image will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src` attribute is used as a fallback for browsers that do not yet support
    `srcset` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This works well. Using the `x` descriptor, you'll always get the same image
    on devices with a similar device-pixel ratio—even if this means that you get the
    same image on a 13.5-inch laptop, and a 5-inch mobile phone, which both have the
    same device-pixel ratio.
  prefs: []
  type: TYPE_NORMAL
- en: The sizes attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual implementation where you'd want a different-sized image (different
    height and width) on different screen sizes is accomplished by using the `sizes`
    attribute along with the `w` descriptor of the `srcset` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want the image to be viewed in half of the viewport width. You''ll
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The picture element
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we saw in the previous section, the `picture` element is used when you want
    to show a different image depending on the rendered size of the image. The `picture`
    element is a container, which contains other elements that control the image to
    be downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, the `srcset` attribute or the `<picture>` element selects the most
    appropriate image asset and performs a network request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to cache an image during the install step for the service worker,
    you have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a single low-resolution version of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a single high-resolution version of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is ideal to limit the amount to two or three images in order to preserve
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the load time, you may decide to go for the low resolution version
    at the time of installation, and you would try to retrieve higher resolution images
    from the network when the page is loaded; however, in the case that the high-resolution
    images fail, you would think you can easily fall back to the low resolution version,
    but there is one issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Display density | Width | Height |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1x` | `400` | `400` |'
  prefs: []
  type: TYPE_TB
- en: '| `2x` | `800` | `800` |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the markup for an `srcset` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On a screen with a `2x` display, the browser could opt to download `image-2x.png`,
    if we are offline, then we could catch this request and return the `image-src.png`
    image instead if the image is cached, the browser may expect an image that considers
    the extra pixels on a `2x` screen, therefore the image will appear as 200 x 200
    pixels instead of 400 x 400 pixels. The only fix is to set a fixed width and height
    on the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can take the same approach to `srcset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No width or height set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The picture element](img/B05381_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Height and width set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The picture element](img/B05381_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to unregister the service worker, you can head to the Developer
    Toolbar in Chrome, and click the **Unregister** button in the **Service Workers**
    section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The picture element](img/B05381_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to find out the resources stored in the caches, you can do so by
    opening Developer Tools and looking at the **Resources** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The picture element](img/B05381_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are using Firefox Nightly, you can view the caches by opening up Developer
    Tools and looking at the Storage Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The picture element](img/B05381_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading CSS offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS is essential in structuring your website and making it look functional.
    Because of this, if your website goes offline and the CSS is not available in
    the cache, your website will look broken. In order to achieve this, we cache CSS
    with service workers, and deliver those CSS files as external resources. In this
    recipe, we are going to look at how to load CSS offline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a CSS file called `style-1.css`, in the same folder as the `index.html`
    file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another CSS file called `style-2.css`, in the same folder as the `index.html`
    file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a browser and go to the `index.html` file. You will see that the background
    color is green:![How to do it...](img/B05381_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open up the Developer Tools (*Cmd* + *Shift* + *I* or *F12*) and change
    the **Network** tab to **Offline** as shown in the following screenshot:![How
    to do it...](img/B05381_02_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The color of the background is now red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the header section of the `index.html` file, we are linking two CSS files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In our styles sheets, we are referencing the same CSS property of body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the order we are calling the CSS files, the last selector takes
    effect on the online page, in our case, this is the `body` selector of `style-1.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `service-worker.js` file, we add `index.html` and the `style-2.css`
    file to the cache when we install the service worker. In the first few lines,
    we specify the cache version and the URL for the offline page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache `index.html`, and the CSS file. The `cache.addAll` function takes an
    array of files to be cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we refresh the page, the background will change to red, as the CSS
    file we saved in the cache will be applied to the page this time.
  prefs: []
  type: TYPE_NORMAL
- en: Loading fonts offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your website uses external fonts, such as open source web fonts, you could
    cache them to be viewed offline with service workers. In this chapter, we are
    going to look at how to load fonts offline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download a web font from [https://www.google.com/fonts](https://www.google.com/fonts)
    and save it in the same folder as the `index.html` file. If you are not quite
    sure how to do this, please look at the following *There's more...* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the browser and go to the `index.html` file:![How to do it...](img/B05381_02_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up Chrome Developer Tools (*Cmd* + *Alt* + *I* or Fb12), select the **Network**
    tab, and click **Offline**:![How to do it...](img/B05381_02_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the page by pressing *Cmd* + *R* or *F5*, and you will see the font
    looks the same as it did online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the header section of the `index.html` file, we link the font file we have
    downloaded inside a `style` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@font-face` declaration will specify a font named `myWebFont` and specify
    the URL where it can be found. In our case, it is in the same directory as the
    `index.html` file. Then we reference the font inside the paragraph declaration
    as the `font-family` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the service worker script file, we add our offline page to the cache when
    we install the service worker. In the first few lines, we specify the cache version
    and the URL for the offline page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache the `index.html` file and the font file; in our case `webfont-serif.woff`.
    The `cache.addAll` function takes an array of files to be cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, the page will be displayed as it was online.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to find a free font family from Google and download it, please perform
    the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Please navigate to [https://www.google.com/fonts](https://www.google.com/fonts),
    and search, or browse, the desired font, then add the one you like to your collection
    by clicking on the blue **Add to Collection** button on the right side of the
    font:![There's more...](img/B05381_02_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your collection will show at the bottom of your screen. Once it has, select
    the **Use this style** checkbox, towards the top-left side of the screen:![There's
    more...](img/B05381_02_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you click the arrow on the top right-hand side of the page, it will
    prompt you with a dialog. You can choose the first option, which downloads the
    file as a ZIP file:![There's more...](img/B05381_02_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you unzip the file, you will find the font you need inside the folder.
    If you want to unregister a service worker, you can go to `chrome://service-worker-internals`
    and click the **Unregister** button:![There's more...](img/B05381_02_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Firefox Nightly, you can go to `about:serviceworkers` and click on the **Unregister**
    button:![There's more...](img/B05381_02_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing multiple fetch handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers can handle multiple fetch handlers, each of which intercepts
    a different type of request. This recipe explains, in detail, how different types
    of request can be handled by implementing separate fetch handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `service-worker.js` in the same folder as the
    `index.html` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up a browser and go to the `index.html` file. You will see the **Registration
    status: successful** message:![How to do it...](img/B05381_02_23.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the URL by adding `/cook/` in front as follows:![How to do it...](img/B05381_02_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the URL again by adding `/book` in front as follows:![How to do it...](img/B05381_02_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the registration is successful, we inspect the state of the registration,
    and print it to the browser. Now it''s time to trigger the responses by the service
    worker. In the `service-worker.js` file, there are two registered fetch handlers,
    `cookFetchHandler` and `cookBookFetchHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first handler, `cookFetchHandler`, intercepts requests ending with `/cook`
    anywhere in the URL, and returns a new response with the wording, `Fetch handler
    for /cook`.
  prefs: []
  type: TYPE_NORMAL
- en: The second handler, `cookBookFetchHandler`, intercepts requests ending with
    `/cook/book` anywhere in the URL, and returns a new response with the wording,
    `Fetch handler for /cook/book`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `cookBookFetchHandler` is registered first, when it intercepts `/cook/book`
    requests, it will always first have the chance to return a response via `event.respondWith()`.The
    second handler gets its chance to handle `event.respondWith()` only if the first
    handler does not call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the fetch event occurs, they are invoked one at a time, in the order they
    are registered. Any time a handler calls `event.respondWith()`, none of the other
    registered handlers will be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If none of the registered fetch handlers call `event.respondWith()`, the browser
    takes control and makes a normal HTTP request. This is the normal procedure, when
    no service workers are involved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within each fetch handler, we have to make sure that the logic that determines
    whether or not to call `event.respondWith()`, is executed synchronously. Simple
    `if()` statements that check `event.request.url` are fine. Anything asynchronous,
    such as performing `caches.match()` and then deciding whether or not to call `event.respondWith()`
    based on the response, will trigger a race condition, and you're likely to see
    an `event already responded to` error in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to unregister the service worker, you can head to the Developer
    Toolbar in Chrome and click the **Unregister** button in the **Service Workers**
    section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/B05381_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching remote resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching remote resources can be done in a few different ways. In this recipe,
    we are going to look at two standard ways of fetching remote resources, as well
    as finding out how to use a service worker to act like a proxy middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the *Setting up GitHub pages for
    SSL* recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service Worker Basics"),
    *Learning Service Worker Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up your file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an `index.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_02_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of the `index.js` file, we are testing three different protocols
    for loading resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https`: HTTP with **Secure Socket Layer** (**SSL**) protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https-acao`: SSL protocol with the **Access-Control-Origin=*** header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`: HTTP without SSL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use three different URLs, which will be loaded multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also use two different methods for fetching resources, with or without `cors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check to see whether the service worker is registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If that is not the case, then we register it and reload the page to make sure
    the client is under the service worker''s control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loops go through the provided `protocols` array, make requests for
    each protocol, build a DOM image element with each URL, and go through each mode
    of the `fetchModes` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` object contains any custom settings that you want to apply to the
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: The request method, for example, `GET` and `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: The mode you want to use for the request, for example, `cors`, `no-cors`,
    or `same-origin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: The cache mode you want to use for the request: `default`, `no-store`,
    `reload`, `no-cache`, `force-cache`, or `only-if-cached`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `buildImage` function takes two arguments: `protocol` and `url`. It creates
    an image element on the fly and attaches the URL as the source of that image.
    Then it goes on to add that image to the DOM tree, where the ID is one of `https-acao-image`,
    `https-image`, or `http–image`. JavaScript has no control over the URL handling
    at this point; the browser handles the URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Images will be rendered for HTTPS requests only, as service workers only support
    connections over SSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05381_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The broken image is the one requested over standard HTTP, which fails to respond
    with the requested image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other requests over HTTP also fail to deliver, resulting in errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05381_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The requests over SSL, with the **Access-Control-Origin=*** header (**Access
    Control Allow Origin**), will return results successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05381_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, fetching a resource from a third-party URL will fail if it doesn''t
    support CORS. You can add a non-CORS option to the request to overcome this, although
    this will cause an *opaque* response, which means you won''t be able to tell whether
    the response was successful or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B05381_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `fireRequest` function takes three arguments, `fetchMode`, `protocol`,
    and `init`. This function, in turn returns another function, which we can call
    a composition. We start with fetching the given resource directly from the remote
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the fetch was successful, we print it to the console, as well as log it on
    the webpage. We do the same if the request fails, only we print `error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also attempt to fetch the resource with the service worker''s proxy, which
    the client recognizes as a local resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printSuccess` and `printError` functions log responses to the console,
    as well as the DOM of the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function log finds the DOM element by the ID, and adds a paragraph
    element, as well as a class attribute, to depict the type of the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `index.html` file, we have style declarations in the `head` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In our `log()` function, we set the undefined type to success, so that it will
    display the color green when we add it to `classList`. The error type will display
    red as declared in the previous styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move over to our `service-worker.js` file. There we have the `onfetch`
    event handler, which gets fired whenever a fetch event occurs. Here, we check
    to see whether the request has a `proxy/` parameter in it. If it does, then it
    responds with the remaining part of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, the response will perform the request with the full URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's examine the defaults of the `fetch()` function in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: No credentials by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use fetch, by default, requests won''t contain credentials such as
    cookies. If you want credentials, you can call this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is intentional, and is arguably better than XHR's more complex
    default behavior of sending credentials if the URL has the same origin, but omitting
    them otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch's behavior is more like other CORS requests, such as `<img crossorigin>`,
    which never sends cookies unless you opt in with `<img crossorigin="use-credentials">`.
  prefs: []
  type: TYPE_NORMAL
- en: Non-CORS fail by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, fetching a resource from a third-party URL will fail if it doesn''t
    support CORS. You can add a non-CORS option to the **Request** function to overcome
    this, although this will cause an *opaque* response, which means you won''t be
    able to tell whether the response was successful or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to unregister the service worker, you can head over to the `chrome://service-worker-internals`
    page in Chrome and click the **Unregister** button of the relevant service worker,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Non-CORS fail by default](img/B05381_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
