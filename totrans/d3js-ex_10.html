<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Using Layouts to Visualize Series and Hierarchical Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Using Layouts to Visualize Series and Hierarchical Data</h1></div></div></div><p>We are now going to get into what some refer to as the most powerful features of D3.js —layouts. Layouts encapsulate algorithms that examine your data and calculate the positions for visual elements for specific type of graphs such as bars, areas, bubbles, chords, trees, and many others.</p><p>We will dive into several useful layouts. These will be categorized into several main categories based upon the structure of the data and type of visualization such as stacked, hierarchical, chords, and flow-based diagrams. For each of the categories, we will go over creating a number of examples, complete with data and code.</p><p>Specifically, we will examine creating the following types of graphs and layouts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stacked layouts to create bar and area graphs</li><li class="listitem" style="list-style-type: disc">Hierarchical diagrams including trees, cluster dendrograms, and enclosures</li><li class="listitem" style="list-style-type: disc">Relationships between items using chord diagrams</li><li class="listitem" style="list-style-type: disc">Flowing data using streamgraphs and Sankey diagrams</li></ul></div><div class="section" title="Using stacked layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec46"/>Using stacked layouts</h1></div></div></div><p>Stacks are a class of <a id="id458" class="indexterm"/>layouts that take multiple series of data, where each measurement from each series is rendered atop each other. These are suited for demonstrating the comparative size of the measurements from each series at each measurement. They are also great at demonstrating how the multiple streams of data change over the entire set of measurements.</p><p>Stacked diagrams basically come down to two different representations: stacked bar graphs and stacked area graphs. We will examine both of these and explain how to create these with D3.js.</p><div class="section" title="Creating a stacked bar graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec61"/>Creating a stacked bar graph</h2></div></div></div><p>The implementation of a <a id="id459" class="indexterm"/>stacked bar graph is similar to that of a bar graph, except that we need to take into account the fact that the height of each bar consists of the sum of each measurement. Normally, each bar is subdivided, with each division sized relative to the sum, and is given a different color to differentiate it.</p><p>Let's jump into creating our own stacked bar graph. The data that will be used can be found at <a class="ulink" href="https://goo.gl/6fJrxE">https://goo.gl/6fJrxE</a>.</p><p>The following are the first few lines of the file. This data represents seven series of data, each series a specific range of age, broken down categorically by state. Each value represents the population for the given state in that age group.</p><div class="informalexample"><pre class="programlisting">State,Under 5 Years,5 to 13 Years,14 to 17 Years,18 to 24 Years,25 to 44 Years,45 to 64 Years,65 Years and Over
AL,310504,552339,259034,450818,1231572,1215966,641667
AK,52083,85640,42153,74257,198724,183159,50277
AZ,515910,828669,362642,601943,1804762,1523681,862573</pre></div><p>The online example is available at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note121"/>Note</h3><p>bl.ock (10.1): <a class="ulink" href="http://goo.gl/G3BIL7">http://goo.gl/G3BIL7</a>
</p></div></div><p>The resulting bar graph is the following:</p><div class="mediaobject"><img src="graphics/B04230_10_01.jpg" alt="Creating a stacked bar graph"/></div><p>The data is loaded using <code class="literal">d3.csv()</code>:</p><div class="informalexample"><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/25129228aa50c30ef01f/raw/17838a0a03d94328a529de1dd768e956ce217af1/stacked_bars.csv';
d3.csv(url, function (error, data) {</pre></div><p>Examining the first object in <a id="id460" class="indexterm"/>the resulting data, we see the following structure:</p><div class="mediaobject"><img src="graphics/B04230_10_02.jpg" alt="Creating a stacked bar graph"/></div><p>This array has 51 elements, one for each state of the US and Washington D.C. This data needs to be converted into a structure that gives us information for rendering each bar and the rectangle for each series within each of the bars. To do this, we need to go through three steps, the last one culminating with the use of <code class="literal">d3.layout.stack()</code>.</p><p>First, the code extracts the unique keys for each series of data, which is the age groups. This can be retrieved by filtering out all properties of each object in the array where the property name is not equal to <code class="literal">State</code>.</p><div class="informalexample"><pre class="programlisting">var keys = d3.keys(data[0])
    .filter(function (key) {
        return key !== "State";
    });</pre></div><div class="mediaobject"><img src="graphics/B04230_10_03.jpg" alt="Creating a stacked bar graph"/></div><p>Using these keys, we can reorganize the data so that we have an array representing the values for each age group:</p><div class="informalexample"><pre class="programlisting">var statesAndAges = keys.map(function (ageRange) {
    return data.map(function (d) {
        return {
            x: d.State,
            y: +d[ageRange]
        };
    });
});</pre></div><p>The <code class="literal">statesAndAges</code> variables now is a seven-element array, with each element being an array of objects representing the <code class="literal">x</code> and <code class="literal">y</code> values for each series:</p><div class="mediaobject"><img src="graphics/B04230_10_04.jpg" alt="Creating a stacked bar graph"/></div><p>Now, using these <a id="id461" class="indexterm"/>keys, we create a <code class="literal">d3.layout.stack()</code> function and have it process this data.</p><div class="informalexample"><pre class="programlisting">var stackedData = d3.layout.stack()(statesAndAges);</pre></div><p>The result of the stacking of this data is that the stack function will add an additional property, <code class="literal">y0</code>, to each object in each series. The value of <code class="literal">y0</code> will be the value of the sum of the <code class="literal">y</code> values in the previously lower-numbered series. To demonstrate, the following are the values of the objects in the first object of each array:</p><div class="mediaobject"><img src="graphics/B04230_10_05.jpg" alt="Creating a stacked bar graph"/></div><p>The value of <code class="literal">y0</code> in the first object is <code class="literal">0</code>. The value of <code class="literal">y0</code> in the second is <code class="literal">310504</code>, which is equal to <code class="literal">y0</code> + <code class="literal">y</code> of the first object. The value of <code class="literal">y0</code> in the third object is <code class="literal">y0</code> + <code class="literal">y</code> of the second, or <code class="literal">862843</code>. This function has stacked the <code class="literal">y</code> values, with each <code class="literal">y</code> value being the value of <code class="literal">y</code> for the individual segment of the bar that will be rendered.</p><p>The data is now <a id="id462" class="indexterm"/>organized to render the bar graph. The next step is to create the main SVG element:</p><div class="informalexample"><pre class="programlisting">var width = 960, height = 500;
var svg = d3.select('body')
    .append("svg")
    .attr({
        width: width,
        height: height
    });</pre></div><p>The code next calculates the <code class="literal">x</code> and <code class="literal">y</code> scales to map the bars into the specified number of pixels. The <code class="literal">y</code> scale will have a domain that ranges from <code class="literal">0</code> to the maximum sum of <code class="literal">y0</code> and <code class="literal">y</code> within all the series:</p><div class="informalexample"><pre class="programlisting">var yScale = d3.scale.linear()
        .domain([0,
            d3.max(stackedData, function (d) {
                return d3.max(d, function (d) {
                    return d.y0 + d.y;
                });
            })
        ])
        .range([0, height]);</pre></div><p>The <span class="emphasis"><em>x</em></span> scale is set up as an ordinal <code class="literal">rangeRoundBands</code>, one for each state:</p><div class="informalexample"><pre class="programlisting">var xScale = d3.scale.ordinal()
    .domain(d3.range(stackedData[0].length))
    .rangeRoundBands([0, width], 0.05);</pre></div><p>The code then creates a group for each of the series, assigning to each the color that the rectangles within will be filled with:</p><div class="informalexample"><pre class="programlisting">var colors = d3.scale.ordinal()
    .range(["#98abc5", "#8a89a6", "#7b6888",
            "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

var groups = svg.selectAll("g")
    .data(stackedData)
    .enter()
    .append("g")
    .style("fill", function (d, i) {
        return colors(i);
    });</pre></div><p>The last step is to render all the rectangles. The following performs this by creating <code class="literal">51</code> rectangles within each group:</p><div class="informalexample"><pre class="programlisting">groups.selectAll("rect")
    .data(function (d) { return d; })
    .enter()
    .append("rect")
    .attr("x", function (d, i) {
        return xScale(i);
    })
    .attr("y", function (d, i) {
        return height - yScale(d.y) - yScale(d.y0);
    })
    .attr("height", function (d) {
        return yScale(d.y);
    })
    .attr("width", xScale.rangeBand());
});</pre></div><p>That's it! You have <a id="id463" class="indexterm"/>drawn this graph using this data.</p></div><div class="section" title="Modifying the stacked bar into a stacked area graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Modifying the stacked bar into a stacked area graph</h2></div></div></div><p>Stacked area <a id="id464" class="indexterm"/>graphs give a different view of the data than a stacked bar does. To create a stacked area graph, we change the rendering of each series of data as a path. The path is defined using an area generator, which has the <code class="literal">y</code> values on the lower end and the sum of <code class="literal">y0 + y</code> on the upper end.</p><p>The code for the stacked area graph is available online at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note122"/>Note</h3><p>bl.ock (10.2): <a class="ulink" href="http://goo.gl/PRw8wv">http://goo.gl/PRw8wv</a>
</p></div></div><p>The resulting output from this example is the following:</p><div class="mediaobject"><img src="graphics/B04230_10_06.jpg" alt="Modifying the stacked bar into a stacked area graph"/></div><p>The change from the previous example is relatively small. The data is loaded and organized exactly the same. The scales and colors are also created the same way.</p><p>The difference comes in the rendering of the visuals. Instead of groups of rectangles, we render a filled path for each series. The following creates these paths and assigns the color for each:</p><div class="informalexample"><pre class="programlisting">svg.selectAll("path")
    .data(stackedData)
    .enter()
    .append("path")
    .style("fill", function (d, i) {
        return colors(i);
    });</pre></div><p>This has generated the <a id="id465" class="indexterm"/>path elements, but has not assigned the path's <code class="literal">d</code> property yet to create the actual path data. That's our next step, but we first need to create an area generator to convert our data to that which is needed for the path. This area generator needs to have three values specified, the <code class="literal">x</code> value, <code class="literal">y0</code> (which represents the bottom of the area), and <code class="literal">y1</code> (which is at the top of the area):</p><div class="informalexample"><pre class="programlisting">var area = d3.svg.area()
    .x(function (d, i) {
        return xScale(i);
    })
    .y0(function (d) {
        return height - yScale(d.y0);
    })
    .y1(function (d) {
        return height - yScale(d.y + d.y0);
    });</pre></div><p>And finally, we select the paths we just created and bind to each the appropriate series, setting the <code class="literal">d</code> attribute of the corresponding path to the result of calling the area generator. Note that this calls the <a id="id466" class="indexterm"/>area generator for each series:</p><div class="informalexample"><pre class="programlisting">svg.selectAll("path")
    .data(stackedData)
    .transition()
    .attr("d", function (d) {
        return area(d);
    });</pre></div></div><div class="section" title="Converting the area graph to an expanded area graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec63"/>Converting the area graph to an expanded area graph</h2></div></div></div><p>There is a <a id="id467" class="indexterm"/>variant of a stacked area graph known as an expanded area graph. An expanded area graph fills the entire area of the graph completely and can be used to easily visualize the relative percentage that each series represents at each point.</p><p>This type of graph is created from a stacked area graph by normalizing the data at each point across all series to 1.0. The following example demonstrates how this is performed:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note123"/>Note</h3><p>bl.ock (10.3): <a class="ulink" href="http://goo.gl/g9BH4L">http://goo.gl/g9BH4L</a>
</p></div></div><p>The resulting graph is the following:</p><div class="mediaobject"><img src="graphics/B04230_10_07.jpg" alt="Converting the area graph to an expanded area graph"/></div><p>This visually gives us a good feel of how the relative size of each age group changes during the period. For the most part, the age groups have stayed at the same proportion, except for perhaps one state near the end of the data.</p><p>It's a really easy <a id="id468" class="indexterm"/>thing to convert the stacked area graph to an expanded area graph. To accomplish this, we need to do two things. The first of these is to change how we stack the data. We change the stack operation to the following:</p><div class="informalexample"><pre class="programlisting">var stackedData = d3.layout.stack()
    .offset('expand')(statesAndAges);</pre></div><p>The change here is to add a call to <code class="literal">.offset("expand")</code>. This informs D3.js to normalize the results to <code class="literal">[0, 1]</code> for each point. The default offset is <code class="literal">"zero",</code> which, as we have seen, starts <span class="emphasis"><em>Y</em></span> values at <code class="literal">0</code> and does a running sum.</p><p>The data is now ready, and the second change is to change the <code class="literal">Y</code> scale to the account for the domain as <code class="literal">[0, 1]</code>:</p><div class="informalexample"><pre class="programlisting">var yScale = d3.scale.linear()
    .domain([0, 1])
    .range([0, height]);</pre></div><p>You now have your expanded area graph.</p></div></div></div>
<div class="section" title="Visualizing hierarchical data"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec47"/>Visualizing hierarchical data</h1></div></div></div><p>
<span class="strong"><strong>Hierarchal layouts</strong></span> <a id="id469" class="indexterm"/>display information that is hierarchical in nature. That is perhaps a slightly recursive definition, but the basic idea is that certain data items break down into zero or more data items at a lower level, and then perhaps to another level, and so on, for as many levels as is required.</p><p>Hierarchical layouts are all created from the <code class="literal">d3.layout.hierarchy()</code> function, but there are specializations of this function that create various layouts which fall into common visual patterns such as trees, clusters, and enclosures and packs. We will take a look at an example of each of these types of layouts.</p><div class="section" title="Tree diagrams"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Tree diagrams</h2></div></div></div><p>Tree diagrams are essentially <a id="id470" class="indexterm"/>node-link diagrams. In <a class="link" href="ch09.html" title="Chapter 9. Complex Shapes Using Paths">Chapter 9</a>, <span class="emphasis"><em>Complex Shapes using Paths</em></span>, we saw the use of a path generator known as a diagonal. This generator was able to create curved line segments that can connect a node to one or more nodes. To refresh you, we had an example that generated the following:</p><div class="mediaobject"><img src="graphics/B04230_10_08.jpg" alt="Tree diagrams"/></div><p>This is a basic node-link diagram. Tree diagrams utilize diagonals and apply them to many levels of hierarchy. The diagram can be structured as a tree or in other more complex layouts such as a radial cluster (which we will examine). The layouts will calculate the positions of the nodes and then we need to render the nodes and the attached diagonals.</p><p>We will start by creating a simple tree diagram. The data is available at <a class="ulink" href="https://goo.gl/mcdT9r">https://goo.gl/mcdT9r</a>. The contents of the data are the following:</p><div class="informalexample"><pre class="programlisting">{
  "name": "Mike and Marcia",
  "children": [
    {
      "name": "Children",
      "children": [
        { "name": "Mikael" }
      ]
    },
    {
      "name": "Pets",
      "children": [
        {
          "name": "Dogs",
          "children": [
            { "name": "Bleu" },
            { "name": "Tagg" }
          ]
        },
        {
          "name": "Cats",
          "children": [
            { "name": "Bob" },
            { "name": "Peanut" }
          ]
        }
      ]
    }
  ]
}</pre></div><p>The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note124"/>Note</h3><p>bl.ock (10.4): <a class="ulink" href="http://goo.gl/t1hBTS">http://goo.gl/t1hBTS</a>
</p></div></div><p>The result of the rendering <a id="id471" class="indexterm"/>is the following tree diagram:</p><div class="mediaobject"><img src="graphics/B04230_10_09.jpg" alt="Tree diagrams"/></div><p>Our example begins with loading the data, establishing metrics for the diagram, creating the main SVG element, and <a id="id472" class="indexterm"/>establishing a main group and margins:</p><div class="informalexample"><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/25129228aa50c30ef01f/raw/c1c3ad9fa745c42c5410fba29cefccac47cd0ec7/familytree.json';
d3.json(url, function (error, data) {
    var width = 960, height = 500,
        nodeRadius = 10,
        margin = {
            left: 50, top: 10,
            bottom: 10, right: 40
        };

    var svg = d3.select('body')
        .append("svg")
        .attr({
            width: width,
            height: height
        });
    var mainGroup = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + 
                                          margin.top + ')');</pre></div><p>To convert the data into a visual representation of a tree, we will create a tree layout using the <code class="literal">d3.layout.tree()</code> function.</p><div class="informalexample"><pre class="programlisting">var tree = d3.layout.tree()
    .size([
        height - (margin.bottom + margin.top),
        width - (margin.left + margin.right),
    ]);</pre></div><p>This informs D3.js that we want to create a tree that will map its data into a rectangle specified by <code class="literal">height</code> and <code class="literal">width</code>. Notice that the <code class="literal">height</code> is specified before <code class="literal">width</code>.</p><p>There are two visual components to the graph: the nodes, represented by circles, and the edges, which are diagonals. To calculate the nodes, we use the <code class="literal">.nodes()</code> function of the layout and pass it our data.</p><div class="informalexample"><pre class="programlisting">var nodes = tree.nodes(data);</pre></div><p>The tree function looks for a top-level node with a <code class="literal">children</code> property. It will traverse all the nodes in the hierarchy and determine its depth, which, in this case, has four levels. It will then add <code class="literal">x</code> and <code class="literal">y</code> properties to each node, where these represent the calculated position of the nodes based upon the layout and the specific <code class="literal">width</code> and <code class="literal">height</code>.</p><p>Examining the contents of the <code class="literal">nodes</code> variable, we can see that D3.js has given us the positions for each node (the <a id="id473" class="indexterm"/>following shows the first two nodes):</p><div class="mediaobject"><img src="graphics/B04230_10_10.jpg" alt="Tree diagrams"/></div><p>To get the links in the tree, we call <code class="literal">tree.links(nodes)</code>:</p><div class="informalexample"><pre class="programlisting">var links = tree.links(nodes);</pre></div><p>The following shows the link that results in this example:</p><div class="mediaobject"><img src="graphics/B04230_10_11.jpg" alt="Tree diagrams"/></div><p>The newly created data structure consists of an element for each link, of which each object contains a <code class="literal">source</code> and <code class="literal">target</code> property that points to the node that is on each end of the link.</p><p>We now have our data ready for creating visuals. Next is the statement for creating the generator for the diagonals. We use the <code class="literal">.projection()</code> function, since we need to tell the generator how to find the <code class="literal">x</code> and <code class="literal">y</code> value from each datum:</p><div class="informalexample"><pre class="programlisting">var diagonal = d3.svg.diagonal()
    .projection(function(d) {
        return [d.y, d.x];
    });</pre></div><p>Now we can create the <a id="id474" class="indexterm"/>diagonals, reusing the generator for each. The diagonals are created before the nodes, because we want the nodes to be in front:</p><div class="informalexample"><pre class="programlisting">mainGroup.selectAll('path')
    .data(links)
    .enter()
    .append('path', 'g')
    .attr({
        d: diagonal,
        fill: 'none',
        stroke: '#ccc',
        'stroke-width': 2
    });</pre></div><p>Now the code creates the circles and the labels. We will represent each node with a group containing a circle and a piece of text. The following creates these groups and places them at the calculated locations:</p><div class="informalexample"><pre class="programlisting">var circleGroups = mainGroup.selectAll('g')
    .data(nodes)
    .enter()
    .append('g')
    .attr('transform', function (d) {
        return 'translate(' + d.y + ',' + d.x + ')';
    });</pre></div><p>Next, we add the circles as a child of each node's group element:</p><div class="informalexample"><pre class="programlisting">circleGroups.append('circle')
    .attr({
        r: nodeRadius,
        fill: '#fff',
        stroke: 'steelblue',
        'stroke-width': 3,
    });</pre></div><p>And then we add the text for the node label to the group:</p><div class="informalexample"><pre class="programlisting">circleGroups.append('text')
    .text(function (d) {
        return d.name;
    })
    .attr('y', function (d) {
        return d.children || d._children ?
            -nodeRadius * 2 : nodeRadius * 2;
    })
    .attr({
        dy: '.35em',
        'text-anchor': 'middle',
        'fill-opacity': 1
    })
    .style('font', '12px sans-serif');</pre></div><p>The function, when <a id="id475" class="indexterm"/>assigning the <code class="literal">y</code> attribute, offsets the position of the text to be above the circle if the node is not a leaf and underneath the node if it is a leaf node.</p></div><div class="section" title="Creating a cluster dendrogram"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec65"/>Creating a cluster dendrogram</h2></div></div></div><p>A hierarchy can also <a id="id476" class="indexterm"/>be visualized as a variant of a tree known as a <span class="strong"><strong>cluster dendrogram</strong></span>. A cluster dendrogram differs from a tree graph in that we use a cluster layout. This layout places the root of the tree at the center. The depth of the data is calculated, and that number of levels of concentric circles are fit <a id="id477" class="indexterm"/>into the diagram. The nodes for each level of depth are then placed around the edge of the circle for their respective depth.</p><p>To demonstrate this, we will utilize the data available at <a class="ulink" href="https://goo.gl/t3M7n1">https://goo.gl/t3M7n1</a>. This data represents three levels of data, with one root node and four nodes on the second level; each of those nodes has nine children.</p><p>The following is a sample of the data:</p><div class="informalexample"><pre class="programlisting">{
  "name": "1",
  "children": [
    {
      "name": "1-1",
      "children": [
        { "name": "1-1-1" },
        { "name": "1-1-2" },
        { "name": "1-1-3" },
        { "name": "1-1-4" },
        { "name": "1-1-5" },
        { "name": "1-1-6" },
        { "name": "1-1-7" },
        { "name": "1-1-8" },
        { "name": "1-1-9" }
      ]
    },
    {
      "name": "1-2",
      "children": [
        { "name": "1-2-1" },
        { "name": "1-2-2" },
        { "name": "1-2-3" },
...</pre></div><p>The example is <a id="id478" class="indexterm"/>available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note125"/>Note</h3><p>bl.ock (10.5): <a class="ulink" href="http://goo.gl/cQtPuH">http://goo.gl/cQtPuH</a>
</p></div></div><p>The resulting graph <a id="id479" class="indexterm"/>is the following:</p><div class="mediaobject"><img src="graphics/B04230_10_12.jpg" alt="Creating a cluster dendrogram"/></div><p>Let's step through how this is created. The code is similar to the tree example, but with some differences. After <a id="id480" class="indexterm"/>the data is loaded, the main SVG element is created, and then a group is placed within the element:</p><div class="informalexample"><pre class="programlisting">var center = width / 2;
var mainGroup = svg.append('g')
    .attr("transform", "translate(" + center + "," + 
                                      center + ")");</pre></div><p>The layout algorithm will calculate the points around a center at (<span class="strong"><strong>0, 0</strong></span>), so we center the group to center the graph.</p><p>The layout is then created using <code class="literal">d3.layout.cluster()</code>:</p><div class="informalexample"><pre class="programlisting">var cluster = d3.layout.cluster()
    .size([
        360,
        center - 50
    ]);</pre></div><p>The size specifies two things; the first parameter is the number of degrees that the points will sweep through on the outer circle. This specifies <code class="literal">360</code> degrees so that we completely fill the outer circle. The second parameter is the tree depth, or what is essentially the radius of the outermost circle.</p><p>Next, we use the layout to calculate the position for the nodes and links:</p><div class="informalexample"><pre class="programlisting">var nodes = cluster.nodes(data);
var links = cluster.links(nodes);</pre></div><p>It is worth examining the first few nodes that result from these calculations:</p><div class="mediaobject"><img src="graphics/B04230_10_13.jpg" alt="Creating a cluster dendrogram"/></div><p>The <code class="literal">x</code> and <code class="literal">y</code> properties specify a direction and distance at which the node (and edges) is to be placed. The <code class="literal">x</code> property specifies the angle from vertical, and the value of the <code class="literal">y</code> property specifies the distance.</p><p>The diagonals are <a id="id481" class="indexterm"/>calculated using a radial diagonal, which needs to convert the <code class="literal">x</code> values into radians:</p><div class="informalexample"><pre class="programlisting">var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) {
        return [
            d.y,
            d.x / 180 * Math.PI
        ];
    });</pre></div><p>Now we can use this radial generator diagonal that connects the nodes:</p><div class="informalexample"><pre class="programlisting">mainGroup.selectAll('path')
    .data(links)
    .enter()
    .append('path')
    .attr({
        'd': diagonal,
        fill: 'none',
        stroke: '#ccc',
        'stroke-width': 2
    }); </pre></div><p>Next, we create a group to hold the node and the text. The trick to this is that we need to translate and rotate the group into the correct position:</p><div class="informalexample"><pre class="programlisting">var nodeGroups = mainGroup.selectAll("g")
    .data(nodes)
    .enter()
    .append("g")
    .attr("transform", function(d) {
        return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")";
    }); </pre></div><p>We rotate the group by <code class="literal">90</code> degrees from the calculated angle. This changes the orientation of the the text to flow out from the circle, along the diagonals. Note that rotate works in degrees, not radians, as was required for the radial generator. The translate uses just the <code class="literal">y</code> value, which moves the group out that distance along the specified angle. Now we add the circles to the group:</p><div class="informalexample"><pre class="programlisting">nodeGroups.append("circle")
    .attr({
        r: nodeRadius,
        fill: '#fff',
        stroke: 'steelblue',
        'stroke-width': 3
    });</pre></div><p>And finally, we add the text. Note the small calculation around the text being at an angle greater or less than 180 degrees. This essentially says that nodes on the left-half of the diagram are positioned with the end of the text against the node and on the right side, start at the beginning <a id="id482" class="indexterm"/>of the text. The text is also transformed by twice the circle radius to prevent it from overlapping the circle:</p><div class="informalexample"><pre class="programlisting">nodeGroups.append('text')
    .attr({
            dy: '.31em',
            'text-anchor': function(d) {
                return d.x &lt; 180 ? 'start' : 'end';
            },
            'transform': function(d) {
                return d.x &lt; 180 ? 
                           'translate(' + (nodeRadius*2) + ')' :
                           'rotate(180)' +
                           'translate(' + (-nodeRadius*2) + ')';
            }
        })
        .style('font', '12px sans-serif')
    .text(function(d) { return d.name; });</pre></div></div><div class="section" title="Representing hierarchy with an enclosure diagram"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec66"/>Representing hierarchy with an enclosure diagram</h2></div></div></div><p>Enclosure <a id="id483" class="indexterm"/>diagrams use nesting of visuals to represent the hierarchy. The size of each leaf node's circle reveals a quantitative dimension of each data point. The enclosing circles show the approximate cumulative size of each subtree, but note that because of wasted space, there is some distortion between levels. Therefore, only the leaf nodes can be compared accurately.</p><p>The following is the location of the online example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note126"/>Note</h3><p>bl.ock (10.6): <a class="ulink" href="http://goo.gl/MQ3CwG">http://goo.gl/MQ3CwG</a>
</p></div></div><p>The following image is the resulting visual:</p><div class="mediaobject"><img src="graphics/B04230_10_14.jpg" alt="Representing hierarchy with an enclosure diagram"/></div><p>The data used by the example is available at <a class="ulink" href="https://goo.gl/RzvlV3">https://goo.gl/RzvlV3</a>. It is similar in structure to the data in the previous example, except that a <code class="literal">value</code> property is added to each node. The values of the leaf nodes are summed in their parents, repeating all the way to the top.</p><p>Essentially, this <a id="id484" class="indexterm"/>data is a rollup of the values, much like what would be performed when rolling up sales numbers from sales persons, to offices, to divisions, to the corporate level. The diagram then allows us to see relative sizes of the numbers in the leaf nodes, which are colored orange, and then get an idea of the total at each level up the tree.</p><p>Now let's examine how this is created. The example begins with loading of the data and then creating an SVG element of a specified diameter. Then, a pack layout is created that is also used the diameter. The hierarchical bubbles that are created will be measured to fit within the specified diameter:</p><div class="informalexample"><pre class="programlisting">var pack = d3.layout.pack()
    .size([diameter, diameter])
    .value(function (d) { return d.value; });</pre></div><p>Now we render the circles. For each node, we append a group that is translated to the appropriate position and then a circle is appended with its radius set to the calculated radius <code class="literal">(d.r),</code> the <code class="literal">fill</code>, <code class="literal">fill-opacity</code>, and the <code class="literal">stroke</code> to different values depending on whether the node is a leaf or not:</p><div class="informalexample"><pre class="programlisting">var nodes = svg.datum(data)
    .selectAll('g')
    .data(pack.nodes)
    .enter()
    .append('g')
    .attr('transform', function (d) {
        return 'translate(' + d.x + ',' + d.y + ')';
    });

nodes.append('circle')
    .each(function (d) {
        d3.select(this)
            .attr({
                r: d.r,
                fill: d.children ? 'rgb(31, 119, 180)' :
                                   '#ff7f0e',
                'fill-opacity': d.children ? 0.25 : 1.0,
                stroke: d.children ? 'rgb(31, 119, 180)' : 'none'
            });
    });</pre></div><p>The last step is <a id="id485" class="indexterm"/>to add the text to the leaf circles (the ones without children, as specified using the filter):</p><div class="informalexample"><pre class="programlisting">nodes.filter(function(d) {
        return !d.children;
    })
    .append('text')
    .attr('dy', '.3em')
    .style({
        'text-anchor': 'middle',
        'font': '10px sans-serif'
    })
    .text(function(d) {
        return d.name.substring(0, d.r / 3);
    });</pre></div></div></div>
<div class="section" title="Representing relationships with chord diagrams"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec48"/>Representing relationships with chord diagrams</h1></div></div></div><p>Chord diagrams <a id="id486" class="indexterm"/>demonstrate the relationships <a id="id487" class="indexterm"/>among a group of entities. To demonstrate, we will use the example available at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note127"/>Note</h3><p>bl.ock (10.7): <a class="ulink" href="http://goo.gl/8mRDSg">http://goo.gl/8mRDSg</a>
</p></div></div><p>The resulting diagram is the following:</p><div class="mediaobject"><img src="graphics/B04230_10_15.jpg" alt="Representing relationships with chord diagrams"/></div><p>The data in this example is a square matrix of data, with rows and columns representing hair color (black, blonde, brown, and red). The data represents a total sample of <span class="strong"><strong>100000</strong></span> measurements, where each row demonstrates the total count of the other hair colors which a person of a given hair color prefers:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top"> </td><td colspan="5" style="text-align: center" valign="bottom">
<p>
<span class="emphasis"><em><span class="strong"><strong>Prefers</strong></span></em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em><span class="strong"><strong>Has</strong></span></em></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Black</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Blonde</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Brown</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Red</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Total</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Black</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>11975</p>
</td><td style="text-align: left" valign="top">
<p>5871</p>
</td><td style="text-align: left" valign="top">
<p>8916</p>
</td><td style="text-align: left" valign="top">
<p>2868</p>
</td><td style="text-align: left" valign="top">
<p>29630</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Blonde</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>1951</p>
</td><td style="text-align: left" valign="top">
<p>10048</p>
</td><td style="text-align: left" valign="top">
<p>2060</p>
</td><td style="text-align: left" valign="top">
<p>6171</p>
</td><td style="text-align: left" valign="top">
<p>20230</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Brown</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>8010</p>
</td><td style="text-align: left" valign="top">
<p>16145</p>
</td><td style="text-align: left" valign="top">
<p>8090</p>
</td><td style="text-align: left" valign="top">
<p>8045</p>
</td><td style="text-align: left" valign="top">
<p>40290</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Red</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>1013</p>
</td><td style="text-align: left" valign="top">
<p>990</p>
</td><td style="text-align: left" valign="top">
<p>940</p>
</td><td style="text-align: left" valign="top">
<p>6907</p>
</td><td style="text-align: left" valign="top">
<p>9850</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Total</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>22949</p>
</td><td style="text-align: left" valign="top">
<p>30354</p>
</td><td style="text-align: left" valign="top">
<p>20006</p>
</td><td style="text-align: left" valign="top">
<p>23991</p>
</td><td style="text-align: left" valign="top">
<p>10000</p>
</td></tr></tbody></table></div><p>To explain the diagram, each outer ring segment represents the number of people that have a given hair color. The size of these ring segments is relative to the percentage of people of a given <a id="id488" class="indexterm"/>hair color. Each arc from a given <a id="id489" class="indexterm"/>color ring segment to another ring segment (or itself) represents the number of people of that hair color that prefer the hair color on the other side of that arc and vice versa. The ticks on the outside of each ring segment gives a feel for the total number of the people represented.</p><p>Now let's step through creating this graph. First, we create our top-level SVG elements. The main group is translated to the center, as the positions will be centered around (<span class="strong"><strong>0, 0</strong></span>):</p><div class="informalexample"><pre class="programlisting">var width = 960, height = 500;
var svg = d3.select('body')
    .append('svg')
    .attr({
        width: width,
        height: height
    });
var mainGroup = svg.append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + 
                                      height / 2 + ')');</pre></div><p>Now let's declare the data. We will use a hard-coded array instead of reading from a file. These values represent the values from the previous table, exclusive of the totals:</p><div class="informalexample"><pre class="programlisting">var matrix = [
    [11975, 5871, 8916, 2868],
    [1951, 10048, 2060, 6171],
    [8010, 16145, 8090, 8045],
    [1013, 990, 940, 6907]
];</pre></div><p>We then use the <code class="literal">d3.layout.chord()</code> function to create the layout object for this graph.</p><div class="informalexample"><pre class="programlisting">var layout = d3.layout.chord()
    .padding(.05)
    .matrix(matrix);</pre></div><p>
<code class="literal">.padding(0.05)</code> states that there will be <code class="literal">0.05</code> radians of space between the sections on the outside of the diagram, and the call to <code class="literal">.matrix()</code> specifies the data to use.</p><p>The following line of code creates the colors that will be utilized (black, blondish, brownish, and reddish):</p><div class="informalexample"><pre class="programlisting">var fill = d3.scale.ordinal().domain(d3.range(4))
    .range(['#000000', '#FFEE89', '#957244', '#FF0023']);</pre></div><p>Then, the ring segments are rendered. The inner and outer radius of the ring segments is calculated as <a id="id490" class="indexterm"/>percentages of the smallest dimension <a id="id491" class="indexterm"/>of the visual. The data that is bound is the group's property of the layout object. For each of these, we render a path using an arc generator:</p><div class="informalexample"><pre class="programlisting">var innerRadius = Math.min(width, height) * 0.41,
    outerRadius = innerRadius * 1.1;
mainGroup.append('g')
    .selectAll('path')
    .data(layout.groups)
    .enter()
    .append('path')
    .style('fill', function(d) { return fill(d.index); })
    .style('stroke', function(d) { return fill(d.index); })
    .attr('d', d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius));</pre></div><p>Next, the chords are rendered. A <code class="literal">d3.svg.chord()</code> function will be applied to each datum, and a path of the size <code class="literal">innerRadius</code> is generated:</p><div class="informalexample"><pre class="programlisting">mainGroup.append('g')
    .selectAll('path')
    .data(layout.chords)
    .enter()
    .append('path')
    .attr('d', d3.svg.chord()
                 .radius(innerRadius))
    .style('fill', function(d) { return fill(d.target.index); })
    .style({
        opacity: 1,
        stroke: '#000',
        'fill-opacity': 0.67,
        'stroke-width': '0.5px'
    });</pre></div><p>At this point, we have created the entire chord graph sans ticks and labels. We will omit covering those in the <a id="id492" class="indexterm"/>book, but feel free to check out <a id="id493" class="indexterm"/>the sample code with the text to see how this is performed.</p></div>
<div class="section" title="Techniques to demonstrate the flow of information"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec49"/>Techniques to demonstrate the flow of information</h1></div></div></div><p>The last two layouts <a id="id494" class="indexterm"/>and corresponding visualizations that we will examine help the viewer to understand how data changes as it flows over time or through intermediate points.</p><div class="section" title="Using streamgraphs to show changes in values"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec67"/>Using streamgraphs to show changes in values</h2></div></div></div><p>A <span class="strong"><strong>streamgraph</strong></span> <a id="id495" class="indexterm"/>demonstrates the change in values in a multiple series of data as a flowing stream of data. The height of each stream represents the value of that stream at that moment in time.</p><p>They are useful for demonstrating where certain categories start or stop at different points along the graph. Common <a id="id496" class="indexterm"/>examples are data such as box-office receipts or the number of listeners for various artists on streaming media as they change over time.</p><p>To demonstrate a streamgraph, we will use the data available at <a class="ulink" href="https://goo.gl/HTL4HG">https://goo.gl/HTL4HG</a>.</p><p>This data consists of four series of data:</p><div class="informalexample"><pre class="programlisting"> [
  [ 20, 49, 67, 16,  0, 19, 19, 0,  0, 1, 10,  5, 6,  1,  1 ],
  [ 4,   6,  3, 34,  0, 16,  1, 2,  1, 1,  6,  0, 1, 56,  0 ],
  [ 2,   8, 13, 15,  0, 12, 23, 15,10, 1,  0,  1, 0,  0,  6 ],
  [ 3,   9, 28,  0, 91,  6,  1, 0,  0, 0,  7, 18, 0,  9, 16 ]
]</pre></div><p>The online example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note128"/>Note</h3><p>bl.ock (10.8): <a class="ulink" href="http://goo.gl/LMd3F3">http://goo.gl/LMd3F3</a>
</p></div></div><p>The following is the resulting streamgraph:</p><div class="mediaobject"><img src="graphics/B04230_10_16.jpg" alt="Using streamgraphs to show changes in values"/></div><p>This graph allows us to see how each individual series of data is related to each other at each point of measurement. It is, in a way, like a stacked area chart, but instead of each being fixed at a common baseline, the bottom of the graph is also allowed to vary in location.</p><p>The example begins by <a id="id497" class="indexterm"/>loading the data and setting up the <a id="id498" class="indexterm"/>main SVG element:</p><div class="informalexample"><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/25129228aa50c30ef01f/raw/4393a0e579cbfd9bb20a431ce93c72fb1ea23537/streamgraph.json';
d3.json(url, function (error, rawData) {
    var width = 960, height = 500;
    var svg = d3.select('body')
        .append('svg')
        .attr({
            'width': width,
            'height': height
        });</pre></div><p>We need to massage the data a little bit, as the call to the layout function will expect it in the same format as an area graph, which is an array of arrays of objects with <code class="literal">x</code> and <code class="literal">y</code> properties. The following code creates this, using the position of the value in each array as the <code class="literal">x</code> value:</p><div class="informalexample"><pre class="programlisting">var data = Array();
d3.map(rawData, function (d, i) {
    data[i] = d.map(function (i, j) {
        return { x: j, y: i };
    });
});</pre></div><p>Next, the code creates the axes, with the <span class="emphasis"><em>X</em></span> axis being a linear axis representing the number of points in <a id="id499" class="indexterm"/>each series:</p><div class="informalexample"><pre class="programlisting">var numPointsPerLayer = data[0].length;

var xScale = d3.scale.linear()
    .domain([0, numPointsPerLayer - 1])
    .range([0, width]);</pre></div><p>The layout is the familiar <a id="id500" class="indexterm"/>stack layout that was used in the area graph example, but we chain a call to <code class="literal">.offset('wiggle')</code>:</p><div class="informalexample"><pre class="programlisting">var layers = d3.layout.stack()
    .offset('wiggle')(data);</pre></div><p>The remainder of the code continues just as an area graph, using an area path generator and similarly scaled <span class="emphasis"><em>Y</em></span> axis.</p></div><div class="section" title="Representing flows through multiple nodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec68"/>Representing flows through multiple nodes</h2></div></div></div><p>Instead of <a id="id501" class="indexterm"/>showing a continuous flow like a streamgraph, a <span class="strong"><strong>Sankey</strong></span> diagram emphasizes how the flow quantity changes proportionally. This is somewhat like a chord diagram, but a Sankey has the ability to visualize more complex flows than just between two items.</p><p>In a Sankey diagram, the width of the lines between the nodes represents the volume of the flow between two nodes. Normally, flows start at one or more nodes on the left, flow through intermediates, and then terminate at nodes on the right.</p><p>The example diagram uses the data available at <a class="ulink" href="https://goo.gl/lgQZBz">https://goo.gl/lgQZBz</a>. This data consists of declarations for eight nodes and then the links between the nodes along with the amount of the flow between the nodes:</p><div class="informalexample"><pre class="programlisting">{
"nodes":[
  {"node":0, "name":"Source 1"},
  {"node":1, "name":"Source 2"},
  {"node":2, "name":"First Level Distribution"},
  {"node":3, "name":"Second Level Distribution 1"},
  {"node":4, "name":"Terminus 1"},
  {"node":5, "name":"Terminus 2"},
  {"node":6, "name":"Second Level Distribution 2"},
  {"node":7, "name":"Source 3"}
],
"links":[
  {"source":0, "target":2, "value":6},
  {"source":0, "target":4, "value":2},

  {"source":1, "target":2, "value":4},
  {"source":1, "target":3, "value":2},
  {"source":1, "target":6, "value":1},
  
  {"source":2, "target":3, "value":5},
  {"source":2, "target":4, "value":3},
  {"source":2, "target":6, "value":2},
  
  {"source":3, "target":4, "value":4},
  {"source":3, "target":5, "value":4},

  {"source":6, "target":5, "value":5},
  {"source":7, "target":6, "value":2},
  {"source":7, "target":3, "value":1}
] 
}</pre></div><p>The online example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note129"/>Note</h3><p>bl.ock (10.9): <a class="ulink" href="http://goo.gl/exZkI4">http://goo.gl/exZkI4</a>
</p></div></div><p>The resulting <a id="id502" class="indexterm"/>Sankey diagram from this data will be the following:</p><div class="mediaobject"><img src="graphics/B04230_10_17.jpg" alt="Representing flows through multiple nodes"/></div><p>The Sankey layout is considered a plugin to D3.js. It is not in the base library, so you need to retrieve the code, and make sure to reference it in your app. This code is available at <a class="ulink" href="https://github.com/d3/d3-plugins/tree/master/sankey">https://github.com/d3/d3-plugins/tree/master/sankey</a>, or you can grab it from the book's example.</p><p>The example <a id="id503" class="indexterm"/>begins by loading the data and creating the main SVG elements:</p><div class="informalexample"><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/25129228aa50c30ef01f/raw/e6ea7c4728e45fb8d0464b21686eec806687e117/sankey.json';
d3.json(url, function(error, graph) {
    var width = 950, height = 500;
    var svg = d3.select('body')
        .append('svg')
        .attr({
            width: width,
            height: height
        });
    var mainGroup = svg.append('g');</pre></div><p>We create the layout using the plugin as follows. There are lot of parameters here to specify the size of the nodes, the padding, overall size of the diagram, where to get the links and nodes in your data, and layout specifying the number of iterations to be processed for positioning the nodes:</p><div class="informalexample"><pre class="programlisting">var sankey = d3.sankey()
    .nodeWidth(36)
    .nodePadding(40)
    .size([width, height])
    .nodes(graph.nodes)
    .links(graph.links)
    .layout(10);</pre></div><p>The flow paths (links) are rendered by creating paths representing flows. The structure of the path is <a id="id504" class="indexterm"/>provided by referencing the <code class="literal">sankey.link()</code>, which is a function that creates the path data for the flow:</p><div class="informalexample"><pre class="programlisting">mainGroup.append('g')
    .selectAll('g.link')
    .data(data.links)
    .enter()
    .append('path')
    .attr({
        d: sankey.link(),
        fill: 'none',
        stroke: '#000',
        'stroke-opacity': 0.2,
        'stroke-width': function(d) { return Math.max(1, d.dy) }
    })
    .sort(function(a, b) { return b.dy - a.dy; });</pre></div><p>Now we create a group to hold the nodes and place them into position based on the <code class="literal">x</code> and <code class="literal">y</code> properties provided by the layout. The <code class="literal">.node</code> style is used simply to differentiate the selection of these groups from those of the paths (which used <code class="literal">.link</code>):</p><div class="informalexample"><pre class="programlisting">var nodes = mainGroup.append('g')
    .selectAll('g.node')
    .data(data.nodes)
    .enter()
    .append('g')
    .attr('transform', function(d) {
        return 'translate(' + d.x + ',' + d.y + ')';
    });</pre></div><p>Then, we insert a colored rectangle into the groups:</p><div class="informalexample"><pre class="programlisting">var color = d3.scale.category20();
nodes.append('rect')
    .attr({
        height: function(d) { return d.dy; },
        width: sankey.nodeWidth(),
        fill: function(d, i) {
            return d.color = color(i);
        },
        stroke: 'black'
    });</pre></div><p>We also <a id="id505" class="indexterm"/>include text to describe the node, with some logic to position the label:</p><div class="informalexample"><pre class="programlisting">nodes.append('text')
    .attr({
        x: -6,
        y: function(d) { return d.dy / 2; },
        dy: '.35em',
        'text-anchor': 'end'
    })
    .style('font', '10px sans-serif')
    .text(function(d) { return d.name; })
    .filter(function(d) { return d.x &lt; width / 2; })
    .attr({
        x: 6 + sankey.nodeWidth(),
        'text-anchor': 'start'
    });</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec50"/>Summary</h1></div></div></div><p>We have covered a lot in this chapter. The overall focus was on creating complex graphs that utilize D3.js layout objects. These included a multitude of graphs in different categories including stacked, packed, clustered, flow-based, hierarchical, and radial.</p><p>One of the beauties of D3.js is the ease at which it allows you to create these complex visuals. They are pattern-oriented such that the code for each is often very similar, with just a slight change of layout objects.</p><p>In the next chapter, we will look at a specific type of graph in detail: the network diagram. These extend upon several concepts we have seen in this chapter, such as flow and hierarchy, to allow us to visualize very complex network data such as those found in social networks.</p></div></body></html>