- en: Chapter 8. Application Implementation – Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After discussing the architectural concepts of our modular design in the previous
    chapter, it is time for us to look at the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to examine the code and see how all the pieces fit
    and work together in a real application.
  prefs: []
  type: TYPE_NORMAL
- en: While we will not discuss every aspect of the code, each main piece will be
    broken down into smaller pieces, and most of the details will be explained.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you download the project code related to this chapter
    from the site accompanying this book and follow along as we go through the finer
    points of the code. I am using different techniques at different parts of the
    code, which at first glance, might look inconsistent. However, this is done intentionally
    so that you can see how different techniques can be applied as needed, in different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that many aspects of the application can be improved upon
    as the focus has been on creating a **Proof Of Concept** (**POC**) application
    as opposed to production quality code. You will see how our modular approach allows
    us to create an easily maintainable, extensible, and robust application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the main modules in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine how components in the application have been constructed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the overall architecture of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at our publish-subscribe implementation, which provides loose coupling
    among our modules and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a simple client-side router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But before examining the implementation, let's have a look at the final view
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The user's view of our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you load `index.html` file of our project using an IDE which has a built-in
    web server, you will see the following main page in the browser. This file resides
    at the root of the application folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![The user''s view of our application](img/B04910_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you may have noticed, I have made improvements to the look and feel of the
    application, in comparison to what we had in the previous chapters. I have also
    done some re-factoring of the code in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'I mentioned previously that our application is somewhat responsive based on
    the browser''s view-port. The following screenshot shows the application''s `index.html`
    page in the Chrome Developer Tools emulator (*Ctrl* + *Shift* + *M* in Windows),
    simulating its rendering in an Apple iPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user''s view of our application](img/B04910_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Application functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, our application was intended to be an image gallery-type
    application which displays a list of images. Users are able to interact with the
    application in a variety of different ways. While the application might seem very
    simple from a user's point of view, it is designed from the ground up, to be easily
    extensible, so more functionality can be added to it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the various aspects of our application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Index page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main page of the application (`index.html`) consists of three main components:
    `header`, `footer`, and `content`.'
  prefs: []
  type: TYPE_NORMAL
- en: These components build the header, footer, and content sections (page fragments)
    of the main page respectively, as shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Since we designed our application as a **Single Page Application** (**SPA**),
    navigation to different pages of the application only updates the view of the
    content area.
  prefs: []
  type: TYPE_NORMAL
- en: The footer and header sections of the application are rendered only once, and
    that is at the initial load time of `index.html`. The main advantage of our SPA
    design is that there is no need to fully re-render the page every time different
    pages are viewed. Therefore, there is no flickering of the page in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the main page, users are able to see the full catalog of all the images available.
    By clicking on an image, the user can see its full-size. Images can also be added
    to, or removed from, the list of favorite images when the user clicks on the related
    link below each image.
  prefs: []
  type: TYPE_NORMAL
- en: Users are able to interact with the header and footer of the application too,
    even though, for our POC, not all the links in the footer and header are activated.
  prefs: []
  type: TYPE_NORMAL
- en: Image page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user clicks on an image, the view of the content area of the application
    is changed to show the image in full view, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image page](img/B04910_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the address bar of the browser, the URL of the page changes
    when an image is clicked to reflect the ID of the image. For the preceding image,
    the URL of the page will be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:49202/Image_9.jpg`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the URL of your local server along with the image ID.
  prefs: []
  type: TYPE_NORMAL
- en: Favorites page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the main page of our application, a user can click on the link at the bottom
    of each image to add the image to the list of his/her favorite images, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Favorites page](img/B04910_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once **Add to Favorites** link has been clicked, the text of the link changes
    to **Remove from Favorites**, which enables the user to remove the image from
    the list of favorite images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can also view all of their favorite images by clicking the **Favorites**
    link in the header section of the page; which takes the user to the **Favorites**
    page of the application, as displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Favorites page](img/B04910_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Support widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user clicks on the **Support** link in the footer section of the application,
    a dialog box will be displayed with information regarding the site's catalog.
  prefs: []
  type: TYPE_NORMAL
- en: This widget (the dialogue box) has been designed to be dynamically loaded, and
    rendered on the page, but only when the **Support** link is clicked. This is an
    example of how components can be loaded and rendered dynamically in the application,
    as needed. This allows us to keep the weight of the application in the browser
    light and minimize its footprint.
  prefs: []
  type: TYPE_NORMAL
- en: The design of this widget also demonstrates the concept of plug-and-play in
    respect to dynamic components in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how this widget is displayed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Support widget](img/B04910_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have had a look at the appearance of the application, it is time
    to examine the mechanics of its implementation and see how things are done under-the-hood.
  prefs: []
  type: TYPE_NORMAL
- en: Application implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the beginning, our intent in the design of our application was to create
    a modularized ecosystem in which different pieces of the code (modules) would
    be joined together to create a fully functional application. To that end, our
    code has been structured as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application implementation](img/B04910_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our application has been organized into three main folders:
    `css` which hosts all of our styling files, `Images` which stores all the images
    in the application''s catalog; and `js`, which contains all the JavaScript code
    for our application. As this structure is only one approach to organizing the
    application''s code, you may decide to organize the code differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Under `js` folder, we have organized our JavaScript files further into three
    main sub-folders; `Components` which contains the files related to modules that
    have views associated with them, `Modules` which contains our modules for the
    controller and Model of the application, and `Widgets` which hosts files related
    to components that are loaded and rendered dynamically in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Modules` folder is further broken down into five sub-folders; `Base` which
    contains our third-party dependencies and the base module, `Core` which hosts
    the controller's code (modules) for our application, and `GlobalData` which holds
    our application's model files.
  prefs: []
  type: TYPE_NORMAL
- en: The other two sub-folders, `SandBox` and `PageDefinitions` contain the sandbox
    module and object definitions file for our dynamically loading components, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine the code in most of the files of our sub-folders in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Loading our module files in index.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start looking at our JavaScript code and modules, let's have a closer
    look at `index.html` file and see how the application modules are loaded in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Our `index.html` page is designed in such a way that it only provides the bare
    minimum skeleton for our application's main page, and all the other pieces (header,
    footer, and content) are built dynamically when the page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, there are instances when it makes more sense to build some
    of the pieces of the application's pages on the server before sending them to
    the client, since this implementation could provide better performance at times.
  prefs: []
  type: TYPE_NORMAL
- en: In our approach here, we are building all the pieces of our application's pages
    on the client. This is so we can examine and apply different concepts of our application's
    design a little easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The skeleton of our `index.html` file consists of three main containers, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have our header container, which hosts the `header` component
    of our application, the main container, which hosts the `content` component of
    our application and a `div`, which is the container for our `footer` component.
  prefs: []
  type: TYPE_NORMAL
- en: These are the pieces (containers) in our `index.html` page which are passed
    to our components so they can render themselves inside of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just before the closing tag for the page''s body element, we have included
    the `<script>` tags which load the scripts for our application. Let''s have a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading our module files in index.html](img/B04910_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, quite a few script files need to be loaded. We can improve on
    this by combining (and minifying) some of the files together, as well as using
    formats such as **Asynchronous Module Definition** (**AMD**) in conjunction with
    libraries like `Require.js` to load our files. For now however, for the sake of
    clarity, we leave things as they are.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Enterprise Grade Modular Design, AMD,
    CommonJS, and ES6 Modules"), *Enterprise Grade Modular Design, AMD, CommonJS,
    and ES6 Modules* of this book, we will discuss how we can use AMD format to combine
    and load our application's required files in a more optimized way.
  prefs: []
  type: TYPE_NORMAL
- en: The following script has also been implemented in our `index.html` file, which
    is responsible for starting up the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading our module files in index.html](img/B04910_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will discuss how the start-up of the application takes place shortly. Notice
    that we initialize all the modules first, then the components, and at the end,
    we pass the URL of the page to `handlePageChange` method of `ImagesInc_Core` module.
    This is done, so we can use the URL of the page in our application's router, which
    will be examined in depth shortly.
  prefs: []
  type: TYPE_NORMAL
- en: I emphasize the point that as you are reading this chapter, you should probably
    load the related code into your IDE so you can easily follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Base module implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start the exploration of our application's modules with the base module.
    Our `Base` folder hosts two JavaScript files; `Base.js` and `jquery-1.10.2.min.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Base.js` file implements `ImagesInc_Base` module which is responsible for
    importing all of our third-party libraries into the application, as we discussed
    in the previous chapter. Currently, the only third-party library that we are importing
    is jQuery.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how this is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using an IIFE to return an object to the global variable
    `ImagesInc_Base`.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we first check to see if a jQuery object has been defined
    in the global scope; if so, we return it. Otherwise, `null` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Our core module will be using this object to leverage the jQuery library's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in `MainCore` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As our `MainCore` module is initializing itself (using an IIFE), it asks the
    base module for its base library and then assigns a reference of the returned
    object in both the `$` and `mainCore.jQuery` properties of `MainCore` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the current implementation, we are only able to import one base
    library. This is to keep the implementation simple, as we only need jQuery in
    our application. However, we could also import and use a collection of libraries
    with some modification to this code.
  prefs: []
  type: TYPE_NORMAL
- en: Core module implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Core module is the heavy-lifter module in our application, and is constructed
    using a few sub-modules. This module's functionality has also been enhanced and
    augmented using the techniques that we discussed in the previous chapters, such
    as tight and loose augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of all the sub-modules that make up the Core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Core module implementation](img/B04910_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will not cover all the related code for this module but we will have a look
    at the important parts of it in this section. Note that the Core module is also
    the controller of our application.
  prefs: []
  type: TYPE_NORMAL
- en: MainCore module implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This module provides the main functionality of the Core module and all the related
    Core's sub-modules are attached to this module, hence the name `MainCore.js`.
  prefs: []
  type: TYPE_NORMAL
- en: I'll be referring to this module as **MainCore** from this point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module has been defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the loose augmentation technique in this module
    to enhance its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This module also uses an inner IIFE to initialize itself and to import our application's
    base library. When the application is in debug mode, MainCore will announce that
    it has been initialized as soon as it is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn the debug mode on or off in the application, we have implemented the
    following method which can be called by the external code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are returning a reference to MainCore module as a global variable,
    `ImagesInc_Core`, which allows the external code to interact with this module,
    through the interface that this module provides.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting MainCore module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In designing MainCore module, I have purposely used various augmentation techniques.
    This is done to demonstrate the practical aspects of such techniques in enchaining
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting MainCore using tight augmentation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider the following augmentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have made a logical separation between the code that deals with event-related
    functionality in MainCore module and the rest of the code related to this module.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have passed a reference of MainCore module (known to the application
    as `ImagesInc_Core`) to the IIFE that implements this augmentation (using tight
    augmentation technique) and then we have added new properties to MainCore module
    as needed. At the end, the reference to the now augmented MainCore module is returned
    to `ImagesInc_Core`, which is the global variable that provides access to MainCore
    module.
  prefs: []
  type: TYPE_NORMAL
- en: We use the same technique again in another part of the code to augment the module
    with more functionality. Please have a look at the related code in `MainCore.js`
    file of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting MainCore using sub-modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's look at an example of how we add sub-modules to MainCore module. To add
    enhanced logging functionality to the application, we have augmented MainCore
    module with a sub-module which specializes in logging messages for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how this sub-module is being used by MainCore
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first check to see if `LoggingHandler` object (the logging
    sub-module) exists and also if `logMessage` method on that object is implemented.
    If both conditions are met, then we pass on the logging message and its related
    information to this sub-module.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the logging sub-module or its required method do not exit,
    we use `mainCore` module's own simple logging mechanism to log messages in the
    browser's console.
  prefs: []
  type: TYPE_NORMAL
- en: We should have a look at how `LoggingHandler` sub-module has been implemented
    and added to MainCore module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown, we have added a property to `ImagesInc_Core` object (MainCore module).
    An IIFE returns an object to this property (`LoggingHandler`) when it is executed.
    This object consists of two methods which provide all the functionality related
    to the logging mechanism of the application.
  prefs: []
  type: TYPE_NORMAL
- en: While the implementation of these two methods is hidden away from the rest of
    the application, other pieces of the application can interact with this sub-module
    through MainCore module and the related interface.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this sub-module can easily be swapped for a different one or modified
    internally in any form that we desire. However, as long as the exposed interface
    does not change, all the external code would still be able to use this sub-module
    for its logging functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can even remove this sub-module completely and it will not affect
    the application at all, except for the fact that the advanced logging mechanism
    for the application would be absent. This highlights some of the advantages of
    modular design in our application, such as **plug-and-play**, **progressive enhancement**,
    and **graceful degradation**.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, we can also add other sub-modules to MainCore module to provide
    more functionality without the need to make many changes in the application. This
    allows us to have a flexible and easily maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, there are also other sub-modules, which attach themselves
    to MainCore module, and provide added functionality to the application. We talked
    about these sub-modules in the previous chapter but I will mention them again
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AjaxEngine`: This module is responsible for making AJAX calls to the server,
    using jQuery AJAX functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CookieHandler`: This module looks after all the cookie-related operations
    in the application, such as writing, reading, and deleting cookies in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotificationHandler`: This module is responsible for displaying notifications
    to the users by leveraging a dialog box component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StorageHanlder`: All the functionality related to the browser''s local storage
    that is implemented in this sub-module, such as storing, reading, and deleting
    objects in local storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Utilities`: This module provides helper methods to the application, such as
    methods to combine two objects, to see if an object is an array, to load files
    from the server, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component registration with MainCore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every component of our application is registered with MainCore module. This
    allows to create the bridge between the component and the application, by using
    an instance of `SandBox` module.. We will talk about the `SandBox` module shortly
    but let's have a look at how the registration of the components takes place in
    the application (in the MainCore module).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Component registration with MainCore](img/B04910_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the following implementation in MainCore module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when this method is called at a component''s load time by the
    component, three parameters are passed into MainCore''s `mainCore.registerComponent`
    method: `containerID`, `componentID`, and `createFunc`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`containerID` parameter is passed to this method to tell the application what
    container (HTML element) the component''s view needs to be rendered in. `componentID`
    is the ID of the component that gets registered with the application and `createFunc`
    is the callback function on the component, which `mainCore.registerComponent`
    method calls to create an instance of the component.'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about how components are instantiated in more depth, later in this
    chapter. But for now, let's have a look at this mechanism from MainCore module's
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In the above method, we first walk the DOM tree to find the container element
    for the component's view, either by using jQuery or the DOM API directly.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check to see if the required `createFunc` parameter has been passed
    in, and whether it is a function. If so, we call this component's function with
    an instance of `SandBox` module (using dependency injection). Remember that every
    component gets a different instance of `SandBox` module, which is the bridge between
    the component and the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the component is designed properly, the result of this function call is an
    instance of the component which is returned and stored in `componentObj` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also a couple of required methods that we need to make sure exist
    on the component''s instance: `init` and `destroy` methods. Notice that MainCore
    is not concerned with how such methods are implemented in the component or what
    they do, only that they exist. The internal implementation of such methods and
    what they do are the responsibility of the component itself and each component
    may implement these methods differently. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the registration phase, each component is pushed to `registeredComponents`
    array, which is a collection of all the registered components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this array of components to do a few different things in the application.
    For instance, when the application is starting up, we loop through all the components
    in this array and call `init` method on each one of them. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method of MainCore module is called in `index.html` file, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After `init` methods of all the components have been called by the application
    in the start-up phase, we will see the following messages displayed in the console,
    if the application is in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Component registration with MainCore](img/B04910_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic loading of components by MainCore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may recall, I mentioned previously that application components can be
    loaded at a later time than the application's start-up. MainCore module provides
    the hooks and implements the functionality needed to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: I think it might be a good idea to go back to the previous chapter and have
    a look at the flow diagram which depicts this mechanism before continuing with
    the explanations to follow, just so you can refresh your memory.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, when the user clicks on the **Support** link provided in
    the footer section, a dialogue box is displayed. This dialogue box provides information
    regarding where the images of our application have been taken from and whether
    the user would like to visit that site.
  prefs: []
  type: TYPE_NORMAL
- en: This widget component (`notificationWidget`), is not loaded in `index.html`
    page when the application is initially started up; it is only loaded when the
    user clicks on the **Support** link.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the widget has been previously loaded in the application (if the
    user had clicked on the **Support** link before), we will simply re-render it
    on the page. This is because after the first time this component is loaded, it
    will be kept in cache, even after the user closes the dialogue box by clicking
    on its **Close** button.
  prefs: []
  type: TYPE_NORMAL
- en: '`NotificationHandler` sub-module is responsible for listening and acting on
    the click event of the **Support** link. This is done by using a publish-subscribe
    mechanism (pattern), which we will discuss shortly in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is the callback function for the **Support** link click event in
    `NotificationHandler` sub-module. The very first thing that this method does is
    to ask the application (MainCore module specifically) whether this component (widget)
    has been previously loaded and registered with the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If so, this methods calls `NotificationHandler.renderWidget` (`self.renderWidget`)
    function, which in turn calls `renderWidget` method on the widget component itself.
    Note that the widget is responsible for its own rendering, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the widget has not been loaded previously, the method asks the MainCore module
    to load the widget first, and then call `NotificationHandler.renderWidget` function,
    which is the callback function that is passed in as `self.renderWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This call is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now the control is given to MainCore module to load the component (widget) dynamically.
    This is done by first finding the object definition for the component in the browser's
    local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first have a look at how the local storage is populated with the components'
    object definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Storing object definitions in local storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The application has been designed to find the object definitions for all the
    dynamically loaded components, in the browser's local storage.
  prefs: []
  type: TYPE_NORMAL
- en: However, these definitions are in fact implemented in `PageDefinitions.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `PageDefinitions.js` file is loaded, it uses an IIFE to store its
    object definitions in the browser''s local storage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After the browser's local storage is populated with the object definitions,
    the file is removed from the browser's cache as it can potentially be large and
    consume a significant amount of memory. This design allows us to minimize the
    use of the browser's cache, which could be of particular interest on mobile devices,
    where resources are limited.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the object definition for `notificationWidget`. On this object, `ScriptFile`
    property holds the name of the `.js` file for this component and `ScriptPath`
    property stores the path to this file. MainCore module uses this information to
    find and load the component from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a component's object definition from local storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how the local storage is populated with the object definitions,
    we can look at how MainCore module gets the `notificationWidget` object definition
    from the local storage and loads the related resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, first the local storage in the browser is checked (using the
    `StorageHandler` sub-module behind the scenes) for the object definition of the
    component. If it is found, then this method calls another method to dynamically
    load the necessary resources for the component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically loading component's resources from the server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once a component''s object definition has been extracted from the local storage,
    its required `.js` and `.css` files are loaded from the server using the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method calls other methods which specialize in loading
    `.js` or `.css` files, as the mechanism for loading the files into the application
    is different, based on the file type. Of course the `.js` file is where the code
    for the component resides and the `.css` file has the styling-related information
    for the component.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the callback function is called **asynchronously** after the
    files are loaded into the browser's cache.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that MainCore module uses `Utilities` sub-module (behind the scenes)
    to take care of the mechanics of requesting and loading the component files from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic loading of components is probably the most involved operation in
    the application and it can be a little challenging to fully understand it by just
    reading this section. I highly recommend that you download the application's code
    and put breakpoints in the methods that I have mentioned in this section when
    you run the application. Doing so, will help you to fully realize how the flow
    of loading components dynamically is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: After a component is dynamically loaded into the application, it still needs
    to register itself with MainCore module. We will talk about this process more
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Routing functionality in MainCore module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As our application is a single page application, and its view needs to change
    based on the user's interaction, we need to implement the client-side routing
    functionality. This also means that we need to incorporate page view changes based
    on the user clicking on the back and forward buttons of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, I have used the HTML5 History API as the basis for our client-side
    routing, but we could have also used open source libraries such as `History.js`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how routing functionality has been implemented in MainCore module.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a URL to the history object of the browser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called when the application needs to create an entry in the
    history object of the browser. For instance, when the **Home** link of the header
    section is clicked, the following callback function is called in the header component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the callback function calls `addToHistory` API of its `SandBox`
    instance with an anonymous object. The `SandBox` instance, in turn, calls `addToHistory`
    method of MainCore module. The anonymous object is passed to this method and then
    the browser''s history object is updated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are three parameters which are passed to `pushState` API of the history
    object. These parameters are; `State` object, `Title`, and `URL`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding example, the following object will be passed to this API as
    the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use `url` property of the same object for the other parameters
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding the browser''s history API, you can refer to
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a URL from the history object of the browser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To get URL entries from the browser''s History object, we first bind `popstate`
    event of the browser to MainCore''s `getFromHistory` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that every time the browser''s `pop` event takes place, which is
    when the user clicks on the back or forward button of the browser, the following
    method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The main action taken by this method is to call `handlePageChange` method of
    MainCore module. This method, in turn, publishes a `page-Changed` event in the
    application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When this event is published, all the modules that have registered for this
    event are notified. The modules can then take action based on the published event.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `content` component has bound `updateContentPage` method to this
    event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To better understand how this process works, we also need to talk about custom
    events and publish-subscribe (observer) pattern implementation in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Publish-subscribe implementation in MainCore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously mentioned, one of the goals of our application design has been
    to create loose coupling among the application modules.
  prefs: []
  type: TYPE_NORMAL
- en: We have also talked about the fact that while our application modules are not
    aware of each other, they need to be able to communicate with one another in an
    indirect manner.
  prefs: []
  type: TYPE_NORMAL
- en: These goals can be achieved by leveraging the **Mediator** design pattern and
    implementing a publish-subscribe mechanism around that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, in Mediator pattern pieces of the application
    do not directly register with each other for custom events. Instead, they register
    for these events and are notified of the broadcast of such events through an intermediary
    piece. In our application, the intermediary piece is our MainCore module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not familiar with mediator or publish-subscribe patterns, I highly
    recommend reading, *Mastering JavaScript Design Patterns* by *Simon Timms*, which
    discusses many popular patterns as well as mediator pattern. You can find this
    book at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Registering components for custom events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following method in MainCore module is used for registering components
    to receive custom events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method registers the custom event object passed to it with
    the ID of the component, which needs to be notified when the event is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `content` component registers for the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When any one of the preceding events is published, the bound event handler method
    for that event is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the code above, no component ID is passed to the `SandBox` module
    instance by the component. However, the `SandBox` module instance associated with
    this component sends the required component ID to MainCore module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about how the `SandBox` instance is aware of the component ID,
    when we talk about `SandBox` module later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting custom events by components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When components need to publish custom events in the application, they do so
    by using `publishCustomEvent` method in MainCore module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an event object is passed to this method. The method loops through
    all the components which have registered for this event and then calls the associated
    event handler on the components for the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Components can publish their events using their instance of `SandBox` module.
    For example, the `header` component of the application broadcasts that the Favorites
    link in the application has been clicked, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since the `content` component has registered for this event, the method `updateContentPage`
    of the `content` component is subsequently called.
  prefs: []
  type: TYPE_NORMAL
- en: To sum things up, application components publish custom events, then the components
    that have registered for these custom events are notified by MainCore module,
    which calls the associated methods for these custom events. Thus, MainCore module
    acts as the mediator piece among all the components of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion and examination of the core module, but keep in
    mind that the core module as a whole provides many more capabilities for the application,
    beyond what we have discussed here. All such functionality is either implemented
    in MainCore module (`MainCore.js`) or other sub-modules which together, make up
    the core module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that from the component's point of view, all the application functionality
    is provided by an instance of `SandBox` module.
  prefs: []
  type: TYPE_NORMAL
- en: SandBox module implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, the components in our application do not directly communicate
    with each other nor do they communicate directly with any other parts of the application.
    The only connection between the components and the rest of the application is
    through an instance of `SandBox` module assigned to them.
  prefs: []
  type: TYPE_NORMAL
- en: SandBox module's constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding code shows, `SandBox` module is created as a global object
    `SandBox`, and three parameters are passed to its constructor by MainCore module.
    `Core` parameter, which is a reference to MainCore module; `contextElem` parameter,
    which is a reference to the container element for the component's view that the
    `SandBox` instance belongs to; and `componentSelector` , which is the ID of the
    sandbox's component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `SandBox` instance of `header` component, receives the following
    parameters when it is instantiated: A reference to the core module as the first
    parameter, `headerContainer` which is the ID of `header` component''s view container
    on the page as the second parameter, and `header` which is the ID of `header`
    component as the third parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The reference to Core module is used by the `SandBox` module instance to get
    access to the functionality that Core module provides.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a component's container context in the SandBox instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference to the container element of the component's view is used by the
    `SandBox` module instance to set the DOM context of the component's HTML elements.
    This is so when an HTML element within this container needs to be accessed, the
    search for this element can start from the container element, as opposed to the
    `document` element of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here the `SandBox` module instance is calling the core module's `getChildOfParentByID`
    method. This method takes two parameters, `containerElemContext`, and `elementID`.
    The objective is to search the DOM tree for the element whose ID has been passed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Using the container element's `DOM` Context, we can start the search in the
    container of the component as opposed to the top-level element of the DOM tree.
    This approach allows us to have a much more optimized search for finding our component's
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the SandBox module's instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The component ID, which is passed in as the third parameter to `SandBox` module's
    constructor, identifies the instance of `SandBox` module. This is used by the
    core module, to identify which component the `SandBox` instance belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the component''s ID is used in the following method of `SandBox`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet above, we are calling `unregisterCustomEvent` method of
    Core module and are passing in the parameter `componentID`. This is so core module
    knows which instance of `SandBox` is making this call and in turn, which component
    wishes to unsubscribe from the custom event.
  prefs: []
  type: TYPE_NORMAL
- en: SandBox module considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are also a couple of other things that you need to keep mind about `SandBox`
    module. First, `SandBox` module can be designed to only provide a subset of Core
    module's functionality to the components. This enables us to control what application
    functionality components can have access to. Second, all the methods of `SandBox`
    module are designed to do a very basic error checking. This filter calls which
    that have passed the basic level of validation to propagate to Core module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that `SandBox` module is supposed to be only a thin layer which
    sits between the components and the rest of the application. Thus, it is best
    to not do extensive validation at `SandBox` module level.
  prefs: []
  type: TYPE_NORMAL
- en: What constitutes a thin layer is open to interpretations, but since there could
    potentially be many instances of `SandBox` module in the application, it is best
    to keep it as thin as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that our application is a **proof of concept** type application,
    we have only implemented four components; `header`, `footer`, `content`, and `notificationWidget`
    (I'm using the component IDs used in the application).
  prefs: []
  type: TYPE_NORMAL
- en: These components are implemented in the following files in the application's
    project, `ImagesInc_Header.js`, `ImagesInc_Footer.js`, `ImagesInc_Content.js`,
    and `NotificationWidget.js`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I will provide an overview of each component, but
    I highly recommend that you have a look at the code accompanying this book to
    get a better understanding of how these components are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that our components are modules, which create different application
    views. In an MVC or MV* architectural pattern paradigm, our components contain
    their own controllers as well as leveraging the application level controller which
    has been provided to them through their own instance of `SandBox` module.
  prefs: []
  type: TYPE_NORMAL
- en: The components also implement their own views and each component is only aware
    of its view in the application.
  prefs: []
  type: TYPE_NORMAL
- en: While an application level model is present (`ImagesInc_GlobalData`), and our
    components can use the data stored in this application model, each component can
    also contain its own model. Therefore, each component implements its own MVC or
    MV* architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Registering components with MainCore module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already talked about how a component is registered with MainCore module
    from the MainCore's perspective. It is time to have a look at how this is done
    at the component's level.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism for registering components with the application is always the
    same, regardless of whether the component is loaded at the application start-up
    phase or at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when a component's `.js` file is loaded, for instance `notificationWidget`
    shown previously, `registerComponent` method of MainCore module is called. Thus,
    MainCore module needs to be loaded before any component files in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have talked about how this method is called by a component previously,
    the following should be just a review for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, when `NotificationWidget.js` file is loaded, the `registerComponent`
    method of MainCore module is called with three parameters: `mainPageContainer`,
    which is the ID of the container element that hosts the component''s view; `notificationWidget`,
    which is the ID of the component itself, and a third parameter as a `callback`
    function. When this `callback` function is called by MainCore module, it receives
    an instance of `SandBox` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the return object from this callback function is the component's singleton
    object, which has the required methods `init` and `destroy`. Of course, these
    methods are used by the application to initialize and destroy the component instance,
    respectively. We will talk about these methods more when we talk about `notificationWidget`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to notice here is that we have created a closure in this callback
    function, so only the returned object from this function has access to the private
    variables of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Header component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component registers itself with Core module using the ID `header`, and
    from that point forward, this ID is used by the application to reference this
    component.
  prefs: []
  type: TYPE_NORMAL
- en: As with all the other components in the application, this component implements
    the required `init` and `destroy` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`header` component also implements methods to attach and remove event handlers,
    for its elements. The method `handleFavouritesClick` is an example of an event
    handler in this component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation of this event handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when the **Favorites** link of `header` component is clicked.
    It first checks to see if there are any favorite images stored in the browser's
    cookie. However, this check is not done directly by the component itself, as the
    call is made to the instance of `SandBox` module for this component.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `header` component has no idea how the mechanism for checking the
    cookie is implemented, and it does not need to implement such functionality itself.
  prefs: []
  type: TYPE_NORMAL
- en: If such mechanism is changed at some point in the future, it makes no difference
    to this component. The component will always make the same call to the `SandBox`
    module instance and lets the application handle this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this method updates the URL in the browser, and publishes a custom
    event that informs the application of the particular event that has taken place.
    Of course, the component leverages the application's functionality through the
    `SandBox` module instance to accomplish all these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Footer component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The design of `footer` component is very similar to `header` component, and
    it registers itself with Core module with the ID of `footer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One method in the component which we need to have a look at is `hanldeSupportClick`.
    This method is called when the **Support** link of `footer` component is clicked.
    Let''s examine the implementation of this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when the link is clicked, the custom event `support-Clicked`
    is published. If you recall from an earlier section in this chapter, `NotificationHandler`
    module is listening to this event and will take the required action when this
    event takes place.
  prefs: []
  type: TYPE_NORMAL
- en: This is another example which shows, while these pieces of the application are
    communicating with each other, they are not actually aware of each other's existence.
    These components are loosely coupled using our publish-subscribe implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Content component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component can be considered as the main component of our application and
    it is responsible for changing the views of the content area. It registers itself
    with Core module with the ID of `content`.
  prefs: []
  type: TYPE_NORMAL
- en: The content component implements the required `init` and `destroy` methods as
    well as many other methods.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to have a look at some of the important ones here.
  prefs: []
  type: TYPE_NORMAL
- en: Handling content area click events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user clicks on the **Add to Favorites** link in the application or when
    an image is clicked in the content area, the parent container of the `content`
    component's view captures the event and processes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding for the event handling of the parent container takes place in `init`
    method of `content` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `handleMainContainerClicked` is the callback method that processes
    this click event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how this method has been implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown, we check to see if the click event is taking place on an image or
    on an anchor tag, and based on this determination, we delegate the rest of the
    event processing to the associated methods.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Add To Favorite link click event
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In `handelFavLinkClick` method, we check the state of the **Add to Favorites**
    link and change its text to **Remove from Favorites**. If the link has already
    been clicked, and it contains the text **Remove from Favorites**, we re-set the
    text to its default value of **Add to Favorites**.
  prefs: []
  type: TYPE_NORMAL
- en: We also add or remove the ID of the favorite image in the browser's cookie,
    so when the user navigates to the **Favorites** page, the correct favorite images
    are rendered in the content area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is also one other thing that we do in this method, which
    is to broadcast the related custom event to the application. This allows all the
    other pieces of the application which are registered for this event to be informed
    of the event taking place in this component.
  prefs: []
  type: TYPE_NORMAL
- en: Handling an image click event
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When an image is clicked in the content area of the application, the following
    method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this method does two main things. One is to update the history object
    of the browser so that the application router can work properly when the user
    clicks on the back and forward buttons of the browser. The second is to broadcast
    the message `img-Clicked` to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting point to consider is that our `content` component itself listens
    to this event and acts on this event to update the page view, using the following
    event registration method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when `img-Clicked` event is received by `content` component
    (which itself had generated), then `updateContentPage` method of this component
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could have directly updated the view of the page in `handleImageClick`
    method, but by broadcasting the event at the application level, we can be sure
    that all the pieces of the application, including `content` component itself,
    can take action upon the broadcast of this event.
  prefs: []
  type: TYPE_NORMAL
- en: Content area generator methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`content` component also has methods which are responsible for generating the
    content area of the page, based on the URL of the browser. The following is a
    summary of such methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buildFavouritesPage`: This method loads the related CSS file for the Favorites
    page (using the `SandBox` module instance) and then renders this page based on
    the number of the favorite images previously selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildIndexContentHTML`: As the name implies, this method is responsible for
    building HTML tags for the content area of `index.html` page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildImagePageHTML`: The full view of the clicked image is rendered using
    this method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAnchorHTMLStr`: This method generates the related link for each image so
    the image can be added or removed from the favorite images list, based on the
    state of the link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend that you have a look at the code for this component to see
    how these methods are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: NotificationWidget component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When this component is loaded, it registers itself as `notificationWidget` with
    core module.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about this component previously and while its design is similar to
    all the other components in the application, there are some differences.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, this component is not loaded or rendered at the application's
    start-up phase. It is loaded and rendered dynamically only when needed, based
    on the user's interaction with the application.
  prefs: []
  type: TYPE_NORMAL
- en: NotificationWidget's model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component''s view is stored as a string in the component itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This string is passed by the component to MainCore module to render its view.
    You will see how this is done very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Required methods of the notificationWidget component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, each component needs to implement the required methods:
    `init` and `destroy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following `init` method of `notificationWidget` component
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When the application calls `init` method of a component, in this case `notificationWidget`,
    a new property is added to the instance of `SandBox` module that was passed to
    the component. This property is `contextObj` and its value is set to `this`.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `this` is a reference to the component itself and is assigned
    to the `SandBox` instance so we can have an easy way to access the context of
    the component when we need to. This property is particularly useful for our event
    handler callbacks in the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet from `notificationWidget` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This callback function is called when the user clicks on the **Close** button
    of the dialogue box which is the view for `notificationWidget` component. You
    might wonder why we are not calling the component''s internal method from the
    callback function as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For the above function call to succeed, the callback function needs to run in
    the context of the component. However, since the context of `this` is set at the
    time of code execution to the object that calls this callback function, and not
    the component, we are not be able to call the component's internal methods using
    `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, by setting the property `contextObj` on the `SandBox` instance, we are
    able to easily access the original context of the component and call the required
    internal method as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we could also use JavaScript's `bind()` method to achieve the same
    context preservation but I have used this approach instead, so you can see a different
    way of resolving this issue.
  prefs: []
  type: TYPE_NORMAL
- en: The `destroy` method of the component is used to make it inactive (no events
    on the component will be processed) or to completely remove the component from
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider destroy method implementation of `notificationWidget`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the value of `removeComponent` flag(`true` or `false`), which is
    passed to this method, the component is either disabled or completely removed
    from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the above code, the component uses its instance of `SandBox` module
    to remove itself from the DOM and it does not need to implement such functionality
    itself. This allows the component to only focus on its own specialized tasks and
    leverage the functionality provided by the application (through the `SandBox`
    instance). This design also limits the component's access to the world beyond
    its own so we can minimize possible DOM manipulation conflicts, as described in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering notificationWidget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This component is rendered when `NotificationHandler` calls the render method
    of the component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the implementation of this method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The component uses a method on its instance of `SandBox` module to create a
    document level component (itself), in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In turn, from the `SandBox` module instance, the following method on Core module
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And a reference to the rendered component''s view is passed back from Core
    module to `renderWidget` method of the component object. The rendered component''s
    view is then tagged with an ID and its context is set on the `SandBox` module
    instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is only at this stage that the component registers for events.
    This is different than other components in the application, which register for
    events when they are initialized. The reason is because when `init` method of
    this component is called, the component's view has not yet been rendered on the
    page. Therefore, there are no HTML elements for this component's view to attach
    events to. It is only after the rendering of the component's view that we can
    attach the required event handlers to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: This widget is an example of how we can render and activate components in the
    application at any time, after the start-up phase.
  prefs: []
  type: TYPE_NORMAL
- en: GlobalData module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name implies, this module is designed to store application level data
    and act as the model for our application. It also provides public methods so that
    other modules can get and set data in this module. This module is defined as `ImagesInc_GlobalData`
    global variable in the application..
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a snippet of the kind of data that the module stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This module is augmented with a sub-module `ImagesInc_PageSections`, which stores
    HTML markup strings related to `header` and `footer` components.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth looking at how this sub-module is added to `GlobalData` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using asynchronous sub-module augmentation technique
    to add the sub-module to `GlobalData` module.
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows us to load `GlobalData` and its related sub-module (`ImagesInc_PageSections`)
    in any order that we desire without affecting the module's augmentation. The augmentation
    is different in comparison to how we added sub-modules to MainCore module in the
    application, as they could only be added to MainCore module after it was loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we create the sub-module if it does not exist in the application
    when we execute the IIFE, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Asynchronous sub-module augmentation also allows us to augment the sub-module
    itself, if it already exists in the application. The augmentation is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, this technique is a little more complex than the other augmentation
    techniques that we have used elsewhere in the application but it does provide
    a greater degree of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to have a look at the code related to this sub-module (`GlobalData_Sub.js`)
    to get a better understanding of how the technique works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a closer look at our application's implementation and
    saw how all the pieces fit and work together to create our modular ecosystem,
    at the code level.
  prefs: []
  type: TYPE_NORMAL
- en: We examined how Core module (our application's controller) was created by leveraging
    different augmentation techniques and adding sub-modules to MainCore module. This
    approach allowed us to extend our application's capabilities with ease and in
    a modular way.
  prefs: []
  type: TYPE_NORMAL
- en: By creating instances of `SandBox` module, we established communication bridges
    among the components and the rest of the application while preserving the loose
    coupling principle of our design.
  prefs: []
  type: TYPE_NORMAL
- en: One important aspect of our application, is the ability to load components dynamically
    and we discussed how such functionality has been implemented in our Core module.
  prefs: []
  type: TYPE_NORMAL
- en: Using the publish-subscribe and mediator patterns, we created an event handing
    mechanism which all the pieces of the application can use to communicate with
    each other. This mechanism was also used in our client side router to change the
    views of the application.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we created a global module to store our application
    level data and act as the model piece of our MV* design.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss testing of our application's modules and
    will see how unit testing can help us maintain the integrity of our application
    during its development and operational phases.
  prefs: []
  type: TYPE_NORMAL
