- en: Chapter 8. Application Implementation – Putting It All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 应用实现 – 整合所有内容
- en: After discussing the architectural concepts of our modular design in the previous
    chapter, it is time for us to look at the actual implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论了我们的模块化设计的架构概念之后，现在是时候看看实际的实现了。
- en: The goal of this chapter is to examine the code and see how all the pieces fit
    and work together in a real application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是检查代码，看看所有部分如何在真实的应用程序中相互配合并工作。
- en: While we will not discuss every aspect of the code, each main piece will be
    broken down into smaller pieces, and most of the details will be explained.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会讨论代码的每个方面，但每个主要部分将被分解成更小的部分，大部分细节都将进行解释。
- en: I highly recommend that you download the project code related to this chapter
    from the site accompanying this book and follow along as we go through the finer
    points of the code. I am using different techniques at different parts of the
    code, which at first glance, might look inconsistent. However, this is done intentionally
    so that you can see how different techniques can be applied as needed, in different
    contexts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您从本书附带的网站上下载与本章相关的项目代码，并随着我们逐步分析代码的细节来跟进。我在代码的不同部分使用了不同的技术，乍一看可能看起来不一致。然而，这是有意为之，以便您可以看到在不同情境下如何根据需要应用不同的技术。
- en: Also, keep in mind that many aspects of the application can be improved upon
    as the focus has been on creating a **Proof Of Concept** (**POC**) application
    as opposed to production quality code. You will see how our modular approach allows
    us to create an easily maintainable, extensible, and robust application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，由于重点在于创建一个**概念验证**（**POC**）应用程序，而不是生产质量的代码，因此应用程序的许多方面都可以进行改进。您将看到我们的模块化方法如何使我们能够创建一个易于维护、可扩展且健壮的应用程序。
- en: 'In this chapter, we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Look at the main modules in the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看应用程序的主要模块
- en: Examine how components in the application have been constructed
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序中的组件是如何构建的
- en: Discuss the overall architecture of the application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论应用程序的整体架构
- en: Look at our publish-subscribe implementation, which provides loose coupling
    among our modules and components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们的发布-订阅实现，它为我们的模块和组件提供了松散耦合
- en: Implement a simple client-side router
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的客户端路由器
- en: But before examining the implementation, let's have a look at the final view
    of our application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但在检查实现之前，让我们先看看我们应用程序的最终视图。
- en: The user's view of our application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户对应用程序的视图
- en: If you load `index.html` file of our project using an IDE which has a built-in
    web server, you will see the following main page in the browser. This file resides
    at the root of the application folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用具有内置Web服务器的IDE加载我们的项目中的`index.html`文件，您将在浏览器中看到以下主页面。此文件位于应用程序文件夹的根目录下。
- en: '![The user''s view of our application](img/B04910_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用程序的用户视图](img/B04910_08_01.jpg)'
- en: As you may have noticed, I have made improvements to the look and feel of the
    application, in comparison to what we had in the previous chapters. I have also
    done some re-factoring of the code in the project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，与之前章节中的内容相比，我对应用程序的外观和感觉进行了改进。我还对项目中的代码进行了一些重构。
- en: 'I mentioned previously that our application is somewhat responsive based on
    the browser''s view-port. The following screenshot shows the application''s `index.html`
    page in the Chrome Developer Tools emulator (*Ctrl* + *Shift* + *M* in Windows),
    simulating its rendering in an Apple iPad:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，我们的应用程序在一定程度上是基于浏览器的视口进行响应式的。以下截图显示了Chrome开发者工具模拟器中应用程序的`index.html`页面（在Windows中为*Ctrl*
    + *Shift* + *M*），模拟其在Apple iPad上的渲染：
- en: '![The user''s view of our application](img/B04910_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用程序的用户视图](img/B04910_08_02.jpg)'
- en: Application functionality
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用功能
- en: As you may recall, our application was intended to be an image gallery-type
    application which displays a list of images. Users are able to interact with the
    application in a variety of different ways. While the application might seem very
    simple from a user's point of view, it is designed from the ground up, to be easily
    extensible, so more functionality can be added to it as needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，我们的应用程序旨在成为一个图像画廊类型的应用程序，显示图像列表。用户能够以各种不同的方式与应用程序进行交互。虽然从用户的角度来看，应用程序可能看起来非常简单，但它从头开始设计，易于扩展，因此可以根据需要添加更多功能。
- en: Let's consider the various aspects of our application's functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们应用程序功能的各种方面。
- en: Index page
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引页
- en: 'The main page of the application (`index.html`) consists of three main components:
    `header`, `footer`, and `content`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主页（`index.html`）由三个主要组件组成：`header`、`footer`和`content`。
- en: These components build the header, footer, and content sections (page fragments)
    of the main page respectively, as shown in the previous screenshot.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件分别构建了主页的页眉、页脚和内容部分（页面片段），如前一个屏幕截图所示。
- en: Since we designed our application as a **Single Page Application** (**SPA**),
    navigation to different pages of the application only updates the view of the
    content area.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将应用程序设计为**单页应用程序**（SPA），因此导航到应用程序的不同页面只会更新内容区域的视图。
- en: The footer and header sections of the application are rendered only once, and
    that is at the initial load time of `index.html`. The main advantage of our SPA
    design is that there is no need to fully re-render the page every time different
    pages are viewed. Therefore, there is no flickering of the page in the browser.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的页眉和页脚部分只渲染一次，即在`index.html`的初始加载时。我们SPA设计的最大优点是，每次查看不同页面时，无需完全重新渲染页面。因此，在浏览器中不会有页面闪烁。
- en: In the main page, users are able to see the full catalog of all the images available.
    By clicking on an image, the user can see its full-size. Images can also be added
    to, or removed from, the list of favorite images when the user clicks on the related
    link below each image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页中，用户可以看到所有可用图像的完整目录。通过点击图像，用户可以看到其全尺寸。当用户点击每张图像下方的相关链接时，还可以将图像添加到或从收藏图像列表中删除。
- en: Users are able to interact with the header and footer of the application too,
    even though, for our POC, not all the links in the footer and header are activated.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以与应用程序的页眉和页脚进行交互，尽管在我们的原型中，页眉和页脚中的所有链接并未全部激活。
- en: Image page
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像页面
- en: 'When a user clicks on an image, the view of the content area of the application
    is changed to show the image in full view, as shown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击图像时，应用程序内容区域的视图会改变，以显示全图，如下所示：
- en: '![Image page](img/B04910_08_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图像页面](img/B04910_08_03.jpg)'
- en: 'If you look at the address bar of the browser, the URL of the page changes
    when an image is clicked to reflect the ID of the image. For the preceding image,
    the URL of the page will be similar to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看浏览器的地址栏，当点击图像时，页面的URL会改变以反映图像的ID。对于前面的图像，页面的URL将类似于：
- en: '`http://127.0.0.1:49202/Image_9.jpg`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:49202/Image_9.jpg`'
- en: This is the URL of your local server along with the image ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您本地服务器的URL以及图像ID。
- en: Favorites page
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收藏页面
- en: 'In the main page of our application, a user can click on the link at the bottom
    of each image to add the image to the list of his/her favorite images, as shown:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的主页中，用户可以点击每张图像底部的链接，将图像添加到其收藏图像列表中，如下所示：
- en: '![Favorites page](img/B04910_08_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![收藏页面](img/B04910_08_04.jpg)'
- en: Once **Add to Favorites** link has been clicked, the text of the link changes
    to **Remove from Favorites**, which enables the user to remove the image from
    the list of favorite images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击**添加到收藏**链接，链接的文本将更改为**从收藏中删除**，使用户能够从收藏图像列表中删除图像。
- en: 'Users can also view all of their favorite images by clicking the **Favorites**
    link in the header section of the page; which takes the user to the **Favorites**
    page of the application, as displayed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以通过点击页眉部分的**收藏**链接查看所有收藏的图像；这将用户带到应用程序的**收藏**页面，如下所示：
- en: '![Favorites page](img/B04910_08_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![收藏页面](img/B04910_08_05.jpg)'
- en: Support widget
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持小部件
- en: When a user clicks on the **Support** link in the footer section of the application,
    a dialog box will be displayed with information regarding the site's catalog.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击应用程序页脚部分的**支持**链接时，将显示一个对话框，其中包含有关网站目录的信息。
- en: This widget (the dialogue box) has been designed to be dynamically loaded, and
    rendered on the page, but only when the **Support** link is clicked. This is an
    example of how components can be loaded and rendered dynamically in the application,
    as needed. This allows us to keep the weight of the application in the browser
    light and minimize its footprint.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件（对话框）已被设计为动态加载，并在页面上渲染，但仅在点击**支持**链接时。这是应用程序中组件如何按需动态加载和渲染的一个示例。这使我们能够保持浏览器中应用程序的重量轻，并最小化其占用空间。
- en: The design of this widget also demonstrates the concept of plug-and-play in
    respect to dynamic components in the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件的设计也展示了在应用程序中动态组件的即插即用概念。
- en: 'The following screenshot shows how this widget is displayed in the browser:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了该小部件在浏览器中的显示方式：
- en: '![Support widget](img/B04910_08_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![支持小部件](img/B04910_08_06.jpg)'
- en: Now that we have had a look at the appearance of the application, it is time
    to examine the mechanics of its implementation and see how things are done under-the-hood.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过应用程序的外观，是时候检查其实施的机制，看看幕后是如何操作的。
- en: Application implementation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序实现
- en: 'From the beginning, our intent in the design of our application was to create
    a modularized ecosystem in which different pieces of the code (modules) would
    be joined together to create a fully functional application. To that end, our
    code has been structured as displayed in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们在设计我们的应用程序时，意图创建一个模块化的生态系统，在这个生态系统中，不同的代码片段（模块）将被组合在一起，以创建一个功能齐全的应用程序。为此，我们的代码结构如下所示，具体请参考以下截图：
- en: '![Application implementation](img/B04910_08_07.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序实现](img/B04910_08_07.jpg)'
- en: 'As you can see, our application has been organized into three main folders:
    `css` which hosts all of our styling files, `Images` which stores all the images
    in the application''s catalog; and `js`, which contains all the JavaScript code
    for our application. As this structure is only one approach to organizing the
    application''s code, you may decide to organize the code differently.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序已组织成三个主要文件夹：`css`，它托管我们所有的样式文件；`Images`，它存储应用程序目录中的所有图像；以及`js`，它包含我们应用程序的所有JavaScript代码。由于这种结构只是组织应用程序代码的一种方法，您可能决定以不同的方式组织代码。
- en: Under `js` folder, we have organized our JavaScript files further into three
    main sub-folders; `Components` which contains the files related to modules that
    have views associated with them, `Modules` which contains our modules for the
    controller and Model of the application, and `Widgets` which hosts files related
    to components that are loaded and rendered dynamically in our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`js`文件夹下，我们将我们的JavaScript文件进一步组织成三个主要子文件夹；`Components`包含与具有视图关联的模块相关的文件，`Modules`包含我们应用程序的控制器和模型模块，而`Widgets`托管与在应用程序中动态加载和渲染的组件相关的文件。
- en: Our `Modules` folder is further broken down into five sub-folders; `Base` which
    contains our third-party dependencies and the base module, `Core` which hosts
    the controller's code (modules) for our application, and `GlobalData` which holds
    our application's model files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Modules`文件夹进一步细分为五个子文件夹；`Base`包含我们的第三方依赖和基础模块，`Core`托管我们应用程序的控制器代码（模块），而`GlobalData`包含我们应用程序的模型文件。
- en: The other two sub-folders, `SandBox` and `PageDefinitions` contain the sandbox
    module and object definitions file for our dynamically loading components, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个子文件夹`SandBox`和`PageDefinitions`分别包含用于动态加载组件的沙盒模块和对象定义文件。
- en: We will examine the code in most of the files of our sub-folders in the following
    sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将检查我们子文件夹中的大多数文件中的代码。
- en: Loading our module files in index.html
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`index.html`中加载我们的模块文件
- en: Before we start looking at our JavaScript code and modules, let's have a closer
    look at `index.html` file and see how the application modules are loaded in the
    browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看我们的JavaScript代码和模块之前，让我们更仔细地看看`index.html`文件，看看应用程序模块是如何在浏览器中加载的。
- en: Our `index.html` page is designed in such a way that it only provides the bare
    minimum skeleton for our application's main page, and all the other pieces (header,
    footer, and content) are built dynamically when the page is loaded.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`页面设计得只提供应用程序主页的最基本骨架，而所有其他部分（页眉、页脚和内容）在页面加载时动态构建。
- en: Generally speaking, there are instances when it makes more sense to build some
    of the pieces of the application's pages on the server before sending them to
    the client, since this implementation could provide better performance at times.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，在某些情况下，在将页面的一部分发送到客户端之前在服务器上构建应用程序页面的某些部分更有意义，因为这种实现有时可以提供更好的性能。
- en: In our approach here, we are building all the pieces of our application's pages
    on the client. This is so we can examine and apply different concepts of our application's
    design a little easier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中，我们正在客户端构建我们应用程序页面的所有部分。这样做是为了我们可以更容易地检查和应用我们应用程序设计中的不同概念。
- en: 'The skeleton of our `index.html` file consists of three main containers, as
    follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`文件的骨架由三个主要容器组成，如下所示：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have our header container, which hosts the `header` component
    of our application, the main container, which hosts the `content` component of
    our application and a `div`, which is the container for our `footer` component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: These are the pieces (containers) in our `index.html` page which are passed
    to our components so they can render themselves inside of them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Just before the closing tag for the page''s body element, we have included
    the `<script>` tags which load the scripts for our application. Let''s have a
    look:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading our module files in index.html](img/B04910_08_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: As you can see, quite a few script files need to be loaded. We can improve on
    this by combining (and minifying) some of the files together, as well as using
    formats such as **Asynchronous Module Definition** (**AMD**) in conjunction with
    libraries like `Require.js` to load our files. For now however, for the sake of
    clarity, we leave things as they are.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Enterprise Grade Modular Design, AMD,
    CommonJS, and ES6 Modules"), *Enterprise Grade Modular Design, AMD, CommonJS,
    and ES6 Modules* of this book, we will discuss how we can use AMD format to combine
    and load our application's required files in a more optimized way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The following script has also been implemented in our `index.html` file, which
    is responsible for starting up the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading our module files in index.html](img/B04910_08_09.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: We will discuss how the start-up of the application takes place shortly. Notice
    that we initialize all the modules first, then the components, and at the end,
    we pass the URL of the page to `handlePageChange` method of `ImagesInc_Core` module.
    This is done, so we can use the URL of the page in our application's router, which
    will be examined in depth shortly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: I emphasize the point that as you are reading this chapter, you should probably
    load the related code into your IDE so you can easily follow along.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Base module implementation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start the exploration of our application's modules with the base module.
    Our `Base` folder hosts two JavaScript files; `Base.js` and `jquery-1.10.2.min.js`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`Base.js` file implements `ImagesInc_Base` module which is responsible for
    importing all of our third-party libraries into the application, as we discussed
    in the previous chapter. Currently, the only third-party library that we are importing
    is jQuery.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how this is implemented:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we are using an IIFE to return an object to the global variable
    `ImagesInc_Base`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we first check to see if a jQuery object has been defined
    in the global scope; if so, we return it. Otherwise, `null` is returned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Our core module will be using this object to leverage the jQuery library's functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in `MainCore` module as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As our `MainCore` module is initializing itself (using an IIFE), it asks the
    base module for its base library and then assigns a reference of the returned
    object in both the `$` and `mainCore.jQuery` properties of `MainCore` module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`MainCore`模块正在初始化自身（使用IIFE），它会向基础模块请求其基础库，然后将返回对象的引用分配给`MainCore`模块的`$`和`mainCore.jQuery`属性。
- en: Note that in the current implementation, we are only able to import one base
    library. This is to keep the implementation simple, as we only need jQuery in
    our application. However, we could also import and use a collection of libraries
    with some modification to this code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在当前实现中，我们只能导入一个基础库。这是为了保持实现简单，因为我们的应用程序只需要jQuery。然而，我们也可以通过修改此代码来导入并使用一系列库。
- en: Core module implementation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心模块实现
- en: The Core module is the heavy-lifter module in our application, and is constructed
    using a few sub-modules. This module's functionality has also been enhanced and
    augmented using the techniques that we discussed in the previous chapters, such
    as tight and loose augmentation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块是我们应用程序中的重量级模块，它由几个子模块构建。此模块的功能也通过我们在前几章讨论的技术得到了增强和增强，例如紧密和松散增强。
- en: 'Here is a list of all the sub-modules that make up the Core module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构成核心模块的所有子模块列表：
- en: '![Core module implementation](img/B04910_08_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![核心模块实现](img/B04910_08_10.jpg)'
- en: We will not cover all the related code for this module but we will have a look
    at the important parts of it in this section. Note that the Core module is also
    the controller of our application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖此模块的所有相关代码，但我们将在本节中查看其重要部分。请注意，核心模块也是我们应用程序的控制者。
- en: MainCore module implementation
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainCore模块实现
- en: This module provides the main functionality of the Core module and all the related
    Core's sub-modules are attached to this module, hence the name `MainCore.js`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了核心模块的主要功能，所有相关的核心子模块都附加到这个模块上，因此命名为`MainCore.js`。
- en: I'll be referring to this module as **MainCore** from this point forward.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我将把这个模块称为**MainCore**。
- en: 'This module has been defined as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块已经被定义为以下内容：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have used the loose augmentation technique in this module
    to enhance its functionality.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在这个模块中使用了松散增强技术来增强其功能。
- en: This module also uses an inner IIFE to initialize itself and to import our application's
    base library. When the application is in debug mode, MainCore will announce that
    it has been initialized as soon as it is loaded.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块还使用内部IIFE来初始化自身并导入我们的应用程序的基础库。当应用程序处于调试模式时，MainCore将在加载后立即宣布它已经初始化。
- en: 'This is shown in the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码片段所示：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To turn the debug mode on or off in the application, we have implemented the
    following method which can be called by the external code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中开启或关闭调试模式，我们已经实现了一个方法，外部代码可以调用此方法：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we are returning a reference to MainCore module as a global variable,
    `ImagesInc_Core`, which allows the external code to interact with this module,
    through the interface that this module provides.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们返回了MainCore模块的引用作为全局变量`ImagesInc_Core`，这允许外部代码通过该模块提供的接口与之交互。
- en: Augmenting MainCore module
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 增强MainCore模块
- en: In designing MainCore module, I have purposely used various augmentation techniques.
    This is done to demonstrate the practical aspects of such techniques in enchaining
    modules.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计MainCore模块时，我故意使用了各种增强技术。这样做是为了展示在模块链接中这些技术的实际应用方面。
- en: Augmenting MainCore using tight augmentation
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用紧密增强增强MainCore
- en: 'Consider the following augmentation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下增强：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have made a logical separation between the code that deals with event-related
    functionality in MainCore module and the rest of the code related to this module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在处理MainCore模块中与事件相关的功能代码和与此模块相关的其他代码之间进行了逻辑分离。
- en: Notice that we have passed a reference of MainCore module (known to the application
    as `ImagesInc_Core`) to the IIFE that implements this augmentation (using tight
    augmentation technique) and then we have added new properties to MainCore module
    as needed. At the end, the reference to the now augmented MainCore module is returned
    to `ImagesInc_Core`, which is the global variable that provides access to MainCore
    module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将 MainCore 模块（在应用程序中被称为 `ImagesInc_Core`）的引用传递给了实现此增强（使用紧密增强技术）的立即执行函数表达式（IIFE），然后根据需要向
    MainCore 模块添加了新的属性。最后，将现在增强后的 MainCore 模块的引用返回给 `ImagesInc_Core`，这是提供对 MainCore
    模块访问的全局变量。
- en: We use the same technique again in another part of the code to augment the module
    with more functionality. Please have a look at the related code in `MainCore.js`
    file of the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码的另一部分再次使用相同的技巧，以增加更多功能来增强模块。请查看应用程序 `MainCore.js` 文件中相关的代码。
- en: Augmenting MainCore using sub-modules
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用子模块增强 MainCore
- en: Let's look at an example of how we add sub-modules to MainCore module. To add
    enhanced logging functionality to the application, we have augmented MainCore
    module with a sub-module which specializes in logging messages for the application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将子模块添加到 MainCore 模块的示例。为了向应用程序添加增强的日志记录功能，我们通过一个专门为应用程序记录消息的子模块来增强 MainCore
    模块。
- en: 'The following code snippet shows how this sub-module is being used by MainCore
    module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了此子模块是如何被 MainCore 模块使用的：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this method, we first check to see if `LoggingHandler` object (the logging
    sub-module) exists and also if `logMessage` method on that object is implemented.
    If both conditions are met, then we pass on the logging message and its related
    information to this sub-module.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们首先检查 `LoggingHandler` 对象（日志子模块）是否存在，以及该对象上的 `logMessage` 方法是否实现。如果这两个条件都满足，则将日志消息及其相关信息传递给此子模块。
- en: On the other hand, if the logging sub-module or its required method do not exit,
    we use `mainCore` module's own simple logging mechanism to log messages in the
    browser's console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果日志子模块或其所需的方法不存在，我们使用 `mainCore` 模块自己的简单日志记录机制在浏览器控制台中记录消息。
- en: We should have a look at how `LoggingHandler` sub-module has been implemented
    and added to MainCore module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看看 `LoggingHandler` 子模块是如何实现并被添加到 MainCore 模块中的。
- en: 'Consider the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown, we have added a property to `ImagesInc_Core` object (MainCore module).
    An IIFE returns an object to this property (`LoggingHandler`) when it is executed.
    This object consists of two methods which provide all the functionality related
    to the logging mechanism of the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们向 `ImagesInc_Core` 对象（MainCore 模块）添加了一个属性。当执行时，立即执行函数表达式（IIFE）将一个对象返回到这个属性（`LoggingHandler`）。这个对象包含两个方法，提供了与应用程序日志记录机制相关的所有功能。
- en: While the implementation of these two methods is hidden away from the rest of
    the application, other pieces of the application can interact with this sub-module
    through MainCore module and the related interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个方法的实现被隐藏在应用程序的其他部分之外，但应用程序的其他部分可以通过 MainCore 模块和相关接口与这个子模块进行交互。
- en: Notice that this sub-module can easily be swapped for a different one or modified
    internally in any form that we desire. However, as long as the exposed interface
    does not change, all the external code would still be able to use this sub-module
    for its logging functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个子模块可以很容易地被替换为不同的子模块或以我们希望的形式进行内部修改。然而，只要暴露的接口不改变，所有外部代码仍然能够使用这个子模块进行日志记录功能。
- en: In fact, we can even remove this sub-module completely and it will not affect
    the application at all, except for the fact that the advanced logging mechanism
    for the application would be absent. This highlights some of the advantages of
    modular design in our application, such as **plug-and-play**, **progressive enhancement**,
    and **graceful degradation**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以完全移除此子模块，而这对应用程序没有任何影响，除了应用程序的高级日志记录机制将不存在。这突显了我们应用程序中模块化设计的一些优点，例如**即插即用**、**渐进增强**和**优雅降级**。
- en: In the same way, we can also add other sub-modules to MainCore module to provide
    more functionality without the need to make many changes in the application. This
    allows us to have a flexible and easily maintainable code base.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以向 MainCore 模块添加其他子模块，以提供更多功能，而无需在应用程序中进行许多更改。这使得我们能够拥有一个灵活且易于维护的代码库。
- en: 'In our application, there are also other sub-modules, which attach themselves
    to MainCore module, and provide added functionality to the application. We talked
    about these sub-modules in the previous chapter but I will mention them again
    here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，还有其他子模块，它们附加到MainCore模块，并为应用程序提供附加功能。我们在上一章中讨论了这些子模块，但我会再次提及它们：
- en: '`AjaxEngine`: This module is responsible for making AJAX calls to the server,
    using jQuery AJAX functionality.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AjaxEngine`: 该模块负责使用jQuery AJAX功能向服务器发出AJAX调用。'
- en: '`CookieHandler`: This module looks after all the cookie-related operations
    in the application, such as writing, reading, and deleting cookies in the browser.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieHandler`: 该模块负责应用程序中所有与cookie相关的操作，例如在浏览器中写入、读取和删除cookie。'
- en: '`NotificationHandler`: This module is responsible for displaying notifications
    to the users by leveraging a dialog box component.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotificationHandler`: 该模块负责通过利用对话框组件向用户显示通知。'
- en: '`StorageHanlder`: All the functionality related to the browser''s local storage
    that is implemented in this sub-module, such as storing, reading, and deleting
    objects in local storage.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StorageHanlder`: 该子模块实现了与浏览器本地存储相关的所有功能，例如在本地存储中存储、读取和删除对象。'
- en: '`Utilities`: This module provides helper methods to the application, such as
    methods to combine two objects, to see if an object is an array, to load files
    from the server, and so on.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Utilities`: 该模块为应用程序提供辅助方法，例如合并两个对象的方法、检查一个对象是否为数组的方法、从服务器加载文件的方法等等。'
- en: Component registration with MainCore
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MainCore中注册组件
- en: Every component of our application is registered with MainCore module. This
    allows to create the bridge between the component and the application, by using
    an instance of `SandBox` module.. We will talk about the `SandBox` module shortly
    but let's have a look at how the registration of the components takes place in
    the application (in the MainCore module).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中的每个组件都注册到MainCore模块。这允许通过`SandBox`模块的实例创建组件与应用程序之间的桥梁。我们很快就会讨论`SandBox`模块，但现在让我们看看应用程序（在MainCore模块中）中组件注册是如何进行的。
- en: 'The following diagram provides an overview of this process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概述了此过程：
- en: '![Component registration with MainCore](img/B04910_08_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![在MainCore中注册组件](img/B04910_08_12.jpg)'
- en: 'Consider the following implementation in MainCore module:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下MainCore模块中的实现：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, when this method is called at a component''s load time by the
    component, three parameters are passed into MainCore''s `mainCore.registerComponent`
    method: `containerID`, `componentID`, and `createFunc`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当组件在加载时由组件调用此方法时，将三个参数传递到MainCore的`mainCore.registerComponent`方法：`containerID`、`componentID`和`createFunc`。
- en: '`containerID` parameter is passed to this method to tell the application what
    container (HTML element) the component''s view needs to be rendered in. `componentID`
    is the ID of the component that gets registered with the application and `createFunc`
    is the callback function on the component, which `mainCore.registerComponent`
    method calls to create an instance of the component.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerID`参数传递给此方法，以告知应用程序组件视图需要渲染到哪个容器（HTML元素）。`componentID`是与应用程序注册的组件的ID，`createFunc`是组件上的回调函数，`mainCore.registerComponent`方法调用它以创建组件的实例。'
- en: We will talk about how components are instantiated in more depth, later in this
    chapter. But for now, let's have a look at this mechanism from MainCore module's
    perspective.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更深入地讨论组件的实例化。但就目前而言，让我们从MainCore模块的角度来看看这个机制。
- en: In the above method, we first walk the DOM tree to find the container element
    for the component's view, either by using jQuery or the DOM API directly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，我们首先遍历DOM树以找到组件视图的容器元素，无论是使用jQuery还是直接使用DOM API。
- en: Then, we check to see if the required `createFunc` parameter has been passed
    in, and whether it is a function. If so, we call this component's function with
    an instance of `SandBox` module (using dependency injection). Remember that every
    component gets a different instance of `SandBox` module, which is the bridge between
    the component and the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查是否已传入所需的`createFunc`参数，并且它是否是一个函数。如果是这样，我们就使用`SandBox`模块的实例（使用依赖注入）调用此组件的函数。请记住，每个组件都会获得`SandBox`模块的不同实例，这是组件与应用程序之间的桥梁。
- en: 'This is done as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这如下所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the component is designed properly, the result of this function call is an
    instance of the component which is returned and stored in `componentObj` variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件设计得当，此函数调用的结果是组件的实例，它被返回并存储在`componentObj`变量中。
- en: 'There are also a couple of required methods that we need to make sure exist
    on the component''s instance: `init` and `destroy` methods. Notice that MainCore
    is not concerned with how such methods are implemented in the component or what
    they do, only that they exist. The internal implementation of such methods and
    what they do are the responsibility of the component itself and each component
    may implement these methods differently. Consider the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些必需的方法，我们需要确保组件实例上存在：`init`和`destroy`方法。请注意，MainCore不关心这些方法在组件中的实现方式或它们的功能，只关心它们的存在。这些方法的内部实现和它们的功能是组件本身的职责，每个组件可能以不同的方式实现这些方法。考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the end of the registration phase, each component is pushed to `registeredComponents`
    array, which is a collection of all the registered components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册阶段结束时，每个组件都会推送到`registeredComponents`数组，这是一个所有注册组件的集合。
- en: 'We use this array of components to do a few different things in the application.
    For instance, when the application is starting up, we loop through all the components
    in this array and call `init` method on each one of them. This is done as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个组件数组在应用中做几件不同的事情。例如，当应用启动时，我们遍历这个数组中的所有组件，并对每个组件调用`init`方法。这是按照以下方式完成的：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding method of MainCore module is called in `index.html` file, as
    shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，在`index.html`文件中调用MainCore模块的先前方法：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After `init` methods of all the components have been called by the application
    in the start-up phase, we will see the following messages displayed in the console,
    if the application is in debug mode.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动阶段，当应用调用所有组件的`init`方法后，如果应用处于调试模式，我们将在控制台看到以下消息。
- en: '![Component registration with MainCore](img/B04910_08_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用MainCore进行组件注册](img/B04910_08_11.jpg)'
- en: Dynamic loading of components by MainCore
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainCore通过动态加载组件
- en: As you may recall, I mentioned previously that application components can be
    loaded at a later time than the application's start-up. MainCore module provides
    the hooks and implements the functionality needed to achieve this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，我之前提到过，应用组件可以在应用启动之后加载。MainCore模块提供了钩子和实现所需功能以实现这一点。
- en: I think it might be a good idea to go back to the previous chapter and have
    a look at the flow diagram which depicts this mechanism before continuing with
    the explanations to follow, just so you can refresh your memory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在继续下面的解释之前，回到前面的章节并查看描述该机制的流程图是个好主意，这样你可以刷新你的记忆。
- en: In our application, when the user clicks on the **Support** link provided in
    the footer section, a dialogue box is displayed. This dialogue box provides information
    regarding where the images of our application have been taken from and whether
    the user would like to visit that site.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，当用户点击页脚部分提供的**支持**链接时，会显示一个对话框。这个对话框提供了关于我们应用中的图片是从哪里获取的信息，以及用户是否希望访问该网站。
- en: This widget component (`notificationWidget`), is not loaded in `index.html`
    page when the application is initially started up; it is only loaded when the
    user clicks on the **Support** link.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件组件（`notificationWidget`）在应用最初启动时不会在`index.html`页面中加载；它仅在用户点击**支持**链接时加载。
- en: However, if the widget has been previously loaded in the application (if the
    user had clicked on the **Support** link before), we will simply re-render it
    on the page. This is because after the first time this component is loaded, it
    will be kept in cache, even after the user closes the dialogue box by clicking
    on its **Close** button.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果小部件已经在应用中预先加载（如果用户之前点击过**支持**链接），我们将在页面上重新渲染它。这是因为第一次加载此组件后，它将被保存在缓存中，即使用户通过点击其**关闭**按钮关闭对话框也是如此。
- en: '`NotificationHandler` sub-module is responsible for listening and acting on
    the click event of the **Support** link. This is done by using a publish-subscribe
    mechanism (pattern), which we will discuss shortly in this chapter.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationHandler`子模块负责监听并处理**支持**链接的点击事件。这是通过使用发布-订阅机制（模式）来实现的，我们将在本章稍后讨论。'
- en: 'Consider the following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method is the callback function for the **Support** link click event in
    `NotificationHandler` sub-module. The very first thing that this method does is
    to ask the application (MainCore module specifically) whether this component (widget)
    has been previously loaded and registered with the application, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是`NotificationHandler`子模块中**支持**链接点击事件的回调函数。这个方法首先做的事情是询问应用程序（特别是MainCore模块）这个组件（小部件）是否已经被应用程序（特别是MainCore模块）之前加载并注册，如下所示：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If so, this methods calls `NotificationHandler.renderWidget` (`self.renderWidget`)
    function, which in turn calls `renderWidget` method on the widget component itself.
    Note that the widget is responsible for its own rendering, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，这个方法会调用`NotificationHandler.renderWidget`（`self.renderWidget`）函数，然后它反过来在组件本身上调用`renderWidget`方法。请注意，组件本身负责其渲染，如下所示：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the widget has not been loaded previously, the method asks the MainCore module
    to load the widget first, and then call `NotificationHandler.renderWidget` function,
    which is the callback function that is passed in as `self.renderWidget`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小部件之前没有被加载，该方法会要求MainCore模块首先加载小部件，然后调用`NotificationHandler.renderWidget`函数，这是作为`self.renderWidget`传入的回调函数。
- en: 'This call is shown as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the control is given to MainCore module to load the component (widget) dynamically.
    This is done by first finding the object definition for the component in the browser's
    local storage.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在控制权交给了MainCore模块来动态加载组件（小部件）。这是通过首先在浏览器的本地存储中查找组件的对象定义来完成的。
- en: Let's first have a look at how the local storage is populated with the components'
    object definitions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看本地存储是如何填充组件对象定义的。
- en: Storing object definitions in local storage
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在本地存储中存储对象定义
- en: The application has been designed to find the object definitions for all the
    dynamically loaded components, in the browser's local storage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已被设计为在浏览器的本地存储中查找所有动态加载组件的对象定义。
- en: However, these definitions are in fact implemented in `PageDefinitions.js` file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些定义实际上是在`PageDefinitions.js`文件中实现的。
- en: 'When the `PageDefinitions.js` file is loaded, it uses an IIFE to store its
    object definitions in the browser''s local storage, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PageDefinitions.js`文件被加载时，它使用IIFE将它的对象定义存储在浏览器的本地存储中，如下所示：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After the browser's local storage is populated with the object definitions,
    the file is removed from the browser's cache as it can potentially be large and
    consume a significant amount of memory. This design allows us to minimize the
    use of the browser's cache, which could be of particular interest on mobile devices,
    where resources are limited.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器本地存储填充了对象定义之后，文件将从浏览器缓存中删除，因为它可能很大，并且会消耗大量的内存。这种设计允许我们最小化浏览器缓存的使用，这在资源有限的移动设备上可能特别有趣。
- en: Notice the object definition for `notificationWidget`. On this object, `ScriptFile`
    property holds the name of the `.js` file for this component and `ScriptPath`
    property stores the path to this file. MainCore module uses this information to
    find and load the component from the server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`notificationWidget`的对象定义。在这个对象上，`ScriptFile`属性持有该组件的`.js`文件名，而`ScriptPath`属性存储该文件的路径。MainCore模块使用这些信息从服务器查找并加载组件。
- en: Getting a component's object definition from local storage
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从本地存储获取组件的对象定义
- en: Now that you know how the local storage is populated with the object definitions,
    we can look at how MainCore module gets the `notificationWidget` object definition
    from the local storage and loads the related resources.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了本地存储是如何填充对象定义的，我们可以看看MainCore模块是如何从本地存储中获取`notificationWidget`对象定义并加载相关资源的。
- en: 'Consider the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this method, first the local storage in the browser is checked (using the
    `StorageHandler` sub-module behind the scenes) for the object definition of the
    component. If it is found, then this method calls another method to dynamically
    load the necessary resources for the component as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先检查浏览器中的本地存储（在幕后使用`StorageHandler`子模块）以查找组件的对象定义。如果找到了，那么这个方法会调用另一个方法来动态加载组件所需的资源，如下所示：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dynamically loading component's resources from the server
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从服务器动态加载组件的资源
- en: 'Once a component''s object definition has been extracted from the local storage,
    its required `.js` and `.css` files are loaded from the server using the following
    method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从本地存储中提取了组件的对象定义，其所需的 `.js` 和 `.css` 文件将通过以下方法从服务器加载：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this method calls other methods which specialize in loading
    `.js` or `.css` files, as the mechanism for loading the files into the application
    is different, based on the file type. Of course the `.js` file is where the code
    for the component resides and the `.css` file has the styling-related information
    for the component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法调用其他专门用于加载 `.js` 或 `.css` 文件的方法，因为根据文件类型，将文件加载到应用程序中的机制不同。当然，`.js` 文件是组件代码所在的地方，而
    `.css` 文件包含组件的样式相关信息。
- en: Keep in mind that the callback function is called **asynchronously** after the
    files are loaded into the browser's cache.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在文件被加载到浏览器缓存后，回调函数将**异步**调用。
- en: Also, note that MainCore module uses `Utilities` sub-module (behind the scenes)
    to take care of the mechanics of requesting and loading the component files from
    the server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，MainCore 模块使用 `Utilities` 子模块（幕后操作）来处理从服务器请求和加载组件文件的技术细节。
- en: The dynamic loading of components is probably the most involved operation in
    the application and it can be a little challenging to fully understand it by just
    reading this section. I highly recommend that you download the application's code
    and put breakpoints in the methods that I have mentioned in this section when
    you run the application. Doing so, will help you to fully realize how the flow
    of loading components dynamically is taking place.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的动态加载可能是应用程序中最复杂的操作，仅通过阅读本节可能难以完全理解。我强烈建议您下载应用程序的代码，并在运行应用程序时在此节中提到的方法中设置断点。这样做将帮助您完全理解动态加载组件的流程。
- en: After a component is dynamically loaded into the application, it still needs
    to register itself with MainCore module. We will talk about this process more
    later in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件被动态加载到应用程序后，它仍然需要向 MainCore 模块注册自己。我们将在本章的后面部分更详细地讨论这个过程。
- en: Routing functionality in MainCore module
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainCore 模块中的路由功能
- en: As our application is a single page application, and its view needs to change
    based on the user's interaction, we need to implement the client-side routing
    functionality. This also means that we need to incorporate page view changes based
    on the user clicking on the back and forward buttons of the browser.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是一个单页应用程序，并且其视图需要根据用户的交互进行更改，因此我们需要实现客户端路由功能。这也意味着我们需要根据用户点击浏览器的后退和前进按钮来整合页面视图的更改。
- en: In our application, I have used the HTML5 History API as the basis for our client-side
    routing, but we could have also used open source libraries such as `History.js`
    instead.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我已使用 HTML5 历史API 作为客户端路由的基础，但我们也可以使用像 `History.js` 这样的开源库。
- en: Let's see how routing functionality has been implemented in MainCore module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 MainCore 模块中如何实现路由功能。
- en: Adding a URL to the history object of the browser
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 URL 添加到浏览器的历史对象中
- en: 'Consider the following method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下方法：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method is called when the application needs to create an entry in the
    history object of the browser. For instance, when the **Home** link of the header
    section is clicked, the following callback function is called in the header component:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要在浏览器的历史对象中创建条目时，将调用此方法。例如，当点击页眉部分的**主页**链接时，在页眉组件中会调用以下回调函数：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, the callback function calls `addToHistory` API of its `SandBox`
    instance with an anonymous object. The `SandBox` instance, in turn, calls `addToHistory`
    method of MainCore module. The anonymous object is passed to this method and then
    the browser''s history object is updated, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回调函数调用其 `SandBox` 实例的 `addToHistory` API，然后 `SandBox` 实例调用 MainCore 模块的
    `addToHistory` 方法。匿名对象传递给此方法，然后浏览器的历史对象按以下方式更新：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are three parameters which are passed to `pushState` API of the history
    object. These parameters are; `State` object, `Title`, and `URL`, respectively.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将三个参数传递给历史对象的 `pushState` API。这些参数分别是；`State` 对象、`Title` 和 `URL`。
- en: 'In our preceding example, the following object will be passed to this API as
    the first parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，以下对象将被作为第一个参数传递给此 API：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use `url` property of the same object for the other parameters
    too.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用同一对象的`url`属性来设置其他参数。
- en: 'For more information regarding the browser''s history API, you can refer to
    the following link:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于浏览器历史API的信息，您可以参考以下链接：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)'
- en: Getting a URL from the history object of the browser
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从浏览器的历史对象中获取URL
- en: 'To get URL entries from the browser''s History object, we first bind `popstate`
    event of the browser to MainCore''s `getFromHistory` method, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要从浏览器的历史对象中获取URL条目，我们首先将浏览器的`popstate`事件绑定到MainCore的`getFromHistory`方法，如下所示：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means that every time the browser''s `pop` event takes place, which is
    when the user clicks on the back or forward button of the browser, the following
    method is called:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当浏览器发生`pop`事件时，即用户点击浏览器的后退或前进按钮时，以下方法就会被调用：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The main action taken by this method is to call `handlePageChange` method of
    MainCore module. This method, in turn, publishes a `page-Changed` event in the
    application, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法采取的主要行动是调用MainCore模块的`handlePageChange`方法。该方法反过来，在应用程序中发布一个`page-Changed`事件，如下所示：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When this event is published, all the modules that have registered for this
    event are notified. The modules can then take action based on the published event.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当此事件发布时，所有注册了此事件的模块都会收到通知。模块可以根据发布的事件采取行动。
- en: 'For instance, `content` component has bound `updateContentPage` method to this
    event as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`content`组件将`updateContentPage`方法绑定到该事件，如下所示：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To better understand how this process works, we also need to talk about custom
    events and publish-subscribe (observer) pattern implementation in the application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一过程是如何工作的，我们还需要讨论应用程序中自定义事件和发布-订阅（观察者）模式的实现。
- en: Publish-subscribe implementation in MainCore
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MainCore中的发布-订阅实现
- en: As previously mentioned, one of the goals of our application design has been
    to create loose coupling among the application modules.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应用程序设计的目标之一就是创建应用程序模块之间的松散耦合。
- en: We have also talked about the fact that while our application modules are not
    aware of each other, they need to be able to communicate with one another in an
    indirect manner.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了这样一个事实：虽然我们的应用程序模块彼此之间并不了解，但它们需要能够以间接的方式相互通信。
- en: These goals can be achieved by leveraging the **Mediator** design pattern and
    implementing a publish-subscribe mechanism around that pattern.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标可以通过利用**中介者**设计模式并在该模式周围实现发布-订阅机制来实现。
- en: As we saw in the previous chapter, in Mediator pattern pieces of the application
    do not directly register with each other for custom events. Instead, they register
    for these events and are notified of the broadcast of such events through an intermediary
    piece. In our application, the intermediary piece is our MainCore module.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，在中介者模式中，应用程序的各个部分不会直接为自定义事件相互注册。相反，它们为这些事件注册，并通过一个中介部件来接收此类事件的广播通知。在我们的应用程序中，中介部件是我们的MainCore模块。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not familiar with mediator or publish-subscribe patterns, I highly
    recommend reading, *Mastering JavaScript Design Patterns* by *Simon Timms*, which
    discusses many popular patterns as well as mediator pattern. You can find this
    book at the following link:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉中介者或发布-订阅模式，我强烈推荐阅读*Simon Timms*的《Mastering JavaScript Design Patterns》，该书讨论了许多流行的模式以及中介者模式。您可以在以下链接找到这本书：
- en: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)'
- en: Registering components for custom events
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为自定义事件注册组件
- en: 'The following method in MainCore module is used for registering components
    to receive custom events:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: MainCore模块中的以下方法用于将组件注册为接收自定义事件：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, this method registers the custom event object passed to it with
    the ID of the component, which needs to be notified when the event is published.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法将传递给它的自定义事件对象与组件的ID注册，当事件发布时需要通知该组件。
- en: 'For instance, `content` component registers for the following events:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`content`组件注册了以下事件：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When any one of the preceding events is published, the bound event handler method
    for that event is called.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述任何事件被发布时，该事件的绑定事件处理器方法就会被调用。
- en: 'Notice that in the code above, no component ID is passed to the `SandBox` module
    instance by the component. However, the `SandBox` module instance associated with
    this component sends the required component ID to MainCore module as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的代码中，组件没有将任何组件 ID 传递给 `SandBox` 模块实例。然而，与该组件关联的 `SandBox` 模块实例按照以下方式将所需的组件
    ID 发送到 `MainCore` 模块：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will talk about how the `SandBox` instance is aware of the component ID,
    when we talk about `SandBox` module later in this chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面讨论 `SandBox` 模块时，我们将讨论 `SandBox` 实例如何知道组件 ID。
- en: Broadcasting custom events by components
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过组件广播自定义事件
- en: When components need to publish custom events in the application, they do so
    by using `publishCustomEvent` method in MainCore module.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件需要在应用程序中发布自定义事件时，它们通过使用 `MainCore` 模块中的 `publishCustomEvent` 方法来实现。
- en: 'Consider the following code for this method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于此方法的代码：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, an event object is passed to this method. The method loops through
    all the components which have registered for this event and then calls the associated
    event handler on the components for the event.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个事件对象被传递到这个方法中。该方法遍历所有已注册此事件的组件，然后调用组件上与该事件关联的事件处理器。
- en: 'Components can publish their events using their instance of `SandBox` module.
    For example, the `header` component of the application broadcasts that the Favorites
    link in the application has been clicked, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以使用它们的 `SandBox` 模块实例发布它们的事件。例如，应用程序的 `header` 组件广播应用程序中的收藏链接已被点击，如下所示：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since the `content` component has registered for this event, the method `updateContentPage`
    of the `content` component is subsequently called.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `content` 组件已注册此事件，因此随后的调用 `content` 组件的 `updateContentPage` 方法。
- en: To sum things up, application components publish custom events, then the components
    that have registered for these custom events are notified by MainCore module,
    which calls the associated methods for these custom events. Thus, MainCore module
    acts as the mediator piece among all the components of the application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，应用程序组件发布自定义事件，然后注册了这些自定义事件的组件通过 `MainCore` 模块得到通知，`MainCore` 模块调用与这些自定义事件关联的方法。因此，`MainCore`
    模块在应用程序的所有组件之间充当了中介件。
- en: This concludes our discussion and examination of the core module, but keep in
    mind that the core module as a whole provides many more capabilities for the application,
    beyond what we have discussed here. All such functionality is either implemented
    in MainCore module (`MainCore.js`) or other sub-modules which together, make up
    the core module.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对核心模块的讨论和审查，但请记住，整个核心模块为应用程序提供了许多超出我们在此讨论的功能。所有此类功能要么在 `MainCore` 模块（`MainCore.js`）中实现，要么在其他子模块中实现，这些子模块共同构成了核心模块。
- en: Keep in mind that from the component's point of view, all the application functionality
    is provided by an instance of `SandBox` module.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从组件的角度来看，所有应用程序功能都是由 `SandBox` 模块的一个实例提供的。
- en: SandBox module implementation
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SandBox 模块实现
- en: As mentioned previously, the components in our application do not directly communicate
    with each other nor do they communicate directly with any other parts of the application.
    The only connection between the components and the rest of the application is
    through an instance of `SandBox` module assigned to them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应用程序中的组件不直接相互通信，也不直接与其他应用程序部分通信。组件与应用程序其余部分之间的唯一连接是通过分配给它们的 `SandBox`
    模块实例。
- en: SandBox module's constructor
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SandBox 模块的构造函数
- en: 'Consider the following code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As the preceding code shows, `SandBox` module is created as a global object
    `SandBox`, and three parameters are passed to its constructor by MainCore module.
    `Core` parameter, which is a reference to MainCore module; `contextElem` parameter,
    which is a reference to the container element for the component's view that the
    `SandBox` instance belongs to; and `componentSelector` , which is the ID of the
    sandbox's component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`SandBox` 模块被创建为一个全局对象 `SandBox`，并且由 `MainCore` 模块通过构造函数传递了三个参数给它。`Core`
    参数，是 `MainCore` 模块的引用；`contextElem` 参数，是组件视图所属的容器元素的引用；以及 `componentSelector`，它是沙盒组件的
    ID。
- en: 'For instance, the `SandBox` instance of `header` component, receives the following
    parameters when it is instantiated: A reference to the core module as the first
    parameter, `headerContainer` which is the ID of `header` component''s view container
    on the page as the second parameter, and `header` which is the ID of `header`
    component as the third parameter.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`header`组件的`SandBox`实例被实例化时，它接收以下参数：作为第一个参数的核心模块引用，`headerContainer`，这是页面上`header`组件视图容器的ID，作为第二个参数，以及`header`，这是`header`组件的ID，作为第三个参数。
- en: The reference to Core module is used by the `SandBox` module instance to get
    access to the functionality that Core module provides.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`SandBox`模块实例使用对核心模块的引用来获取核心模块提供的功能。'
- en: Setting a component's container context in the SandBox instance
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`SandBox`实例中设置组件的容器上下文
- en: A reference to the container element of the component's view is used by the
    `SandBox` module instance to set the DOM context of the component's HTML elements.
    This is so when an HTML element within this container needs to be accessed, the
    search for this element can start from the container element, as opposed to the
    `document` element of the page.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`SandBox`模块实例使用组件视图的容器元素的引用来设置组件HTML元素的DOM上下文。这样，当需要访问此容器内的HTML元素时，搜索可以从容器元素开始，而不是从页面的`document`元素开始。'
- en: 'Have a look at the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here the `SandBox` module instance is calling the core module's `getChildOfParentByID`
    method. This method takes two parameters, `containerElemContext`, and `elementID`.
    The objective is to search the DOM tree for the element whose ID has been passed
    in.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SandBox`模块实例正在调用核心模块的`getChildOfParentByID`方法。此方法接受两个参数，`containerElemContext`和`elementID`。目标是搜索DOM树以找到传递进来的ID对应的元素。
- en: Using the container element's `DOM` Context, we can start the search in the
    container of the component as opposed to the top-level element of the DOM tree.
    This approach allows us to have a much more optimized search for finding our component's
    elements.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器元素的`DOM`上下文，我们可以从组件的容器开始搜索，而不是从DOM树的最顶层元素开始。这种方法使我们能够对找到组件元素进行更优化的搜索。
- en: Identifying the SandBox module's instance
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别`SandBox`模块的实例
- en: The component ID, which is passed in as the third parameter to `SandBox` module's
    constructor, identifies the instance of `SandBox` module. This is used by the
    core module, to identify which component the `SandBox` instance belongs to.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`SandBox`模块构造函数的第三个参数传入的组件ID，用于标识`SandBox`模块的实例。核心模块使用这个ID来识别`SandBox`实例属于哪个组件。
- en: 'For instance, the component''s ID is used in the following method of `SandBox`
    module:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，组件的ID在以下`SandBox`模块的方法中使用：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the code snippet above, we are calling `unregisterCustomEvent` method of
    Core module and are passing in the parameter `componentID`. This is so core module
    knows which instance of `SandBox` is making this call and in turn, which component
    wishes to unsubscribe from the custom event.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们正在调用核心模块的`unregisterCustomEvent`方法，并传入参数`componentID`。这样核心模块就能知道哪个`SandBox`实例正在发起这个调用，进而知道哪个组件希望取消订阅自定义事件。
- en: SandBox module considerations
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`SandBox`模块注意事项'
- en: There are also a couple of other things that you need to keep mind about `SandBox`
    module. First, `SandBox` module can be designed to only provide a subset of Core
    module's functionality to the components. This enables us to control what application
    functionality components can have access to. Second, all the methods of `SandBox`
    module are designed to do a very basic error checking. This filter calls which
    that have passed the basic level of validation to propagate to Core module.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SandBox`模块还有一些其他事项需要注意。首先，`SandBox`模块可以被设计成只为组件提供核心模块功能的一个子集。这使我们能够控制组件可以访问哪些应用程序功能。其次，`SandBox`模块的所有方法都设计为进行非常基本的错误检查。这个过滤器将已通过基本级别验证的调用传播到核心模块。
- en: Keep in mind that `SandBox` module is supposed to be only a thin layer which
    sits between the components and the rest of the application. Thus, it is best
    to not do extensive validation at `SandBox` module level.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`SandBox`模块应该只是一个位于组件和应用程序其余部分之间的薄层。因此，最好在`SandBox`模块级别不要进行广泛的验证。
- en: What constitutes a thin layer is open to interpretations, but since there could
    potentially be many instances of `SandBox` module in the application, it is best
    to keep it as thin as possible.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是薄层，这取决于解释，但由于应用中可能存在许多 `SandBox` 模块的实例，最好将其保持得尽可能薄。
- en: Application components
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: Considering that our application is a **proof of concept** type application,
    we have only implemented four components; `header`, `footer`, `content`, and `notificationWidget`
    (I'm using the component IDs used in the application).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的应用程序是一个 **概念验证** 类型的应用程序，我们只实现了四个组件；`header`、`footer`、`content` 和 `notificationWidget`（我使用的是应用程序中使用的组件
    ID）。
- en: These components are implemented in the following files in the application's
    project, `ImagesInc_Header.js`, `ImagesInc_Footer.js`, `ImagesInc_Content.js`,
    and `NotificationWidget.js`, respectively.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件在应用程序的项目中的以下文件中实现，分别是 `ImagesInc_Header.js`、`ImagesInc_Footer.js`、`ImagesInc_Content.js`
    和 `NotificationWidget.js`。
- en: In the following sections, I will provide an overview of each component, but
    I highly recommend that you have a look at the code accompanying this book to
    get a better understanding of how these components are implemented.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将概述每个组件，但我强烈建议你查看本书附带的代码，以更好地理解这些组件是如何实现的。
- en: Keep in mind that our components are modules, which create different application
    views. In an MVC or MV* architectural pattern paradigm, our components contain
    their own controllers as well as leveraging the application level controller which
    has been provided to them through their own instance of `SandBox` module.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的组件是模块，它们创建不同的应用程序视图。在 MVC 或 MV* 架构模式范式中，我们的组件包含它们自己的控制器，同时利用通过它们自己的 `SandBox`
    模块实例提供的应用级控制器。
- en: The components also implement their own views and each component is only aware
    of its view in the application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还实现了它们自己的视图，每个组件只了解其在应用中的视图。
- en: While an application level model is present (`ImagesInc_GlobalData`), and our
    components can use the data stored in this application model, each component can
    also contain its own model. Therefore, each component implements its own MVC or
    MV* architecture.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在一个应用级模型（`ImagesInc_GlobalData`），并且我们的组件可以使用存储在这个应用模型中的数据，但每个组件也可以包含它自己的模型。因此，每个组件实现了它自己的
    MVC 或 MV* 架构。
- en: Registering components with MainCore module
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MainCore 模块注册组件
- en: We have already talked about how a component is registered with MainCore module
    from the MainCore's perspective. It is time to have a look at how this is done
    at the component's level.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从 MainCore 的角度讨论了组件是如何注册到 MainCore 模块的。现在是时候看看在组件级别是如何操作的。
- en: The mechanism for registering components with the application is always the
    same, regardless of whether the component is loaded at the application start-up
    phase or at a later time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 无论组件是在应用启动阶段还是稍后加载，注册组件到应用中的机制总是相同的。
- en: 'Consider the following code snippet:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, when a component's `.js` file is loaded, for instance `notificationWidget`
    shown previously, `registerComponent` method of MainCore module is called. Thus,
    MainCore module needs to be loaded before any component files in the application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当一个组件的 `.js` 文件被加载时，例如之前展示的 `notificationWidget`，会调用 MainCore 模块的 `registerComponent`
    方法。因此，在应用中加载任何组件文件之前，都需要先加载 MainCore 模块。
- en: Since we have talked about how this method is called by a component previously,
    the following should be just a review for you.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前已经讨论了组件是如何被调用的，以下内容对你来说应该只是复习。
- en: 'In the preceding code, when `NotificationWidget.js` file is loaded, the `registerComponent`
    method of MainCore module is called with three parameters: `mainPageContainer`,
    which is the ID of the container element that hosts the component''s view; `notificationWidget`,
    which is the ID of the component itself, and a third parameter as a `callback`
    function. When this `callback` function is called by MainCore module, it receives
    an instance of `SandBox` module.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当 `NotificationWidget.js` 文件被加载时，会调用 MainCore 模块的 `registerComponent`
    方法，并带有三个参数：`mainPageContainer`，这是承载组件视图的容器元素的 ID；`notificationWidget`，这是组件本身的
    ID；以及第三个参数作为一个 `callback` 函数。当这个 `callback` 函数被 MainCore 模块调用时，它会接收到 `SandBox`
    模块的一个实例。
- en: Note that the return object from this callback function is the component's singleton
    object, which has the required methods `init` and `destroy`. Of course, these
    methods are used by the application to initialize and destroy the component instance,
    respectively. We will talk about these methods more when we talk about `notificationWidget`
    component.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此回调函数的返回对象是组件的单例对象，它具有所需的 `init` 和 `destroy` 方法。当然，这些方法被应用程序用于初始化和销毁组件实例。当我们讨论
    `notificationWidget` 组件时，我们将更详细地介绍这些方法。
- en: One other thing to notice here is that we have created a closure in this callback
    function, so only the returned object from this function has access to the private
    variables of the component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要注意的事项，那就是我们在回调函数中创建了一个闭包，因此只有从该函数返回的对象才能访问组件的私有变量。
- en: Header component
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题组件
- en: This component registers itself with Core module using the ID `header`, and
    from that point forward, this ID is used by the application to reference this
    component.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件使用 ID `header` 在 Core 模块中注册自己，从那时起，应用程序使用此 ID 来引用此组件。
- en: As with all the other components in the application, this component implements
    the required `init` and `destroy` methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序中的所有其他组件一样，此组件实现了所需的 `init` 和 `destroy` 方法。
- en: '`header` component also implements methods to attach and remove event handlers,
    for its elements. The method `handleFavouritesClick` is an example of an event
    handler in this component.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`header` 组件也实现了用于其元素附加和移除事件处理程序的方法。`handleFavouritesClick` 方法是此组件中事件处理程序的一个示例。'
- en: 'Consider the implementation of this event handler as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下事件处理程序的实现：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method is called when the **Favorites** link of `header` component is clicked.
    It first checks to see if there are any favorite images stored in the browser's
    cookie. However, this check is not done directly by the component itself, as the
    call is made to the instance of `SandBox` module for this component.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `header` 组件的 **Favorites** 链接时，会调用此方法。它首先检查浏览器 cookie 中是否存储了任何收藏的图片。然而，此检查不是由组件直接完成的，因为这个调用是针对该组件的
    `SandBox` 模块实例进行的。
- en: Notice that `header` component has no idea how the mechanism for checking the
    cookie is implemented, and it does not need to implement such functionality itself.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`header` 组件并不知道检查 cookie 的机制是如何实现的，它也不需要自己实现此类功能。
- en: If such mechanism is changed at some point in the future, it makes no difference
    to this component. The component will always make the same call to the `SandBox`
    module instance and lets the application handle this operation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未来某个时刻改变了这种机制，这对该组件没有影响。组件将始终调用 `SandBox` 模块实例的相同方法，并让应用程序处理此操作。
- en: Also note that this method updates the URL in the browser, and publishes a custom
    event that informs the application of the particular event that has taken place.
    Of course, the component leverages the application's functionality through the
    `SandBox` module instance to accomplish all these tasks.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，此方法更新浏览器中的 URL，并发布一个自定义事件，通知应用程序已发生特定事件。当然，组件通过 `SandBox` 模块实例利用应用程序的功能来完成所有这些任务。
- en: Footer component
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页脚组件
- en: The design of `footer` component is very similar to `header` component, and
    it registers itself with Core module with the ID of `footer`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`footer` 组件的设计与 `header` 组件非常相似，并且它使用 `footer` ID 在 Core 模块中注册自己。'
- en: 'One method in the component which we need to have a look at is `hanldeSupportClick`.
    This method is called when the **Support** link of `footer` component is clicked.
    Let''s examine the implementation of this method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中我们需要查看的一个方法是 `handleSupportClick`。当点击 `footer` 组件的 **Support** 链接时，会调用此方法。让我们检查此方法的实现，如下所示：
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, when the link is clicked, the custom event `support-Clicked`
    is published. If you recall from an earlier section in this chapter, `NotificationHandler`
    module is listening to this event and will take the required action when this
    event takes place.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当点击链接时，会发布自定义事件 `support-Clicked`。如果您回忆起本章前面的某个部分，`NotificationHandler`
    模块正在监听此事件，并在事件发生时采取必要的行动。
- en: This is another example which shows, while these pieces of the application are
    communicating with each other, they are not actually aware of each other's existence.
    These components are loosely coupled using our publish-subscribe implementation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个示例，说明尽管这些应用程序的部分正在相互通信，但实际上它们并不了解彼此的存在。这些组件通过我们的发布-订阅实现松散耦合。
- en: Content component
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容组件
- en: This component can be considered as the main component of our application and
    it is responsible for changing the views of the content area. It registers itself
    with Core module with the ID of `content`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件可以被认为是我们的应用程序的主要组件，它负责改变内容区域视图。它使用`content`的ID向Core模块注册自己。
- en: The content component implements the required `init` and `destroy` methods as
    well as many other methods.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 内容组件实现了所需的`init`和`destroy`方法以及许多其他方法。
- en: We are going to have a look at some of the important ones here.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里查看一些重要的方法。
- en: Handling content area click events
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理内容区域点击事件
- en: When a user clicks on the **Add to Favorites** link in the application or when
    an image is clicked in the content area, the parent container of the `content`
    component's view captures the event and processes it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用程序中点击**添加到收藏**链接或当内容区域中的图像被点击时，`content`组件视图的父容器捕获事件并处理它。
- en: 'The binding for the event handling of the parent container takes place in `init`
    method of `content` component as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理绑定的父容器发生在`content`组件的`init`方法中，如下所示：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, `handleMainContainerClicked` is the callback method that processes
    this click event.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`handleMainContainerClicked`是处理这个点击事件的回调方法。
- en: 'Consider how this method has been implemented:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个方法是如何实现的：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown, we check to see if the click event is taking place on an image or
    on an anchor tag, and based on this determination, we delegate the rest of the
    event processing to the associated methods.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们检查点击事件是否发生在图像或锚标签上，并根据这个判断，将事件处理的其余部分委托给相关的方法。
- en: Handling the Add To Favorite link click event
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理添加到收藏链接的点击事件
- en: In `handelFavLinkClick` method, we check the state of the **Add to Favorites**
    link and change its text to **Remove from Favorites**. If the link has already
    been clicked, and it contains the text **Remove from Favorites**, we re-set the
    text to its default value of **Add to Favorites**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handelFavLinkClick`方法中，我们检查**添加到收藏**链接的状态，并将其文本更改为**从收藏中移除**。如果链接已经被点击，并且包含文本**从收藏中移除**，我们将文本重置为其默认值**添加到收藏**。
- en: We also add or remove the ID of the favorite image in the browser's cookie,
    so when the user navigates to the **Favorites** page, the correct favorite images
    are rendered in the content area.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在浏览器的cookie中添加或删除收藏图像的ID，因此当用户导航到**收藏**页面时，正确收藏的图像会在内容区域渲染。
- en: 'Consider the implementation of this method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个方法的实现：
- en: '[PRE43]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, there is also one other thing that we do in this method, which
    is to broadcast the related custom event to the application. This allows all the
    other pieces of the application which are registered for this event to be informed
    of the event taking place in this component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这个方法中我们还有其他一件事情要做，那就是广播相关的自定义事件到应用程序。这允许所有注册了这个事件的程序的其他部分都能得知这个组件中发生的事件。
- en: Handling an image click event
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理图像点击事件
- en: 'When an image is clicked in the content area of the application, the following
    method is called:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序内容区域中的图像被点击时，将调用以下方法：
- en: '[PRE44]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that this method does two main things. One is to update the history object
    of the browser so that the application router can work properly when the user
    clicks on the back and forward buttons of the browser. The second is to broadcast
    the message `img-Clicked` to the application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个方法做了两件主要的事情。一是更新浏览器的历史对象，以便当用户点击浏览器的后退和前进按钮时，应用程序路由器可以正常工作。二是向应用程序广播消息`img-Clicked`。
- en: 'The interesting point to consider is that our `content` component itself listens
    to this event and acts on this event to update the page view, using the following
    event registration method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的有趣点是，我们的`content`组件本身监听这个事件，并对此事件采取行动来更新页面视图，使用以下事件注册方法：
- en: '[PRE45]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, when `img-Clicked` event is received by `content` component
    (which itself had generated), then `updateContentPage` method of this component
    is called.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当`img-Clicked`事件被`content`组件（它自身生成的）接收时，那么这个组件的`updateContentPage`方法就会被调用。
- en: Of course, we could have directly updated the view of the page in `handleImageClick`
    method, but by broadcasting the event at the application level, we can be sure
    that all the pieces of the application, including `content` component itself,
    can take action upon the broadcast of this event.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在 `handleImageClick` 方法中直接更新页面的视图，但通过在应用程序级别广播事件，我们可以确保应用程序的所有部分，包括 `content`
    组件本身，都可以在事件广播时采取行动。
- en: Content area generator methods
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容区域生成方法
- en: '`content` component also has methods which are responsible for generating the
    content area of the page, based on the URL of the browser. The following is a
    summary of such methods:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 组件也有负责根据浏览器 URL 生成页面内容区域的方法。以下是对这些方法的总结：'
- en: '`buildFavouritesPage`: This method loads the related CSS file for the Favorites
    page (using the `SandBox` module instance) and then renders this page based on
    the number of the favorite images previously selected by the user'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildFavouritesPage`：此方法加载与收藏夹页面相关的 CSS 文件（使用 `SandBox` 模块实例），然后根据用户之前选择的收藏图像数量渲染此页面'
- en: '`buildIndexContentHTML`: As the name implies, this method is responsible for
    building HTML tags for the content area of `index.html` page'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildIndexContentHTML`：如名称所示，此方法负责为 `index.html` 页面的内容区域构建 HTML 标签'
- en: '`buildImagePageHTML`: The full view of the clicked image is rendered using
    this method'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildImagePageHTML`：使用此方法渲染点击的图像的全视图'
- en: '`getAnchorHTMLStr`: This method generates the related link for each image so
    the image can be added or removed from the favorite images list, based on the
    state of the link'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAnchorHTMLStr`：此方法为每个图像生成相关链接，以便根据链接的状态将图像添加或从收藏夹图像列表中删除'
- en: I highly recommend that you have a look at the code for this component to see
    how these methods are implemented.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您查看此组件的代码，以了解这些方法是如何实现的。
- en: NotificationWidget component
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NotificationWidget 组件
- en: When this component is loaded, it registers itself as `notificationWidget` with
    core module.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组件加载时，它将自己注册为 `notificationWidget` 到核心模块。
- en: We talked about this component previously and while its design is similar to
    all the other components in the application, there are some differences.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过这个组件，尽管其设计与应用程序中的所有其他组件类似，但也有一些不同之处。
- en: As mentioned before, this component is not loaded or rendered at the application's
    start-up phase. It is loaded and rendered dynamically only when needed, based
    on the user's interaction with the application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个组件不是在应用程序启动阶段加载或渲染的。它仅在需要时根据用户与应用程序的交互动态加载和渲染。
- en: NotificationWidget's model
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NotificationWidget 的模型
- en: 'This component''s view is stored as a string in the component itself, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的视图以字符串形式存储在组件本身中，如下所示：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This string is passed by the component to MainCore module to render its view.
    You will see how this is done very shortly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串由组件传递给 MainCore 模块以渲染其视图。您很快就会看到这是如何完成的。
- en: Required methods of the notificationWidget component
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知组件所需的方法
- en: 'As mentioned previously, each component needs to implement the required methods:
    `init` and `destroy`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个组件都需要实现所需的方法：`init` 和 `destroy`。
- en: 'Have a look at the following `init` method of `notificationWidget` component
    as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下 `notificationWidget` 组件的 `init` 方法，如下所示：
- en: '[PRE47]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When the application calls `init` method of a component, in this case `notificationWidget`,
    a new property is added to the instance of `SandBox` module that was passed to
    the component. This property is `contextObj` and its value is set to `this`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序调用组件的 `init` 方法，在这种情况下是 `notificationWidget`，就会向传递给组件的 `SandBox` 模块实例添加一个新属性。这个属性是
    `contextObj`，其值设置为 `this`。
- en: In this context, `this` is a reference to the component itself and is assigned
    to the `SandBox` instance so we can have an easy way to access the context of
    the component when we need to. This property is particularly useful for our event
    handler callbacks in the component.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`this` 是对组件本身的引用，并被分配给 `SandBox` 实例，这样我们就可以在需要时轻松访问组件的上下文。这个属性对于组件中的事件处理程序回调特别有用。
- en: 'Consider the following code snippet from `notificationWidget` component:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自 `notificationWidget` 组件的代码片段：
- en: '[PRE48]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This callback function is called when the user clicks on the **Close** button
    of the dialogue box which is the view for `notificationWidget` component. You
    might wonder why we are not calling the component''s internal method from the
    callback function as:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击对话框的**关闭**按钮时，该按钮是`notificationWidget`组件的视图，此时会调用此回调函数。你可能想知道为什么我们不从回调函数中调用组件的内部方法，如下所示：
- en: '[PRE49]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For the above function call to succeed, the callback function needs to run in
    the context of the component. However, since the context of `this` is set at the
    time of code execution to the object that calls this callback function, and not
    the component, we are not be able to call the component's internal methods using
    `this`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述函数调用成功，回调函数需要在组件的上下文中运行。然而，由于`this`的上下文在代码执行时设置为调用此回调函数的对象，而不是组件，因此我们无法使用`this`调用组件的内部方法。
- en: 'Thus, by setting the property `contextObj` on the `SandBox` instance, we are
    able to easily access the original context of the component and call the required
    internal method as:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在`SandBox`实例上设置属性`contextObj`，我们能够轻松访问组件的原始上下文并调用所需内部方法，如下所示：
- en: '[PRE50]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Of course, we could also use JavaScript's `bind()` method to achieve the same
    context preservation but I have used this approach instead, so you can see a different
    way of resolving this issue.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用JavaScript的`bind()`方法来实现相同的作用域保留，但我选择了这种方法，这样你可以看到解决这个问题的另一种方式。
- en: The `destroy` method of the component is used to make it inactive (no events
    on the component will be processed) or to completely remove the component from
    the DOM.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的`destroy`方法用于使其失效（组件上不会处理任何事件）或完全从DOM中移除组件。
- en: 'Consider destroy method implementation of `notificationWidget`, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`notificationWidget`的`destroy`方法实现，如下所示：
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Depending on the value of `removeComponent` flag(`true` or `false`), which is
    passed to this method, the component is either disabled or completely removed
    from the DOM.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递给此方法的`removeComponent`标志（`true`或`false`）的值，组件要么被禁用，要么完全从DOM中移除。
- en: Note that in the above code, the component uses its instance of `SandBox` module
    to remove itself from the DOM and it does not need to implement such functionality
    itself. This allows the component to only focus on its own specialized tasks and
    leverage the functionality provided by the application (through the `SandBox`
    instance). This design also limits the component's access to the world beyond
    its own so we can minimize possible DOM manipulation conflicts, as described in
    the previous chapter.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的代码中，组件使用其`SandBox`模块的实例从DOM中移除自身，并且它不需要自己实现此类功能。这使得组件只需专注于自己的专业任务，并利用应用程序（通过`SandBox`实例）提供的功能。这种设计也限制了组件对其自身世界之外的访问，因此我们可以最小化可能的DOM操作冲突，如前一章所述。
- en: Rendering notificationWidget
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染`notificationWidget`
- en: 'This component is rendered when `NotificationHandler` calls the render method
    of the component, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当`NotificationHandler`调用组件的渲染方法时，该组件被渲染，如下所示：
- en: '[PRE52]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Consider the implementation of this method, as shown here:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑此方法的实现，如下所示：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The component uses a method on its instance of `SandBox` module to create a
    document level component (itself), in the following line of code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用其`SandBox`模块实例上的方法创建一个文档级别的组件（即自身），如下代码行所示：
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In turn, from the `SandBox` module instance, the following method on Core module
    is called:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，从`SandBox`模块实例中，调用以下核心模块的方法：
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And a reference to the rendered component''s view is passed back from Core
    module to `renderWidget` method of the component object. The rendered component''s
    view is then tagged with an ID and its context is set on the `SandBox` module
    instance, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 并且从核心模块到组件对象的`renderWidget`方法传递了渲染组件的视图的引用。然后，渲染组件的视图被标记了一个ID，并在`SandBox`模块实例上设置了其上下文，如下所示：
- en: '[PRE56]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that it is only at this stage that the component registers for events.
    This is different than other components in the application, which register for
    events when they are initialized. The reason is because when `init` method of
    this component is called, the component's view has not yet been rendered on the
    page. Therefore, there are no HTML elements for this component's view to attach
    events to. It is only after the rendering of the component's view that we can
    attach the required event handlers to the elements.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有在这一阶段，组件才会注册事件。这与应用程序中的其他组件不同，它们在初始化时注册事件。原因是当调用此组件的 `init` 方法时，组件的视图尚未在页面上渲染。因此，没有
    HTML 元素供此组件的视图附加事件。只有在组件视图渲染之后，我们才能将所需的事件处理程序附加到元素上。
- en: This widget is an example of how we can render and activate components in the
    application at any time, after the start-up phase.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件是我们如何可以在启动阶段之后随时渲染和激活应用程序中组件的一个示例。
- en: GlobalData module
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlobalData 模块
- en: As the name implies, this module is designed to store application level data
    and act as the model for our application. It also provides public methods so that
    other modules can get and set data in this module. This module is defined as `ImagesInc_GlobalData`
    global variable in the application..
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此模块旨在存储应用程序级数据，并作为我们应用程序的模型。它还提供了公共方法，以便其他模块可以在此模块中获取和设置数据。此模块在应用程序中定义为
    `ImagesInc_GlobalData` 全局变量。
- en: 'The following shows a snippet of the kind of data that the module stores:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了模块存储的数据类型：
- en: '[PRE57]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This module is augmented with a sub-module `ImagesInc_PageSections`, which stores
    HTML markup strings related to `header` and `footer` components.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块通过子模块 `ImagesInc_PageSections` 进行增强，该子模块存储与 `header` 和 `footer` 组件相关的 HTML
    标记字符串。
- en: It is worth looking at how this sub-module is added to `GlobalData` module.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 值得关注的是，这个子模块是如何添加到 `GlobalData` 模块的。
- en: '[PRE58]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we are using asynchronous sub-module augmentation technique
    to add the sub-module to `GlobalData` module.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用异步子模块增强技术将子模块添加到 `GlobalData` 模块。
- en: This technique allows us to load `GlobalData` and its related sub-module (`ImagesInc_PageSections`)
    in any order that we desire without affecting the module's augmentation. The augmentation
    is different in comparison to how we added sub-modules to MainCore module in the
    application, as they could only be added to MainCore module after it was loaded.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使我们能够以我们希望的方式按任何顺序加载 `GlobalData` 及其相关的子模块 (`ImagesInc_PageSections`)，而不会影响模块的增强。与我们在应用程序中向
    MainCore 模块添加子模块的方式相比，增强方式不同，因为它们只能在 MainCore 模块加载后添加。
- en: 'Notice that we create the sub-module if it does not exist in the application
    when we execute the IIFE, as shown:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们执行 IIFE 时，如果子模块不存在于应用程序中，我们会创建它，如下所示：
- en: '[PRE59]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Asynchronous sub-module augmentation also allows us to augment the sub-module
    itself, if it already exists in the application. The augmentation is shown in
    the following code snippet:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 异步子模块增强还允许我们在子模块已在应用程序中存在的情况下对其进行增强。增强方式在下面的代码片段中显示：
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Admittedly, this technique is a little more complex than the other augmentation
    techniques that we have used elsewhere in the application but it does provide
    a greater degree of flexibility.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 必须承认，这种技术比我们在应用程序其他地方使用的其他增强技术要复杂一些，但它确实提供了更大的灵活性。
- en: I encourage you to have a look at the code related to this sub-module (`GlobalData_Sub.js`)
    to get a better understanding of how the technique works.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您查看与此子模块相关的代码（`GlobalData_Sub.js`），以更好地理解该技术是如何工作的。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a closer look at our application's implementation and
    saw how all the pieces fit and work together to create our modular ecosystem,
    at the code level.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更详细地研究了我们应用程序的实现，并看到了所有组件是如何相互配合，在代码层面上创建我们的模块化生态系统的。
- en: We examined how Core module (our application's controller) was created by leveraging
    different augmentation techniques and adding sub-modules to MainCore module. This
    approach allowed us to extend our application's capabilities with ease and in
    a modular way.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何通过利用不同的增强技术向 MainCore 模块添加子模块来创建 Core 模块（我们应用程序的控制器）。这种方法使我们能够轻松并以模块化的方式扩展应用程序的功能。
- en: By creating instances of `SandBox` module, we established communication bridges
    among the components and the rest of the application while preserving the loose
    coupling principle of our design.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建`SandBox`模块的实例，我们在组件和应用程序的其他部分之间建立了通信桥梁，同时保留了我们设计中的松耦合原则。
- en: One important aspect of our application, is the ability to load components dynamically
    and we discussed how such functionality has been implemented in our Core module.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的一个重要方面是能够动态加载组件，我们讨论了这种功能是如何在我们的核心模块中实现的。
- en: Using the publish-subscribe and mediator patterns, we created an event handing
    mechanism which all the pieces of the application can use to communicate with
    each other. This mechanism was also used in our client side router to change the
    views of the application.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布-订阅和中介模式，我们创建了一个事件处理机制，应用程序的所有部分都可以使用这个机制相互通信。这个机制也被用于我们的客户端路由器，以更改应用程序的视图。
- en: At the end of the chapter, we created a global module to store our application
    level data and act as the model piece of our MV* design.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们创建了一个全局模块来存储我们的应用程序级数据，并作为我们MV*设计中的模型部分。
- en: In the next chapter, we will discuss testing of our application's modules and
    will see how unit testing can help us maintain the integrity of our application
    during its development and operational phases.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论我们应用程序模块的测试，并了解单元测试如何帮助我们维护应用程序在开发和运营阶段的一致性。
