<html><head></head><body>
<div id="_idContainer080" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor199" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor200" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Micro Frontends, Zones, and Islands Architectures</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">The micro frontend architecture, and specifically the “zones” and “islands” patterns, mirror the microservices architecture for backend systems. </span><span class="kobospan" id="kobo.3.2">Given the right tooling, they allow multiple teams to maintain high-velocity development on a single product. </span><span class="kobospan" id="kobo.3.3">The techniques covered in this chapter look at system-level interaction and integration patterns. </span><span class="kobospan" id="kobo.3.4">Each system can leverage creational, structural, behavioral, and reactive view library patterns, as covered in </span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapters</span></em> <em class="italic"><span class="kobospan" id="kobo.5.1">1</span></em><span class="kobospan" id="kobo.6.1">, </span><em class="italic"><span class="kobospan" id="kobo.7.1">2</span></em><span class="kobospan" id="kobo.8.1">, </span><em class="italic"><span class="kobospan" id="kobo.9.1">3</span></em><span class="kobospan" id="kobo.10.1">, and </span><em class="italic"><span class="kobospan" id="kobo.11.1">4</span></em><span class="kobospan" id="kobo.12.1"> respectively. </span><span class="kobospan" id="kobo.12.2">Micro frontend architectures help link systems together as opposed to structuring the code within each of </span><span><span class="kobospan" id="kobo.13.1">them better.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">We’ll cover the following topics in </span><span><span class="kobospan" id="kobo.15.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.16.1">The problem space that micro frontends address, including some common approaches and </span><span><span class="kobospan" id="kobo.17.1">their drawbacks</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Leveraging Next.js features to build a “zones” micro </span><span><span class="kobospan" id="kobo.19.1">frontend setup</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.20.1">Using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.21.1">is-land</span></strong><span class="kobospan" id="kobo.22.1"> package to deliver an “islands” micro frontend setup with islands in Preact </span><span><span class="kobospan" id="kobo.23.1">and Vue.js</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">By the end of this chapter, you’ll be able to discuss the trade-offs and deliver modern micro frontend approaches </span><span><span class="kobospan" id="kobo.25.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-106" class="calibre5"><a id="_idTextAnchor201" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.26.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.28.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.29.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor202" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.30.1">An overview of micro frontends</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">A micro frontend setup</span><a id="_idIndexMarker326" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.32.1"> is one where multiple frontend applications or components are composed. </span><span class="kobospan" id="kobo.32.2">This is akin to microservices, where a micro frontend would encapsulate a subset of functionality, or “</span><span><span class="kobospan" id="kobo.33.1">bounded context.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">For example, in an e-commerce setting, we might have a “search” micro frontend and a “cart” or “checkout” </span><span><span class="kobospan" id="kobo.35.1">micro frontend.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer065">
<span class="kobospan" id="kobo.36.1"><img alt="Figure 6.1: A simplified micro frontends diagram" src="image/B19109_06_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.37.1">Figure 6.1: A simplified micro frontends diagram</span></p>
<p class="calibre3"><a id="_idTextAnchor203" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.38.1">We’ve now introduced the micro frontends architecture; next, we’ll see at the key benefits micro </span><span><span class="kobospan" id="kobo.39.1">frontends deliver.</span></span></p>
<h2 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor204" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.40.1">Key benefits</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">The benefits of the micro frontend</span><a id="_idIndexMarker327" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.42.1"> patterns are similar to microservice benefits. </span><span class="kobospan" id="kobo.42.2">They usually come in the sociotechnical aspect </span><span><span class="kobospan" id="kobo.43.1">of development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.44.1">Each micro frontend can use a different set of technologies, which means the right tool for the job can be selected. </span><span class="kobospan" id="kobo.44.2">A very page-load performance-sensitive page might use a different stack than an admin interface or a high-volume SVG </span><span><span class="kobospan" id="kobo.45.1">visualization page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Incremental upgrades are available, and changes can be tested in one component before being rolled out to </span><span><span class="kobospan" id="kobo.47.1">all components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">The releases of different micro frontends are not locked together. </span><span class="kobospan" id="kobo.48.2">This can help when scaling, where each team might work on one or more of the micro frontends. </span><span class="kobospan" id="kobo.48.3">They can be released independently of other teams, meaning the cadence can increase; this is related to the last benefit </span><span><span class="kobospan" id="kobo.49.1">we’ll discuss.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">Each micro frontend can have</span><a id="_idIndexMarker328" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.51.1"> its own code base, and “bounded contexts” can be </span><span><span class="kobospan" id="kobo.52.1">strictly enforced</span><a id="_idTextAnchor205" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.53.1">.</span></span></p>
<h2 id="_idParaDest-109" class="calibre7"><a id="_idTextAnchor206" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.54.1">“Classic” micro frontend patterns</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.55.1">We’ll cover five</span><a id="_idIndexMarker329" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.56.1"> different “classic” approaches</span><a id="_idIndexMarker330" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.57.1"> to creating a micro </span><span><span class="kobospan" id="kobo.58.1">frontend setup.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">The first is the “container application” using server-side includes. </span><span class="kobospan" id="kobo.59.2">This leverages a server that will fetch from the different micro frontends and stitch them together. </span><span class="kobospan" id="kobo.59.3">This is illustrated in the following diagram, where the container application loads a “cart” HTML section and a “search” HTML section and injects them into its own template, before returning to </span><span><span class="kobospan" id="kobo.60.1">the client.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer066">
<span class="kobospan" id="kobo.61.1"><img alt="Figure 6.2: The “container application” sequence" src="image/B19109_06_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.62.1">Figure 6.2: The “container application” sequence</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">The benefits of server-side include, or the “container application,” is that deployments of each micro frontend are decoupled (e.g., we can deploy changes to the cart without deploying changes to the search section or the container); in addition, it’s completely technology-agnostic, as micro frontends don’t even need to </span><span><span class="kobospan" id="kobo.64.1">use JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">The next “classic” approach we’ll see is different, using “build-time composition,” where each micro frontend is a package, usually a npm package (part of the Node.js/JavaScript toolchain). </span><span class="kobospan" id="kobo.65.2">Each package is then imported where necessary and composed at “build-time” (when each application is packaged </span><span><span class="kobospan" id="kobo.66.1">for deployment).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">The key drawback of “build-time” composition</span><a id="_idIndexMarker331" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.68.1"> is that releases now require deployment</span><a id="_idIndexMarker332" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.69.1"> cascades. </span><span class="kobospan" id="kobo.69.2">For all the applications to receive updates to the “cart”, we need to update the version and release all </span><span><span class="kobospan" id="kobo.70.1">the applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.71.1">The three final “classic” approaches are similar conceptually although use different technologies. </span><span class="kobospan" id="kobo.71.2">They’re all “runtime integrations”; the technologies are iframes, JavaScript, and web components. </span><span class="kobospan" id="kobo.71.3">Runtime integrations mean that the micro frontend requests the micro frontend resource from </span><span><span class="kobospan" id="kobo.72.1">the browser.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">In the case of iframes, this involves using the iframe </span><strong class="source-inline"><span class="kobospan" id="kobo.74.1">src</span></strong><span class="kobospan" id="kobo.75.1"> attribute. </span><span class="kobospan" id="kobo.75.2">The main downside of this is that each micro frontend needs to be secured against all public network exploits. </span><span class="kobospan" id="kobo.75.3">What’s more, allowing the iframing of an application’s content can lead to click-jacking vulnerabilities if not done carefully, so there are </span><span><span class="kobospan" id="kobo.76.1">security implications.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer067">
<span class="kobospan" id="kobo.77.1"><img alt="Figure 6.3: Runtime integration with iframes" src="image/B19109_06_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.78.1">Figure 6.3: Runtime integration with iframes</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">In the case of JavaScript</span><a id="_idIndexMarker333" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.80.1"> or Web Component “runtime” integration, the composition</span><a id="_idIndexMarker334" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.81.1"> is managed by loading JavaScript files. </span><span class="kobospan" id="kobo.81.2">This is more ideal than using iframes, since serving JavaScript to the browser has fewer security implications than allowing the framing of your content. </span><span class="kobospan" id="kobo.81.3">In the Web Components case, you would have both the web component referenced in the body of the HTML and a reference to the scripts required to run the </span><span><span class="kobospan" id="kobo.82.1">Web Component.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer068">
<span class="kobospan" id="kobo.83.1"><img alt="Figure 6.4: Runtime integration with JavaScript or web components" src="image/B19109_06_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.84.1">Figure 6.4: Runtime integration with JavaScript or web components</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">Runtime integrations have a performance</span><a id="_idIndexMarker335" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.86.1"> impact on the user experience, as shown by the difference</span><a id="_idIndexMarker336" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.87.1"> in diagrams between our “server-side includes” and “runtime integration” diagrams. </span><span class="kobospan" id="kobo.87.2">In the “server-side includes” case, the server composes a full application before returning it to the customer. </span><span class="kobospan" id="kobo.87.3">In the “runtime integration”, the server returns what are essentially resource references to the browser, which then has to load </span><span><span class="kobospan" id="kobo.88.1">these resources.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">As we explore the “zones” and “islands” modern</span><a id="_idIndexMarker337" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.90.1"> implementations of micro</span><a id="_idIndexMarker338" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.91.1"> frontends, we’ll encounter several instances of these techniques </span><span><span class="kobospan" id="kobo.92.1">used t</span><a id="_idTextAnchor207" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.93.1">ogether.</span></span></p>
<h2 id="_idParaDest-110" class="calibre7"><a id="_idTextAnchor208" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.94.1">Other concerns in a micro frontend world</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">Similar to a microservice</span><a id="_idIndexMarker339" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.96.1"> setup, micro frontends that allow different teams to build in their own way can be a benefit and </span><span><span class="kobospan" id="kobo.97.1">a drawback.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">At the end of the day, most frontend systems will need to communicate with a backend service. </span><span class="kobospan" id="kobo.98.2">How to do this remains something </span><a id="_idIndexMarker340" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.99.1">to be decided – should each team deploy its own </span><strong class="bold"><span class="kobospan" id="kobo.100.1">backend for frontend</span></strong><span class="kobospan" id="kobo.101.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.102.1">BFF</span></strong><span class="kobospan" id="kobo.103.1">), should a single gateway be deployed that exposes relevant service endpoints, or should it be a gateway that wraps services in a different query system such </span><span><span class="kobospan" id="kobo.104.1">as GraphQL?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.105.1">Micro frontends also cause challenges for testing. </span><span class="kobospan" id="kobo.105.2">How do we reliably test at the “user journey” level, which might go through multiple micro frontends, when each of the micro frontends also has its own </span><span><span class="kobospan" id="kobo.106.1">test suite?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.107.1">Similar to the questions about which backend integrations to use, there’s a challenge related to shared styles and potentially component libraries. </span><span class="kobospan" id="kobo.107.2">Teams doing micro frontends might standardize on a set technology (React, Vue, etc) in order to gain the benefits of a component library. </span><span class="kobospan" id="kobo.107.3">Component libraries are more difficult to maintain in multiple technologies, but companies sometimes opt for this to support their engineers in picking the right tool for </span><span><span class="kobospan" id="kobo.108.1">the job.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">One big challenge of micro frontends is how to keep them performant. </span><span class="kobospan" id="kobo.109.2">Even in a case where all teams use the same technologies, it’s likely that the same dependency is duplicated across micro frontends, which has a performance impact. </span><span class="kobospan" id="kobo.109.3">When technologies and build and deploy processes diverge (which is possible with micro frontends), this problem </span><span><span class="kobospan" id="kobo.110.1">is exacerbated.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.111.1">The other performance issue that occurs with, for example, “server-side includes” is that the page will only load as fast as the slowest component on the page. </span><span class="kobospan" id="kobo.111.2">This is less of an issue with runtime integrations, but the idea that each micro frontend might affect a whole page’s performance is a relevant one with regard to the challenges of building a system using </span><span><span class="kobospan" id="kobo.112.1">micro frontends.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">Finally, as we’ve alluded to with regard to testing micro frontends, it causes operational and governance complexities. </span><span class="kobospan" id="kobo.113.2">For example, environment mismatch issues are harder to detect. </span><span class="kobospan" id="kobo.113.3">Running or deploying a full environment for development or testing with multiple micro frontends is more complex than with a </span><span><span class="kobospan" id="kobo.114.1">monolithic application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.115.1">Now that we’ve defined and contrasted</span><a id="_idIndexMarker341" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.116.1"> the benefits and drawbacks of micro frontends in general and specific micro frontend approaches, we can look at modern implementations of micro frontends. </span><span class="kobospan" id="kobo.116.2">In the following section, we’ll look at leveraging Next.js and “zones” in order to build flexible </span><span><span class="kobospan" id="kobo.117.1">micro</span><a id="_idTextAnchor209" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.118.1"> frontends.</span></span></p>
<h1 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor210" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.119.1">Composing applications with Next.js “zones”</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">Next.js “zones” are a URL “base path”-driven approach to composing Next.js</span><a id="_idIndexMarker342" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.121.1"> applications. </span><span class="kobospan" id="kobo.121.2">This allows us to build a micro frontend setup </span><span><span class="kobospan" id="kobo.122.1">with Next.js.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">What this means, as shown in the figure that follows, is that an e-commerce use case, where the user might request four sets of URLs (</span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">GET /, GET /careers, GET /search, and GET /cart/{id}), "{id}"</span></strong><span class="kobospan" id="kobo.125.1">), denotes that the cart has a dynamic segment, which is the cart ID that is requested. </span><span class="kobospan" id="kobo.125.2">For </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">GET /</span></strong><span class="kobospan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">GET /careers</span></strong><span class="kobospan" id="kobo.129.1">, the request first goes to the </span><strong class="source-inline"><span class="kobospan" id="kobo.130.1">root</span></strong><span class="kobospan" id="kobo.131.1"> frontend, which handles rendering directly. </span><span class="kobospan" id="kobo.131.2">For </span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">GET /search</span></strong><span class="kobospan" id="kobo.133.1">, the request goes to the root frontend, which forwards the request to the search frontend. </span><span class="kobospan" id="kobo.133.2">Similarly, for </span><strong class="source-inline"><span class="kobospan" id="kobo.134.1">GET /cart/{id}</span></strong><span class="kobospan" id="kobo.135.1"> requests, the request initially is sent to the root frontend, which proxies the request to the </span><span><span class="kobospan" id="kobo.136.1">checkout frontend.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<span class="kobospan" id="kobo.137.1"><img alt="Figure 6.5: An overview flowchart of a three-app Next.js﻿ zone setup" src="image/B19109_06_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.138.1">Figure 6.5: An overview flowchart of a three-app Next.js</span><a id="_idTextAnchor211" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.139.1"> zone setup</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.140.1">We’ve now introduced</span><a id="_idIndexMarker343" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.141.1"> Next.js “zones” and an overview of our implementation, next we’ll implement the “</span><span><span class="kobospan" id="kobo.142.1">root app”.</span></span></p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor212" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.143.1">Root app</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">The root app contains</span><a id="_idIndexMarker344" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.145.1"> two pages, </span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">/</span></strong><span class="kobospan" id="kobo.147.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">pages/index.js</span></strong><span class="kobospan" id="kobo.149.1">) and </span><strong class="source-inline"><span class="kobospan" id="kobo.150.1">/careers</span></strong><span class="kobospan" id="kobo.151.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">pages/careers.js</span></strong><span class="kobospan" id="kobo.153.1">). </span><span class="kobospan" id="kobo.153.2">Both of these pages are statically rendered, </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">index.js</span></strong><span class="kobospan" id="kobo.155.1"> via automatic static generation (since it doesn’t have </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.157.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.158.1">getInitialProps</span></strong><span class="kobospan" id="kobo.159.1">) and </span><strong class="source-inline"><span class="kobospan" id="kobo.160.1">careers.js</span></strong><span class="kobospan" id="kobo.161.1"> via static site generation (since it </span><span><span class="kobospan" id="kobo.162.1">has </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.163.1">getStaticProps</span></strong></span><span><span class="kobospan" id="kobo.164.1">).</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.165.1">index.js</span></strong><span class="kobospan" id="kobo.166.1"> contains a heading as well as </span><span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">Head</span></strong></span><span><span class="kobospan" id="kobo.168.1"> content.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.169.1">
import React from 'react';
import Head from 'next/head';
export default function Home() {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Homepage (Root zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Root&lt;/h1&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.170.1">When we load the </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">GET</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.172.1">/</span></strong><span class="kobospan" id="kobo.173.1"> path, our root app </span><a id="_idIndexMarker345" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.174.1">renders the </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">h1</span></strong><span class="kobospan" id="kobo.176.1"> element we placed within it, with </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">'Root'</span></strong><span class="kobospan" id="kobo.178.1"> as </span><span><span class="kobospan" id="kobo.179.1">its content.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<span class="kobospan" id="kobo.180.1"><img alt="Figure 6.6: The Root page rendered" src="image/B19109_06_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.181.1">Figure 6.6: The Root page rendered</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.182.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">/careers</span></strong><span class="kobospan" id="kobo.184.1"> page loads roles from an API using </span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">getStaticProps</span></strong><span class="kobospan" id="kobo.186.1"> and displays them in </span><span><span class="kobospan" id="kobo.187.1">a list.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">We can start with a </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">getStaticProps</span></strong><span class="kobospan" id="kobo.190.1"> function</span><a id="_idIndexMarker346" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.191.1"> in </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">pages/careers.js</span></strong><span class="kobospan" id="kobo.193.1">. </span><span class="kobospan" id="kobo.193.2">This function loads from a “fake jobs” API and returns a </span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">roles</span></strong><span class="kobospan" id="kobo.195.1"> prop, which includes the returned data from </span><span><span class="kobospan" id="kobo.196.1">the API:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.197.1">
export async function getStaticProps() {
  const jobs = await fetch(
    'https://apis.camillerakoto.fr/fakejobs/
      jobs?fulltime=true').then((res) =&gt; res.json());
  return {
    props: { roles: jobs },
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.198.1">Next, we’ll add a </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">CareersPages</span></strong><span class="kobospan" id="kobo.200.1"> component. </span><span class="kobospan" id="kobo.200.2">It includes the page scaffolding with </span><strong class="source-inline"><span class="kobospan" id="kobo.201.1">title</span></strong><span class="kobospan" id="kobo.202.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">h1</span></strong><span class="kobospan" id="kobo.204.1">. </span><span class="kobospan" id="kobo.204.2">It also loops through the </span><strong class="source-inline"><span class="kobospan" id="kobo.205.1">roles</span></strong><span class="kobospan" id="kobo.206.1"> prop to render it as a list, using </span><strong class="source-inline"><span class="kobospan" id="kobo.207.1">ul</span></strong> <span><span class="kobospan" id="kobo.208.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">li</span></strong></span><span><span class="kobospan" id="kobo.210.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.211.1">
import React from 'react';
import Head from 'next/head';
export default function CareersPage({ roles }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Careers (Root zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Careers&lt;/h1&gt;
        &lt;ul&gt;
          {roles.map((role) =&gt; {
            return (
              &lt;li key={role.id}&gt;
                {role.title} ({role.country})
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.212.1">It displays</span><a id="_idIndexMarker347" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.213.1">as follows.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<span class="kobospan" id="kobo.214.1"><img alt="Figure 6.7: The Careers page in the root zone" src="image/B19109_06_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.215.1">Figure 6.7: The Careers page in the root zone</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.216.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">next build</span></strong><span class="kobospan" id="kobo.218.1"> output shows that </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">index.js</span></strong><span class="kobospan" id="kobo.220.1"> is indeed statically</span><a id="_idIndexMarker348" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.221.1"> rendered, while </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">/</span></strong><strong class="source-inline"><span class="kobospan" id="kobo.223.1">careers</span></strong><span class="kobospan" id="kobo.224.1"> uses static </span><span><span class="kobospan" id="kobo.225.1">site generation:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.226.1">
Route (pages)                              Size     First Load JS
┌ ○ /                                      430 B          77.7 kB
├ ○ /404                                   182 B          77.5 kB
├ λ /api/health                            0 B            77.3 kB
└ ● /careers                               498 B          77.8 kB
+ First Load JS shared by all              77.3 kB
  ├ chunks/framework-4725d5bb117f1d8e.js   45.2 kB
  ├ chunks/main-7a398668474d4dd1.js        31.1 kB
  ├ chunks/pages/_app-ecd5712b2c05cb6a.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses </span><a id="_idTextAnchor213" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.227.1">getStaticProps)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.228.1">We’ve now started implementing</span><a id="_idIndexMarker349" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.229.1"> the root app, we’ll move on to our second zone, the “</span><span><span class="kobospan" id="kobo.230.1">search” zone.</span></span></p>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor214" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.231.1">Adding a /search app</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.232.1">Next, we’ll build</span><a id="_idIndexMarker350" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.233.1"> and mount a </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">/</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">search</span></strong></span><span><span class="kobospan" id="kobo.236.1"> page.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.237.1">search/pages/index.js</span></strong><span class="kobospan" id="kobo.238.1"> displays an input and makes a call to the </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">/search/api/search</span></strong><span class="kobospan" id="kobo.240.1"> route </span><span><span class="kobospan" id="kobo.241.1">on change:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.242.1">
import React, { useState } from 'react';
import Head from 'next/head';
export default function Home() {
  const [searchResult, setSearchResult] = useState({
    count: 0,
    matches: [],
  });
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Search Page (Search zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Search&lt;/h1&gt;
        &lt;input
          type="search"
          onChange={async (event) =&gt; {
            const data = await fetch(
              `/search/api/search?q=${event.target.value}`
            ).then((res) =&gt; res.json());
            setSearchResult(data);
          }}
        /&gt;
        &lt;div&gt;
          &lt;h2&gt;Results ({searchResult.count})&lt;/h2&gt;
          {searchResult.matches.map((product) =&gt; {
            return &lt;div key={product.id}&gt;
              {product.title}&lt;/div&gt;;
          })}
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.243.1">To implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">search/pages/api/search</span></strong><span class="kobospan" id="kobo.245.1"> API route, we create </span><strong class="source-inline"><span class="kobospan" id="kobo.246.1">pages/api/search</span></strong><span class="kobospan" id="kobo.247.1">, which loads</span><a id="_idIndexMarker351" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.248.1"> products from </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">fakestoreapi</span></strong><span class="kobospan" id="kobo.250.1"> and finds a match between the title, description </span><span><span class="kobospan" id="kobo.251.1">and category:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.252.1">
export default async function handler(req, res) {
  const allProducts = await fetch
    ('https://fakestoreapi.com/products').then(
      (res) =&gt; res.json()
  );
  const { q } = req.query;
  const searchQuery = Array.isArray(q) ? </span><span class="kobospan1" id="kobo.252.2">q[0] : q;
  const matches = allProducts.filter(
    (product) =&gt;
      product.title.includes(searchQuery) ||
      product.description.includes(searchQuery) ||
      product.category.includes(searchQuery)
  );
  return res.status(200).json({ matches,
    count: matches.length });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.253.1">In order for </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">search-app/</span></strong><span class="kobospan" id="kobo.255.1"> to be mounted under </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">search-app/search</span></strong><span class="kobospan" id="kobo.257.1">, we’ll use </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">basePath</span></strong><span class="kobospan" id="kobo.259.1"> in </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">next.config.js</span></strong><span class="kobospan" id="kobo.261.1"> in the </span><span><span class="kobospan" id="kobo.262.1">search app:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.263.1">
module.exports = {
  basePath: '/search',
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.264.1">We’ll expose </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">search</span></strong><span class="kobospan" id="kobo.266.1"> via the root</span><a id="_idIndexMarker352" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.267.1">app’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">next.config.js</span></strong></span><span><span class="kobospan" id="kobo.269.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.270.1">
module.exports = {
  async rewrites() {
    return [
      {
        source: '/search/:path*',
        destination: 'http://localhost:3001/search/:path*',
      },
    ];
  },
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.271.1">We can then load the </span><strong class="bold"><span class="kobospan" id="kobo.272.1">Search</span></strong><span class="kobospan" id="kobo.273.1"> page, which displays </span><span><span class="kobospan" id="kobo.274.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer072">
<span class="kobospan" id="kobo.275.1"><img alt="Figure 6.8: The Search page on load" src="image/B19109_06_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.276.1">Figure 6.8: The Search page on load</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.277.1">The search works – for example, with the </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">jacket</span></strong> <span><span class="kobospan" id="kobo.279.1">search term.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer073">
<span class="kobospan" id="kobo.280.1"><img alt="Figure 6.9: The Search page with the jacket search term" src="image/B19109_06_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.281.1">Figure 6.9: The Search page with the jacket search term</span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.282.1">/search</span></strong><span class="kobospan" id="kobo.283.1"> is statically rendered</span><a id="_idIndexMarker353" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.284.1"> via automatic </span><span><span class="kobospan" id="kobo.285.1">static rendering:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.286.1">
Route (pages)                              Size     First Load JS
┌ ○ /                                      607 B          73.7 kB
├   └ css/776983a5dfcef528.css             271 B
├ ○ /404                                   182 B          73.2 kB
├ λ /api/health                            0 B            73.1 kB
└ λ /api/search                            0 B            73.1 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-4725d5bb117f1d8e.js   45.2 kB
  ├ chunks/main-ee0b7fc0f7162449.js        26.9 kB
  ├ chunks/pages/_app-ecd5712b2c05cb6a.js  195 B
  └ chunks/webpack-ab5c478f511867a3.js     756 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses</span><a id="_idTextAnchor215" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.287.1"> no initial props)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.288.1">We’ve now implemented</span><a id="_idIndexMarker354" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.289.1"> the search “zone”, next we’ll implement the </span><span><span class="kobospan" id="kobo.290.1">checkout “zone”.</span></span></p>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor216" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.291.1">Adding /checkout app</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.292.1">We’ll add a “view cart” page</span><a id="_idIndexMarker355" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.293.1"> in a new checkout Next.js app </span><span><span class="kobospan" id="kobo.294.1">under </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">pages/cart/[id].js</span></strong></span><span><span class="kobospan" id="kobo.296.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.297.1">The cart page loads a cart and its contained products from </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">fakestoreapi</span></strong><span class="kobospan" id="kobo.299.1">, displaying them via a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">CartContents</span></strong></span><span><span class="kobospan" id="kobo.301.1"> component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.302.1">First, we’ll define a </span><strong class="source-inline"><span class="kobospan" id="kobo.303.1">CartContents</span></strong><span class="kobospan" id="kobo.304.1"> component that takes </span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">cart</span></strong><span class="kobospan" id="kobo.306.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">productsById</span></strong><span class="kobospan" id="kobo.308.1"> props. </span><span class="kobospan" id="kobo.308.2">It then maps through </span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">cart.products</span></strong><span class="kobospan" id="kobo.310.1">, extracting the product’s title and the quantity requested in the cart, before computing and formatting the price in euros </span><span><span class="kobospan" id="kobo.311.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">.toLocaleString</span></strong></span><span><span class="kobospan" id="kobo.313.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">The reason we need </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">cart</span></strong><span class="kobospan" id="kobo.316.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.317.1">productsById</span></strong><span class="kobospan" id="kobo.318.1"> is that the cart comes back in a normalized data format, meaning it contains only cart-specific information and none of the related product’s information, except the product ID. </span><span class="kobospan" id="kobo.318.2">Therefore, we need to do a lookup based on the </span><span><span class="kobospan" id="kobo.319.1">product ID.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.320.1">Our rendering logic uses an unordered list container (the </span><strong class="source-inline"><span class="kobospan" id="kobo.321.1">ul</span></strong><span class="kobospan" id="kobo.322.1"> HTML element) and list item elements (</span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">li</span></strong><span class="kobospan" id="kobo.324.1"> HTML elements). </span><span class="kobospan" id="kobo.324.2">We render the title in an </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">h3</span></strong><span class="kobospan" id="kobo.326.1"> heading and the rest of the information using </span><span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">span</span></strong></span><span><span class="kobospan" id="kobo.328.1"> elements:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.329.1">
import React from 'react';
function CartContents(props) {
  const { cart, productsById } = props;
  return (
    &lt;ul&gt;
      {cart.products.map((product) =&gt; {
        const fullProductInformation = productsById
          [product.productId];
        return (
          &lt;li key={product.productId} className=
            "cart-item-product"&gt;
            &lt;h3 className="cart-item-product-name"&gt;
              {fullProductInformation?.title}
            &lt;/h3&gt;
            &lt;span className="cart-item-product-quantity"&gt;
              {' '}
              x {product.quantity}
            &lt;/span&gt;
            &lt;span className="cart-item-product-price"&gt;
              Price:
              {(
                product.quantity *
                  fullProductInformation?.price)
                  .toLocaleString('en', {
                style: 'currency',
                currency: 'EUR',
              })}
            &lt;/span&gt;
          &lt;/li&gt;
        );
      })}
    &lt;/ul&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.330.1">Now that we’re rendering the contents</span><a id="_idIndexMarker356" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.331.1"> of the cart, the additional functionality we’ll add to </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">CartContents</span></strong><span class="kobospan" id="kobo.333.1"> is a display of the cart’s </span><span><span class="kobospan" id="kobo.334.1">total price.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.335.1">This is done by adding another </span><strong class="source-inline"><span class="kobospan" id="kobo.336.1">li</span></strong><span class="kobospan" id="kobo.337.1">, which displays “Total:” and computes the total price, using </span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">reduce</span></strong><span class="kobospan" id="kobo.339.1"> over </span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">cart.products</span></strong><span class="kobospan" id="kobo.341.1">. </span><span class="kobospan" id="kobo.341.2">Remember from the previous code block that </span><strong class="source-inline"><span class="kobospan" id="kobo.342.1">cart.products</span></strong><span class="kobospan" id="kobo.343.1"> is normalized, meaning that it doesn’t contain any information about the product (e.g., its price), apart from the product’s ID. </span><span class="kobospan" id="kobo.343.2">This means that our reduce handler does a lookup on </span><strong class="source-inline"><span class="kobospan" id="kobo.344.1">productsById[product.productId]</span></strong><span class="kobospan" id="kobo.345.1"> in order to access the </span><span><span class="kobospan" id="kobo.346.1">product’s price.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.347.1">Once we have the quantity of a given product in the cart and the price of the product, we simply multiply them together and sum the quantity times the price result to the accumulator, which we initialized </span><span><span class="kobospan" id="kobo.348.1">as 0.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.349.1">Similar to the cart items, we use </span><strong class="source-inline"><span class="kobospan" id="kobo.350.1">toLocaleString</span></strong><span class="kobospan" id="kobo.351.1"> to format the total price in euros as an en </span><span><span class="kobospan" id="kobo.352.1">localized string:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.353.1">
// no change to imports
function CartContents(props) {
  // no change to the function body
  return (
    &lt;ul&gt;
      {/* no change to `cart.products` mapping */}
      &lt;li className="cart-item-product"&gt;
        &lt;strong className="cart-item-product-price"&gt;
          Total:
          {cart.products
            .reduce((acc, curr) =&gt; {
              const fullProductInformation = productsById
                [curr.productId];
              return acc + curr.quantity *
                fullProductInformation.price;
            }, 0)
            .toLocaleString('en', {
              style: 'currency',
              currency: 'EUR',
            })}
        &lt;/strong&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.354.1">We’ll leverage </span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.356.1"> to load the cart, and then the relevant</span><a id="_idIndexMarker357" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.357.1"> products from </span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">fakestoreapi</span></strong><span class="kobospan" id="kobo.359.1">. </span><span class="kobospan" id="kobo.359.2">As mentioned in the previous code blocks, </span><strong class="source-inline"><span class="kobospan" id="kobo.360.1">fakestoreapi</span></strong><span class="kobospan" id="kobo.361.1">’s cart response is normalized and, therefore, doesn’t include all the product data we need, which is why we load the products </span><span><span class="kobospan" id="kobo.362.1">by ID.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Once we have a cart response</span><a id="_idIndexMarker358" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.364.1"> and all relevant product responses, we process the products to allow them to be looked up by ID. </span><span class="kobospan" id="kobo.364.2">Finally, </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.366.1"> returns </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">id</span></strong><span class="kobospan" id="kobo.368.1"> (the cart ID from the Next.js context), </span><strong class="source-inline"><span class="kobospan" id="kobo.369.1">productsById</span></strong><span class="kobospan" id="kobo.370.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.371.1">cart</span></strong><span class="kobospan" id="kobo.372.1"> in a </span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">props</span></strong><span class="kobospan" id="kobo.374.1"> property of an object so that Next.js can pass them to our </span><span><span class="kobospan" id="kobo.375.1">page component:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.376.1">
// no changes to imports
// no changes to CartContents definition
export async function getServerSideProps(ctx) {
  const { params } = ctx;
  const cartId = params.id;
  const cart = await fetch(`https://fakestoreapi.com/carts
    /${cartId}`).then(
    (res) =&gt; res.json()
  );
  if (!cart?.products) {
    return {
      props: {
        id: cartId,
      },
    };
  }
  const productsById = (
    await Promise.all(
      cart.products.map(async (product) =&gt; {
        return await fetch(
          `https://fakestoreapi.com/products/$
             {product.productId}`
        ).then((res) =&gt; res.json());
      })
    )
  ).reduce((acc, curr) =&gt; {
    acc[curr.id] = curr;
    return acc;
  }, {});
  return {
    props: {
      id: cartId,
      cart,
      productsById,
    },
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.377.1">Finally, we’ll add our </span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">GetCartPage</span></strong><span class="kobospan" id="kobo.379.1"> component, which will take props</span><a id="_idIndexMarker359" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.380.1"> as passed by Next.js (based on the output of </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.382.1">), and we’ll use them to render </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">CartContents</span></strong><span class="kobospan" id="kobo.384.1">, as well as a heading </span><span><span class="kobospan" id="kobo.385.1">and title:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.386.1">
import Head from 'next/head';
import React from 'react';
// no changes to CartContents definition
export default function GetCartPage({ id, cart, productsById }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;GetCartPage (Checkout zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;GetCartPage (Checkout zone)&lt;/h1&gt;
        &lt;CartContents cart={cart} productsById=
          {productsById} /&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}
// no changes to getServerSideProps definition</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.387.1">For the checkout app to mount</span><a id="_idIndexMarker360" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.388.1"> under the right path, we set </span><strong class="source-inline"><span class="kobospan" id="kobo.389.1">basePath</span></strong><span class="kobospan" id="kobo.390.1"> in </span><span><span class="kobospan" id="kobo.391.1">its </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">next.config.js</span></strong></span><span><span class="kobospan" id="kobo.393.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.394.1">
module.exports = {
  basePath: '/checkout',
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.395.1">We again need to modify the root app’s </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">next.config.js</span></strong><span class="kobospan" id="kobo.397.1"> so that relevant requests are proxied to the </span><span><span class="kobospan" id="kobo.398.1">checkout app:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.399.1">
module.exports = {
  async rewrites() {
    return [
      // no change to other entries
      {
        source: '/checkout/:path*',
       destination:'http://localhost:3002/checkout/:path*',
      },
    ];
  },
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.400.1">We can load </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">/checkout/cart/2</span></strong><span class="kobospan" id="kobo.402.1">, and the following</span><a id="_idIndexMarker361" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.403.1">will display:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer074">
<span class="kobospan" id="kobo.404.1"><img alt="Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded" src="image/B19109_06_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.405.1">Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.406.1">In the build output, we can see that </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">/cart/[id]</span></strong><span class="kobospan" id="kobo.408.1"> is server-side rendered, since it </span><span><span class="kobospan" id="kobo.409.1">uses </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">getServerSideProps</span></strong></span><span><span class="kobospan" id="kobo.411.1">:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.412.1">
Route (pages)                              Size     First Load JS
┌ ○ /                                      445 B          73.5 kB
├ ○ /404                                   182 B          73.3 kB
└ λ /cart/[id]                             3.95 kB          77 kB
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTM</span><a id="_idTextAnchor217" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.413.1">L (uses no initial props)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.414.1">We’ve now seen how to add a checkout “zone” to our micro frontend</span><a id="_idIndexMarker362" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.415.1"> setup, next we’ll cover the benefits of a micro frontend “zones” architecture specifically with regards to working in </span><span><span class="kobospan" id="kobo.416.1">growing teams.</span></span></p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor218" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.417.1">The benefits/supporting team scaling</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">Using “zones” with </span><strong class="source-inline"><span class="kobospan" id="kobo.419.1">basePath</span></strong><span class="kobospan" id="kobo.420.1"> means that Next.js features</span><a id="_idIndexMarker363" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.421.1"> work out of the box. </span><span class="kobospan" id="kobo.421.2">For example, client-side transitions and </span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.423.1"> re-fetches work (where Next.js loads </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">{basePath}/_next/...</span></strong><span class="kobospan" id="kobo.425.1">) as well as the API routes that we used in the </span><span><span class="kobospan" id="kobo.426.1">search example.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">Adding new pages also “just works”; a new page at </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">/cart/[id]/checkout</span></strong><span class="kobospan" id="kobo.429.1"> wouldn’t require any changes to the root app to be available </span><span><span class="kobospan" id="kobo.430.1">to users.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">The only time we would change the root application config is to add a whole new app (top-level path) – for example, if we wanted an admin app, we would need to create that and configure the </span><span><span class="kobospan" id="kobo.432.1">root </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">next.config.js</span></strong></span><span><span class="kobospan" id="kobo.434.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.435.1">In the case where there’s a lot of traffic to applications and we want to be more efficient with our resource, we don’t need to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">root</span></strong><span class="kobospan" id="kobo.437.1"> app to forward all requests to the other micro frontends; we could leverage any reverse proxy (web servers such as NGINX and Caddy) or even the infrastructure provider’s CDN (e.g., Fastly, Akamai, Cloudflare and AWS) can be configured to forward all requests from </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">domain.tld/{path}/*</span></strong><span class="kobospan" id="kobo.439.1"> (all requests to </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">domain.tld</span></strong><span class="kobospan" id="kobo.441.1"> starting with </span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">{path}</span></strong><span class="kobospan" id="kobo.443.1">) to a </span><span><span class="kobospan" id="kobo.444.1">specific origin.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.445.1">By having a suite of applications that all use Next.js, pages can be built in the root app experimentally and then spun off to a full </span><span><span class="kobospan" id="kobo.446.1">Next.js application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.447.1">For debugging and communication purposes, having the app name in the URL can help when discussing apps and pages with technical and non-technical team members. </span><span class="kobospan" id="kobo.447.2">For example, even non-technical team members will understand that “this first section of the URL is the </span><span><span class="kobospan" id="kobo.448.1">application name.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.449.1">One other benefit of using zones is that that request is not rewritten during a reverse-proxy pass. </span><span class="kobospan" id="kobo.449.2">For example, in some setups, the reverse proxy would receive </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">/search</span></strong><span class="kobospan" id="kobo.451.1"> but load </span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">/</span></strong><span class="kobospan" id="kobo.453.1"> on the search app. </span><span class="kobospan" id="kobo.453.2">This means that there’s a subtle mismatch when running the search app locally versus </span><span><span class="kobospan" id="kobo.454.1">when proxied.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.455.1">Next.js was used for all systems</span><a id="_idIndexMarker364" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.456.1"> here but is not required; most tools can be configured to serve out of a “sub-path,” or </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">b</span><a id="_idTextAnchor219" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.458.1">asePath</span></strong><span class="kobospan" id="kobo.459.1"> as Next.js </span><span><span class="kobospan" id="kobo.460.1">calls it.</span></span></p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor220" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.461.1">The drawbacks of Next.js zones</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.462.1">In the setup we’ve demonstrated, the key drawback</span><a id="_idIndexMarker365" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.463.1"> is that the “framework” bundle is not shared across apps. </span><span class="kobospan" id="kobo.463.2">That means that as a user goes from one zone to another, they load a different version of Next.js, React, and React DOM. </span><span class="kobospan" id="kobo.463.3">This is suboptimal but probably acceptable for a lot of use cases. </span><span class="kobospan" id="kobo.463.4">When it’s not acceptable, a technique such as module federation or its predecessor, vendor bundles, can </span><span><span class="kobospan" id="kobo.464.1">be deployed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.465.1">Another drawback is that when developing locally, using </span><strong class="source-inline"><span class="kobospan" id="kobo.466.1">next dev</span></strong><span class="kobospan" id="kobo.467.1">, and using the root app to proxy requests, we lose features such as fast refresh/live reload. </span><span class="kobospan" id="kobo.467.2">This can be worked around by going directly to the micro frontend during </span><span><span class="kobospan" id="kobo.468.1">local development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">Now that we understand how we can use Next.js path-based routing, proxying, and base URL functionality to deliver a “zones” implementation, where the micro frontends each serve different subsets of the URLs, we’ll now look at how to deliver a micro frontend application where all the micro frontends are visible on one page, using the “islands” architecture with the </span><strong class="source-inline"><span class="kobospan" id="kobo.470.1">is-land</span></strong><span class="kobospan" id="kobo.471.1"> package. </span><span class="kobospan" id="kobo.471.2">The micro frontends</span><a id="_idIndexMarker366" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.472.1"> will be </span><a id="_idTextAnchor221" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.473.1">built using Preact </span><span><span class="kobospan" id="kobo.474.1">and Vue.js.</span></span></p>
<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor222" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.475.1">Scaling performance-sensitive pages with the “islands” architecture</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.476.1">According to the is-land library documentation (</span><a href="https://github.com/11ty/is-land" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.477.1">https://github.com/11ty/is-land</span></a><span class="kobospan" id="kobo.478.1">), is-land is</span><em class="italic"><span class="kobospan" id="kobo.479.1"> “A new performance-focused way to add interactive client-side components to your web site. </span><span class="kobospan" id="kobo.479.2">Or, more technically: a framework independent partial hydration islands </span></em><span><em class="italic"><span class="kobospan" id="kobo.480.1">architecture implementation.”</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.481.1">Let’s start by looking</span><a id="_idIndexMarker367" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.482.1"> at what a “islands architecture” is. </span><span class="kobospan" id="kobo.482.2">The islands architecture</span><a id="_idIndexMarker368" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.483.1"> is a paradigm where a page is mainly server-rendered, and interactivity is added specifically where necessary. </span><span class="kobospan" id="kobo.483.2">This reduces the page load time, as well as the amount of JavaScript being delivered (JavaScript is only delivered for specific client-side interactions). </span><span class="kobospan" id="kobo.483.3">This is in contrast to situations where a JavaScript application “takes over” the full page – for example, in a Next.js app, where the client-side JavaScript will remount what’s been server-rendered, meaning the minimum amount of JavaScript running client-side by default is Next.js client code + React + </span><span><span class="kobospan" id="kobo.484.1">React DOM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.485.1">The following diagram shows how the islands architecture can be leveraged to deliver a micro </span><span><span class="kobospan" id="kobo.486.1">frontend experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.487.1">Each island is responsible for its own data fetching from </span><span><span class="kobospan" id="kobo.488.1">the server.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer075">
<span class="kobospan" id="kobo.489.1"><img alt="Figure 6.11: An app page composed of islands" src="image/B19109_06_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.490.1">Figure 6.11: An app page composed of islands</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.491.1">One additional element in the islands architecture is loading JavaScript on user interaction – for example, on a click, hover, or scroll</span><a id="_idIndexMarker369" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.492.1"> into view of an element. </span><span class="kobospan" id="kobo.492.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">is-land</span></strong><span class="kobospan" id="kobo.494.1"> package provides primitives</span><a id="_idIndexMarker370" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.495.1"> to create islands with the</span><a id="_idTextAnchor223" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.496.1">se types of </span><span><span class="kobospan" id="kobo.497.1">hydration strategies.</span></span></p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor224" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.498.1">Islands setup with is-land</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.499.1">We’ll look at how to implement</span><a id="_idIndexMarker371" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.500.1"> the three-islands page with a product island that is immediately initialized, a cart island that is initialized on interaction, and a related products island that is initialized when scrolled </span><span><span class="kobospan" id="kobo.501.1">into view.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.502.1">Our example will demonstrate the usage of all the tools without a bundler in the first instance. </span><span class="kobospan" id="kobo.502.2">We’ll use Preact with </span><em class="italic"><span class="kobospan" id="kobo.503.1">htm</span></em><span class="kobospan" id="kobo.504.1"> (since we don’t have a JSX compilation pipeline) and Vue with </span><span><span class="kobospan" id="kobo.505.1">DOM templates.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.506.1">In order to enable simple imports in our scripts, we’ll leverage an import map, loading from the </span><a href="http://unpkg.com" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.507.1">unpkg.com</span></span></a><span><span class="kobospan" id="kobo.508.1"> CDN:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.509.1">
&lt;script type="importmap"&gt;
  {
    "imports": {"@11ty/is-land/is-land.js":
      "https://unpkg.com/@11ty/is-land@4.0.0/is-land.js",
      "htm/preact": "https://unpkg.com/htm@3.1.1/
         preact/index.module.js",
      "htm": "https://unpkg.com/htm@3.1.1/dist/htm.mjs",
      "preact": "https://unpkg.com/preact@10.15.1/
         dist/preact.mjs",
      "vue": "https://unpkg.com/vue@3.2.36/dist
        /vue.esm-browser.prod.js"
    }
  }
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.510.1">In order to initialize the islands, we’ll include the </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">is-land</span></strong><span class="kobospan" id="kobo.512.1"> package at the end of </span><span><span class="kobospan" id="kobo.513.1">the page:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.514.1">
&lt;script type="module"&gt;
  import '@1</span><a id="_idTextAnchor225" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.515.1">1ty/is-land/is-land.js';
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.516.1">We’ve now introduced</span><a id="_idIndexMarker372" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.517.1"> the page we’ll be building and configured </span><strong class="source-inline"><span class="kobospan" id="kobo.518.1">is-land</span></strong><span class="kobospan" id="kobo.519.1"> to initialize on page load, next we’ll implement the </span><span><span class="kobospan" id="kobo.520.1">product island.</span></span></p>
<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor226" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.521.1">Product island</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.522.1">We’ll use Vue</span><a id="_idIndexMarker373" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.523.1"> to build our </span><span><span class="kobospan" id="kobo.524.1">product island.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.525.1">The first step is to create an </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">&lt;is-land&gt;</span></strong><span class="kobospan" id="kobo.527.1"> element </span><span><span class="kobospan" id="kobo.528.1">and script.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.529.1">We set </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">on:visible</span></strong><span class="kobospan" id="kobo.531.1"> so that the contents of the island are initialized by </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">is-land</span></strong><span class="kobospan" id="kobo.533.1"> when the element is within the viewport; since our HTML contains only the product island, this will occur on </span><span><span class="kobospan" id="kobo.534.1">page load.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">We’ll create a Vue app that, on </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">mount</span></strong><span class="kobospan" id="kobo.537.1">, makes an API call to </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.539.1"> to fetch a product based on the query parameters. </span><span class="kobospan" id="kobo.539.2">Around the API call using </span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">fetch</span></strong><span class="kobospan" id="kobo.541.1">, we’ll set </span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">this.loading = true</span></strong><span class="kobospan" id="kobo.543.1"> (before the API call starts) and </span><strong class="source-inline"><span class="kobospan" id="kobo.544.1">this.loading = false</span></strong><span class="kobospan" id="kobo.545.1"> (when the API </span><span><span class="kobospan" id="kobo.546.1">call completes).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.547.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.548.1">data</span></strong><span class="kobospan" id="kobo.549.1"> method of the Vue app</span><a id="_idIndexMarker374" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.550.1"> will read </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">productId</span></strong><span class="kobospan" id="kobo.552.1"> from the URL query string, set loading to </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">true</span></strong><span class="kobospan" id="kobo.554.1">, and set </span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">product</span></strong><span class="kobospan" id="kobo.556.1"> to an empty object </span><span><span class="kobospan" id="kobo.557.1">literal (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.558.1">{}</span></strong></span><span><span class="kobospan" id="kobo.559.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.560.1">
&lt;is-land on:visible&gt;
  &lt;div id="vue-product-island"&gt;&lt;/div&gt;
  &lt;template data-island&gt;
    &lt;script type="module"&gt;
      import { createApp } from 'vue';
      createApp({
        async mounted() {
          this.loading = true;
          const product = await fetch(
            `https://fakestoreapi.com/
              products/${this.productId}`
          ).then((res) =&gt; res.json());
          this.product = product;
          this.loading = false;
        },
        data: () =&gt; ({
          productId:
            new URLSearchParams(window.location.search).
</span><span class="kobospan1" id="kobo.560.2">              get('productId') || '1',
          loading: true,
          product: {},
        }),
      }).mount('#vue-product-island');
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.561.1">Now that the data is loaded, we can focus</span><a id="_idIndexMarker375" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.562.1"> on the template; we’ll render the title, description, and other </span><span><span class="kobospan" id="kobo.563.1">product information:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.564.1">
&lt;is-land on:visible&gt;
  &lt;div id="vue-product-island" class="product-container"&gt;
    &lt;h2 v-text="product.title"&gt;&lt;/h2&gt;
    &lt;p v-text="product.description"&gt;&lt;/p&gt;
    &lt;p v-cloak&gt;
      &lt;span
        v-text="product.price?.toLocaleString('en', {
          style: 'currency', currency: 'EUR'})"
      &gt;&lt;/span&gt;
      &lt;br /&gt;&lt;span v-text="product?.rating?.rate"&gt;
        &lt;/span&gt;/5.0 (&lt;span
        v-text="product?.rating?.count"
      &gt;&lt;/span
      &gt;)
    &lt;/p&gt;
    &lt;img v-bind:src="product.image" width="320px"
      class="product-image" /&gt;
  &lt;/div&gt;
  &lt;style&gt;
    .product-container {
      min-height: 100vh;
      border-bottom: solid 1px black;
    }
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
  &lt;template data-island&gt;
    &lt;style&gt;
      .product-image {
        min-width: 320px;
        display: block;
        margin: auto;
      }
    &lt;/style&gt;
    &lt;!-- no change to the script --&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.565.1">When we load this page</span><a id="_idIndexMarker376" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.566.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">productId=1</span></strong><span class="kobospan" id="kobo.568.1"> or no </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">productId</span></strong><span class="kobospan" id="kobo.570.1"> (since it’s defaulted), we see the </span><span><span class="kobospan" id="kobo.571.1">following output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer076">
<span class="kobospan" id="kobo.572.1"><img alt="Figure 6.12: The product with﻿ ID 1 displaying in the product island" src="image/B19109_06_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.573.1">Figure 6.12: The product with</span><a id="_idTextAnchor227" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.574.1"> ID 1 displaying in the product island</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.575.1">We’ve now seen how to implement</span><a id="_idIndexMarker377" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.576.1"> a product island using </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">is-land</span></strong><span class="kobospan" id="kobo.578.1"> and Vue. </span><span class="kobospan" id="kobo.578.2">Next, we’ll build the </span><span><span class="kobospan" id="kobo.579.1">cart island.</span></span></p>
<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor228" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.580.1">Cart island</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">Again, we’ll start with an </span><strong class="source-inline"><span class="kobospan" id="kobo.582.1">is-land</span></strong><span class="kobospan" id="kobo.583.1"> element, this time</span><a id="_idIndexMarker378" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.584.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">on:interaction</span></strong><span class="kobospan" id="kobo.586.1">, which means the island will initialize only when the user clicks on it (we’ll show a button for them to </span><span><span class="kobospan" id="kobo.587.1">do so):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.588.1">
&lt;is-land on:interaction&gt;
  &lt;div id="preact-cart-island"&gt;
    &lt;button&gt;My Cart&lt;/button&gt;
  &lt;/div&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.589.1">Next, we’ll build a </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">CartContainer</span></strong><span class="kobospan" id="kobo.591.1"> component that will be mounted </span><span><span class="kobospan" id="kobo.592.1">using Preact.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.593.1">CartContainer</span></strong><span class="kobospan" id="kobo.594.1"> loads cart and product information from </span><strong class="source-inline"><span class="kobospan" id="kobo.595.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.596.1"> and stores it in state for a </span><strong class="source-inline"><span class="kobospan" id="kobo.597.1">CartContents</span></strong><span class="kobospan" id="kobo.598.1"> component </span><span><span class="kobospan" id="kobo.599.1">to render:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.600.1">
&lt;is-land on:interaction&gt;
  &lt;div id="preact-cart-island"&gt;
    &lt;button&gt;My Cart&lt;/button&gt;
  &lt;/div&gt;
  &lt;template data-island&gt;
    &lt;script type="module"&gt;
      import { html, render } from 'htm/preact';
      import { useState, useEffect } from 'preact/hooks';
      function CartContents() {
        // empty for now
        return null;
      }
      function CartContainer(props) {
        const cartId = props.id ?? </span><span class="kobospan1" id="kobo.600.2">1;
        const [open, setOpen] = useState(true);
        const [isLoading, setIsLoading] = useState(false);
        const [cartContents, setCartContents] = useState({
          cart: null,
          productsById: null,
        });
        useEffect(async () =&gt; {
          setIsLoading(true);
          const cart = await fetch(
            `https://fakestoreapi.com/carts/${cartId}`
          ).then((res) =&gt; res.json());
          if (!cart?.products) {
            return {
              props: {
                id: cartId,
              },
            };
          }
          const productsById = (
            await Promise.all(
              cart.products.map(async (product) =&gt; {
                return await fetch(
                   `https://fakestoreapi.com/
                     products/${product.productId}`
                ).then((res) =&gt; res.json());
              })
            )
          ).reduce((acc, curr) =&gt; {
            acc[curr.id] = curr;
            return acc;
          }, {});
          setCartContents({
            cart,
            productsById,
          });
          setIsLoading(false);
        }, [cartId]);
        const cartItemCount = cartContents?.
</span><span class="kobospan1" id="kobo.600.3">          cart?.products?.length;
        return html`&lt;div&gt;
          &lt;button onClick=${() =&gt; setOpen(!open)}&gt;
            My Cart ${cartItemCount !== undefined ? </span><span class="kobospan1" id="kobo.600.4">`
              (${cartItemCount})` : ''}
          &lt;/button&gt;
          ${open &amp;&amp; isLoading &amp;&amp; html`&lt;div&gt;
            Loading...&lt;/div&gt;`} ${open &amp;&amp;
          !isLoading &amp;&amp;
          cartContents.cart &amp;&amp;
          cartContents.productsById &amp;&amp;
          html`&lt;${CartContents}
            cart=${cartContents.cart}
            productsById=${cartContents.productsById}
          /&gt;`}
        &lt;/div&gt;`;
      }
      const appContainer = document.querySelector
        ('#preact-cart-island');
      render(
        html`&lt;${CartContainer}
          id=${new URLSearchParams(window.location.search)
            .get('cartId')}
        /&gt;`,
        appContainer,
        appContainer
      );
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.601.1">Finally, we’ll implement </span><strong class="source-inline"><span class="kobospan" id="kobo.602.1">CartContents</span></strong><span class="kobospan" id="kobo.603.1">, in which we loop</span><a id="_idIndexMarker379" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.604.1"> through the cart and render </span><span><span class="kobospan" id="kobo.605.1">pricing information:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.606.1">
&lt;template data-island&gt;
  &lt;script type="module"&gt;
    import { html, render } from 'htm/preact';
    // no changes to imports
    function CartContents(props) {
      const { cart, productsById } = props;
      return html`&lt;ul&gt;
        ${cart.products.map((product) =&gt; {
          const lineItemQueryParams = new URLSearchParams([
            ['productId', product.productId],
            ['cartId', cart.id],
          ]);
          const fullProductInformation = productsById
            [product.productId];
          return html`&lt;li class="cart-item-product"
            key=${product.productId}&gt;
            ${html`&lt;a href=${'?' </span><span class="kobospan1" id="kobo.606.2">+
              lineItemQueryParams.toString()}
              &gt;${fullProductInformation?.title}&lt;/a
            &gt;`}
            &lt;span class="cart-item-product-quantity"
              &gt;x ${product.quantity}&lt;/span
            &gt;
            &lt;span class="cart-item-product-price"&gt;
              Price:${' '}${(
                product.quantity * fullProductInformation
              ?.price).toLocaleString(navigator.language, {
                style: 'currency',
                currency: 'EUR',
              })}
            &lt;/span&gt;
          &lt;/li&gt;`;
        })}
        &lt;li class="cart-item-product"&gt;
          &lt;strong class="cart-item-product-price"&gt;
            Total:${' '} ${cart.products
              .reduce((acc, curr) =&gt; {
                const fullProductInformation =
                   productsById[curr.productId];
                return acc + curr.quantity *
                  fullProductInformation.price;
              }, 0)
              .toLocaleString(navigator.language, {
                style: 'currency',
                currency: 'EUR',
              })}
          &lt;/strong&gt;
        &lt;/li&gt;
      &lt;/ul&gt; `;
    }
    // no changes to CartContainer component
  &lt;/script&gt;
&lt;/template&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.607.1">When we load our page with </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">cartId 1</span></strong><span class="kobospan" id="kobo.609.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">productId 1</span></strong><span class="kobospan" id="kobo.611.1"> and open the cart contents, we can see that it renders the cart with ID 1, including the three line items, their amount, the subtotal per item, and the </span><span><span class="kobospan" id="kobo.612.1">cart total.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<span class="kobospan" id="kobo.613.1"><img alt="Figure 6﻿.13: Cart 1 rendering in the cart island" src="image/B19109_06_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.614.1">Figure 6</span><a id="_idTextAnchor229" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.615.1">.13: Cart 1 rendering in the cart island</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">We’ve now implemented the cart island</span><a id="_idIndexMarker380" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.617.1"> with Preact, next we’ll implement a related products island which initializes only when </span><span><span class="kobospan" id="kobo.618.1">it’s visible.</span></span></p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor230" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.619.1">A related products island</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.620.1">Finally, we’ll build our related products</span><a id="_idIndexMarker381" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.621.1"> island. </span><span class="kobospan" id="kobo.621.2">The island itself is quite straightforward, but communicating which product is being displayed and its category </span><span><span class="kobospan" id="kobo.622.1">is trickier.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.623.1">We’ll build an island that waits to be visible to initialize itself, again using </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">on:visible</span></strong><span class="kobospan" id="kobo.625.1"> but also </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">on:idle</span></strong><span class="kobospan" id="kobo.627.1">. </span><span class="kobospan" id="kobo.627.2">This means the island will load either when it’s visible or when other processing </span><span><span class="kobospan" id="kobo.628.1">has completed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.629.1">The island will mount if it receives a </span><strong class="source-inline"><span class="kobospan" id="kobo.630.1">product-category-load</span></strong> <span><span class="kobospan" id="kobo.631.1">custom event.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.632.1">We’ll start by building the </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">RelatedProducts</span></strong><span class="kobospan" id="kobo.634.1"> component, which will receive three props – </span><strong class="source-inline"><span class="kobospan" id="kobo.635.1">selectedProductId</span></strong><span class="kobospan" id="kobo.636.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">category</span></strong><span class="kobospan" id="kobo.638.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">from</span></strong><span class="kobospan" id="kobo.640.1">. </span><span class="kobospan" id="kobo.640.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">from</span></strong><span class="kobospan" id="kobo.642.1"> value will be displayed in an </span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">h3</span></strong><span class="kobospan" id="kobo.644.1"> element we render to illustrate how the island received </span><span><span class="kobospan" id="kobo.645.1">its data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.646.1">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      import { html } from 'htm/preact';
      function RelatedProducts({ selectedProductId,
        category, from }) {
        return html`&lt;div&gt;
          &lt;h3&gt;Related Products (from ${from})&lt;/h3&gt;
        &lt;/div&gt;`;
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.647.1">Next, based on the category, we want to load all possible products from </span><strong class="source-inline"><span class="kobospan" id="kobo.648.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.649.1">. </span><span class="kobospan" id="kobo.649.2">We’ll store the value using the </span><strong class="source-inline"><span class="kobospan" id="kobo.650.1">useState()</span></strong><span class="kobospan" id="kobo.651.1"> hook, and loading the related products will be done on component mount, using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">useEffect()</span></strong></span><span><span class="kobospan" id="kobo.653.1"> hook.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.654.1">The data fetching logic is as follows. </span><span class="kobospan" id="kobo.654.2">We’ll make</span><a id="_idIndexMarker382" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.655.1"> an API call to </span><strong class="source-inline"><span class="kobospan" id="kobo.656.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.657.1"> using the provided category. </span><span class="kobospan" id="kobo.657.2">To fulfill the “related” requirement of the “related products,” we’ll exclude the product that’s currently being displayed – that is, remove the product with an ID equal to </span><strong class="source-inline"><span class="kobospan" id="kobo.658.1">selectedProductId</span></strong><span class="kobospan" id="kobo.659.1"> from the products list. </span><span class="kobospan" id="kobo.659.2">Finally, we sort the related products by rating and persist the first three items to state, </span><span><span class="kobospan" id="kobo.660.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.661.1">setRelatedProducts</span></strong></span><span><span class="kobospan" id="kobo.662.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.663.1">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      // no changes to other imports
      import { useState, useEffect } from 'preact/hooks';
      function RelatedProducts({ selectedProductId,
        category, from }) {
        const [relatedProducts, setRelatedProducts] =
          useState([]);
        useEffect(async () =&gt; {
          const productsInCategory = await fetch(
            `https://fakestoreapi.com/products/category/$
              {encodeURIComponent(
              category
            )}`
          ).then((res) =&gt; res.json());
          const topRelatedProductsByRating =
             productsInCategory
            .filter((el) =&gt; {
              return el.id !== parseInt(selectedProductId,
                10);
            })
            .sort((a, b) =&gt; b.rating.rate – a.rating.rate);
          setRelatedProducts
            (topRelatedProductsByRating.slice(0, 3));
        }, [selectedProductId, category]);
        // no change to returned template
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.664.1">With the data persisted to </span><strong class="source-inline"><span class="kobospan" id="kobo.665.1">relatedProducts</span></strong><span class="kobospan" id="kobo.666.1">, we can now render</span><a id="_idIndexMarker383" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.667.1"> them using the </span><strong class="source-inline"><span class="kobospan" id="kobo.668.1">.map</span></strong><span class="kobospan" id="kobo.669.1"> function which returns a list. </span><span class="kobospan" id="kobo.669.2">For each product, we want to show a title that’s also a link to view the product, its price, an image, and the </span><span><span class="kobospan" id="kobo.670.1">rating information:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.671.1">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      // no changes to imports
      function RelatedProducts({ selectedProductId,
        category, from }) {
        const [relatedProducts, setRelatedProducts] =
          useState([]);
        // no change to useEffect
        return html`&lt;div&gt;
          &lt;h3&gt;Related Products (from ${from})&lt;/h3&gt;
          &lt;ul class="related-product-card-row"&gt;
            ${relatedProducts.map((product) =&gt; {
              const productSearchParams = new
                URLSearchParams([
                ['productId', product.id],
              ]);
              const currentCartId = new URLSearchParams(
                window.location.search
              ).get('cartId');
              if (currentCartId) {
                productSearchParams.set('cartId',
                  currentCartId);
              }
              return html`&lt;li class="related-product-card"&gt;
                &lt;a href=${'?' </span><span class="kobospan1" id="kobo.671.2">+ productSearchParams
                  .toString()}&gt;
                  &lt;h4&gt;${product.title}&lt;/h4&gt;
                  &lt;p&gt;
                    ${product.price.toLocaleString
                      (navigator.language, {
                      style: 'currency',
                      currency: 'EUR',
                    })}
                  &lt;/p&gt;
                  &lt;img height="100px" src=${product.image} /&gt;
                  &lt;p&gt;${product.rating.rate}/5.0
                    (${product.rating.count})&lt;/p&gt;
                &lt;/a&gt;
              &lt;/li&gt;`;
            })}
          &lt;/ul&gt;
        &lt;/div&gt;`;
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.672.1">Finally, we’ll add logic</span><a id="_idIndexMarker384" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.673.1"> to mount </span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">RelatedProducts</span></strong><span class="kobospan" id="kobo.675.1">, based on an event listener for the </span><strong class="source-inline"><span class="kobospan" id="kobo.676.1">product-category-load</span></strong> <span><span class="kobospan" id="kobo.677.1">custom event:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.678.1">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;div id="preact-related-products-island"&gt;
    &lt;h3&gt;Related Products&lt;/h3&gt;
    &lt;div class="related-product-card-row"&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      import { html, render } from 'htm/preact';
      // no change to preact/hooks import or
         RelatedProducts
      const relatedProductsIslandContainer =
        document.querySelector(
        '#preact-related-products-island'
      );
      function mountRelatedProductsIsland(
        relatedProductsIslandContainer,
        category,
        selectedProductId,
        from
      ) {
        if (category &amp;&amp; selectedProductId) {
          render(
            html`&lt;${RelatedProducts}
              category=${category}
              selectedProductId=${selectedProductId}
              from=${from}
            /&gt;`,
            relatedProductsIslandContainer,
            relatedProductsIslandContainer
          );
        }
      }
      document.addEventListener('product-category-load',
        (event) =&gt; {
        const category = event.detail.category;
        const selectedProductId = event.detail.
</span><span class="kobospan1" id="kobo.678.2">          selectedProductId;
        mountRelatedProductsIsland(
          relatedProductsIslandContainer,
          category,
          selectedProductId,
          'custom-event'
        );
      });
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.679.1">Now, we need to ensure</span><a id="_idIndexMarker385" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.680.1"> that </span><strong class="source-inline"><span class="kobospan" id="kobo.681.1">product-category-load</span></strong><span class="kobospan" id="kobo.682.1"> is dispatched from the product island. </span><span class="kobospan" id="kobo.682.2">We need to make the following change to the “mounted” life cycle hook of the Vue.js product </span><span><span class="kobospan" id="kobo.683.1">island script:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.684.1">
&lt;script type="module"&gt;
  import { createApp } from 'vue';
  createApp({
    async mounted() {
      // no changes
      document.dispatchEvent(
        new CustomEvent('product-category-load', {
          detail: {
            category: this.product.category,
            selectedProductId: this.product.id,
          },
        })
      );
    },
    // no changes to other properties
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.685.1">There’s also a condition whereby the </span><strong class="source-inline"><span class="kobospan" id="kobo.686.1">product-category-load</span></strong><span class="kobospan" id="kobo.687.1"> is emitted before the related products island is initialized; in order to work around this, we’ll store the information in the </span><strong class="source-inline"><span class="kobospan" id="kobo.688.1">#related-products-island-wrapper</span></strong><span class="kobospan" id="kobo.689.1"> element’s </span><span><strong class="source-inline"><span class="kobospan" id="kobo.690.1">dataset</span></strong></span><span><span class="kobospan" id="kobo.691.1"> property:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.692.1">
&lt;script&gt;
  document.addEventListener('product-category-load',
    (event) =&gt; {
    const category = event.detail.category;
    const selectedProductId = event.detail.
</span><span class="kobospan1" id="kobo.692.2">      selectedProductId;
    Object.assign(
      document.querySelector('#related-products-island-
        wrapper').dataset,
      { category, selectedProductId }
    );
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.693.1">We can then use that information</span><a id="_idIndexMarker386" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.694.1"> as a mounting condition </span><span><span class="kobospan" id="kobo.695.1">as well:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.696.1">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;!-- no changes to template --&gt;
  &lt;script type="module"&gt;
    // no changes to the rest of the code
    const { selectedProductId, category } =
      document.querySelector(
      '#related-products-island-wrapper'
    ).dataset;
    mountRelatedProductsIsland(
      relatedProductsIslandContainer,
      category,
      selectedProductId,
      'data-*'
    );
  &lt;/script&gt;
&lt;/is-land&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.697.1">We render </span><strong class="source-inline"><span class="kobospan" id="kobo.698.1">from </span></strong><span class="kobospan" id="kobo.699.1">to illustrate that both the </span><strong class="source-inline"><span class="kobospan" id="kobo.700.1">dataset</span></strong><span class="kobospan" id="kobo.701.1">-based approach and the event-based approach both function in </span><span><span class="kobospan" id="kobo.702.1">different scenarios.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.703.1">If we load the page and scroll down</span><a id="_idIndexMarker387" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.704.1"> to the related products (which are initially below outside the viewport), we’ll see </span><span><span class="kobospan" id="kobo.705.1">the following:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer078">
<span class="kobospan" id="kobo.706.1"><img alt="Figure 6.14: The related products island with category information from data attributes" src="image/B19109_06_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.707.1">Figure 6.14: The related products island with category information from data attributes</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.708.1">If we then reload the page, the scroll position will be such that the related products island is in view and initializes immediately, meaning the data comes from the custom </span><span><span class="kobospan" id="kobo.709.1">event directly.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer079">
<span class="kobospan" id="kobo.710.1"><img alt="Figure 6.15: The related products island w﻿ith category information from the custom event" src="image/B19109_06_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.711.1">Figure 6.15: The related products island w</span><a id="_idTextAnchor231" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.712.1">ith category information from the custom event</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.713.1">We’ve now implemented the related products</span><a id="_idIndexMarker388" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.714.1"> island with Preact and two approaches to reading the product category. </span><span class="kobospan" id="kobo.714.2">Next, we’ll see how to use bundling in conjunction with the </span><span><span class="kobospan" id="kobo.715.1">islands architecture.</span></span></p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor232" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.716.1">Scaling with a team – bundling islands</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.717.1">We can move the bulk</span><a id="_idIndexMarker389" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.718.1"> of the code for a particular island to an external file and then use a tool such as </span><strong class="source-inline"><span class="kobospan" id="kobo.719.1">esbuild</span></strong><span class="kobospan" id="kobo.720.1"> to bundle it together. </span><span class="kobospan" id="kobo.720.2">The following uses </span><strong class="source-inline"><span class="kobospan" id="kobo.721.1">.jsx</span></strong><span class="kobospan" id="kobo.722.1"> files for Preact, but a copy and paste of the existing files using </span><strong class="source-inline"><span class="kobospan" id="kobo.723.1">htm</span></strong><span class="kobospan" id="kobo.724.1"> would </span><span><span class="kobospan" id="kobo.725.1">also work:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.726.1">
npx esbuild ./src/preact-cart-island.jsx --jsx-import-source=preact --jsx=automatic --bundle --outdir=dist --format=esm --minify
npx esbuild ./src/vue-product-island.js --alias:vue=vue/dist/vue.esm-bundler.js --bundle --outdir=dist --format=esm --minify
npx esbuild ./src/preact-related-products-island.jsx --jsx-import-source=preact --jsx=automatic --bundle --outdir=dist --format=esm --minify</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.727.1">The outputted files can then be used </span><span><span class="kobospan" id="kobo.728.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.729.1">
&lt;script type="module" src="./dist/
   preact-cart-island.js"&gt;&lt;/script&gt;
&lt;script type="module" src="./dist/
  vue-product-island.js"&gt;&lt;/script&gt;
&lt;script type="module"&gt;
  import { mountRelatedProductsIsland } from './dist/
    preact-related-products-island.js';
  // use mountRelatedProductsIsland
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.730.1">Each team can own one or more islands </span><a id="_idIndexMarker390" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.731.1">by providing a JavaScript bundle for them and/or a template </span><a id="_idTextAnchor233" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.732.1">(the template needs to be a </span><span><span class="kobospan" id="kobo.733.1">server-side include).</span></span></p>
<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor234" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.734.1">Drawbacks</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.735.1">In the bundled use case, our two Preact islands</span><a id="_idIndexMarker391" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.736.1"> don’t share a Preact version, which means that this dependency will be loaded twice in the browser. </span><span class="kobospan" id="kobo.736.2">This can be fixed with vendor bundles or module federation, as mentioned in the previous section. </span><span class="kobospan" id="kobo.736.3">Also, note that it’s not an issue for the initial version of the code where the scripts for the islands were in the </span><span><span class="kobospan" id="kobo.737.1">page itself.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">Challenges in an islands architecture mainly relate to component communication (as we’ve illustrated with the related products island) and the mechanism used to co</span><a id="_idTextAnchor235" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.739.1">mpose the templates and scripts in a </span><span><span class="kobospan" id="kobo.740.1">unified page.</span></span></p>
<h1 id="_idParaDest-124" class="calibre5"><a id="_idTextAnchor236" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.741.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.742.1">In this chapter, we’ve covered micro frontends, common approaches, and how the zones and islands architectures with Next.js and </span><strong class="source-inline"><span class="kobospan" id="kobo.743.1">is-land</span></strong><span class="kobospan" id="kobo.744.1"> allow us to build high-development velocity systems without compromising the </span><span><span class="kobospan" id="kobo.745.1">user experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.746.1">Micro frontends allow teams to have strong governance over different parts of a frontend ecosystem without compromising the user experience. </span><span class="kobospan" id="kobo.746.2">Micro frontends allow more teams and their skills to be brought to bear effectively, which increases delivery velocity across the board. </span><span class="kobospan" id="kobo.746.3">Common approaches include a container application with “server-side includes,” build-time integration via shared packages, and runtime integrations (e.g., iframes, JavaScript, and </span><span><span class="kobospan" id="kobo.747.1">Web Components).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.748.1">The recommended Next.js “zones” approach allows different micro frontends to be mounted on different “base paths.” </span><span class="kobospan" id="kobo.748.2">The zones approach is a more flexible type of server-side includes; apps are “included” via a reverse-proxy and URLs. </span><span class="kobospan" id="kobo.748.3">On a conceptual level, domain-specific applications that can deliver multiple pages and API routes are a great tool to leverage for </span><span><span class="kobospan" id="kobo.749.1">larger teams.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.750.1">Finally, we discussed the “islands” architecture implemented via the </span><strong class="source-inline"><span class="kobospan" id="kobo.751.1">is-land</span></strong><span class="kobospan" id="kobo.752.1"> package, which demonstrated a lightweight micro frontend approach with multiple JavaScript based libraries for different components. </span><strong class="source-inline"><span class="kobospan" id="kobo.753.1">is-land</span></strong><span class="kobospan" id="kobo.754.1">’s ability to do partial hydration is a clear benefit to end users. </span><span class="kobospan" id="kobo.754.2">Cross-island communication, a common challenge of the islands architecture, was addressed with an approach that includes </span><strong class="source-inline"><span class="kobospan" id="kobo.755.1">CustomEvent</span></strong><span class="kobospan" id="kobo.756.1">’s and HTML </span><span><span class="kobospan" id="kobo.757.1">data attributes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.758.1">Now that we’ve covered modern micro frontend approaches and the “zones” and “islands” architectures, we will look at patterns for performant asynchronous programming in JavaScript in the </span><span><span class="kobospan" id="kobo.759.1">next chapter.</span></span></p>
</div>
</body></html>