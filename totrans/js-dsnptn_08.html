<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor199" class="pcalibre1 calibre6 pcalibre"/>6</h1>
<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor200" class="pcalibre1 calibre6 pcalibre"/>Micro Frontends, Zones, and Islands Architectures</h1>
<p class="calibre3">The micro frontend architecture, and specifically the “zones” and “islands” patterns, mirror the microservices architecture for backend systems. Given the right tooling, they allow multiple teams to maintain high-velocity development on a single product. The techniques covered in this chapter look at system-level interaction and integration patterns. Each system can leverage creational, structural, behavioral, and reactive view library patterns, as covered in <em class="italic">Chapters</em> <em class="italic">1</em>, <em class="italic">2</em>, <em class="italic">3</em>, and <em class="italic">4</em> respectively. Micro frontend architectures help link systems together as opposed to structuring the code within each of them better.</p>
<p class="calibre3">We’ll cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">The problem space that micro frontends address, including some common approaches and their drawbacks</li>
<li class="calibre11">Leveraging Next.js features to build a “zones” micro frontend setup</li>
<li class="calibre11">Using the <strong class="source-inline1">is-land</strong> package to deliver an “islands” micro frontend setup with islands in Preact and Vue.js</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to discuss the trade-offs and deliver modern micro frontend approaches in JavaScript.</p>
<h1 id="_idParaDest-106" class="calibre5"><a id="_idTextAnchor201" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor202" class="pcalibre1 calibre6 pcalibre"/>An overview of micro frontends</h1>
<p class="calibre3">A micro frontend setup<a id="_idIndexMarker326" class="pcalibre1 calibre6 pcalibre"/> is one where multiple frontend applications or components are composed. This is akin to microservices, where a micro frontend would encapsulate a subset of functionality, or “bounded context.”</p>
<p class="calibre3">For example, in an e-commerce setting, we might have a “search” micro frontend and a “cart” or “checkout” micro frontend.</p>
<div><div><img alt="Figure 6.1: A simplified micro frontends diagram" src="img/B19109_06_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1: A simplified micro frontends diagram</p>
<p class="calibre3"><a id="_idTextAnchor203" class="pcalibre1 calibre6 pcalibre"/>We’ve now introduced the micro frontends architecture; next, we’ll see at the key benefits micro frontends deliver.</p>
<h2 id="_idParaDest-108" class="calibre7"><a id="_idTextAnchor204" class="pcalibre1 calibre6 pcalibre"/>Key benefits</h2>
<p class="calibre3">The benefits of the micro frontend<a id="_idIndexMarker327" class="pcalibre1 calibre6 pcalibre"/> patterns are similar to microservice benefits. They usually come in the sociotechnical aspect of development.</p>
<p class="calibre3">Each micro frontend can use a different set of technologies, which means the right tool for the job can be selected. A very page-load performance-sensitive page might use a different stack than an admin interface or a high-volume SVG visualization page.</p>
<p class="calibre3">Incremental upgrades are available, and changes can be tested in one component before being rolled out to all components.</p>
<p class="calibre3">The releases of different micro frontends are not locked together. This can help when scaling, where each team might work on one or more of the micro frontends. They can be released independently of other teams, meaning the cadence can increase; this is related to the last benefit we’ll discuss.</p>
<p class="calibre3">Each micro frontend can have<a id="_idIndexMarker328" class="pcalibre1 calibre6 pcalibre"/> its own code base, and “bounded contexts” can be strictly enforced<a id="_idTextAnchor205" class="pcalibre1 calibre6 pcalibre"/>.</p>
<h2 id="_idParaDest-109" class="calibre7"><a id="_idTextAnchor206" class="pcalibre1 calibre6 pcalibre"/>“Classic” micro frontend patterns</h2>
<p class="calibre3">We’ll cover five<a id="_idIndexMarker329" class="pcalibre1 calibre6 pcalibre"/> different “classic” approaches<a id="_idIndexMarker330" class="pcalibre1 calibre6 pcalibre"/> to creating a micro frontend setup.</p>
<p class="calibre3">The first is the “container application” using server-side includes. This leverages a server that will fetch from the different micro frontends and stitch them together. This is illustrated in the following diagram, where the container application loads a “cart” HTML section and a “search” HTML section and injects them into its own template, before returning to the client.</p>
<div><div><img alt="Figure 6.2: The “container application” sequence" src="img/B19109_06_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2: The “container application” sequence</p>
<p class="calibre3">The benefits of server-side include, or the “container application,” is that deployments of each micro frontend are decoupled (e.g., we can deploy changes to the cart without deploying changes to the search section or the container); in addition, it’s completely technology-agnostic, as micro frontends don’t even need to use JavaScript.</p>
<p class="calibre3">The next “classic” approach we’ll see is different, using “build-time composition,” where each micro frontend is a package, usually a npm package (part of the Node.js/JavaScript toolchain). Each package is then imported where necessary and composed at “build-time” (when each application is packaged for deployment).</p>
<p class="calibre3">The key drawback of “build-time” composition<a id="_idIndexMarker331" class="pcalibre1 calibre6 pcalibre"/> is that releases now require deployment<a id="_idIndexMarker332" class="pcalibre1 calibre6 pcalibre"/> cascades. For all the applications to receive updates to the “cart”, we need to update the version and release all the applications.</p>
<p class="calibre3">The three final “classic” approaches are similar conceptually although use different technologies. They’re all “runtime integrations”; the technologies are iframes, JavaScript, and web components. Runtime integrations mean that the micro frontend requests the micro frontend resource from the browser.</p>
<p class="calibre3">In the case of iframes, this involves using the iframe <code>src</code> attribute. The main downside of this is that each micro frontend needs to be secured against all public network exploits. What’s more, allowing the iframing of an application’s content can lead to click-jacking vulnerabilities if not done carefully, so there are security implications.</p>
<div><div><img alt="Figure 6.3: Runtime integration with iframes" src="img/B19109_06_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3: Runtime integration with iframes</p>
<p class="calibre3">In the case of JavaScript<a id="_idIndexMarker333" class="pcalibre1 calibre6 pcalibre"/> or Web Component “runtime” integration, the composition<a id="_idIndexMarker334" class="pcalibre1 calibre6 pcalibre"/> is managed by loading JavaScript files. This is more ideal than using iframes, since serving JavaScript to the browser has fewer security implications than allowing the framing of your content. In the Web Components case, you would have both the web component referenced in the body of the HTML and a reference to the scripts required to run the Web Component.</p>
<div><div><img alt="Figure 6.4: Runtime integration with JavaScript or web components" src="img/B19109_06_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4: Runtime integration with JavaScript or web components</p>
<p class="calibre3">Runtime integrations have a performance<a id="_idIndexMarker335" class="pcalibre1 calibre6 pcalibre"/> impact on the user experience, as shown by the difference<a id="_idIndexMarker336" class="pcalibre1 calibre6 pcalibre"/> in diagrams between our “server-side includes” and “runtime integration” diagrams. In the “server-side includes” case, the server composes a full application before returning it to the customer. In the “runtime integration”, the server returns what are essentially resource references to the browser, which then has to load these resources.</p>
<p class="calibre3">As we explore the “zones” and “islands” modern<a id="_idIndexMarker337" class="pcalibre1 calibre6 pcalibre"/> implementations of micro<a id="_idIndexMarker338" class="pcalibre1 calibre6 pcalibre"/> frontends, we’ll encounter several instances of these techniques used t<a id="_idTextAnchor207" class="pcalibre1 calibre6 pcalibre"/>ogether.</p>
<h2 id="_idParaDest-110" class="calibre7"><a id="_idTextAnchor208" class="pcalibre1 calibre6 pcalibre"/>Other concerns in a micro frontend world</h2>
<p class="calibre3">Similar to a microservice<a id="_idIndexMarker339" class="pcalibre1 calibre6 pcalibre"/> setup, micro frontends that allow different teams to build in their own way can be a benefit and a drawback.</p>
<p class="calibre3">At the end of the day, most frontend systems will need to communicate with a backend service. How to do this remains something <a id="_idIndexMarker340" class="pcalibre1 calibre6 pcalibre"/>to be decided – should each team deploy its own <strong class="bold">backend for frontend</strong> (<strong class="bold">BFF</strong>), should a single gateway be deployed that exposes relevant service endpoints, or should it be a gateway that wraps services in a different query system such as GraphQL?</p>
<p class="calibre3">Micro frontends also cause challenges for testing. How do we reliably test at the “user journey” level, which might go through multiple micro frontends, when each of the micro frontends also has its own test suite?</p>
<p class="calibre3">Similar to the questions about which backend integrations to use, there’s a challenge related to shared styles and potentially component libraries. Teams doing micro frontends might standardize on a set technology (React, Vue, etc) in order to gain the benefits of a component library. Component libraries are more difficult to maintain in multiple technologies, but companies sometimes opt for this to support their engineers in picking the right tool for the job.</p>
<p class="calibre3">One big challenge of micro frontends is how to keep them performant. Even in a case where all teams use the same technologies, it’s likely that the same dependency is duplicated across micro frontends, which has a performance impact. When technologies and build and deploy processes diverge (which is possible with micro frontends), this problem is exacerbated.</p>
<p class="calibre3">The other performance issue that occurs with, for example, “server-side includes” is that the page will only load as fast as the slowest component on the page. This is less of an issue with runtime integrations, but the idea that each micro frontend might affect a whole page’s performance is a relevant one with regard to the challenges of building a system using micro frontends.</p>
<p class="calibre3">Finally, as we’ve alluded to with regard to testing micro frontends, it causes operational and governance complexities. For example, environment mismatch issues are harder to detect. Running or deploying a full environment for development or testing with multiple micro frontends is more complex than with a monolithic application.</p>
<p class="calibre3">Now that we’ve defined and contrasted<a id="_idIndexMarker341" class="pcalibre1 calibre6 pcalibre"/> the benefits and drawbacks of micro frontends in general and specific micro frontend approaches, we can look at modern implementations of micro frontends. In the following section, we’ll look at leveraging Next.js and “zones” in order to build flexible micro<a id="_idTextAnchor209" class="pcalibre1 calibre6 pcalibre"/> frontends.</p>
<h1 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor210" class="pcalibre1 calibre6 pcalibre"/>Composing applications with Next.js “zones”</h1>
<p class="calibre3">Next.js “zones” are a URL “base path”-driven approach to composing Next.js<a id="_idIndexMarker342" class="pcalibre1 calibre6 pcalibre"/> applications. This allows us to build a micro frontend setup with Next.js.</p>
<p class="calibre3">What this means, as shown in the figure that follows, is that an e-commerce use case, where the user might request four sets of URLs (<code>GET /, GET /careers, GET /search, and GET /cart/{id}), "{id}"</code>), denotes that the cart has a dynamic segment, which is the cart ID that is requested. For <code>GET /</code> and <code>GET /careers</code>, the request first goes to the <code>root</code> frontend, which handles rendering directly. For <code>GET /search</code>, the request goes to the root frontend, which forwards the request to the search frontend. Similarly, for <code>GET /cart/{id}</code> requests, the request initially is sent to the root frontend, which proxies the request to the checkout frontend.</p>
<div><div><img alt="Figure 6.5: An overview flowchart of a three-app Next.js﻿ zone setup" src="img/B19109_06_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.5: An overview flowchart of a three-app Next.js<a id="_idTextAnchor211" class="pcalibre1 calibre6 pcalibre"/> zone setup</p>
<p class="calibre3">We’ve now introduced<a id="_idIndexMarker343" class="pcalibre1 calibre6 pcalibre"/> Next.js “zones” and an overview of our implementation, next we’ll implement the “root app”.</p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor212" class="pcalibre1 calibre6 pcalibre"/>Root app</h2>
<p class="calibre3">The root app contains<a id="_idIndexMarker344" class="pcalibre1 calibre6 pcalibre"/> two pages, <code>/</code> (<code>pages/index.js</code>) and <code>/careers</code> (<code>pages/careers.js</code>). Both of these pages are statically rendered, <code>index.js</code> via automatic static generation (since it doesn’t have <code>getServerSideProps</code> or <code>getInitialProps</code>) and <code>careers.js</code> via static site generation (since it has <code>getStaticProps</code>).</p>
<p class="calibre3"><code>index.js</code> contains a heading as well as <code>Head</code> content.</p>
<pre class="source-code">
import React from 'react';
import Head from 'next/head';
export default function Home() {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Homepage (Root zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Root&lt;/h1&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we load the <code>GET</code> <code>/</code> path, our root app <a id="_idIndexMarker345" class="pcalibre1 calibre6 pcalibre"/>renders the <code>h1</code> element we placed within it, with <code>'Root'</code> as its content.</p>
<div><div><img alt="Figure 6.6: The Root page rendered" src="img/B19109_06_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.6: The Root page rendered</p>
<p class="calibre3">The <code>/careers</code> page loads roles from an API using <code>getStaticProps</code> and displays them in a list.</p>
<p class="calibre3">We can start with a <code>getStaticProps</code> function<a id="_idIndexMarker346" class="pcalibre1 calibre6 pcalibre"/> in <code>pages/careers.js</code>. This function loads from a “fake jobs” API and returns a <code>roles</code> prop, which includes the returned data from the API:</p>
<pre class="source-code">
export async function getStaticProps() {
  const jobs = await fetch(
    'https://apis.camillerakoto.fr/fakejobs/
      jobs?fulltime=true').then((res) =&gt; res.json());
  return {
    props: { roles: jobs },
  };
}</pre> <p class="calibre3">Next, we’ll add a <code>CareersPages</code> component. It includes the page scaffolding with <code>title</code> and <code>h1</code>. It also loops through the <code>roles</code> prop to render it as a list, using <code>ul</code> and <code>li</code>:</p>
<pre class="source-code">
import React from 'react';
import Head from 'next/head';
export default function CareersPage({ roles }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Careers (Root zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Careers&lt;/h1&gt;
        &lt;ul&gt;
          {roles.map((role) =&gt; {
            return (
              &lt;li key={role.id}&gt;
                {role.title} ({role.country})
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">It displays<a id="_idIndexMarker347" class="pcalibre1 calibre6 pcalibre"/> as follows.</p>
<div><div><img alt="Figure 6.7: The Careers page in the root zone" src="img/B19109_06_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.7: The Careers page in the root zone</p>
<p class="calibre3">The <code>next build</code> output shows that <code>index.js</code> is indeed statically<a id="_idIndexMarker348" class="pcalibre1 calibre6 pcalibre"/> rendered, while <code>/</code><code>careers</code> uses static site generation:</p>
<pre class="console">
Route (pages)                              Size     First Load JS
┌ ○ /                                      430 B          77.7 kB
├ ○ /404                                   182 B          77.5 kB
├ λ /api/health                            0 B            77.3 kB
└ ● /careers                               498 B          77.8 kB
+ First Load JS shared by all              77.3 kB
  ├ chunks/framework-4725d5bb117f1d8e.js   45.2 kB
  ├ chunks/main-7a398668474d4dd1.js        31.1 kB
  ├ chunks/pages/_app-ecd5712b2c05cb6a.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses <a id="_idTextAnchor213" class="pcalibre1 calibre16 pcalibre"/>getStaticProps)</pre> <p class="calibre3">We’ve now started implementing<a id="_idIndexMarker349" class="pcalibre1 calibre6 pcalibre"/> the root app, we’ll move on to our second zone, the “search” zone.</p>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor214" class="pcalibre1 calibre6 pcalibre"/>Adding a /search app</h2>
<p class="calibre3">Next, we’ll build<a id="_idIndexMarker350" class="pcalibre1 calibre6 pcalibre"/> and mount a <code>/</code><code>search</code> page.</p>
<p class="calibre3"><code>search/pages/index.js</code> displays an input and makes a call to the <code>/search/api/search</code> route on change:</p>
<pre class="source-code">
import React, { useState } from 'react';
import Head from 'next/head';
export default function Home() {
  const [searchResult, setSearchResult] = useState({
    count: 0,
    matches: [],
  });
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Search Page (Search zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;Search&lt;/h1&gt;
        &lt;input
          type="search"
          onChange={async (event) =&gt; {
            const data = await fetch(
              `/search/api/search?q=${event.target.value}`
            ).then((res) =&gt; res.json());
            setSearchResult(data);
          }}
        /&gt;
        &lt;div&gt;
          &lt;h2&gt;Results ({searchResult.count})&lt;/h2&gt;
          {searchResult.matches.map((product) =&gt; {
            return &lt;div key={product.id}&gt;
              {product.title}&lt;/div&gt;;
          })}
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">To implement the <code>search/pages/api/search</code> API route, we create <code>pages/api/search</code>, which loads<a id="_idIndexMarker351" class="pcalibre1 calibre6 pcalibre"/> products from <code>fakestoreapi</code> and finds a match between the title, description and category:</p>
<pre class="source-code">
export default async function handler(req, res) {
  const allProducts = await fetch
    ('https://fakestoreapi.com/products').then(
      (res) =&gt; res.json()
  );
  const { q } = req.query;
  const searchQuery = Array.isArray(q) ? q[0] : q;
  const matches = allProducts.filter(
    (product) =&gt;
      product.title.includes(searchQuery) ||
      product.description.includes(searchQuery) ||
      product.category.includes(searchQuery)
  );
  return res.status(200).json({ matches,
    count: matches.length });
}</pre> <p class="calibre3">In order for <code>search-app/</code> to be mounted under <code>search-app/search</code>, we’ll use <code>basePath</code> in <code>next.config.js</code> in the search app:</p>
<pre class="source-code">
module.exports = {
  basePath: '/search',
};</pre> <p class="calibre3">We’ll expose <code>search</code> via the root<a id="_idIndexMarker352" class="pcalibre1 calibre6 pcalibre"/> app’s <code>next.config.js</code>:</p>
<pre class="source-code">
module.exports = {
  async rewrites() {
    return [
      {
        source: '/search/:path*',
        destination: 'http://localhost:3001/search/:path*',
      },
    ];
  },
};</pre> <p class="calibre3">We can then load the <strong class="bold">Search</strong> page, which displays as follows:</p>
<div><div><img alt="Figure 6.8: The Search page on load" src="img/B19109_06_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.8: The Search page on load</p>
<p class="calibre3">The search works – for example, with the <code>jacket</code> search term.</p>
<div><div><img alt="Figure 6.9: The Search page with the jacket search term" src="img/B19109_06_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.9: The Search page with the jacket search term</p>
<p class="calibre3"><code>/search</code> is statically rendered<a id="_idIndexMarker353" class="pcalibre1 calibre6 pcalibre"/> via automatic static rendering:</p>
<pre class="console">
Route (pages)                              Size     First Load JS
┌ ○ /                                      607 B          73.7 kB
├   └ css/776983a5dfcef528.css             271 B
├ ○ /404                                   182 B          73.2 kB
├ λ /api/health                            0 B            73.1 kB
└ λ /api/search                            0 B            73.1 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-4725d5bb117f1d8e.js   45.2 kB
  ├ chunks/main-ee0b7fc0f7162449.js        26.9 kB
  ├ chunks/pages/_app-ecd5712b2c05cb6a.js  195 B
  └ chunks/webpack-ab5c478f511867a3.js     756 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses<a id="_idTextAnchor215" class="pcalibre1 calibre16 pcalibre"/> no initial props)</pre> <p class="calibre3">We’ve now implemented<a id="_idIndexMarker354" class="pcalibre1 calibre6 pcalibre"/> the search “zone”, next we’ll implement the checkout “zone”.</p>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor216" class="pcalibre1 calibre6 pcalibre"/>Adding /checkout app</h2>
<p class="calibre3">We’ll add a “view cart” page<a id="_idIndexMarker355" class="pcalibre1 calibre6 pcalibre"/> in a new checkout Next.js app under <code>pages/cart/[id].js</code>.</p>
<p class="calibre3">The cart page loads a cart and its contained products from <code>fakestoreapi</code>, displaying them via a <code>CartContents</code> component.</p>
<p class="calibre3">First, we’ll define a <code>CartContents</code> component that takes <code>cart</code> and <code>productsById</code> props. It then maps through <code>cart.products</code>, extracting the product’s title and the quantity requested in the cart, before computing and formatting the price in euros using <code>.toLocaleString</code>.</p>
<p class="calibre3">The reason we need <code>cart</code> and <code>productsById</code> is that the cart comes back in a normalized data format, meaning it contains only cart-specific information and none of the related product’s information, except the product ID. Therefore, we need to do a lookup based on the product ID.</p>
<p class="calibre3">Our rendering logic uses an unordered list container (the <code>ul</code> HTML element) and list item elements (<code>li</code> HTML elements). We render the title in an <code>h3</code> heading and the rest of the information using <code>span</code> elements:</p>
<pre class="source-code">
import React from 'react';
function CartContents(props) {
  const { cart, productsById } = props;
  return (
    &lt;ul&gt;
      {cart.products.map((product) =&gt; {
        const fullProductInformation = productsById
          [product.productId];
        return (
          &lt;li key={product.productId} className=
            "cart-item-product"&gt;
            &lt;h3 className="cart-item-product-name"&gt;
              {fullProductInformation?.title}
            &lt;/h3&gt;
            &lt;span className="cart-item-product-quantity"&gt;
              {' '}
              x {product.quantity}
            &lt;/span&gt;
            &lt;span className="cart-item-product-price"&gt;
              Price:
              {(
                product.quantity *
                  fullProductInformation?.price)
                  .toLocaleString('en', {
                style: 'currency',
                currency: 'EUR',
              })}
            &lt;/span&gt;
          &lt;/li&gt;
        );
      })}
    &lt;/ul&gt;
  );
}</pre> <p class="calibre3">Now that we’re rendering the contents<a id="_idIndexMarker356" class="pcalibre1 calibre6 pcalibre"/> of the cart, the additional functionality we’ll add to <code>CartContents</code> is a display of the cart’s total price.</p>
<p class="calibre3">This is done by adding another <code>li</code>, which displays “Total:” and computes the total price, using <code>reduce</code> over <code>cart.products</code>. Remember from the previous code block that <code>cart.products</code> is normalized, meaning that it doesn’t contain any information about the product (e.g., its price), apart from the product’s ID. This means that our reduce handler does a lookup on <code>productsById[product.productId]</code> in order to access the product’s price.</p>
<p class="calibre3">Once we have the quantity of a given product in the cart and the price of the product, we simply multiply them together and sum the quantity times the price result to the accumulator, which we initialized as 0.</p>
<p class="calibre3">Similar to the cart items, we use <code>toLocaleString</code> to format the total price in euros as an en localized string:</p>
<pre class="source-code">
// no change to imports
function CartContents(props) {
  // no change to the function body
  return (
    &lt;ul&gt;
      {/* no change to `cart.products` mapping */}
      &lt;li className="cart-item-product"&gt;
        &lt;strong className="cart-item-product-price"&gt;
          Total:
          {cart.products
            .reduce((acc, curr) =&gt; {
              const fullProductInformation = productsById
                [curr.productId];
              return acc + curr.quantity *
                fullProductInformation.price;
            }, 0)
            .toLocaleString('en', {
              style: 'currency',
              currency: 'EUR',
            })}
        &lt;/strong&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</pre> <p class="calibre3">We’ll leverage <code>getServerSideProps</code> to load the cart, and then the relevant<a id="_idIndexMarker357" class="pcalibre1 calibre6 pcalibre"/> products from <code>fakestoreapi</code>. As mentioned in the previous code blocks, <code>fakestoreapi</code>’s cart response is normalized and, therefore, doesn’t include all the product data we need, which is why we load the products by ID.</p>
<p class="calibre3">Once we have a cart response<a id="_idIndexMarker358" class="pcalibre1 calibre6 pcalibre"/> and all relevant product responses, we process the products to allow them to be looked up by ID. Finally, <code>getServerSideProps</code> returns <code>id</code> (the cart ID from the Next.js context), <code>productsById</code>, and <code>cart</code> in a <code>props</code> property of an object so that Next.js can pass them to our page component:</p>
<pre class="source-code">
// no changes to imports
// no changes to CartContents definition
export async function getServerSideProps(ctx) {
  const { params } = ctx;
  const cartId = params.id;
  const cart = await fetch(`https://fakestoreapi.com/carts
    /${cartId}`).then(
    (res) =&gt; res.json()
  );
  if (!cart?.products) {
    return {
      props: {
        id: cartId,
      },
    };
  }
  const productsById = (
    await Promise.all(
      cart.products.map(async (product) =&gt; {
        return await fetch(
          `https://fakestoreapi.com/products/$
             {product.productId}`
        ).then((res) =&gt; res.json());
      })
    )
  ).reduce((acc, curr) =&gt; {
    acc[curr.id] = curr;
    return acc;
  }, {});
  return {
    props: {
      id: cartId,
      cart,
      productsById,
    },
  };
}</pre> <p class="calibre3">Finally, we’ll add our <code>GetCartPage</code> component, which will take props<a id="_idIndexMarker359" class="pcalibre1 calibre6 pcalibre"/> as passed by Next.js (based on the output of <code>getServerSideProps</code>), and we’ll use them to render <code>CartContents</code>, as well as a heading and title:</p>
<pre class="source-code">
import Head from 'next/head';
import React from 'react';
// no changes to CartContents definition
export default function GetCartPage({ id, cart, productsById }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;GetCartPage (Checkout zone)&lt;/title&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;h1&gt;GetCartPage (Checkout zone)&lt;/h1&gt;
        &lt;CartContents cart={cart} productsById=
          {productsById} /&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}
// no changes to getServerSideProps definition</pre> <p class="calibre3">For the checkout app to mount<a id="_idIndexMarker360" class="pcalibre1 calibre6 pcalibre"/> under the right path, we set <code>basePath</code> in its <code>next.config.js</code>:</p>
<pre class="source-code">
module.exports = {
  basePath: '/checkout',
};</pre> <p class="calibre3">We again need to modify the root app’s <code>next.config.js</code> so that relevant requests are proxied to the checkout app:</p>
<pre class="source-code">
module.exports = {
  async rewrites() {
    return [
      // no change to other entries
      {
        source: '/checkout/:path*',
       destination:'http://localhost:3002/checkout/:path*',
      },
    ];
  },
};</pre> <p class="calibre3">We can load <code>/checkout/cart/2</code>, and the following<a id="_idIndexMarker361" class="pcalibre1 calibre6 pcalibre"/> will display:</p>
<div><div><img alt="Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded" src="img/B19109_06_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded</p>
<p class="calibre3">In the build output, we can see that <code>/cart/[id]</code> is server-side rendered, since it uses <code>getServerSideProps</code>:</p>
<pre class="console">
Route (pages)                              Size     First Load JS
┌ ○ /                                      445 B          73.5 kB
├ ○ /404                                   182 B          73.3 kB
└ λ /cart/[id]                             3.95 kB          77 kB
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTM<a id="_idTextAnchor217" class="pcalibre1 calibre16 pcalibre"/>L (uses no initial props)</pre> <p class="calibre3">We’ve now seen how to add a checkout “zone” to our micro frontend<a id="_idIndexMarker362" class="pcalibre1 calibre6 pcalibre"/> setup, next we’ll cover the benefits of a micro frontend “zones” architecture specifically with regards to working in growing teams.</p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor218" class="pcalibre1 calibre6 pcalibre"/>The benefits/supporting team scaling</h2>
<p class="calibre3">Using “zones” with <code>basePath</code> means that Next.js features<a id="_idIndexMarker363" class="pcalibre1 calibre6 pcalibre"/> work out of the box. For example, client-side transitions and <code>getServerSideProps</code> re-fetches work (where Next.js loads <code>{basePath}/_next/...</code>) as well as the API routes that we used in the search example.</p>
<p class="calibre3">Adding new pages also “just works”; a new page at <code>/cart/[id]/checkout</code> wouldn’t require any changes to the root app to be available to users.</p>
<p class="calibre3">The only time we would change the root application config is to add a whole new app (top-level path) – for example, if we wanted an admin app, we would need to create that and configure the root <code>next.config.js</code>.</p>
<p class="calibre3">In the case where there’s a lot of traffic to applications and we want to be more efficient with our resource, we don’t need to use the <code>root</code> app to forward all requests to the other micro frontends; we could leverage any reverse proxy (web servers such as NGINX and Caddy) or even the infrastructure provider’s CDN (e.g., Fastly, Akamai, Cloudflare and AWS) can be configured to forward all requests from <code>domain.tld/{path}/*</code> (all requests to <code>domain.tld</code> starting with <code>{path}</code>) to a specific origin.</p>
<p class="calibre3">By having a suite of applications that all use Next.js, pages can be built in the root app experimentally and then spun off to a full Next.js application.</p>
<p class="calibre3">For debugging and communication purposes, having the app name in the URL can help when discussing apps and pages with technical and non-technical team members. For example, even non-technical team members will understand that “this first section of the URL is the application name.”</p>
<p class="calibre3">One other benefit of using zones is that that request is not rewritten during a reverse-proxy pass. For example, in some setups, the reverse proxy would receive <code>/search</code> but load <code>/</code> on the search app. This means that there’s a subtle mismatch when running the search app locally versus when proxied.</p>
<p class="calibre3">Next.js was used for all systems<a id="_idIndexMarker364" class="pcalibre1 calibre6 pcalibre"/> here but is not required; most tools can be configured to serve out of a “sub-path,” or <code>b<a id="_idTextAnchor219" class="pcalibre1 calibre6 pcalibre"/>asePath</code> as Next.js calls it.</p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor220" class="pcalibre1 calibre6 pcalibre"/>The drawbacks of Next.js zones</h2>
<p class="calibre3">In the setup we’ve demonstrated, the key drawback<a id="_idIndexMarker365" class="pcalibre1 calibre6 pcalibre"/> is that the “framework” bundle is not shared across apps. That means that as a user goes from one zone to another, they load a different version of Next.js, React, and React DOM. This is suboptimal but probably acceptable for a lot of use cases. When it’s not acceptable, a technique such as module federation or its predecessor, vendor bundles, can be deployed.</p>
<p class="calibre3">Another drawback is that when developing locally, using <code>next dev</code>, and using the root app to proxy requests, we lose features such as fast refresh/live reload. This can be worked around by going directly to the micro frontend during local development.</p>
<p class="calibre3">Now that we understand how we can use Next.js path-based routing, proxying, and base URL functionality to deliver a “zones” implementation, where the micro frontends each serve different subsets of the URLs, we’ll now look at how to deliver a micro frontend application where all the micro frontends are visible on one page, using the “islands” architecture with the <code>is-land</code> package. The micro frontends<a id="_idIndexMarker366" class="pcalibre1 calibre6 pcalibre"/> will be <a id="_idTextAnchor221" class="pcalibre1 calibre6 pcalibre"/>built using Preact and Vue.js.</p>
<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor222" class="pcalibre1 calibre6 pcalibre"/>Scaling performance-sensitive pages with the “islands” architecture</h1>
<p class="calibre3">According to the is-land library documentation (<a href="https://github.com/11ty/is-land" class="pcalibre1 calibre6 pcalibre">https://github.com/11ty/is-land</a>), is-land is<em class="italic"> “A new performance-focused way to add interactive client-side components to your web site. Or, more technically: a framework independent partial hydration islands </em><em class="italic">architecture implementation.”</em></p>
<p class="calibre3">Let’s start by looking<a id="_idIndexMarker367" class="pcalibre1 calibre6 pcalibre"/> at what a “islands architecture” is. The islands architecture<a id="_idIndexMarker368" class="pcalibre1 calibre6 pcalibre"/> is a paradigm where a page is mainly server-rendered, and interactivity is added specifically where necessary. This reduces the page load time, as well as the amount of JavaScript being delivered (JavaScript is only delivered for specific client-side interactions). This is in contrast to situations where a JavaScript application “takes over” the full page – for example, in a Next.js app, where the client-side JavaScript will remount what’s been server-rendered, meaning the minimum amount of JavaScript running client-side by default is Next.js client code + React + React DOM.</p>
<p class="calibre3">The following diagram shows how the islands architecture can be leveraged to deliver a micro frontend experience.</p>
<p class="calibre3">Each island is responsible for its own data fetching from the server.</p>
<div><div><img alt="Figure 6.11: An app page composed of islands" src="img/B19109_06_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.11: An app page composed of islands</p>
<p class="calibre3">One additional element in the islands architecture is loading JavaScript on user interaction – for example, on a click, hover, or scroll<a id="_idIndexMarker369" class="pcalibre1 calibre6 pcalibre"/> into view of an element. The <code>is-land</code> package provides primitives<a id="_idIndexMarker370" class="pcalibre1 calibre6 pcalibre"/> to create islands with the<a id="_idTextAnchor223" class="pcalibre1 calibre6 pcalibre"/>se types of hydration strategies.</p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor224" class="pcalibre1 calibre6 pcalibre"/>Islands setup with is-land</h2>
<p class="calibre3">We’ll look at how to implement<a id="_idIndexMarker371" class="pcalibre1 calibre6 pcalibre"/> the three-islands page with a product island that is immediately initialized, a cart island that is initialized on interaction, and a related products island that is initialized when scrolled into view.</p>
<p class="calibre3">Our example will demonstrate the usage of all the tools without a bundler in the first instance. We’ll use Preact with <em class="italic">htm</em> (since we don’t have a JSX compilation pipeline) and Vue with DOM templates.</p>
<p class="calibre3">In order to enable simple imports in our scripts, we’ll leverage an import map, loading from the <a href="http://unpkg.com" class="pcalibre1 calibre6 pcalibre">unpkg.com</a> CDN:</p>
<pre class="source-code">
&lt;script type="importmap"&gt;
  {
    "imports": {"@11ty/is-land/is-land.js":
      "https://unpkg.com/@11ty/is-land@4.0.0/is-land.js",
      "htm/preact": "https://unpkg.com/htm@3.1.1/
         preact/index.module.js",
      "htm": "https://unpkg.com/htm@3.1.1/dist/htm.mjs",
      "preact": "https://unpkg.com/preact@10.15.1/
         dist/preact.mjs",
      "vue": "https://unpkg.com/vue@3.2.36/dist
        /vue.esm-browser.prod.js"
    }
  }
&lt;/script&gt;</pre> <p class="calibre3">In order to initialize the islands, we’ll include the <code>is-land</code> package at the end of the page:</p>
<pre class="source-code">
&lt;script type="module"&gt;
  import '@1<a id="_idTextAnchor225" class="pcalibre1 calibre16 pcalibre"/>1ty/is-land/is-land.js';
&lt;/script&gt;</pre> <p class="calibre3">We’ve now introduced<a id="_idIndexMarker372" class="pcalibre1 calibre6 pcalibre"/> the page we’ll be building and configured <code>is-land</code> to initialize on page load, next we’ll implement the product island.</p>
<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor226" class="pcalibre1 calibre6 pcalibre"/>Product island</h2>
<p class="calibre3">We’ll use Vue<a id="_idIndexMarker373" class="pcalibre1 calibre6 pcalibre"/> to build our product island.</p>
<p class="calibre3">The first step is to create an <code>&lt;is-land&gt;</code> element and script.</p>
<p class="calibre3">We set <code>on:visible</code> so that the contents of the island are initialized by <code>is-land</code> when the element is within the viewport; since our HTML contains only the product island, this will occur on page load.</p>
<p class="calibre3">We’ll create a Vue app that, on <code>mount</code>, makes an API call to <code>fakestoreapi.com</code> to fetch a product based on the query parameters. Around the API call using <code>fetch</code>, we’ll set <code>this.loading = true</code> (before the API call starts) and <code>this.loading = false</code> (when the API call completes).</p>
<p class="calibre3">The <code>data</code> method of the Vue app<a id="_idIndexMarker374" class="pcalibre1 calibre6 pcalibre"/> will read <code>productId</code> from the URL query string, set loading to <code>true</code>, and set <code>product</code> to an empty object literal (<code>{}</code>):</p>
<pre class="source-code">
&lt;is-land on:visible&gt;
  &lt;div id="vue-product-island"&gt;&lt;/div&gt;
  &lt;template data-island&gt;
    &lt;script type="module"&gt;
      import { createApp } from 'vue';
      createApp({
        async mounted() {
          this.loading = true;
          const product = await fetch(
            `https://fakestoreapi.com/
              products/${this.productId}`
          ).then((res) =&gt; res.json());
          this.product = product;
          this.loading = false;
        },
        data: () =&gt; ({
          productId:
            new URLSearchParams(window.location.search).
              get('productId') || '1',
          loading: true,
          product: {},
        }),
      }).mount('#vue-product-island');
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Now that the data is loaded, we can focus<a id="_idIndexMarker375" class="pcalibre1 calibre6 pcalibre"/> on the template; we’ll render the title, description, and other product information:</p>
<pre class="source-code">
&lt;is-land on:visible&gt;
  &lt;div id="vue-product-island" class="product-container"&gt;
    &lt;h2 v-text="product.title"&gt;&lt;/h2&gt;
    &lt;p v-text="product.description"&gt;&lt;/p&gt;
    &lt;p v-cloak&gt;
      &lt;span
        v-text="product.price?.toLocaleString('en', {
          style: 'currency', currency: 'EUR'})"
      &gt;&lt;/span&gt;
      &lt;br /&gt;&lt;span v-text="product?.rating?.rate"&gt;
        &lt;/span&gt;/5.0 (&lt;span
        v-text="product?.rating?.count"
      &gt;&lt;/span
      &gt;)
    &lt;/p&gt;
    &lt;img v-bind:src="img/product.image" width="320px"
      class="product-image" /&gt;
  &lt;/div&gt;
  &lt;style&gt;
    .product-container {
      min-height: 100vh;
      border-bottom: solid 1px black;
    }
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
  &lt;template data-island&gt;
    &lt;style&gt;
      .product-image {
        min-width: 320px;
        display: block;
        margin: auto;
      }
    &lt;/style&gt;
    &lt;!-- no change to the script --&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">When we load this page<a id="_idIndexMarker376" class="pcalibre1 calibre6 pcalibre"/> with <code>productId=1</code> or no <code>productId</code> (since it’s defaulted), we see the following output:</p>
<div><div><img alt="Figure 6.12: The product with﻿ ID 1 displaying in the product island" src="img/B19109_06_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.12: The product with<a id="_idTextAnchor227" class="pcalibre1 calibre6 pcalibre"/> ID 1 displaying in the product island</p>
<p class="calibre3">We’ve now seen how to implement<a id="_idIndexMarker377" class="pcalibre1 calibre6 pcalibre"/> a product island using <code>is-land</code> and Vue. Next, we’ll build the cart island.</p>
<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor228" class="pcalibre1 calibre6 pcalibre"/>Cart island</h2>
<p class="calibre3">Again, we’ll start with an <code>is-land</code> element, this time<a id="_idIndexMarker378" class="pcalibre1 calibre6 pcalibre"/> with <code>on:interaction</code>, which means the island will initialize only when the user clicks on it (we’ll show a button for them to do so):</p>
<pre class="source-code">
&lt;is-land on:interaction&gt;
  &lt;div id="preact-cart-island"&gt;
    &lt;button&gt;My Cart&lt;/button&gt;
  &lt;/div&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Next, we’ll build a <code>CartContainer</code> component that will be mounted using Preact.</p>
<p class="calibre3"><code>CartContainer</code> loads cart and product information from <code>fakestoreapi.com</code> and stores it in state for a <code>CartContents</code> component to render:</p>
<pre class="source-code">
&lt;is-land on:interaction&gt;
  &lt;div id="preact-cart-island"&gt;
    &lt;button&gt;My Cart&lt;/button&gt;
  &lt;/div&gt;
  &lt;template data-island&gt;
    &lt;script type="module"&gt;
      import { html, render } from 'htm/preact';
      import { useState, useEffect } from 'preact/hooks';
      function CartContents() {
        // empty for now
        return null;
      }
      function CartContainer(props) {
        const cartId = props.id ?? 1;
        const [open, setOpen] = useState(true);
        const [isLoading, setIsLoading] = useState(false);
        const [cartContents, setCartContents] = useState({
          cart: null,
          productsById: null,
        });
        useEffect(async () =&gt; {
          setIsLoading(true);
          const cart = await fetch(
            `https://fakestoreapi.com/carts/${cartId}`
          ).then((res) =&gt; res.json());
          if (!cart?.products) {
            return {
              props: {
                id: cartId,
              },
            };
          }
          const productsById = (
            await Promise.all(
              cart.products.map(async (product) =&gt; {
                return await fetch(
                   `https://fakestoreapi.com/
                     products/${product.productId}`
                ).then((res) =&gt; res.json());
              })
            )
          ).reduce((acc, curr) =&gt; {
            acc[curr.id] = curr;
            return acc;
          }, {});
          setCartContents({
            cart,
            productsById,
          });
          setIsLoading(false);
        }, [cartId]);
        const cartItemCount = cartContents?.
          cart?.products?.length;
        return html`&lt;div&gt;
          &lt;button onClick=${() =&gt; setOpen(!open)}&gt;
            My Cart ${cartItemCount !== undefined ? `
              (${cartItemCount})` : ''}
          &lt;/button&gt;
          ${open &amp;&amp; isLoading &amp;&amp; html`&lt;div&gt;
            Loading...&lt;/div&gt;`} ${open &amp;&amp;
          !isLoading &amp;&amp;
          cartContents.cart &amp;&amp;
          cartContents.productsById &amp;&amp;
          html`&lt;${CartContents}
            cart=${cartContents.cart}
            productsById=${cartContents.productsById}
          /&gt;`}
        &lt;/div&gt;`;
      }
      const appContainer = document.querySelector
        ('#preact-cart-island');
      render(
        html`&lt;${CartContainer}
          id=${new URLSearchParams(window.location.search)
            .get('cartId')}
        /&gt;`,
        appContainer,
        appContainer
      );
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Finally, we’ll implement <code>CartContents</code>, in which we loop<a id="_idIndexMarker379" class="pcalibre1 calibre6 pcalibre"/> through the cart and render pricing information:</p>
<pre class="source-code">
&lt;template data-island&gt;
  &lt;script type="module"&gt;
    import { html, render } from 'htm/preact';
    // no changes to imports
    function CartContents(props) {
      const { cart, productsById } = props;
      return html`&lt;ul&gt;
        ${cart.products.map((product) =&gt; {
          const lineItemQueryParams = new URLSearchParams([
            ['productId', product.productId],
            ['cartId', cart.id],
          ]);
          const fullProductInformation = productsById
            [product.productId];
          return html`&lt;li class="cart-item-product"
            key=${product.productId}&gt;
            ${html`&lt;a href=${'?' +
              lineItemQueryParams.toString()}
              &gt;${fullProductInformation?.title}&lt;/a
            &gt;`}
            &lt;span class="cart-item-product-quantity"
              &gt;x ${product.quantity}&lt;/span
            &gt;
            &lt;span class="cart-item-product-price"&gt;
              Price:${' '}${(
                product.quantity * fullProductInformation
              ?.price).toLocaleString(navigator.language, {
                style: 'currency',
                currency: 'EUR',
              })}
            &lt;/span&gt;
          &lt;/li&gt;`;
        })}
        &lt;li class="cart-item-product"&gt;
          &lt;strong class="cart-item-product-price"&gt;
            Total:${' '} ${cart.products
              .reduce((acc, curr) =&gt; {
                const fullProductInformation =
                   productsById[curr.productId];
                return acc + curr.quantity *
                  fullProductInformation.price;
              }, 0)
              .toLocaleString(navigator.language, {
                style: 'currency',
                currency: 'EUR',
              })}
          &lt;/strong&gt;
        &lt;/li&gt;
      &lt;/ul&gt; `;
    }
    // no changes to CartContainer component
  &lt;/script&gt;
&lt;/template&gt;</pre> <p class="calibre3">When we load our page with <code>cartId 1</code> and <code>productId 1</code> and open the cart contents, we can see that it renders the cart with ID 1, including the three line items, their amount, the subtotal per item, and the cart total.</p>
<div><div><img alt="Figure 6﻿.13: Cart 1 rendering in the cart island" src="img/B19109_06_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6<a id="_idTextAnchor229" class="pcalibre1 calibre6 pcalibre"/>.13: Cart 1 rendering in the cart island</p>
<p class="calibre3">We’ve now implemented the cart island<a id="_idIndexMarker380" class="pcalibre1 calibre6 pcalibre"/> with Preact, next we’ll implement a related products island which initializes only when it’s visible.</p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor230" class="pcalibre1 calibre6 pcalibre"/>A related products island</h2>
<p class="calibre3">Finally, we’ll build our related products<a id="_idIndexMarker381" class="pcalibre1 calibre6 pcalibre"/> island. The island itself is quite straightforward, but communicating which product is being displayed and its category is trickier.</p>
<p class="calibre3">We’ll build an island that waits to be visible to initialize itself, again using <code>on:visible</code> but also <code>on:idle</code>. This means the island will load either when it’s visible or when other processing has completed.</p>
<p class="calibre3">The island will mount if it receives a <code>product-category-load</code> custom event.</p>
<p class="calibre3">We’ll start by building the <code>RelatedProducts</code> component, which will receive three props – <code>selectedProductId</code>, <code>category</code>, and <code>from</code>. The <code>from</code> value will be displayed in an <code>h3</code> element we render to illustrate how the island received its data:</p>
<pre class="source-code">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      import { html } from 'htm/preact';
      function RelatedProducts({ selectedProductId,
        category, from }) {
        return html`&lt;div&gt;
          &lt;h3&gt;Related Products (from ${from})&lt;/h3&gt;
        &lt;/div&gt;`;
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Next, based on the category, we want to load all possible products from <code>fakestoreapi.com</code>. We’ll store the value using the <code>useState()</code> hook, and loading the related products will be done on component mount, using the <code>useEffect()</code> hook.</p>
<p class="calibre3">The data fetching logic is as follows. We’ll make<a id="_idIndexMarker382" class="pcalibre1 calibre6 pcalibre"/> an API call to <code>fakestoreapi.com</code> using the provided category. To fulfill the “related” requirement of the “related products,” we’ll exclude the product that’s currently being displayed – that is, remove the product with an ID equal to <code>selectedProductId</code> from the products list. Finally, we sort the related products by rating and persist the first three items to state, using <code>setRelatedProducts</code>:</p>
<pre class="source-code">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      // no changes to other imports
      import { useState, useEffect } from 'preact/hooks';
      function RelatedProducts({ selectedProductId,
        category, from }) {
        const [relatedProducts, setRelatedProducts] =
          useState([]);
        useEffect(async () =&gt; {
          const productsInCategory = await fetch(
            `https://fakestoreapi.com/products/category/$
              {encodeURIComponent(
              category
            )}`
          ).then((res) =&gt; res.json());
          const topRelatedProductsByRating =
             productsInCategory
            .filter((el) =&gt; {
              return el.id !== parseInt(selectedProductId,
                10);
            })
            .sort((a, b) =&gt; b.rating.rate – a.rating.rate);
          setRelatedProducts
            (topRelatedProductsByRating.slice(0, 3));
        }, [selectedProductId, category]);
        // no change to returned template
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">With the data persisted to <code>relatedProducts</code>, we can now render<a id="_idIndexMarker383" class="pcalibre1 calibre6 pcalibre"/> them using the <code>.map</code> function which returns a list. For each product, we want to show a title that’s also a link to view the product, its price, an image, and the rating information:</p>
<pre class="source-code">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      // no changes to imports
      function RelatedProducts({ selectedProductId,
        category, from }) {
        const [relatedProducts, setRelatedProducts] =
          useState([]);
        // no change to useEffect
        return html`&lt;div&gt;
          &lt;h3&gt;Related Products (from ${from})&lt;/h3&gt;
          &lt;ul class="related-product-card-row"&gt;
            ${relatedProducts.map((product) =&gt; {
              const productSearchParams = new
                URLSearchParams([
                ['productId', product.id],
              ]);
              const currentCartId = new URLSearchParams(
                window.location.search
              ).get('cartId');
              if (currentCartId) {
                productSearchParams.set('cartId',
                  currentCartId);
              }
              return html`&lt;li class="related-product-card"&gt;
                &lt;a href=${'?' + productSearchParams
                  .toString()}&gt;
                  &lt;h4&gt;${product.title}&lt;/h4&gt;
                  &lt;p&gt;
                    ${product.price.toLocaleString
                      (navigator.language, {
                      style: 'currency',
                      currency: 'EUR',
                    })}
                  &lt;/p&gt;
                  &lt;img height="100px" src=${product.image} /&gt;
                  &lt;p&gt;${product.rating.rate}/5.0
                    (${product.rating.count})&lt;/p&gt;
                &lt;/a&gt;
              &lt;/li&gt;`;
            })}
          &lt;/ul&gt;
        &lt;/div&gt;`;
      }
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Finally, we’ll add logic<a id="_idIndexMarker384" class="pcalibre1 calibre6 pcalibre"/> to mount <code>RelatedProducts</code>, based on an event listener for the <code>product-category-load</code> custom event:</p>
<pre class="source-code">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;div id="preact-related-products-island"&gt;
    &lt;h3&gt;Related Products&lt;/h3&gt;
    &lt;div class="related-product-card-row"&gt;Loading...&lt;/div&gt;
  &lt;/div&gt;
  &lt;template data-island=""&gt;
    &lt;script type="module"&gt;
      import { html, render } from 'htm/preact';
      // no change to preact/hooks import or
         RelatedProducts
      const relatedProductsIslandContainer =
        document.querySelector(
        '#preact-related-products-island'
      );
      function mountRelatedProductsIsland(
        relatedProductsIslandContainer,
        category,
        selectedProductId,
        from
      ) {
        if (category &amp;&amp; selectedProductId) {
          render(
            html`&lt;${RelatedProducts}
              category=${category}
              selectedProductId=${selectedProductId}
              from=${from}
            /&gt;`,
            relatedProductsIslandContainer,
            relatedProductsIslandContainer
          );
        }
      }
      document.addEventListener('product-category-load',
        (event) =&gt; {
        const category = event.detail.category;
        const selectedProductId = event.detail.
          selectedProductId;
        mountRelatedProductsIsland(
          relatedProductsIslandContainer,
          category,
          selectedProductId,
          'custom-event'
        );
      });
    &lt;/script&gt;
  &lt;/template&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">Now, we need to ensure<a id="_idIndexMarker385" class="pcalibre1 calibre6 pcalibre"/> that <code>product-category-load</code> is dispatched from the product island. We need to make the following change to the “mounted” life cycle hook of the Vue.js product island script:</p>
<pre class="source-code">
&lt;script type="module"&gt;
  import { createApp } from 'vue';
  createApp({
    async mounted() {
      // no changes
      document.dispatchEvent(
        new CustomEvent('product-category-load', {
          detail: {
            category: this.product.category,
            selectedProductId: this.product.id,
          },
        })
      );
    },
    // no changes to other properties
  });
&lt;/script&gt;</pre> <p class="calibre3">There’s also a condition whereby the <code>product-category-load</code> is emitted before the related products island is initialized; in order to work around this, we’ll store the information in the <code>#related-products-island-wrapper</code> element’s <code>dataset</code> property:</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('product-category-load',
    (event) =&gt; {
    const category = event.detail.category;
    const selectedProductId = event.detail.
      selectedProductId;
    Object.assign(
      document.querySelector('#related-products-island-
        wrapper').dataset,
      { category, selectedProductId }
    );
  });
&lt;/script&gt;</pre> <p class="calibre3">We can then use that information<a id="_idIndexMarker386" class="pcalibre1 calibre6 pcalibre"/> as a mounting condition as well:</p>
<pre class="source-code">
&lt;is-land on:visible on:idle id="related-products-island-wrapper"&gt;
  &lt;!-- no changes to template --&gt;
  &lt;script type="module"&gt;
    // no changes to the rest of the code
    const { selectedProductId, category } =
      document.querySelector(
      '#related-products-island-wrapper'
    ).dataset;
    mountRelatedProductsIsland(
      relatedProductsIslandContainer,
      category,
      selectedProductId,
      'data-*'
    );
  &lt;/script&gt;
&lt;/is-land&gt;</pre> <p class="calibre3">We render <code>from </code>to illustrate that both the <code>dataset</code>-based approach and the event-based approach both function in different scenarios.</p>
<p class="calibre3">If we load the page and scroll down<a id="_idIndexMarker387" class="pcalibre1 calibre6 pcalibre"/> to the related products (which are initially below outside the viewport), we’ll see the following:</p>
<div><div><img alt="Figure 6.14: The related products island with category information from data attributes" src="img/B19109_06_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.14: The related products island with category information from data attributes</p>
<p class="calibre3">If we then reload the page, the scroll position will be such that the related products island is in view and initializes immediately, meaning the data comes from the custom event directly.</p>
<div><div><img alt="Figure 6.15: The related products island w﻿ith category information from the custom event" src="img/B19109_06_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.15: The related products island w<a id="_idTextAnchor231" class="pcalibre1 calibre6 pcalibre"/>ith category information from the custom event</p>
<p class="calibre3">We’ve now implemented the related products<a id="_idIndexMarker388" class="pcalibre1 calibre6 pcalibre"/> island with Preact and two approaches to reading the product category. Next, we’ll see how to use bundling in conjunction with the islands architecture.</p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor232" class="pcalibre1 calibre6 pcalibre"/>Scaling with a team – bundling islands</h2>
<p class="calibre3">We can move the bulk<a id="_idIndexMarker389" class="pcalibre1 calibre6 pcalibre"/> of the code for a particular island to an external file and then use a tool such as <code>esbuild</code> to bundle it together. The following uses <code>.jsx</code> files for Preact, but a copy and paste of the existing files using <code>htm</code> would also work:</p>
<pre class="source-code">
npx esbuild ./src/preact-cart-island.jsx --jsx-import-source=preact --jsx=automatic --bundle --outdir=dist --format=esm --minify
npx esbuild ./src/vue-product-island.js --alias:vue=vue/dist/vue.esm-bundler.js --bundle --outdir=dist --format=esm --minify
npx esbuild ./src/preact-related-products-island.jsx --jsx-import-source=preact --jsx=automatic --bundle --outdir=dist --format=esm --minify</pre> <p class="calibre3">The outputted files can then be used as follows:</p>
<pre class="source-code">
&lt;script type="module" src="./dist/
   preact-cart-island.js"&gt;&lt;/script&gt;
&lt;script type="module" src="./dist/
  vue-product-island.js"&gt;&lt;/script&gt;
&lt;script type="module"&gt;
  import { mountRelatedProductsIsland } from './dist/
    preact-related-products-island.js';
  // use mountRelatedProductsIsland
&lt;/script&gt;</pre> <p class="calibre3">Each team can own one or more islands <a id="_idIndexMarker390" class="pcalibre1 calibre6 pcalibre"/>by providing a JavaScript bundle for them and/or a template <a id="_idTextAnchor233" class="pcalibre1 calibre6 pcalibre"/>(the template needs to be a server-side include).</p>
<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor234" class="pcalibre1 calibre6 pcalibre"/>Drawbacks</h2>
<p class="calibre3">In the bundled use case, our two Preact islands<a id="_idIndexMarker391" class="pcalibre1 calibre6 pcalibre"/> don’t share a Preact version, which means that this dependency will be loaded twice in the browser. This can be fixed with vendor bundles or module federation, as mentioned in the previous section. Also, note that it’s not an issue for the initial version of the code where the scripts for the islands were in the page itself.</p>
<p class="calibre3">Challenges in an islands architecture mainly relate to component communication (as we’ve illustrated with the related products island) and the mechanism used to co<a id="_idTextAnchor235" class="pcalibre1 calibre6 pcalibre"/>mpose the templates and scripts in a unified page.</p>
<h1 id="_idParaDest-124" class="calibre5"><a id="_idTextAnchor236" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve covered micro frontends, common approaches, and how the zones and islands architectures with Next.js and <code>is-land</code> allow us to build high-development velocity systems without compromising the user experience.</p>
<p class="calibre3">Micro frontends allow teams to have strong governance over different parts of a frontend ecosystem without compromising the user experience. Micro frontends allow more teams and their skills to be brought to bear effectively, which increases delivery velocity across the board. Common approaches include a container application with “server-side includes,” build-time integration via shared packages, and runtime integrations (e.g., iframes, JavaScript, and Web Components).</p>
<p class="calibre3">The recommended Next.js “zones” approach allows different micro frontends to be mounted on different “base paths.” The zones approach is a more flexible type of server-side includes; apps are “included” via a reverse-proxy and URLs. On a conceptual level, domain-specific applications that can deliver multiple pages and API routes are a great tool to leverage for larger teams.</p>
<p class="calibre3">Finally, we discussed the “islands” architecture implemented via the <code>is-land</code> package, which demonstrated a lightweight micro frontend approach with multiple JavaScript based libraries for different components. <code>is-land</code>’s ability to do partial hydration is a clear benefit to end users. Cross-island communication, a common challenge of the islands architecture, was addressed with an approach that includes <code>CustomEvent</code>’s and HTML data attributes.</p>
<p class="calibre3">Now that we’ve covered modern micro frontend approaches and the “zones” and “islands” architectures, we will look at patterns for performant asynchronous programming in JavaScript in the next chapter.</p>
</div>
</body></html>