- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Three.js Materials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Three.js材质一起工作
- en: In [*Chapter 3*](B18726_03.xhtml#_idTextAnchor040), *Working with Light Sources
    in Three.js*, we talked a bit about materials. You learned that a material, together
    with a `THREE.Geometry` instance, forms a `THREE.Mesh` object. A material is like
    the skin of an object that defines what the outside of a geometry looks like.
    For example, a skin defines whether a geometry is metallic-looking, transparent,
    or shown as a wireframe. The resulting `THREE.Mesh` object can then be added to
    the scene to be rendered by Three.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18726_03.xhtml#_idTextAnchor040)，*在Three.js中使用光源*中，我们简要地讨论了材质。你了解到，一个材质与一个`THREE.Geometry`实例一起形成一个`THREE.Mesh`对象。材质就像物体的皮肤，定义了几何体的外观。例如，皮肤定义了几何体是否看起来像金属、透明或显示为线框。然后，生成的`THREE.Mesh`对象可以被添加到场景中，由Three.js进行渲染。
- en: 'So far, we haven’t looked at materials in much detail. In this chapter, we’ll
    dive into all the materials Three.js has to offer, and you’ll learn how you can
    use these materials to create good-looking 3D objects. The materials we’ll explore
    in this chapter are shown in the following list:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有详细地查看材质。在本章中，我们将深入了解Three.js提供的所有材质，并学习如何使用这些材质创建看起来好的3D对象。本章中我们将探讨的材质如下所示：
- en: '`MeshBasicMaterial`: This is a basic material that you can use to give your
    geometries a simple color or show the wireframe of your geometries. This material
    isn’t influenced by lights.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshBasicMaterial`：这是一种基本的材质，你可以用它给你的几何体一个简单的颜色或显示你的几何体的线框。这种材质不受灯光的影响。'
- en: '`MeshDepthMaterial`: This is a material that uses the distance from the camera
    to determine how to color your mesh.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshDepthMaterial`：这是一种使用从相机到网格的距离来确定如何着色网格的材质。'
- en: '`MeshNormalMaterial`: This is a simple material that bases the color of a face
    on its normal vector.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshNormalMaterial`：这是一种简单的材质，它根据面的法向量来确定颜色。'
- en: '`MeshLambertMaterial`: This is a material that takes lighting into account
    and is used to create dull, non-shiny-looking objects.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshLambertMaterial`：这是一种考虑光照的材质，用于创建看起来不反光的物体。'
- en: '`MeshPhongMaterial`: This is a material that also takes lighting into account
    and can be used to create shiny objects.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshPhongMaterial`：这是一种也考虑光照的材质，可以用来创建反光的物体。'
- en: '`MeshStandardMaterial`: This is a material that uses physical-based rendering
    to render the object. With physical-based rendering, a physically correct model
    is used to determine how light interacts with a surface. This allows you to create
    more accurate and realistic-looking objects.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshStandardMaterial`：这是一种使用基于物理的渲染来渲染对象的材质。在基于物理的渲染中，使用一个物理正确的模型来确定光线如何与表面相互作用。这允许你创建更准确和看起来更逼真的对象。'
- en: '`MeshPhysicalMaterial`: This is an extension of `MeshStandardMaterial` that
    allows more control over the reflection.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshPhysicalMaterial`：这是`MeshStandardMaterial`的一个扩展，它允许对反射有更多的控制。'
- en: '`MeshToonMaterial`: This is an extension of `MeshPhongMaterial` that tries
    to make objects look hand-drawn.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeshToonMaterial`：这是`MeshPhongMaterial`的一个扩展，试图使物体看起来像是手绘的。'
- en: '`ShadowMaterial`: This is a specific material that can receive shadows, but
    otherwise, it is rendered transparent.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShadowMaterial`：这是一种可以接收阴影的特定材质，但除此之外，它被渲染为透明。'
- en: '`ShaderMaterial`: This material allows you to specify shader programs to directly
    control how vertices are positioned and pixels are colored.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShaderMaterial`：这种材质允许你指定着色器程序，以直接控制顶点的位置和像素的颜色。'
- en: '`LineBasicMaterial`: This is a material that can be used on the `THREE.Line`
    geometry to create colored lines.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineBasicMaterial`：这是一种可以用于`THREE.Line`几何体的材质，用于创建彩色线条。'
- en: '`LineDashMaterial`: This is the same as `LineBasicMaterial`, but this material
    also allows you to create a dashed effect.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineDashMaterial`：这与`LineBasicMaterial`相同，但此材质还允许你创建虚线效果。'
- en: In the sources of Three.js, you can also find `THREE.SpriteMaterial` and `THREE.PointsMaterial`.
    These are materials you can use when styling individual points. We won’t discuss
    those in this chapter, but we’ll explore them in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    *Points* *and Sprites*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js的源代码中，你还可以找到`THREE.SpriteMaterial`和`THREE.PointsMaterial`。这些是在为单个点着色时可以使用的材质。在本章中我们不会讨论这些，但将在[*第7章*](B18726_07.xhtml#_idTextAnchor122)，*点和精灵*中探讨它们。
- en: Materials have several common properties, so before we look at the first material,
    `THREE.MeshBasicMaterial`, we’ll look at the properties shared by all the materials.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 材质具有几个共同的属性，所以在我们查看第一个材质`THREE.MeshBasicMaterial`之前，我们将查看所有材质共有的属性。
- en: Understanding common material properties
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见的材质属性
- en: 'You can quickly see for yourself which properties are shared between all the
    materials. Three.js provides a material base class, `THREE.Material`, that lists
    all these common properties. We’ve divided these common material properties into
    the following three categories:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以快速查看所有材质之间共享哪些属性。Three.js 提供了一个材质基类 `THREE.Material`，列出了所有这些常见属性。我们将这些常见材质属性分为以下三个类别：
- en: '**Basic properties**: These are the properties you’ll use most often. With
    these properties, you can, for instance, control the opacity of the object, whether
    it is visible, and how it is referenced (by ID or custom name).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本属性**：这些是您最常使用的属性。使用这些属性，您可以控制对象的透明度、是否可见以及如何引用（通过 ID 或自定义名称）。'
- en: '**Blending properties**: Every object has a set of blending properties. These
    properties define how the color of each point of the material is combined with
    the color behind it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合属性**：每个对象都有一组混合属性。这些属性定义了材质中每个点的颜色如何与后面的颜色结合。'
- en: '**Advanced properties**: Several advanced properties control how the low-level
    WebGL context renders objects. In most cases, you won’t need to deal with these
    properties.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级属性**：几个高级属性控制低级 WebGL 上下文如何渲染对象。在大多数情况下，您不需要处理这些属性。'
- en: Note that, in this chapter, we will skip most of the properties related to textures
    and maps. Most materials allow you to use images as textures (for instance, a
    wood-like or stone-like texture). In [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working with Textures*, we will dive into the various available texture
    and mapping options. Some materials also have specific properties related to animation
    (for example, `skinning`, `morpNormals`, and `morphTargets`); we’ll also skip
    those properties. These will be addressed in [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148),
    *Animations and Moving the Camera*. The `clipIntersection`, `clippingPlanes`,
    and `clipShadows` properties will be addressed in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring* *Advanced Geometries*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章中，我们将跳过大多数与纹理和贴图相关的属性。大多数材质允许您使用图像作为纹理（例如，类似木材或石头的纹理）。在[*第10章*](B18726_10.xhtml#_idTextAnchor171)
    *加载和使用纹理*中，我们将深入了解各种可用的纹理和贴图选项。一些材质还具有与动画相关的特定属性（例如，`skinning`、`morpNormals` 和
    `morphTargets`）；我们也将跳过这些属性。这些将在[*第9章*](B18726_09.xhtml#_idTextAnchor148) *动画和移动摄像机*中讨论。`clipIntersection`、`clippingPlanes`
    和 `clipShadows` 属性将在[*第6章*](B18726_06.xhtml#_idTextAnchor101) *探索高级几何体*中讨论。
- en: 'We will start with the first set shown in the list: the basic properties.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表中显示的第一个集合开始：基本属性。
- en: Basic properties
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本属性
- en: 'The basic properties of the `THREE.Material` object are listed here (you will
    see these properties in action in the *THREE.MeshBasicMaterial* section):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 `THREE.Material` 对象的基本属性（您将在 *THREE.MeshBasicMaterial* 部分中看到这些属性的实际应用）：
- en: '`id`: This is used to identify a material and is assigned when you create a
    material. This starts at `0` for the first material and is increased by `1` for
    each additional material that is created.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这用于识别材质，并在创建材质时分配。对于第一个材质，它从 `0` 开始，并为每个创建的额外材质增加 `1`。'
- en: '`uuid`: This is a uniquely generated ID and is used internally.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid`：这是一个唯一生成的 ID，并在内部使用。'
- en: '`name`: You can assign a name to a material with this property. This can be
    used for debugging purposes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：您可以使用此属性为材质分配一个名称。这可以用于调试目的。'
- en: '`opacity`: This defines how transparent an object is. Use this together with
    the `transparent` property. The range of this property is from `0` to `1`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`：这定义了对象的透明度。请与 `transparent` 属性一起使用。此属性的取值范围从 `0` 到 `1`。'
- en: '`transparent`: If this is set to `true`, Three.js will render this object with
    the set opacity. If this is set to `false`, the object won’t be transparent, just
    more lightly colored. This property should also be set to `true` if you use a
    texture that uses an alpha (transparency) channel.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transparent`: 如果设置为 `true`，Three.js 将使用设置的透明度渲染此对象。如果设置为 `false`，则对象不会透明，只是颜色较浅。如果您使用的是使用
    alpha（透明度）通道的纹理，此属性也应设置为 `true`。'
- en: '`visible`: This defines whether this material is visible. If you set this to
    `false`, you won’t see the object in the scene.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visible`：这定义了此材质是否可见。如果您将其设置为 `false`，则您将不会在场景中看到该对象。'
- en: '`side`: With this property, you can define to which side of the geometry a
    material is applied. The default is `THREE.Frontside`, which applies the material
    to the front (outside) of an object. You can also set this to `THREE.BackSide`,
    which applies it to the back (inside), or `THREE.DoubleSide`, which applies it
    to both sides.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`side`: 通过这个属性，你可以定义材质应用于几何体的哪一侧。默认值是 `THREE.Frontside`，它将材质应用于对象的前面（外部）。你也可以将其设置为
    `THREE.BackSide`，这样它就会应用于背面（内部），或者设置为 `THREE.DoubleSide`，这样它就会应用于两面。'
- en: '`needsUpdate`: When Three.js creates a material, it converts it into a set
    of WebGL instructions. When you want the changes you made in the material to also
    result in an update to the WebGL instructions, you can set this property to `true`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`needsUpdate`: 当Three.js创建一个材质时，它会将其转换为一系列WebGL指令。当你想要你在材质中做的更改也导致WebGL指令的更新时，你可以将此属性设置为
    `true`。'
- en: '`colorWrite`: If set to `false`, the color of this material won’t be shown
    (in effect, you’ll create invisible objects, which occlude objects behind them).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorWrite`: 如果设置为 `false`，则此材质的颜色将不会显示（实际上，你会创建不可见对象，这些对象会遮挡它们后面的对象）。'
- en: '`flatShading`: This determines whether this material is rendered using flat
    shading. With flat shading, the individual triangles that make up an object are
    rendered separately and aren’t combined into a smooth surface.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatShading`: 这决定了是否使用平面着色来渲染此材质。在平面着色中，组成对象的各个三角形分别渲染，并不会合并成一个平滑的表面。'
- en: '`lights`: This is a Boolean value that determines whether this material is
    affected by lights. The default value is `true`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lights`: 这是一个布尔值，用于确定此材质是否受灯光影响。默认值是 `true`。'
- en: '`premultipliedAlpha`: This changes the way the transparency of an object is
    rendered. The default value is `false`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`premultipliedAlpha`: 这改变了对象透明度渲染的方式。默认值是 `false`。'
- en: '`dithering`: This applies a dithering effect to the rendering material. This
    can be used to avoid banding. The default value is `false`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dithering`: 这将对渲染材质应用抖动效果。这可以用来避免条纹。默认值是 `false`。'
- en: '`shadowSide`: This is just like the `side` property but determines which side
    of the faces casts the shadows. If not set, this follows the value set on the
    `side` property.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowSide`: 这就像 `side` 属性一样，但确定哪个面的哪一侧投射阴影。如果没有设置，它将遵循 `side` 属性设置的值。'
- en: '`vertexColors`: With this property, you can define individual colors to be
    applied to each vertex. If set to `true`, any color set on a vertex is used in
    rendering, while if set to `false`, the colors of the vertices aren’t used.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexColors`: 通过这个属性，你可以定义应用于每个顶点的单独颜色。如果设置为 `true`，则渲染时使用设置在顶点的任何颜色，而如果设置为
    `false`，则顶点的颜色不使用。'
- en: '`fog`: This property determines whether this material is affected by global
    fog settings. This is not shown in action, but if this is set to `false`, the
    global fog we saw in [*Chapter 2*](B18726_02.xhtml#_idTextAnchor028), *Basic Components
    that Make up a Three.js Scene*, is disabled.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fog`: 这个属性确定此材质是否受全局雾设置的影响。这没有在动作中显示，但如果设置为 `false`，我们看到的全局雾（在[*第2章*](B18726_02.xhtml#_idTextAnchor028)，*构成Three.js场景的基本组件*）将被禁用。'
- en: For each material, you can also set several blending properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个材质，你还可以设置几个混合属性。
- en: Blending properties
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合属性
- en: 'Materials have a couple of generic blending-related properties. Blending determines
    how the colors we render interact with the colors that are behind them. We’ll
    touch upon this subject a little bit when we talk about combining materials. The
    blending properties are listed here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 材质有几个通用的混合相关属性。混合决定了我们渲染的颜色如何与它们后面的颜色交互。当我们讨论组合材质时，我们会稍微涉及这个主题。混合属性如下：
- en: '`blending`: This determines how the material on this object blends with the
    background. The normal mode is `THREE.NormalBlending`, which only shows the top
    layer.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blending`: 这决定了此对象上的材质如何与背景混合。正常模式是 `THREE.NormalBlending`，它只显示顶层。'
- en: '`blendSrc`: Besides using the standard blending modes, you can also create
    custom blend modes by setting `blendsrc`, `blenddst`, and `blendequation`. This
    property defines how an object (the source) is blended into the background (the
    destination). The default `THREE.SrcAlphaFactor` setting uses the alpha (transparency)
    channel for blending.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendSrc`: 除了使用标准混合模式外，你还可以通过设置 `blendsrc`、`blenddst` 和 `blendequation` 来创建自定义混合模式。此属性定义了对象（源）如何与背景（目标）混合。默认的
    `THREE.SrcAlphaFactor` 设置使用alpha（透明度）通道进行混合。'
- en: '`blendSrcAlpha`: This is the transparency of `blendSrc`. The default is `null`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendSrcAlpha`: 这是 `blendSrc` 的透明度。默认值是 `null`。'
- en: '`blendDst`: This property defines how the background (the destination) is used
    in blending and defaults to `THREE.OneMinusSrcAlphaFactor`, which means this property
    also uses the alpha channel of the source for blending but uses `1` ( the alpha
    channel of the source) as the value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendDst`：此属性定义了在混合中如何使用背景（目标）。默认值为`THREE.OneMinusSrcAlphaFactor`，这意味着此属性也使用源alpha通道进行混合，但使用`1`（源的alpha通道）作为值。'
- en: '`blendDstAlpha`: This is the transparency of `blendDst`. The default is `null`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendDstAlpha`：这是`blendDst`的透明度。默认值为`null`。'
- en: '`blendEquation`: This defines how the `blendsrc` and `blenddst` values are
    used. The default is to add them (`AddEquation`). With these three properties,
    you can create your own custom blend modes.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendEquation`：这定义了如何使用`blendsrc`和`blenddst`值。默认值是相加（`AddEquation`）。使用这三个属性，您可以创建自己的自定义混合模式。'
- en: The last set of properties is mostly used internally and controls the specifics
    of how WebGL is used to render the scene.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一批属性主要用于内部，并控制WebGL渲染场景的具体方式。
- en: Advanced properties
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级属性
- en: 'We won’t go into the details of these properties. These are related to how
    WebGL works internally. If you do want to know more about these properties, the
    OpenGL specification is a good starting point. You can find this specification
    at [https://www.khronos.org/opengl/wiki](https://www.khronos.org/opengl/wiki).
    The following list provides a brief description of these advanced properties:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入这些属性的具体细节。这些属性与WebGL的内部工作方式有关。如果您想了解更多关于这些属性的信息，OpenGL规范是一个好的起点。您可以在[https://www.khronos.org/opengl/wiki](https://www.khronos.org/opengl/wiki)找到此规范。以下列表提供了这些高级属性的简要描述：
- en: '`depthTest`: This is an advanced WebGL property. With this property, you can
    enable or disable the `GL_DEPTH_TEST` parameter. This parameter controls whether
    the depth of a pixel is used to determine a new pixel’s value. Normally, you wouldn’t
    need to change this. More information can be found in the OpenGL specification
    we mentioned earlier.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depthTest`：这是一个高级WebGL属性。使用此属性，您可以启用或禁用`GL_DEPTH_TEST`参数。此参数控制是否使用像素的深度来确定新像素的值。通常，您不需要更改此参数。更多详细信息可以在我们之前提到的OpenGL规范中找到。'
- en: '`depthWrite`: This is another internal property. This property can be used
    to determine whether this material affects the WebGL depth buffer. If you use
    an object for a 2D overlay (for example, a hub), you should set this property
    to `false`. Usually, though, you shouldn’t need to change this property.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depthWrite`：这是另一个内部属性。此属性可以用来确定此材质是否影响WebGL深度缓冲区。如果您使用一个对象作为2D叠加（例如，一个中心），应将此属性设置为`false`。不过，通常您不需要更改此属性。'
- en: '`depthFunc`: This function compares a pixel’s depth. This corresponds to `glDepthFunc`
    from the WebGL specifications.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depthFunc`：此函数比较像素的深度。这对应于WebGL规范中的`glDepthFunc`。'
- en: '`polygonOffset`, `polygonOffsetFactor`, and `polygonOffsetUnits`: With these
    properties, you can control the `POLYGON_OFFSET_FILL` WebGL feature. These are
    normally not needed. For an explanation of what they do in detail, you can look
    at the OpenGL specification.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygonOffset`、`polygonOffsetFactor`和`polygonOffsetUnits`：通过这些属性，您可以控制`POLYGON_OFFSET_FILL`
    WebGL功能。这些属性通常不需要。如果您想详细了解它们的功能，可以查看OpenGL规范。'
- en: '`Alphatest`: This value can be set to a specific value (`0` to `1`). Whenever
    a pixel has an alpha value smaller than this value, it won’t be drawn. You can
    use this property to remove some transparency-related artifacts. You can set the
    precision for this material to one of the following WebGL values: `highp`, `mediump`,
    or `lowp`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alphatest`：此值可以设置为特定值（`0`到`1`）。当像素的alpha值小于此值时，它将不会被绘制。您可以使用此属性来移除一些与透明度相关的伪影。您可以将此材质的精度设置为以下WebGL值之一：`highp`、`mediump`或`lowp`。'
- en: Now, let’s look at all the available materials so that you can see the effect
    these properties have on the rendered output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看所有可用的材质，以便您可以看到这些属性对渲染输出的影响。
- en: Starting with simple materials
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单的材质开始
- en: 'In this section, we’ll look at a few simple materials: `MeshBasicMaterial`,
    `MeshDepthMaterial`, and `MeshNormalMaterial`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种简单的材质：`MeshBasicMaterial`、`MeshDepthMaterial`和`MeshNormalMaterial`。
- en: 'Before we look into the properties of these materials, here’s a quick note
    on how you can pass in properties to configure the materials. There are two options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨这些材质的属性之前，这里有一个关于如何传递属性以配置材质的快速说明。有两种选项：
- en: 'You can pass in the arguments in the constructor as a parameter object, like
    this:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将参数对象作为构造函数中的参数传递，如下所示：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can create an instance and set the properties individually,
    like this:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the best way is to use the constructor if we know all the properties’
    values while creating the material. The arguments used in both of these styles
    use the same format. The only exception to this rule is the `color` property.
    In the first style, we can just pass in the hex value, and Three.js will create
    a `THREE.Color` object itself. In the second style, we have to explicitly create
    a `THREE.Color` object. In this book, we’ll use both of these styles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the first of the simple materials: `THREE.MeshBasicMaterial`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshBasicMaterial
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MeshBasicMaterial` is a very simple material that doesn’t take into account
    the lights that are available in the scene. Meshes with this material will be
    rendered as simple, flat polygons, and you also have the option to show the geometry’s
    wireframe. Besides the common properties we saw earlier regarding this material,
    we can set the following properties (once again, we will ignore the properties
    that are used for textures since we’ll discuss those in the chapter on textures):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This property allows you to set the color of the material.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wireframe`: This allows you to render the material as a wireframe. This is
    great for debugging purposes.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertexColors`: When set to `true`, this will take the color of the individual
    vertices into account when rendering the model.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous chapters, we saw how to create materials and assign them to
    objects. For `THREE.MeshBasicMaterial`, we can do so like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This creates a new `THREE.MeshBasicMaterial` and initializes the `color` property
    to `0x7777ff` (which is purple).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added an example that you can use to play around with the `THREE.MeshBasicMaterial`
    properties and the basic properties we discussed in the previous sections. If
    you open up the `basic-mesh-material.html` example in the `chapter-04` folder,
    you’ll see a simple mesh on screen and a set of properties on the right of the
    scene that you can use to change models, add a simple texture, and change any
    of the material properties to see the effect immediately:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Start screen for the basic material example](img/Figure_4.01_B18726.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Start screen for the basic material example
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'What you can see in this screenshot is a basic simple gray sphere. We already
    mentioned that `THREE.MeshBasicMaterial` doesn’t respond to lights, so you don’t
    see any depth; all the faces are the same color. Even with this material, though,
    you can still create nice-looking models. If you, for instance, enable the reflection
    by selecting the `reflection` property in the `envMaps` dropdown, set the background
    of the scene, and change the model to the `torus` model, you can already create
    great-looking models:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Torus knot with an environment map](img/Figure_4.02_B18726.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Torus knot with an environment map
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wireframe` property is a great one for looking at the underlying geometry
    of `THREE.Mesh` and works great for debugging:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`wireframe`属性非常适合查看`THREE.Mesh`的底层几何形状，并且非常适合调试：'
- en: '![Figure 4.3 – Model showing its wireframe](img/Figure_4.03_B18726.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 显示其线框的模型](img/Figure_4.03_B18726.jpg)'
- en: Figure 4.3 – Model showing its wireframe
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 显示其线框的模型
- en: 'The final property that we want to look a bit closer at is `vertexColors`.
    If you enable this property, the colors of the individual vertices are used in
    rendering the model. If you select `vertexColor` from the model dropdown in the
    menu, you’ll see a model that has colored vertices. The easiest way to see this
    is by also enabling the wireframe:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要更仔细地研究的是`vertexColors`属性。如果您启用此属性，则模型的单个顶点的颜色将用于渲染模型。如果您从菜单中的模型下拉列表中选择`vertexColor`，您将看到一个具有着色顶点的模型。要查看这一点，最简单的方法是同时启用线框：
- en: '![Figure 4.4 – Model showing wireframe and vertex colors](img/Figure_4.04_B18726.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 显示线框和顶点颜色的模型](img/Figure_4.04_B18726.jpg)'
- en: Figure 4.4 – Model showing wireframe and vertex colors
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 显示线框和顶点颜色的模型
- en: Vertex colors can be used to color different parts of the mesh in different
    colors without having to use textures or multiple materials.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点颜色可以用来用不同的颜色为网格的不同部分着色，而无需使用纹理或多个材料。
- en: In this example, you can also play around with the standard material properties
    we discussed at the beginning of this chapter by looking at the **THREE.Material**
    section of the menu in *Figure 4**.4*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您还可以通过查看*图4.4*中的菜单的**THREE.Material**部分来尝试调整我们在本章开头讨论的标准材料属性。
- en: THREE.MeshDepthMaterial
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshDepthMaterial
- en: 'The next material on the list is `THREE.MeshDepthMaterial`. With this material,
    the way an object looks isn’t defined by lights or by a specific material property
    – it is defined by the distance from the object to the camera. You can, for instance,
    combine this with other materials to easily create fading effects. The only additional
    property this material has is one we saw in `THREE.MeshBasicMaterial`: the `wireframe`
    property.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个材料是`THREE.MeshDepthMaterial`。使用这种材料，对象的视觉效果不是由灯光或特定的材料属性定义的，而是由对象到摄像机的距离定义的。例如，您可以将其与其他材料结合使用，以轻松创建渐变效果。这种材料唯一的附加属性是我们之前在`THREE.MeshBasicMaterial`中看到的一个：`wireframe`属性。
- en: 'To demonstrate this material, we created an example that you can view by opening
    the `mesh-depth-material` example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种材料，我们创建了一个示例，您可以通过打开`mesh-depth-material`示例来查看：
- en: '![Figure 4.5 – Mesh depth material](img/Figure_4.04_B18726.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 网格深度材料](img/Figure_4.04_B18726.jpg)'
- en: Figure 4.5 – Mesh depth material
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 网格深度材料
- en: In this example, you can add and remove cubes by clicking on the relevant buttons
    in the menu. What you’ll see is that the cubes that are close to the camera are
    rendered very bright, and those farther away from the camera are rendered less
    bright. In this example, you can see how this works by playing around with the
    properties of the `Perspective Camera` settings. By playing around with the `far`
    and `near` properties of the camera, you can change the brightness of all the
    cubes in the scene.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以通过点击菜单中的相关按钮来添加和移除立方体。您会看到靠近摄像机的立方体渲染得非常亮，而远离摄像机的立方体渲染得较暗。在这个示例中，您可以通过调整`Perspective
    Camera`设置的`far`和`near`属性来了解这是如何工作的。通过调整摄像机的`far`和`near`属性，您可以改变场景中所有立方体的亮度。
- en: Normally, you wouldn’t use this material as the only material for a mesh; instead,
    you’d combine it with a different material. We’ll see how that works in the next
    section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会将此材料作为网格的唯一材料使用；相反，您会将其与不同的材料结合使用。我们将在下一节中看到这是如何工作的。
- en: Combining materials
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料组合
- en: 'If you look back at the properties of `THREE.MeshDepthMaterial`, you will see
    that there isn’t an option to set the color of the cubes. Everything was decided
    for you by the default properties of the material. Three.js, however, has the
    option to combine materials to create new effects (this is also where blending
    comes into play). The following code shows how we can combine materials:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾一下`THREE.MeshDepthMaterial`的属性，您会看到没有选项可以设置立方体的颜色。所有这些都是由材料的默认属性为您决定的。然而，Three.js提供了组合材料以创建新效果的选择（这也是混合作用的地方）。以下代码显示了我们可以如何组合材料：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we create our two materials. For `THREE.MeshDepthMaterial`, we don’t
    do anything special; for `THREE.MeshBasicMaterial`, we just set the color. The
    last line in this code fragment is also an important one. When we create a mesh
    with the `SceneUtils.createMultiMaterialObject()` function, the geometry gets
    copied and two of the same meshes are returned in a group.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了两种材质。对于`THREE.MeshDepthMaterial`，我们没有做任何特殊的事情；对于`THREE.MeshBasicMaterial`，我们只是设置了颜色。这段代码的最后一行也是很重要的一行。当我们使用`SceneUtils.createMultiMaterialObject()`函数创建网格时，几何体被复制，并返回两个相同的网格组。
- en: 'We get the following green-colored cubes that use the brightness from `THREE.MeshDepthMaterial`
    and the color from `THREE.MeshBasicMaterial`. You can see how this works by opening
    the `combining-materials.html` example in the `chapter-4` folder in your browser:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下使用`THREE.MeshDepthMaterial`的亮度和`THREE.MeshBasicMaterial`的颜色组合的绿色立方体。你可以在浏览器中打开“chapter-4”文件夹中的`combining-materials.html`示例来查看这是如何工作的：
- en: '![Figure 4.6 – Combining materials](img/Figure_4.06_B18726.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 材料组合](img/Figure_4.06_B18726.jpg)'
- en: Figure 4.6 – Combining materials
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 材料组合
- en: When you open this example for the first time, you’ll just see the solid objects,
    without any effect from `THREE.MeshDepthMaterial`. To combine the colors, we also
    need to specify how these colors blend. In the menu on the right in *Figure 4**.6*,
    you can specify this using the `blending` property. For this example, we’ve used
    the `THREE.AdditiveBlending` mode, which means the colors are added together,
    and the resulting color is shown. This example is a great way to play around with
    the different blending options, and see how they affect the final color of the
    material.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开这个示例时，你只会看到实体对象，没有任何`THREE.MeshDepthMaterial`的效果。为了组合颜色，我们还需要指定这些颜色如何混合。在*图
    4*.6*的右侧菜单中，你可以使用`blending`属性来指定这一点。在这个示例中，我们使用了`THREE.AdditiveBlending`模式，这意味着颜色会被相加，最终的颜色会显示出来。这个示例是探索不同混合选项并观察它们如何影响材质最终颜色的绝佳方式。
- en: The next material is also one where we won’t have any influence on the colors
    used in rendering.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个材质也是我们不会对渲染中使用的颜色产生任何影响的一个。
- en: THREE.MeshNormalMaterial
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshNormalMaterial
- en: 'The easiest way to understand how this material is rendered is by first looking
    at an example. Open up the `mesh-normal-material.html` example in the `chapter-4`
    folder and enable `flatShading`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种材质如何渲染的最简单方法首先是查看一个示例。打开“chapter-4”文件夹中的`mesh-normal-material.html`示例，并启用`flatShading`：
- en: '![Figure 4.7 – Mesh normal material](img/Figure_4.07_B18726.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 网格法线材质](img/Figure_4.07_B18726.jpg)'
- en: Figure 4.7 – Mesh normal material
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 网格法线材质
- en: As you can see, each face of the mesh is rendered in a slightly different color.
    This happens because the color of each face is based on the normals pointing out
    from the face. And this face normal is based on the normal vector of the individual
    vertices that make up the face. A normal vector is perpendicular to the face of
    a vertex. The normal vector is used in many different parts of Three.js. It is
    used to determine light reflections, helps with mapping textures to 3D models,
    and provides information on how to light, shade, and color pixels on the surface.
    Luckily, though, Three.js handles the computation of these vectors and uses them
    internally, so you don’t have to calculate or deal with them yourselves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，网格的每个面都以略不同的颜色渲染。这是因为每个面的颜色基于从面指向外的法线。而这个面的法线是基于构成面的各个顶点的法线向量。法线向量垂直于顶点的面。法线向量在
    Three.js 的许多不同部分中使用。它用于确定光线反射，帮助将纹理映射到 3D 模型，并提供有关如何照亮、着色和着色像素表面的信息。幸运的是，Three.js
    处理这些向量的计算并在内部使用它们，所以你不需要自己计算或处理它们。
- en: 'Three.js comes with a helper to visualize this normal, and you can show this
    by enabling the `vertexHelpers` property in the menu:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一个辅助工具来可视化这个法线，你可以在菜单中启用`vertexHelpers`属性来显示它：
- en: '![Figure 4.8 – Mesh normal helpers](img/Figure_4.08_B18726.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 网格法线辅助工具](img/Figure_4.08_B18726.jpg)'
- en: Figure 4.8 – Mesh normal helpers
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 网格法线辅助工具
- en: 'Adding this helper yourself can be done in a couple of lines of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行代码自己添加这个辅助工具：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`VertexNormalsHelper` takes three parameters. The first one is `THREE.Mesh`,
    for which you want to see the helpers, the second one is the length of the arrow,
    and the last one is the color.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexNormalsHelper`接受三个参数。第一个是`THREE.Mesh`，你想看到辅助工具的网格，第二个是箭头的长度，最后一个是颜色。'
- en: 'Let’s take this example as an opportunity to look at the `shading` property.
    With the `shading` property, we can tell Three.js how to render our objects. If
    you use `THREE.FlatShading`, each face will be rendered as-is (as you can see
    in the previous following screenshot), or you can use `THREE.SmoothShading`, which
    smooths out the faces of our objects. For instance, if we render the same sphere
    using `THREE.SmoothShading`, the result will look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以此为例，看看`shading`属性。使用`shading`属性，我们可以告诉Three.js如何渲染我们的对象。如果你使用`THREE.FlatShading`，每个面将按原样渲染（如前一张截图所示），或者你可以使用`THREE.SmoothShading`，它将平滑我们的对象的面。例如，如果我们使用`THREE.SmoothShading`渲染相同的球体，结果将看起来像这样：
- en: '![Figure 4.9 – Mesh normal smooth shading](img/Figure_4.09_B18726.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 网格法线平滑着色](img/Figure_4.09_B18726.jpg)'
- en: Figure 4.9 – Mesh normal smooth shading
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 网格法线平滑着色
- en: We’re done with the simple materials, but let’s look at one additional subject
    before moving on. In the next section, we’ll look at how you can use different
    materials for specific faces of a geometry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了简单材料的学习，但在继续之前，让我们看看一个额外的主题。在下一节中，我们将探讨如何为几何体的特定面使用不同的材料。
- en: Multiple materials for a single mesh
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个网格的多个材料
- en: 'When creating `THREE.Mesh`, so far, we’ve used a single material. It is also
    possible to define a specific material for each of the faces of a geometry. For
    instance, if you have a cube that has 12 faces (remember, Three.js works with
    triangles), you can assign a different material (for example, with a different
    color) to each side of the cube. Doing this is straightforward, as shown in the
    following piece of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`THREE.Mesh`时，到目前为止，我们使用的是单一材料。也可以为几何体的每个面定义特定的材料。例如，如果你有一个有12个面的立方体（记住，Three.js使用三角形），你可以为立方体的每个面分配不同的材料（例如，使用不同的颜色）。这样做很简单，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create an array, named `matArray`, to hold all the materials, and use that
    array to create `THREE.Mesh`. What you might notice is that we only create six
    materials, even though we’ve got 12 faces. To understand how this works, we have
    to look at how Three.js assigns a material to a face. Three.js uses the `groups`
    property for this. To see this yourself, open up the source code for `multi-material.js`
    and add the `debugger` statement, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`matArray`的数组来存储所有材料，并使用该数组创建`THREE.Mesh`。你可能注意到，尽管我们有12个面，但我们只创建了六个材料。要理解这是如何工作的，我们必须看看Three.js是如何将材料分配给面的。Three.js使用`groups`属性来做这件事。要亲自查看，请打开`multi-material.js`的源代码，并添加`debugger`语句，如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will cause the browser to stop executing, and allows you to inspect all
    the objects from the console of the browser:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致浏览器停止执行，并允许你从浏览器控制台检查所有对象：
- en: '![Figure 4.10 – Using the debugger statement to stop execution](img/Figure_4.10_B18726.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 使用断点语句停止执行](img/Figure_4.10_B18726.jpg)'
- en: Figure 4.10 – Using the debugger statement to stop execution
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 使用断点语句停止执行
- en: 'In the browser, if you open the `cubeMesh`, we can use `console.log(cubeMesh)`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，如果你打开`cubeMesh`，我们可以使用`console.log(cubeMesh)`：
- en: '![Figure 4.11 – Printing out information about an object](img/Figure_4.11_B18726.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 打印出有关对象的信息](img/Figure_4.11_B18726.jpg)'
- en: Figure 4.11 – Printing out information about an object
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 打印出有关对象的信息
- en: 'If you look further into the `geometry` property of `cubeMesh`, you will see
    `groups`. This property is an array that consists of six elements, where each
    element contains the range of vertices that belong to that group, and an additional
    property called `materialIndex` that specifies which of the passed-in materials
    should be used for that group of vertices:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步查看`cubeMesh`的`geometry`属性，你会看到`groups`。这个属性是一个包含六个元素的数组，其中每个元素包含属于该组的顶点范围，以及一个额外的属性`materialIndex`，它指定了应该为该组顶点使用传入的哪种材料：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, if you create your own objects from scratch, and want to apply different
    materials to different vertices groups, you have to make sure you set the `groups`
    property correctly. For the objects created by Three.js, you don’t have to do
    this manually, since Three.js already does this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你从头开始创建自己的对象，并想将不同的材料应用于不同的顶点组，你必须确保正确设置`groups`属性。对于由Three.js创建的对象，你不需要手动做这件事，因为Three.js已经做了。
- en: 'With this approach, it’s very simple to create interesting models. For instance,
    we can easily create a simple 3D Rubik’s Cube, as you can see in the `multi-materials.html`
    example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，创建有趣的模型非常简单。例如，我们可以轻松地创建一个简单的3D魔方，正如你在`multi-materials.html`示例中看到的那样：
- en: '![Figure 4.12 – Multi-material with six different materials](img/Figure_4.12_B18726.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 六种不同材料的多材料](img/Figure_4.12_B18726.jpg)'
- en: Figure 4.12 – Multi-material with six different materials
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 六种不同材料的多材料
- en: 'We’ve also added controls for the materials that are applied to each side to
    experiment with. Creating this cube is not much different than what we saw in
    the *Multiple materials for a single* *mesh* section:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了对应用于每个面的材料的控制，以便进行实验。创建这个立方体与我们之前在*单个网格的多种材料*部分看到的方法没有太大区别：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this piece of code, first, we create `THREE.Group`, which will hold all the
    individual cubes (group); next, we create the materials for each side of the cube.
    Then, we create three loops to make sure we create the right number of cubes.
    In this loop, we create each of the individual cubes, assign the materials, position
    them, and add them to the group. What you should remember is that the position
    of the cubes is relative to the position of this group. If we move or rotate the
    group, all the cubes will move and rotate with it. For more information on how
    to work with groups, look at [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132),
    *Creating and Loading Advanced Meshes* *and Geometries*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，首先，我们创建`THREE.Group`，它将包含所有的单个立方体（组）；接下来，我们为立方体的每一面创建材料。然后，我们创建三个循环以确保创建正确的立方体数量。在这个循环中，我们创建每个单个立方体，分配材料，定位它们，并将它们添加到组中。你应该记住的是，立方体的位置相对于这个组的位置。如果我们移动或旋转组，所有的立方体都会随之移动和旋转。有关如何使用组的更多信息，请参阅[*第8章*](B18726_08.xhtml#_idTextAnchor132)，*创建和加载高级网格*
    *和几何体*。
- en: And that wraps up this section on basic materials and how to combine them. In
    the following section, we’ll look at more advanced materials.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了关于基本材料和如何组合它们的这一节。在下一节中，我们将探讨更多高级材料。
- en: Advanced materials
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级材料
- en: 'In this section, we’ll look at the more advanced materials Three.js has to
    offer. We’ll look at the following materials:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Three.js提供的高级材料。我们将探讨以下材料：
- en: '`THREE.MeshLambertMaterial`: A material for rough-looking surfaces'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MeshLambertMaterial`：一种用于看起来粗糙的材料'
- en: '`THREE.MeshPhongMaterial`: A material for shiny-looking surfaces'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MeshPhongMaterial`：一种用于看起来光滑的材料'
- en: '`THREE.MeshToonMaterial`: Renders the mesh in a cartoon-like fashion'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MeshToonMaterial`：以卡通风格渲染网格'
- en: '`THREE.ShadowMaterial`: A material that only shows shadows cast on it; the
    material is otherwise is transparent'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ShadowMaterial`：一种只显示在其上投射的阴影的材料；材料本身是透明的'
- en: '`THREE.MeshStandardMaterial`: A versatile material that can be used to represent
    many different kinds of surfaces'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MeshStandardMaterial`：一种多功能的材料，可以用来表示许多不同类型的表面'
- en: '`THREE.MeshPhysicalMaterial`: Similar to `THREE.MeshStandardMaterial` but provides
    additional properties for more real-world-like surfaces'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MeshPhysicalMaterial`：类似于`THREE.MeshStandardMaterial`，但提供了更多类似真实世界表面的属性'
- en: '`THREE.ShaderMaterial`: A material where you can define for yourself how to
    render the object by writing your own shaders'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial`：一种可以自己定义如何渲染对象，通过编写自己的着色器的材料'
- en: We’ll start with `THREE.MeshLambertMaterial`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`THREE.MeshLambertMaterial`开始。
- en: THREE.MeshLambertMaterial
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshLambertMaterial
- en: 'This material can be used to create dull-looking, non-shiny surfaces. This
    is a very easy-to-use material that responds to the lighting sources in the scene.
    This material can be configured with the basic properties we’ve already seen,
    so we won’t go into the details of those properties; instead, we will focus on
    the ones specific to this material. That just leaves us with the following properties:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料可以用来创建看起来平淡无奇、非闪亮的表面。这是一个非常易于使用的材料，它对场景中的光源做出反应。这个材料可以使用我们之前已经看到的基本属性进行配置，因此我们不会深入探讨这些属性的细节；相反，我们将专注于特定于这种材料的属性。这仅剩下以下属性：
- en: '`color`: This is the color of the material.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：这是材料颜色。'
- en: '`emissive`: This is the color the material emits. It doesn’t act as a light
    source, but this is a solid color that is unaffected by other lighting. This defaults
    to black. You can use this to create objects that look like they glow.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissive`：这是材料发出的颜色。它不作为光源，但这是一个不受其他光照影响的实色。默认为黑色。你可以使用这个属性来创建看起来像发光物体的对象。'
- en: '`emissiveIntensity`: The intensity with which the object seems to glow.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissiveIntensity`：对象看起来发光的强度。'
- en: 'Creating this object follows the same approach we’ve seen for the other materials:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此对象的方法与我们之前看到的其他材质相同：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For an example of this material, look at the `mesh-lambert-material.html` example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此材质的示例，请查看 `mesh-lambert-material.html` 示例：
- en: '![Figure 4.13 – Mesh lambert material](img/Figure_4.13_B18726.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 网格 Lambert 材质](img/Figure_4.13_B18726.jpg)'
- en: Figure 4.13 – Mesh lambert material
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 网格 Lambert 材质
- en: 'This screenshot shows a torus knot, in white, with a very light red emissive
    glow. One of the interesting features of `THREE.LambertMaterial` is that it also
    supports the wireframe properties, so you can render a wireframe that responds
    to the lights in the scene:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了一个白色的环面结，带有非常淡的红光发射。`THREE.LambertMaterial` 的一个有趣特性是它也支持线框属性，因此您可以渲染一个对场景中的灯光做出反应的线框：
- en: '![Figure 4.14 – Mesh Lambert material with a wireframe](img/Figure_4.14_B18726.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 具有线框的网格 Lambert 材质](img/Figure_4.14_B18726.jpg)'
- en: Figure 4.14 – Mesh Lambert material with a wireframe
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 具有线框的网格 Lambert 材质
- en: The next material works in pretty much the same way but can be used to create
    shiny objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个材质的工作方式几乎与上一个相同，但可以用来创建具有光泽的对象。
- en: THREE.MeshPhongMaterial
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshPhongMaterial
- en: With `THREE.MeshPhongMaterial`, we can create a shiny material. The properties
    you can use for that are pretty much the same as for a non-shiny `THREE.MeshLambertMaterial`
    object. In older versions, this was the only material that you could use to make
    shiny, plastic, or metal-like objects. With newer versions of Three.js, if you
    want more control, you can also use `THREE.MeshStandardMaterial` and `THREE.MeshPhysicalMaterial`.
    We’ll discuss both of these materials after we look at `THREE.MeshPhongMaterial`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.MeshPhongMaterial`，我们可以创建一个具有光泽的材质。可用于此的属性与非光泽的 `THREE.MeshLambertMaterial`
    对象的属性几乎相同。在旧版本中，这是唯一可以用来制作具有光泽、塑料或金属感对象的材质。随着 Three.js 的新版本，如果您想要更多控制，您还可以使用 `THREE.MeshStandardMaterial`
    和 `THREE.MeshPhysicalMaterial`。在查看 `THREE.MeshPhongMaterial` 之后，我们将讨论这两种材质。
- en: 'We’ll once again skip the basic properties and focus on the properties specific
    to this material. The properties of this material are listed here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次跳过基本属性，专注于此材质的特定属性。此材质的属性在此列出：
- en: '`emissive`: This is the color this material emits. It doesn’t act as a light
    source, but this is a solid color that is unaffected by other lighting. This defaults
    to black.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissive`：这是此材质发出的颜色。它不作为光源，但这是一个不受其他光照影响的实色。默认为黑色。'
- en: '`emissiveIntensity`: The intensity with which the object seems to glow.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissiveIntensity`：对象看起来发光的强度。'
- en: '`specular`: This property defines how shiny the material is and with what color
    it shines. If this is set to the same color as the `color` property, you get a
    more metallic-looking material. If this is set to gray, it results in a more plastic-looking
    material.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`specular`：此属性定义了材质的光泽度和发光颜色。如果将其设置为与 `color` 属性相同的颜色，则得到更具金属感的材质。如果设置为灰色，则结果为更具塑料感的材质。'
- en: '`shininess`: This property defines how shiny the specular highlight is. The
    default value for `shininess` is `30`. The higher this value is, the shinier the
    object is.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shininess`：此属性定义了镜面高光的光泽度。`shininess` 的默认值为 `30`。此值越高，对象的光泽度就越高。'
- en: 'Initializing a `THREE.MeshPhongMaterial` material is done in the same way as
    we’ve already seen for all the other materials and is shown in the following line
    of code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个 `THREE.MeshPhongMaterial` 材质的方式与我们已经看到的所有其他材质相同，如下代码行所示：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To give you the best comparison, we will keep using the same models for this
    material as we did for `THREE.MeshLambertMaterial` and the other materials in
    this chapter. You can use the control GUI to play around with this material. For
    instance, the following settings create a plastic-looking material. You can find
    this example in `mesh-phong-material.html`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您提供最佳的比较，我们将继续使用与 `THREE.MeshLambertMaterial` 和本章中其他材质相同的模型。您可以使用控制 GUI 来玩转此材质。例如，以下设置创建了一个具有塑料感的材质。您可以在
    `mesh-phong-material.html` 中找到此示例：
- en: '![Figure 4.15 – Mesh Phong material with high shininess](img/Figure_4.15_B18726.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 具有高光泽度的网格 Phong 材质](img/Figure_4.15_B18726.jpg)'
- en: Figure 4.15 – Mesh Phong material with high shininess
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 具有高光泽度的网格 Phong 材质
- en: As you can see from this screenshot, the object is more shiny and plastic compared
    to what we saw with `THREE.MeshLambertMaterial`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如此截图所示，与 `THREE.MeshLambertMaterial` 相比，该对象的光泽度和塑料感更强。
- en: THREE.MeshToonMaterial
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshToonMaterial
- en: 'Not all the materials Three.js provides are practical. For instance, `THREE.MeshToonMaterial`
    allows you to render an object in a cartoon-like style (see the `mesh-toon-material.html`
    example):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 并非 Three.js 提供的所有材质都实用。例如，`THREE.MeshToonMaterial` 允许您以类似卡通的风格渲染对象（参见 `mesh-toon-material.html`
    示例）：
- en: '![Figure 4.16 – The fox model rendered with MeshToonMaterial](img/Figure_4.16_B18726.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.16 – The fox model rendered with MeshToonMaterial](img/Figure_4.16_B18726.jpg)'
- en: Figure 4.16 – The fox model rendered with MeshToonMaterial
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.16 – The fox model rendered with MeshToonMaterial
- en: As you can see, it looks a little bit like what we saw with `THREE.MeshBasicMaterial`,
    but this material responds to the lights in the scene and supports shadows. It
    just bands colors together to create a cartoon-like effect.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它看起来有点像我们之前看到的 `THREE.MeshBasicMaterial`，但这种材质会响应场景中的灯光并支持阴影。它只是将颜色组合在一起以创建类似卡通的效果。
- en: If you want more realistic materials, `THREE.MeshStandardMaterial` is a good
    choice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更逼真的材质，`THREE.MeshStandardMaterial` 是一个好的选择。
- en: THREE.MeshStandardMaterial
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshStandardMaterial
- en: '`THREE.MeshStandardMaterial` is a material that takes a physics approach to
    determine how to react to the lighting in the scene. It is a great material for
    shiny and metal-like materials, and provides several properties you can use to
    configure this material:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.MeshStandardMaterial` 是一种采用物理方法来确定场景中光照反应的材质。它非常适合用于具有光泽和金属质感的材质，并提供了一些您可以用来配置此材质的属性：'
- en: '`metalness`: This property determines how metal-like a material is. Non-metallic
    materials should use a value of `0`, whereas metallic materials should use a value
    close to 1\. The default is `0.5`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metalness`: 此属性决定了材质的金属程度。非金属材质应使用 `0` 的值，而金属材质应使用接近 `1` 的值。默认值为 `0.5`。'
- en: '`roughness`: You can also set how rough the material is. This determines how
    the light that hits this material is diffused. The default is `0.5`. A value of
    `0` is a mirror-like reflection, whereas a value of `1` diffuses all the light.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roughness`: 您也可以设置材质的粗糙程度。这决定了光线照射到该材质时的扩散情况。默认值为 `0.5`。值为 `0` 时呈现类似镜面的反射，而值为
    `1` 则会扩散所有光线。'
- en: 'Besides these properties, you can also use the `color` and `emissive` properties,
    as well as the properties from `THREE.Material`, to alter this material. As you
    can see in the following screenshot, we can use these properties to simulate a
    kind of brushed metal look by playing around with the `metalness` and `roughness`
    parameters:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性外，您还可以使用 `color` 和 `emissive` 属性，以及来自 `THREE.Material` 的属性，来改变此材质。如以下截图所示，我们可以通过调整
    `metalness` 和 `roughness` 参数来模拟一种刷漆金属的外观：
- en: '![Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial](img/Figure_4.17_B18726.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial](img/Figure_4.17_B18726.jpg)'
- en: Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial
- en: 'Three.js provides a material that provides even more settings to render real-looking
    objects: `THREE.MeshPhysicalMaterial`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一种材质，提供了更多设置以渲染看起来更真实的对象：`THREE.MeshPhysicalMaterial`。
- en: THREE.MeshPhysicalMaterial
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.MeshPhysicalMaterial
- en: 'A material very close to `THREE.MeshStandardMaterial` is `THREE.MeshPhysicalMaterial`.
    With this material, you have more control over the reflectivity of the material.
    This material provides, besides the properties we’ve already seen for `THREE.MeshPhysicalMaterial`,
    the following properties to help you control what the material looks like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `THREE.MeshStandardMaterial` 非常接近的材质是 `THREE.MeshPhysicalMaterial`。使用此材质，您可以更好地控制材质的反射性。除了我们之前看到的
    `THREE.MeshPhysicalMaterial` 的属性外，此材质还提供了以下属性，以帮助您控制材质的外观：
- en: '`clearCoat`: A value indicating a coating layer on top of the material. The
    higher this value is, the more coating is applied, and the more effective the
    `clearCoatRoughness` parameter is. This value ranges from `0` to `1` with a default
    of `0`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearCoat`: 表示材料上涂层层的值。此值越高，涂层的应用越多，`clearCoatRoughness` 参数的效果越明显。此值范围从 `0`
    到 `1`，默认值为 `0`。'
- en: '`clearCoatRoughness`: The roughness used for the coating of the material. The
    rougher it is, the more light is diffused. This is used together with the `clearCoat`
    property. This value ranges from `0` to `1` with a default of `0`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearCoatRoughness`: 材料涂层的粗糙程度。越粗糙，光线扩散越多。这通常与 `clearCoat` 属性一起使用。此值范围从 `0`
    到 `1`，默认值为 `0`。'
- en: 'As we’ve seen for other materials, it is quite hard to reason about the values
    you should use for your specific requirements. It’s often the best choice to add
    a simple UI (as we do in the examples) and play around with the values to get
    to a combination that best reflects your needs. You can see this example in action
    by looking at the `mesh-physical-material.html` example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们看到的其他材质一样，很难推理出你应该为特定需求使用的值。通常，添加一个简单的 UI（如我们在示例中所做）并调整值以找到最能反映你需求的组合是最好的选择。你可以通过查看
    `mesh-physical-material.html` 示例来查看这个示例的实际效果：
- en: '![Figure 4.18 – Mesh physical material using a clear coat to control reflection](img/Figure_4.18_B18726.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 使用清漆控制反射的网格物理材质](img/Figure_4.18_B18726.jpg)'
- en: Figure 4.18 – Mesh physical material using a clear coat to control reflection
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 使用清漆控制反射的网格物理材质
- en: Most of the advanced materials cast and receive shadows. The next material we’re
    going to have a quick look at is a bit different than most. This material doesn’t
    render the object itself, but only shows the shadows.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级材质都能投射和接收阴影。我们将快速查看的下一个材质与大多数材质略有不同。这种材质不会渲染对象本身，而只显示阴影。
- en: THREE.ShadowMaterial
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.ShadowMaterial
- en: '`THREE.ShadowMaterial` is a special material that doesn’t have any properties.
    You can’t set the color or the shininess, or anything else. The only thing this
    material does is render the shadow the mesh would receive. The following screenshot
    should explain this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShadowMaterial` 是一种特殊的材质，它没有任何属性。你不能设置颜色或光泽，或任何其他东西。这个材质唯一能做的就是渲染网格接收到的阴影。以下截图应该可以解释这一点：'
- en: '![Figure 4.19 – Shadow material just rendering the shadows the mesh receives](img/Figure_4.19_B18726.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 仅渲染网格接收到的阴影的阴影材质](img/Figure_4.19_B18726.jpg)'
- en: Figure 4.19 – Shadow material just rendering the shadows the mesh receives
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 仅渲染网格接收到的阴影的阴影材质
- en: Here, the only thing we can see are the shadows the object receives, nothing
    else. This material can, for instance, be combined with your own materials without
    you having to determine how to receive shadows.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只能看到对象接收到的阴影，没有其他东西。这种材质可以，例如，与你的其他材质结合使用，而无需确定如何接收阴影。
- en: The last of the advanced materials we’ll explore is `THREE.ShaderMaterial`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的最后一种高级材质是 `THREE.ShaderMaterial`。
- en: Using your own shaders with THREE.ShaderMaterial
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 THREE.ShaderMaterial 自定义着色器
- en: '`THREE.ShaderMaterial` is one of the most versatile and complex materials available
    in Three.js. With this material, you can pass in your own custom shaders that
    are directly run in the WebGL context. A shader converts Three.js JavaScript meshes
    into pixels on the screen. With these custom shaders, you can define exactly how
    your object should be rendered and how to override or alter the defaults from
    Three.js. In this section, we won’t go into too much detail on how to write custom
    shaders; instead, we will just show you a couple of examples.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ShaderMaterial` 是 Three.js 中最灵活和复杂的材质之一。使用这种材质，你可以传递自己的自定义着色器，这些着色器直接在
    WebGL 上下文中运行。着色器将 Three.js 的 JavaScript 网格转换为屏幕上的像素。使用这些自定义着色器，你可以精确地定义你的对象应该如何渲染，以及如何覆盖或修改
    Three.js 的默认设置。在本节中，我们不会过多地介绍如何编写自定义着色器；相反，我们只会展示几个示例。'
- en: 'As we’ve already seen, `THREE.ShaderMaterial` has several properties you can
    set. With `THREE.ShaderMaterial`, Three.js passes in all the information regarding
    these properties to your custom shaders, but you still have to process the information
    to create colors and vertex positions. The following are the properties of `THREE.Material`
    that are passed into the shader, and that you can interpret for yourself:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`THREE.ShaderMaterial` 有几个你可以设置的属性。使用 `THREE.ShaderMaterial`，Three.js
    会将所有关于这些属性的详细信息传递给你的自定义着色器，但你仍然需要处理这些信息以创建颜色和顶点位置。以下是将传递到着色器中的 `THREE.Material`
    属性，你可以自己进行解释：
- en: '`wireframe`: This renders the material as a wireframe. This is great for debugging
    purposes.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wireframe`: 这会将材质渲染为线框。这对于调试目的非常有用。'
- en: '`shading`: This defines how shading is applied. The possible values are `THREE.SmoothShading`
    and `THREE.FlatShading`. This property isn’t enabled in the example for this material.
    For an example, look at the *THREE.* *MeshNormalMaterial* section.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shading`: 这定义了阴影的应用方式。可能的值有 `THREE.SmoothShading` 和 `THREE.FlatShading`。这个属性在这个材料的示例中没有被启用。例如，可以查看
    *THREE.* *MeshNormalMaterial* 部分。'
- en: '`vertexColors`: You can define individual colors to be applied to each vertex
    with this property. Look at the `LineBasicMaterial` example in the *THREE.LineBasicMaterial*
    section, where we use this property to color the various parts of a line.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexColors`: 您可以使用此属性为每个顶点定义要应用的颜色。查看*THREE.LineBasicMaterial*部分中的`LineBasicMaterial`示例，在那里我们使用此属性为线的各个部分着色。'
- en: '`fog`: This determines whether this material is affected by global fog settings.
    This is not shown in action. If this is set to `false`, the global fog we saw
    in [*Chapter 2*](B18726_02.xhtml#_idTextAnchor028) doesn’t affect how this object
    is rendered.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fog`: 这决定了这个材料是否受全局雾设置的影响。这不会在动作中显示。如果设置为`false`，我们在[*第2章*](B18726_02.xhtml#_idTextAnchor028)中看到的全局雾不会影响这个对象的渲染方式。'
- en: 'Besides these properties that are passed into the shader, `THREE.ShaderMaterial`
    also provides several specific properties you can use to pass in additional information
    into your custom shader. Once again, we won’t go into too much detail on how you
    can write your own shaders, since that would be a book on its own, so we’ll just
    cover the basics:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递给着色器的这些属性外，`THREE.ShaderMaterial`还提供了一些特定的属性，您可以使用它们将额外的信息传递到您的自定义着色器中。再次强调，我们不会过多地详细介绍如何编写自己的着色器，因为这本身就可以是一本专著，所以我们只介绍基础知识：
- en: '`fragmentShader`: This shader defines the color of each pixel that is passed
    in. Here, you need to pass in the string value of your fragment shader program.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragmentShader`: 这个着色器定义了传入的每个像素的颜色。在这里，您需要传入您的片段着色器程序的字面值字符串。'
- en: '`vertextShader`: This shader allows you to change the position of each vertex
    that is passed in. Here, you need to pass in the string value of your vertex shader
    program.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexShader`: 这个着色器允许您改变传入的每个顶点的位置。在这里，您需要传入您的顶点着色器程序的字面值字符串。'
- en: '`uniforms`: This allows you to send information to your shader. The same information
    is sent to each vertex and fragment.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniforms`: 这允许您将信息发送到您的着色器。相同的信息被发送到每个顶点和片段。'
- en: '`defines`: Converts custom key value pairs as `#define` code fragments. With
    these fragments, you can set some additional global variables in the shader programs
    or define your own custom global constants.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defines`: 将自定义键值对转换为`#define`代码片段。使用这些片段，您可以在着色器程序中设置一些额外的全局变量或定义您自己的自定义全局常量。'
- en: '`attributes`: These can change between each vertex and fragment. They are usually
    used to pass positional and normal-related data. If you want to use this property,
    you need to provide information for all the vertices of the geometry.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`: 这些属性可以在每个顶点和片段之间变化。它们通常用于传递位置和法线相关的数据。如果您想使用这个属性，您需要为几何形状的所有顶点提供信息。'
- en: '`lights`: This determines whether light data should be passed into the shaders.
    This defaults to `false`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lights`: 这决定了是否应将光数据传递到着色器中。默认为`false`。'
- en: 'Before we look at an example, we’ll provide a quick explanation of the most
    important parts of `THREE.ShaderMaterial`. To work with this material, we have
    to pass in two different shaders:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，我们将快速解释`THREE.ShaderMaterial`最重要的部分。要使用这种材料，我们必须传递两个不同的着色器：
- en: '`vertexShader`: This is run on each vertex of the geometry. You can use this
    shader to transform the geometry by moving the position of the vertices around.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexShader`: 这是在几何形状的每个顶点上运行的。您可以使用这个着色器通过移动顶点的位置来变换几何形状。'
- en: '`fragmentShader`: This is run on each fragment of the geometry. In `fragmentShader`,
    we return the color that should be shown for this specific fragment.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fragmentShader`: 这是在几何形状的每个片段上运行的。在`fragmentShader`中，我们返回应该显示给这个特定片段的颜色。'
- en: For all the materials we’ve discussed so far in this chapter, Three.js provides
    `fragmentShader` and `vertexShader`, so you don’t have to worry about them and
    pass them in explicitly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中讨论的所有材料，Three.js提供了`fragmentShader`和`vertexShader`，因此您不必担心它们，也不必明确传递它们。
- en: In this section, we’ll look at a simple example that uses a very simple `vertexShader`
    program that changes the `x` and `y` coordinates of the vertices of a simple `THREE.PlainGeometry`
    and a `fragmentShader` program that changes the color based on some input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个简单的示例，该示例使用一个非常简单的`vertexShader`程序，该程序改变简单`THREE.PlainGeometry`的顶点的`x`和`y`坐标，以及一个`fragmentShader`程序，该程序根据一些输入改变颜色。
- en: 'Up next, you can see the complete code for our `vertexShader`. Note that writing
    shaders isn’t done in JavaScript. You write shaders in a C-like language called
    GLSL (WebGL supports OpenGL ES Shading Language 1.0 — for more information on
    GLSL, see [https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)). The
    code for our simple shader looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到我们的`vertexShader`的完整代码。请注意，编写着色器不是在JavaScript中完成的。你使用一种类似于C的语言编写着色器，称为GLSL（WebGL支持OpenGL
    ES Shading Language 1.0 —— 关于GLSL的更多信息，请参阅[https://www.khronos.org/webgl/](https://www.khronos.org/webgl/))。我们的简单着色器代码看起来像这样：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We won’t go into too much detail here and just focus on the most important parts
    of this code. To communicate with the shaders from JavaScript, we use something
    called uniforms. In this example, we use the `uniform float time;` statement to
    pass in an external value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会过多地深入细节，只关注这段代码最重要的部分。为了从JavaScript与着色器通信，我们使用一种称为uniforms的东西。在这个例子中，我们使用`uniform
    float time;`语句传入一个外部值。
- en: 'Based on this value, we change the `x`, `y`, and `z` coordinates of the passed-in
    vertex (which is passed in as the position variable):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此值，我们更改传入顶点的`x`、`y`和`z`坐标（该顶点作为位置变量传入）：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `posChanged` vector now contains the new coordinate for this vertex based
    on the passed-in time variable. The last step we need to perform is to pass this
    new position back to the renderer, which is always done like this for Three.js:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`posChanged`向量现在包含根据传入的时间变量计算出的这个顶点的新的坐标。我们需要执行的最后一个步骤是将这个新位置传回渲染器，对于Three.js来说，这总是这样做的：'
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `gl_Position` variable is a special variable that is used to return the
    final position. This program is passed as a string value to the `vertexShader`
    property of `THREE.ShaderMaterial`. For `fragmentShader`, we do something similar.
    We’ve created a very simple fragment shader that just flips through colors based
    on the passed-in `time` uniform:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_Position`变量是一个特殊变量，用于返回最终位置。这个程序作为字符串值传递给`THREE.ShaderMaterial`的`vertexShader`属性。对于`fragmentShader`，我们做类似的事情。我们创建了一个非常简单的片段着色器，它根据传入的`time`uniform翻转颜色：'
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we do in a `fragmentShader` is determine the color of a passed-in fragment
    (a pixel). The real shader programs take a lot into account, such as lights, the
    position of the vertex on the face, normals, and more. In this example, though,
    we just determine the `rgb` values of a color and return that in `gl_FragColor`,
    which is then shown on the final rendered mesh.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fragmentShader`中，我们确定传入的片段（一个像素）的颜色。真实的着色器程序考虑了很多因素，比如灯光、顶点在面上的位置、法线等等。然而，在这个例子中，我们只是确定颜色的`rgb`值，并在`gl_FragColor`中返回它，然后它会在最终渲染的网格上显示出来。
- en: 'Now, we need to glue the geometry, the material, and the two shaders together.
    In Three.js, we can do that like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将几何体、材质和两个着色器粘合在一起。在Three.js中，我们可以这样做：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we define the `time` uniform, which will contain a value available in
    the shaders, and define `vertexShader` and `fragmentShader` as strings that we
    want to use. The only thing we need to do is make sure we change the `time` uniform
    in the render loop, and that’s it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`time`uniform，它将包含在着色器中可用的值，并将`vertexShader`和`fragmentShader`定义为我们要使用的字符串。我们唯一需要做的是确保在渲染循环中更改`time`uniform，然后就可以了：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the examples for this chapter, we’ve added a couple of simple shaders to
    experiment with. You will see the results if you open up the `shader-material-vertex.html`
    example in the `chapter-4` folder:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们添加了一些简单的着色器来进行实验。如果你打开`chapter-4`文件夹中的`shader-material-vertex.html`示例，你会看到结果：
- en: '![Figure 4.20 – A shader material that shows a plane with the two example shader
    programs](img/Figure_4.20_B18726.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – 显示两个示例着色程序的平面着色器材质](img/Figure_4.20_B18726.jpg)'
- en: Figure 4.20 – A shader material that shows a plane with the two example shader
    programs
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 显示两个示例着色程序的平面着色器材质
- en: 'In the dropdown menu, you can also find a couple of other shaders. For instance,
    the `fs_night_sky` fragment shader shows a starry night (based on the shader from
    [https://www.shadertoy.com/view/Nlffzj](https://www.shadertoy.com/view/Nlffzj)).
    When combined with `vs_ripple`, you get a very nice-looking effect, completely
    running on the GPU, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中，你还可以找到一些其他的着色器。例如，`fs_night_sky`片段着色器显示了一个星空夜空（基于[https://www.shadertoy.com/view/Nlffzj](https://www.shadertoy.com/view/Nlffzj)的着色器）。当与`vs_ripple`结合使用时，你会得到一个非常漂亮的视觉效果，完全在GPU上运行，如图所示：
- en: '![Figure 4.21 – Rippling effect with a starry night fragment shader](img/Figure_4.21_B18726.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21 – 使用星空片段着色器的涟漪效果](img/Figure_4.21_B18726.jpg)'
- en: Figure 4.21 – Rippling effect with a starry night fragment shader
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to combine existing materials and reuse their fragment and vertex
    shaders with your own shaders. That way, you can, for instance, extend `THREE.MeshStandardMaterial`
    with some custom effects. Doing this in plain Three.js, however, is rather difficult
    to do and very error prone. Luckily, there is an open source project that provides
    us with a custom material that makes it very easy to wrap existing materials and
    add our own custom shaders. In the next section, we’ll have a quick look at how
    that works.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Customizing existing shaders with CustomShaderMaterial
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.CustomShader` doesn’t come with the default Three.js distribution, but
    since we’re using `yarn`, it is really easy to install (this is what you did when
    running the relevant commands from [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014),
    *Creating Your First 3D Scene wth Three.js*). If you want more information on
    this module, you can check out [https://github.com/FarazzShaikh/THREE-CustomShaderMaterial](https://github.com/FarazzShaikh/THREE-CustomShaderMaterial),
    where you can find documentation and additional examples.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s have a quick look at the code before we show some examples. Using
    `THREE.CustomShader` is the same as using the other materials:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, it is a bit of a combination of a normal material and a `THREE.ShaderMaterial`.
    The main thing to look at is the `baseMaterial` property. Here, you can add any
    of the standard Three.js materials. Any additional property you add, besides `vertexShader`,
    `fragmentShader`, and `uniforms`, gets applied to this `baseMaterial`. The `vertexshader`,
    `fragmentShader`, and `uniforms` properties work in the same way as we’ve seen
    for `THREE.ShaderMaterial`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, we need to make a couple of small changes to our shaders themselves.
    Recall the *Using your own shaders with THREE.ShaderMaterial* section, where we
    used `gl_Position` and `gl_FragColor` to set the final output of the position
    of a vertex and the color of a fragment. With this material, we use `csm_Position`
    for the final position and `csm_DiffuseColor` for the color. There are a couple
    more output variables you can use, which are explained in more detail here: [https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables](https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `custom-shader-material` example, you will see how our simple
    shaders can be used together with the default materials from Three.js:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials
    as the base](img/Figure_4.22_B18726.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials
    as the base
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: This approach gives you a relatively easy way to create your custom shaders,
    without having to start completely from scratch. You can just reuse the lights
    and shadow effects from the default shaders and extend them with your custom-needed
    functionality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法为您提供了一个相对简单的方式来创建自定义着色器，而无需从头开始。您只需重用默认着色器中的灯光和阴影效果，并扩展它们以包含您所需的自定义功能。
- en: So far, we’ve looked at materials that work with meshes. Three.js also provides
    materials that can be used together with line geometries. In the next section,
    we’ll explore those materials.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已查看与网格一起工作的材料。Three.js 还提供了可以与线几何体一起使用的材料。在下一节中，我们将探讨这些材料。
- en: Materials you can use for a line geometry
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用于线几何体的材料
- en: 'The last couple of materials we’re going to look at can only be used on one
    specific mesh: `THREE.Line`. As the name implies, this is just a single line that
    only consists of lines and doesn’t contain any faces. Three.js provides two different
    materials you can use on a `THREE.Line` geometry, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后几种材料只能用于一个特定的网格：`THREE.Line`。正如其名称所暗示的，这仅仅是一条线，只由线组成，不包含任何面。Three.js
    提供了两种不同的材料，您可以在 `THREE.Line` 几何体上使用，如下所示：
- en: '`THREE.LineBasicMaterial`: This basic material for a line allows you to set
    the `color` and `vertexColors` properties.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineBasicMaterial`：这是一种基本的线材料，允许您设置 `color` 和 `vertexColors` 属性。'
- en: '`THREE.LineDashedMaterial`: This has the same properties as `THREE.LineBasicMaterial`
    but allows you to create a dashed line effect by specifying `dash` and `spacing`
    sizes.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LineDashedMaterial`：它具有与 `THREE.LineBasicMaterial` 相同的属性，但允许您通过指定 `dash`
    和 `spacing` 大小来创建虚线效果。'
- en: We’ll start with the basic variant; after that, we’ll look at the dashed variant.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看基本变体；之后，我们将查看虚线变体。
- en: THREE.LineBasicMaterial
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineBasicMaterial
- en: 'The materials that are available for the `THREE.Line` geometry are very simple.
    It inherits all of the properties from `THREE.Material`, but the following are
    the properties that are most important for this material:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 `THREE.Line` 几何体的材料非常简单。它继承了 `THREE.Material` 的所有属性，但以下是该材料最重要的属性：
- en: '`color`: This determines the color of the line. If you specify `vertexColors`,
    this property is ignored. An example of how to do this is shown in the following
    code fragment.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：这决定了线的颜色。如果您指定了 `vertexColors`，则此属性将被忽略。以下代码片段展示了如何进行此操作。'
- en: '`vertexColors`: You can supply a specific color for each vertex by setting
    this property to the `THREE.VertexColors` value.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexColors`：您可以通过将此属性设置为 `THREE.VertexColors` 值来为每个顶点提供特定的颜色。'
- en: 'Before we look at an example of `THREE.LineBasicMaterial`, let’s have a quick
    look at how we can create a `THREE.Line` mesh from a set of vertices and combine
    that with `THREE.LineMaterial` to create the mesh, as shown in the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 `THREE.LineBasicMaterial` 的示例之前，让我们快速看一下如何从一组顶点创建一个 `THREE.Line` 网格，并将其与
    `THREE.LineMaterial` 结合起来以创建网格，如下所示：
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first part of this code fragment, `const points = gosper(4, 60)`, is used
    as an example to get a set of `x`, `y`, and `z` coordinates. This function returns
    a Gosper curve (for more information, check out [https://mathworld.wolfram.com/Peano-GosperCurve.html](https://mathworld.wolfram.com/Peano-GosperCurve.html)),
    which is a simple algorithm that fills a 2D space. What we do next is create a
    `THREE.BufferGeometry` instance and call the `setFromPoints` function to add the
    generated points. For each coordinate, we also calculate a color value that we
    use to set the `color` attribute of the geometry. Note `mesh.computeLineDistances`
    at the end of this code fragment. This is needed when you want to have dashed
    lines when using `THREE.LineDashedMaterial`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的第一部分 `const points = gosper(4, 60)` 被用作示例，以获取一组 `x`、`y` 和 `z` 坐标。此函数返回一个
    Gosper 曲线（更多信息，请参阅 [https://mathworld.wolfram.com/Peano-GosperCurve.html](https://mathworld.wolfram.com/Peano-GosperCurve.html)），这是一个简单的算法，用于填充
    2D 空间。接下来我们要做的是创建一个 `THREE.BufferGeometry` 实例，并调用 `setFromPoints` 函数来添加生成的点。对于每个坐标，我们还会计算一个颜色值，并将其用于设置几何体的
    `color` 属性。注意此代码片段末尾的 `mesh.computeLineDistances`。当您想使用 `THREE.LineDashedMaterial`
    时，这将是必需的。
- en: 'Now that we have our geometry, we can create `THREE.LineBasicMaterial` and
    use this together with the geometry to create a `THREE.Line` mesh. You can see
    the result in the `line-basic-material.html` example. The following screenshot
    shows this example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的几何体，我们可以创建 `THREE.LineBasicMaterial` 并将其与几何体一起使用来创建一个 `THREE.Line`
    网格。您可以在 `line-basic-material.html` 示例中看到结果。以下截图显示了此示例：
- en: '![Figure 4.23 – Line basic material](img/Figure_4.23_B18726.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 基本线材料](img/Figure_4.23_B18726.jpg)'
- en: Figure 4.23 – Line basic material
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 基本线材料
- en: 'This is a line geometry created with `THREE.LineBasicMaterial`. If we enable
    the `vertexColors` property, we will see that the individual line segments are
    colored:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`THREE.LineBasicMaterial`创建的线几何体。如果我们启用`vertexColors`属性，我们会看到各个线段都有颜色：
- en: '![Figure 4.24 – Line basic material with vertex colors](img/Figure_4.24_B18726.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24 – 带顶点颜色的基本线材料](img/Figure_4.24_B18726.jpg)'
- en: Figure 4.24 – Line basic material with vertex colors
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – 带顶点颜色的基本线材料
- en: The next and last material we’ll discuss in this chapter is only slightly different
    from `THREE.LineBasicMaterial`. With `THREE.LineDashedMaterial`, not only can
    we color lines, but we can also add spaces to those lines.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来要讨论的最后一种材料与`THREE.LineBasicMaterial`只有细微的差别。使用`THREE.LineDashedMaterial`，我们不仅可以给线着色，还可以给这些线添加空间。
- en: THREE.LineDashedMaterial
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LineDashedMaterial
- en: 'This material has the same properties as `THREE.LineBasicMaterial` and three
    additional ones you can use to define the dash width and the width of the gaps
    between the dashes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料具有与`THREE.LineBasicMaterial`相同的属性，以及三个额外的属性，可以用来定义虚线的宽度和虚线之间的间隙宽度：
- en: '`scale`: This scales `dashSize` and `gapSize`. If the scale is smaller than
    `1`, `dashSize` and `gapSize` increase, whereas if the scale is larger than `1`,
    `dashSize` and `gapSize` decrease.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`: 这会缩放`dashSize`和`gapSize`。如果缩放小于`1`，则`dashSize`和`gapSize`增加，而如果缩放大于`1`，则`dashSize`和`gapSize`减小。'
- en: '`dashSize`: This is the size of the dash.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashSize`: 这是虚线的长度。'
- en: '`gapSize`: This is the size of the gap.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gapSize`: 这是间隙的长度。'
- en: 'This material works almost exactly like `THREE.LineBasicMaterial`. The only
    difference is that you have to call `computeLineDistances()` (which is used to
    determine the distance between the vertices that make up a line). If you don’t
    do this, the gaps won’t be shown correctly. An example of this material can be
    found in `line-dashed-material.html` and looks like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这种材料几乎与`THREE.LineBasicMaterial`完全相同。唯一的区别是您必须调用`computeLineDistances()`（用于确定构成线的顶点之间的距离）。如果不这样做，间隙将不会正确显示。这种材料的示例可以在`line-dashed-material.html`中找到，看起来是这样的：
- en: '![Figure 4.25 – A Gosper mesh with the line dashed material](img/Figure_4.25_B18726.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图4.25 – 使用线虚线材料的高斯网格](img/Figure_4.25_B18726.jpg)'
- en: Figure 4.25 – A Gosper mesh with the line dashed material
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 – 使用线虚线材料的高斯网格
- en: That’s it for this section on materials used for lines. You’ve seen that Three.js
    only provides a few materials specifically for line geometries, but with these
    materials, especially in combination with `vertexColors`, you should be able to
    style the line geometries any way you want.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用于线的材料这一部分就到这里。您已经看到，Three.js只为线几何体提供了一些特定的材料，但使用这些材料，特别是与`vertexColors`结合使用，您应该能够以任何您想要的方式样式化线几何体。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Three.js gives you a lot of materials you can use to skin your geometries. The
    materials range from the very simple (`THREE.MeshBasicMaterial`) to the complex
    (`THREE.ShaderMaterial`), where you can provide your own `vertexShader` and `fragmentShader`
    programs. Materials share a lot of basic properties. If you know how to use a
    single material, you’ll probably also know how to use the other materials. Note
    that not all materials respond to the lights in your scene. If you want a material
    that takes lighting into effect, you can usually just use `THREE.MeshStandardMaterial`.
    If you need more control, you can also look at `THREE.MeshPhysicalMaterial`, `THREE.MeshPhongMaterial`,
    or `THREE.MeshLamberMaterial`. Determining the effect of certain material properties
    from just code is very hard. Often, a good idea is to use the control GUI approach
    to experiment with these properties, as we showed in this chapter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了许多您可以用来为几何体着色的材料。这些材料从非常简单的（`THREE.MeshBasicMaterial`）到复杂的（`THREE.ShaderMaterial`），其中您可以提供自己的`vertexShader`和`fragmentShader`程序。材料共享许多基本属性。如果您知道如何使用一种材料，您可能也知道如何使用其他材料。请注意，并非所有材料都对场景中的灯光做出反应。如果您需要一个考虑光照效果的材质，通常只需使用`THREE.MeshStandardMaterial`。如果您需要更多控制，也可以查看`THREE.MeshPhysicalMaterial`、`THREE.MeshPhongMaterial`或`THREE.MeshLamberMaterial`。仅从代码中确定某些材质属性的效果非常困难。通常，一个好的方法是使用控制GUI方法来实验这些属性，就像我们在本章中展示的那样。
- en: 'Also, remember that most of the properties of a material can be modified at
    runtime. Some, though (for example, `side`), can’t be modified at runtime. If
    you change such a value, you need to set the `needsUpdate` property to `true`.
    For a complete overview of what can and cannot be changed at runtime, see the
    following page: [https://threejs.org/docs/#manual/en/introduction/How-to-update-things](https://threejs.org/docs/#manual/en/introduction/How-to-update-things).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，大多数材料的属性都可以在运行时进行修改。尽管如此（例如，`side`），有些属性在运行时是无法修改的。如果你更改了这样的值，你需要将`needsUpdate`属性设置为`true`。关于在运行时可以和不可以更改的完整概述，请参阅以下页面：[https://threejs.org/docs/#manual/en/introduction/How-to-update-things](https://threejs.org/docs/#manual/en/introduction/How-to-update-things)。
- en: In this and the previous chapters, we talked about geometries. We used these
    in our examples and explored a couple of them. In the next chapter, you’ll learn
    everything about geometries and how you can work with them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一章中，我们讨论了几何体。我们在示例中使用它们，并探索了其中的一些。在下一章中，你将了解有关几何体的所有内容以及如何与它们一起工作。
