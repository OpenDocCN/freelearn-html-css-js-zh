- en: Chapter 4. Building Media Queries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：构建媒体查询
- en: 'The days of simply using one device to browse an online site are long since
    gone: responsive sites will work on a range of devices, from smart phones through
    to digital TVs and laptops. A key element of making sites responsive is the use
    of media queries. In this chapter, we''ll explore how to create them using PostCSS,
    see how they compare to the likes of Less and SASS, and how the use of PostCSS
    makes for a more flexible approach in comparison to standard preprocessors. This
    chapter will cover the following technical topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单一设备浏览在线网站的日子已经一去不复返了：响应式网站将在各种设备上运行，从智能手机到数字电视和笔记本电脑。使网站响应式的一个关键要素是使用媒体查询。在本章中，我们将探讨如何使用PostCSS创建它们，看看它们与Less和SASS等工具相比如何，以及PostCSS的使用如何使方法比标准预处理器更加灵活。本章将涵盖以下技术主题：
- en: Revisiting media queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视媒体查询
- en: Working through the basics of media queries using PostCSS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostCSS掌握媒体查询的基础
- en: Adding responsive support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加响应式支持
- en: Optimizing media queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化媒体查询
- en: Retrofitting support for older browsers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧浏览器添加支持
- en: Taking things further—exploring the hover feature in CSS4 media queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索——在CSS4媒体查询中探索悬停功能
- en: Let's make a start…!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧…！
- en: Revisiting media queries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视媒体查询
- en: If you spend any time viewing sites on different devices, then it will hardly
    come as a surprise to see media queries in the style sheet—they form the basis
    for responsive design and declarations allow us to control what is displayed on
    screen, according to the available screen width.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间在不同的设备上查看网站，那么在样式表中看到媒体查询几乎不会令人惊讶——它们是响应式设计的基础，并且声明允许我们根据可用的屏幕宽度控制屏幕上显示的内容。
- en: 'The principles behind media queries are simple. In a nutshell, we have to define
    the device or media, and the resolution (or width) at which point the rule (or
    breakpoint) either kicks in or stops being applied. Take this simple example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询背后的原理很简单。简而言之，我们必须定义设备或媒体，以及规则（或断点）开始应用或停止应用的分辨率（或宽度）。以下是一个简单的例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any styles within will be applied only when we're viewing on screen, and our
    available screen estate is `768px` or less. This is a simple example, they can
    be as simple or as complex as required; it's down to us as developers to work
    out exactly where our content breaks and to build a suitable breakpoint to manage
    the change.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中使用的任何样式都仅在屏幕上查看时应用，并且我们的可用屏幕空间为`768px`或更小。这是一个简单的例子，它们可以像所需的那样简单或复杂；这取决于我们作为开发者来确定我们的内容在哪里断裂，并构建一个合适的断点来管理变化。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get a feel for some of the more recent media queries that are possible, take
    a look at this post by Chris Coyier, who has queries for laptops, PCs, and even
    wearable devices! The list is available at [https://css-tricks.com/snippets/css/media-queries-for-standard-devices/](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受一些最近可能的媒体查询，请查看Chris Coyier的这篇帖子，他提供了针对笔记本电脑、PC甚至可穿戴设备的查询！列表可在[https://css-tricks.com/snippets/css/media-queries-for-standard-devices/](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/)找到。
- en: 'Okay, let''s make a start: PostCSS makes it easy to manage queries for both
    text and images; we''ll begin our journey with a look at handling images.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧：PostCSS使得管理文本和图像的查询变得简单；我们将从查看如何处理图像开始我们的旅程。
- en: Exploring custom media queries in PostCSS
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索PostCSS中的自定义媒体查询
- en: Making the switch to using PostCSS is a cinch, we can use the `postcss-custom-media`
    plugin for this purpose, available at [https://github.com/postcss/postcss-custom-media](https://github.com/postcss/postcss-custom-media).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 转向使用PostCSS非常简单，我们可以使用`postcss-custom-media`插件来完成此目的，可在[https://github.com/postcss/postcss-custom-media](https://github.com/postcss/postcss-custom-media)找到。
- en: 'The plugin is easy to install, it follows the same principles as all of the
    other plugins we''ve covered, so without further ado, let''s get that out of the
    way now:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 插件易于安装，它遵循我们之前介绍的所有其他插件的原则，所以无需多言，我们现在就把它解决掉：
- en: Fire up a Node.js command prompt, then navigate to the working directory.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Node.js命令提示符，然后导航到工作目录。
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中输入以下命令，然后按*Enter*键：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keep the command prompt open for now, we will use it in the next few steps.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前请保持命令提示符打开，我们将在接下来的几个步骤中使用它。
- en: 'With the plugin installed, we can now use it, before we get stuck into converting
    our previous demo, let''s work through a simple example, so you can see it in
    action:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装插件后，我们现在可以使用它了，在我们开始转换之前的演示之前，让我们通过一个简单的例子来操作，这样你就可以看到它的实际效果：
- en: 'In a new file, add the following code, saving it as `style.css` within the
    `src` folder at the root of our project area:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，将其保存为项目区域根目录下的`src`文件夹中的`style.css`：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remove the existing `gulpfile.js` file from the root of the project area.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目区域的根目录中删除现有的`gulpfile.js`文件。
- en: 'In a new file, add the following code, this will form a new `gulpfile.js` file;
    save this to the root of our project area:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，这将形成一个新的`gulpfile.js`文件；将其保存到项目区域的根目录：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Revert back to the command prompt session we had open earlier, then enter `gulp`
    at the command prompt, and press *Enter*.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回我们之前打开的命令提示符会话，然后在命令提示符中输入`gulp`，然后按*Enter*键。
- en: 'If all is well, we should see this code if we open up the compiled `style.css`
    from within the `dest` folder of our project area:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在项目区域的`dest`文件夹中打开编译后的`style.css`时看到此代码：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Believe it or not, this is all that is required to use the plugin; let's take
    a moment to consider what we've covered through this demo.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是使用插件所需的所有内容；让我们花点时间考虑一下通过这个演示我们涵盖了什么。
- en: At first glance, you might be forgiven for thinking that this plugin doesn't
    actually do anything to help us—it's a valid point, but there is one key benefit
    to using this plugin. We can separate out the media breakpoints into separate
    variable statements, and store these at the top of our style sheet. This means
    that if we should ever need to update a particular breakpoint, we only need to
    do it once. Our code is then updated automatically at the compilation stage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能认为这个插件实际上并没有做什么来帮助我们——这是一个合理的观点，但使用这个插件有一个关键的好处。我们可以将媒体断点分离成单独的变量声明，并将这些存储在样式表的顶部。这意味着如果我们需要更新特定的断点，我们只需要做一次。然后在编译阶段，我们的代码会自动更新。
- en: With that in mind, let's get stuck into a demo; we're going to work through
    the previous plain CSS version of our parallax scrolling example, and convert
    it to use PostCSS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始一个演示；我们将处理之前平铺滚动的CSS版本，并将其转换为使用PostCSS。
- en: Beginning with plain CSS
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从纯CSS开始
- en: 'Over the next few pages, we''re going to use a relatively recent technique
    as the basis for our demo—parallax scrolling. Just in case you''ve been under
    a rock, parallax scrolling is a single page application, which allows us to scroll
    through content whilst showing a number of fixed images behind our content:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将使用一种相对较新的技术作为我们演示的基础——平铺滚动。以防你躲在岩洞里，平铺滚动是一个单页应用程序，它允许我们在滚动内容的同时显示一系列固定在内容后面的图像：
- en: '![Beginning with plain CSS](img/BO5194_04_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![从纯CSS开始](img/BO5194_04_01.jpg)'
- en: We'll be using a demo created by Nick Salloum, which is available at [http://callmenick.com/_development/simple-parallax-effect/](http://callmenick.com/_development/simple-parallax-effect/)
    (I've simplified some of the CSS styles used, removed vendor prefixes, and reduced
    the number of separate files called by the example). We'll start with a plain
    CSS version of our demo—go ahead and extract a copy of `Tutorial11` to our project
    area. Try running `index.html`; if all is well, we should see something akin to
    the screenshot at the head of this section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由Nick Salloum创建的演示，该演示可在[http://callmenick.com/_development/simple-parallax-effect/](http://callmenick.com/_development/simple-parallax-effect/)找到（我已经简化了一些CSS样式，移除了供应商前缀，并减少了示例中调用的单独文件的数量）。我们将从演示的纯CSS版本开始——请将`Tutorial11`的副本提取到我们的项目区域。尝试运行`index.html`；如果一切顺利，我们应该看到类似于本节开头截图的内容。
- en: It's a great effect when used well, our interest is in the last section of the
    CSS file, from around line 133; this section contains the media queries we will
    convert in our next demo.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用得当的时候，这是一个很棒的效果，我们的兴趣在于CSS文件的最后部分，大约在第133行；这一部分包含我们将要在下一个演示中转换的媒体查询。
- en: Altering our demo to use PostCSS
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的演示修改为使用PostCSS
- en: If media queries are used correctly, this can open up a world of possibilities;
    we can tweak our style sheet for anything from an iPhone through to a printer.
    In our demo, we've used a couple to adjust how content is displayed on sites where
    displays are larger than `600px` or `960px` width; altering these to work in PostCSS
    is a cinch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确使用媒体查询，这可以打开一个充满可能性的世界；我们可以调整我们的样式表以适应从 iPhone 到打印机等各种设备。在我们的演示中，我们使用了一些来调整在显示宽度大于
    `600px` 或 `960px` 的网站上内容的显示方式；将这些调整到在 PostCSS 中工作非常简单。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The CSS3 Media Queries site has a large list of different types of queries that
    are available; if you check out the site on a target PC or device, it will show
    you if that query is supported on that device. The full list is available at [http://www.cssmediaqueries.com](http://www.cssmediaqueries.com).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3 媒体查询网站列出了大量不同类型的查询；如果您在目标 PC 或设备上查看该网站，它将显示该查询是否在该设备上受支持。完整列表可在[http://www.cssmediaqueries.com](http://www.cssmediaqueries.com)找到。
- en: 'We only need to make a couple of changes in the style sheet to switch to using
    PostCSS, so let''s make a start:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在样式表中做一些更改即可切换到使用 PostCSS，让我们开始：
- en: 'Let''s make a start on the changes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进行更改：
- en: We'll start by copying the `style.css` file from `Tutorial11` folder to the
    `src` folder in our project area.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将 `Tutorial11` 文件夹中的 `style.css` 文件复制到我们的项目区域的 `src` 文件夹中。
- en: 'We need to edit the file, to convert our media queries to use the PostCSS plugin—go
    ahead and add these two lines at lines 4 and 5:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编辑文件，以将我们的媒体查询转换为使用 PostCSS 插件——请在这些行的 4 和 5 行处添加以下两行：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Further down, replace lines 161 and 182 with this code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面，将第 161 行和第 182 行替换为以下代码：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On line 200, replace that line with this code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 200 行，将此行替换为以下代码：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the file—next, go ahead and replace the current `gulpfile.js` file with
    the version from the root of the `Tutorial12` folder. It has the same initial
    PostCSS task, but this has been renamed and extended with additional tasks that
    we've already used from earlier chapters.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件——接下来，请将当前的 `gulpfile.js` 文件替换为 `Tutorial12` 文件夹根目录中的版本。它具有相同的初始 PostCSS
    任务，但已被重命名并扩展了我们在前面的章节中已经使用过的附加任务。
- en: Next, go ahead and save a copy of the `package.json` file from the same location
    to the root of our project area—this contains updated links to the plugins used
    in this demo.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请将同一位置的 `package.json` 文件副本保存到我们的项目区域的根目录——它包含此演示中使用的插件的更新链接。
- en: Fire up a Node.js command prompt window, then change the working directory to
    our project area. At the prompt, enter `gulp` then press *Enter*.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动 Node.js 命令提示符窗口，然后更改工作目录到我们的项目区域。在提示符下，输入 `gulp` 然后按 *Enter*。
- en: If all is well, we should have a compiled CSS file appear in the `dest` folder—go
    ahead and copy this into the `css` folder of the `Tutorial12` folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在 `dest` 文件夹中看到一个编译后的 CSS 文件——请将其复制到 `Tutorial12` 文件夹的 `css` 文件夹中。
- en: Go ahead and run `index.html` in our project area, to preview the results—if
    all is well, we should not see anything different, but a quick check in the source
    code should show that we're using the minified version of our code:![Altering
    our demo to use PostCSS](img/BO5194_04_02.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目区域中运行 `index.html` 以预览结果——如果一切顺利，我们不应该看到任何不同，但在源代码中快速检查应该显示我们正在使用代码的压缩版本：![调整我们的演示以使用
    PostCSS](img/BO5194_04_02.jpg)
- en: 'It''s worth noting that in our demo, we used a typical format of media query:
    we could for example extend or alter our style sheet to work on handheld devices
    such as Galaxy tablets; the same principles apply, but clearly different width
    values will need to be used! For details on the values to use, take a look at
    [http://cssmediaqueries.com](http://cssmediaqueries.com), which has a useful list
    of queries to use for recent devices.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在我们的演示中，我们使用了媒体查询的典型格式：例如，我们可以扩展或修改样式表以在 Galaxy 平板等手持设备上工作；同样的原则适用，但显然需要使用不同的宽度值！有关使用值的详细信息，请查看[http://cssmediaqueries.com](http://cssmediaqueries.com)，它列出了用于最新设备的查询列表。
- en: 'If we want to push the boundaries of what is possible, there are a couple of
    options that we can consider:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要拓展可能的边界，我们可以考虑几个选项：
- en: '`postcss-media-variables`: This plugin (available at [https://github.com/WolfgangKluge/postcss-media-variables](https://github.com/WolfgangKluge/postcss-media-variables))
    works in the same way, but allows us to use variables in media queries. The benefit
    of using this plugin is that we can hive off width values into a central `:root`
    rule; we can potentially use one fixed value, but work out others based on this
    value:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-media-variables`：此插件（可在[https://github.com/WolfgangKluge/postcss-media-variables](https://github.com/WolfgangKluge/postcss-media-variables)找到）以相同的方式工作，但它允许我们在媒体查询中使用变量。使用此插件的好处是我们可以将宽度值分离到一个中央的`:root`规则中；我们可以使用一个固定的值，但基于此值计算出其他值：'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The downside is that it is considered as non-standard, the plugin must be called
    twice, and if other plugins are used, be called in a certain order—this means
    it might only suit a specific set of circumstances!
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缺点是，这被认为是非标准的，插件必须调用两次，并且如果使用其他插件，必须按照一定的顺序调用——这意味着它可能只适合特定的情况！
- en: '`postcss-quantity-queries`: This plugin (available at [https://github.com/pascalduez/postcss-quantity-queries](https://github.com/pascalduez/postcss-quantity-queries))
    is based on the SASS quantity queries mixins by Daniel Guillan. This allows us
    to use rules such as this:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-quantity-queries`：此插件（可在[https://github.com/pascalduez/postcss-quantity-queries](https://github.com/pascalduez/postcss-quantity-queries)找到）基于Daniel
    Guillan的SASS数量查询混入。这使我们能够使用如下规则：'
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Which will compile to this:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将编译成如下：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is one of four pseudo-selector extensions we can use with this plugin,
    it's a perfect way to style items such as navigation entries, or if we wanted
    a numbered list of items with different styles for even or odd numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以与该插件一起使用的四个伪选择器扩展之一，这是为导航条目等元素进行样式化的完美方式，或者如果我们想要一个带有不同样式的偶数和奇数项的编号列表。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a useful reference article on using quantity queries in CSS, head over to
    the post by Heydon Pickering at [http://alistapart.com/article/quantity-queries-for-css](http://alistapart.com/article/quantity-queries-for-css).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一篇关于在CSS中使用数量查询的有用参考文章，请访问Heydon Pickering在[http://alistapart.com/article/quantity-queries-for-css](http://alistapart.com/article/quantity-queries-for-css)上的帖子。
- en: Let's change tack now, and focus on our content. So far, we've concentrated
    on the page layout, but we can take it further by making images truly responsive;
    let's dive in and take a look.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改变方向，专注于我们的内容。到目前为止，我们一直专注于页面布局，但我们可以通过使图片真正响应式来更进一步；让我们深入探讨并看看。
- en: Making images responsive
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作响应式图片
- en: A key element of making any site responsive has of course to be images—after
    all, we can always construct a site without images, but how effective would it
    *really* be?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使任何网站响应式的一个关键要素当然是图片——毕竟，我们总是可以构建一个没有图片的网站，但这样真的有效吗？
- en: Sure, one can always use a data **Uniform Resource Identifier** (**URI**) to
    convert images to CSS equivalents, but this is at the risk of dramatically inflating
    our style sheet to the point of it becoming impossible to manage. The reality
    is that we have to have some form of images—if we are to make them behave, we
    clearly need to ensure that they expand or contract in size, according to available
    screen estate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，人们总是可以使用数据**统一资源标识符**（**URI**）将图片转换为CSS等效物，但这会使我们的样式表急剧膨胀，以至于变得难以管理。现实是，我们必须以某种形式拥有图片——如果我们想让它们表现良好，我们显然需要确保它们根据可用的屏幕空间扩展或收缩大小。
- en: 'The easiest way to adapt images for responsive layouts is to set a `max-width`
    value to `100%`, along with `height: auto` and `display: block`, and remove any
    attribute that defines either a fixed height or width for that image element.
    We can make the changes manually, but this is time-consuming; instead, let''s
    take a look at a PostCSS plugin that allows us to set these three values at compilation,
    by adding one single line of code to each image.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '适应响应式布局的最简单方法是为图片设置`max-width`值为`100%`，同时设置`height: auto`和`display: block`，并移除任何定义该图片元素固定高度或宽度的属性。我们可以手动进行更改，但这很耗时；相反，让我们看看一个PostCSS插件，它允许我们在编译时通过为每个图片添加一行代码来设置这三个值。'
- en: Making an image responsive with PostCSS
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PostCSS制作响应式图片
- en: Adding responsive capabilities to a site using PostCSS is simple; it will depend
    largely on your requirements as to how we make the images responsive, but the
    two key plugins to look out for are `postcss-responsive-images` (available at
    [https://github.com/azat-io/postcss-responsive-images](https://github.com/azat-io/postcss-responsive-images)),
    and `postcss-at2x` (available at [https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PostCSS 为网站添加响应式功能很简单；我们将主要根据您的需求来决定如何使图片响应式，但有两个关键插件需要关注：`postcss-responsive-images`（可在
    [https://github.com/azat-io/postcss-responsive-images](https://github.com/azat-io/postcss-responsive-images)
    获取），以及 `postcss-at2x`（可在 [https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x)
    获取)。
- en: We will cover the use of the `postcss-at2x` plugin in a moment, but for now,
    let's take a look at using the `postcss-re` `sponsive-images` plugin.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍 `postcss-at2x` 插件的使用，但现在，让我们看看如何使用 `postcss-re` `sponsive-images` 插件。
- en: Implementing responsive capabilities to images
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现图片的响应式功能
- en: 'Making our images responsive requires a single line of code to be added to
    any image-based rule; let''s dive in and add this capability to a copy of the
    `Tutorial13` folder from the code download that accompanies this book:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的图片响应式只需要在基于图片的规则中添加一行代码；让我们深入探讨，并将此功能添加到本书附带的代码下载中的 `Tutorial13` 文件夹的副本中：
- en: We'll start, as always, by installing the plugin—for this, fire up a Node.js
    command prompt, then run the commands as shown in this screenshot:![Implementing
    responsive capabilities to images](img/BO5194_04_03.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，首先安装插件——为此，打开 Node.js 命令提示符，然后运行此截图所示的命令：![为图片实现响应式功能](img/BO5194_04_03.jpg)
- en: We'll start by extracting a copy of the `Tutorial13` folder from the code download
    that accompanies this book, then saving it to our project area.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的代码下载中提取 `Tutorial13` 文件夹的副本，然后将其保存到我们的项目区域。
- en: 'Open up `style.css` from the `css` folder within the `Tutorial13` folder, then
    remove this rule:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Tutorial13` 文件夹中 `css` 文件夹内的 `style.css`，然后删除此规则：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In its place, add the following line:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其位置，添加以下行：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save the file, then copy it to the `src` folder underneath our project area
    (not within the `Tutorial` folder!).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后将其复制到项目区域下方的 `src` 文件夹中（不在 `Tutorial` 文件夹内！）。
- en: 'For this exercise, we''re going to replace the Gulp task file—go ahead and
    add this code to a new file, saving it as `gulpfile.js` at the root of our project
    area:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将替换 Gulp 任务文件——请将此代码添加到新文件中，并将其保存为 `gulpfile.js`，位于我们的项目区域根目录下：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we're concentrating on just making our image responsive with this
    `gulp` file, hence why it is a lot shorter than previous versions we have used
    to date.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在这个 `gulp` 文件中只专注于使我们的图片响应式，这就是为什么它比我们迄今为止使用的先前版本要短得多。
- en: Fire up a Node.js command prompt, then change the working directory to our project
    area—at the prompt, enter `gulp` then press *Enter*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Node.js 命令提示符，然后更改工作目录到我们的项目区域——在提示符中，输入 `gulp` 然后按 *Enter*。
- en: Node will go away and compile our code—if all is well, the compiled code for
    `#retina img` will look like this:![Implementing responsive capabilities to images](img/BO5194_04_04.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node 将编译我们的代码——如果一切顺利，`#retina img` 的编译代码将看起来像这样：![为图片实现响应式功能](img/BO5194_04_04.jpg)
- en: Copy the compiled CSS file from the `dest` folder into the `css` folder of the
    `Tutorial13` folder.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dest` 文件夹中的编译 CSS 文件复制到 `Tutorial13` 文件夹的 `css` 文件夹中。
- en: Go ahead and preview the results—try resizing the browser; if all is well, the
    image will automatically resize the image for us.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，预览一下结果——尝试调整浏览器大小；如果一切顺利，图片将自动为我们调整大小。
- en: 'Although it''s easy enough to install and use this plugin, it works best when
    referencing images directly in our HTML code, and not through the use of `background:`
    or `content: url(…)` attributes in our CSS.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然安装和使用此插件很容易，但它最好是在我们的 HTML 代码中直接引用图片，而不是通过在 CSS 中使用 `background:` 或 `content:
    url(…)` 属性。'
- en: What does this mean for us? It's a little limiting, as the purists amongst us
    may prefer to hive off asset attributes to CSS style sheets such is open source
    software, though this is one limitation that is bound to be fixed in the fullness
    of time!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们意味着什么？它有点限制性，因为在我们中间的纯粹主义者可能更喜欢将资产属性分离到 CSS 样式表中，就像开源软件那样，尽管这是一个注定会在未来得到解决的限制！
- en: 'The keen-eyed amongst you will spot that the image presentation clearly needs
    further work—for example, the paper clip isn''t repositioning when the window
    is resized, and we need to set a minimum width so that there is some white space
    around the image when we resize it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 留意观察的你们中的一些人会发现图像呈现显然需要进一步的工作——例如，当窗口大小调整时，回形针没有重新定位，我们需要设置一个最小宽度，以便在调整大小时图像周围有一些空白空间：
- en: '![Implementing responsive capabilities to images](img/BO5194_04_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![实现图像的响应式功能](img/BO5194_04_05.jpg)'
- en: The key principles remain the same though, irrespective of the presentation,
    removing the fixed image sizes and replacing with a `max-width` of `100%` is a
    good step to making an image responsive.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是哪种呈现方式，关键原则保持不变，移除固定图像大小，并用`max-width`为`100%`替换，是使图像响应式的好步骤。
- en: To get a true responsive image though, we ideally would use the new HTML5 `<picture>`
    tags—trouble is, PostCSS doesn't yet have a plugin to implement these tags!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要获得真正的响应式图像，我们理想情况下会使用新的HTML5 `<picture>` 标签——问题是，PostCSS还没有插件来实现这些标签！
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in some of the more general techniques of making images
    responsive (and outside of the world of PostCSS), then take a look at [https://jakearchibald.com/2015/anatomy-of-responsive-images/](https://jakearchibald.com/2015/anatomy-of-responsive-images/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于一些更通用的图像响应式制作技术（并且超出PostCSS的世界），那么请查看[https://jakearchibald.com/2015/anatomy-of-responsive-images/](https://jakearchibald.com/2015/anatomy-of-responsive-images/)。
- en: In the absence of any available capability to handle the use of `<picture>`
    tags within PostCSS, we can instead take a more traditional route and use media
    queries to help switch between different images, depending on the available screen
    estate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostCSS中处理`<picture>`标签的任何可用功能缺失的情况下，我们可以采取更传统的路线，并使用媒体查询来帮助在不同图像之间切换，这取决于可用的屏幕空间。
- en: We can go a step further, and even switch in images of better resolution if
    the device supports it—I'm thinking of course of Apple iPads or iPhones, which
    support retina images. We can easily use this format when working with PostCSS;
    for this, we need to make use of the `postcss-at2x` plugin by Simon Smith, available
    at [https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x).
    I feel a couple of demos coming on, so without further ado, let's go explore using
    this plugin.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，如果设备支持的话，甚至可以切换到更高分辨率的图像——我当然是在想苹果的iPad或iPhone，它们支持视网膜图像。我们可以轻松地在使用PostCSS时使用这种格式；为此，我们需要使用Simon
    Smith的`postcss-at2x`插件，该插件可在[https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x)找到。我感觉有几个演示即将到来，所以不再多言，让我们去探索使用这个插件吧。
- en: Adding support for retina images
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对视网膜图像的支持
- en: Retina images, a term coined by Apple's marketing team, contain up to twice
    as many pixels in the same space as standard images. This allow us to switch in
    images of higher quality (or resolution) automatically, provided we're using a
    device that supports their use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜图像，这个术语是由苹果市场营销团队提出的，它们在同一空间内包含的像素数量是标准图像的两倍。这使得我们能够自动切换到更高品质（或分辨率）的图像，前提是我们使用的设备支持它们的用途。
- en: This might be as simple as an iPhone, or something more substantial like an
    iPad—Apple's marketing clout means that they are probably two of the most popular
    portable devices that people own! But I digress…
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能只是一个iPhone，或者更实质性的iPad——苹果的市场影响力意味着它们可能是人们拥有的最受欢迎的便携式设备中的两个！但我在这里跑题了…
- en: 'At a technical level, we have two routes available for adding retina images,
    before we explore these in more detail, let''s just remind ourselves of the basics:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术层面上，我们有两条路线可以用来添加视网膜图像，在我们更详细地探讨这些之前，让我们先回顾一下基础知识：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is an extract from the CSS style sheet in the `Tutorial15` folder,
    which is available in the code download that accompanies this book; try previewing
    `index.html` in a browser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是从`Tutorial15`文件夹中的CSS样式表中提取的，该文件夹包含在这本书的代码下载中；尝试在浏览器中预览`index.html`。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For best results, it is strongly recommended that you use Google Chrome—it's
    a great browser for simulating the effects of switching between low and high resolution
    images.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，强烈建议您使用Google Chrome——这是一个模拟低分辨率和高分辨率图像切换效果的优秀浏览器。
- en: 'The image displayed displays the text *8-bit version*—to switch, try this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的图像显示的是文本*8位版本*——要切换，请尝试这样做：
- en: Press *Shift* + *Ctrl* + *I* to display the Developer toolbar.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Shift* + *Ctrl* + *I*显示开发者工具栏。
- en: Click on the mobile phone icon to enable Responsive Design mode![Adding support
    for retina images](img/BO5194_04_14.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击手机图标以启用响应式设计模式![添加对视网膜图像的支持](img/BO5194_04_14.jpg)
- en: We can then switch between different devices using the dropdown—try switching
    to **Apple iPad**; you may need to press *F5* to refresh the display. If all is
    well, it will switch between 8-bit and 24-bit versions of the orchid image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过下拉菜单在不同设备之间切换——尝试切换到**苹果iPad**；你可能需要按*F5*键刷新显示。如果一切顺利，它将在8位和24位版本的兰花图像之间切换。
- en: Taking the next steps
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行下一步
- en: 'This is all good, but we''re clearly not using PostCSS here—what are our options?
    Well, we have two that we can use: `customMedia()` or the `postcss-at2x` plugin.
    We''ve already covered the basics of using `customMedia` in the *Exploring custom
    media queries in PostCSS* section; for this, we would use a variable such as this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很正常，但我们显然没有在这里使用 PostCSS——我们的选项是什么？嗯，我们有两种可以使用：`customMedia()`或`postcss-at2x`插件。我们已经在*探索PostCSS中的自定义媒体查询*部分介绍了使用`customMedia`的基本知识；对于这个，我们会使用一个变量，例如这个：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would be coupled with a query such as this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与如下查询相结合：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When compiled, and run in Google Chrome (to take advantage of its responsive
    design tools), we can see the image switch from 8-bit:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译并在Google Chrome中运行（以利用其响应式设计工具）时，我们可以看到图像从8位：
- en: '![Taking the next steps](img/BO5194_04_15.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![进行下一步](img/BO5194_04_15.jpg)'
- en: '…to a 24-bit version of the image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: …到一个24位的图像版本：
- en: '![Taking the next steps](img/BO5194_04_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![进行下一步](img/BO5194_04_06.jpg)'
- en: 'A peek at the active style rules view shows the media query update automatically:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 查看活动样式规则视图，会自动显示媒体查询更新：
- en: '![Taking the next steps](img/BO5194_04_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![进行下一步](img/BO5194_04_07.jpg)'
- en: 'This is good, but still a manual approach that takes time—instead, we can use
    a quicker route to achieve similar results. The alternative route, using `postcss-at2x`,
    is a simpler option—instead of working out what resolution ratio to use, we simply
    add the term `at-2x` to our style rule:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但仍然是一种耗时的人工方法——相反，我们可以使用更快捷的途径来达到类似的效果。使用`postcss-at2x`的替代途径是一个更简单的选项——我们不需要确定使用什么分辨率比率，我们只需在我们的样式规则中添加`at-2x`这个术语：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This automatically compiles to produce the relative resolution statements for
    us in our style sheet. It's a useful trick to use when working with iPads and
    other devices that can support hi-res images.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动编译，为我们生成样式表中的相对分辨率语句。当与iPad和其他支持高分辨率图像的设备一起工作时，这是一个有用的技巧。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure the `src` and `dest` folders at the root of our project area are clear
    of files before starting this demo, otherwise you might find they have some undesired
    effects during compilation!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此演示之前，确保项目区域的根目录下的`src`和`dest`文件夹中没有文件，否则你可能会在编译过程中发现它们有一些不期望的效果！
- en: Let's dive in and take a look at this in more detail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨并更详细地查看这一点。
- en: We start, as usual by installing the plugin—fire up a Node.js command prompt,
    then change the working directory to our project area.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样开始安装插件——打开 Node.js 命令提示符，然后更改工作目录到我们的项目区域。
- en: At the prompt, enter the commands shown in this screenshot, pressing *Enter*
    after each:![Taking the next steps](img/BO5194_04_08.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，输入此截图所示的命令，在每个命令后按*Enter*键：![进行下一步](img/BO5194_04_08.jpg)
- en: Keep the window handy, we will need it in a few steps!
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持窗口在手边，我们将在接下来的几个步骤中需要它！
- en: Let's now set up our markup, extract a copy of the `Tutorial17` folder from
    the code download that accompanies this book, and save the folder to our project
    area.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的标记，从本书附带的代码下载中提取`Tutorial17`文件夹的副本，并将其保存到我们的项目区域。
- en: Extract a copy of the `gulp` file from this folder and use it to replace the
    existing one at the root of our project area.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个文件夹中提取`gulp`文件的副本，并使用它替换项目区域根目录下现有的文件。
- en: Extract a copy of `style – pre-compile.css` from the `Tutorial17` folder, then
    copy it to the `src` folder at the root of our project area. Rename it as `style.css`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Tutorial17`文件夹中提取`style – pre-compile.css`的副本，然后将其复制到项目区域的根目录下的`src`文件夹中。将其重命名为`style.css`。
- en: Switch back to the Node.js command prompt window we had up earlier—at the prompt,
    enter `gulp` then press *Enter*.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回我们之前打开的 Node.js 命令提示符窗口——在提示符中输入`gulp`然后按*Enter*键。
- en: 'PostCSS will go away and compile our code—if all is well, we should see something
    akin to this extract in the compiled file within the `dest` folder:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PostCSS将编译我们的代码——如果一切顺利，我们应该在`dest`文件夹内的编译文件中看到类似以下内容的提取：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go ahead and copy the contents of the `dest` folder to the `css` folder within
    the `Tutorial17` folder.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dest` 文件夹的内容复制到 `Tutorial17` 文件夹内的 `css` 文件夹中。
- en: Try previewing the demo—if all is well, we should see that orchid flower as
    before, and force Chrome to display the hi-res version as we did in our previous
    demo.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览演示——如果一切顺利，我们应该看到之前的花朵，并强制 Chrome 显示高分辨率版本，就像我们在之前的演示中所做的那样。
- en: The great thing about this plugin is that it deals with creating the media query
    for us; all we need to do is add the `at2x` tag to any image where we want to
    display hi-resolution versions in the browser. There is always a risk that we
    may end up producing queries that are not 100% optimized (for example, combining
    identical breakpoints into one block, and so on); we will explore a couple of
    options to help keep our queries working efficiently towards the end of this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件的好处是它为我们处理创建媒体查询；我们只需要将 `at2x` 标签添加到任何我们希望在浏览器中显示高分辨率版本的图像上。我们总是存在这样的风险，即我们可能会产生不是100%优化的查询（例如，将相同的断点组合到一个块中等等）；我们将在本章末尾探索一些选项，以帮助我们的查询高效地工作。
- en: As an aside, a more concise option for working with hi-res images which is frequently
    forgotten, is the use of `image-set()`; this performs in a similar fashion, by
    providing different versions for devices that support high-resolution images.
    PostCSS provides a fallback option in the form of `postcss-image-set` (available
    from [https://github.com/alex499/postcss-image-set](https://github.com/alex499/postcss-image-set)),
    which sets a basic image that will work in those browsers that don't support the
    use of `image-` `set()` within a style sheet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁白，一个经常被遗忘的、处理高分辨率图像的更简洁选项是使用 `image-set()`；它以类似的方式执行，为支持高分辨率图像的设备提供不同版本。PostCSS
    提供了一个回退选项，形式为 `postcss-image-set`（可在 [https://github.com/alex499/postcss-image-set](https://github.com/alex499/postcss-image-set)
    获取），它设置了一个基本图像，该图像将在不支持在样式表中使用 `image-` `set()` 的浏览器中工作。
- en: Exploring other media possibilities
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索其他媒体可能性
- en: 'So, we''ve covered a number of key topics around making content responsive,
    using media queries; what does this mean when using PostCSS? The simple answer
    is that it opens up a world of possibilities—if your site needs to use media queries,
    then it is very likely that we can use PostCSS to compile our queries into valid
    CSS rules. To pique your interest, here are a couple of options to consider:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经使用媒体查询覆盖了使内容响应式的一些关键主题；当使用 PostCSS 时这意味着什么？简单的答案是它打开了一个可能性的世界——如果你的网站需要使用媒体查询，那么我们很可能可以使用
    PostCSS 将我们的查询编译成有效的 CSS 规则。为了激发你的兴趣，这里有一些可以考虑的选项：
- en: Creating a responsive slider using the `bxSlider` plugin, available from [http://www.bxslider.com](http://www.bxslider.com).
    Granted, it uses jQuery to move between each slide, but who's to say you couldn't
    eventually convert this to an all-CSS option?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自 [http://www.bxslider.com](http://www.bxslider.com) 的 `bxSlider` 插件创建一个响应式滑块。诚然，它使用
    jQuery 在每个幻灯片之间移动，但谁能说最终不能将其转换为全 CSS 选项？
- en: How about using responsive image sprites? A classic use for this is credit card
    symbols on an e-commerce shopping cart, with a bit of care, we can even make the
    image adapt to display hi-res versions, if the device being used supports it.
    We'll cover more of this in [Chapter 5](ch05.html "Chapter 5. Managing Colors,
    Images, and Fonts"), *Managing Colors, Images and Fonts*, if you want to give
    this a try, take a look at the postcss-sprites plugin, available from [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式图像精灵怎么样？这个的经典用途是在电子商务购物车上的信用卡符号，如果我们稍加注意，甚至可以使图像适应显示高分辨率版本，如果使用的设备支持的话。如果你想尝试一下，可以查看来自
    [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites)
    的 postcss-sprites 插件。
- en: Okay, we've covered making images responsive using PostCSS, but what about text?
    Pages won't look good if text doesn't flow properly when content is resized. Thankfully
    we can apply similar principles to text, using the `postcss-responsive-type` plugin
    by Sean King—let's take a look at it in action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经介绍了使用 PostCSS 使图像响应式的方法，但关于文本呢？如果内容调整大小时文本不能正确流动，页面看起来就不会很好。幸运的是，我们可以使用
    Sean King 的 `postcss-responsive-type` 插件将类似的原则应用于文本，让我们看看它的实际应用。
- en: Adding responsive text support
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加响应式文本支持
- en: The process of making text responsive within PostCSS shares some similarities
    to the postcss-responsive-images plugin we've already used, in both cases, all
    we need to add is a simple attribute to make our content responsive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostCSS中使文本具有响应性的过程与我们已经使用的 `postcss-responsive-images` 插件有相似之处，在这两种情况下，我们只需要添加一个简单的属性来使我们的内容具有响应性。
- en: 'The plugin we need to use for text though is the `PostCSS-responsive-type`
    plugin by Sean King (available at [https://github.com/seaneking/postcss-responsive-type](https://github.com/seaneking/postcss-responsive-type));
    adding font-size, being responsive to a rule in our style sheet is enough to get
    us started. Of course, we almost certainly want to specify our own rules; for
    example, we can use something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本处理，我们需要使用的插件是Sean King开发的 `PostCSS-responsive-type` 插件（可在[https://github.com/seaneking/postcss-responsive-type](https://github.com/seaneking/postcss-responsive-type)找到）；添加字体大小，使样式表中的规则具有响应性，就足以开始使用了。当然，我们几乎肯定想要指定自己的规则；例如，我们可以使用如下代码：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This compiles into two media queries—one at `480px`, and the other at `1280px`;
    the former sets a text size of `12px`, with the latter setting `21px` as the font
    size. Without further ado, let''s get stuck in and start using this plugin in
    anger:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译成两个媒体查询——一个在 `480px`，另一个在 `1280px`；前者设置文本大小为 `12px`，后者设置字体大小为 `21px`。无需多言，让我们开始使用这个插件吧：
- en: Fire up a Node.js command and change the working directory to the project area.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Node.js命令行并更改工作目录到项目区域。
- en: Enter the command shown in this screenshot, then press *Enter*:![Adding responsive
    text support](img/BO5194_04_09.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入此截图所示的命令，然后按 *Enter*：![添加响应式文本支持](img/BO5194_04_09.jpg)
- en: 'At this point, the plugin is installed—we can start to use it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，插件已安装——我们可以开始使用它了：
- en: Start by extracting a copy of the `Tutorial18` folder from the code download
    that accompanies this book; save it to the root area of our project folder.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从本书附带的代码下载中提取 `Tutorial18` 文件夹的副本；将其保存到我们项目文件夹的根目录。
- en: 'In a new file, add the following code—this contains some simple font styling
    for our demo; save it as `style.css` in the `src` folder of our project area:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码——这包含了一些简单的字体样式用于我们的演示；将其保存为 `style.css` 并放置在我们项目区域的 `src` 文件夹中：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, open up a copy of the `gulpfile.js` file at the root of our project area.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开我们项目区域根目录下的 `gulpfile.js` 文件。
- en: 'Note how a reference to the `postcss-responsive-type` plugin has been added,
    as indicated:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意如何添加对 `postcss-responsive-type` 插件的引用，如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `autoprefixer` task has also been amended—it has a reference to the `postcss-responsive-type`
    plugin, using the variable that has been declared at the top of the file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`autoprefixer` 任务也已更新——它引用了 `postcss-responsive-type` 插件，使用文件顶部声明的变量：'
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now compile the code from a Node.js command prompt, change the working
    directory to the project area, and run this command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从Node.js命令提示符编译代码，更改工作目录到项目区域，并运行以下命令：
- en: '[PRE23]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once the code has compiled, copy the contents of the `dest` folder to the `css`
    folder of the `Tutorial18` folder; if all is well, we should see this when previewing
    the results in a browser:![Adding responsive text support](img/BO5194_04_10.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦代码编译完成，将 `dest` 文件夹的内容复制到 `Tutorial18` 文件夹的 `css` 文件夹中；如果一切顺利，我们在浏览器中预览结果时应看到如下内容：![添加响应式文本支持](img/BO5194_04_10.jpg)
- en: Try resizing the window to make it larger or smaller—you should notice that
    the text size increases or decreases in size, according to the size of the available
    screen estate. We can then use this as a basis for adding images; if we apply
    both `postcss-responsive-images` and `postcss-responsive-type` plugins, we can
    use this as a solid basis for adding responsive capabilities to our sites.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整窗口大小，使其变大或变小——你应该会注意到文本大小会根据可用屏幕空间的大小而增加或减少。然后我们可以以此为基础添加图片；如果我们应用了 `postcss-responsive-images`
    和 `postcss-responsive-type` 插件，我们可以将其作为为我们的网站添加响应式功能的基础。
- en: A small point to note though—we've used pixel values throughout our code. Historical
    convention recommended the use of `em` (or even better `rem`) values, as these
    scaled better than standard pixel values. However, some developers now argue that
    this convention is no longer valid; there are occasions when pixel `em` or `rem`
    values should be used. It's up to us to decide which unit of value to use, and
    when it should be used!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们一直在代码中使用像素值。历史惯例推荐使用`em`（或者更好的`rem`）值，因为这些值比标准像素值缩放得更好。然而，一些开发者现在认为这种惯例不再有效；在某些情况下，应该使用像素`em`或`rem`值。决定使用哪个单位值以及何时使用它取决于我们！
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a good discussion on the merits of using pixel versus rem values, take a
    look at this post by Gion Kunz, at [https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/](https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用像素值与rem值优点的良好讨论，请参阅Gion Kunz在[https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/](https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/)上的这篇文章。
- en: Leaving aside what is possible when working with media queries, there are a
    couple of key topics we should explore—optimizing media queries, and how we can
    retrofit some form of support for older browsers. We'll start with optimizing
    queries—PostCSS has a couple of useful plugins available to help with maintaining
    our code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论使用媒体查询时，我们可以忽略一些可能的情况，但有两个关键主题我们应该探讨——优化媒体查询以及我们如何为旧浏览器提供某种形式的支持。我们将从优化查询开始——PostCSS提供了一些有用的插件来帮助我们维护代码。
- en: Optimizing media queries
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化媒体查询
- en: Throughout this chapter, we've explored using PostCSS to compile our media queries;
    while there are plenty of options open to us in terms of what we create, we should
    be mindful of what we create, to ensure that we're not creating a monster that
    slows our site down!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用PostCSS来编译我们的媒体查询；虽然我们在创建内容方面有很多选择，但我们应该注意我们创建的内容，以确保我们不会创建一个减慢网站速度的怪物！
- en: 'PostCSS has a couple of plugins available to help us here. They are:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS提供了一些插件来帮助我们。它们是：
- en: '`postcss-mq-keyframes`: Available at [https://github.com/TCotton/postcss-mq-keyframes](https://github.com/TCotton/postcss-mq-keyframes)),
    this is a simple plugin that moves all keyframes out of existing queries, to the
    bottom of a style sheet. This allows us to rationalize our keyframe rules—in the
    event that we have multiple media queries, we can apply the same rule to each
    of these media queries.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-mq-keyframes`：可在[https://github.com/TCotton/postcss-mq-keyframes](https://github.com/TCotton/postcss-mq-keyframes)找到），这是一个简单的插件，它将所有关键帧从现有查询中移出，放到样式表的底部。这允许我们合理化关键帧规则——如果我们有多个媒体查询，我们可以将这些规则应用到每个媒体查询上。'
- en: 'For example, the highlighted code below would be moved out of the query, and
    become a rule in its own right:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，下面高亮的代码将会从查询中移出，成为一个独立的规则：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`css-mqpacker`: Available at [https://github.com/hail2u/node-css-mqpacker](https://github.com/hail2u/node-css-mqpacker)),
    this plugin parses our code and merges any identical rules into one media query
    rule. It is arguable how much benefit we are likely to get from this plugin; we
    will likely only see any significant benefit from using it on larger, more complex
    sites!'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css-mqpacker`：可在[https://github.com/hail2u/node-css-mqpacker](https://github.com/hail2u/node-css-mqpacker)找到），这个插件解析我们的代码并将任何相同的规则合并为一个媒体查询规则。我们可能从这个插件中获得多少好处是有争议的；我们可能只有在较大的、更复杂的网站上使用它时才会看到任何显著的益处！'
- en: Both plugins can be installed using the same process as all of the plugins we've
    used to date; it's worth noting that we should not overuse our queries. Instead
    of designing for specific platforms, try designing for instances where content
    clearly breaks and becomes unusable. The fewer queries we have, the easier it
    becomes to manage our code; simplicity is absolutely key to a successful site.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个插件都可以使用与我们迄今为止使用的所有插件相同的安装过程来安装；值得注意的是，我们不应该过度使用查询。而不是为特定的平台设计，尝试为内容明显断裂且无法使用的情况设计。查询越少，管理代码就越容易；简洁对于成功网站至关重要。
- en: Looking further afield, there is one area we should not forget when optimizing
    our code—what browsers should we support? I'm all for pushing the proverbial browser
    boat out and using modern browsers where possible. However, some of you may still
    have to support older browsers (and please don't tell me that includes IE6!).
    Let's explore an option available in PostCSS to help those of you still having
    to support applications that really should be put out to pasture, so to speak.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从更广泛的角度来看，在优化我们的代码时，有一个领域我们不应该忘记——我们应该支持哪些浏览器？我完全支持尽可能推动传统浏览器的发展，使用现代浏览器。然而，有些人可能仍然需要支持旧浏览器（请不要告诉我这包括IE6！）。让我们探索PostCSS中可用的一个选项，以帮助那些仍然需要支持那些实际上应该被淘汰的应用程序的用户。
- en: Retrofitting support for older browsers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持旧浏览器的更新
- en: 'For those of you who still have to support older browsers, such as IE6-8, then
    PostCSS can help—we can use the `postcss-mqwidth-to-class` plugin to generate
    hardcoded class rules, based on the media queries we specify, such as this example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些仍然需要支持旧浏览器，例如IE6-8的用户，PostCSS可以提供帮助——我们可以使用`postcss-mqwidth-to-class`插件来生成基于我们指定的媒体查询的硬编码类规则，例如这个例子：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we compile it using this plugin, it will produce this result:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个插件进行编译，它将产生这个结果：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Anyone spot the danger here? The code may be *technically* correct, but it
    suffers from some limitations which make it less attractive: a risk of high levels
    of CSS specificity, media types are ignored (such as screen or print); and JavaScript
    may be required if adding classes to the `<body>` or `<html>` tags.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人注意到这里的危险了吗？代码在技术上可能是正确的，但它存在一些局限性，使其不那么吸引人：CSS特定性级别高，忽略了媒体类型（如屏幕或打印）；如果向`<body>`或`<html>`标签添加类，可能需要JavaScript。
- en: Ultimately it is down to us to decide what we need to use, but we should always
    be mindful that our code doesn't introduce new issues if we have to support older
    browsers! In this instance, a better alternative to consider is the `postcss-unmq`
    plugin (the source is available at [https://github.com/jonathantneal/postcss-unmq](https://github.com/jonathantneal/postcss-unmq));
    this removes media queries in favor of allowing us to create rules that adhere
    to specific screen sizes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最终决定我们使用什么取决于我们自己，但我们应该始终注意，如果我们必须支持旧浏览器，我们的代码不会引入新的问题！在这个例子中，一个更好的选择是考虑使用`postcss-unmq`插件（源代码可在[https://github.com/jonathantneal/postcss-unmq](https://github.com/jonathantneal/postcss-unmq)找到）；这个插件通过允许我们创建遵循特定屏幕尺寸的规则来移除媒体查询。
- en: Now, whilst browsers such as IE8 should indeed be (forcibly) retired from active
    service, there is something to be said for considering if we can take it one step
    further, and start to move away from using responsive design techniques.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然像IE8这样的浏览器确实应该（强制性地）从活跃服务中退役，但考虑如果我们能更进一步，开始远离使用响应式设计技术，这也是有话可说的。
- en: For example, conventional wisdom suggests that using rem values were a better
    alternative than using pixels. There is now a recent shift that suggests a blanket
    use (as many developers may have done) of rem units is less preferable, and that
    we should perhaps consider a blend of different units, to ensure content is correctly
    resized and maintains sufficient clarity. This is an important concept to consider
    as part of our development work in PostCSS, so let's take a moment to consider
    what this might mean for us.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，传统智慧认为使用rem值比使用像素更好。现在有一种新的转变表明，广泛使用rem单位（许多开发者可能已经这样做）可能不是最佳选择，我们可能需要考虑不同单位的混合，以确保内容正确缩放并保持足够的清晰度。这是我们PostCSS开发工作中需要考虑的一个重要概念，所以让我们花点时间考虑这可能会对我们意味着什么。
- en: Moving away from responsive design
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向非响应式设计
- en: '*"Moving away from responsive* *design?? Have you really lost your marbles…??"*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*"远离响应式设计？？你真的失去理智了吗……？？"*'
- en: In answer to what many might consider a perfectly valid question, the answer
    is no—or as *Polonius* might have put it in *Hamlet*, "*Though there be madness,
    yet there is method in't*".
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人可能认为的一个完全合理的问题，答案是“不”——或者正如*波洛纽斯*在*哈姆雷特*中可能说的那样，“*尽管有疯狂，但其中也有方法*”。
- en: In short, there is a good reason for considering this topic, as creating breakpoints
    using PostCSS is a cinch, but working out what they should be is the key to the
    success of our code. Many developers have blogged online about different types
    of media queries to use—examples for tablets, desktops, and laptops are widely
    available, and are frequently updated or replaced, if hardware changes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，考虑这个话题有很好的理由，因为使用PostCSS创建断点非常容易，但确定它们应该是什么是代码成功的关键。许多开发者已经在网上博客中讨论了不同类型的媒体查询——例如平板电脑、桌面和笔记本电脑的示例广泛可用，并且经常更新或替换，如果硬件发生变化。
- en: Since Ethan Marcotte's popularization of the term "responsive web design" in
    2010, many have accepted responsive design as an accepted standard for creating
    content for multiple devices or platforms. As a concept though, it is starting
    to lose favor with developers; an inherent weakness is the need to download multiple
    assets, even though only select versions of those assets may be used (such as
    larger or smaller versions of images). This of course increases bandwidth usage,
    and ultimately makes a site slower to navigate.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Ethan Marcotte在2010年普及“响应式网页设计”这个术语以来，许多人已经接受响应式设计作为为多个设备或平台创建内容的公认标准。然而，作为一个概念，它开始失去开发者的青睐；一个固有的弱点是需要下载多个资产，即使只有选择性的版本可能被使用（例如图像的大或小版本）。这当然增加了带宽使用，并最终使网站导航速度变慢。
- en: So, should we not use responsive design at all? Well, not entirely, but it depends
    on your circumstances. Instead of blindly adding media queries that add a layer
    of complexity, take a moment to consider if you *really* need that media query.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是否应该完全不使用响应式设计呢？嗯，不完全是这样，这取决于你的情况。不要盲目地添加会增加复杂性的媒体查询，花点时间考虑你是否真的需要那个媒体查询。
- en: As an alternative, consider using content specific breakpoints, in place of
    media equivalents; instead of tying our design to specific devices, we can work
    out where content can no longer be consumed properly, and build our breakpoint
    on this, rather than a known device width, which is likely to be changed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，考虑使用内容特定的断点，而不是媒体等效断点；而不是将我们的设计绑定到特定设备上，我们可以找出内容无法正确消费的地方，并在此基础上构建我们的断点，而不是一个可能改变的已知设备宽度。
- en: Images, or specifically hi-resolution versions, are no longer an issue; in place
    of using a low and high res version of each, consider switching to SVG format.
    This scales beautifully (irrespective of device), and removes any issue with scalability
    on devices at a stroke. Granted, there are some known issues with support for
    IE, but most other browsers should be able to handle SVG without causing too many
    problems!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图片，或者更具体地说，高分辨率版本，已经不再是问题；在不再使用每个图片的低分辨率和高分辨率版本的情况下，考虑切换到SVG格式。这种格式可以很好地缩放（不受设备影响），并且一举解决了设备上可伸缩性的任何问题。当然，对于IE的兼容性存在一些已知问题，但大多数其他浏览器应该能够处理SVG而不会引起太多问题！
- en: Fonts are another area where we can begin to reduce our use of media queries—here,
    we would need to look at using `vw`, `vh`, `vmin,` or `vmax` units; text will
    automatically resize if the browser viewport is resized. Adapting our code will
    require some manual changes; we can use the `postcss-vmin` plugin to provide some
    fallback for older versions of Internet Explorer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 字体是另一个我们可以开始减少使用媒体查询的领域——在这里，我们需要考虑使用`vw`、`vh`、`vmin`或`vmax`单位；文本将在浏览器视口大小调整时自动缩放。适应我们的代码将需要一些手动更改；我们可以使用`postcss-vmin`插件为旧版本的Internet
    Explorer提供一些回退。
- en: Hopefully this has given you some food for thought—the key message here is that
    whilst the PostCSS plugin for media queries makes it really easy to implement,
    we should not blindly go ahead and implement lots of media queries, without considering
    if there are alternative means to achieve the same results.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能给你一些思考——这里的关键信息是，虽然媒体查询的PostCSS插件使得实现变得非常容易，但我们不应该盲目地实施大量的媒体查询，而不考虑是否有其他方法可以达到相同的结果。
- en: 'Okay, let''s move on: time to push the boat out a little; let''s take a look
    at how we can take things further with CSS4 (as it is popularly known). We''ll
    work on an example that allows us to simulate the new greater than or less than
    operators that can be used as part of CSS level 4 media queries.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续前进：现在是时候把事情做得更彻底一些；让我们看看如何进一步利用CSS4（正如其广为人知的那样）。我们将通过一个示例来模拟CSS第4级媒体查询中可以使用的新的大于或小于运算符。
- en: Taking things further with CSS4
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨CSS4
- en: 'One of those small pet hates when working with media queries is that the query
    itself isn''t really semantic; most queries will show something like `max-width:
    1024px`, when we really mean *…less than…* or *…greater than…*.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用媒体查询时，有一个小的不满是查询本身并不真正具有语义性；大多数查询将显示类似`max-width: 1024px`的内容，而我们的真正意图是*…小于…*或*…大于…*。'
- en: Thankfully, with the upcoming changes to CSS in what most people call CSS4,
    we will be able to use `>`, `<`, or `=` symbols to express what we really mean
    in our code. The beauty about PostCSS is that we can emulate that functionality
    now, with the `postcss-media-minmax` plugin (available at [https://github.com/postcss/postcss-media-minmax](https://github.com/postcss/postcss-media-minmax));
    the plugin will convert these to the more familiar min- or max- statements that
    we already know.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，随着CSS即将到来的变化，大多数人称之为CSS4，我们将能够使用`>`, `<`, 或`=`符号来表达我们代码中的真正意图。PostCSS的美丽之处在于，我们现在可以使用`postcss-media-minmax`插件（可在[https://github.com/postcss/postcss-media-minmax](https://github.com/postcss/postcss-media-minmax)找到）来模拟这种功能；该插件将这些转换为更熟悉的min-或max-语句，这是我们已知的。
- en: 'It''s a really easy plugin to use—we''re going to break with convention here
    though, and use CodePen to demonstrate the plugin in action. CodePen will support
    a limited number of plugins, of which this is one of them—it''s a perfect opportunity
    to see the effect of our query in action. For our demo, we''re going to use the
    Font Awesome library to create some social media icons—our demo is loosely based
    on a version by Amey Raut:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常容易使用的插件——我们在这里将打破常规，使用CodePen来演示插件的实际应用。CodePen将支持有限数量的插件，其中之一就是它——这是一个观察查询实际效果的完美机会。对于我们的演示，我们将使用Font
    Awesome库来创建一些社交媒体图标——我们的演示是基于Amey Raut的一个版本：
- en: '![Taking things further with CSS4](img/BO5194_04_11.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS4进一步扩展功能](img/BO5194_04_11.jpg)'
- en: 'You can see the demo at [http://codepen.io/alibby251/pen/wKNMGL](http://codepen.io/alibby251/pen/wKNMGL)—the
    code that is of interest to us is from lines 70 to 79—notice the use of `<=` and
    `>=` in line 71:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://codepen.io/alibby251/pen/wKNMGL](http://codepen.io/alibby251/pen/wKNMGL)查看演示——对我们有意义的代码是从第70行到第79行——注意第71行中`<=`和`>=`的使用：
- en: '![Taking things further with CSS4](img/BO5194_04_12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS4进一步扩展功能](img/BO5194_04_12.jpg)'
- en: 'When compiled, it shows this valid CSS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，它显示以下有效的CSS：
- en: '![Taking things further with CSS4](img/BO5194_04_13.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS4进一步扩展功能](img/BO5194_04_13.jpg)'
- en: The use of operators such as `<` or `>` in media queries is just a small part
    of what is coming in CSS4; for more details, take a look at the W3C editorial
    draft at [http://dev.w3.org/csswg/](http://dev.w3.org/csswg/)—note, it makes for
    dry reading!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在媒体查询中使用操作符如`<`或`>`只是CSS4中即将到来的一部分；更多详情，请查看W3C编辑草案[http://dev.w3.org/csswg/](http://dev.w3.org/csswg/)——注意，它可能是一段枯燥的阅读材料！
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For anyone creating responsive sites, media queries are a core part of this
    process—PostCSS can easily help with creating the appropriate media queries that
    are needed for our projects. We've covered a number of key topics over the last
    few pages, so let's take a moment to consider what we've covered in this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何创建响应式网站的人来说，媒体查询是这个过程中的核心部分——PostCSS可以轻松帮助我们创建项目所需的适当媒体查询。在过去的几页中，我们已经覆盖了许多关键主题，所以让我们花点时间考虑一下本章我们涵盖了哪些内容。
- en: For anyone creating responsive sites, media queries are a core part of this
    process—PostCSS can easily help with creating the appropriate media queries that
    are needed for our projects. We've covered a number of key topics over the last
    few pages, so let's take a moment to consider what we've covered in this chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何创建响应式网站的人来说，媒体查询是这个过程中的核心部分——PostCSS可以轻松帮助我们创建项目所需的适当媒体查询。在过去的几页中，我们已经覆盖了许多关键主题，所以让我们花点时间考虑一下本章我们涵盖了哪些内容。
- en: We kicked off with a quick review of standard media queries in CSS, before altering
    our code to use PostCSS as the basis for our queries. We then put this to good
    use in making images responsive, with a look first at the options available in
    PostCSS, before working through an example using PostCSS. We then switched to
    a common use of media queries for images, with a look at switching in a high resolution
    version for those devices that support their use.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先快速回顾了CSS中的标准媒体查询，然后修改了我们的代码，使用PostCSS作为查询的基础。然后我们将其用于使图像响应式，首先查看PostCSS中可用的选项，然后通过一个PostCSS的示例来操作。然后我们转向媒体查询在图像中的常见用途，查看为支持其使用的设备切换到高分辨率版本。
- en: We then switched to making text responsive, and discovered that it is a similar
    process that takes place, albeit using a different plugin. We then moved onto
    look at optimizing queries using PostCSS, before a quick review of some of the
    options available when retrofitting support for older browsers. We then rounded
    out the chapter to look at how we can use alternative techniques to make our sites
    responsive, without the need for media queries, before finishing with discovering
    a small part of what is available within CSS4, and how PostCSS can be used to
    make those techniques available today.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后转向制作响应式文本，并发现这是一个类似的过程，尽管使用了不同的插件。然后我们转向使用 PostCSS 优化查询，在快速回顾了为旧浏览器添加支持时可用的一些选项之后。接着，我们完成了这一章节，探讨了如何使用替代技术使我们的网站响应式，而无需使用媒体查询，最后以发现
    CSS4 中的一部分内容以及如何使用 PostCSS 使这些技术今天可用作为结束。
- en: 'Phew, we certainly covered a lot: it doesn''t stop there though! The next stop
    on our journey promises to be just as interesting; every website or online application
    will use different fonts, images, or colors in some form throughout the site.
    We''ll take a look at how we can use PostCSS to make our lives just that little
    bit easier….'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，我们确实覆盖了很多内容：但这还没有结束！我们旅程的下一站承诺将同样有趣；每个网站或在线应用都会以某种形式在整个网站上使用不同的字体、图像或颜色。我们将探讨如何使用
    PostCSS 使我们的生活变得稍微轻松一些……。
