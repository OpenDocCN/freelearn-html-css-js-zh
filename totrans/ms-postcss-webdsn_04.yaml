- en: Chapter 4. Building Media Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The days of simply using one device to browse an online site are long since
    gone: responsive sites will work on a range of devices, from smart phones through
    to digital TVs and laptops. A key element of making sites responsive is the use
    of media queries. In this chapter, we''ll explore how to create them using PostCSS,
    see how they compare to the likes of Less and SASS, and how the use of PostCSS
    makes for a more flexible approach in comparison to standard preprocessors. This
    chapter will cover the following technical topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working through the basics of media queries using PostCSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding responsive support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrofitting support for older browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking things further—exploring the hover feature in CSS4 media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start…!
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any time viewing sites on different devices, then it will hardly
    come as a surprise to see media queries in the style sheet—they form the basis
    for responsive design and declarations allow us to control what is displayed on
    screen, according to the available screen width.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principles behind media queries are simple. In a nutshell, we have to define
    the device or media, and the resolution (or width) at which point the rule (or
    breakpoint) either kicks in or stops being applied. Take this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Any styles within will be applied only when we're viewing on screen, and our
    available screen estate is `768px` or less. This is a simple example, they can
    be as simple or as complex as required; it's down to us as developers to work
    out exactly where our content breaks and to build a suitable breakpoint to manage
    the change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get a feel for some of the more recent media queries that are possible, take
    a look at this post by Chris Coyier, who has queries for laptops, PCs, and even
    wearable devices! The list is available at [https://css-tricks.com/snippets/css/media-queries-for-standard-devices/](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s make a start: PostCSS makes it easy to manage queries for both
    text and images; we''ll begin our journey with a look at handling images.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring custom media queries in PostCSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making the switch to using PostCSS is a cinch, we can use the `postcss-custom-media`
    plugin for this purpose, available at [https://github.com/postcss/postcss-custom-media](https://github.com/postcss/postcss-custom-media).
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin is easy to install, it follows the same principles as all of the
    other plugins we''ve covered, so without further ado, let''s get that out of the
    way now:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt, then navigate to the working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep the command prompt open for now, we will use it in the next few steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the plugin installed, we can now use it, before we get stuck into converting
    our previous demo, let''s work through a simple example, so you can see it in
    action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a new file, add the following code, saving it as `style.css` within the
    `src` folder at the root of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the existing `gulpfile.js` file from the root of the project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following code, this will form a new `gulpfile.js` file;
    save this to the root of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Revert back to the command prompt session we had open earlier, then enter `gulp`
    at the command prompt, and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is well, we should see this code if we open up the compiled `style.css`
    from within the `dest` folder of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Believe it or not, this is all that is required to use the plugin; let's take
    a moment to consider what we've covered through this demo.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, you might be forgiven for thinking that this plugin doesn't
    actually do anything to help us—it's a valid point, but there is one key benefit
    to using this plugin. We can separate out the media breakpoints into separate
    variable statements, and store these at the top of our style sheet. This means
    that if we should ever need to update a particular breakpoint, we only need to
    do it once. Our code is then updated automatically at the compilation stage.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's get stuck into a demo; we're going to work through
    the previous plain CSS version of our parallax scrolling example, and convert
    it to use PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with plain CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the next few pages, we''re going to use a relatively recent technique
    as the basis for our demo—parallax scrolling. Just in case you''ve been under
    a rock, parallax scrolling is a single page application, which allows us to scroll
    through content whilst showing a number of fixed images behind our content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Beginning with plain CSS](img/BO5194_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll be using a demo created by Nick Salloum, which is available at [http://callmenick.com/_development/simple-parallax-effect/](http://callmenick.com/_development/simple-parallax-effect/)
    (I've simplified some of the CSS styles used, removed vendor prefixes, and reduced
    the number of separate files called by the example). We'll start with a plain
    CSS version of our demo—go ahead and extract a copy of `Tutorial11` to our project
    area. Try running `index.html`; if all is well, we should see something akin to
    the screenshot at the head of this section.
  prefs: []
  type: TYPE_NORMAL
- en: It's a great effect when used well, our interest is in the last section of the
    CSS file, from around line 133; this section contains the media queries we will
    convert in our next demo.
  prefs: []
  type: TYPE_NORMAL
- en: Altering our demo to use PostCSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If media queries are used correctly, this can open up a world of possibilities;
    we can tweak our style sheet for anything from an iPhone through to a printer.
    In our demo, we've used a couple to adjust how content is displayed on sites where
    displays are larger than `600px` or `960px` width; altering these to work in PostCSS
    is a cinch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSS3 Media Queries site has a large list of different types of queries that
    are available; if you check out the site on a target PC or device, it will show
    you if that query is supported on that device. The full list is available at [http://www.cssmediaqueries.com](http://www.cssmediaqueries.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need to make a couple of changes in the style sheet to switch to using
    PostCSS, so let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start on the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by copying the `style.css` file from `Tutorial11` folder to the
    `src` folder in our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to edit the file, to convert our media queries to use the PostCSS plugin—go
    ahead and add these two lines at lines 4 and 5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further down, replace lines 161 and 182 with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 200, replace that line with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file—next, go ahead and replace the current `gulpfile.js` file with
    the version from the root of the `Tutorial12` folder. It has the same initial
    PostCSS task, but this has been renamed and extended with additional tasks that
    we've already used from earlier chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go ahead and save a copy of the `package.json` file from the same location
    to the root of our project area—this contains updated links to the plugins used
    in this demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt window, then change the working directory to
    our project area. At the prompt, enter `gulp` then press *Enter*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If all is well, we should have a compiled CSS file appear in the `dest` folder—go
    ahead and copy this into the `css` folder of the `Tutorial12` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and run `index.html` in our project area, to preview the results—if
    all is well, we should not see anything different, but a quick check in the source
    code should show that we're using the minified version of our code:![Altering
    our demo to use PostCSS](img/BO5194_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s worth noting that in our demo, we used a typical format of media query:
    we could for example extend or alter our style sheet to work on handheld devices
    such as Galaxy tablets; the same principles apply, but clearly different width
    values will need to be used! For details on the values to use, take a look at
    [http://cssmediaqueries.com](http://cssmediaqueries.com), which has a useful list
    of queries to use for recent devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to push the boundaries of what is possible, there are a couple of
    options that we can consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postcss-media-variables`: This plugin (available at [https://github.com/WolfgangKluge/postcss-media-variables](https://github.com/WolfgangKluge/postcss-media-variables))
    works in the same way, but allows us to use variables in media queries. The benefit
    of using this plugin is that we can hive off width values into a central `:root`
    rule; we can potentially use one fixed value, but work out others based on this
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The downside is that it is considered as non-standard, the plugin must be called
    twice, and if other plugins are used, be called in a certain order—this means
    it might only suit a specific set of circumstances!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`postcss-quantity-queries`: This plugin (available at [https://github.com/pascalduez/postcss-quantity-queries](https://github.com/pascalduez/postcss-quantity-queries))
    is based on the SASS quantity queries mixins by Daniel Guillan. This allows us
    to use rules such as this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Which will compile to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is one of four pseudo-selector extensions we can use with this plugin,
    it's a perfect way to style items such as navigation entries, or if we wanted
    a numbered list of items with different styles for even or odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a useful reference article on using quantity queries in CSS, head over to
    the post by Heydon Pickering at [http://alistapart.com/article/quantity-queries-for-css](http://alistapart.com/article/quantity-queries-for-css).
  prefs: []
  type: TYPE_NORMAL
- en: Let's change tack now, and focus on our content. So far, we've concentrated
    on the page layout, but we can take it further by making images truly responsive;
    let's dive in and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Making images responsive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key element of making any site responsive has of course to be images—after
    all, we can always construct a site without images, but how effective would it
    *really* be?
  prefs: []
  type: TYPE_NORMAL
- en: Sure, one can always use a data **Uniform Resource Identifier** (**URI**) to
    convert images to CSS equivalents, but this is at the risk of dramatically inflating
    our style sheet to the point of it becoming impossible to manage. The reality
    is that we have to have some form of images—if we are to make them behave, we
    clearly need to ensure that they expand or contract in size, according to available
    screen estate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to adapt images for responsive layouts is to set a `max-width`
    value to `100%`, along with `height: auto` and `display: block`, and remove any
    attribute that defines either a fixed height or width for that image element.
    We can make the changes manually, but this is time-consuming; instead, let''s
    take a look at a PostCSS plugin that allows us to set these three values at compilation,
    by adding one single line of code to each image.'
  prefs: []
  type: TYPE_NORMAL
- en: Making an image responsive with PostCSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding responsive capabilities to a site using PostCSS is simple; it will depend
    largely on your requirements as to how we make the images responsive, but the
    two key plugins to look out for are `postcss-responsive-images` (available at
    [https://github.com/azat-io/postcss-responsive-images](https://github.com/azat-io/postcss-responsive-images)),
    and `postcss-at2x` (available at [https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x)).
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the use of the `postcss-at2x` plugin in a moment, but for now,
    let's take a look at using the `postcss-re` `sponsive-images` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing responsive capabilities to images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making our images responsive requires a single line of code to be added to
    any image-based rule; let''s dive in and add this capability to a copy of the
    `Tutorial13` folder from the code download that accompanies this book:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start, as always, by installing the plugin—for this, fire up a Node.js
    command prompt, then run the commands as shown in this screenshot:![Implementing
    responsive capabilities to images](img/BO5194_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll start by extracting a copy of the `Tutorial13` folder from the code download
    that accompanies this book, then saving it to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `style.css` from the `css` folder within the `Tutorial13` folder, then
    remove this rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In its place, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file, then copy it to the `src` folder underneath our project area
    (not within the `Tutorial` folder!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this exercise, we''re going to replace the Gulp task file—go ahead and
    add this code to a new file, saving it as `gulpfile.js` at the root of our project
    area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we're concentrating on just making our image responsive with this
    `gulp` file, hence why it is a lot shorter than previous versions we have used
    to date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt, then change the working directory to our project
    area—at the prompt, enter `gulp` then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node will go away and compile our code—if all is well, the compiled code for
    `#retina img` will look like this:![Implementing responsive capabilities to images](img/BO5194_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the compiled CSS file from the `dest` folder into the `css` folder of the
    `Tutorial13` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and preview the results—try resizing the browser; if all is well, the
    image will automatically resize the image for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Although it''s easy enough to install and use this plugin, it works best when
    referencing images directly in our HTML code, and not through the use of `background:`
    or `content: url(…)` attributes in our CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for us? It's a little limiting, as the purists amongst us
    may prefer to hive off asset attributes to CSS style sheets such is open source
    software, though this is one limitation that is bound to be fixed in the fullness
    of time!
  prefs: []
  type: TYPE_NORMAL
- en: 'The keen-eyed amongst you will spot that the image presentation clearly needs
    further work—for example, the paper clip isn''t repositioning when the window
    is resized, and we need to set a minimum width so that there is some white space
    around the image when we resize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing responsive capabilities to images](img/BO5194_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key principles remain the same though, irrespective of the presentation,
    removing the fixed image sizes and replacing with a `max-width` of `100%` is a
    good step to making an image responsive.
  prefs: []
  type: TYPE_NORMAL
- en: To get a true responsive image though, we ideally would use the new HTML5 `<picture>`
    tags—trouble is, PostCSS doesn't yet have a plugin to implement these tags!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in some of the more general techniques of making images
    responsive (and outside of the world of PostCSS), then take a look at [https://jakearchibald.com/2015/anatomy-of-responsive-images/](https://jakearchibald.com/2015/anatomy-of-responsive-images/).
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of any available capability to handle the use of `<picture>`
    tags within PostCSS, we can instead take a more traditional route and use media
    queries to help switch between different images, depending on the available screen
    estate.
  prefs: []
  type: TYPE_NORMAL
- en: We can go a step further, and even switch in images of better resolution if
    the device supports it—I'm thinking of course of Apple iPads or iPhones, which
    support retina images. We can easily use this format when working with PostCSS;
    for this, we need to make use of the `postcss-at2x` plugin by Simon Smith, available
    at [https://github.com/simonsmith/postcss-at2x](https://github.com/simonsmith/postcss-at2x).
    I feel a couple of demos coming on, so without further ado, let's go explore using
    this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for retina images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retina images, a term coined by Apple's marketing team, contain up to twice
    as many pixels in the same space as standard images. This allow us to switch in
    images of higher quality (or resolution) automatically, provided we're using a
    device that supports their use.
  prefs: []
  type: TYPE_NORMAL
- en: This might be as simple as an iPhone, or something more substantial like an
    iPad—Apple's marketing clout means that they are probably two of the most popular
    portable devices that people own! But I digress…
  prefs: []
  type: TYPE_NORMAL
- en: 'At a technical level, we have two routes available for adding retina images,
    before we explore these in more detail, let''s just remind ourselves of the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code is an extract from the CSS style sheet in the `Tutorial15` folder,
    which is available in the code download that accompanies this book; try previewing
    `index.html` in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For best results, it is strongly recommended that you use Google Chrome—it's
    a great browser for simulating the effects of switching between low and high resolution
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image displayed displays the text *8-bit version*—to switch, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Shift* + *Ctrl* + *I* to display the Developer toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the mobile phone icon to enable Responsive Design mode![Adding support
    for retina images](img/BO5194_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then switch between different devices using the dropdown—try switching
    to **Apple iPad**; you may need to press *F5* to refresh the display. If all is
    well, it will switch between 8-bit and 24-bit versions of the orchid image.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the next steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is all good, but we''re clearly not using PostCSS here—what are our options?
    Well, we have two that we can use: `customMedia()` or the `postcss-at2x` plugin.
    We''ve already covered the basics of using `customMedia` in the *Exploring custom
    media queries in PostCSS* section; for this, we would use a variable such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be coupled with a query such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, and run in Google Chrome (to take advantage of its responsive
    design tools), we can see the image switch from 8-bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking the next steps](img/BO5194_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '…to a 24-bit version of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking the next steps](img/BO5194_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A peek at the active style rules view shows the media query update automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking the next steps](img/BO5194_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is good, but still a manual approach that takes time—instead, we can use
    a quicker route to achieve similar results. The alternative route, using `postcss-at2x`,
    is a simpler option—instead of working out what resolution ratio to use, we simply
    add the term `at-2x` to our style rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This automatically compiles to produce the relative resolution statements for
    us in our style sheet. It's a useful trick to use when working with iPads and
    other devices that can support hi-res images.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the `src` and `dest` folders at the root of our project area are clear
    of files before starting this demo, otherwise you might find they have some undesired
    effects during compilation!
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive in and take a look at this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: We start, as usual by installing the plugin—fire up a Node.js command prompt,
    then change the working directory to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter the commands shown in this screenshot, pressing *Enter*
    after each:![Taking the next steps](img/BO5194_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the window handy, we will need it in a few steps!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's now set up our markup, extract a copy of the `Tutorial17` folder from
    the code download that accompanies this book, and save the folder to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract a copy of the `gulp` file from this folder and use it to replace the
    existing one at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract a copy of `style – pre-compile.css` from the `Tutorial17` folder, then
    copy it to the `src` folder at the root of our project area. Rename it as `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the Node.js command prompt window we had up earlier—at the prompt,
    enter `gulp` then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PostCSS will go away and compile our code—if all is well, we should see something
    akin to this extract in the compiled file within the `dest` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and copy the contents of the `dest` folder to the `css` folder within
    the `Tutorial17` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try previewing the demo—if all is well, we should see that orchid flower as
    before, and force Chrome to display the hi-res version as we did in our previous
    demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The great thing about this plugin is that it deals with creating the media query
    for us; all we need to do is add the `at2x` tag to any image where we want to
    display hi-resolution versions in the browser. There is always a risk that we
    may end up producing queries that are not 100% optimized (for example, combining
    identical breakpoints into one block, and so on); we will explore a couple of
    options to help keep our queries working efficiently towards the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, a more concise option for working with hi-res images which is frequently
    forgotten, is the use of `image-set()`; this performs in a similar fashion, by
    providing different versions for devices that support high-resolution images.
    PostCSS provides a fallback option in the form of `postcss-image-set` (available
    from [https://github.com/alex499/postcss-image-set](https://github.com/alex499/postcss-image-set)),
    which sets a basic image that will work in those browsers that don't support the
    use of `image-` `set()` within a style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other media possibilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we''ve covered a number of key topics around making content responsive,
    using media queries; what does this mean when using PostCSS? The simple answer
    is that it opens up a world of possibilities—if your site needs to use media queries,
    then it is very likely that we can use PostCSS to compile our queries into valid
    CSS rules. To pique your interest, here are a couple of options to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive slider using the `bxSlider` plugin, available from [http://www.bxslider.com](http://www.bxslider.com).
    Granted, it uses jQuery to move between each slide, but who's to say you couldn't
    eventually convert this to an all-CSS option?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about using responsive image sprites? A classic use for this is credit card
    symbols on an e-commerce shopping cart, with a bit of care, we can even make the
    image adapt to display hi-res versions, if the device being used supports it.
    We'll cover more of this in [Chapter 5](ch05.html "Chapter 5. Managing Colors,
    Images, and Fonts"), *Managing Colors, Images and Fonts*, if you want to give
    this a try, take a look at the postcss-sprites plugin, available from [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, we've covered making images responsive using PostCSS, but what about text?
    Pages won't look good if text doesn't flow properly when content is resized. Thankfully
    we can apply similar principles to text, using the `postcss-responsive-type` plugin
    by Sean King—let's take a look at it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Adding responsive text support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of making text responsive within PostCSS shares some similarities
    to the postcss-responsive-images plugin we've already used, in both cases, all
    we need to add is a simple attribute to make our content responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin we need to use for text though is the `PostCSS-responsive-type`
    plugin by Sean King (available at [https://github.com/seaneking/postcss-responsive-type](https://github.com/seaneking/postcss-responsive-type));
    adding font-size, being responsive to a rule in our style sheet is enough to get
    us started. Of course, we almost certainly want to specify our own rules; for
    example, we can use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles into two media queries—one at `480px`, and the other at `1280px`;
    the former sets a text size of `12px`, with the latter setting `21px` as the font
    size. Without further ado, let''s get stuck in and start using this plugin in
    anger:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command and change the working directory to the project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the command shown in this screenshot, then press *Enter*:![Adding responsive
    text support](img/BO5194_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, the plugin is installed—we can start to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by extracting a copy of the `Tutorial18` folder from the code download
    that accompanies this book; save it to the root area of our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following code—this contains some simple font styling
    for our demo; save it as `style.css` in the `src` folder of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open up a copy of the `gulpfile.js` file at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note how a reference to the `postcss-responsive-type` plugin has been added,
    as indicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `autoprefixer` task has also been amended—it has a reference to the `postcss-responsive-type`
    plugin, using the variable that has been declared at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now compile the code from a Node.js command prompt, change the working
    directory to the project area, and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the code has compiled, copy the contents of the `dest` folder to the `css`
    folder of the `Tutorial18` folder; if all is well, we should see this when previewing
    the results in a browser:![Adding responsive text support](img/BO5194_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try resizing the window to make it larger or smaller—you should notice that
    the text size increases or decreases in size, according to the size of the available
    screen estate. We can then use this as a basis for adding images; if we apply
    both `postcss-responsive-images` and `postcss-responsive-type` plugins, we can
    use this as a solid basis for adding responsive capabilities to our sites.
  prefs: []
  type: TYPE_NORMAL
- en: A small point to note though—we've used pixel values throughout our code. Historical
    convention recommended the use of `em` (or even better `rem`) values, as these
    scaled better than standard pixel values. However, some developers now argue that
    this convention is no longer valid; there are occasions when pixel `em` or `rem`
    values should be used. It's up to us to decide which unit of value to use, and
    when it should be used!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a good discussion on the merits of using pixel versus rem values, take a
    look at this post by Gion Kunz, at [https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/](https://mindtheshift.wordpress.com/2015/04/02/r-i-p-rem-viva-css-reference-pixel/).
  prefs: []
  type: TYPE_NORMAL
- en: Leaving aside what is possible when working with media queries, there are a
    couple of key topics we should explore—optimizing media queries, and how we can
    retrofit some form of support for older browsers. We'll start with optimizing
    queries—PostCSS has a couple of useful plugins available to help with maintaining
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've explored using PostCSS to compile our media queries;
    while there are plenty of options open to us in terms of what we create, we should
    be mindful of what we create, to ensure that we're not creating a monster that
    slows our site down!
  prefs: []
  type: TYPE_NORMAL
- en: 'PostCSS has a couple of plugins available to help us here. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postcss-mq-keyframes`: Available at [https://github.com/TCotton/postcss-mq-keyframes](https://github.com/TCotton/postcss-mq-keyframes)),
    this is a simple plugin that moves all keyframes out of existing queries, to the
    bottom of a style sheet. This allows us to rationalize our keyframe rules—in the
    event that we have multiple media queries, we can apply the same rule to each
    of these media queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the highlighted code below would be moved out of the query, and
    become a rule in its own right:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`css-mqpacker`: Available at [https://github.com/hail2u/node-css-mqpacker](https://github.com/hail2u/node-css-mqpacker)),
    this plugin parses our code and merges any identical rules into one media query
    rule. It is arguable how much benefit we are likely to get from this plugin; we
    will likely only see any significant benefit from using it on larger, more complex
    sites!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both plugins can be installed using the same process as all of the plugins we've
    used to date; it's worth noting that we should not overuse our queries. Instead
    of designing for specific platforms, try designing for instances where content
    clearly breaks and becomes unusable. The fewer queries we have, the easier it
    becomes to manage our code; simplicity is absolutely key to a successful site.
  prefs: []
  type: TYPE_NORMAL
- en: Looking further afield, there is one area we should not forget when optimizing
    our code—what browsers should we support? I'm all for pushing the proverbial browser
    boat out and using modern browsers where possible. However, some of you may still
    have to support older browsers (and please don't tell me that includes IE6!).
    Let's explore an option available in PostCSS to help those of you still having
    to support applications that really should be put out to pasture, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: Retrofitting support for older browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those of you who still have to support older browsers, such as IE6-8, then
    PostCSS can help—we can use the `postcss-mqwidth-to-class` plugin to generate
    hardcoded class rules, based on the media queries we specify, such as this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile it using this plugin, it will produce this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyone spot the danger here? The code may be *technically* correct, but it
    suffers from some limitations which make it less attractive: a risk of high levels
    of CSS specificity, media types are ignored (such as screen or print); and JavaScript
    may be required if adding classes to the `<body>` or `<html>` tags.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately it is down to us to decide what we need to use, but we should always
    be mindful that our code doesn't introduce new issues if we have to support older
    browsers! In this instance, a better alternative to consider is the `postcss-unmq`
    plugin (the source is available at [https://github.com/jonathantneal/postcss-unmq](https://github.com/jonathantneal/postcss-unmq));
    this removes media queries in favor of allowing us to create rules that adhere
    to specific screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whilst browsers such as IE8 should indeed be (forcibly) retired from active
    service, there is something to be said for considering if we can take it one step
    further, and start to move away from using responsive design techniques.
  prefs: []
  type: TYPE_NORMAL
- en: For example, conventional wisdom suggests that using rem values were a better
    alternative than using pixels. There is now a recent shift that suggests a blanket
    use (as many developers may have done) of rem units is less preferable, and that
    we should perhaps consider a blend of different units, to ensure content is correctly
    resized and maintains sufficient clarity. This is an important concept to consider
    as part of our development work in PostCSS, so let's take a moment to consider
    what this might mean for us.
  prefs: []
  type: TYPE_NORMAL
- en: Moving away from responsive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Moving away from responsive* *design?? Have you really lost your marbles…??"*'
  prefs: []
  type: TYPE_NORMAL
- en: In answer to what many might consider a perfectly valid question, the answer
    is no—or as *Polonius* might have put it in *Hamlet*, "*Though there be madness,
    yet there is method in't*".
  prefs: []
  type: TYPE_NORMAL
- en: In short, there is a good reason for considering this topic, as creating breakpoints
    using PostCSS is a cinch, but working out what they should be is the key to the
    success of our code. Many developers have blogged online about different types
    of media queries to use—examples for tablets, desktops, and laptops are widely
    available, and are frequently updated or replaced, if hardware changes.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ethan Marcotte's popularization of the term "responsive web design" in
    2010, many have accepted responsive design as an accepted standard for creating
    content for multiple devices or platforms. As a concept though, it is starting
    to lose favor with developers; an inherent weakness is the need to download multiple
    assets, even though only select versions of those assets may be used (such as
    larger or smaller versions of images). This of course increases bandwidth usage,
    and ultimately makes a site slower to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: So, should we not use responsive design at all? Well, not entirely, but it depends
    on your circumstances. Instead of blindly adding media queries that add a layer
    of complexity, take a moment to consider if you *really* need that media query.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, consider using content specific breakpoints, in place of
    media equivalents; instead of tying our design to specific devices, we can work
    out where content can no longer be consumed properly, and build our breakpoint
    on this, rather than a known device width, which is likely to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Images, or specifically hi-resolution versions, are no longer an issue; in place
    of using a low and high res version of each, consider switching to SVG format.
    This scales beautifully (irrespective of device), and removes any issue with scalability
    on devices at a stroke. Granted, there are some known issues with support for
    IE, but most other browsers should be able to handle SVG without causing too many
    problems!
  prefs: []
  type: TYPE_NORMAL
- en: Fonts are another area where we can begin to reduce our use of media queries—here,
    we would need to look at using `vw`, `vh`, `vmin,` or `vmax` units; text will
    automatically resize if the browser viewport is resized. Adapting our code will
    require some manual changes; we can use the `postcss-vmin` plugin to provide some
    fallback for older versions of Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully this has given you some food for thought—the key message here is that
    whilst the PostCSS plugin for media queries makes it really easy to implement,
    we should not blindly go ahead and implement lots of media queries, without considering
    if there are alternative means to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s move on: time to push the boat out a little; let''s take a look
    at how we can take things further with CSS4 (as it is popularly known). We''ll
    work on an example that allows us to simulate the new greater than or less than
    operators that can be used as part of CSS level 4 media queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking things further with CSS4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of those small pet hates when working with media queries is that the query
    itself isn''t really semantic; most queries will show something like `max-width:
    1024px`, when we really mean *…less than…* or *…greater than…*.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, with the upcoming changes to CSS in what most people call CSS4,
    we will be able to use `>`, `<`, or `=` symbols to express what we really mean
    in our code. The beauty about PostCSS is that we can emulate that functionality
    now, with the `postcss-media-minmax` plugin (available at [https://github.com/postcss/postcss-media-minmax](https://github.com/postcss/postcss-media-minmax));
    the plugin will convert these to the more familiar min- or max- statements that
    we already know.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a really easy plugin to use—we''re going to break with convention here
    though, and use CodePen to demonstrate the plugin in action. CodePen will support
    a limited number of plugins, of which this is one of them—it''s a perfect opportunity
    to see the effect of our query in action. For our demo, we''re going to use the
    Font Awesome library to create some social media icons—our demo is loosely based
    on a version by Amey Raut:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking things further with CSS4](img/BO5194_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the demo at [http://codepen.io/alibby251/pen/wKNMGL](http://codepen.io/alibby251/pen/wKNMGL)—the
    code that is of interest to us is from lines 70 to 79—notice the use of `<=` and
    `>=` in line 71:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking things further with CSS4](img/BO5194_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When compiled, it shows this valid CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking things further with CSS4](img/BO5194_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The use of operators such as `<` or `>` in media queries is just a small part
    of what is coming in CSS4; for more details, take a look at the W3C editorial
    draft at [http://dev.w3.org/csswg/](http://dev.w3.org/csswg/)—note, it makes for
    dry reading!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For anyone creating responsive sites, media queries are a core part of this
    process—PostCSS can easily help with creating the appropriate media queries that
    are needed for our projects. We've covered a number of key topics over the last
    few pages, so let's take a moment to consider what we've covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For anyone creating responsive sites, media queries are a core part of this
    process—PostCSS can easily help with creating the appropriate media queries that
    are needed for our projects. We've covered a number of key topics over the last
    few pages, so let's take a moment to consider what we've covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with a quick review of standard media queries in CSS, before altering
    our code to use PostCSS as the basis for our queries. We then put this to good
    use in making images responsive, with a look first at the options available in
    PostCSS, before working through an example using PostCSS. We then switched to
    a common use of media queries for images, with a look at switching in a high resolution
    version for those devices that support their use.
  prefs: []
  type: TYPE_NORMAL
- en: We then switched to making text responsive, and discovered that it is a similar
    process that takes place, albeit using a different plugin. We then moved onto
    look at optimizing queries using PostCSS, before a quick review of some of the
    options available when retrofitting support for older browsers. We then rounded
    out the chapter to look at how we can use alternative techniques to make our sites
    responsive, without the need for media queries, before finishing with discovering
    a small part of what is available within CSS4, and how PostCSS can be used to
    make those techniques available today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phew, we certainly covered a lot: it doesn''t stop there though! The next stop
    on our journey promises to be just as interesting; every website or online application
    will use different fonts, images, or colors in some form throughout the site.
    We''ll take a look at how we can use PostCSS to make our lives just that little
    bit easier….'
  prefs: []
  type: TYPE_NORMAL
