- en: Managing States with Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that, previously, we said that it is not good to have application states
    in multiple places, because it makes debugging much harder. Therefore, we moved
    states from the input components to the form components. But now that we have
    two forms, we once again have states in two places. Therefore, we need to move
    the states up again. The most ideal case is where our application has only one
    state store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: However, if we keep moving states up, and passing the relevant state properties
    down as props, it can be quite un-performant. Let's say a component is nested
    20 layers deep; for it to consume the state it needs, the state needs to have
    passed through 19 components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, let's say the same heavily nested component needs to change the
    state; it will have to call its `onChange` prop, prompting its parent to call
    its `onChange` prop, and so on, and so on. Having to call 20 `onChange` functions
    for every state change is ineffective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, people have faced the same issues before and have come up with **state
    management** libraries that address them. In this chapter, we will use the most
    popular state management library, **Redux**, to organize our state in a centralized
    manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Different concepts in Redux, such as state **store**, **reducers**, **actions**
    and **dispatchers**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to lift state up
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management tools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many state management libraries out there, with the two most popular
    being Redux and MobX.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Redux
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Redux, you keep the state of your application inside an object literal that
    belongs to a *store*. When the state needs to be changed, an *action* describing
    what has happened should be emitted.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you''d define a set of *reducer* functions, each responding to different
    types of actions. The purpose of a reducer is to generate a new state object that’ll
    replace the last one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84d96930-a7fa-486c-ac96-09b341d1e6a9.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: This way, updating the state no longer requires calling 20 different `onChange`
    functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: However, you'd still need to pass the state via the props of many components.
    There’s a way to mitigate this through the use of *selectors*; but more on that
    later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: MobX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mobx incorporates functional reactive programming principles, and uses *observables*
    as its stores:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fc86d4c-d080-4f6d-a3f6-da156381b4fd.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: You can tag entities (for example, objects and arrays) as observables using
    the `@observable` decorator. You can also tag some functions with the `@computed`
    decorator to make it into a *derivation* or *reaction*. The `@computed` functions
    will be re-run each time the `@observable` store has changed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are a proposed addition to ECMAScript, currently tracked at [github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A derivation is a value that can be derived solely from the state. For example,
    we can make our `LoginPage` component a derivation of the state. When the state
    contains a token property, the user is already logged in and the `LoginPage` can
    display a message saying "You’re already logged in". When the state does not contain
    the token property, `LoginPage` will render the `LoginForm` component. What the
    `LoginPage` displays can be wholly derived from the value of the token property
    inside the state object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Reactions are events that are triggered whenever the state changes. For instance,
    if the stale state property of a news feed application changes to `true`, you
    may want to query the API to get fresh data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, state changes are triggered by *actions*, which are events that mutate
    the state. In MobX, actions are simply JavaScript statements that update the state
    in some way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Redux versus MobX
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, we must be clear that both Redux and MobX work well with
    React.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Redux has a much bigger community, its developer tools are much more mature,
    and there is more support when integrating with other tools.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Redux
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start by installing Redux:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s also an official React binding that provides the `connect` method that
    helps you connect a component to the store:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may also want to install the Redux DevTools ([https://github.com/reduxjs/redux-devtools](https://github.com/reduxjs/redux-devtools))
    as it'll make debugging with Redux much easier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Creating the store
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, the entire state of the application is stored as a
    single object inside a construct called the *store*. The store is central to a
    Redux application, so let’s create it. Inside `src/index.jsx`, add the following
    lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `createStore` method accepts three parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '`reducer` *function*: A function that takes in the current state and an action,
    and uses them to generate a new state.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialState` *any*: The initial state. The `initialState` can be of any data
    type, but we will use an object literal here.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enhancer` *function*: A function that takes in the current store, and modifies
    it to create a new, "enhanced" store. You may wish to use enhancers to implement
    middleware:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5ae39ed1-b9bf-4342-9214-19ec75bbac2c.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: At the moment, we’ll just focus on creating a store with a state, so we’re using
    a dummy reducer, which simply returns the state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The store object has many methods, the most important of which are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`getState`: Gets the current state of the store'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatch`: Dispatches an action to the store'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Subscribe functions to run whenever the store’s state changes'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using these three methods to implement our Redux integration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Lifting the state up
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let’s work on lifting the state up. Currently, we are holding the state in
    our two form elements. So let’s migrate those *local* states into the *central*
    state we’re keeping inside our Redux store.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the constructor methods inside the `LoginForm` and `RegistrationForm`
    components (these were only used to initialize the states), and update our `initialState`
    object to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to make this central state available to the components. We do
    this by passing the states down to the form components via the `Route` component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using `store.getState()` to get the current state of the store, and we
    are passing in only the relevant parts into the component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the render prop of `Route` instead of the component.
    The render prop is useful when you want to pass in in-scope variables without
    causing the component to unmount and re-mount.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to make sure that `ReactDOM.render` is called whenever the state
    changes, so the UI is a deterministic representation of our state. We do this
    by wrapping the `ReactDOM.render` call in a function, and invoking it each time
    the state changes by providing it as the argument to `store.subscribe`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, inside the `LoginForm` and `RegistrationForm` components, change every
    instance of `this.state` to `this.props`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The UI is now a deterministic representation of our state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Save and run `yarn run serve` to serve this new version of our application.
    You’ll notice that when you type in the input box, the value of the input box
    doesn't change. This is because we haven’t dispatched an action that'll alter
    our state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the value of `initialState.loginForm.email.value` and re-serve
    the application. You'll see that it is reflected in the form.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching actions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have integrated with React to make our UI a deterministic representation
    of our state. However, as demonstrated when you tried typing in the input box,
    there’s no way for us to update the state. Let's change that now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Just to recap, the way you change a state in Redux is by dispatching an action,
    and defining reducers that react to those actions and update the state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a scenario where we are updating the state; for instance,
    when we type in the input box in one of the forms. At the moment, we are using
    the `handleInputChange` method to update the local state:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead, we want to update this event handler to dispatch an action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'An action is simply an object that describes the event that has occurred. It
    should be as concise as possible. After creating an action, you call the `dispatch`
    method on the store to dispatch the action. For instance, the action to dispatch
    after an input value changed in our `RegistrationForm` component would look like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we removed the validation logic. This is because it does not describe
    the event that has occurred (the input value changed). This validation logic belongs
    in the reducer, which we will implement now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Updating the state with the Reducer
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the dummy reducer function to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have migrated the validation logic here, and we are returning a new instance
    of the state. Because our state object has many layers, simply using `Object.assign`
    or the ES6 spread syntax would not be sufficient. Therefore, we are using an NPM
    package called `deepmerge` to perform the merge of our old and new states. So,
    make sure we are adding that package to our project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Convert the rest of the `RegistrationForm` component to use Redux (that is,
    change the `handleRegistration` method), and then do the same for the `LoginForm`
    component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Then, serve your application again, and it should work the same way as before.
    But always run `yarn run test:e2e` to make sure!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with React Redux
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve used `createStore` to create a new store, `store.getState` to
    get the state of the store, `store.dispatch` to dispatch actions that get processed
    by the reducer to alter the state, and finally `subscribe` to re-run our `render`
    function whenever the state changed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to do all that by hand, but there’s a better alternative that simplifies
    this as well as adds many performance optimizations that prevents unnecessary
    re-renders. React Redux is the official binding of Redux for React. It provides
    a `connect` function that will replace the role of `store.subscribe`, reads from
    the Redux store’s state, and passes the relevant parts as props to the presentational
    components (for example, `Input` and `Button`). Let’s install it now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It works with React Redux like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: You wrap the root component of the application with the `<Provider>` component.
    This makes the Redux store available to every component within the app.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within each container component that needs to read from the state, you use the
    `connect` function to connect the component to the Redux store.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping with the Provider component
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, remove the `store.subscribe` call from `src/index.jsx`. We no longer
    need this as `connect` will take care of subscribing to changes to the state.
    This also means we no longer need to wrap our `ReactDOM.render` call inside a
    function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Next, since we will be calling `connect` within each component, there’s no need
    to pass the store and the state properties as props. Therefore, in our `<Route>`
    components, switch back to using the component prop instead of `render`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Most importantly, wrap our entire application with the `<Provider>` component,
    passing the store as its only prop:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the store is available to all components within the app. To access the
    store’s state and to dispatch actions to the store, we’d need to use `connect`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Redux store
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are not passing down the store and the state to the form components,
    we need to use `connect` to re-connect the component to the store.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect` function has the following signature:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All arguments are optional, and are described next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: mapStateToProps
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If `mapStateToProps` is a function, then the component will subscribe to changes
    in the store’s state. When a change occurs, the `mapStateToProps` function will
    be invoked, and is passed the store’s entire updated state. The function should
    extract the parts of the state that are relevant to this component, and return
    them as an object literal. This object literal will then be merged with the props
    passed to the component and be available in its methods through `this.props`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `LoginForm` component, we only care about the `loginForm` property
    inside the state, and so replace our current export statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do the same for `RegistrationForm`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If a component does not need to read the state from the store, but needs to
    interact with the store in other ways (for example, dispatching an event), then
    you can use `null` or `undefined` for the `mapStateToProps` argument. The component
    would then no longer react to state changes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `connect` function itself returns a function that you can then use to wrap
    your component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: mapDispatchToProps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `mapStateToProps` allows a component to subscribe to a store's state changes,
    `mapDispatchToProps` allows a component to dispatch actions to the store.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: It is called with a reference to the store’s dispatch method, and should return
    an object where each key maps to a function that calls the dispatch method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, our `mapDispatchToProps` function may look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `handleInputChange` key will get merged into the component's props, and
    be available in the component’s methods as `this.props.handleInputChange`. And
    thus, we can update the `onChange` prop on our Input components to `onChange={this.props.handleInputChange}`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling Redux from components
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may be thinking, "This looks extremely convoluted, why can''t I just pass
    the dispatch as the props and call `this.props.dispatch()` in my event handlers?
    Similar to what we did before?” Like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whilst that is certainly possible, it couples our component to Redux. Outside
    Redux, the concept of a dispatch method does not exist. Therefore, using `dispatch`
    within our component’s methods effectively ties the component to the Redux environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: By using the `mapDispatchToProps` function, we are decoupling the component
    from Redux. Now, `this.props.handleInputChange` is just a function we’ve passed
    down to the component. If we later decide not to use Redux, or we want to re-use
    the component in a non-Redux environment, we can simply pass down a different
    function, without changing the component code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can pull the dispatch call from the `handleLogin` event handler
    into `mapDispatchToProps`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To connect the dots, pass `mapStateToProps` and `mapDispatchToProps` into `connect`.
    This returns with a function that you can use to wrap the `LoginForm` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the original component (`LoginForm`) is not mutated. Instead, a newly-wrapped
    component is created and exported.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Then use `handleSuccess` in the `handleLogin` event handler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`handleLogin`事件处理器中使用`handleSuccess`：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Repeat the same steps for `RegistrationForm`. As always, run the tests to ensure
    there are no typos or mistakes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RegistrationForm`重复相同的步骤。一如既往，运行测试以确保没有错别字或错误。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have migrated our code to use Redux to manage our state.
    Having a single state store makes things much easier to manage and maintain.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经将代码迁移到使用Redux来管理我们的状态。拥有一个单一的状态存储使得事情的管理和维护变得更加容易。
- en: We have now finished our mini-tour of the front-end world. In the next chapter,
    we will look at how to use **Docker** to containerize our applications and make
    each service more independent and self-contained.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了前端世界的迷你之旅。在下一章中，我们将探讨如何使用**Docker**来容器化我们的应用程序，并使每个服务更加独立和自包含。
