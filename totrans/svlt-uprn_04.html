<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Effective Routing Techniques</h1>
<p>We’ve spent a lot of time covering background information. I know those topics aren’t always the most exciting, but now that we’ve covered them, we can get to the real fun. Up until now, we’ve only briefly touched on adding new routes by creating a directory inside <code>src/routes/</code> with the desired route name and adding a <code>+page.svelte</code> file inside of it. We also briefly looked into creating server pages. But, of course, routing isn’t always so simple. How do we build out an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>)? How do we create a consistent <strong class="bold">user interface </strong>(<strong class="bold">UI</strong>) throughout our application without duplicating styles on each page? What happens when our application throws an error?</p>
<p>In this chapter, we will answer some of those questions by discussing some core points about routing within the context of SvelteKit. First, we’ll look at how we can create new pages with dynamic content. Then, we’ll take a closer look at how the <code>+page.server.js</code> files work. We’ll then show how to go about creating API endpoints that can accept various types of HTTP requests. And finally, we’ll cover how to build a consistent UI throughout an application using layouts.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Creating Dynamic Pages</li>
<li>Creating Server Pages</li>
<li>Creating API Endpoints</li>
<li>Creating Layouts</li>
</ul>
<p>By the end of this chapter, you should have a comfortable understanding of routing concepts for SvelteKit’s file-based routing mechanism.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04</a>.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Creating Dynamic Pages</h1>
<p>In <a id="_idIndexMarker065"/>previous chapters, we’ve covered the process of creating a new page. To refresh your memory, it is as simple as creating a new directory inside <code>src/routes/</code> with the desired route name. Inside that directory, we create <code>+page.svelte</code>, which is simply a Svelte component that is then rendered as the page shown in the browser. An embarrassingly simple <strong class="bold">About</strong> page might look like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/about/+page.svelte</p>
<pre class="source-code">
&lt;div class='wrapper'&gt;
  &lt;h1&gt;About&lt;/h1&gt;
  &lt;p&gt;
    Lorem ipsum dolor sit amet...
  &lt;/p&gt;
&lt;/div&gt;</pre>
<p>This example illustrates just how simple adding a new page is. In it, we see a <code>div</code>, an <code>h1</code> title tag, and a paragraph <code>p</code> tag with the <code>lorem ipsum</code> sample text. Of course, in a real-world scenario, it would have much more content as well as some styles. This example exists only to show how simple it is to add a new, static page.</p>
<p>But what if you needed to create a page where you didn’t know what the content was? What if we wanted to create a page with a dynamic URL? For instance, when viewing news articles online, users can typically share a link directly to the article. This means each article has its own unique URL. If we wanted to create a single template that showed articles pulled from a database, we would need to find a way to manage the URL to each as well.</p>
<p>In instances such as these, SvelteKit’s file-based routing mechanism has a special syntax to use. When creating the template showing the content, we create it in a directory with the dynamic portion of the route surrounded by square brackets (<code>[ ]</code>). The name given inside the brackets will then become a parameter that will allow us to load data dynamically. To make this parameter optional, use double square brackets (<code>[[ ]]</code>).</p>
<p>That may<a id="_idIndexMarker066"/> sound confusing at first, so let’s take a look at an example showcasing how you might manage news articles or blog posts. We’ll need to create a few files within this example. Instead of connecting to an actual database, we’ll use a JSON file to store some sample data and pull directly from that:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/articles.json</p>
<pre class="source-code">
{
  "0": {
    "title": "First Post",
    "slug": "first-post",
    "content": "Lorem ipsum dolor…"
  },
  "1": {
    "title": "Effective Routing Techniques",
    "slug": "effective-routing-techniques",
    "content": "Lorem ipsum dolor…"
  }
}</pre>
<p>This file is essentially a single object containing two objects, each of which has the <code>title</code>, <code>slug</code>, and <code>content</code> properties. You can tweak this file however you like or add as many entries as you’d like to see. Its purpose is to act as a placeholder database to illustrate the following example.</p>
<p>Next, a news page usually has a landing page where users can scroll and view the most recent articles. In accordance with established practices, we’ll create a <code>+page.server.js</code> file to load our data and make it available to the <code>+page.svelte</code> template that will function as the page rendering the data:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/news/+page.server.js</p>
<pre class="source-code">
import json from '$lib/articles.json';
export function load() {
  return { json };
}</pre>
<p>Because<a id="_idIndexMarker067"/> it doesn’t contain any environment variables or secrets or make a call to a real database, this file could just as well be a <code>+page.js</code> file. It works only to load data from the JSON example file. Essentially, it imports that file and then returns it as an object in the exported <code>load()</code> function, making it available to the Svelte template shown next. In reality, something so trivial could also be done in the <code>&lt;script&gt;</code> tag of the Svelte template but remember that this example aims to function as a stand-in for a real database.</p>
<p>Now that we’ve loaded our articles, we’ll need somewhere to show them, so let’s do that now and create a landing page for our news. For the sake of brevity, styles have been omitted:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/news/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;h1&gt;
  News
&lt;/h1&gt;
&lt;ul&gt;
  {#each Object.entries(data.json) as [key, value]}
    &lt;li&gt;
      &lt;a href='/news/{value.slug}'&gt;{value.title}&lt;/a&gt;
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre>
<p>This<a id="_idIndexMarker068"/> Svelte component exports the <code>data</code> variable, giving us access to the data we previously returned from our faked database in <code>load()</code>. It then adds an <code>h1</code> title tag, followed by an unordered list of each of the entries from our fake data. After which, it makes use of the <code>{#each}</code> Svelte template syntax to iterate over each of the entries in the array returned from <code>Object.entries(data.json)</code>. For each of the entries (our two sample objects), we surround them with list item tags and show the <code>title</code> property inside a <code>&lt;a&gt;</code> tag linking to the article via the <code>slug</code> property.</p>
<p>Next, we’ll need to create a page to show the article content but keep in mind we want the route to have a parameter within it, so we’ll use the <code>[ ]</code> square brackets to surround the article slug:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/news/[slug]/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;h1&gt;News&lt;/h1&gt;
&lt;h2&gt;{data.title}&lt;/h2&gt;
&lt;div class='content'&gt;
  {data.content}
&lt;/div&gt;
&lt;a href='/news'&gt;Back to news&lt;/a&gt;</pre>
<p>This file exports the <code>data</code> variable so that we may access information about our article. It then shows <code>News</code> inside a <code>&lt;h1&gt;</code> title tag, followed by a <code>&lt;h2&gt;</code> title tag with the article title, a <code>div</code> containing the article content, and a link back to the news page. All of the article information is loaded by making another call to our <em class="italic">database</em> in the next file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/news/[slug]/+page.server.js</p>
<pre class="source-code">
import json from '$lib/articles.json';
import { error } from '@sveltejs/kit';
export function load({ params }) {
  let found = {};
  Object.keys(json).forEach((id) =&gt; {
    if(json[id].slug === params.slug) {
      found = json[id];
    }
  });
  if(Object.keys(found).length !== 0) {
    return found;
  }
  throw error(404, 'Whoops! That article wasn\'t found!');
}</pre>
<p>Just as<a id="_idIndexMarker069"/> before, we’ve imported our fake database to access the full article content. This code also imports the <code>error</code> module from SvelteKit, which will come in handy later on. We’ve then exported the <code>load()</code> function so that we can return the loaded data to the rendered page. Inside the <code>load()</code> function, the code initializes an empty variable labeled <code>found</code>, and then begins to iterate over each object inside of the JSON data. In the loop, it checks whether any of the slugs in our data match the given slug in the URL. If a match is found, it is then assigned to the <code>found</code> variable. After finishing the loop, we check that <code>found</code> is not an empty object. If it is not empty, we return an object containing the <code>found</code> variable. If it is empty, we throw a <strong class="bold">404 Not </strong><strong class="bold">Found</strong> error.</p>
<p>Upon opening your development site in your browser and navigating to <code>/news</code>, you should see two article titles listed. When clicked, they will redirect users to the respective article. This <a id="_idIndexMarker070"/>example illustrates routing with parameters in a simple way that works for the most part. But what do we do about the times when it doesn’t work? Have you tried navigating to an article that doesn’t exist yet? Go ahead and try it now; I’ll wait right here:</p>
<div><div><img alt="" src="img/B19024_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A generic error page is shown when throwing an error in SvelteKit</p>
<p>The article doesn’t exist, and the user is shown a generic error page. If we didn’t throw an error at all, the page would be rendered showing the <code>undefined</code> values. Instead, we should show the user a proper error page. Just as SvelteKit provides us with the <code>+page.svelte</code>, <code>+page.js</code>, and <code>+page.server.js</code> files, we can also create an <code>+error.svelte</code> template, which can be used when errors are thrown from the application. By specifying it in the <code>src/routes/news/[slug]/</code> directory, the error page template will be localized to that particular route. If we wanted to build a generic error page to be used across the entire application, we could do so by placing an <code>+error.svelte</code> template at the root route of the application (<code>src/routes/+error.svelte</code>). Let’s create a template in <code>src/routes/news/[slug]/</code> so users aren’t confused by our lack of clear communication:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/news/[slug]/+error.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { page } from '$app/stores';
&lt;/script&gt;
&lt;h1&gt;News&lt;/h1&gt;
&lt;h2&gt;{$page.status}&lt;/h2&gt;
&lt;div class='content'&gt;
  {$page.error.message}
&lt;/div&gt;
&lt;style&gt;
  * {
    font-family: sans-serif;
  }
  h1, h2, .content {
    text-align: center;
    color: #358eaa;
  }
&lt;/style&gt;</pre>
<p>For this<a id="_idIndexMarker071"/> error template, we import the <code>page</code> store module to access information about this particular request. This module, as well as many others, is available to use throughout the application. As this one makes use of Svelte’s stores, we can access the values it contains about the page by prefacing it with a dollar sign (<code>$</code>). The rest of this template is fairly straightforward. It includes the <code>&lt;h1&gt;</code> title tag labeled <code>News</code>, followed by the status code and error message we passed when we threw our error in <code>+page.server.js</code>. Some styles have been included to show how this template is different from the default template shown throughout SvelteKit. Compare <em class="italic">Figure 4</em><em class="italic">.1</em> of the generic SvelteKit error template to <em class="italic">Figure 4</em><em class="italic">.2</em>, our custom version:</p>
<div><div><img alt="" src="img/B19024_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A customized error page template</p>
<p>By now, you <a id="_idIndexMarker072"/>should feel comfortable creating essential routes for your application, whether they are static or dynamic. You should also be able to show error pages based on the route. There will be more about advanced routing later on, but for now, let’s take a closer look at how the <code>+page.server.js</code> files work.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Creating Server Pages</h1>
<p>In <a id="_idIndexMarker073"/>previous examples, we’ve used the <code>+page.js</code> and <code>+page.server.js</code> files for loading data. Often, they can be used interchangeably, but when is the best time to use which? In this section, we’ll break down some of the differences between the two and also discuss various features available in the <code>+page.server.js</code> files. We’ll break it down into these topics:</p>
<ul>
<li><code>load()</code></li>
<li>Page options</li>
<li>Actions</li>
</ul>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>load()</h2>
<p>As we’ve<a id="_idIndexMarker074"/> seen in previous examples, data can be loaded into a <code>+page.svelte</code> component by exporting the <code>data</code> property on that page. Both <code>+page.js</code> and <code>+page.server.js</code> can then be used for loading data to that page template as they can both export a <code>load()</code> function. When to use which file depends on how you plan to load that data. When run in a <code>+page.js</code> file, <code>load()</code> will run on <em class="italic">both the client and the server</em>. It is recommended to load data here if you are able, as SvelteKit can manage grabbing data from calls with <code>fetch()</code>. This becomes particularly useful when preloading data (anticipating what the user may do and starting the process milliseconds before they actually do it).</p>
<p>However, there are times this isn’t possible. For instance, if you need to make a call to an API that requires authentication or a database, you likely don’t want your connection secrets exposed to the client. That would allow anyone with access to your application to then download your secrets and make requests to said API or database on your behalf. In these cases, you’ll need to store the secrets on your server. And since those secrets are on your server, you’ll need access to the server’s filesystem. The server will need to make the calls to obtain the appropriate data and pass that data to the client. In instances such as these, it is best to use the <code>+page.server.js</code> files for data loading requirements.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Page options</h2>
<p><code>+page.js</code> and <code>+page.server.js</code> files are not just used for loading data. They can also <a id="_idIndexMarker075"/>export various options specific to their sibling page. Some <a id="_idIndexMarker076"/>options allow you to configure functionality related to the rendering of pages. These particular options are Boolean values, which means they can be enabled by setting them to <code>true</code> or disabled by setting them to <code>false</code>. They are the following:</p>
<ul>
<li><code>prerender</code></li>
<li><code>ssr</code></li>
<li><code>csr</code></li>
</ul>
<h3>prerender</h3>
<p>While prerendering can be customized in a <code>svelte.config.js</code> project, you may find yourself <a id="_idIndexMarker077"/>needing to explicitly enable or disable it on a per-page basis. To enable it on a page, you can set <code>export const prerender = true;</code>. Conversely, setting its value to <code>false</code> will disable prerendering for that page. When to prerender a page should be determined by whether or not the HTML content of the page is static. If the HTML shown on the page should be the same no matter who is viewing it, then a page is considered safe to prerender. By prerendering a page, the HTML will be generated at build time, and static HTML will be shipped to the client for each request to that particular route. This results in faster load times for end users, which makes for a better experience.</p>
<h3>Server-side rendering</h3>
<p><code>export const ssr = true;</code> in the <code>+page.js</code> file or <code>+page.server.js</code>. SvelteKit enables this option by default, so if you need to change it, you’ll likely find yourself disabling it by setting the value to <code>false</code>.</p>
<h3>Client Side Rendering</h3>
<p>Instead of <a id="_idIndexMarker080"/>rendering the page on the server, and sending that to the client, enabling <code>export const csr = false;</code> just as you would with other available page options.</p>
<p>You’ll likely find these rendering-related options useful should you find yourself building an SPA, a static HTML site, or if you’re attempting to render static content on the client end.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Actions</h2>
<p>Because <code>+page.js</code> files <a id="_idIndexMarker083"/>are also run in the client, they cannot export actions. Actions allow you to <a id="_idIndexMarker084"/>receive data submitted by the <code>form</code> elements sent via the POST HTTP method. We saw an example of this in <a href="B19024_03_Final_AM.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, where we discussed the <code>FormData</code> API compatibility with SvelteKit. In that example, we exported a default action. A default action will be triggered by submitting a form element that has not specified an <code>action</code> property. However, we are not limited to only default actions, as SvelteKit also enables us to create named actions. Named actions will all work on the same route but are differentiated from each other by providing the route followed by the action name in a query string. A default action may not exist alongside named actions, so you must remove it or change its name and set the <code>action</code> property on the <code>form</code> elements that utilize it.</p>
<p>Building from our previous example, let’s look at how we might implement a few more actions related to comments online. Some additional functionality we may want to create would be allowing users to <code>star</code> a comment or reply. Since we’ll be adding more named actions, we’ll change the <code>default</code> action to <code>create</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/comment/+page.server.js</p>
<pre class="source-code">
export const actions = {
  create: async (event) =&gt; {
    const form = await event.request.formData();
    …
  },
  star: async () =&gt; {
    return {
      status: true,
      msg: 'You starred this comment!'
    }
  },
  reply: async () =&gt; {
    return {
      status: true,
      msg: 'You replied!'
    }
  }
}</pre>
<p>Notice <a id="_idIndexMarker085"/>how the <code>default</code> action was changed to <code>create</code>. The code within <code>create</code> has been omitted as it has not changed since our last example. We’ve also added the <code>star</code> and <code>reply</code> actions. For now, they don’t do much except return an object that will output our message, showcasing that they are both called when the respective button is clicked. In a real-world scenario, these would likely make calls to a database, increasing the “star count,” or saving the reply comment content and a unique identifier of the comment being replied to.</p>
<p>As for the<a id="_idIndexMarker086"/> form itself, we could create separate forms and specify the <code>POST</code> method as well as the <code>action</code> property for each new feature. However, a more intuitive user experience would consolidate the features and keep them all in one cohesive component. Instead of creating multiple forms, we’ll create a button for the new features and specify a <code>formaction</code> property for each. Doing this will keep the HTTP method specified in the parent form but allow sending the requests to different actions based on the button clicked:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/comment/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { enhance } from '$app/forms';
  export let form;
&lt;/script&gt;
&lt;div class='wrap'&gt;
  {#if form &amp;&amp; form.status === true}
    &lt;p&gt;{form.msg}&lt;/p&gt;
  {/if}
  &lt;form method='POST' action='?/create' use:enhance&gt;
    &lt;label&gt;
      Comment
      &lt;input name="comment" type="text"&gt;
    &lt;/label&gt;
    &lt;button&gt;Submit&lt;/button&gt;
    &lt;button formaction='?/star'&gt;Star&lt;/button&gt;
    &lt;button formaction='?/reply'&gt;Reply&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;style&gt;
…
&lt;/style&gt;</pre>
<p>The<a id="_idIndexMarker087"/> first change to notice from our previous encounter with this example is<a id="_idIndexMarker088"/> that we’ve added <code>import { enhance } from '$app/forms';</code>. This addition will allow us to progressively enhance our form with JavaScript. The page will then not need to be reloaded after each form submission. This module is utilized in the <code>&lt;form&gt;</code> element further down with the Svelte <code>use:</code> directive. Try running the example without it and observe how the URL will now contain query strings based on which button is clicked.</p>
<p>Speaking of buttons, we’ve added two in this example. Each has the <code>formaction</code> property set, which allows us to specify which of our named actions we would like called from <code>+page.server.js</code>. Take note that we <em class="italic">must</em> call these actions by specifying a query parameter followed by a <code>/</code> character. We’ve also set the form action to <code>?/create</code>. Since we have exported named actions, we can no longer have an action named <code>default</code> and must specify the action to be called on the <code>form</code> element. If we wanted to call an action located at another route, we could do so easily by setting <code>formaction</code> to the desired route name followed by <code>?/</code>, and the action name.</p>
<p>You should now be <a id="_idIndexMarker089"/>confident in knowing when to use <code>+page.server.js</code> over <code>+page.js</code>, how to customize the rendering of pages, and how you can easily accept data from the <code>form</code> elements. In the next section, we’ll cover how you can create API endpoints that accept more than just POST requests.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>API Endpoints</h1>
<p>We’ve covered<a id="_idIndexMarker090"/> the <code>+page.svelte</code>, <code>+page.js</code>, and <code>+page.server.js</code> files but we have yet to discuss <code>+server.js</code> files. These files enable us to accept more than just <code>POST</code> requests. As web application developers, we may be expected to support various platforms. Having an API simplifies the transmission of data between our server and these other platforms. Many APIs can accept GET and POST requests as well as PUT, PATCH, DELETE, or OPTIONS.</p>
<p>A <code>+server.js</code> file creates an API endpoint by exporting a function with the name of the HTTP request method you would like for it to accept. The functions exported will take a SvelteKit-specific <code>RequestEvent</code> parameter and return a <code>Response</code> object. As an example, we can create a simple endpoint that would allow us to create posts for a blog. This could be useful if we used a mobile app to write and post from. Note that a <code>+server.js</code> file should not exist alongside page files as it is intended to handle all HTTP request types:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/api/post/+server.js</p>
<pre class="source-code">
import { json } from '@sveltejs/kit';
export function POST({ request }) {
  // save post to DB
  console.log(request);
  return json({
    status: true,
    method: request.method
  });
}
export function GET({ request }) {
  // retrieve post from DB
  console.log(request);
  return json({
    status: true,
    method: request.method
  });
}</pre>
<p>This <a id="_idIndexMarker091"/>file imports the <code>json</code> module from the <code>@sveltejs/kit</code> package, which is useful for sending JSON-formatted <code>Response</code> objects. We then export functions named for both POST and GET methods, each of which only outputs the <code>Request</code> object to the console and then returns a <code>Response</code> JSON. If we were so inclined, we could also export functions for other HTTP verbs such as PUT, PATCH, or DELETE.</p>
<p>You should demo this example by navigating to the <code>api/post/</code> route in your browser. After opening the page, observe the rest of the properties available in the <code>Request</code> object output to your development server. If you don’t understand what you’re looking at, that’s okay because we’ll look into it more in the next chapter. Back in your browser, open the <code>method</code> property set to POST returned in a JSON formatted object. If your browser doesn’t allow you to edit requests, proxy tools such as OWASP ZAP, Burp Suite, Postman, or Telerik Fiddler will let you customize HTTP requests. See the resources at the end of this chapter for links.</p>
<p>Now that you know how to go about creating your very own API, let’s look at how you can unify the user experience of your application with a layout.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Creating Layouts</h1>
<p>We've <a id="_idIndexMarker092"/>covered a lot so far in this chapter, but we’ve still only added styles and markup to each specific page. This is repetitive and not a practical use of our time. To reduce repetition, we can utilize layouts. A <code>+layout.svelte</code> component can unify the user experience by leveraging Svelte’s <code>&lt;slot&gt;</code> directive. The layout file will nest any sibling page components and child routes within itself, allowing us to show persistent markup across the application. Just like <code>+page.svelte</code>, we can include a <code>+layout.svelte</code> component at any level in our route hierarchy, allowing the nesting of layouts within layouts. Because each layout is also a Svelte component, the styles will be localized to that particular component and will not cascade to those nested within. Let’s look at how we might use layouts to create a consistent layout and navigation menu for our existing code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import Nav from '$lib/Nav.svelte';
&lt;/script&gt;
&lt;div class='wrapper'&gt;
  &lt;div class='nav'&gt;
    &lt;Nav /&gt;
  &lt;/div&gt;
  &lt;div class='content'&gt;
    &lt;slot /&gt;
  &lt;/div&gt;
  &lt;div class='footer'&gt;
    This is my footer
  &lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .wrapper {
    min-height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }
  .footer {
    text-align: center;
    margin: 20px 0;
  }
&lt;/style&gt;</pre>
<p>Because <a id="_idIndexMarker093"/>this <code>+layout.svelte</code> component is at the root level of our routes, it will be applied across all child routes. The very first thing our component does is import our custom navigation component (shown next). Secondly, it creates the markup that will house the rest of our application, including this file’s sibling <code>+page.svelte</code>. Its markup consists of several <code>&lt;div&gt;</code> elements with varying class names indicating functionality. The <code>.wrapper</code> <code>&lt;div&gt;</code> element wraps all others so that we may apply the sticky footer styles found in the <code>&lt;style&gt;</code> section of this component. The div with the <code>.nav</code> class contains our custom <code>Nav</code> component, the <code>.content</code> div contains our Svelte <code>&lt;slot&gt;</code> directive, and <code>.footer</code> is where we would put our site footer information. Now let’s take a look at the custom <code>Nav</code> component we imported in our root layout:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Nav.svelte</p>
<pre class="source-code">
&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/news'&gt;News&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/fetch'&gt;Fetch&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/comment'&gt;Comment&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/about'&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/api/post'&gt;API&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;style&gt;
  ul {
    list-style: none;
    text-align: center;
  }
  ul li {
    display: inline-block;
    padding: 0;
    margin: 1em .75em;
  }
&lt;/style&gt;</pre>
<p>This<a id="_idIndexMarker094"/> component merely contains HTML with links to all of the routes we’ve already created and some rudimentary styling. It consists of the <code>&lt;a&gt;</code> elements with the <code>href</code> properties set to the relative routes we’ve created up to this point. They are all nested within list items of an unordered list, contained within a <code>&lt;nav&gt;</code> element. Again, this example is overly simple, but for our purposes, it works. Now, you can add any new routes we create later on in the book to the navigation menu so they may be easily accessed when testing in the browser.</p>
<p class="callout-heading">Relative routes</p>
<p class="callout">Notice how the routes provided are relative and are not prefaced by a domain name. If we were to deploy our production application to a subdirectory; rather than the root folder of our domain, these routes would fail. Instead, we can set the base path of our application in <code>svelte.config.js</code>. Specifically, we’d set <code>config.kit.paths.base</code> to our subdirectory path, starting with a <code>/</code>. Then in components and routes, we could use <code>import { base } from $app/paths</code> and preface all routes with <code>{base}/</code>. In this way, our application would know it exists within a subdirectory. Try doing it in your development project and observe how Vite and SvelteKit automatically serve the project from that directory!</p>
<p>To<a id="_idIndexMarker095"/> practice the concepts surrounding layouts further, try creating <code>src/routes/news/[slug]/+layout.svelte</code> to give the articles a consistent appearance. Just as we saw with the <code>+page.svelte</code> files, the <code>+layout.svelte</code> files can be accompanied by the <code>+layout.js</code> or <code>+layout.server.js</code> files. Their functionality is identical to their page counterparts, but the data returned from them will be available in <code>+layout.svelte</code> as well as any <code>+page.svelte</code> pages that exist in parallel. Page options can also be set in layout files, and those options will “trickle down” to nested components.</p>
<p>With the information provided, you should now have the skills necessary to produce consistent and robust UIs for your SvelteKit applications. Layouts come in handy when creating all sorts of UI elements, but especially those that must remain consistent across various portions of the app.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Summary</h1>
<p>In this chapter, we covered how to create static and dynamic routes as well as manage custom error templates for those routes. We also saw how developers can accept data submitted via the <code>&lt;form&gt;</code> elements with multiple named actions that can be called from a single form. We learned how to leverage SvelteKit’s routing mechanism to build out an API, which is particularly useful when an application needs to be accessed from platforms other than web browsers. We then unified the UI of our application with layouts. With those layouts, we saw how they can be leveraged to keep navigation elements in a predictable location across the app. That’s a lot of information to absorb in these few pages so we’ll take a closer look at some of these concepts in the next few chapters.</p>
<p>In the next chapter, we will learn more about managing the data we’re loading onto our pages. We’ll also cover more advanced methods for loading that data.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Resources</h1>
<p><strong class="bold">HTTP </strong><strong class="bold">Proxy/Sending Tools</strong>:</p>
<ul>
<li>OWASP ZAP (Web App Penetration Testing and Proxy): <a href="https://www.zaproxy.org/">https://www.zaproxy.org/</a>.</li>
<li>Burp Suite (Web App Penetration Testing and Proxy): <a href="https://portswigger.net/burp">https://portswigger.net/burp</a>.</li>
<li>Postman (API Testing Tool): <a href="https://www.postman.com/">https://www.postman.com/</a></li>
<li>Telerik Fiddler (Web Debugging and Proxy Tool): <a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a>.</li>
</ul>
</div>
</body></html>