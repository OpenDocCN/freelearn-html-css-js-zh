<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Developing a Basic Site with Node.js and Express"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Developing a Basic Site with Node.js and Express</h1></div></div></div><p class="calibre7">In the previous chapter, we learned about common programming paradigms and how they apply to Node.js. In this chapter, we will continue with the <span class="strong"><strong class="calibre8">Express</strong></span> framework. It's one of the most popular frameworks available and is certainly a pioneering one. Express is still widely used and several developers use it as a starting point.</p></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Developing a Basic Site with Node.js and Express">
<div class="book" title="Getting acquainted with Express"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec17" class="calibre1"/>Getting acquainted with Express</h1></div></div></div><p class="calibre7">Express <a id="id44" class="calibre1"/>(<a class="calibre1" href="http://expressjs.com/">http://expressjs.com/</a>) is a <a id="id45" class="calibre1"/>web application framework for <a id="id46" class="calibre1"/>Node.js. It is built on top of <a id="id47" class="calibre1"/>Connect (<a class="calibre1" href="http://www.senchalabs.org/connect/">http://www.senchalabs.org/connect/</a>), which means that it implements middleware architecture. In the previous chapter, when exploring Node.js, we discovered the benefit of such a design decision: the framework acts as a plugin system. Thus, we can say that Express is suitable for not only simple but also complex applications because of its architecture. We may use only some of the popular types of middleware or add a lot of features and still keep the application modular.</p><p class="calibre7">In general, most projects in Node.js perform two functions: run a server that listens on a specific port, and process incoming requests. Express is a wrapper for these two functionalities. The following is basic code that runs the server:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '127.0.0.1');
console.log('Server running at http://127.0.0.1:1337/');</pre></div><p class="calibre7">This is an example extracted from the official documentation of Node.js. As shown, we use the native module <code class="email">http</code>
<span class="strong"><em class="calibre9"> </em></span>and run a server on the port <code class="email">1337</code>. There is also a request handler function, which simply sends the <code class="email">Hello world</code> string to the browser. Now, let's implement the same thing but with the Express framework, using the following code:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var app = express();
app.get("/", function(req, res, next) {
  res.send("Hello world");
}).listen(1337);
console.log('Server running at http://127.0.0.1:1337/');</pre></div><p class="calibre7">It's pretty much <a id="id48" class="calibre1"/>the same thing. However, we don't need to specify the response headers or add a new line at the end of the string because the framework does it for us. In addition, we have a bunch of middleware available, which will help us process the requests easily. Express is like a toolbox. We have a lot of tools to do the boring stuff, allowing us to focus on the application's logic and content. That's what Express is built for: saving time for the developer by providing ready-to-use functionalities.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Installing Express"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Installing Express</h1></div></div></div><p class="calibre7">There are two ways to install <a id="id49" class="calibre1"/>Express. We'll will start with the simple one and then proceed <a id="id50" class="calibre1"/>to the more advanced technique. The simpler approach generates a template, which we may use to start writing the business logic directly. In some cases, this can save us time. From another viewpoint, if we are developing a custom application, we need to use custom settings. We can also use the boilerplate, which we get with the advanced technique; however, it may not work for us.</p></div>

<div class="book" title="Installing Express">
<div class="book" title="Using package.json"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec09" class="calibre1"/>Using package.json</h2></div></div></div><p class="calibre7">Express is like <a id="id51" class="calibre1"/>every other module. It has its own place in the <a id="id52" class="calibre1"/>packages register. If we want to use it, we need <a id="id53" class="calibre1"/>to add the framework in the <code class="email">package.json</code> file. The ecosystem of Node.js is built on top of the Node Package Manager. It uses the JSON file to find out what we need and installs it in the current directory. So, the content of our <code class="email">package.json</code> file looks like the following code:</p><div class="informalexample"><pre class="programlisting">{
  "name": "projectname",
  "description": "description",
  "version": "0.0.1",
  "dependencies": {
    "express": "3.x"
  }
}</pre></div><p class="calibre7">These are the required fields that we have to add. To be more accurate, we have to say that the mandatory fields are <code class="email">name</code> and <code class="email">version</code>. However, it is always good to add descriptions to our modules, particularly if we want to publish our work in the registry, where such information is extremely important. Otherwise, the other developers will not know what our library is doing. Of course, there are a bunch of other fields, such as contributors, keywords, or <a id="id54" class="calibre1"/>development dependencies, but we will stick to limited options so that we<a id="id55" class="calibre1"/> can focus on Express.</p><p class="calibre7">Once we have our <code class="email">package.json</code> file <a id="id56" class="calibre1"/>placed in the project's folder, we have to call <code class="email">npm install</code> in the console. By doing so, the package manager will create a <code class="email">node_modules</code> folder and will store Express and its dependencies there. At the end of the command's execution, we will see something like the following screenshot:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Using package.json" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The first line shows us the installed version, and the proceeding lines are actually modules that Express depends on. Now, we are ready to use Express. If we type <code class="email">require('express')</code>, Node.js will start looking for that library inside the local <code class="email">node_modules</code> directory. Since we are not using absolute paths, this is normal behavior. If we miss running the <code class="email">npm install</code> command, we will be prompted with <code class="email">Error: Cannot find module 'express'</code>.</p></div></div>

<div class="book" title="Installing Express">
<div class="book" title="Using a command-line tool"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec10" class="calibre1"/>Using a command-line tool</h2></div></div></div><p class="calibre7">There is a <a id="id57" class="calibre1"/>command-line instrument<a id="id58" class="calibre1"/> called <code class="email">express-generator</code>. Once we run <code class="email">npm install -g express-generator</code>, we will<a id="id59" class="calibre1"/> install and use it as every other command in our terminal.</p><p class="calibre7">If you use the framework in<a id="id60" class="calibre1"/> several projects, you will notice that some things are repeated. We can even copy and paste them from one application to another, and this is perfectly fine. We may even end up with our own boilerplate and can always start from there. The command-line version of Express does the same thing. It accepts few arguments and based on them, creates a skeleton for use. This can be very handy in some cases and will definitely save some time. Let's have a look at the available arguments:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">-h, --help</code>: This<a id="id61" class="calibre1"/> signifies output usage information.</li><li class="listitem"><code class="email">-V, --version</code>: This <a id="id62" class="calibre1"/>shows the version of Express.</li><li class="listitem"><code class="email">-e, --ejs</code>: This <a id="id63" class="calibre1"/>argument adds the EJS template engine support. Normally, we need a library to deal with our templates. Writing pure HTML is not very practical. The default engine is set to JADE.</li><li class="listitem"><code class="email">-H, --hogan</code>: This<a id="id64" class="calibre1"/> argument is Hogan-enabled (another template engine).</li><li class="listitem"><code class="email">-c, --css</code>: If we <a id="id65" class="calibre1"/>want to use the CSS preprocessors, this option lets us use <a id="id66" class="calibre1"/><span class="strong"><strong class="calibre8">LESS</strong></span> (short for<span class="strong"><strong class="calibre8"> Leaner CSS</strong></span>) or <a id="id67" class="calibre1"/>Stylus. The default is plain CSS.</li><li class="listitem"><code class="email">-f, --force</code>: This forces Express to operate on a nonempty directory.</li></ul></div><p class="calibre7">Let's try to generate an Express application skeleton with LESS as a CSS preprocessor. We use the following line of command:</p><div class="informalexample"><pre class="programlisting">express --css less myapp</pre></div><p class="calibre7">A new <code class="email">myapp</code>
<span class="strong"><em class="calibre9"> </em></span>folder is created with the file structure, as seen in the following screenshot:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Using a command-line tool" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We still need to<a id="id68" class="calibre1"/> install the dependencies, so <code class="email">cd myapp &amp;&amp; npm install</code> is required. We will skip the explanation of the generated <a id="id69" class="calibre1"/>directories for now and will move to the <a id="id70" class="calibre1"/>created <code class="email">app.js</code> file. It starts with initializing the module dependencies, as follows:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var path = require('path');
var favicon = require('static-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');
var users = require('./routes/users');

var app = express();</pre></div><p class="calibre7">Our framework is <code class="email">express</code>, and <code class="email">path</code> is a native Node.js module. The middleware are <code class="email">favicon</code>, <code class="email">logger</code>, <code class="email">cookieParser</code>, and <code class="email">bodyParser</code>. The <code class="email">routes</code> and <code class="email">users</code> are custom-made modules, placed in local for the project folders. Similarly, as in the <a id="id71" class="calibre1"/>
<span class="strong"><strong class="calibre8">Model-View-Controller</strong></span> (<span class="strong"><strong class="calibre8">MVC</strong></span>) pattern, these are the controllers for our application. Immediately after, an <code class="email">app</code> variable is created; this represents the Express library. We use this variable to configure our application. The script continues by setting some key-value pairs. The next code snippet defines the path to our views and the default template engine:</p><div class="informalexample"><pre class="programlisting">app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');</pre></div><p class="calibre7">The framework uses the methods <code class="email">set</code> and <code class="email">get</code> to define the internal properties. In fact, we may use these methods to define our own variables. If the value is a Boolean, we can replace <code class="email">set</code> and <code class="email">get</code> with <code class="email">enable</code> and <code class="email">disable</code>. For example, see the following code:</p><div class="informalexample"><pre class="programlisting">app.set('color', 'red');
app.get('color'); // red
app.enable('isAvailable');</pre></div><p class="calibre7">The next code <a id="id72" class="calibre1"/>adds middleware to the framework. We <a id="id73" class="calibre1"/>can see the code as follows:</p><div class="informalexample"><pre class="programlisting">app.use(favicon());
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded());
app.use(cookieParser());
app.use(require('less-middleware')({ src: path.join(__dirname, 'public') }));
app.use(express.static(path.join(__dirname, 'public')));</pre></div><p class="calibre7">The first <a id="id74" class="calibre1"/>middleware serves as the favicon of our application. The second is responsible for the output in the console. If we remove it, we will not get information about the incoming requests to our server. The following is a simple output produced by <code class="email">logger</code>:</p><div class="informalexample"><pre class="programlisting">GET / 200 554ms - 170b
GET /stylesheets/style.css 200 18ms - 110b</pre></div><p class="calibre7">The <code class="email">json</code> and <code class="email">urlencoded</code> middleware are related to the data sent along with the request. We need them because they convert the information in an easy-to-use format. There is also a middleware for the cookies. It populates the request object, so we later have access to the required data. The generated app uses LESS as a CSS preprocessor, and we need to configure it by setting the directory containing the <code class="email">.less</code> files. We will talk about LESS in <a class="calibre1" title="Chapter 10. Writing Flexible and Modular CSS" href="part0074_split_000.html#page">Chapter 10</a>, <span class="strong"><em class="calibre9">Writing Flexible and Modular CSS</em></span>, where will cover this in detail. Eventually, we define our static resources, which should be delivered by the server. These are just few lines, but we've configured the whole application. We may remove or replace some of the modules, and the others will continue working. The next code in the file maps two defined routes to two different handlers, as follows:</p><div class="informalexample"><pre class="programlisting">app.use('/', routes);
app.use('/users', users);</pre></div><p class="calibre7">If the user tries to open a missing page, Express still processes the request by forwarding it to the error handler, as follows:</p><div class="informalexample"><pre class="programlisting">app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});</pre></div><p class="calibre7">The <a id="id75" class="calibre1"/>framework suggests two types of error handling: <a id="id76" class="calibre1"/>one for the development<a id="id77" class="calibre1"/> environment and another for the production server. The difference is that the second one hides the stack trace of the error, which should be visible only for the developers of the application. As we can see in the following code, we are checking the value of the <code class="email">env</code> property and handling the error differently:</p><div class="informalexample"><pre class="programlisting">// development error handler
if (app.get('env') === 'development') {
    app.use(function(err, req, res, next) {
        res.status(err.status || 500);
        res.render('error', {
            message: err.message,
            error: err
        });
    });
}
// production error handler
app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});</pre></div><p class="calibre7">At the end, the <code class="email">app.js</code> file exports the created Express instance, as follows:</p><div class="informalexample"><pre class="programlisting">module.exports = app;</pre></div><p class="calibre7">To run the application, we need to execute <code class="email">node ./bin/www</code>. The code requires <code class="email">app.js</code> and starts the server, which by default listens on port <code class="email">3000</code>.</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env node
var debug = require('debug')('my-application');
var app = require('../app');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});</pre></div><p class="calibre7">The <code class="email">process.env</code> declaration <a id="id78" class="calibre1"/>provides an access to variables <a id="id79" class="calibre1"/>defined in the current development<a id="id80" class="calibre1"/> environment. If there is no <code class="email">PORT</code> setting, Express uses 3000 as the value. The required <code class="email">debug</code> module uses a similar approach to find out whether it has to show messages to the console.</p></div></div>
<div class="book" title="Managing routes"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Managing routes</h1></div></div></div><p class="calibre7">The input of our application is the<a id="id81" class="calibre1"/> routes. The user visits our page at a specific URL and we have to map this URL to a specific logic. In the context of Express, this can be done easily, as follows:</p><div class="informalexample"><pre class="programlisting">var controller = function(req, res, next) {
  res.send("response");
}
app.get('/example/url', controller);</pre></div><p class="calibre7">We even have control over the HTTP's method, that is, we are able to catch POST, PUT, or DELETE requests. This is very handy if we want to retain the address path but apply a different logic. For example, see the following code:</p><div class="informalexample"><pre class="programlisting">var getUsers = function(req, res, next) {
  // ...
}
var createUser = function(req, res, next) {
  // ...
}
app.get('/users', getUsers);
app.post('/users', createUser);</pre></div><p class="calibre7">The path is still the same, <code class="email">/users</code>, but if we make a POST request to that URL, the application will try to create a new user. Otherwise, if the method is <code class="email">GET</code>, it will return a list of all the registered members. There is also a method, <code class="email">app.all</code>, which we can use to handle all the method types at once. We can see this method in the following code snippet:</p><div class="informalexample"><pre class="programlisting">app.all('/', serverHomePage);</pre></div><p class="calibre7">There is something interesting about the routing in Express. We may pass not just one but many handlers. This means that we can create a chain of functions that correspond to one URL. For example, it we need to know if the user is logged in, there is a module for that. We can add another method that validates the current user and attaches a variable to the request object, as follows:</p><div class="informalexample"><pre class="programlisting">var isUserLogged = function(req, res, next) {
  req.userLogged = Validator.isCurrentUserLogged();
  next();
}
var getUser = function(req, res, next) {
  if(req.userLogged) {
    res.send("You are logged in. Hello!");
  } else {
    res.send("Please log in first.");
  }
}
app.get('/user', isUserLogged, getUser);</pre></div><p class="calibre7">The <code class="email">Validator</code> class is a <a id="id82" class="calibre1"/>class that checks the current user's session. The idea is simple: we add another handler, which acts as an additional middleware. After performing the necessary actions, we call the <code class="email">next</code> function, which passes the flow to the next handler, <code class="email">getUser</code>. Because the request and response objects are the same for all the middlewares, we have access to the <code class="email">userLogged</code> variable. This is what makes Express really flexible. There are a lot of great features available, but they are optional. At the end of this chapter, we will make a simple website that implements the same logic.</p></div>
<div class="book" title="Handling dynamic URLs and the HTML forms"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Handling dynamic URLs and the HTML forms</h1></div></div></div><p class="calibre7">The Express framework also supports<a id="id83" class="calibre1"/> dynamic URLs. Let's say we have a separate page for every user in our system. The address to those pages looks like the following code:</p><div class="informalexample"><pre class="programlisting">/user/45/profile</pre></div><p class="calibre7">Here, <code class="email">45</code> is the unique number of the user in our database. It's of course normal to use one route handler for this functionality. We can't really define different functions for every user. The problem can be solved by using the <a id="id84" class="calibre1"/>following syntax:</p><div class="informalexample"><pre class="programlisting">var getUser = function(req, res, next) {
  res.send("Show user with id = " + req.params.id);
}
app.get('/user/:id/profile', getUser);</pre></div><p class="calibre7">The route is actually like a regular expression with variables inside. Later, that variable is accessible in the <code class="email">req.params</code> object. We can have more than one variable. Here is a slightly more complex example:</p><div class="informalexample"><pre class="programlisting">var getUser = function(req, res, next) {
  var userId = req.params.id;
  var actionToPerform = req.params.action;
  res.send("User (" + userId + "): " + actionToPerform)
}
app.get('/user/:id/profile/:action', getUser);</pre></div><p class="calibre7">If we open <code class="email">http://localhost:3000/user/451/profile/edit</code>, we see <code class="email">User (451): edit</code> as a response. This is how we can get a nice looking, SEO-friendly URL.</p><p class="calibre7">Of course, sometimes we need to pass data via the GET or POST parameters. We may have a request like <code class="email">http://localhost:3000/user?action=edit</code>. To parse it easily, we need to use the native <code class="email">url</code> module, which has few helper functions to parse URLs:</p><div class="informalexample"><pre class="programlisting">var getUser = function(req, res, next) {
  var url = require('url');
  var url_parts = url.parse(req.url, true);
  var query = url_parts.query;
  res.send("User: " + query.action);
}
app.get('/user', getUser);</pre></div><p class="calibre7">Once the module parses the given URL, our GET parameters are stored in the <code class="email">.query </code>object. The POST variables are a bit different. We need a new middleware to handle that. Thankfully, Express <a id="id85" class="calibre1"/>has one, which is as follows:</p><div class="informalexample"><pre class="programlisting">app.use(express.bodyParser());
var getUser = function(req, res, next) {
  res.send("User: " + req.body.action);
}
app.post('/user', getUser);</pre></div><p class="calibre7">The <code class="email">express.bodyParser()</code> middleware populates the <code class="email">req.body</code> object with the POST data. Of course, we have to change the HTTP method from <code class="email">.get</code> to <code class="email">.post</code> or <code class="email">.all</code>.</p><p class="calibre7">If we want to <a id="id86" class="calibre1"/>read cookies in Express, we may use the <code class="email">cookieParser</code> middleware. Similar to the body parser, it should also be installed and added to the <code class="email">package.json</code> file. The following example sets the middleware and demonstrates its usage:</p><div class="informalexample"><pre class="programlisting">var cookieParser = require('cookie-parser');
app.use(cookieParser('optional secret string'));
app.get('/', function(req, res, next){
    var prop = req.cookies.propName
});</pre></div></div>
<div class="book" title="Returning a response"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Returning a response</h1></div></div></div><p class="calibre7">Our server accepts<a id="id87" class="calibre1"/> requests, does some stuff, and finally, sends the response to the client's browser. This can be HTML, JSON, XML, or binary data, among others. As we know, by default, every middleware in Express accepts two objects, <code class="email">request</code> and <code class="email">response</code>. The <code class="email">response</code> object<a id="id88" class="calibre1"/> has methods that we can use to send an answer to the client. Every response should have a proper content type or length. Express simplifies the process by providing functions to set HTTP headers and sending content to the browser. In most cases, we will use the <code class="email">.send</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">res.send("simple text");</pre></div><p class="calibre7">When we pass a string, the framework sets the <code class="email">Content-Type</code>
<span class="strong"><em class="calibre9"> </em></span>header to <code class="email">text/html</code>. It's great to know that if we pass an object or array, the content type is <code class="email">application/json</code>. If we develop an API, the response status code is probably going to be important for us. With Express, we are able to set it like in the following code snippet:</p><div class="informalexample"><pre class="programlisting">res.send(404, 'Sorry, we cannot find that!');</pre></div><p class="calibre7">It's even possible to respond with a file from our hard disk. If we don't use the framework, we will need to read the file, set the correct HTTP headers, and send the content. However, Express offers the <code class="email">.sendfile</code> method, which wraps all these operations as follows:</p><div class="informalexample"><pre class="programlisting">res.sendfile(__dirname + "/images/photo.jpg");</pre></div><p class="calibre7">Again, the content type is set automatically; this time it is based on the filename's extension.</p><p class="calibre7">When building websites or applications with a user interface, we normally need to serve an HTML. Sure, we can write it manually in JavaScript, but it's good practice to use a template engine. This means we save everything in external files and the engine reads the markup from there. It populates them with some data and, at the end, provides ready-to-show content. In Express, the whole process is summarized in one method, <code class="email">.render</code>. However, to work properly, we have to instruct the framework regarding which template engine to use. We already talked about this in the beginning of this chapter. The following two lines of code, set the path to our views and the template engine:</p><div class="informalexample"><pre class="programlisting">app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');</pre></div><p class="calibre7">Let's say we have the following template (<code class="email">/views/index.jade</code>):</p><div class="informalexample"><pre class="programlisting">h1= title
p Welcome to #{title}</pre></div><p class="calibre7">Express provides a method to serve templates. It accepts the path to the template, the data to be applied, and a callback. To render the previous template, we should use the following code:</p><div class="informalexample"><pre class="programlisting">res.render("index", {title: "Page title here"});</pre></div><p class="calibre7">The <a id="id89" class="calibre1"/>HTML produced looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;Page title here&lt;/h1&gt;&lt;p&gt;Welcome to Page title here&lt;/p&gt;</pre></div><p class="calibre7">If we pass a third parameter, <code class="email">function</code>, we will have access to the generated HTML. However, it will not be sent as a response to the browser.</p></div>
<div class="book" title="The example-logging system"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>The example-logging system</h1></div></div></div><p class="calibre7">We've seen the main <a id="id90" class="calibre1"/>features of Express. Now let's build something real. The next few pages present a simple website where users can read only if they are logged in. Let's start and set up the application. We are going to use Express' command-line instrument. It should be installed using <code class="email">npm install -g express-generator</code>. We create a new folder for the example, navigate to it via the terminal, and execute <code class="email">express --css less site</code>. A new directory, <code class="email">site</code>, will be created. If we go there and run <code class="email">npm install</code>, Express will download all the required dependencies. As we saw earlier, by default, we have two routes and two controllers. To simplify the example, we will use only the first one: <code class="email">app.use('/', routes)</code>. Let's change the <code class="email">views/index.jade</code> file content to the following HTML code:</p><div class="informalexample"><pre class="programlisting">doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
  body
    h1= title
    hr
    p That's a simple application using Express.</pre></div><p class="calibre7">Now, if we run <code class="email">node ./bin/www</code> and open <code class="email">http://127.0.0.1:3000</code>, we will see the page. Jade uses indentation to parse our template. So, we should not mix tabs and spaces. Otherwise, we will get an error.</p><p class="calibre7">Next, we need to protect our content. We check whether the current user has a session created; if not, a login form is shown. It's the perfect time to create a new middleware.</p><p class="calibre7">To use sessions in Express, install an <a id="id91" class="calibre1"/>additional module: <code class="email">express-session</code>. We need to open our <code class="email">package.json</code> file and add the following line of code:</p><div class="informalexample"><pre class="programlisting">"express-session": "~1.0.0"</pre></div><p class="calibre7">Once we do that, a quick run of <code class="email">npm install</code> will bring the module to our application. All we have to do is use it. The following code goes to <code class="email">app.js</code>:</p><div class="informalexample"><pre class="programlisting">var session = require('express-session');
app.use(session({ secret: 'app', cookie: { maxAge: 60000 }}));
var verifyUser = function(req, res, next) {
    if(req.session.loggedIn) {
        next(); 
    } else {
        res.send("show login form");
    }   
}
app.use('/', verifyUser, routes);</pre></div><p class="calibre7">Note that we changed the original <code class="email">app.use('/', routes)</code> line. The <code class="email">session</code> middleware is initialized and added to Express. The <code class="email">verifyUser</code> function is called before the page rendering. It uses the <code class="email">req.session</code> object, and checks whether there is a <code class="email">loggedIn</code> variable defined and if its value is <code class="email">true</code>. If we run the script again, we will see that the <code class="email">show login form </code>text<code class="email"> </code>is shown for every request. It's like this because no code sets the session exactly the way we want it. We need a form where users can type their username and password. We will process the result of the form and if the credentials are correct, the <code class="email">loggedIn</code> variable will be set to <code class="email">true</code>. Let's create a new <code class="email">Jade</code> template, <code class="email">/views/login.jade</code>:</p><div class="informalexample"><pre class="programlisting">doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
  body
    h1= title
    hr
    form(method='post')
      label Username:
      br
      input(type='text', name='username')
      br
      label Password:
      br
      input(type='password', name='password')
      br
      input(type='submit')</pre></div><p class="calibre7">Instead of sending just <a id="id92" class="calibre1"/>a text with <code class="email">res.send("show login form");</code> we should render the new template, as follows:</p><div class="informalexample"><pre class="programlisting">res.render("login", {title: "Please log in."});</pre></div><p class="calibre7">We choose POST as the method for the form. So, we need to add the middleware that populates the <code class="email">req.body</code> object with the user's data, as follows:</p><div class="informalexample"><pre class="programlisting">app.use(bodyParser());</pre></div><p class="calibre7">Process the submitted username and password as follows:</p><div class="informalexample"><pre class="programlisting">var verifyUser = function(req, res, next) {
  if(req.session.loggedIn) {
    next();  
  } else {
    var username = "admin", password = "admin";
    if(req.body.username === username &amp;&amp; 
    req.body.password === password) {
      req.session.loggedIn = true;
      res.redirect('/');
    } else {
      res.render("login", {title: "Please log in."});
    }
  }  
}</pre></div><p class="calibre7">The valid credentials are set to <code class="email">admin/admin</code>. In a real application, we may need to access a database or get this information from another place. It's not really a good idea to place the username and password in the code; however, for our little experiment, it is fine. The previous code checks whether the passed data matches our predefined values. If everything is correct, it sets the session, after which the user is forwarded to the home page.</p><p class="calibre7">Once you log in, you should be able to log out. Let's add a link for that just after the content on the index page (<code class="email">views/index.jade</code>):</p><div class="informalexample"><pre class="programlisting">a(href='/logout') logout</pre></div><p class="calibre7">Once users clicks on this link, they will be forward to a new page. We just need to create a handler for the new route, remove the session, and forward them to the index page where the login form is reflected. Here is what our logging out handler looks like:</p><div class="informalexample"><pre class="programlisting">// in app.js
var logout = function(req, res, next) {
  req.session.loggedIn = false;
  res.redirect('/');
}
app.all('/logout', logout);</pre></div><p class="calibre7">Setting <code class="email">loggedIn</code> to <code class="email">false</code> is enough to <a id="id93" class="calibre1"/>make the session invalid. The redirect sends users to the same content page they came from. However, this time, the content is hidden and the login form pops up.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned about one of most widely used Node.js frameworks, Express. We discussed its fundamentals, how to set it up, and its main characteristics. The middleware architecture, which we mentioned in the previous chapter, is the base of the library and gives us the power to write complex but, at the same time, flexible applications. The example we used was a simple one. We required a valid session to provide page access. However, it illustrates the usage of the body parser middleware and the process of registering the new routes. We also updated the <code class="email">Jade</code> templates and saw the results in the browser.</p><p class="calibre7">The next chapter will show us how Node.js collaborated with AngularJS, a popular framework made by Google for client-side JavaScript applications.</p></div></body></html>