<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;MMO Word Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. MMO Word Game</h1></div></div></div><p>Word Chain Game is a real-time, massive multiplayer online game. Each player will be able to see the other online players when playing the game, along with a score leaderboard for score. In this chapter we will introduce the Promise pattern and explain how Promises simplify asynchronous operations. You will learn how to build a real-time application with Express and SocketIO, perform authentication over socket handshaking, and deal with race conditions using the atomic update of MongoDB. You will also learn how to build the game client to connect to the game server over socket, and how to debug WebSocket on the client side using Chrome Developer Tools.</p><p>Once you have mastered this, you can build similar games such as online quiz competitions.</p><div class="section" title="Gameplay"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Gameplay</h1></div></div></div><p>The game starts with a randomly selected English word and each player tries to submit a word where the first character of their submission matches the last character of the current word; we call this chaining with the current word. For example, if the game starts with the word <code class="literal">Today</code>, then players can send words such as <code class="literal">Yes</code> or <code class="literal">Yellow</code>.</p><p>The first person to submit a<a id="id136" class="indexterm"/> valid word will have their word become the starting word for the next round and gets the points for that round. Once the new word is accepted, the server will broadcast the change to all online players. The players will see the new word and submit another word to chain with it.</p><p>For example, if player 1 sends <code class="literal">Yes</code> to chain with <code class="literal">Today</code>, the server will accept the word and broadcast the current word <code class="literal">Yes</code> to all other players. If a player submits a word that is invalid based on the dictionary we have or was submitted by another player earlier, the game server will ignore that request. If multiple players submit valid words simultaneously, the server will only accept the first submitted word.</p><div class="mediaobject"><img src="graphics/0818_04_01.jpg" alt="Gameplay"/></div><div class="section" title="Real-time application overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Real-time application overview</h2></div></div></div><p>In this game, we will introduce<a id="id137" class="indexterm"/> the Promise pattern and explain how Promise will simplify async operations.</p><p>Despite this being a real-time game, we will not rush into implementing a real-time feature at the beginning. Instead, we will first build a game model, which contains all the game logic.</p><p>In the game logic, we first introduce how to keep track of active users and then explain how we verify users' input. After verifying the input, during the updating game state phase, we deal with race conditions by utilizing the atomic operation of MongoDB. We also look into how to cover the race conditions with test cases.</p><p>After the game logic is done, we will introduce how to broadcast game state changes to all players using Socket.IO.</p><p>In the end, we will create an Express app, a Socket.IO server, and a game client that can talk to our server using the <code class="literal">socket.io-client</code> libraries.</p></div><div class="section" title="Keeping track of active users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Keeping track of active users</h2></div></div></div><p>Since the game is a multiplayer game, players can see the number of players and their usernames. To keep<a id="id138" class="indexterm"/> track of active users, we need to track when a player joins the game and when a player leaves the game.</p></div></div></div>
<div class="section" title="Schema design"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Schema design</h1></div></div></div><p>Each player can simply be represented by a document with a single field for the name:</p><div class="informalexample"><pre class="programlisting">{ name: 'leo' }</pre></div><div class="section" title="User schema"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>User schema</h2></div></div></div><p>We will use Mongoose for our data modeling. Let's start with designing<a id="id139" class="indexterm"/> our user schema. The schemas are placed in the <code class="literal">models</code> folder in the app. The following screenshot shows the folder structure. The schema will have one required field <code class="literal">name</code>, this is done by adding <code class="literal">required: true</code> to the name object in the schema.</p><div class="mediaobject"><img src="graphics/0818_04_02.jpg" alt="User schema"/></div><p>To make querying a user by name fast, we can add an index to <code class="literal">name</code>. By default, only the <code class="literal">_id</code> field that MongoDB generates will be indexed. This means, to perform a search by name, the database will need to iterate over all the documents in the collection to find a matching name. When you add an index to <code class="literal">name</code>, you can query by name as quickly as when you query by <code class="literal">_id</code>. Now, when a user leaves, we can find the user by name directly and remove that user.</p><p>Also, we add the <code class="literal">unique : true</code> property to the index to avoid having multiple users with the same name, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var mongoose = require('mongoose');
var schema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    index: {
      unique: true
    }
  }
});


var User = mongoose.model('user', schema);
module.exports = User;
</pre></div></div><div class="section" title="User join"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>User join</h2></div></div></div><p>When a user joins a game, we create<a id="id140" class="indexterm"/> a user with the key <code class="literal">name</code> and save this user to MongoDB, as follows:</p><div class="informalexample"><pre class="programlisting">schema.statics.join = function(name, callback) {
  var user = new User({
    name: name
  });

  user.save(function(err, doc) {
    if (!callback) { return ; }
    if (err) { return callback(err); }

    callback(null, doc);
  });
};
</pre></div><p>The <code class="literal">save()</code> method in the preceding code uses callback patterns, which is also known as callback hell. If an error occurs, we make a call to the callback function passing the error as a parameter; otherwise, the operation succeeds and it returns the updated document.</p><p>The preceding callback pattern involves a lot of logic and condition checks. The nested callback pattern of JavaScript can quickly turn into a spaghetti nightmare. A good alternative is to use Promises to simplify things.</p><p>Mongoose's <code class="literal">model.create()</code> method (<a class="ulink" href="http://mongoosejs.com/docs/api.html#model_Model.create">http://mongoosejs.com/docs/api.html#model_Model.create</a>) can create and save a new document into the <a id="id141" class="indexterm"/>database if valid. Functions and documents such as objects and arrays are valid parameters for the <code class="literal">model.create()</code> method. The <code class="literal">create</code> method returns a Promise.</p><p>With this Promise, the caller of the <code class="literal">join</code> method can define the success and fail callbacks, simplifying the code:</p><div class="informalexample"><pre class="programlisting">schema.statics.join = function(name) {
  return User.create({
    name: name
  });
};
</pre></div></div></div>
<div class="section" title="Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Promises</h1></div></div></div><p>A Promise is the eventual<a id="id142" class="indexterm"/> result of an asynchronous operation, just like giving someone a promise. Promises help handle errors, which results in writing cleaner code without callbacks. Instead of passing in an additional function that takes an error and result as parameters to every function, you can simply call your function with its parameter and get a Promise:</p><div class="informalexample"><pre class="programlisting"> getUserinfo('leo', function(err, user){
   if (err) {
    // handle error
     onFail(err);
     return;
   }
  
  onSuccess(user);
 });
</pre></div><p>versus</p><div class="informalexample"><pre class="programlisting">var promiseUserInfo = getUserinfo('leo');

promiseUserInfo.then(function(user) {
  onSuccess(user);
});

promiseUserInfo.catch(function(error) {
  // code to handle error
  onFail(user);
});
</pre></div><p>The benefit of using Promises isn't obvious if<a id="id143" class="indexterm"/> there is only one async operation. If there are many async operations with one depending on another, the callback pattern will quickly turn into a deeply nested structure, while Promises can keep your code shallow and easier to read.</p><p>Promises can centralize your error handling and when an exception happens, you will get stack traces that reference actual function names instead of anonymous ones.</p><p>In our word game, you could use Promises to turn this:</p><div class="informalexample"><pre class="programlisting">var onJoinSuccess = function(user) {console.log('user', user.name, 'joined game!');
  return user;
};

var onJoinFail = function(err) {console.error('user fails to join, err', err);
};

User.join('leo', function(err, user) {if (err) {return onJoinFail(err);
  }

  onJoinSuccess(user);
});</pre></div><p>into this:</p><div class="informalexample"><pre class="programlisting">User.join('leo')
.then(function(user) {onJoinSuccess(user);})
.catch(function(err) {onJoinFail(err);
});</pre></div><p>or even simplier:</p><div class="informalexample"><pre class="programlisting">User.join('leo')
.then(onJoinSuccess)
.catch(onJoinFail);</pre></div><p>To understand the <a id="id144" class="indexterm"/>execution flow of the preceding, let's create a complete example that calls the user model's <code class="literal">join()</code> method, and then add some log statements to see the output:</p><div class="informalexample"><pre class="programlisting">var User = require('../app/models/user.js');
var db = require('../db');

var onJoinSuccess = function(user) {
  console.log('user', user.name, 'joined game!');
  return user;
};

var onJoinFail = function(err) {
  console.error('user fails to join, err', err);
};

console.log('Before leo send req to join game');

User.join('leo')
.then(onJoinSuccess)
.catch(onJoinFail);

console.log('After leo send req to join game');</pre></div><p>If a user joins the game successfully, the Promise returned by the <code class="literal">User.join()</code> method will be resolved. A <a id="id145" class="indexterm"/>newly created user document object will be passed to the <code class="literal">onJoinSuccess</code> callback and the output result will be printed as follows:</p><div class="mediaobject"><img src="graphics/0818_04_03.jpg" alt="Promises"/></div><p>If we run this script again, we will see that the user fails to join the game and the error is printed. It fails because the user model already has an index on name property because a user with the name <code class="literal">leo</code> was created when we ran the script the first time. When we run it again, we can't create another user with the same name <code class="literal">leo</code>, so the Promise fails and the error is passed into <code class="literal">onJoinFail</code>.</p><div class="mediaobject"><img src="graphics/0818_04_04.jpg" alt="Promises"/></div><p>A Promise has three states: pending, fulfilled, or rejected; a Promise's initial state is pending, then it Promises that it will either succeed (fulfilled) or fail (rejected). Once it is fulfilled or rejected, it cannot change again. A major benefit of this is that you can chain multiple Promises<a id="id146" class="indexterm"/> together and define one error handler to handle all the errors.</p><p>As the <code class="literal">join()</code> method returns a Promise, we can define the success and fail callbacks as follows.</p><div class="section" title="The then and catch method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>The then and catch method</h2></div></div></div><p>The <code class="literal">then</code> <a id="id147" class="indexterm"/>and <code class="literal">catch</code> methods are<a id="id148" class="indexterm"/> used to define success and fail callbacks; you <a id="id149" class="indexterm"/>might wonder when they are actually being called. When the <code class="literal">User.create()</code> method is called, it will return a Promise object and at the same time send an async query to MongoDB. The success<a id="id150" class="indexterm"/> callback, <code class="literal">onJoinSuccess</code>, is then passed into the <code class="literal">then</code> method and will be called when the async query is successfully completed, resolving the Promise.</p><p>Once the Promise is resolved, it can't be resolved again, so <code class="literal">onJoinSuccess</code> won't be called again, it will only be called once at the most.</p></div><div class="section" title="Chain multiple Promises"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Chain multiple Promises</h2></div></div></div><p>You can chain Promise<a id="id151" class="indexterm"/> operations by calling them on the Promise that is returned by the previous <code class="literal">then()</code> function. We use the <code class="literal">.then()</code> method when we want to do something with the result from the Promise (once <span class="emphasis"><em>x</em></span> resolves, then do <span class="emphasis"><em>y</em></span>) as follows:</p><div class="informalexample"><pre class="programlisting">var User = require('../app/models/user.js');
var db = require('../db');

var onJoinSuccess = function(user) {
  console.log('user', user.name, 'joined game!');
  return user;
};

var onJoinFail = function(err) {
  console.error('user fails to join, err', err);
};

console.log('Before leo send req to join game');
User.join('leo')
.then(onJoinSuccess)
.then(function(user) {
  return User.findAllUsers();
})
.then(function(allUsers) {
  return JSON.stringify(allUsers);
})
.then(function(val) {
  console.log('all users json string:', val);
})
.catch(onJoinFail);

console.log('After leo send req to join game');</pre></div><p>We can centralize the<a id="id152" class="indexterm"/> error handling at the end. It's much easier to deal with errors with Promise chains. If we run the code, we will get the following result:</p><div class="mediaobject"><img src="graphics/0818_04_05.jpg" alt="Chain multiple Promises"/></div><p>Now that we've gone through all the logic and error handling of creating a new user, let's look into how we will ensure that multiple users with the same name can't join.</p></div><div class="section" title="Prevent duplicates"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Prevent duplicates</h2></div></div></div><p>Earlier, when we defined <a id="id153" class="indexterm"/>our user schema, we added <code class="literal">index</code> with a unique set to <code class="literal">true</code> on the name field:</p><div class="informalexample"><pre class="programlisting">var schema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    index: {
      unique: true
    }
  }
});
</pre></div><p>MongoDB will issue a query to see whether there is another record with the same value for the unique property and, if that query comes back empty, it allows the save or update to proceed. If another user joins with the same name, Mongo throws the error: Duplicate Key Error. This prevents the user from being saved and the player must choose another name to join with.</p><p>To make sure our <a id="id154" class="indexterm"/>code works as we want it to, we need to create tests; we will create a test case with Mocha. The test case will pass a username to the <code class="literal">User.join</code> method and expect that the username of the newly created user is valid. The <code class="literal">User.join</code> method returns a Promise. If it succeeds, the object returned from the Promise will be sent to the <code class="literal">then</code> method; otherwise it fails and the Promise will <code class="literal">.reject</code> with an error that will be caught by the <code class="literal">catch</code> method.</p><p>In the case of the success callback, we have the newly created user, and we can check whether it's correct by expecting <code class="literal">user.name</code> to return <code class="literal">leo</code>, since <code class="literal">leo</code> was entered as the username (illustrated in the following code).</p><p>In the case of fail callback, we can pass the error object to Mocha, <code class="literal">done(error)</code>, to fail the test case. Since we created a user named <code class="literal">leo</code> for the first time, we expect this test to pass. Since Mocha tests are synchronous and Promises are async, we need to wait for the function to be done. When the code is successful, it will call the <code class="literal">done()</code> function and report success to Mocha; if it fails, the <code class="literal">catch</code> method will catch the error and return the error to the <code class="literal">done</code> method, which will tell Mocha to fail the test case.</p><div class="informalexample"><pre class="programlisting">var User = require('../../app/models/user');

  describe('when leo joins', function() {
    it('should return leo', function(done) {
      User.join('leo')

        .then(function(user) {
          expect(user.name).to.equal('leo');
          done();
        })
        .catch(function(error) {
          done(error);
        });
    });
  });
</pre></div><p>Version 1.18.0 or above of Mocha allows you to return a Promise in a test case. Mocha will fail the test case if the Promise fails without needing to explicitly catch the error as given in the following:</p><div class="informalexample"><pre class="programlisting">  describe('when leo joins', function() {
    it('should return leo', function() {
      return User.join('leo')
        .then(function(user) {
          expect(user.name).to.equal('leo');
        });
    });
  });
</pre></div><p>Now that we tested that submitting the first user with a unique name works, we want to test what happens when <a id="id155" class="indexterm"/>another user with the same name joins:</p><div class="informalexample"><pre class="programlisting"> describe('when another leo joins', function() {
    it('should be rejected', function() {
      return User.join('leo')
        .then(function() {
          throw new Error('should return Error');
        })
        .catch(function(err) {
          expect(err.code).to.equal(11000);
          return true;
        });
    });
  });
</pre></div><p>When we submit <code class="literal">leo</code> again as a username, the Promise of <code class="literal">Game.join</code> comes back rejected and goes to the <code class="literal">.catch</code> method. The <code class="literal">return true</code> turns a failed Promise into a success, which tells us that it succeeded in rejecting the second <code class="literal">leo</code> and that we successfully caught the error; we basically swallow the error to tell Mocha that this is the correct behavior we expect.</p></div><div class="section" title="User leaves the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>User leaves the game</h2></div></div></div><p>When a user leaves<a id="id156" class="indexterm"/> the game, we need to remove their entry in the database; this would also free up their user name so that a new user can take it. Mongoose has a <code class="literal">delete</code> method called <code class="literal">findOneAndRemove</code>, which can find that player by name, and then remove it as shown in the following code.</p><p>For our Promises, we use<a id="id157" class="indexterm"/> Bluebird (<a class="ulink" href="https://github.com/petkaantonov/bluebird">https://github.com/petkaantonov/bluebird</a>) (spec: PromiseA) because of its better performance, utility, and popularity (support).</p><p>We call the <code class="literal">Promise.resolve</code> method, which creates a Promise that is resolved with the value inside: <code class="literal">Promise.resolve(value)</code>. Therefore, we can take a method that does not normally return a Promise and wrap it with the Bluebird <code class="literal">Promise.resolve</code> method to get a Promise back, which we can then chain with then if it succeeds or catch if it fails. Receiving Promises from our methods will ensure that we deal with successes and errors efficiently and also lets the callee deal with the error when it runs (.exec()).</p><div class="informalexample"><pre class="programlisting">schema.statics.leave = function(name) {
  return Promise.resolve(this.findOneAndRemove({name: name
  })
  .exec());
};</pre></div></div><div class="section" title="Show all active users"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Show all active users</h2></div></div></div><p>So far we demonstrated how to add and remove users, we will now dive into how we will display the game data to a<a id="id158" class="indexterm"/> user that's joined. To show the total active users, we could simply return all users, as offline users have already been removed. In order to return an array of just the user names, rather than an array of the entire user object, we could use the <code class="literal">Promise.map()</code> method to convert each user object in the array into a user name.</p><p>Since <code class="literal">User.find</code> returns an array of users, we use the <a id="id159" class="indexterm"/>
<code class="literal">Promise.map()</code>method to return the values from the name key. This effectively turns the array of user objects into an array of user names. Again, notice that we use the <code class="literal">promise.resolve()</code>method to obtain a Promise from our input. This will allow us to display a list of the currently logged in users by their user name.</p><div class="informalexample"><pre class="programlisting">schema.statics.findAllUsers = function() {
  return Promise.resolve(User.find({}).exec())
    .map(function(user) {
      return user.name;
    });
};
</pre></div></div><div class="section" title="The words – Subdocuments"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>The words – Subdocuments</h2></div></div></div><p>We have gone through the <a id="id160" class="indexterm"/>game logic involving creating, displaying, and deleting users but what about the meat of the game itself—the words?</p><p>In <code class="literal">app/models/stat.js</code>, we see how we model our word data. The <code class="literal">word</code> field shows the current word, and the <code class="literal">used</code> field saves the game's history.</p><p>We embedded the <code class="literal">used</code> list as subdocuments into the Stat document, so that we can update stats atomically. We will explain this later.</p><div class="informalexample"><pre class="programlisting">{
  'word': 'what',
  'used': [
    { 'user': 'admin', 'word': 'what' },
    { 'user': 'player1', 'word': 'tomorrow' },
    { 'user': 'player2', 'word': 'when' },
    { 'user': 'player2', 'word': 'nice' },
    { 'user': 'player1', 'word': 'egg' },
  ]
}
</pre></div><p>The preceding code gives you an overview of what we will store in the database.</p><p>We first create a model for our word inputs, new word (word) and used words (used), in a similar method to our user's model, by defining a type (string for new and array for old). The old words are<a id="id161" class="indexterm"/> stored in an array so that they can be accessed when we check whether or not a new word has been used before.</p><div class="informalexample"><pre class="programlisting">var schema = new mongoose.Schema({word: {type: String,required: true},
  used: {type: Array
  },
});</pre></div><p>Further logic about validating word inputs and scoring will be described after we create a new game.</p><p>When we create a new game, we want to make sure that no old game data exists and that all values in our database are reset, so we will first remove the existing game, and then create a new one, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">schema.statics.newGame = function() {return Promise.resolve(Stat.remove().exec())
  .then(function() {return Stat.create({word: 'what',used: [{word: 'what',user: 'admin'}]
    });
  });
};</pre></div><p>In the preceding example, we use <code class="literal">Stat.remove()</code> to remove all old game data and when the Promise is fulfilled, we create a new game using <code class="literal">Stat.create()</code> by passing a new word, <code class="literal">'what'</code>, to start off the new round and also submit both the word and the user who submitted the word into the used array. We want to submit the user in addition to the word so that other users can see who submitted the current word and also use that information to calculate scores.</p></div><div class="section" title="Validate input"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Validate input</h2></div></div></div><p>We can't just accept any word a user might input; users might enter an invalid word (as determined by our internal dictionary), a word that can't chain with the current word or a word that has already been used before in this game.</p><p>Our internal dictionary <a id="id162" class="indexterm"/>model is found in <code class="literal">models/dictionary.js</code> and consists of the dictionary <code class="literal">json</code>. Requests with an invalid word should be ignored and should not change the game's state (see <code class="literal">app/controllers/game.js</code>); if the word is not in the dictionary, the Promise will be rejected and will not go to <code class="literal">Stat.chain()</code>.</p><p>In the following code example, we illustrate how to check whether the submitted word chains with the current word:</p><div class="informalexample"><pre class="programlisting">schema.statics.chain = function(word, user) {var first = word.substr(0, 1).toLowerCase();

  return Promise.resolve(Stat.findOne({}).exec())
  .then(function(stat) {var currentWord = stat.word;
    if (currentWord.substr(-1) !== first) {throw Helper.build400Error('not match');
    }

    return currentWord;
  })
  .then(function(currentWord ) {return Promise.resolve(Stat.findOneAndUpdate({word: currentWord,}, {$push: {used: { 'word': word, 'user': user }}
    }, {upsert: false}).exec();
  });
});</pre></div><p>The first step is to query the <code class="literal">Stat</code> collection to get the current game state. From the game state, we know the current word that needs to be matched by calling <code class="literal">stat.word</code> and assigning it to the variable <code class="literal">currentWord</code>.</p><p>We then compare the current word with the user's input. First we determine the first letter of the submitted word using <code class="literal">calling substr(0, 1)</code> and then we compare it to the last letter of the current word (<code class="literal">currentWord</code> ) by calling <code class="literal">substr(-1)</code>. If the first character of the user's input doesn't match with the last character of the current word of the game, we throw a <code class="literal">400</code> error. The Promise will catch this error, and call the <code class="literal">catch</code> callback to handle the error.</p><p>Here, in the model's method, we let the model object return a <code class="literal">Promise</code> object. Later on, we will introduce how to<a id="id163" class="indexterm"/> catch this error in the controller's method and return a <code class="literal">400</code> response to the user.</p><div class="informalexample"><pre class="programlisting">throw Helper.build400Error('not match');
</pre></div><p>The <code class="literal">Helper.build400Error()</code> function is a utility function that returns a <code class="literal">400</code> Error with an error message:</p><div class="informalexample"><pre class="programlisting">
exports.build400Error = function(message) {var error = new Error(message);
  error.status = 400;
  return error;
};</pre></div><p>If the word can chain with the current word, it's a valid request. We will get back a successful Promise, which allows us to chain with the next then and save the word along with the player's username to the database.</p><p>To save the data into the database, we use Mongoose's <code class="literal">findOneAndUpdate</code> method, which takes three arguments. The first is a query object to find the document to be updated. We find the stat document where the word is <code class="literal">currentWord</code> we get from <code class="literal">Stat.findOnequery</code>. The second argument is the <code class="literal">update</code> object. This defines what to update.</p><p>We use Mongo's modifier <code class="literal">$push</code> to push a word chain history into the <code class="literal">used</code> field, which is an array. The last argument is options.</p><p>We use the <code class="literal">{ upsert: false }</code> option, which means if we can't find the document with the query defined in the first argument, we won't update or insert a new document. This makes sure no other operation occurs in between the time it takes to find the document and update the document, that is, we don't insert a new word if the current word cannot be found. Therefore, the game status doesn't change because the current word is assigned to <code class="literal">word</code> and is still the same.</p><p>If we successfully find the word, we add a new used word object to the used word array consisting of the new valid word and the username that submitted it.</p><div class="informalexample"><pre class="programlisting">Stat.findOneAndUpdate({word: currentWord,}, {$push: {used: { 'word': word, 'user': user }
  }
}, {upsert: false
}).exec();</pre></div></div><div class="section" title="Dealing with race conditions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Dealing with race conditions</h2></div></div></div><p>You might have questions about the preceding code. Finding a document and updating a document seem like two<a id="id164" class="indexterm"/> separate operations; what if two users send the same request? It may cause a race condition.</p><p>For example, if the current word is <code class="literal">Today</code>, Player 1 submits <code class="literal">yes</code>, and Player 2 submits <code class="literal">yellow</code>; both players chain a valid word. While both these words are valid, we can't accept both of them for two reasons; only one player can win each round, and if we had two or more winning words, the words could end with different letters, which would affect the next word chain. </p><p>If <code class="literal">yes</code> arrives at the server first and gets accepted, then the next word should start with an <code class="literal">s</code>, and <code class="literal">yellow</code> from Player 2 should become invalid and be rejected. This is called a race condition.</p><p>How do we solve this? We need to combine the two database operations, finding a document and updating a document, into one operation. We could use Mongoose model's <code class="literal">findOneAndUpdate</code> method. This method will actually call the <code class="literal">findAndModify</code> method of MongoDB, which is an isolated update and return operation. Since it becomes one database operation, MongoDB will update the document atomically.</p><div class="informalexample"><pre class="programlisting">schema.statics.chain = function(word, user) {var first = word.substr(0, 1);

  return Promise.resolve(Stat.findOne({}).exec())
  .then(function(stat) {var currentWord = stat.word;

    if (currentWord.substr(-1).toLowerCase() !== first.toLowerCase()) {throw Helper.build400Error('not match');
    }

    return currentWord;
  })
  .then(function(currentWord) {return Promise.resolve(Stat.findOneAndUpdate({word: currentWord,'used.word': { $ne: word }
    }, {word: word,$push: {used: { 'word': word, 'user': user }}
    }, {upsert: false,
    })
    .exec());
  })
  .then(function(result) {if (!result) {throw Helper.build404Error('not found');
    }

    return result;
  });
};</pre></div><p>When a user submits a word, we first query the current game state, when the Promise is resolved and successful, and then check that the first letter of our submitted word (first) and last letter of the<a id="id165" class="indexterm"/> current word (currentWord) are the same.</p><p>If they are the same, we call <code class="literal">findOneAndUpdate()</code> to search for the submitted word and make sure that it is not present in the array of previously used words. <code class="literal">used.word: { $ne: word }</code> then returns a Promise object.</p><p>If the Promise comes back fulfilled, then we push the submitted word and user to the used words array.</p><p>If the Promise is rejected and/or the conditions are not satisfied, then no data will be pushed into the array (<code class="literal">upsert: false</code>).</p><p>The last <code class="literal">then</code> statement returns the new result; if none was returned, then the <code class="literal">not found</code> error will be thrown.</p></div><div class="section" title="Test case to test race conditions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Test case to test race conditions</h2></div></div></div><p>Now that we implemented the logic, we want to<a id="id166" class="indexterm"/> test it out. The test case is shown as follows:</p><div class="informalexample"><pre class="programlisting"> describe('when player1 and player2 send different valid word together', function() {it('should accept player1\'s word, and reject player2\'s word', function(done) {Game.chain('geoffrey', 'hello')
        .then(function(state) {expect(state.used.length).to.equal(4);
          expect(state.used[3].word).to.equal('hello');
          expect(state.used[3].user).to.equal('geoffrey');

          expect(state.word).to.equal('hello');
        });

      Game.chain('marc', 'helium')
        .then(function(state) {done(new Error('should return Error'));
        })
        .catch(function(err) {expect(err.status).to.equal(400);
          done();
        });

    });
  });</pre></div><p>As the word by player 1 goes in first, the <code class="literal">hello</code> word by player 1 should increase the length of the used array to <code class="literal">4</code>, the current word position in the array should be equal to <code class="literal">hello</code>, and the<a id="id167" class="indexterm"/> successful user who submitted it should be updated to be <code class="literal">geoffrey</code>.</p><p>When marc submits a word beginning with <code class="literal">h</code>, it should return an error because the last letter of the current word, <code class="literal">hello</code>, is <code class="literal">o</code> and helium does not begin with <code class="literal">o</code>.</p></div></div>
<div class="section" title="Socket.IO"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Socket.IO</h1></div></div></div><p>We can send information to our servers when we submit user info or words but how do we get the server to update us without requesting updates manually? We use Socket.IO to enable real-time two-way event-based communication. Documentation<a id="id168" class="indexterm"/> for Socket.IO is available at <code class="literal">socket.io/docs</code>. We install it by executing the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save socket.io</strong></span>
</pre></div><div class="section" title="Socket handshaking, user join"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Socket handshaking, user join</h2></div></div></div><p>First, we require <code class="literal">socket.io</code> and our game in <code class="literal">socket.js</code>:</p><div class="informalexample"><pre class="programlisting">var socketIO = require('socket.io');
var Game = require('./app/controllers/game');</pre></div><p>Authorization takes place during handshaking, which is when the socket connection is established. Without handshaking, we would not know which socket connection belongs to which Express session. As given in the following code:</p><div class="informalexample"><pre class="programlisting">module.exports = function(server) {
  var io = socketIO(server, {transports: ['websocket']});

  io.use(function(socket, next) {var handshakeData = socket.request;
    console.log('socket handshaking', handshakeData._query.username);
    socket.user = handshakeData._query.username;

    Game.join(socket.user)
    .then(function(users) {console.log('game joined successfully', socket.user);
      socket.broadcast.emit('join', users);
      next();
    })
    .catch(function(err) {console.log('game joined fail', socket.user);
      next(err);
    });
  });

};</pre></div><p>The <code class="literal">io.use()</code> method lets you give the Socket.IO server functions to run after a socket is created.</p><p>The request sent from the client (consisting of a URL and name) will be stored in <code class="literal">handshakeData</code>. The console will output the username and make sure that the sockets are handshaking.</p><p>Next, it will assign the username to <code class="literal">socket.user</code> so that it can be passed in to the <code class="literal">join()</code> function. The socket will call the <code class="literal">Game.join()</code> function and if the user is able to join, a console message will be displayed with the message <code class="literal">game joined successfully</code> and the name of the user.</p><p>The <code class="literal">Socket.broadcast.emit</code> method sends the message to all other clients except the newly created connection telling them that a new user has joined.</p><p>If the user was not successfully created (that is, there were two users with the same name) the error will be sent to the <code class="literal">catch</code> method and the console will log that the user was not able to join the game. Then, <code class="literal">next(err)</code> will send the error message back to the connecting client, so that on the client side we can show a pop-up message telling the user that the name is being used.</p></div><div class="section" title="Adding and pushing updates to clients"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Adding and pushing updates to clients</h2></div></div></div><p>With Socket.IO, you <a id="id169" class="indexterm"/>can send and receive any events you want as well as any data you want in the JSON format.</p><p>There are three additional<a id="id170" class="indexterm"/> socket events (after connecting) that we're going to need for our game: disconnect, chain (chain new word to last), and game status.</p><p>In <code class="literal">socket.js</code>, add these three socket events:</p><div class="informalexample"><pre class="programlisting"> io.sockets.on('connection', function(socket) {console.log('client connected via socket', socket.user);

    socket.on('disconnect', function() {console.log('socket user', socket.user, 'leave');
      Game.leave(socket.user)
      .then(function(users) {socket.broadcast.emit('leave', users);
      });
    });

    socket.on('chain', function(word, responseFunc) {console.log('socket chain', word);
      Game.chain(socket.user, word)
      .then(function(stat) {console.log('successful to chain', stat);
        if (responseFunc) {responseFunc({status: 200,
            resp: stat
          });
        }
        console.log('broadcasting from', socket.user, stat);
        socket.broadcast.emit('stat', stat);
      })
      .catch(function(err) {console.log('fail to chain', err);
        if (responseFunc) {responseFunc(err);
        }
      });
    });

    socket.on('game', function(query, responseFunc) {console.log('socket stat', socket.user);
      Game.state()
      .then(function(game) {console.log('socket stat end', game);
        if (responseFunc) {responseFunc(game);
        }
      });
    });

    socket.on('error', function(err) {console.error('error', err);
    });
  });</pre></div><p>The first socket event <code class="literal">connection</code> we subscribe to will be triggered when a user establishes a socket connection with the server. Once a client is connected, we log that event and display their name on to the console so that we know who is connected.</p><p>The second <a id="id171" class="indexterm"/>event <code class="literal">disconnect</code> will be triggered when users are disconnected from the server. It happens when they leave the game or the network connection is broken. Once this event is triggered, we broadcast to all other sockets that the user has left (via <code class="literal">socket.broadcast.emit</code>) so that the other users can see that the disconnected user is no longer in the list of active players.</p><p>The last two socket events, chain and game, are game actions.</p><p>The chain takes in the<a id="id172" class="indexterm"/> user's submitted word and calls the <code class="literal">Game.chain()</code> function; if it succeeds, then it logs that the chain was successful and broadcasts the status to all other users.</p><p>The <code class="literal">game</code> responds with the latest game status.</p></div><div class="section" title="Launch Socket.IO applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Launch Socket.IO applications</h2></div></div></div><p>To launch our<a id="id173" class="indexterm"/> game, let's create a launch script called <code class="literal">www</code>, and place it <a id="id174" class="indexterm"/>under the <code class="literal">bin</code> folder. This is our code for <code class="literal">./bin/www</code> as given in the following:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env node
var app = require('../app');
var socket = require('../socket');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {console.log('Express server listening on port ' + server.address().port);
});
socket(server);</pre></div><p>The first line tells shell which interpreter should be used to execute this script. Here, we tell shell that the interpreter is node. Then, we can launch the server locally with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>./bin/www</strong></span>
</pre></div><p>Next, in <code class="literal">bin/www</code>, we will set up an Express application listening on a port, which is defined in the environment variable or <code class="literal">3000</code> if nothing is there.</p><p>We then bind socket to our HTTP server, which is created by our Express application. Since the Socket.IO server needs to be attached to an HTTP server, we pass the server object to the socket function, where we initialize the socket server.</p><p>So now we have the launch script in place. If we launch the server locally, we will see the following message printed to the console:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ ./bin/www</strong></span>
<span class="strong"><strong>connecting db...</strong></span>
<span class="strong"><strong>Express server listening on port 3000</strong></span>
<span class="strong"><strong>db connected</strong></span>
</pre></div></div><div class="section" title="Test Socket.IO applications with the Socket.IO client"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Test Socket.IO applications with the Socket.IO client</h2></div></div></div><p>We will write the<a id="id175" class="indexterm"/> JavaScript for the client-side frontend application, which we will test our game with.</p><p>You can find the<a id="id176" class="indexterm"/> JavaScript file under <code class="literal">public/javascripts/app.js</code> and the view in <code class="literal">app/views/index.jade</code>. We will not be covering frontend components such as <code class="literal">jade</code> and <code class="literal">stylus/css</code> in this book.</p><p>We begin by setting up our game with all our variables, which are classes in the <code class="literal">index.jade</code> file that we will refer to. We also initialize our game with the <code class="literal">init()</code> function, which will be described in the next code block:</p><div class="informalexample"><pre class="programlisting">$(function() {var game = new Game({$viewLogin: $('.view-login'),$viewGame: $('.view-game'),$username: $('.username'),$wordInput: $('.word-input'),$word: $('.word'),$bywho: $('.bywho'),$users: $('.users'),});
});

var Game = function(views) {this.views = views;

  this.init();
};</pre></div><p>The <code class="literal">Game.prototype</code> adds functions to our <code class="literal">Game</code> method in <code class="literal">app/controllers/game.js</code>. We will break this up into several smaller code blocks to show the client-side logic that we're working with.</p><p>The <code class="literal">init()</code> function begins by bringing the username input box into focus, and then when the submit button is pressed, obtain the value of the user input and assign it to the variable <code class="literal">username</code>.</p><p>We then send the user name to the <code class="literal">join()</code> function listed as follows, in the next code block.</p><p>We also set up a function that will take the input from the submit button for <code class="literal">chain</code> (which is where you input the word you would like to chain with the current word), store it in the chain variable, and then send it to the chain function (discussed later) and clear out the text input box.</p><div class="informalexample"><pre class="programlisting">Game.prototype = {init: function() {var me = this;

    this.views.$username.focus();

    this.views.$viewLogin.submit(function() {var username = me.views.$username.val();me.join(username);
      return false;
    });

    this.views.$viewGame.submit(function() {var word = me.views.$wordInput.val();
      me.chain(word);
      me.views.$chain.val('');
      return false;
    });
  };</pre></div><p>The<a id="id177" class="indexterm"/> login UI will<a id="id178" class="indexterm"/> look like this:</p><div class="mediaobject"><img src="graphics/0818_04_06.jpg" alt="Test Socket.IO applications with the Socket.IO client"/></div><p>When a user submits a user name, it is passed on to the <code class="literal">join</code> function, which first establishes a socket connection and then calls <code class="literal">User.join()</code> (covered earlier) on the server (<code class="literal">game.js</code>) and initializes <a id="id179" class="indexterm"/>a socket handshake (with the configuration to only use WebSocket as the transport) with the submitted username and a URL that consists of <code class="literal">/?username= + username</code>.</p><p>When the connection<a id="id180" class="indexterm"/> is established, the socket emits the game status and users list (<code class="literal">updateStat()</code> and <code class="literal">updateUsers()</code> functions, which we will discuss later) and calls the <code class="literal">showGameView()</code> function.</p><p>The <code class="literal">showGameView()</code> function (see the following code block) hides the login form, displays the view-game form where you can input a <code class="literal">word</code> to chain, and focuses on the chain input box.</p><div class="informalexample"><pre class="programlisting"> join: function(username) {var socket = io.connect('/?username=' + username, {transports: ['websocket'],
    });

    this.socket = socket;

    var me = this;
    this.socket.on('connect', function() {console.log('connect');
      me.socket.emit('game', null, function(game) {console.log('stat', game);
        me.updateStat(game.stat);
        me.updateUsers(game.users);
      });

      me.showGameView();
    });

    this.socket.on('join', function(users) {me.updateUsers(users);
    });

    this.socket.on('leave', function(users) {me.updateUsers(users);
    });

    this.socket.on('stat', function(stat) {me.updateStat(stat);
    });
  },

  showGameView: function() {this.views.$viewLogin.hide();
    this.views.$viewGame.show();
    this.views.$wordInput.focus();
  },</pre></div><p>When a<a id="id181" class="indexterm"/> user joins or leaves the game, it's passed to<a id="id182" class="indexterm"/> the socket server (<code class="literal">game.js</code>) <code class="literal">join</code> or <code class="literal">leave</code> functions, and the client-side <code class="literal">updateUsers()</code> function is called.</p><p>The <code class="literal">updateUsers()</code> function takes the array of users that was returned by the server and maps it to get the usernames that are displayed as a list.</p><p>Similarly, when a stat call is made to the server, <code class="literal">updateStat()</code> method gets called, which receives the current word (<code class="literal">stat.word</code>) from the server and displays it.</p><p>Additionally, the input box will contain the last letter of that word as a placeholder and the user who submitted the current word will be displayed by accessing the user array and popping out the last user.</p><div class="informalexample"><pre class="programlisting">  updateStat: function(stat) {this.views.$word.html(stat.word);

    this.views.$wordInput.attr('placeholder', stat.word.substr(-1));
    this.views.$bywho.html('current word updated by: ' + stat.used.pop().user);
  },

  updateUsers: function(users) {this.views.$users.html(users.map(function(user) {return '&lt;li&gt;' + user + '&lt;/li&gt;';
    }).join(''));
  },</pre></div><p>The <code class="literal">chain</code> function given in the following alerts a user if they try to submit without entering a word; it then<a id="id183" class="indexterm"/> sends a call to the server's <code class="literal">chain</code> function, the input word, and the callback function, which will output the<a id="id184" class="indexterm"/> data received from the server (which is the response word and used array).</p><p>Looking in the server's socket code (socket.js line 47), if a callback is present, and the function was successful, then a status of <code class="literal">200</code> is sent back.</p><p>If the client side receives a status of <code class="literal">200</code>, then it will call the <code class="literal">updateStat()</code> function with <code class="literal">data.resp</code>, which is the stat object containing the word and used words; otherwise, if no data was received from the server or the chain was unsuccessful and a status code that is not <code class="literal">200</code> is sent back, the user will see an alert telling them that their input word doesn't chain with the current word.</p><div class="informalexample"><pre class="programlisting"> chain: function(word) {if (!word) {return alert('Please input a word');
    }

    var me = this;
    this.socket.emit('chain', word, function(data) {console.log('chain', data);
      if (!data || data.status !== 200) {return alert('Your word "' + word + ' can\'t chain with current word.');
      }

      me.updateStat(data.resp);
    });
  }
};</pre></div><div class="mediaobject"><img src="graphics/0818_04_07.jpg" alt="Test Socket.IO applications with the Socket.IO client"/></div></div><div class="section" title="Debug Socket.IO with Chrome Developer Tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Debug Socket.IO with Chrome Developer Tools</h2></div></div></div><p>To debug Socket.IO, we want to know what socket request we send to our server, what the request <a id="id185" class="indexterm"/>arguments are, and what the broadcast messages look like. Chrome has a built-in powerful WebSocket debugging tool; let's see<a id="id186" class="indexterm"/> how to use it.</p><p>To open Chrome Developer Tools, go to the menu, select <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Developer</strong></span> | <span class="strong"><strong>Developer Tools</strong></span>. You can also right click on the page, and select <span class="strong"><strong>Inspect Element</strong></span>.</p><p>From the Developer tools, select the <span class="strong"><strong>Network</strong></span> panel.</p><div class="mediaobject"><img src="graphics/0818_04_08.jpg" alt="Debug Socket.IO with Chrome Developer Tools"/></div><p>Now when we go back to the page and join the game, we will see a Socket.IO request in the <span class="strong"><strong>Network</strong></span> panel of the Chrome Developer Tools. The request URL is <code class="literal">ws://127.0.01:3000/socket.io/?username=marc&amp;EIO=2&amp;transport=websocket</code> and <span class="strong"><strong>Status Code is 101 Switching Protocols</strong></span>, meaning we passed the handshaking and established a socket<a id="id187" class="indexterm"/> connection with the <a id="id188" class="indexterm"/>server.</p><p>Now, click on the <span class="strong"><strong>Frames</strong></span> tab on the right-hand side panel. We will see some messages there in the table. The white rows are the messages our client sent to the server and the green rows are the messages that the server sent to the client.</p><div class="mediaobject"><img src="graphics/0818_04_09.jpg" alt="Debug Socket.IO with Chrome Developer Tools"/></div><p>Let's take a look at each row and understand what happened in the game.</p><p>
<span class="strong"><strong>0{"sid":"XNhi9CiZ-rbgbS5VAAAC","upgrades":[],"pingInterval":25000,"pingTimeout":60000}:</strong></span>. After the connection<a id="id189" class="indexterm"/> is established, the<a id="id190" class="indexterm"/> server returned some configuration to the client such as the socket session id (sid), pingInterval, and pingTimeout.</p><p>
<span class="strong"><strong>420["game",null]:</strong></span> The client sent a socket request to get the latest game status.</p><p>
<span class="strong"><strong>430[{"users":["leo"],"stat":{"word":"what","_id":"54cec37c0ffeb2cca1778ae6","__v":0,"used":[{"word":"what","user":"admin"}]}}]</strong></span>: The server responded with the latest game status, which shows that the current word is <span class="strong"><strong>what</strong></span>.</p><p>
<span class="strong"><strong>421["chain","tomorrow"]:</strong></span> The client sent a request to chain the current word <span class="strong"><strong>what</strong></span> with <span class="strong"><strong>tomorrow</strong></span>.</p><p>
<span class="strong"><strong>431[{"status":200,"resp":{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"tomorrow","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"}]}}]</strong></span>: The server <a id="id191" class="indexterm"/>accepted the request and returned the updated game status. So now, the current word is <span class="strong"><strong>tomorrow</strong></span>
</p><p>
<span class="strong"><strong>42["join",["leo","marc"]]</strong></span>: marc joined the game. Now we have leo and marc in the game.</p><p>
<span class="strong"><strong>42["stat",{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"we","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"},{"user":"marc","word":"we"}]}]</strong></span>: Here <span class="strong"><strong>marc</strong></span> chained the current word <span class="strong"><strong>tomorrow</strong></span> with <span class="strong"><strong>we</strong></span>. So the server pushed the game<a id="id192" class="indexterm"/> status to the client.</p><p>
<span class="strong"><strong>42["join",["leo","marc","geoffrey"]]:</strong></span> <span class="strong"><strong>geoffrey</strong></span> joined the game. Now we have three players in the game: <span class="strong"><strong>leo</strong></span>, <span class="strong"><strong>marc</strong></span>, and <span class="strong"><strong>geoffrey</strong></span>.</p><p>
<span class="strong"><strong>42["leave",["leo","geoffrey"]]:</strong></span> <span class="strong"><strong>marc</strong></span> left the game, <span class="strong"><strong>leo</strong></span> and <span class="strong"><strong>geoffrey</strong></span> are still in the game.</p><p>Now you've had a chance to actually test the game developed for this app and can see how the different aspects intertwine.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>We created an Express app, a Socket.IO server, and a game client that can talk to our server using the <code class="literal">socket.io-client</code> library, and receive the push updates from our server. We've also gone through the user creation and word chaining logic so that we can validate new users and words to be chained. In this process, we dived into the world of Promises; hopefully, illustrating their versatility and how they can simplify your code.</p><p>In the next chapter, we will introduce how to build a user matching system, and make it a service. You will also learn how to set up periodical tasks with node-cron.</p></div></body></html>