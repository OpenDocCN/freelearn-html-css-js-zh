<html><head></head><body><div><h1 class="header-title">State</h1>
                
            
            
                
<p class="mce-root">Now that we have created our microservice base layout on different frameworks, it's time to read our code more carefully and see if everything looks good. It's easy to just keep writing code and stop thinking about what we're doing, but later on, when we do stop for a while, we'll be wasting time deleting repeated code and reorganizing our service.</p>
<p class="mce-root">It's always better to think before we code. This is something you'll learn with time, to value the time you dedicate to plan your service or think about a new feature. It's never a good idea to just start coding. In theory, your <strong>Service</strong> should be inside a <strong>Security</strong> layer, with a good and stable connection to <strong>State</strong>:</p>
<div><img src="img/0fafb30f-c4b5-4361-a42c-fc1ca74f7259.png" width="504" height="169"/></div>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">State</h1>
                
            
            
                
<p class="mce-root">Think of state as a person's memory. Usually, a service has state, which means it has memory of actions and information it's serving. The idea is that our service will run indefinitely, but sometimes we're forced to restart it or even stop it for some time because of maintenance or an upgrade.</p>
<p class="mce-root">Ideally, a service should resume without losing state, giving its users the perception that it never stopped. This is achieved by doing one of two things:</p>
<ul>
<li class="mce-root">Having state stored in a persistent storage</li>
<li class="mce-root">Saving state in a persistent storage before stopping and loading that state after restarting</li>
</ul>
<p class="mce-root">The first option will make your service a bit slower (nothing is faster than state in system memory) but should give you a more consistent state across restarts.</p>
<p class="mce-root">The second option is trickier, because sometimes our service might stop abruptly and be unable to save that state, but for those use cases, you may not care about the state. It's up to you.</p>
<p class="mce-root">There are a lot of options to store state; it will depend on what you want to store. For a microservice, you should avoid the filesystem so as to make your service more compatible with multiple operating systems.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Storing state</h1>
                
            
            
                
<p class="mce-root">Depending on your service, you can store state using:</p>
<ul>
<li class="mce-root">A <strong>relational database management system</strong> (<strong>RDBMS</strong>), such as MySQL or PostgreSQL</li>
<li class="mce-root">A <strong>non-relational database management system</strong>, or NoSQL, such as MongoDB or RethinkDB</li>
<li class="mce-root">An <strong>in-memory database</strong> (<strong>IMDB</strong>), such as Redis or Memcached</li>
</ul>
<p class="mce-root">The first option is still the most commonly used one. You'll rely on stable and more than proven database systems that run in multiple systems and that you can find on any cloud service where you might want to deploy your microservice. Apart from the maturity of most solutions, a relational database, if properly set up, should give you consistency.</p>
<p class="mce-root">The second option is more recent compared to the first one. Usually, there are no fixed tables as in RDBMS, and you normally work with collections of documents that are just common JSON structures. It's more agile as there are usually no restrictions, and each document might have a different structure. The more agile, the less consistent.</p>
<p class="mce-root"/>
<p class="mce-root">All three options, depending on the specific system you choose, support replication, which should enable fault tolerance and improve speed in geographically spaced instances.</p>
<p class="mce-root">Let's try each of the three options using one of the suggested systems. Let's begin with the relational database, and use MySQL.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">MySQL</h1>
                
            
            
                
<p>Installing MySQL is very simple. Just head to the official website and follow the instructions. You'll usually be asked for a password for the root user, which you can use later on to manage the server settings and user accounts.</p>
<p class="mce-root">There are some options to connect to a MySQL server using Node.js, but the best tools are the <kbd>mysql</kbd> and <kbd>mysql2</kbd> modules. They both serve the required purpose, and neither is the next version of the other, they're just a bit different in design and supported features.</p>
<p class="mce-root">First, let's add the dependency to our service. On the terminal, go to our service folder and type:</p>
<pre class="mce-root"><strong>npm install mysql --save</strong></pre>
<p class="mce-root">We can now include our dependency and configure a connection to the database. To avoid having the credentials in our code, we can create a separate file and put settings there that we may change in the future, and that shouldn't belong in the code. We can take advantage of Node.js being able to include JSON files, and just write our settings in JSON.</p>
<p class="mce-root">Create a file called <kbd>settings.json</kbd>, and add the following content:</p>
<pre class="mce-root">{<br/>    "db": "mysql://root:test@localhost/imagini"<br/>}</pre>
<p class="mce-root">We defined a setting called <kbd>db</kbd> that has a database URI, which is a handy way of defining our database access and credentials using an address similar to any website address. Our database uses <kbd>mysql</kbd>; it's at <kbd>localhost</kbd> (using the default port), which can be accessed using the username <kbd>root</kbd> and the password <kbd>test</kbd>, and our database name is called <kbd>imagini</kbd>.</p>
<p class="mce-root">We can now include the module and settings, and create the connection:</p>
<pre class="mce-root">const settings = require("./settings");<br/>const mysql    = require("mysql");<br/>const db       = mysql.createConnection(settings.db);</pre>
<p class="mce-root">This module only connects to the database when you make a query. This means the service would start and you wouldn't know whether your connection settings are correct until you make the first query. We don't want to figure out we can't connect to the database only when the service is used later on, so let's force a connection and check if the server is running and accepts our connection:</p>
<pre class="mce-root">db.connect((err) =&gt; {<br/>    if (err) throw err;<br/><br/>    console.log("db: ready");<br/><br/>    // ...<br/>    // the rest of our service code<br/>    // ...<br/><br/>    app.listen(3000, () =&gt; {<br/>        console.log("app: ready");<br/>    });<br/>});</pre>
<p class="mce-root">This way, if anything is wrong with the database, the service won't start and will throw an exception, which will notify you to check what's wrong. Here's an example of a possible error:</p>
<pre class="mce-root"><strong>Error: ER_ACCESS_DENIED_ERROR: Access denied for user 'root'@'localhost' (using password: YES)</strong></pre>
<p class="mce-root">This indicates you probably typed the password incorrectly, or the user doesn't match, or even the hostname or database may be wrong. Ensuring you connect to the database before setting up the service means your service won't be exposed to the public without a proper state.</p>
<p class="mce-root">Our microservice has a very simple state, so to speak. Our state is the images previously uploaded. Instead of using the filesystem, we can now use the database and create a table to store them all:</p>
<pre class="mce-root">db.query(<br/>    `CREATE TABLE IF NOT EXISTS images<br/>    (<br/>        id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,<br/>        date_created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,<br/>        date_used TIMESTAMP NULL DEFAULT NULL,<br/>        name VARCHAR(300) NOT NULL,<br/>        size INT(11) UNSIGNED NOT NULL,<br/>        data LONGBLOB NOT NULL,<br/><br/>        PRIMARY KEY (id),<br/>        UNIQUE KEY name (name)<br/>    )<br/>    ENGINE=InnoDB DEFAULT CHARSET=utf8`<br/>);</pre>
<p class="mce-root">We can issue this query every time the service starts because it will create the images table only if it doesn't exist already. If we don't change its structure, it's fine to always do this.</p>
<p class="mce-root">You can see we're creating a table with a unique identification number (<kbd>id</kbd>), a creation date (<kbd>date_created</kbd>), a date to know when our image has been used(<kbd>date_used</kbd>), the <kbd>name</kbd> of the image, the <kbd>size</kbd> of it in bytes, and the image <kbd>data</kbd>. The size is a little redundant here as we could just check the data length, but bear with me, this is just an example.</p>
<p class="mce-root">We also defined our name as a unique key, meaning it has an index for quickly finding images by name, and also ensures our name does not repeat and that no one can overwrite an image (without removing it first).</p>
<p class="mce-root">Having the images stored this way on a database table gives you several advantages, such as regarding:</p>
<ul>
<li>How many images you have</li>
<li>The size of every image and the total size</li>
<li>When the images were created and last used</li>
</ul>
<p class="mce-root">It also enables you to improve your service; for example, you can delete images that are not used for longer than a specific time period. You can also make this dependent on the image sizes. Later, you can add authentication (mandatory or not) and have user-specific rules.</p>
<p class="mce-root">It's also easy to back up and replicate the state to another site. There are plenty of tools for backing up databases, and you can have another MySQL server acting as a slave to this one and have your images replicated in real time to another geographical location.</p>
<p class="mce-root">Let's change our service from the previous chapter to use our table instead of the previously used folder on our filesystem.</p>
<p class="mce-root">We can remove our  <kbd>fs</kbd> module dependency (don't remove the path dependency for now):</p>
<pre class="mce-root">app.param("image", (req, res, next, image) =&gt; {<br/>    if (!image.match(/\.(png|jpg)$/i)) {<br/>        return res.status(403).end();<br/>    }<br/><br/>    db.query("SELECT * FROM images WHERE name = ?", [ image ], (err, <br/>    images) =&gt; {<br/>        if (err || !images.length) {<br/>            return res.status(404).end();<br/>        }<br/><br/>        req.image = images[0];<br/><br/>        return next();<br/>    });<br/>});</pre>
<p class="mce-root">Our <kbd>app.param</kbd> is completely different. We now validate the <kbd>image</kbd> against our <kbd>image</kbd> table. If it doesn't find it, it returns code <kbd>404</kbd>. If it does find it, it stores the <kbd>image</kbd> information in <kbd>req.image</kbd>. We can now change our <kbd>image</kbd> upload to store the <kbd>image</kbd> on our table:</p>
<pre class="mce-root">app.post("/uploads/:name", bodyparser.raw({<br/>    limit : "10mb",<br/>    type : "image/*"<br/>}), (req, res) =&gt; {<br/>    db.query("INSERT INTO images SET ?", {<br/>        name : req.params.name,<br/>        size : req.body.length,<br/>        data : req.body,<br/>    }, (err) =&gt; {<br/>        if (err) {<br/>            return res.send({ status : "error", code: err.code });<br/>        }<br/><br/>        res.send({ status : "ok", size: req.body.length });<br/>    });<br/>});</pre>
<p class="mce-root">Uploading images no longer use the filesystem and instead creates a new row on our table. We don't need to specify the <kbd>id</kbd> as it's automatic. Our creation date is also automatic as it defaults to the current timestamp. Our use date defaults to <kbd>NULL</kbd>, which means we haven't used the <kbd>image</kbd> yet:</p>
<pre class="mce-root">app.head("/uploads/:image", (req, res) =&gt; {<br/>    return res.status(200).end();<br/>});</pre>
<p class="mce-root">Our <kbd>image</kbd> check method now gets extremely simple as it relies on the previous <kbd>app.param</kbd> to check whether the <kbd>image</kbd> exists, so, if we get to this point, we already know the image exists (it's on <kbd>req.image</kbd>), so we just need to return the code <kbd>200</kbd>.</p>
<p class="mce-root">Before updating our image <kbd>fetch</kbd> method, let's try our service. If you start it on the console, you can immediately open any MySQL administration tool and check our database. I'm using Sequel Pro for macOS. Although there's a Pro in the name, it's free software and it's damn good:</p>
<div><img src="img/65b81b98-1531-4dfd-9cc2-1987f3662fcc.png" width="1999" height="1052"/></div>
<p class="mce-root">Our table was created, and you can check it has all the properties and indexes we defined. Let's now upload an <kbd>image</kbd> once again:</p>
<div><img src="img/51f3e97d-d8ed-4e1f-9d58-0fb7277a8c99.png" width="1920" height="476"/></div>
<p class="mce-root">As before, it returns a JSON response with a success status and the size of the <kbd>image</kbd>. If you look at Sequel again, on the content separator, you'll see our images data:</p>
<div><img src="img/8abacb08-a0fd-4724-9b17-2280b0cd71ab.png" width="1999" height="1051"/></div>
<p class="mce-root">Let's try and upload the <kbd>image</kbd> again. Previously, our service would just overwrite it. Now, because of our unique index, it should deny an <kbd>INSERT</kbd> with the same name:</p>
<div><img src="img/44849b11-4ec0-40e4-92cb-d6604f5515cc.png" width="1561" height="369"/></div>
<p class="mce-root">Great! The <kbd>ER_DUP_ENTRY</kbd> is the MySQL code for duplicate insertion. We can rely on that and deny overwriting images.</p>
<p class="mce-root">We can also check whether our <kbd>image</kbd> exists using the <kbd>check</kbd> method:</p>
<div><img src="img/b2f9f4a5-884f-444e-b8ae-2de6bcf310ba.png" width="1338" height="291"/></div>
<p class="mce-root">If we use another name, we'll get a code <kbd>404</kbd>:</p>
<div><img src="img/c33c9c5a-0af8-4b77-b65b-08cdd3acd9b6.png" width="1526" height="435"/></div>
<p class="mce-root">It looks like everything is working great. Let's now change our final method, the <kbd>image</kbd> manipulation one. This method is almost the same; we just don't have to read the <kbd>image</kbd> file, as it's already available:</p>
<pre class="mce-root">app.get("/uploads/:image", (req, res) =&gt; {<br/>    let image     = sharp(req.image.data);<br/>    let width     = +req.query.width;<br/>    let height    = +req.query.height;<br/>    let blur      = +req.query.blur;<br/>    let sharpen   = +req.query.sharpen;<br/>    let greyscale = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.greyscale);<br/>    let flip      = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.flip);<br/>    let flop      = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.flop);<br/><br/>    if (width &gt; 0 &amp;&amp; height &gt; 0) {<br/>        image.ignoreAspectRatio();<br/>    }<br/><br/>    if (width &gt; 0 || height &gt; 0) {<br/>        image.resize(width || null, height || null);<br/>    }<br/><br/>    if (flip)        image.flip();<br/>    if (flop)        image.flop();<br/>    if (blur &gt; 0)    image.blur(blur);<br/>    if (sharpen &gt; 0) image.sharpen(sharpen);<br/>    if (greyscale)   image.greyscale();<br/><br/>    db.query("UPDATE images " +<br/>             "SET date_used = UTC_TIMESTAMP " +<br/>             "WHERE id = ?", [ req.image.id ]);<br/><br/>    res.setHeader("Content-Type", "image/" + path.extname(req.image.name).substr(1));<br/><br/>    image.pipe(res);<br/>});</pre>
<p class="mce-root">You can see how we used the path dependency to get the extension of the <kbd>image</kbd> name. The rest is the same. We just add an update to our image every time we request this method.</p>
<p class="mce-root">We can use a web browser to test our method and see our previously uploaded image:</p>
<div><img src="img/88605934-5962-4af5-b5fb-821ef77a428d.png" style="width:30.92em;height:23.83em;" width="1499" height="1156"/></div>
<p class="mce-root">Everything should just work as before because we haven't changed our image manipulation dependency, so blurring and the other actions should work as expected:</p>
<div><img src="img/6cd78552-7907-4854-b1fc-27fd4eb936a4.png" width="1493" height="1142"/></div>
<p class="mce-root"/>
<p class="mce-root">We can now improve our service and add a method we didn't expose before: deleting an <kbd>image</kbd>. To do that, we can use the <kbd>DELETE</kbd> verb from HTTP and just remove the <kbd>image</kbd> from our table:</p>
<pre class="mce-root">app.delete("/uploads/:image", (req, res) =&gt; {<br/>    db.query("DELETE FROM images WHERE id = ?", [ req.image.id ], (err) <br/>    =&gt; {<br/>        return res.status(err ? 500 : 200).end();<br/>    });<br/>});</pre>
<p class="mce-root">We just have to check whether the query resulted in an error. If so, we respond with a code <kbd>500</kbd> (internal server error). If not, we respond with the usual code <kbd>200</kbd>.</p>
<p class="mce-root">Let's restart our microservice and try to delete our <kbd>image</kbd>:</p>
<div><img src="img/f332e424-4eb1-4153-9c9e-0807469373fe.png" width="1421" height="533"/></div>
<p class="mce-root">It looks like it worked; it responded with a code <kbd>200</kbd>. If we try to open our image in the web browser, we should see something like this:</p>
<div><img src="img/eced36f5-8a89-4228-ad2f-779c7b69b60a.png" width="1497" height="1175"/></div>
<p class="mce-root">On Sequel, the table should now be empty too:</p>
<div><img src="img/480a78b6-72cc-4286-bb0e-719f3fea3f71.png" width="1902" height="1201"/></div>
<p class="mce-root">We now have a functional microservice with a state that persists across restarts, as we intended. You can now deploy to any cloud service with no dependency on the filesystem, just a database.</p>
<p class="mce-root">You could easily change MySQL to another database or use an <strong>o</strong><strong>bject relational </strong><strong>mapping</strong> (<strong>ORM</strong>) module to enable you to change database server without changing your code. An ORM is a library that allows you to use a common interface to access different types of databases. Usually, this kind of abstraction involves not using SQL at all and reducing your interaction with the databases to simpler queries (to allow for interoperability between database servers).</p>
<p class="mce-root">Let's take this opportunity to go a little further and add a few methods that got simplified by this migration to the database. Let's create a method that exposes statistics about our database, and let's remove old images.</p>
<p class="mce-root">Our first statistics method should just return a JSON structure with some useful information. Let's expose the following:</p>
<ul>
<li>The total number of images</li>
<li>The total size of the images</li>
<li>How long our service is running</li>
<li>When the last time was that we uploaded an image</li>
</ul>
<p class="mce-root">Here's an example of how our statistics method could look:</p>
<pre class="mce-root">app.get("/stats", (req, res) =&gt; {<br/>    db.query("SELECT COUNT(*) total" +<br/>             ", SUM(size) size " +<br/>             ", MAX(date_created) last_created " +<br/>             "FROM images",<br/>    (err, rows) =&gt; {<br/>        if (err) {<br/>            return res.status(500).end();<br/>        }<br/><br/>        rows[0].uptime = process.uptime();<br/><br/>        return res.send(rows[0]);<br/>    });<br/>});</pre>
<p class="mce-root">Restart the service, and let's try it:</p>
<div><img src="img/277cd1a8-085e-410c-b712-0e6d1f58d1f2.png" width="1366" height="286"/></div>
<p class="mce-root">As we can see, we have no images as we just removed our image previously. There's no size because we have no images. There's also no used date, and the service uptime is 5 seconds.</p>
<p class="mce-root">If we upload our previous image, we will get different results, something like the following screenshot:</p>
<div><img src="img/ac4b4b76-7cad-4ba4-b35e-40b11c7ca310.png" width="1395" height="247"/></div>
<p class="mce-root">Now, for our second task, deleting old images, we need to check our database periodically. We'll use an interval timer and just run a <kbd>DELETE</kbd> query. The intervals mentioned in the following query are just an example; you can write the conditions you want.</p>
<pre class="mce-root">setInterval(() =&gt; {<br/>    db.query("DELETE FROM images " +<br/>             "WHERE (date_created &lt; UTC_TIMETSTAMP - INTERVAL 1 WEEK <br/>             AND date_used IS NULL) " +<br/>             " OR (date_used &lt; UTC_TIMETSTAMP - INTERVAL 1 MONTH)");<br/>}, 3600 * 1000);</pre>
<p class="mce-root">This query deletes <kbd>images</kbd> that were not used in the past month (but were used before) or images that were not used in the past week (and never used before). This means that images uploaded need to be used at least once or they will get removed quickly.</p>
<p class="mce-root">You can think of a different strategy, or use no strategy and delete manually if you want. Now that we've seen MySQL, let's move on and look at another kind of database server.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding code coverage</h1>
                
            
            
                
<p>Now that our test suite is working and has one test, let's introduce code coverage. Adding this from the beginning of development is very easy and will help us focus on parts of the code that need to be tested, especially some use cases that involve specific conditions (such as <kbd>if-then-else</kbd> statements in our code). Having it all set up from the start of development is easy. On the other hand, if you have a fully working code and want to add tests and coverage, it will be harder and will take quite some time.</p>
<p>To add code coverage, we'll introduce another module. We'll install it globally to be able to run the tests with it directly:</p>
<pre><strong>npm install -g nyc</strong></pre>
<p>We can now run our tests with the following instrumentation:</p>
<pre><strong>nyc npm test</strong></pre>
<p>This should run our tests with the instrumentation installed. In the end, you'll get a nice console report.</p>
<div><img src="img/99619f27-c68e-49d6-8b6a-a3ad0178c91a.png" width="1933" height="630"/></div>
<p>The coverage results are stored inside in a <kbd>.nyc_output</kbd> folder. This enables you to look at the last test results without running tests again. This is useful if your test suite is big and takes some time to finish.</p>
<p>To see the results, you just run <kbd>nyc report</kbd>:</p>
<div><img src="img/bd9cb784-7cdb-4a9f-8136-5c8c2e133c2a.png" width="1933" height="357"/></div>
<p>The result is a console report. There are several other styles of reports. One particularly useful one is the <kbd>html</kbd> report. Let's generate it:</p>
<pre><strong>nyc report --reporter=html</strong></pre>
<p>You should now have a <kbd>coverage</kbd> folder with an <kbd>index.html</kbd> file. Open that in your browser, and you should see something like the following screenshot:</p>
<div><img src="img/90266f17-41c9-456b-ae43-f238f88d56bb.png" width="1999" height="1261"/></div>
<p>We only have one file that represents our microservice. If we had more, they would be listed hierarchically. There are global average statistics for every file.</p>
<p>There are three important groups of columns:</p>
<ul>
<li><strong>Statements</strong>: Which represent code statements (conditions, assignments, assertions, calls, and so on)</li>
<li><strong>Branches</strong>: Which represent possible code control workflows, such as if-then-else or switch-case statement possibilities</li>
<li><strong>Functions</strong>: Which represent our actual code functions and callbacks</li>
</ul>
<p>You can click in our file, look at the specific details of it and, more specifically, see the code and information line by line:</p>
<div><img src="img/9331f44e-72e3-4ca6-ab78-8be70c2f63e8.png" width="1999" height="1260"/></div>
<p>To the right of every line number, you see a gray area and, in this case, you see <kbd>2x</kbd> in some of the lines. This is the execution count for that line. The execution has passed by that line twice. This is actually not that important, unless you're looking for bits of code that get largely executed and you want to do some kind of optimization.</p>
<p>You can also see that <em>line 12</em> has two changes. First, there's a pinkish background in the back of <kbd>throw err</kbd>. That means that statement never got executed, which is normal for now as we always successfully connected to the database. The mark before the <kbd>if</kbd> statement means that the condition never got executed:</p>
<div><img src="img/0945b756-7b35-43c7-ae99-dd753f2e554f.png" width="1999" height="1272"/></div>
<p>If you scroll a few lines down, we'll see more lines with marks. For example, we can see our image upload method got almost completely covered. The only statement missing is the error handling.</p>
<p>As we delete our test image before running the tests, our image deletion method is also covered. Again, the only missing branch is if the database returns an error to our <kbd>DELETE</kbd> query.</p>
<p>Before going any further with the image upload, let's add another <kbd>integration</kbd> test file called <kbd>image-parameter.js</kbd>, and add some tests to increase our coverage:</p>
<pre>const chai = require("chai");<br/>const http = require("chai-http");<br/>const tools = require("../tools");<br/><br/>chai.use(http);<br/><br/>describe("The image parameter", () =&gt; {<br/>    beforeEach((done) =&gt; {<br/>        chai<br/>        .request(tools.service)<br/>        .delete("/uploads/test_image_parameter.png")<br/>        .end(() =&gt; {<br/>            return done();<br/>        });<br/>    });<br/><br/>    it("should reply 403 for non image extension", (done) =&gt; {<br/>        chai<br/>        .request(tools.service)<br/>        .get("/uploads/test_image_parameter.txt")<br/>        .end((err, res) =&gt; {<br/>            chai.expect(res).to.have.status(403);<br/><br/>            return done();<br/>        });<br/>    });<br/><br/>    it("should reply 404 for non image existence", (done) =&gt; {<br/>        chai<br/>        .request(tools.service)<br/>        .get("/uploads/test_image_parameter.png")<br/>        .end((err, res) =&gt; {<br/>            chai.expect(res).to.have.status(404);<br/><br/>            return done();<br/>        });<br/>    });<br/>});</pre>
<p>Let's run our test suite and see how it goes:</p>
<div><img src="img/44cfd9bd-5ed2-43df-9b75-925c62c0c5da.png" width="1936" height="765"/></div>
<p>Refresh the HTML report page and look at our parameter method:</p>
<div><img src="img/feb5c546-faf8-48dd-9033-b7d921f98985.png" width="1999" height="1272"/></div>
<p>As you can see, we now cover the following condition:</p>
<pre>if (!image.match(/\.(png|jpg)$/i)) {</pre>
<p>The following condition:</p>
<pre>if (err || !images.length) {</pre>
<p>We now have full coverage on this method.</p>
<p>There are other coverage lines that are harder to test, such as timers (you can see one on <em>line 28</em>), <kbd>catch</kbd> statements, or external errors coming from databases or other storage sources. There are ways of mocking those events, and we'll cover them later on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">RethinkDB</h1>
                
            
            
                
<p class="mce-root">Let's see the differences for a non-relational database using RethinkDB. If you don't have it, just install it by following the official documentation (<a href="https://www.rethinkdb.com/docs/">https://www.rethinkdb.com/docs/</a>). Let's just start the server:</p>
<pre class="mce-root"><strong>rethinkdb</strong></pre>
<p class="mce-root">This will start the server, which comes with a very nice administration console on port <kbd>8080</kbd>. You can open it in the web browser:</p>
<div><img src="img/8a25af14-fa51-4597-9eff-d47bcde127d9.png" width="1999" height="1444"/></div>
<p class="mce-root">Go to the Tables section on top to see the databases:</p>
<div><img src="img/b2a5cad5-13fc-40b5-9aa5-c36694406605.png" width="1999" height="1442"/></div>
<p class="mce-root">Create a database called <kbd>imagini</kbd> using the Add Database button. You should now have our database ready. You need nothing else here:</p>
<div><img src="img/5be39ecd-34f7-42c4-8266-fbad8ad61e0b.png" width="1999" height="1445"/></div>
<p class="mce-root">To use our new database, we need to install the <kbd>rethinkdb</kbd> dependency. You can remove the MySQL dependency:</p>
<pre class="mce-root"><strong>npm uninstall mysql --save</strong><br/><strong>npm install rethinkdb -–save</strong></pre>
<p class="mce-root">Now, let's change our <kbd>settings</kbd> file. This module doesn't accept a connection string, so we'll use a JSON structure:</p>
<pre class="mce-root">{<br/>    "db": {<br/>        "host" : "localhost",<br/>        "db" : "imagini"<br/>    }<br/>}</pre>
<p class="mce-root">To include our dependency, we just need to include the module:</p>
<pre class="mce-root">const rethinkdb = require("rethinkdb");</pre>
<p class="mce-root">Then, use this to connect to our server:</p>
<pre class="mce-root">rethinkdb.connect(settings.db, (err, db) =&gt; {<br/>    if (err) throw err;<br/><br/>    console.log("db: ready");<br/><br/>    // ...<br/>    // the rest of our service code<br/>    // ...<br/><br/>    app.listen(3000, () =&gt; {<br/>        console.log("app: ready");<br/>    });<br/>});</pre>
<p class="mce-root">After connecting, we can create our table as we did before. This time, we don't need to specify any structure:</p>
<pre class="mce-root">rethinkdb.tableCreate("images").run(db);</pre>
<p class="mce-root">The <kbd>rethinkdb</kbd> object is the one we'll use to manipulate our table, and the <kbd>db</kbd> object is a connection object used to reference the connection and to indicate where to run our manipulations.</p>
<p class="mce-root">If you restart our service just like this, you'll see a new table on our previously created database:</p>
<div><img src="img/976d103d-a00f-4bc1-b830-ada32e107310.png" width="1999" height="1438"/></div>
<p class="mce-root">If you restart our service again, you'll get an error trying to create the table that already exists. We need to check whether it already exists, and only issue the command if not:</p>
<pre class="mce-root">rethinkdb.tableList().run(db, (err, tables) =&gt; {<br/>    if (err) throw err;<br/><br/>    if (!tables.includes("images")) {<br/>        rethinkdb.tableCreate("images").run(db);<br/>    }<br/>});</pre>
<p class="mce-root">Moving on, our upload method should be changed slightly to something like the following:</p>
<pre class="mce-root">app.post("/uploads/:name", bodyparser.raw({<br/>    limit : "10mb",<br/>    type : "image/*"<br/>}), (req, res) =&gt; {<br/>    rethinkdb.table("images").insert({<br/>        name : req.params.name,<br/>        size : req.body.length,<br/>        data : req.body,<br/>    }).run(db, (err) =&gt; {<br/>        if (err) {<br/>            return res.send({ status : "error", code: err.code });<br/>        }<br/><br/>        res.send({ status : "ok", size: req.body.length });<br/>    });<br/>});</pre>
<p class="mce-root">If you restart the server just like this, you should be able to upload an <kbd>image</kbd>:</p>
<div><img src="img/5591f6a1-af2d-414b-9d22-9b5defb7c872.png" width="1613" height="403"/></div>
<p class="mce-root"/>
<p class="mce-root">We receive the same response, just like with MySQL. We can go to the Data Explorer section in the administration console and get our record to see whether it's there:</p>
<div><img src="img/b05c2929-88d4-46bb-aa48-61055e014f06.png" width="1999" height="1452"/></div>
<p class="mce-root">Looks good. Notice our record ID is not a number, it's a <strong>Universally Unique Identifier</strong> (<strong>UUID</strong>). This is because RethinkDB has support for sharding (our table is sharded by default if there was more than one server) and it's easier to shard unique identifiers than an incremental number.</p>
<p class="mce-root">Moving on to our Express parameter:</p>
<pre class="mce-root">app.param("image", (req, res, next, image) =&gt; {<br/>    if (!image.match(/\.(png|jpg)$/i)) {<br/>        return res.status(403).end();<br/>    }<br/><br/>    rethinkdb.table("images").filter({<br/>        name : image<br/>    }).limit(1).run(db, (err, images) =&gt; {<br/>        if (err) return res.status(404).end();<br/><br/>        images.toArray((err, images) =&gt; {<br/>            if (err) return res.status(500).end();<br/>            if (!images.length) return res.status(404).end();<br/><br/>            req.image = images[0];<br/><br/>            return next();<br/>        });<br/>    });<br/>});</pre>
<p class="mce-root">With this change, we can now restart our service and see whether our <kbd>image</kbd> exists:</p>
<div><img src="img/cf087587-648d-4091-aa9f-e0d9a8a15fd7.png" width="1349" height="436"/></div>
<p class="mce-root">We need to change the download just a little bit. We need to remove the previous query to update our usage date and replace it with a new one:</p>
<pre class="mce-root">app.get("/uploads/:image", (req, res) =&gt; {<br/>    let image     = sharp(req.image.data);<br/>    let width     = +req.query.width;<br/>    let height    = +req.query.height;<br/>    let blur      = +req.query.blur;<br/>    let sharpen   = +req.query.sharpen;<br/>    let greyscale = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.greyscale);<br/>    let flip      = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.flip);<br/>    let flop      = [ "y", "yes", "true", "1", <br/>    "on"].includes(req.query.flop);<br/><br/>    if (width &gt; 0 &amp;&amp; height &gt; 0) {<br/>        image.ignoreAspectRatio();<br/>    }<br/><br/>    if (width &gt; 0 || height &gt; 0) {<br/>        image.resize(width || null, height || null);<br/>    }<br/><br/>    if (flip)        image.flip();<br/>    if (flop)        image.flop();<br/>    if (blur &gt; 0)    image.blur(blur);<br/>    if (sharpen &gt; 0) image.sharpen(sharpen);<br/>    if (greyscale)   image.greyscale();<br/><br/>    rethinkdb.table("images").get(req.image.id).update({ date_used : <br/>    Date.now() }).run(db);<br/><br/>    res.setHeader("Content-Type", "image/" + <br/>    path.extname(req.image.name).substr(1));<br/><br/>    image.pipe(res);<br/>});</pre>
<p class="mce-root">We can now download our image using the web browser:</p>
<div><img src="img/454e1973-472e-414f-af6e-2b0abbb621ea.png" style="width:43.25em;height:29.75em;" width="1999" height="1376"/></div>
<p class="mce-root">Next, we need to update our image removal method. It's as easy as our upload:</p>
<pre class="mce-root">app.delete("/uploads/:image", (req, res) =&gt; {<br/>    rethinkdb.table("images").get(req.image.id).delete().run(db, (err) <br/>    =&gt; {<br/>        return res.status(err ? 500 : 200).end();<br/>    });<br/>});</pre>
<p class="mce-root">This time, we used the image unique ID to remove it. If we try again using the <kbd>curl</kbd> command, we'll receive a code <kbd>200</kbd>:</p>
<div><img src="img/e8c95a69-2e76-4e9d-b83f-7990119543e7.png" width="1504" height="558"/></div>
<p class="mce-root">If we try to get the first record of our table, we'll see there's nothing there:</p>
<div><img src="img/600662dc-1ded-4417-a286-899f773f6fc1.png" style="width:40.50em;height:28.92em;" width="1999" height="1425"/></div>
<p class="mce-root">Finally, there are our two extra features that we added after introducing MySQL: the statistics and removing old unused images.</p>
<p class="mce-root">Our statistics method is not so simple as running an SQL query with aggregations. We must calculate each of our statistics:</p>
<pre class="mce-root">app.get("/stats", (req, res) =&gt; {<br/>    let uptime = process.uptime();<br/><br/>    rethinkdb.table("images").count().run(db, (err, total) =&gt; {<br/>        if (err) return res.status(500).end();<br/><br/>        rethinkdb.table("images").sum("size").run(db, (err, size) =&gt; {<br/>            if (err) return res.status(500).end();<br/><br/>            rethinkdb.table("images").max("date_created").run(db, (err, <br/>            last_created) =&gt; {<br/>                if (err) return res.status(500).end();<br/><br/>                last_created = (last_created ? new <br/>                Date(last_created.date_created) : null);<br/><br/>                return res.send({ total, size, last_created, uptime });<br/>            });<br/>        });<br/>    });<br/>});</pre>
<p class="mce-root">We should have a similar result to before:</p>
<div><img src="img/81ddd5ab-115d-42c0-867b-95a7319a2555.png" style="width:43.42em;height:23.17em;" width="1999" height="1068"/></div>
<p class="mce-root">Removing old images is more or less easy; we just need to filter the images we want to remove, and then remove them:</p>
<pre class="mce-root">setInterval(() =&gt; {<br/>    let expiration = Date.now() - (30 * 86400 * 1000);<br/><br/>    rethinkdb.table("images").filter((image) =&gt; {<br/>        return image("date_used").lt(expiration);<br/>    }).delete().run(db);<br/>}, 3600 * 1000);</pre>
<p class="mce-root">I simplified the previous strategy and am just removing <kbd>images</kbd> older than 1 month (30 days, times 86,400 seconds a day, times 1,000 milliseconds).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Redis</h1>
                
            
            
                
<p class="mce-root">In-memory databases are different from the previous two types, as they're usually not structured, which means you have no tables. What you have is normally lists of some kind that you can look up and manipulate, or simple hash tables.</p>
<p class="mce-root">Taking advantage of the Redis instance we installed previously for Hydra, let's see another drawback, or actually feature, of this kind of database. Let's connect to our Redis instance and make the following sequence of instructions:</p>
<div><img src="img/2b204f94-7078-4020-9b1d-bf1f62f402cc.png" width="1862" height="716"/></div>
<p class="mce-root">What we did here was to:</p>
<ol>
<li class="mce-root">Connect to the Redis service using <kbd>redis-cli</kbd>.</li>
<li class="mce-root">Get the content of the counter, which is nil (nothing), because we haven't defined it yet.</li>
<li class="mce-root">Increment the counter, which is now automatically defined and set to <kbd>1</kbd>.</li>
<li class="mce-root">Increment the counter again, which is now <kbd>2</kbd>.</li>
<li class="mce-root">Get the content of the counter, which is of course <kbd>2</kbd>.</li>
<li class="mce-root">Shut down the Redis service.</li>
<li class="mce-root">Start the Redis service.</li>
<li class="mce-root">Connect to the Redis service again.</li>
<li class="mce-root">Get the content of the counter, which is nil (nothing).</li>
</ol>
<p class="mce-root">Where's our counter? Well, this is an in-memory database, so everything is gone when we shut down the Redis service. This is the design of almost all kinds of in-memory databases.</p>
<p class="mce-root">They're designed to be fast and in-memory. Their purpose is normally to cache data that is expensive to get, such as some complex calculations, or extensive to download, and we want that to be available faster (in-memory).</p>
<p class="mce-root">I wasn't completely fair with Redis as it actually allows your data to be saved between service restarts. So, let's see how far we can go in using it to save our microservice state.</p>
<p class="mce-root">As before, let's uninstall <kbd>rethinkdb</kbd> and install the <kbd>redis</kbd> module:</p>
<pre class="mce-root"><strong>npm uninstall rethinkdb --save</strong><br/><strong>npm install redis --save</strong></pre>
<p class="mce-root">Let's ignore our <kbd>settings.json</kbd> file (you can remove it if you prefer) and assume Redis will be on our local machine.</p>
<p class="mce-root">First, we need to include the <kbd>redis</kbd> module and create a <kbd>Client</kbd> instance:</p>
<pre class="mce-root">const redis = require("redis");<br/>const db    = redis.createClient(); </pre>
<p class="mce-root">We then need to wait until it connects:</p>
<pre class="mce-root">db.on("connect", () =&gt; {<br/>    console.log("db: ready");<br/><br/>    // ...<br/>    // the rest of our service code<br/>    // ...<br/><br/>    app.listen(3000, () =&gt; {<br/>        console.log("app: ready");<br/>    });<br/>});</pre>
<p class="mce-root">There are a couple of ways we can use Redis to store our data. To make it simple, as we don't have tables, let's use hashes to store our images. Each image will have a different hash, and the name of the hash will be the name of the image.</p>
<p class="mce-root">As there are no tables in this kind of database, our initialization code can just be removed.</p>
<p class="mce-root">Next, let's change our upload method to store data on Redis. As I mentioned, let's store it in a hash with the name of the <kbd>image</kbd>:</p>
<pre class="mce-root">app.post("/uploads/:name", bodyparser.raw({<br/>    limit : "10mb",<br/>    type : "image/*"<br/>}), (req, res) =&gt; {<br/>    db.hmset(req.params.name, {<br/>        size : req.body.length,<br/>        data : req.body.toString("base64"),<br/>    }, (err) =&gt; {<br/>        if (err) {<br/>            return res.send({ status : "error", code: err.code });<br/>        }<br/><br/>        res.send({ status : "ok", size: req.body.length });<br/>    });<br/>});</pre>
<p class="mce-root">The <kbd>hmset</kbd> command lets us set multiple fields of a hash, in our case, <kbd>size</kbd> and <kbd>data</kbd>. Notice we're storing our image content in <kbd>base64</kbd> encoding, otherwise we'll lose data. If we restart our service and try to upload our test <kbd>image</kbd>, it should work fine:</p>
<div><img src="img/69d28e98-498a-4a5f-8dca-9532bb9027e6.png" width="1699" height="334"/></div>
<p class="mce-root">We can then use <kbd>redis-cli</kbd> and see whether our image is there. Well, we're checking to see whether our hash has the field size and matches our image size:</p>
<div><img src="img/3112df7b-958f-4b55-97c6-d3623d694963.png" width="1344" height="237"/></div>
<p class="mce-root">Great! We can now change our Express parameter to look for the <kbd>image</kbd> hash:</p>
<pre class="mce-root">app.param("image", (req, res, next, name) =&gt; {<br/>    if (!name.match(/\.(png|jpg)$/i)) {<br/>        return res.status(403).end();<br/>    }<br/><br/>    db.hgetall(name, (err, image) =&gt; {<br/>        if (err || !image) return res.status(404).end();<br/><br/>        req.image      = image;<br/>        req.image.name = name;<br/><br/>        return next();<br/>    });<br/>});</pre>
<p class="mce-root">Our <kbd>image</kbd> check method should work now. And, for our download method to work, we just need to change the image loading to decode our previous <kbd>base64</kbd> encoding:</p>
<pre class="mce-root">app.get("/uploads/:image", (req, res) =&gt; {<br/>    let image     = sharp(Buffer.from(req.image.data, "base64"));<br/>    let width     = +req.query.width;<br/>    let height    = +req.query.height;<br/>    let blur      = +req.query.blur;<br/>    let sharpen   = +req.query.sharpen;<br/>    let greyscale = [ "y", "yes", "true", "1", "on"].includes(req.query.greyscale);<br/>    let flip      = [ "y", "yes", "true", "1", "on"].includes(req.query.flip);<br/>    let flop      = [ "y", "yes", "true", "1", "on"].includes(req.query.flop);<br/><br/>    if (width &gt; 0 &amp;&amp; height &gt; 0) {<br/>        image.ignoreAspectRatio();<br/>    }<br/><br/>    if (width &gt; 0 || height &gt; 0) {<br/>        image.resize(width || null, height || null);<br/>    }<br/><br/>    if (flip)        image.flip();<br/>    if (flop)        image.flop();<br/>    if (blur &gt; 0)    image.blur(blur);<br/>    if (sharpen &gt; 0) image.sharpen(sharpen);<br/>    if (greyscale)   image.greyscale();<br/><br/>    db.hset(req.image.name, "date_used", Date.now());<br/><br/>    res.setHeader("Content-Type", "image/" + path.extname(req.image.name).substr(1));<br/><br/>    image.pipe(res);<br/>});</pre>
<p class="mce-root">Our images are now being served from Redis. As a bonus, we're adding/updating a <kbd>date_used</kbd> field in our <kbd>image</kbd> hash to indicate when it was last used:</p>
<div><img src="img/c617c24a-e4df-4878-a442-2ce3ff909f1b.png" width="1999" height="1296"/></div>
<p class="mce-root">Removing our <kbd>image</kbd> is as simple as removing our hash:</p>
<pre class="mce-root">app.delete("/uploads/:image", (req, res) =&gt; {<br/>    db.del(req.image.name, (err) =&gt; {<br/>        return res.status(err ? 500 : 200).end();<br/>    });<br/>});</pre>
<p class="mce-root">We can then try to remove our <kbd>test</kbd> image:</p>
<div><img src="img/3557032f-1cf1-42f1-9943-00c31ef5fd66.png" width="1952" height="582"/></div>
<p class="mce-root">Using <kbd>redis-cli</kbd> to check whether the hash exists, we see that it's gone:</p>
<div><img src="img/716dfce9-3eaa-405a-ac5f-91f5bdd7424a.png" width="1617" height="359"/></div>
<p class="mce-root">The only two features missing are the statistics and removing old images.</p>
<p class="mce-root">For the statistics, that could be hard as we're using generic hash tables and we can't be sure how many hash tables are defined, and if all or any have image data. We would have to scan all hash tables, which is complex for large sets.</p>
<p class="mce-root">To remove old images, the problem is the same as there's no way of looking for hash tables with a specific condition, such as a field value.</p>
<p class="mce-root">There are still other paths available to tackle this problem. For example, we could have another hash table with just our image names and use dates. But, the complexity would increase, and the integrity could be at risk as we're splitting information through different hash tables with no certainty of making <strong>Atomicity</strong>, <strong>Consistency</strong>, <strong>Isolation</strong>, and <strong>Durability</strong> (<strong>ACID</strong>) operations.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Conclusion</h1>
                
            
            
                
<p class="mce-root">As we've seen, there are plenty of options to store our microservice state. Depending on the type of information we're manipulating, there are databases better-prepared to handle our data.</p>
<p class="mce-root">It all depends on a few different questions we should ask ourselves:</p>
<ul>
<li class="mce-root">Is our data integrity important?</li>
<li class="mce-root">Is our data structure complex?</li>
<li class="mce-root">How and what type of information do we need to acquire?</li>
</ul>
<p class="mce-root">If our data integrity is important or the data structure is complex, do not use in-memory databases. Depending on the complexity, see if you need a non-relational database, or whether you can go with a relational database that can handle more complex manipulation and data aggregation operations, which will help you to achieve the last point.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Security</h1>
                
            
            
                
<p>One good practice is to write code iteratively, testing every time we make a new small feature or improvement, and always write code thinking of all the features we envision for our service.</p>
<p class="mce-root">Thinking about the service roadmap allows you to prepare the service for future improvements, reducing the amount of code wasted or replaced later on.</p>
<p class="mce-root">For instance, in terms of security:</p>
<ul>
<li class="mce-root">Is our service secure? Is it prepared for some types of malicious attacks?</li>
<li class="mce-root">Is our service private? Should it have some kind of authentication or authorization mechanism?</li>
</ul>
<p class="mce-root">Luckily, our frameworks allow our code to be composed and allow us to add layers of security later. For example, using Express or Hydra, we can add a precedent routing function that will run before any of our service methods, allowing us to enforce, for example, authentication.</p>
<p class="mce-root">Looking at our service, since it exposes its methods using HTTP, there are a couple of improvements we can add to it, for example:</p>
<ul>
<li class="mce-root"><strong>Authentication</strong>: Forcing anyone that uses it to identify themselves. Or, just the upload and removal methods. It's up to you. There could also be user accounts, and each user would see their respective list of images.</li>
<li class="mce-root"><strong>Authorization</strong>: Restricting, for example, what networks could access the service, independently of having a valid authentication or not.</li>
<li class="mce-root"><strong>Confidentiality</strong>: Giving your users protection against prying eyes over the network traffic.</li>
<li class="mce-root"><strong>Availability</strong>: Restricting the maximum usage frequency of the service, per client, to ensure a single client cannot block your entire service.</li>
</ul>
<p class="mce-root">To introduce these improvements, you may add an authentication module such as the Passport module, and use a certificate to give your users a more secure HTTPS experience.</p>
<p class="mce-root">Other types of insecurity come directly from your code and don't improve by adding a certificate or forcing authentication. I'm referring to:</p>
<ul>
<li class="mce-root">Bugs, programming logic flaws, and use cases not properly tested, which can lead to minor or serious problems</li>
<li class="mce-root">Dependency bugs, which you might not be aware of but can still ruin your service and may force you to look for alternative dependencies, which is never a pleasant task</li>
</ul>
<p class="mce-root">To minimize these events, you should always keep evolving your test suite, adding use cases as they show up, ensuring a new bug that is solved does not reappear later. Regarding dependency bugs, you can subscribe to the Node Security Project and even integrate it with your code to always know when one of your dependencies is a risk.</p>
<p class="mce-root">If there were source code commandments, the next four would surely be on the list:</p>
<ul>
<li class="mce-root">Keep the code simple. If the code is getting complex, stop, look back, and split the code into simpler parts.</li>
<li class="mce-root">Validate external input, whether it's the user or another service. Never trust data from the outside.</li>
<li class="mce-root">Deny by default and not the opposite, checking whether someone has access to a resource and denying anyone that is not.</li>
<li class="mce-root">Add test cases from the beginning of the project.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>The state is part of any service, and state is built upon data. For a more cloud-native experience, a service cannot depend on a traditional filesystem and needs to use other kinds of storage structures to store data. Databases are a natural progress, and there are some types of databases to choose from, depending on how important and complex our data is.</p>
<p>Assuming our state is securely stored in a database service of some kind, it's also important to ensure our data cannot be corrupted using our service. There can be security flaws and bugs in our service that may put our data at risk, so it's important to write simple code, validate input, and think about security in general when planning the service roadmap.</p>
<p>To progress our service, let's introduce something we haven't done yet, and should, which is a proper test suite. In the next chapter, we'll see some good options and create a test suite, establishing whether anything needs to change in order to make our service as secure as possible.</p>


            

            
        
    </div>



  </body></html>