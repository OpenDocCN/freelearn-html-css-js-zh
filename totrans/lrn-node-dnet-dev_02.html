<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Getting Started with Node.js</h1></div></div></div><p>This chapter will get you up and running with Node.js. You'll see how quick this can be and how easy it is to start writing web applications. You'll also choose a development environment for working with Node.js. In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Installing Node.js</li><li class="listitem">Writing our first Node.js web application</li><li class="listitem">Setting up our development environment</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Installing and running Node.js</h1></div></div></div><p>To install Node.js, visit <a class="ulink" href="https://nodejs.org">https://nodejs.org</a>, and download and run the installer package for the currently<a id="id33" class="indexterm"/> recommended version. The examples in this book are based on Node.js v6, released in April 2016 and supported through to April 2018.</p><p>After installation, open <a id="id34" class="indexterm"/>up a console window (run command prompt on <a id="id35" class="indexterm"/>Windows, or terminal on Mac) and type <code class="literal">node</code>.</p><p>This opens the Node.js REPL, which works like the JavaScript console in browsers. Try typing in a few commands and see the output:</p><div><pre class="programlisting"><strong>&gt; function square(x) { return x*x; }</strong>
<strong>undefined</strong>
<strong>&gt; square(42)</strong>
<strong>1764</strong>
<strong>&gt; new Date()</strong>
<strong>2016-05-02T16:08:41.915Z</strong>
<strong>&gt; var foo = { bar: 'baz' }</strong>
<strong>undefined</strong>
<strong>&gt; typeof foo</strong>
<strong>'object'</strong>
<strong>&gt; foo.bar</strong>
<strong>'baz'</strong>
</pre></div><p>Now let's make use of one of the Node.js-specific APIs to create an HTTP server. Type the following commands into the REPL (the output of each command is omitted from the listing below for brevity):</p><div><pre class="programlisting"><strong>&gt; var listener = function(request, response) { response.end('Hello World!') }</strong>
<strong>&gt; require('http').createServer(listener).listen(3000)</strong>
</pre></div><p>Now try<a id="id36" class="indexterm"/> visiting <code class="literal">http://localhost:3000</code> in your browser. Congratulations! You have written your first web server, in just two lines of code. The first line defines <a id="id37" class="indexterm"/>a callback function for handling HTTP requests and returning a response. The second line sets up a new server that accepts HTTP requests on port 3000 and invokes our callback function for each request.</p><p>You can exit the Node.js REPL by typing <code class="literal">process.exit()</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Choosing an editor</h1></div></div></div><p>Of course, we're not going to write all of our code inside the REPL. You can use any text editor or IDE you like for writing JavaScript for Node.js. If you're not sure what to use, try one of the <a id="id38" class="indexterm"/>following:</p><div><ul class="itemizedlist"><li class="listitem">Atom (<a class="ulink" href="https://atom.io/">https://atom.io/</a>)</li><li class="listitem">Visual Studio Code (<a class="ulink" href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>)</li></ul></div><p>These are both<a id="id39" class="indexterm"/> free, lightweight IDEs that are actually implemented in Node.js. They are both available for Windows, Mac, and Linux.</p><p>The code listings in <a id="id40" class="indexterm"/>the rest of this book will be JavaScript source code files, not commands to be typed into the REPL.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Using an application framework</h1></div></div></div><p>The server we <a id="id41" class="indexterm"/>created in the REPL used the low-level HTTP module built into Node.js. This provides an API for creating a server that reads data from requests and writes to responses.</p><p>As with other programming platforms, there are frameworks available providing more useful high-level abstractions for writing web applications. These include things such as URL routing and templating engines. ASP.NET MVC, Ruby on Rails, and Spring MVC are all examples of such frameworks on different platforms.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>
<strong>Example code</strong>
</p><p>If you get stuck at any point in this book, you can follow along with the code at <a class="ulink" href="https://github.com/NodeJsForDevelopers">https://github.com/NodeJsForDevelopers</a> (there is a repository for each chapter and a commit for each heading that introduces any new code).</p></div><p>In this book, we'll be<a id="id42" class="indexterm"/> using a framework called Express to write a web application in Node.js. Express is the most popular web application framework for Node.js. It is well suited to small-scale applications such as the one we'll be building. It also provides a good introduction to important concepts. Most other popular Node.js web application frameworks are conceptually similar to Express, and several are actually built on top of it.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Getting started with Express</h2></div></div></div><p>To get our<a id="id43" class="indexterm"/> Express-based application started, we'll use npm to install the <code class="literal">express-generator</code> package, which will create a skeleton<a id="id44" class="indexterm"/> application based on Express. Run the following command in the console (that is, your regular terminal, not inside the Node.js REPL):</p><div><pre class="programlisting"><strong>&gt; npm install -g express-generator@~4.x</strong>
</pre></div><p>The <code class="literal">-g</code> option installs the Express generator globally, so you can run it from anywhere. The next command we run will create a new folder to contain our application code, so run this command wherever you want this folder to reside:</p><div><pre class="programlisting"><strong>&gt; express --hogan chapter02</strong>
</pre></div><div><h3 class="title"><a id="note03"/>Note</h3><p>
<strong>Templating engines</strong>
</p><p>Express offers a <a id="id45" class="indexterm"/>choice of templating engines. We'll be using Hogan, which is an implementation of the Mustache templating engine. You may already be familiar with Mustache from client-side libraries. Don't worry if not, though. It's very simple to pick up.</p></div><p>As you can see from the output, this sets up a minimal standard application structure for us. Now run the following command (as instructed by the generator output) to install the modules on which our application depends:</p><div><pre class="programlisting"><strong>&gt; c</strong><strong>d chapter02</strong>
<strong>&gt; npm install</strong>
</pre></div><p>The generator has created a skeleton Node.js web application for us. Let's try running this:</p><div><pre class="programlisting"><strong>&gt; npm start</strong>
</pre></div><p>Now <a id="id46" class="indexterm"/>visit <code class="literal">http://localhost:3000</code> again and you'll see<a id="id47" class="indexterm"/> the Express welcome page as shown here:</p><div><img src="img/image00213.jpeg" alt="Getting started with Express"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Exploring our Express application</h2></div></div></div><p>Let's look at<a id="id48" class="indexterm"/> the folders that the Express generator created for us:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">node_modules</code>: This<a id="id49" class="indexterm"/> folder contains the third-party packages that our application depends on, which are installed when we run <code class="literal">npm install</code> (it is common to exclude this directory from source control)</li><li class="listitem"><code class="literal">public</code>: This<a id="id50" class="indexterm"/> folder contains the static assets of our application: images, client-side JavaScript, and CSS</li><li class="listitem"><code class="literal">routes</code>: This <a id="id51" class="indexterm"/>folder contains the logic of our application</li><li class="listitem"><code class="literal">views</code>: This<a id="id52" class="indexterm"/> folder contains the server-side templates for our application</li></ul></div><p>There are also some files that aren't contained in any of the preceding folders:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">package.json</code>: This <a id="id53" class="indexterm"/>file contains metadata about our application used by the <code class="literal">npm install</code> and <code class="literal">npm start</code> commands used earlier. We'll explore this file further in <a class="link" title="Chapter 4. Introducing Node.js Modules" href="part0025.xhtml#aid-NQU21">Chapter 4</a>, <em>Introducing Node.js Modules</em>.</li><li class="listitem"><code class="literal">app.js</code>: This file <a id="id54" class="indexterm"/>is the main entry point for our application, which glues together all of the preceding components and initializes Express. We'll go through this file in more detail later on in this chapter.</li><li class="listitem"><code class="literal">bin/www</code>: This file is <a id="id55" class="indexterm"/>a Node.js script that launches our application. This is the script that gets executed when we run <code class="literal">npm start</code>.</li></ul></div><p>It's not<a id="id56" class="indexterm"/> important to understand everything in the <code class="literal">bin/www</code> script at this point. However, note that it uses the same <code class="literal">http.createServer</code> call as in the REPL example before. This time, though, the listener argument is not a simple function but is our entire application (defined in <code class="literal">app.js</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Understanding Express routes and views</h2></div></div></div><p>
<strong>Routes</strong> in <a id="id57" class="indexterm"/>Express contain the logic for handling requests and rendering the <a id="id58" class="indexterm"/>appropriate response. They have similar responsibilities to<a id="id59" class="indexterm"/> controllers in MVC frameworks such as ASP.NET, Spring<a id="id60" class="indexterm"/> MVC, or Ruby on Rails.</p><p>The route that serves the page we just viewed in the browser can be found at <code class="literal">routes/index.js</code> and looks like this:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});

module.exports = router;</pre></div><p>The <code class="literal">require</code> call imports the Express module. We will discuss how this works in much more detail in <a class="link" title="Chapter 4. Introducing Node.js Modules" href="part0025.xhtml#aid-NQU21">Chapter 4</a>, <em>Introducing Node.js Modules</em>. For now, think of it like a <code class="literal">using</code> or <code class="literal">import</code> statement in .NET or Java. The call to <code class="literal">express.Router()</code> creates a context under which we can define new routes. We will discuss this in more detail later on in this chapter (see <em>Creating modular applications with Express</em>). The <code class="literal">router.get()</code> call adds a new handler to this context for GET requests to the path <code class="literal">'/'</code>.</p><p>The <code class="literal">callback</code> function takes a request and response argument, similar to the listener in our "Hello World!" server at the beginning of this chapter. However, the request and response in this case are objects provided by Express, with additional functionality.</p><p>The <code class="literal">render</code> function allows us to respond with a template, which is rendered using the data we pass to it. This is typically the last thing you will do in a route's <code class="literal">callback</code> function. Here, we pass an object containing the title <em>Express</em> to the view template.</p><p>The view template can be found at <code class="literal">views/index.hjs</code> and looks like this:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;{{ title }}&lt;/h1&gt;
    &lt;p&gt;Welcome to {{ title }}&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>This is a<a id="id61" class="indexterm"/> Hogan template. As mentioned previously, Hogan is an implementation<a id="id62" class="indexterm"/> of Mustache, a very lightweight templating language <a id="id63" class="indexterm"/>that limits<a id="id64" class="indexterm"/> the amount of logic in <a id="id65" class="indexterm"/>views. You can see the full syntax of Mustache at <a class="ulink" href="https://mustache.github.io/mustache.5.html">https://mustache.github.io/mustache.5.html</a>.</p><p>Our template is a simple HTML page with some special template tags. The <code class="literal">{{ title }} </code>tags are replaced with the title field from the data passed in by the route.</p><p>Let's change the heading in the view to include a name as well as a title. It should look like this:</p><div><pre class="programlisting">&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;</pre></div><p>Try reloading the page again. You should see the following:</p><div><img src="img/image00214.jpeg" alt="Understanding Express routes and views"/></div><p style="clear:both; height: 1em;"> </p><p>We don't have a name yet. That's because there is no <strong>name</strong> field in our view data. Let's fix that by editing our route:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
<strong>  res.render('index', { title: 'Express', name: 'World' });</strong>
});

module.exports = router;</pre></div><p>If we <a id="id66" class="indexterm"/>refresh our browser again at this point, we still won't see the name. That's<a id="id67" class="indexterm"/> because our application has already loaded our route, so won't<a id="id68" class="indexterm"/> pick up the change.</p><p>Go back to your<a id="id69" class="indexterm"/> terminal and kill the running application. Start it again (using <code class="literal">npm start</code>) and reload the page in the browser. You should now see the text <strong>Hello, World!</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Using nodemon for automatic restarts</h2></div></div></div><p>Restarting the<a id="id70" class="indexterm"/> application every time we make a change is a bit tedious. We can do better by running our application with <strong>nodemon</strong>, which will automatically restart the application whenever we make a change<a id="id71" class="indexterm"/>:</p><div><pre class="programlisting"><strong>&gt; npm install -g nodemon</strong>
<strong>&gt; nodemon</strong>
</pre></div><p>Try updating the <code class="literal">routes/index.js</code> file again (for example, change the name string to your own name), then refresh the browser. This time, the change should appear without you needing to manually stop and restart the application. Note that the process is restarted by nodemon though, so if our application stored any internal state, this would be lost.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Creating modular applications with Express</h2></div></div></div><p>To find <a id="id72" class="indexterm"/>out how our route gets called when a request is <a id="id73" class="indexterm"/>made, we need to look at the <code class="literal">app.js</code> bootstrapping file. See the following two lines:</p><div><pre class="programlisting">var routes = require('./routes/index');
...
app.use('/', routes);</pre></div><p>This tells Express to use the routing context defined in <code class="literal">routes/index.js</code> for requests to the root path (<code class="literal">'/'</code>).</p><p>There is a similar call setting up a route under the <code class="literal">/users</code> path. Try visiting this path in your browser. The route that renders this response is defined in <code class="literal">/routes/users.js</code>.</p><p>Note that the route in <code class="literal">/routes/users.js</code> is <em>also</em> bound to <code class="literal">'/'</code>, the same as the route in <code class="literal">/routes/index.js</code>. The reason this works is that these paths are each relative to a separate Router instance, and the instance created in <code class="literal">/routes/users.js</code> is mounted under the <code class="literal">/users</code> path in <code class="literal">app.js</code>.</p><p>This mechanism makes it easy to build large applications composed from smaller modules. You can think of it as similar to the Areas functionality in ASP.NET MVC, or simply as an alternative structure to MVC controllers grouping together action methods.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Bootstrapping an Express application</h2></div></div></div><p>Let's take a<a id="id74" class="indexterm"/> look at the rest of the <code class="literal">app.js</code> file. Your file might not look identical to the listings below due to minor differences in our versions of Express, but it will contain broadly the same sections.</p><p>The various <code class="literal">require()</code> calls at the top of the file import the modules used by the application, including built-in Node.js modules (HTTP and Path), third-party libraries, and the application's own routes. The following lines initialize Express, telling it where to look for view templates and what rendering engine to use (in our case, Hogan):</p><div><pre class="programlisting">var app = express();
// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', '{views}');</pre></div><p>The rest of the file consists of calls<a id="id75" class="indexterm"/> to <code class="literal">app.use()</code>. These register various different <strong>middleware</strong> for processing the request. The order in which they are registered forms a request processing pipeline. You might already be familiar with this pattern from servlet filters in Java, or the <code class="literal">IAppBuilder</code>/<code class="literal">IApplicationBuilder</code>/<code class="literal">IBuilder</code> interfaces in OWIN and ASP.NET. Don't worry if not though; we'll explore middleware thoroughly here.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Understanding Express middleware</h2></div></div></div><p>Middleware functions<a id="id76" class="indexterm"/> are the fundamental building blocks of an Express <a id="id77" class="indexterm"/>application. They are simply functions that take request and response arguments (just like our listener functions before) and a reference to the next middleware in the chain.</p><p>Each middleware function can manipulate the request and response objects before passing onto the next middleware in the chain. By chaining middleware together in this way, you can build complex functionality from simple modular components. It also allows clean separation between your application logic and cross-cutting concerns such as logging, authentication, or error handling.</p><p>Instead of passing control to the next middleware in the chain, a function can also end the processing of the request and return a response. Middleware can also be mounted to specific paths or router instances, for example, if we want enhanced logging on a particular part of our site.</p><p>In fact, Express routes are just another example of middleware: the routes that we have already looked at are ordinary middleware functions with the same three arguments noted above. They just happen to be mounted to a specific path and to return a response.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Implementing error handling</h3></div></div></div><p>Let's take a <a id="id78" class="indexterm"/>closer look at some of the middleware in <code class="literal">app.js</code>. First, look at the 404 error handler:</p><div><pre class="programlisting">app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});</pre></div><p>This function <a id="id79" class="indexterm"/>always returns a response. So why do we not always get a 404 from our application? Remember that middleware is called in order, and the routes (which are registered before this function) return a response and don't call the next middleware. This means that the 404 function will only be called for requests that don't match any route, which is exactly what we want.</p><p>What about the other two error handlers in app.js? They return a 500 response with a custom error page. Why does our application not return a 500 response in all cases? How do these get executed if another middleware throws an error before calling <code class="literal">next()</code>?</p><p>Error-handling is a special case in Express. Error-handling middleware functions take four arguments instead of three, with the first parameter being an error. They should be registered last, after all other middlewares.</p><p>In the case of an error (either an error being thrown or a middleware function passing in an error argument when calling <code class="literal">next</code>), Express will skip any other non-error handling middleware and start executing the error handlers.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Using Express middleware</h3></div></div></div><p>Let's see some <a id="id80" class="indexterm"/>Express middleware in action by making use of cookie parsing middleware (which is already part of the skeleton application created by <code class="literal">express-generator</code>). We can do this by using a cookie to store how many times someone has visited the site. Update <code class="literal">routes/index.js</code> as follows:</p><div><pre class="programlisting">router.get('/', function(req, res, next) {
<strong>  var visits = parseInt(req.cookies.visits) || 0;</strong>
<strong>  visits += 1;</strong>
<strong>  res.cookie('visits', visits);</strong>
<strong>  res.render('index',</strong>
<strong>      { title: 'Express', name: 'World', visits: visits }</strong>
<strong>  );</strong>
});</pre></div><p>And add a new line to <code class="literal">views/index.hjs</code>:</p><div><pre class="programlisting">&lt;p&gt;You have visited this site {{visits}} time(s).&lt;/p&gt;</pre></div><p>Now visit <code class="literal">http://localhost:3000/</code> again and refresh the page a few times. You should see the visit count increase based on the value stored in the cookie. To see what the cookie parsing middleware is doing for us, try deleting or commenting out the following line from <code class="literal">app.js</code> and reloading the page:</p><div><pre class="programlisting">app.use(cookieParser());</pre></div><p>As you can see <a id="id81" class="indexterm"/>from the error, the <code class="literal">cookies</code> property of the request is now undefined. The cookie parsing middleware looks at the cookie header of the request and turns it into a convenient JavaScript object for us. This is a common use case for middleware. The <code class="literal">bodyParser</code> middleware functions do a very similar job with the request body, turning raw text into a JavaScript object that is easier to use in our routes.</p><p>Note that the error response above also demonstrates our error handling middleware. Try commenting out the error handlers at the end of the <code class="literal">app.js</code> file and reloading the page again. We now get the default stack trace rather than the custom error response defined in our handler.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we installed Node.js, saw how to interact with it from the command line, and started using it to write web applications. We learned about Express and how we can structure an application using routes and middleware.</p><p>Although we've seen some code in this chapter, we haven't really explored the JavaScript syntax in detail. Before adding more functionality to our application, we should make sure that we're up to speed with JavaScript. This is the subject of the next chapter.</p></div></body></html>