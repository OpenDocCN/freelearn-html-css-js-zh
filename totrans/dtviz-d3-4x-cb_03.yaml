- en: Chapter 3. Dealing with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding an array as data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding object literals as data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding functions as data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data from a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous data loading using queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the most essential question in any data visualization
    project: how data can be represented in both programming constructs, and its visual
    metaphor. Before we start on this topic, some discussion on data visualization
    is necessary. In order to understand what data visualization is, first we will
    need to understand the difference between data and information.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data consists of raw facts. The word raw indicates that the facts have not
    yet been processed to reveal their meaning...Information is the result of processing
    raw data to reveal its meaning.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*   -Rob P., S. Morris, and Coronel C. 2009*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is how data and information are traditionally defined in the digital information
    world. However, data visualization provides a much richer interpretation of this
    definition since information is no longer the mere result of processed raw facts
    but rather a visual metaphor of the facts. As stated by *Manuel Lima*, in his
    *Information Visualization Manifesto*, design in the material world, where form
    is regarded to follow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same dataset can generate any number of visualizations, which may lay equal
    claim in terms of validity. In a sense, visualization is more about communicating
    the creator''s insight into data than anything else. On a more provocative note,
    Card, McKinlay, and Shneiderman suggested that the practice of information visualization
    can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The use of computer-supported, interactive, visual representations of abstract
    data to amplify cognition.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* -"Card S. and Mackinly J.", and Shneiderman B. 1999*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following sections, we will explore various techniques D3 provides to
    bridge the data with the visual domain. It is the very first step we need to take
    before we can create a *cognition amplifier* with our data.
  prefs: []
  type: TYPE_NORMAL
- en: The enter-update-exit pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The task of matching each datum with its visual representation, for example,
    drawing a single bar for every data point you have in your dataset, updating the
    bars when the data points change, and then eventually removing the bars when certain
    data points no longer exist, seems to be a complicated and tedious task. This
    is precisely why D3 was designed, to provide an ingenious way of simplifying the
    implementation of this task. This way of defining the connection between data
    and its visual representation is usually referred to as the *enter-update-exit*
    pattern in D3\. This pattern is profoundly different from the typical *imperative
    method* most developers are familiar with. However, the understanding of this
    pattern is crucial to your effectiveness with the D3 library; and therefore, in
    this section, we will focus on explaining the concept behind this pattern. First,
    let''s take a look at the following conceptual illustration of the two domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data and visual set
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding illustration, the two circles represent two joined sets. Set
    **A** depicts your dataset, whereas set **B** represents the visual elements.
    This is essentially how D3 sees the connection between your data and visual elements.
    You might be asking how set theory will help your data visualization effort here.
    Let me explain.
  prefs: []
  type: TYPE_NORMAL
- en: First, let us consider the question *how can I find all visual elements that
    currently represent their corresponding data point?* The answer is *A∩B*; this
    denotes the intersection of sets **A** and **B**, the elements that exist in both
    Data and Visual domains.
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Update mode
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the shaded area represents the intersection between
    the two sets, **A** and **B**. In D3, the `selection.data` function can be used
    to select this intersection, *A* *∩* *B*.
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data)` function, upon selection, sets up the connection
    between the data domain and visual domain, as we discussed in the previous paragraph.
    The initial selection forms the visual set **B**, whereas the data provided in
    the `data` function form dataset **A**. The return result of this function is
    a new selection (a data-bound selection) of all elements existing in this intersection.
    Now, you can invoke the modifier function on this new selection to update all
    the existing elements. This mode of selection is usually referred to as the **Update
    mode**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second question we will need to answer here is *how can I target data points
    that have not yet been visualized?* The answer is the set difference of **A**
    and **B**, denoted as *A\B*, which can be seen visually through the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter mode
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area in set **A** represents the data points that have not yet been
    visualized. In order to gain access to this *A\B* subset, the following functions
    need to be performed on a data-bound D3 selection (a selection returned by the
    `data` function).
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data).enter()` function returns a new selection representing
    the *A\B* subset, which contains all the pieces of data that has not yet been
    represented in the visual domain. The regular modifier function can then be chained
    to this new selection method to create new visual elements that represent the
    given data elements. This mode of selection is simply referred to as the **Enter
    mode**.
  prefs: []
  type: TYPE_NORMAL
- en: The third case in our discussion covers the visual elements that exist in our
    dataset but no longer have any corresponding data element associated with them.
    You might ask how this kind of visual element can exist in the first place. This
    is usually caused by removing the elements from the dataset; that is, if you initially
    visualized all data points within your dataset, and removed some data points after
    that. Now, you have certain visual elements that are no longer representing any
    valid data point in your dataset. This subset can be discovered using an inverse
    of the Update difference, denoted as *B\A*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exit mode
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area in the preceding illustration represents the difference we just
    discussed. The subset can be selected using the `selection.exit` function on a
    data-bound selection.
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data).exit` function, when invoked on a data-bound D3 `selectioncomputes`
    a new selection which contains all visual elements that are no longer associated
    with any valid data element. As a valid D3 selection object, the modifier function
    can then be chained to this selection to update and remove these visual elements
    that are no longer required as part of our visualization. This mode of selection
    is called the **Exit mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Together, the three different selection modes cover all possible cases of interaction
    between the data and its visual domain.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, D3 also offers a fourth selection mode that is very handy when
    you need to avoid duplicating visualization code or the so-called *DRY* up your
    code. This fourth mode is called merge mode. It can be invoked using the `selection.merge`
    function. This function merges the given selection passed to the `merge` function
    with the selection where the function is invoked and returns a new selection that
    is a union of both. In the *enter-update-exit* pattern, the `merge` function is
    commonly used to construct a selection that covers both the Enter and Update modes
    since that's where most code duplication would otherwise live.
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Merge mode
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area in this illustration shows the data points targeted by merge
    mode that combines both Enter and Update modes, which is essentially the entire
    set A. This is very convenient since now a single chain of modifiers can be utilized
    to style both modes and thus lead to less code duplication. We will demonstrate
    how to leverage merge mode in each recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In software engineering, **Don't Repeat Yourself** (**DRY**) is a principle
    of software development, aimed at reducing repetition of information of all kinds
    (Wikipedia, August 2016). You can also read Mike Bostock's post on *What Makes
    Software Good?* for more insight on reasons behind this design change at [https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp](https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The *enter-update-exit* pattern is the cornerstone of any D3-driven visualization.
    In the following recipes of this chapter, we will cover the topics on how these selection
    methods can be utilized to generate data-driven visual elements efficiently and
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Binding an array as data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common and popular ways to define data in D3 visualization is
    through the use of JavaScript arrays; for example, say you have multiple data
    elements stored in an array, and you want to generate corresponding visual elements
    to represent each and every one of them. Additionally, when the data array gets
    updated, you would want your visualization to reflect such changes immediately.
    In this recipe, we will accomplish this common approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and most natural solution that might come to mind is iterating through
    the data array elements and generating their corresponding visual elements on
    the page. This is definitely a valid solution, and it will work with D3; however,
    the enter-update-exit pattern we discussed in the introduction provides a much
    easier and more efficient way to generate visual elements. Let''s take a look
    at how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data as array
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, data (a list of integers in this case) is stored in a simple
    JavaScript array as shown on the line `A` in the preceding code. The `render`
    function is defined on the line marked as `B` so that it can be repeatedly invoked
    to update our visualization. The selection starts on the line marked as `C`, which
    selects all `div` elements on the web page with the `h-bar` CSS class. You are
    probably wondering why we are selecting these `div` elements since they don''t
    even exist on the web page yet. This is in fact true; however, the selection at
    this point is used to define the visual set we discussed in the introduction.
    By issuing this selection, that we made in the previous line, we essentially declare
    that there should be a set of the `div.h-bar` elements on the web page to form
    our visual set. On the line marked as `D`, we invoke the `data` function on this
    initial selection to bind the array as our dataset to the to-be-created visual
    elements. Once the two sets are defined, the `enter()` function on line `E` can
    be used to select all pieces of data elements that are not yet visualized. When
    the `render` function is invoked for the very first time, it returns all elements
    in the data array, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On line `F`, a new `div` element is created and appended to the `body` element
    of each data element selected in the `enter` function; this essentially creates
    one `div` element for each datum. Finally, on line `G`, we set its CSS class to
    `h-bar`. At this point, we basically created the skeleton of our visualization,
    including the empty `div` elements. Next step is to change the visual attributes
    of our elements based on the given data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3 injects a property to the DOM element named `__data__` to make data sticky
    with visual elements so when selections are made using a modified dataset, D3
    can compute the difference and intersection correctly. You can see this property
    easily if you inspect the DOM element either visually using a debugger or programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated by the preceding screenshot, this is very useful to know when
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, on line `H`, the merge function is invoked with
    the selection as its parameter. This function call essentially merges the enter
    selection with the update selection and returns the union of both selections,
    thus allowing us to chain modifiers for both enter and update scenarios. Without
    the merge function, we would need to repeat the code here for both enter and update
    scenarios. Then, on line `I`, we applied a dynamic style attribute `width` to
    be three times the integer value associated with each visual element, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All D3 modifier functions accept this type of dynamic function to compute its
    value on the fly. This is precisely what it means to *data drive* your visualization.
    Hence, it is crucial to understand what this function is designed to achieve in
    our example. This function receives a parameter `d`, which is the datum associated
    with the current element. In our example, the first `div` bar has the value `10`
    associated as its datum, the second bar has `15`, and so on. Therefore, this function
    essentially computes a numeric value that is three times the datum for each bar
    and returns it as the element's `width` in pixels. While, on line `J`, we used
    a similar approach to change the text content of the `div` element to the datum
    value associated with each element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dynamic modifier function actually accepts two parameters, `d` and `i`.
    The first parameter `d` is the associated datum we just discussed, and `i` is
    a zero-based index number for the current element. Some recipes in the previous
    chapter relied on this index, and in the rest of this chapter, we will take look
    at other recipes that utilize this index in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the raw HTML code that resulted from this update process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following last section, `Exit` section, is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The selection returned by the `exit()` function is just like any other selection.
    Therefore, although `remove` is the most common action used against the `exit`
    selection, you can also apply other modifiers or transitions to this selection.
    We will explore some of these options in later chapters
  prefs: []
  type: TYPE_NORMAL
- en: On line `K` in the preceding code snippet, the `exit()` function is called to
    compute the set difference of all visual elements that are no longer associated
    with any data. Finally, the `remove()` function is called on this selection to
    remove all the elements selected by the `exit()` function. This way, as long as
    you call the `render()` function after you change our data, you can always ensure
    that our visual representation and data are kept synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the following last block of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On line `L`, a simple anonymous function was created to remove the top element
    in the data array using the `shift` function while appending a random integer
    to the data array using the `push()` function every 1.5 seconds. Once the data
    array is updated, the `render()` function is called again to update our visualization
    to keep it synchronized with the new dataset. This is what gives our example its
    animated bar chart look.
  prefs: []
  type: TYPE_NORMAL
- en: Binding object literals as data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a more complex visualization, each element we have in a data array might
    not be a primitive integer value or a string, but a JavaScript object itself.
    In this recipe, we will discuss how this more complex data structure can be leveraged
    to drive your visualization using D3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript object literal is probably the most common data structure you will
    encounter when you load data sources on the Web. In this recipe, we will take
    a look at how these JavaScript objects can be leveraged to generate rich visualization.
    The following code illustrates how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates  the following visu alization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data as object
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe is built on top of the previous recipe, so if you are not familiar
    with the fundamental enter-update-exit selection pattern, please take a look at
    the previous recipe first.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, instead of simple integers as shown in the previous recipe,
    now our data array is filled with objects (refer to the line marked as `A` with
    an arrow left to it). Each data object contains two attributes: `width` and `color`,
    that are both integers in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On line `B`, we have a complicated-looking `color` scale defined: `...` `.range(["#add8e6",
    "blue"]); // <- B` `...` Scales, including color scale, will be discussed in depth
    in the next chapter, so for now let us just assume this is a scale function we
    can use to produce CSS-compatible color code, given some integer input value.
    This is sufficient for the purpose of this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The major difference between this recipe and the previous one is the way the
    data is handled as shown on line `C` in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, in this recipe, the datum associated
    with each visual element is actually an object, not an integer. Therefore, we
    can access the `d.width` attribute on line `D`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your object has functions of its own, you can also access them here in a
    dynamic modifier function. This is a convenient way to add some data-specific
    helper functions in your data source. However, beware that since dynamic functions
    are usually invoked numerous times during visualization, the function you rely
    on should be implemented as efficiently as possible. If this is not possible,
    then it is best to preprocess your data before binding it to your visualization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, on line `E` in the following code snippet, the `background-color`
    style can be computed using the `d.color` attribute with the color scale we defined
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, on line `F`, we set the text of each bar to display its width.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how JavaScript objects can easily be bound to visual
    elements using exactly the same method discussed in the previous recipe. This
    is one of the most powerful capabilities of the D3 library; it allows you to reuse
    the same pattern and method to handle different types of data, whether simple
    or complex. We will see more examples on this topic in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Binding functions as data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of D3's excellent support for functional-style JavaScript
    programming is that it allows functions to be treated as data as well. This particular
    feature can offer some very powerful capabilities under certain circumstances.
    This is a more advanced recipe. Don't worry about it if you are new to D3 and
    have some difficulty understanding it at first. Over time, this functional programming
    usage will become natural to you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore the possibility of binding functions as data
    to your visual elements. This capability is extremely powerful and flexible, if
    used correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code produces the following bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data as function
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we chose to visualize the output of formula `15 + x * x` using
    a series of vertical bars, each of them annotated with its representing integral
    value. This visualization adds a new bar to the right of the previous one every
    one and a half seconds. We can of course implement this visualization using the
    techniques we discussed in the previous two recipes, where we generated an array
    of integers using the formula, and then just appended a new integer from *n* to
    *n+1* every 1.5 seconds before re-rendering the visualization. However, in this
    recipe, we decided to take a more functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we started with an empty data array on line `A`. On line `B`, a simple
    `datum` function was defined to calculate the result of this formula *15+x^2*.
    Then, on line `C`, another function `newData` was created to generate the current
    dataset, which contains *n+1* references to the `next` function. The following
    is the code for a functional data definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to be a strange setup to achieve our goal. Let''s take a look at
    how we can leverage all these functions in our visualization code. On line `D`,
    we bound our data to a selection of `div` elements, just as we did in the previous
    recipes. However, this time, the data is not an array, but rather the `newData`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'D3 is pretty flexible when it comes to data. If you provide a function to the
    `data` function, D3 will simply invoke the given function and use the returned
    value of this function as a parameter of the `data` function. In this case, the
    data being returned by the `newData` function is an array of function references.
    As the result of this, now in our dynamic modifier function, on lines `E` and
    `G`, the datum `d` that is being passed into these functions is actually a reference
    to the `next` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As a reference to a function, `d` can now be invoked with index `i` as the parameter,
    which in turn will generate the output of the formula needed for our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, functions are special objects, so semantically this is exactly
    the same as binding objects as data. Additionally data can also be considered
    as functions. Constant values such as integers can be thought of as an identity
    function that simply returns what it receives with no modification made.
  prefs: []
  type: TYPE_NORMAL
- en: This technique might not be the most commonly used technique in visualization;
    but when used properly, it is extremely flexible and powerful, especially when
    you have a fluid dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Datum function typically needs to be *idempotent* to make sense. Idempotence
    is the property of being able to apply the same function with the same inputs
    multiple times without changing the result beyond the initial application. For
    more detail on idempotence, visit [http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of our data is stored in arrays, and we spend a lot of our effort working
    with arrays to format and restructure data. This is why D3 provides a rich set
    of array-oriented utilities functions, making this task a lot easier. In this
    recipe, we will explore some of the most common and helpful utilities in this
    aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code example shows some of the most common and helpful array
    utility functions offered by the D3 library and their effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 provides a variety of utility functions to help perform operations on JavaScript
    arrays. Most of them are pretty intuitive and straightforward; however, there
    are a few intrinsic ones. We will discuss them briefly in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our array as `[3, 2, 11, 7, 6, 4, 10, 8, 15]`, the following will be
    its utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.min`: This function retrieves the smallest element, that is, `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.max`: This function retrieves the largest element, that is, `15`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.extent`: This function retrieves both the smallest and the largest elements,
    that is, `[2, 15]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.sum`: This function retrieves the addition of all elements in the array,
    that is, `66`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.medium`: This function finds the medium, that is, `7`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.mean`: This function calculates the mean value, that is, `7.33`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.ascending`/`d3.descending`: The `d3` object comes with a built-in comparator
    function that you can use to sort the JavaScript array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`d3.quantile`: This function calculates the quantile on an array that is already
    sorted in an ascending order, for example, the quantile of `0.25` will be `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.deviation`: This function calculates the standard deviation of the array,
    in our case that will be `4.18`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.bisect`: This function finds an insertion point that comes after (to the
    right of) any existing element of an already-sorted array, that is, bisect (array,
    `6`) will produce `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.nest`: D3''s nest function can be used to build an algorithm that transforms
    a flat array-based data structure into a hierarchical nested structure that is
    particularly suitable for some types of visualization. D3''s nest function can
    be configured using the key function chained to `nest`, as seen on lines `A` and
    `B`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple `key` functions can be provided to generate multiple levels of nesting.
    In our case, the nesting consists of two levels, first by the `type` amount and
    then by the `tip` amount, as demonstrated in the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `entries()` function is used to supply the flat array-based dataset
    as shown on line `C`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you need to filter D3 selection based on the associated data elements
    so that you can hide or show different subdatasets based on the user's input.
    D3 selection provides a filter function to perform this kind of data-driven filtering.
    In this recipe, we will show you how this can be leveraged to filter visual elements
    in a data-driven fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example code shows how data-based filtering can be leveraged
    to highlight different visual elements based on its categorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following visual output once you click on
    the **Dining** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data-based Filtering
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have a dataset that consists of a list of personal expense
    records with `expense` and `category` as attributes, which is shown on the block
    of code marked as `A`. On lines `B`, `C`, and `D`, a set of horizontal bars (HTML
    `div`) was created using the standard enter-update-exit pattern to represent the
    expense records. So far, this recipe is similar to the *Binding object literals
    as data* recipe. Now let''s take a look at line `E`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'D3''s `selection.filter` function takes a function as its parameter. It applies
    the function against every element in the existing selection. The given function
    for `filter` takes two parameters with a hidden `this` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d`: It is the datum associated with the current element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: It is a zero-based index for the current element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this`: This has the hidden reference points to the current DOM element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3's `selection.filter` function expects the given function to return a Boolean
    value. If the returned value is `true`, the corresponding element will be included
    into the new selection that is returned by the `filter` function. In our example,
    the `filter` function essentially selects all bars that match the user-selected
    category and applies a CSS class `selected` to each one of them. This method provides
    you a powerful way to filter and generate data-driven sub-selection, which you
    can further manipulate or dissect to generate focused visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3's `selection.filter` function treats the returned value using JavaScript
    as *truthy* and *falsy tests*, thus not exactly expecting a strict Boolean value.
    What this means is that `false`, `null`, `0`, `""`, `undefined`, and **NaN** (**not
    a number**) are all treated as `false`, while other things are considered `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it is desirable to sort your visual elements according to the
    data they represent so that you can highlight the significance of different elements
    visually. In this recipe, we will explore how this can be achieved in D3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how data-driven sorting and further manipulation can
    be performed using D3\. In this example, we will sort the bar chart we created
    in the previous recipe based on either expense (width) or category, using a user''s
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code generates sorted horizontal bars as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data-based Sorting
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we set up a simple row-based visualization (in lines `B`, `C`,
    and `D`) of some simulated personal expense records containing two attributes,
    `expense` and `category`, that are defined on line `A`. This is almost exactly
    the same as the previous recipe and quite similar to what we have done in the
    *Binding object literals as data* recipe. Once the basics are done, we then select
    all existing bars on line `E` and perform sorting using D3''s `selection.sort`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `selection.sort` function accepts a comparator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `comparator` function receives two data elements: `a` and `b`, to compare,
    returning either a negative, positive, or zero value. If the value is negative,
    `a` will be placed before `b`; if positive, `a` will be placed after `b`; otherwise,
    `a` and `b` are considered equal and the order is *arbitrary*. The `sort()` function
    returns a new selection with all elements sorted in an order that is determined
    by the specified comparator function. The newly returned selection can then be
    manipulated further to generate the desired visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As `a` and `b` are placed arbitrarily when they are equal, D3 `selection.sort`
    is not guaranteed to be stable; however, it is guaranteed to be consistent with
    your browser's built-in `sort` method on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is probably very rare that you will only be visualizing static local data.
    The power of data visualization usually lays on the ability to visualize dynamic
    data typically generated by a server-side program. Since this is a common use
    case, D3 comes with some handy helper functions to make this task as easy as possible.
    In this recipe, we will see how a remote dataset can be loaded dynamically and
    will update an existing visualization once it is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the code example of the `asyn-data-load.html` file, we will load data dynamically
    from the server on the user''s request, and once the data is loaded, we will also
    update our visualization to reflect the new expanded dataset. The following is
    the code for its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what our `data.json` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visual output after you click on the **Load
    Data from JSON feed** button once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data Loading from server
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we created a `render` function to generate a horizontal bar-based
    visualization very similar to what we did in the last couple of recipes. The `load`
    function is defined on line `C` that responds to the user''s click on the **Load
    Data from JSON feed** button, which loads the data from a separate file (`data.json`)
    served by the server. This is achieved using the `d3.json` function as shown on
    line `F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since loading a remote dataset from a JSON file could take some time, it is
    performed asynchronously. Once loaded, the dataset will be passed to the given
    anonymous callback function defined on line `D`. In this function, we simply pass
    the newly loaded dataset to the `render` function in order to generate the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT,
    HTML, and XML data a simple task.
  prefs: []
  type: TYPE_NORMAL
- en: If a more customized and specific control is required, the `d3.request` function
    can be used to further customize the MIME type and request headers. Behind the
    scenes, `d3.json` and `d3.csv` both use `d3.request` to generate the actual request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MIME media type are a two part identifier for file format transmitted on the
    internet. The common registered top-level types are: application, text, audio,
    image, video.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is by no means the only way to load remote data from the server.
    D3 does not dictate how data should be loaded from the remote server. You are
    free to use your favorite JavaScript libraries, such as jQuery or Zepto.js, to
    issue an Ajax request and load a remote dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data loading using queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate another very useful technique commonly used
    to process or generate data in large data visualization projects. It is usually
    necessary in complex visualization project to load and merge multiple datasets
    from different sources before proceeding to visualizing. The challenge in this
    kind of asynchronous loading is the difficulty in waiting to know when all datasets
    have been successfully loaded since only then the visualization can begin. D3
    provides a very convenient `queue` interface to help organize these types of asynchronous
    tasks and helps you coordinate among them, which is the focus of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the code example of the `queue.html` file, we will simulate loading and
    merging multiple data points using the `setTimeout` function. The `setTimeout`
    function executes the given function after a set period of delay; in our case,
    we set the delay to 500 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following output after clicking on the **Generate
    Data Set** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous Data Generation using D3 Queue
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have a pretty standard `render` function that generates
    horizontal bar visualization using the standard enter-update-exit pattern shown
    on lines `B` and `C`. This pattern by now should be very familiar to you. However,
    the data generation part, which is also our focus here, is a bit different in
    this recipe. On line `D`, we have a simple random datum generation function called
    `generateDatum(callback)`, which receives a single parameter callback. This is
    a very standard template for task function in D3 queue interface, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we use the `setInterval` function to simulate asynchronous
    data generation with a 500 milliseconds delay. Each task function can perform
    arbitrary logic and calculation in its body, for example, loading data or computing
    results asynchronously. However, once the task is done, it has to invoke the callback
    function to notify the queue that it has finished its task and pass back the result
    as shown on line `D`. The callback function takes two parameters: error and result;
    in this case, we pass `null` as error signaling since it has completed successfully
    with the random number in second parameter. On line `E`, we have the `load` function
    defined that leverages `d3.queue` to execute the tasks. Let''s take a closer look
    at the `load` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: D3 Queue can be instantiated using the `d3.queue` function as shown on line
    `F`. Once created, it can register any number of tasks using the `defer` function
    as shown on line `G`. In our case, we used a `for` loop to register `10` asynchronous
    random datum generation tasks in our queue as shown on line `G`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3 Queue does not provide multithreading internally as **Web Worker** offers.
    All tasks are handled synchronously; however, the task function can perform, and
    typically is designed to perform, asynchronous task as we demonstrated here. For
    more information on Web Worker, refer to [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The `d3.queue.awaitAll` function shown on line `H` is used to wait for all tasks
    to be completed. This callback function passed to the `awaitAll` function will
    only be invoked once all tasks are completed or when an error occurs (only the
    first error is captured and passed to the callback). In our example, we have to
    wait till all the 10 random data points are successfully produced before calling
    the render function to generate the visualization on line `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `d3.queue` function also takes a parameter to define the maximum concurrency
    allowed when executing tasks. If not provided, it puts no limitation on concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we covered the fundamental aspect of using D3 - binding data
    with the visual elements and how to keep them in synchronization. On top of that
    we have also covered various topics on data loading and manipulation. In next
    chapter we will introduce another fundamental concept in D3 to our readers - scales
    which powers many other higher level D3 features such as animation and shape generator
    for example.
  prefs: []
  type: TYPE_NORMAL
