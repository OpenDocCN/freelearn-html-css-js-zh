- en: Chapter 3. Dealing with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。处理数据
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Binding an array as data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组绑定为数据
- en: Binding object literals as data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象字面量绑定为数据
- en: Binding functions as data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数绑定为数据
- en: Working with arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组
- en: Filtering with data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据过滤
- en: Sorting with data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据排序
- en: Loading data from a server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: Asynchronous data loading using queue
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列进行异步数据加载
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will explore the most essential question in any data visualization
    project: how data can be represented in both programming constructs, and its visual
    metaphor. Before we start on this topic, some discussion on data visualization
    is necessary. In order to understand what data visualization is, first we will
    need to understand the difference between data and information.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨任何数据可视化项目中最重要的一个问题：数据如何以编程结构和其视觉隐喻的形式来表示。在我们开始这个话题之前，对数据可视化的一些讨论是必要的。为了理解什么是数据可视化，首先我们需要了解数据和信息的区别。
- en: '*Data consists of raw facts. The word raw indicates that the facts have not
    yet been processed to reveal their meaning...Information is the result of processing
    raw data to reveal its meaning.*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*数据由原始事实组成。单词“原始”表示这些事实尚未经过处理以揭示其含义...信息是处理原始数据以揭示其含义的结果。*'
- en: '*   -Rob P., S. Morris, and Coronel C. 2009*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*   -Rob P., S. Morris, and Coronel C. 2009*'
- en: This is how data and information are traditionally defined in the digital information
    world. However, data visualization provides a much richer interpretation of this
    definition since information is no longer the mere result of processed raw facts
    but rather a visual metaphor of the facts. As stated by *Manuel Lima*, in his
    *Information Visualization Manifesto*, design in the material world, where form
    is regarded to follow function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在数字信息世界中传统上对数据和信息的定义。然而，数据可视化提供了对这个定义的更丰富解释，因为信息不再是仅仅处理过的原始事实的结果，而是一种事实的视觉隐喻。正如*曼努埃尔·利马*在他的*信息可视化宣言*中所说，在物质世界中，形式被视为功能的追随者。
- en: 'The same dataset can generate any number of visualizations, which may lay equal
    claim in terms of validity. In a sense, visualization is more about communicating
    the creator''s insight into data than anything else. On a more provocative note,
    Card, McKinlay, and Shneiderman suggested that the practice of information visualization
    can be described as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个数据集可以生成任何数量的可视化，在有效性方面可能具有同等权利。在某种意义上，可视化更多的是关于传达创作者对数据的洞察，而不是其他任何事情。更有挑衅意味的是，Card、McKinlay和Shneiderman提出，信息可视化的实践可以这样描述：
- en: '*The use of computer-supported, interactive, visual representations of abstract
    data to amplify cognition.*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*使用计算机支持的、交互式的、抽象数据的视觉表示来增强认知。*'
- en: '* -"Card S. and Mackinly J.", and Shneiderman B. 1999*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '* -"Card S. and Mackinly J.", and Shneiderman B. 1999*'
- en: In the following sections, we will explore various techniques D3 provides to
    bridge the data with the visual domain. It is the very first step we need to take
    before we can create a *cognition amplifier* with our data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨D3提供的各种技术，以将数据与视觉领域连接起来。这是我们在能够用我们的数据创建一个*认知放大器*之前需要采取的第一个步骤。
- en: The enter-update-exit pattern
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入-更新-退出模式
- en: 'The task of matching each datum with its visual representation, for example,
    drawing a single bar for every data point you have in your dataset, updating the
    bars when the data points change, and then eventually removing the bars when certain
    data points no longer exist, seems to be a complicated and tedious task. This
    is precisely why D3 was designed, to provide an ingenious way of simplifying the
    implementation of this task. This way of defining the connection between data
    and its visual representation is usually referred to as the *enter-update-exit*
    pattern in D3\. This pattern is profoundly different from the typical *imperative
    method* most developers are familiar with. However, the understanding of this
    pattern is crucial to your effectiveness with the D3 library; and therefore, in
    this section, we will focus on explaining the concept behind this pattern. First,
    let''s take a look at the following conceptual illustration of the two domains:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配每个数据与其视觉表示的任务，例如，为数据集中每个数据点绘制一个条形图，当数据点发生变化时更新条形图，然后最终在某些数据点不再存在时删除条形图，这似乎是一个复杂且繁琐的任务。这正是
    D3 被设计出来的原因，为了提供一种巧妙的方式来简化这个任务的实现。这种定义数据与其视觉表示之间连接的方式通常被称为 D3 中的 *进入-更新-退出* 模式。这种模式与大多数开发者熟悉的典型
    *命令式方法* 深刻不同。然而，理解这个模式对于你在 D3 库中的有效性至关重要；因此，在本节中，我们将专注于解释这个模式背后的概念。首先，让我们看一下以下两个域的概念性示意图：
- en: '![The enter-update-exit pattern](img/image_03_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![进入-更新-退出模式](img/image_03_001.jpg)'
- en: Data and visual set
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和视觉集
- en: In the preceding illustration, the two circles represent two joined sets. Set
    **A** depicts your dataset, whereas set **B** represents the visual elements.
    This is essentially how D3 sees the connection between your data and visual elements.
    You might be asking how set theory will help your data visualization effort here.
    Let me explain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示意图中，两个圆圈代表两个连接的集合。集合 **A** 描述了你的数据集，而集合 **B** 代表视觉元素。这正是 D3 看待数据与视觉元素之间连接的方式。你可能想知道集合理论如何帮助你在这里的数据可视化工作中。让我来解释。
- en: First, let us consider the question *how can I find all visual elements that
    currently represent their corresponding data point?* The answer is *A∩B*; this
    denotes the intersection of sets **A** and **B**, the elements that exist in both
    Data and Visual domains.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下这个问题：*我如何找到所有当前代表其对应数据点的视觉元素？* 答案是 *A∩B*；这表示集合 **A** 和 **B** 的交集，存在于数据和视觉域中的元素。
- en: '![The enter-update-exit pattern](img/image_03_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![进入-更新-退出模式](img/image_03_002.jpg)'
- en: Update mode
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模式
- en: In the preceding diagram, the shaded area represents the intersection between
    the two sets, **A** and **B**. In D3, the `selection.data` function can be used
    to select this intersection, *A* *∩* *B*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，阴影区域代表两个集合 **A** 和 **B** 之间的交集。在 D3 中，可以使用 `selection.data` 函数来选择这个交集，*A*
    *∩* *B*。
- en: The `selection.data(data)` function, upon selection, sets up the connection
    between the data domain and visual domain, as we discussed in the previous paragraph.
    The initial selection forms the visual set **B**, whereas the data provided in
    the `data` function form dataset **A**. The return result of this function is
    a new selection (a data-bound selection) of all elements existing in this intersection.
    Now, you can invoke the modifier function on this new selection to update all
    the existing elements. This mode of selection is usually referred to as the **Update
    mode**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择时，`selection.data(data)` 函数会建立数据域和视觉域之间的连接，正如我们在上一段中讨论的那样。初始选择形成视觉集 **B**，而
    `data` 函数中提供的数据形成数据集 **A**。此函数的返回结果是所有存在于该交集中的元素的新选择（数据绑定选择）。现在，你可以在这个新选择上调用修改器函数来更新所有现有元素。这种选择模式通常被称为
    **更新模式**。
- en: 'The second question we will need to answer here is *how can I target data points
    that have not yet been visualized?* The answer is the set difference of **A**
    and **B**, denoted as *A\B*, which can be seen visually through the following
    illustration:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要回答的第二个问题是：*我如何定位尚未可视化的数据点？* 答案是 **A** 和 **B** 的集合差，表示为 *A\B*，可以通过以下示意图直观地看到：
- en: '![The enter-update-exit pattern](img/image_03_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![进入-更新-退出模式](img/image_03_003.jpg)'
- en: Enter mode
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 进入模式
- en: The shaded area in set **A** represents the data points that have not yet been
    visualized. In order to gain access to this *A\B* subset, the following functions
    need to be performed on a data-bound D3 selection (a selection returned by the
    `data` function).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 **A** 中的阴影区域表示尚未可视化的数据点。为了访问这个 *A\B* 子集，需要在数据绑定的 D3 选择（由 `data` 函数返回的选择）上执行以下函数。
- en: The `selection.data(data).enter()` function returns a new selection representing
    the *A\B* subset, which contains all the pieces of data that has not yet been
    represented in the visual domain. The regular modifier function can then be chained
    to this new selection method to create new visual elements that represent the
    given data elements. This mode of selection is simply referred to as the **Enter
    mode**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`selection.data(data).enter()` 函数返回一个新的选择，表示 *A\B* 子集，其中包含所有尚未在视觉领域中表示的数据片段。然后，常规的修改函数可以链接到这个新的选择方法，以创建表示给定数据元素的新视觉元素。这种选择模式简单地被称为
    **Enter 模式**。'
- en: The third case in our discussion covers the visual elements that exist in our
    dataset but no longer have any corresponding data element associated with them.
    You might ask how this kind of visual element can exist in the first place. This
    is usually caused by removing the elements from the dataset; that is, if you initially
    visualized all data points within your dataset, and removed some data points after
    that. Now, you have certain visual elements that are no longer representing any
    valid data point in your dataset. This subset can be discovered using an inverse
    of the Update difference, denoted as *B\A*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的第三个案例涵盖了存在于我们的数据集中的视觉元素，但不再与任何相关联的数据元素。你可能想知道这种类型的视觉元素最初是如何存在的。这通常是由于从数据集中删除元素造成的；也就是说，如果你最初在数据集中可视化了所有数据点，并在之后删除了一些数据点。现在，你有一些视觉元素不再代表数据集中的任何有效数据点。这个子集可以使用更新差异的逆运算来发现，表示为
    *B\A*。
- en: '![The enter-update-exit pattern](img/image_03_004.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![The enter-update-exit pattern](img/image_03_004.jpg)'
- en: Exit mode
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Exit 模式
- en: The shaded area in the preceding illustration represents the difference we just
    discussed. The subset can be selected using the `selection.exit` function on a
    data-bound selection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的插图中的阴影区域表示我们刚才讨论的差异。可以使用数据绑定的选择上的 `selection.exit` 函数来选择这个子集。
- en: The `selection.data(data).exit` function, when invoked on a data-bound D3 `selectioncomputes`
    a new selection which contains all visual elements that are no longer associated
    with any valid data element. As a valid D3 selection object, the modifier function
    can then be chained to this selection to update and remove these visual elements
    that are no longer required as part of our visualization. This mode of selection
    is called the **Exit mode**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据绑定的 D3 `selectioncomputes` 上调用 `selection.data(data).exit` 函数时，它会计算一个新的选择，其中包含所有不再与任何有效数据元素相关联的视觉元素。作为一个有效的
    D3 选择对象，修改函数可以链接到这个选择，以更新和删除不再作为我们可视化一部分的这些视觉元素。这种选择模式被称为 **Exit 模式**。
- en: Together, the three different selection modes cover all possible cases of interaction
    between the data and its visual domain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 三个不同的选择模式共同涵盖了数据与其视觉领域之间所有可能的交互情况。
- en: Additionally, D3 also offers a fourth selection mode that is very handy when
    you need to avoid duplicating visualization code or the so-called *DRY* up your
    code. This fourth mode is called merge mode. It can be invoked using the `selection.merge`
    function. This function merges the given selection passed to the `merge` function
    with the selection where the function is invoked and returns a new selection that
    is a union of both. In the *enter-update-exit* pattern, the `merge` function is
    commonly used to construct a selection that covers both the Enter and Update modes
    since that's where most code duplication would otherwise live.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，D3 还提供了一个第四种选择模式，当需要避免重复可视化代码或所谓的 *DRY*（Don't Repeat Yourself）代码时，这个模式非常有用。这种第四种模式被称为合并模式。可以使用
    `selection.merge` 函数调用它。此函数将传递给 `merge` 函数的给定选择与函数被调用的选择合并，并返回一个新的选择，它是两者的并集。在
    *enter-update-exit* 模式下，`merge` 函数通常用于构建一个覆盖 Enter 和 Update 模式的选择，因为那里是大多数代码重复可能存在的位置。
- en: '![The enter-update-exit pattern](img/image_03_005.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![The enter-update-exit pattern](img/image_03_005.jpg)'
- en: Merge mode
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 合并模式
- en: The shaded area in this illustration shows the data points targeted by merge
    mode that combines both Enter and Update modes, which is essentially the entire
    set A. This is very convenient since now a single chain of modifiers can be utilized
    to style both modes and thus lead to less code duplication. We will demonstrate
    how to leverage merge mode in each recipe of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本图中的阴影区域显示了由合并模式（结合了输入和更新模式）针对的目标数据点，这实际上是整个集合A。这非常方便，因为现在可以使用单个修饰符链来样式化这两种模式，从而减少代码重复。我们将在本章的每个菜谱中展示如何利用合并模式。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In software engineering, **Don't Repeat Yourself** (**DRY**) is a principle
    of software development, aimed at reducing repetition of information of all kinds
    (Wikipedia, August 2016). You can also read Mike Bostock's post on *What Makes
    Software Good?* for more insight on reasons behind this design change at [https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp](https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp)
    .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，**不要重复自己**（**DRY**）是一个软件开发原则，旨在减少各种信息重复（维基百科，2016年8月）。你还可以阅读Mike Bostock关于*什么使软件变得好？*的帖子，以了解更多关于这种设计变化背后的原因。[https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp](https://medium.com/@mbostock/what-makes-software-good-943557f8a488#.l640c13rp)
    .
- en: The *enter-update-exit* pattern is the cornerstone of any D3-driven visualization.
    In the following recipes of this chapter, we will cover the topics on how these selection
    methods can be utilized to generate data-driven visual elements efficiently and
    easily.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入-更新-退出*模式是任何由D3驱动的可视化的基石。在本章的后续菜谱中，我们将涵盖如何有效地利用这些选择方法来生成数据驱动的视觉元素。'
- en: Binding an array as data
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组绑定为数据
- en: One of the most common and popular ways to define data in D3 visualization is
    through the use of JavaScript arrays; for example, say you have multiple data
    elements stored in an array, and you want to generate corresponding visual elements
    to represent each and every one of them. Additionally, when the data array gets
    updated, you would want your visualization to reflect such changes immediately.
    In this recipe, we will accomplish this common approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3可视化中定义数据最常见和最受欢迎的方法是通过使用JavaScript数组；例如，假设你有一个存储在数组中的多个数据元素，并且你想要生成相应的视觉元素来表示它们中的每一个。此外，当数据数组更新时，你希望你的可视化能够立即反映这些变化。在本菜谱中，我们将完成这个常见的做法。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html)
    .'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/array-as-data.html)
    .'
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first and most natural solution that might come to mind is iterating through
    the data array elements and generating their corresponding visual elements on
    the page. This is definitely a valid solution, and it will work with D3; however,
    the enter-update-exit pattern we discussed in the introduction provides a much
    easier and more efficient way to generate visual elements. Let''s take a look
    at how we can do that:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可能首先想到的第一个和最自然的解决方案是遍历数据数组元素，并在页面上生成它们对应的视觉元素。这绝对是一个有效的解决方案，并且与D3一起工作；然而，我们在介绍中讨论的输入-更新-退出模式提供了一个更简单、更有效的方法来生成视觉元素。让我们看看我们如何做到这一点：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe generates the following visual output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱生成以下视觉输出：
- en: '![How to do it...](img/image_03_006.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_03_006.jpg)'
- en: Data as array
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为数组
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, data (a list of integers in this case) is stored in a simple
    JavaScript array as shown on the line `A` in the preceding code. The `render`
    function is defined on the line marked as `B` so that it can be repeatedly invoked
    to update our visualization. The selection starts on the line marked as `C`, which
    selects all `div` elements on the web page with the `h-bar` CSS class. You are
    probably wondering why we are selecting these `div` elements since they don''t
    even exist on the web page yet. This is in fact true; however, the selection at
    this point is used to define the visual set we discussed in the introduction.
    By issuing this selection, that we made in the previous line, we essentially declare
    that there should be a set of the `div.h-bar` elements on the web page to form
    our visual set. On the line marked as `D`, we invoke the `data` function on this
    initial selection to bind the array as our dataset to the to-be-created visual
    elements. Once the two sets are defined, the `enter()` function on line `E` can
    be used to select all pieces of data elements that are not yet visualized. When
    the `render` function is invoked for the very first time, it returns all elements
    in the data array, as shown in the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数据（在这种情况下是一个整数列表）存储在简单的 JavaScript 数组中，如前述代码中的第 `A` 行所示。`render` 函数在第
    `B` 行标记的位置定义，以便它可以被重复调用以更新我们的可视化。选择从标记为 `C` 的行开始，它选择网页上所有具有 `h-bar` CSS 类的 `div`
    元素。你可能想知道为什么我们要选择这些 `div` 元素，因为它们甚至还没有在网页上存在。这实际上是正确的；然而，在这个阶段的选择是用来定义我们在介绍中讨论的视觉集。通过发出我们在上一行所做的选择，我们实际上声明网页上应该有一组
    `div.h-bar` 元素来形成我们的视觉集。在第 `D` 行，我们调用初始选择上的 `data` 函数，将数组作为我们的数据集绑定到即将创建的视觉元素上。一旦定义了两个集合，第
    `E` 行的 `enter()` 函数就可以用来选择所有尚未可视化的数据元素。当 `render` 函数第一次被调用时，它返回数据数组中的所有元素，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On line `F`, a new `div` element is created and appended to the `body` element
    of each data element selected in the `enter` function; this essentially creates
    one `div` element for each datum. Finally, on line `G`, we set its CSS class to
    `h-bar`. At this point, we basically created the skeleton of our visualization,
    including the empty `div` elements. Next step is to change the visual attributes
    of our elements based on the given data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `F` 行，创建了一个新的 `div` 元素并将其附加到 `enter` 函数中选中的每个数据元素的 `body` 元素上；这实际上为每个数据创建了一个
    `div` 元素。最后，在第 `G` 行，我们将它的 CSS 类设置为 `h-bar`。到这一点，我们基本上创建了可视化的大纲，包括空的 `div` 元素。下一步是根据给定数据更改元素的可视属性。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: D3 injects a property to the DOM element named `__data__` to make data sticky
    with visual elements so when selections are made using a modified dataset, D3
    can compute the difference and intersection correctly. You can see this property
    easily if you inspect the DOM element either visually using a debugger or programmatically.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: D3 向 DOM 元素注入了一个名为 `__data__` 的属性，使数据与视觉元素粘合，因此当使用修改后的数据集进行选择时，D3 可以正确地计算差异和交集。如果你使用调试器或以编程方式检查
    DOM 元素，可以轻松地看到这个属性。
- en: '![How it works...](img/image_03_007.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_03_007.jpg)'
- en: As illustrated by the preceding screenshot, this is very useful to know when
    debugging.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，这在调试时非常有用。
- en: 'In the following code snippet, on line `H`, the merge function is invoked with
    the selection as its parameter. This function call essentially merges the enter
    selection with the update selection and returns the union of both selections,
    thus allowing us to chain modifiers for both enter and update scenarios. Without
    the merge function, we would need to repeat the code here for both enter and update
    scenarios. Then, on line `I`, we applied a dynamic style attribute `width` to
    be three times the integer value associated with each visual element, as shown
    in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，在第 `H` 行调用了合并函数，并将选择项作为其参数。这个函数调用实际上是将进入选择项与更新选择项合并，并返回两个选择项的并集，从而允许我们为进入和更新场景链式调用修饰符。如果没有合并函数，我们需要为进入和更新场景重复这段代码。然后，在第
    `I` 行，我们应用了一个动态样式属性 `width`，其值是每个视觉元素关联的整数值的三倍，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All D3 modifier functions accept this type of dynamic function to compute its
    value on the fly. This is precisely what it means to *data drive* your visualization.
    Hence, it is crucial to understand what this function is designed to achieve in
    our example. This function receives a parameter `d`, which is the datum associated
    with the current element. In our example, the first `div` bar has the value `10`
    associated as its datum, the second bar has `15`, and so on. Therefore, this function
    essentially computes a numeric value that is three times the datum for each bar
    and returns it as the element's `width` in pixels. While, on line `J`, we used
    a similar approach to change the text content of the `div` element to the datum
    value associated with each element.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有D3修饰函数都接受这种动态函数来实时计算其值。这正是“数据驱动”您的可视化的含义。因此，了解这个函数在我们例子中的设计目的是至关重要的。这个函数接收一个参数`d`，它是与当前元素关联的数值。在我们的例子中，第一个`div`条形图具有与其数据关联的值`10`，第二个条形图有`15`，依此类推。因此，这个函数本质上计算每个条形图数值的三倍，并将其作为像素宽度的元素`width`返回。而在第`J`行，我们使用了类似的方法来更改`div`元素的文本内容，将其设置为与每个元素关联的数据值。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The dynamic modifier function actually accepts two parameters, `d` and `i`.
    The first parameter `d` is the associated datum we just discussed, and `i` is
    a zero-based index number for the current element. Some recipes in the previous
    chapter relied on this index, and in the rest of this chapter, we will take look
    at other recipes that utilize this index in different ways.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 动态修饰函数实际上接受两个参数，`d`和`i`。第一个参数`d`是我们刚才讨论的关联数据，`i`是当前元素的零基于索引号。前一章的一些食谱依赖于这个索引，在本章的其余部分，我们将探讨其他利用这个索引以不同方式使用的食谱。
- en: 'The following is the raw HTML code that resulted from this update process:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新过程产生的原始HTML代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following last section, `Exit` section, is fairly simple:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下最后部分，即“退出”部分，相当简单：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The selection returned by the `exit()` function is just like any other selection.
    Therefore, although `remove` is the most common action used against the `exit`
    selection, you can also apply other modifiers or transitions to this selection.
    We will explore some of these options in later chapters
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`函数返回的选择集就像任何其他选择集一样。因此，尽管`remove`是针对`exit`选择集最常用的操作，但您也可以将其他修饰符或过渡应用到这个选择集上。我们将在后面的章节中探讨一些这些选项。'
- en: On line `K` in the preceding code snippet, the `exit()` function is called to
    compute the set difference of all visual elements that are no longer associated
    with any data. Finally, the `remove()` function is called on this selection to
    remove all the elements selected by the `exit()` function. This way, as long as
    you call the `render()` function after you change our data, you can always ensure
    that our visual representation and data are kept synchronized.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段的第`K`行，调用了`exit()`函数来计算不再与任何数据关联的所有视觉元素集合的差集。最后，在这个选择集上调用`remove()`函数来移除由`exit()`函数选中的所有元素。这样，只要您在更改我们的数据后调用`render()`函数，您就可以始终确保我们的视觉表示和数据保持同步。
- en: 'Now, let''s implement the following last block of code as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实现最后一段代码：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On line `L`, a simple anonymous function was created to remove the top element
    in the data array using the `shift` function while appending a random integer
    to the data array using the `push()` function every 1.5 seconds. Once the data
    array is updated, the `render()` function is called again to update our visualization
    to keep it synchronized with the new dataset. This is what gives our example its
    animated bar chart look.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`L`行，创建了一个简单的匿名函数，使用`shift`函数移除数据数组中的顶部元素，并使用`push()`函数每1.5秒向数据数组中添加一个随机整数。一旦数据数组更新，再次调用`render()`函数来更新我们的可视化，以保持与新的数据集同步。这就是我们的例子具有动画条形图外观的原因。
- en: Binding object literals as data
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象字面量绑定到数据
- en: With a more complex visualization, each element we have in a data array might
    not be a primitive integer value or a string, but a JavaScript object itself.
    In this recipe, we will discuss how this more complex data structure can be leveraged
    to drive your visualization using D3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数据可视化，数据数组中的每个元素可能不仅是一个原始整数或字符串，而是一个JavaScript对象本身。在本食谱中，我们将讨论如何利用这种更复杂的数据结构来使用D3驱动您的可视化。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html)
    .'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/object-as-data.html)
    .'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'JavaScript object literal is probably the most common data structure you will
    encounter when you load data sources on the Web. In this recipe, we will take
    a look at how these JavaScript objects can be leveraged to generate rich visualization.
    The following code illustrates how to do it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网络上加载数据源时，JavaScript 对象字面量可能是你遇到的最常见的数 据结构。在本示例中，我们将探讨如何利用这些 JavaScript 对象生成丰富的可视化。以下代码展示了如何实现：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This recipe generates  the following visu alization:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例生成了以下可视化：
- en: '![How to do it...](img/image_03_008.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/image_03_008.jpg)'
- en: Data as object
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为对象
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe is built on top of the previous recipe, so if you are not familiar
    with the fundamental enter-update-exit selection pattern, please take a look at
    the previous recipe first.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例建立在之前的示例之上，所以如果你不熟悉基本的 enter-update-exit 选择模式，请先查看之前的示例。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, instead of simple integers as shown in the previous recipe,
    now our data array is filled with objects (refer to the line marked as `A` with
    an arrow left to it). Each data object contains two attributes: `width` and `color`,
    that are both integers in this case:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，与上一个示例中显示的简单整数不同，现在我们的数据数组填充了对象（参看带有箭头的标记为 `A` 的行）。每个数据对象包含两个属性：`width`
    和 `color`，在这个例子中这两个属性都是整数：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On line `B`, we have a complicated-looking `color` scale defined: `...` `.range(["#add8e6",
    "blue"]); // <- B` `...` Scales, including color scale, will be discussed in depth
    in the next chapter, so for now let us just assume this is a scale function we
    can use to produce CSS-compatible color code, given some integer input value.
    This is sufficient for the purpose of this recipe.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `B` 行，我们定义了一个看起来很复杂的 `color` 比例：`...` `.range(["#add8e6", "blue"]); // <-
    B` `...` 包括颜色比例在内的比例将在下一章中深入讨论，所以现在让我们假设这是一个我们可以使用它来生成 CSS 兼容颜色代码的比例函数，给定一些整数输入值。这对于本示例的目的来说已经足够了。
- en: 'The major difference between this recipe and the previous one is the way the
    data is handled as shown on line `C` in the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例相比，主要区别在于处理数据的方式，如下面的代码片段中第 `C` 行所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see in the preceding code snippet, in this recipe, the datum associated
    with each visual element is actually an object, not an integer. Therefore, we
    can access the `d.width` attribute on line `D`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，在本示例中，与每个视觉元素关联的实际上是对象，而不是整数。因此，我们可以在第 `D` 行访问 `d.width` 属性。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your object has functions of its own, you can also access them here in a
    dynamic modifier function. This is a convenient way to add some data-specific
    helper functions in your data source. However, beware that since dynamic functions
    are usually invoked numerous times during visualization, the function you rely
    on should be implemented as efficiently as possible. If this is not possible,
    then it is best to preprocess your data before binding it to your visualization
    process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的对象有自己的函数，你还可以在这里通过动态修改函数访问它们。这是在数据源中添加一些特定数据辅助函数的方便方式。然而，请注意，由于动态函数通常在可视化过程中被多次调用，因此你依赖的函数应该尽可能高效地实现。如果这不可能，那么在将数据绑定到可视化过程之前预处理你的数据是最好的选择。
- en: 'Similarly, on line `E` in the following code snippet, the `background-color`
    style can be computed using the `d.color` attribute with the color scale we defined
    earlier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下面的代码片段中第 `E` 行，可以使用我们之前定义的颜色比例的 `d.color` 属性来计算 `background-color` 样式：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, on line `F`, we set the text of each bar to display its width.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在第 `F` 行，我们将每个条形的文本设置为显示其宽度。
- en: This recipe demonstrates how JavaScript objects can easily be bound to visual
    elements using exactly the same method discussed in the previous recipe. This
    is one of the most powerful capabilities of the D3 library; it allows you to reuse
    the same pattern and method to handle different types of data, whether simple
    or complex. We will see more examples on this topic in the next recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何使用与上一示例中讨论的完全相同的方法轻松地将 JavaScript 对象绑定到视觉元素。这是 D3 库最强大的功能之一；它允许您重用相同的模式和方
    法来处理不同类型的数据，无论是简单还是复杂。我们将在下一示例中看到更多关于这个主题的例子。
- en: Binding functions as data
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为数据绑定
- en: One of the benefits of D3's excellent support for functional-style JavaScript
    programming is that it allows functions to be treated as data as well. This particular
    feature can offer some very powerful capabilities under certain circumstances.
    This is a more advanced recipe. Don't worry about it if you are new to D3 and
    have some difficulty understanding it at first. Over time, this functional programming
    usage will become natural to you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: D3对函数式JavaScript编程的优秀支持之一是它允许将函数视为数据。这种特定功能在某些情况下可以提供一些非常强大的功能。这是一个更高级的菜谱。如果你是D3的新手，并且一开始理解起来有些困难，请不要担心。随着时间的推移，这种函数式编程的使用将变得自然。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html)
    .'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/function-as-data.html)
    .'
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will explore the possibility of binding functions as data
    to your visual elements. This capability is extremely powerful and flexible, if
    used correctly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨将函数作为数据绑定到您的视觉元素上的可能性。如果正确使用，这种功能非常强大且灵活：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This preceding code produces the following bar chart:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了以下条形图：
- en: '![How to do it...](img/image_03_009.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_03_009.jpg)'
- en: Data as function
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为函数
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we chose to visualize the output of formula `15 + x * x` using
    a series of vertical bars, each of them annotated with its representing integral
    value. This visualization adds a new bar to the right of the previous one every
    one and a half seconds. We can of course implement this visualization using the
    techniques we discussed in the previous two recipes, where we generated an array
    of integers using the formula, and then just appended a new integer from *n* to
    *n+1* every 1.5 seconds before re-rendering the visualization. However, in this
    recipe, we decided to take a more functional approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们选择使用一系列垂直条来可视化公式`15 + x * x`的输出，每个条形上都有其代表的积分值。这种可视化每1.5秒在之前的条形右侧添加一个新的条形。当然，我们可以使用我们在前两个菜谱中讨论的技术来实现这种可视化，其中我们使用公式生成一个整数数组，然后在每1.5秒重新渲染可视化之前，从*n*到*n+1*追加一个新的整数。然而，在这个菜谱中，我们决定采取更函数式的方法。
- en: 'This time we started with an empty data array on line `A`. On line `B`, a simple
    `datum` function was defined to calculate the result of this formula *15+x^2*.
    Then, on line `C`, another function `newData` was created to generate the current
    dataset, which contains *n+1* references to the `next` function. The following
    is the code for a functional data definition:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在行`A`上从一个空的数据数组开始。在行`B`上，定义了一个简单的`datum`函数来计算公式`15+x^2`的结果。然后，在行`C`上，创建了一个名为`newData`的另一个函数来生成当前数据集，该数据集包含对`next`函数的*n+1*个引用。以下是一个函数数据定义的代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This seems to be a strange setup to achieve our goal. Let''s take a look at
    how we can leverage all these functions in our visualization code. On line `D`,
    we bound our data to a selection of `div` elements, just as we did in the previous
    recipes. However, this time, the data is not an array, but rather the `newData`
    function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置似乎很奇怪，但为了达到我们的目标。让我们看看我们如何利用所有这些函数在我们的可视化代码中。在行`D`，我们将数据绑定到`div`元素的选择上，就像我们在之前的菜谱中所做的那样。然而，这次数据不是一个数组，而是`newData`函数：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'D3 is pretty flexible when it comes to data. If you provide a function to the
    `data` function, D3 will simply invoke the given function and use the returned
    value of this function as a parameter of the `data` function. In this case, the
    data being returned by the `newData` function is an array of function references.
    As the result of this, now in our dynamic modifier function, on lines `E` and
    `G`, the datum `d` that is being passed into these functions is actually a reference
    to the `next` function, as shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数据时，D3非常灵活。如果你向`data`函数提供一个函数，D3将简单地调用给定的函数，并使用该函数返回的值作为`data`函数的参数。在这种情况下，`newData`函数返回的数据是一个函数引用数组。因此，现在在我们的动态修改函数中，在行`E`和`G`上，传递给这些函数的`datum`
    `d`实际上是对`next`函数的引用，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a reference to a function, `d` can now be invoked with index `i` as the parameter,
    which in turn will generate the output of the formula needed for our visualization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数的引用，`d`现在可以用索引`i`作为参数调用，这将生成我们可视化所需的公式输出。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In JavaScript, functions are special objects, so semantically this is exactly
    the same as binding objects as data. Additionally data can also be considered
    as functions. Constant values such as integers can be thought of as an identity
    function that simply returns what it receives with no modification made.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是特殊对象，因此从语义上讲，这与绑定对象作为数据完全相同。此外，数据也可以被视为函数。例如，整数等常量值可以被视为一个恒等函数，它只是返回它接收的内容，而不进行任何修改。
- en: This technique might not be the most commonly used technique in visualization;
    but when used properly, it is extremely flexible and powerful, especially when
    you have a fluid dataset.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可能不是可视化中最常用的技术；但使用得当，它非常灵活且强大，尤其是在您有一个流动的数据集时。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Datum function typically needs to be *idempotent* to make sense. Idempotence
    is the property of being able to apply the same function with the same inputs
    multiple times without changing the result beyond the initial application. For
    more detail on idempotence, visit [http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)
    .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数据函数通常需要是*幂等的*才有意义。幂等性是指能够多次应用相同的函数和相同的输入，而不会改变结果（除了初始应用之外）。有关幂等的更多详细信息，请访问[http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)。
- en: Working with arrays
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数组
- en: Most of our data is stored in arrays, and we spend a lot of our effort working
    with arrays to format and restructure data. This is why D3 provides a rich set
    of array-oriented utilities functions, making this task a lot easier. In this
    recipe, we will explore some of the most common and helpful utilities in this
    aspect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分数据都存储在数组中，我们花费大量精力处理数组以格式化和重构数据。这就是为什么D3提供了一套丰富的面向数组的实用函数，使得这项任务变得容易得多。在本配方中，我们将探讨这方面的某些最常见和有用的实用函数。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html)
    .'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/working-with-array.html)。'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code example shows some of the most common and helpful array
    utility functions offered by the D3 library and their effects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了D3库提供的某些最常见和有用的数组实用函数及其效果：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code produces the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: D3 provides a variety of utility functions to help perform operations on JavaScript
    arrays. Most of them are pretty intuitive and straightforward; however, there
    are a few intrinsic ones. We will discuss them briefly in this section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: D3提供了一系列实用函数来帮助在JavaScript数组上执行操作。其中大多数都很直观且简单；然而，也有一些是内在的。我们将在本节中简要讨论它们。
- en: 'Given our array as `[3, 2, 11, 7, 6, 4, 10, 8, 15]`, the following will be
    its utility function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的数组`[3, 2, 11, 7, 6, 4, 10, 8, 15]`，以下将是其实用函数：
- en: '`d3.min`: This function retrieves the smallest element, that is, `2`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.min`：此函数检索最小元素，即`2`。'
- en: '`d3.max`: This function retrieves the largest element, that is, `15`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.max`：此函数检索最大元素，即`15`。'
- en: '`d3.extent`: This function retrieves both the smallest and the largest elements,
    that is, `[2, 15]`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.extent`：此函数检索最小和最大元素，即`[2, 15]`。'
- en: '`d3.sum`: This function retrieves the addition of all elements in the array,
    that is, `66`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.sum`：此函数检索数组中所有元素的总和，即`66`。'
- en: '`d3.medium`: This function finds the medium, that is, `7`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.median`：此函数找到中位数，即`7`。'
- en: '`d3.mean`: This function calculates the mean value, that is, `7.33`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.mean`：此函数计算平均值，即`7.33`。'
- en: '`d3.ascending`/`d3.descending`: The `d3` object comes with a built-in comparator
    function that you can use to sort the JavaScript array:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.ascending`/`d3.descending`：`d3`对象包含一个内置的比较函数，您可以使用它来对JavaScript数组进行排序：'
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`d3.quantile`: This function calculates the quantile on an array that is already
    sorted in an ascending order, for example, the quantile of `0.25` will be `4`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.quantile`：此函数计算已按升序排序的数组上的分位数，例如，`0.25`的分位数将是`4`。'
- en: '`d3.deviation`: This function calculates the standard deviation of the array,
    in our case that will be `4.18`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.deviation`：此函数计算数组的标准差，在我们的例子中将是`4.18`。'
- en: '`d3.bisect`: This function finds an insertion point that comes after (to the
    right of) any existing element of an already-sorted array, that is, bisect (array,
    `6`) will produce `4`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.bisect`：此函数在已排序数组中找到一个插入点，该点位于任何现有元素之后（右侧），即`bisect`（数组，`6`）将产生`4`。'
- en: '`d3.nest`: D3''s nest function can be used to build an algorithm that transforms
    a flat array-based data structure into a hierarchical nested structure that is
    particularly suitable for some types of visualization. D3''s nest function can
    be configured using the key function chained to `nest`, as seen on lines `A` and
    `B`:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.nest`：D3的`nest`函数可以用来构建一个算法，将基于平铺数组的结构转换为适合某些类型可视化的层次嵌套结构。D3的`nest`函数可以通过连接到`nest`的键函数进行配置，如`A`和`B`行所示：'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Multiple `key` functions can be provided to generate multiple levels of nesting.
    In our case, the nesting consists of two levels, first by the `type` amount and
    then by the `tip` amount, as demonstrated in the following output:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以提供多个`key`函数以生成多个嵌套级别。在我们的例子中，嵌套由两个级别组成，首先是按`type`金额，然后是按`tip`金额，如下面的输出所示：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, the `entries()` function is used to supply the flat array-based dataset
    as shown on line `C`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`entries()`函数提供与`C`行上显示的基于平铺数组的数据集。
- en: Filtering with data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据过滤
- en: Imagine you need to filter D3 selection based on the associated data elements
    so that you can hide or show different subdatasets based on the user's input.
    D3 selection provides a filter function to perform this kind of data-driven filtering.
    In this recipe, we will show you how this can be leveraged to filter visual elements
    in a data-driven fashion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要根据关联的数据元素过滤D3选择，以便可以根据用户的输入隐藏或显示不同的子数据集。D3选择提供了一个过滤函数来执行这种数据驱动的过滤。在这个菜谱中，我们将向您展示如何利用这种方式以数据驱动的方式过滤视觉元素。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html)
    .'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-filter.html)
    .'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following example code shows how data-based filtering can be leveraged
    to highlight different visual elements based on its categorization:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了如何利用数据过滤来根据其分类突出显示不同的视觉元素：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code generates the following visual output once you click on
    the **Dining** button:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击**Dining**按钮时，前面的代码将生成以下视觉输出：
- en: '![How to do it...](img/image_03_010.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_03_010.jpg)'
- en: Data-based Filtering
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数据过滤
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we have a dataset that consists of a list of personal expense
    records with `expense` and `category` as attributes, which is shown on the block
    of code marked as `A`. On lines `B`, `C`, and `D`, a set of horizontal bars (HTML
    `div`) was created using the standard enter-update-exit pattern to represent the
    expense records. So far, this recipe is similar to the *Binding object literals
    as data* recipe. Now let''s take a look at line `E`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有一个数据集，它包含一系列个人消费记录，以`expense`和`category`作为属性，这显示在标记为`A`的代码块中。在`B`、`C`和`D`行，使用标准的enter-update-exit模式创建了一组水平条形图（HTML
    `div`），以表示消费记录。到目前为止，这个菜谱与*绑定对象字面量作为数据*菜谱类似。现在让我们看看`E`行：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'D3''s `selection.filter` function takes a function as its parameter. It applies
    the function against every element in the existing selection. The given function
    for `filter` takes two parameters with a hidden `this` reference:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: D3的`selection.filter`函数接受一个函数作为其参数。它将函数应用于现有选择中的每个元素。`filter`提供的函数有两个参数，具有隐藏的`this`引用：
- en: '`d`: It is the datum associated with the current element'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：它是与当前元素关联的数据'
- en: '`i`: It is a zero-based index for the current element'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：它是当前元素的零基索引'
- en: '`this`: This has the hidden reference points to the current DOM element'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`：这具有对当前DOM元素的隐藏引用点'
- en: D3's `selection.filter` function expects the given function to return a Boolean
    value. If the returned value is `true`, the corresponding element will be included
    into the new selection that is returned by the `filter` function. In our example,
    the `filter` function essentially selects all bars that match the user-selected
    category and applies a CSS class `selected` to each one of them. This method provides
    you a powerful way to filter and generate data-driven sub-selection, which you
    can further manipulate or dissect to generate focused visualization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: D3的`selection.filter`函数期望给定的函数返回一个布尔值。如果返回值为`true`，则相应的元素将被包含在由`filter`函数返回的新选择集中。在我们的例子中，`filter`函数实际上选择了所有与用户选择的类别匹配的条形，并将CSS类`selected`应用于它们。这种方法为你提供了一种强大的方式来过滤和生成数据驱动的子选择集，你可以进一步操作或分解以生成专注的可视化。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: D3's `selection.filter` function treats the returned value using JavaScript
    as *truthy* and *falsy tests*, thus not exactly expecting a strict Boolean value.
    What this means is that `false`, `null`, `0`, `""`, `undefined`, and **NaN** (**not
    a number**) are all treated as `false`, while other things are considered `true`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: D3的`selection.filter`函数将返回的值作为JavaScript中的*真值*和*假值*测试处理，因此并不期望严格的布尔值。这意味着`false`、`null`、`0`、`""`、`undefined`和**NaN**（非数字）都被视为`false`，而其他东西被认为是`true`。
- en: Sorting with data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据排序
- en: In many cases, it is desirable to sort your visual elements according to the
    data they represent so that you can highlight the significance of different elements
    visually. In this recipe, we will explore how this can be achieved in D3.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，根据所代表的数据对视觉元素进行排序是可取的，这样你可以通过视觉方式突出不同元素的重要性。在本食谱中，我们将探讨如何在D3中实现这一点。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html)
    .'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/data-sort.html)
    .'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take a look at how data-driven sorting and further manipulation can
    be performed using D3\. In this example, we will sort the bar chart we created
    in the previous recipe based on either expense (width) or category, using a user''s
    input:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用D3执行数据驱动的排序和进一步的操作。在这个例子中，我们将根据用户输入对之前食谱中创建的条形图进行排序，基于支出（宽度）或类别：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This preceding code generates sorted horizontal bars as shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了如下截图所示的排序后的水平条形：
- en: '![How to do it...](img/image_03_011.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_03_011.jpg)'
- en: Data-based Sorting
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据的排序
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we set up a simple row-based visualization (in lines `B`, `C`,
    and `D`) of some simulated personal expense records containing two attributes,
    `expense` and `category`, that are defined on line `A`. This is almost exactly
    the same as the previous recipe and quite similar to what we have done in the
    *Binding object literals as data* recipe. Once the basics are done, we then select
    all existing bars on line `E` and perform sorting using D3''s `selection.sort`
    function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们设置了一个简单的基于行的可视化（在`B`、`C`和`D`行），包含两个属性`expense`和`category`，这些属性在`A`行定义。这几乎与之前的食谱完全相同，并且与我们之前在*绑定对象字面量作为数据*食谱中所做的非常相似。一旦完成基本操作，我们就在`E`行选择所有现有的条形，并使用D3的`selection.sort`函数进行排序：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `selection.sort` function accepts a comparator function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`selection.sort`函数接受一个比较函数：'
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `comparator` function receives two data elements: `a` and `b`, to compare,
    returning either a negative, positive, or zero value. If the value is negative,
    `a` will be placed before `b`; if positive, `a` will be placed after `b`; otherwise,
    `a` and `b` are considered equal and the order is *arbitrary*. The `sort()` function
    returns a new selection with all elements sorted in an order that is determined
    by the specified comparator function. The newly returned selection can then be
    manipulated further to generate the desired visualization.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`comparator` 函数接收两个数据元素：`a` 和 `b`，进行比较，返回一个负数、正数或零值。如果值为负数，则 `a` 将被放置在 `b`
    之前；如果为正数，则 `a` 将被放置在 `b` 之后；否则，`a` 和 `b` 被视为相等，顺序是任意的。`sort()` 函数返回一个新的选择集，其中所有元素按指定的比较函数确定的顺序排序。然后可以进一步操作这个新返回的选择集以生成所需的可视化。'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As `a` and `b` are placed arbitrarily when they are equal, D3 `selection.sort`
    is not guaranteed to be stable; however, it is guaranteed to be consistent with
    your browser's built-in `sort` method on arrays.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a`和`b`在它们相等时被任意放置，D3 `selection.sort`不能保证是稳定的；然而，它保证与浏览器内置的数组`sort`方法一致。
- en: Loading data from a server
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: It is probably very rare that you will only be visualizing static local data.
    The power of data visualization usually lays on the ability to visualize dynamic
    data typically generated by a server-side program. Since this is a common use
    case, D3 comes with some handy helper functions to make this task as easy as possible.
    In this recipe, we will see how a remote dataset can be loaded dynamically and
    will update an existing visualization once it is loaded.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能很少只可视化静态本地数据。数据可视化的力量通常在于能够可视化由服务器端程序生成的动态数据。由于这是一个常见用例，D3提供了一些方便的辅助函数，以尽可能简化这项任务。在本菜谱中，我们将了解如何动态加载远程数据集，并在加载后更新现有可视化。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html)
    .'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/asyn-data-load.html)
    .'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the code example of the `asyn-data-load.html` file, we will load data dynamically
    from the server on the user''s request, and once the data is loaded, we will also
    update our visualization to reflect the new expanded dataset. The following is
    the code for its implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`asyn-data-load.html`文件的代码示例中，我们将根据用户请求从服务器动态加载数据，一旦数据加载完成，我们还将更新我们的可视化以反映新的扩展数据集。以下是其实现代码：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is what our `data.json` file looks like:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的`data.json`文件看起来像：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This recipe generates the following visual output after you click on the **Load
    Data from JSON feed** button once:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击**从JSON源加载数据**按钮一次后，此菜谱将生成以下视觉输出：
- en: '![How to do it...](img/image_03_012.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_03_012.jpg)'
- en: Data Loading from server
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we created a `render` function to generate a horizontal bar-based
    visualization very similar to what we did in the last couple of recipes. The `load`
    function is defined on line `C` that responds to the user''s click on the **Load
    Data from JSON feed** button, which loads the data from a separate file (`data.json`)
    served by the server. This is achieved using the `d3.json` function as shown on
    line `F`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个`render`函数来生成一个基于水平条的可视化，这与我们在上一两个菜谱中所做的工作非常相似。`load`函数定义在行`C`，它响应用户点击**从JSON源加载数据**按钮，从服务器加载来自单独文件（`data.json`）的数据。这是通过行`F`上显示的`d3.json`函数实现的：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since loading a remote dataset from a JSON file could take some time, it is
    performed asynchronously. Once loaded, the dataset will be passed to the given
    anonymous callback function defined on line `D`. In this function, we simply pass
    the newly loaded dataset to the `render` function in order to generate the visualization.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从JSON文件加载远程数据集可能需要一些时间，因此它是异步执行的。一旦加载完成，数据集将被传递给在行`D`上定义的匿名回调函数。在这个函数中，我们只需将新加载的数据集传递给`render`函数，以便生成可视化。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT,
    HTML, and XML data a simple task.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: D3还提供了类似的功能，使得加载CSV、TSV、TXT、HTML和XML数据变得简单。
- en: If a more customized and specific control is required, the `d3.request` function
    can be used to further customize the MIME type and request headers. Behind the
    scenes, `d3.json` and `d3.csv` both use `d3.request` to generate the actual request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更定制化和具体的控制，可以使用`d3.request`函数进一步自定义MIME类型和请求头。在幕后，`d3.json`和`d3.csv`都使用`d3.request`来生成实际请求。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'MIME media type are a two part identifier for file format transmitted on the
    internet. The common registered top-level types are: application, text, audio,
    image, video.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MIME媒体类型是互联网上传输的文件格式的两部分标识符。常见的注册顶级类型包括：应用程序、文本、音频、图像、视频。
- en: Of course, this is by no means the only way to load remote data from the server.
    D3 does not dictate how data should be loaded from the remote server. You are
    free to use your favorite JavaScript libraries, such as jQuery or Zepto.js, to
    issue an Ajax request and load a remote dataset.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这绝对不是从服务器加载远程数据的唯一方法。D3 并不规定如何从远程服务器加载数据。您可以使用您喜欢的 JavaScript 库，例如 jQuery
    或 Zepto.js，发起 Ajax 请求并加载远程数据集。
- en: Asynchronous data loading using queue
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列进行异步数据加载
- en: In this recipe, we will demonstrate another very useful technique commonly used
    to process or generate data in large data visualization projects. It is usually
    necessary in complex visualization project to load and merge multiple datasets
    from different sources before proceeding to visualizing. The challenge in this
    kind of asynchronous loading is the difficulty in waiting to know when all datasets
    have been successfully loaded since only then the visualization can begin. D3
    provides a very convenient `queue` interface to help organize these types of asynchronous
    tasks and helps you coordinate among them, which is the focus of this recipe.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示另一种在大型数据可视化项目中常用且非常有用的技术，用于处理或生成数据。在复杂的可视化项目中，通常在可视化之前，有必要从不同的来源加载和合并多个数据集。这种异步加载的挑战在于难以知道何时所有数据集都已成功加载，因为只有在那时可视化才能开始。D3
    提供了一个非常方便的 `queue` 接口来帮助组织这些类型的异步任务，并帮助您协调它们，这也是本菜谱的焦点。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html)
    .'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter3/queue.html)
    .'
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the code example of the `queue.html` file, we will simulate loading and
    merging multiple data points using the `setTimeout` function. The `setTimeout`
    function executes the given function after a set period of delay; in our case,
    we set the delay to 500 milliseconds:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `queue.html` 文件的代码示例中，我们将使用 `setTimeout` 函数模拟加载和合并多个数据点。`setTimeout` 函数在设置的一段时间延迟后执行给定的函数；在我们的情况下，我们将延迟设置为
    500 毫秒：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This recipe generates the following output after clicking on the **Generate
    Data Set** button:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**生成数据集**按钮后，此菜谱将生成以下输出：
- en: '![How to do it...](img/image_03_013.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_03_013.jpg)'
- en: Asynchronous Data Generation using D3 Queue
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 D3 队列进行异步数据生成
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have a pretty standard `render` function that generates
    horizontal bar visualization using the standard enter-update-exit pattern shown
    on lines `B` and `C`. This pattern by now should be very familiar to you. However,
    the data generation part, which is also our focus here, is a bit different in
    this recipe. On line `D`, we have a simple random datum generation function called
    `generateDatum(callback)`, which receives a single parameter callback. This is
    a very standard template for task function in D3 queue interface, as shown in
    the following code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有一个相当标准的 `render` 函数，它使用标准的 enter-update-exit 模式生成水平条形可视化，如第 `B` 行和
    `C` 行所示。到目前为止，这个模式应该非常熟悉。然而，数据生成部分，这也是我们在这里关注的焦点，在这个菜谱中略有不同。在第 `D` 行，我们有一个简单的随机数据生成函数
    `generateDatum(callback)`，它接收一个参数 callback。这是 D3 队列接口中任务函数的一个非常标准的模板，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this function, we use the `setInterval` function to simulate asynchronous
    data generation with a 500 milliseconds delay. Each task function can perform
    arbitrary logic and calculation in its body, for example, loading data or computing
    results asynchronously. However, once the task is done, it has to invoke the callback
    function to notify the queue that it has finished its task and pass back the result
    as shown on line `D`. The callback function takes two parameters: error and result;
    in this case, we pass `null` as error signaling since it has completed successfully
    with the random number in second parameter. On line `E`, we have the `load` function
    defined that leverages `d3.queue` to execute the tasks. Let''s take a closer look
    at the `load` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用 `setInterval` 函数以 500 毫秒的延迟模拟异步数据生成。每个任务函数可以在其主体中执行任意逻辑和计算，例如异步加载数据或计算结果。然而，一旦任务完成，它必须调用回调函数来通知队列它已完成其任务，并传递回结果，如第
    `D` 行所示。回调函数接受两个参数：错误和结果；在这种情况下，我们传递 `null` 作为错误信号，因为它是通过第二个参数中的随机数成功完成的。在第 `E`
    行，我们定义了 `load` 函数，该函数利用 `d3.queue` 来执行任务。让我们更详细地看看 `load` 函数：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: D3 Queue can be instantiated using the `d3.queue` function as shown on line
    `F`. Once created, it can register any number of tasks using the `defer` function
    as shown on line `G`. In our case, we used a `for` loop to register `10` asynchronous
    random datum generation tasks in our queue as shown on line `G`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `d3.queue` 函数创建 D3 队列，如第 `F` 行所示。一旦创建，它可以使用 `defer` 函数注册任意数量的任务，如第 `G`
    行所示。在我们的例子中，我们使用 `for` 循环在我们的队列中注册了 `10` 个异步随机数据生成任务，如第 `G` 行所示。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: D3 Queue does not provide multithreading internally as **Web Worker** offers.
    All tasks are handled synchronously; however, the task function can perform, and
    typically is designed to perform, asynchronous task as we demonstrated here. For
    more information on Web Worker, refer to [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
    .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: D3 队列内部不提供多线程，如 **Web Worker** 所提供的。所有任务都是同步处理的；然而，任务函数可以执行，并且通常设计为执行异步任务，正如我们在这里所展示的。有关
    Web Worker 的更多信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)。
- en: The `d3.queue.awaitAll` function shown on line `H` is used to wait for all tasks
    to be completed. This callback function passed to the `awaitAll` function will
    only be invoked once all tasks are completed or when an error occurs (only the
    first error is captured and passed to the callback). In our example, we have to
    wait till all the 10 random data points are successfully produced before calling
    the render function to generate the visualization on line `I`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `H` 行显示的 `d3.queue.awaitAll` 函数用于等待所有任务完成。传递给 `awaitAll` 函数的回调函数将在所有任务完成或发生错误时（仅捕获并传递给回调的第一个错误）被调用。在我们的例子中，我们必须等待所有
    10 个随机数据点成功生成后，才能调用渲染函数在第 `I` 行生成可视化。
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `d3.queue` function also takes a parameter to define the maximum concurrency
    allowed when executing tasks. If not provided, it puts no limitation on concurrency.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.queue` 函数还接受一个参数来定义执行任务时允许的最大并发数。如果没有提供，则不对并发数进行限制。'
- en: In this chapter we covered the fundamental aspect of using D3 - binding data
    with the visual elements and how to keep them in synchronization. On top of that
    we have also covered various topics on data loading and manipulation. In next
    chapter we will introduce another fundamental concept in D3 to our readers - scales
    which powers many other higher level D3 features such as animation and shape generator
    for example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 D3 的基本方面——将数据绑定到视觉元素以及如何保持它们的同步。在此基础上，我们还涵盖了数据加载和处理的各种主题。在下一章中，我们将向读者介绍
    D3 的另一个基本概念——刻度（scales），它为许多其他高级 D3 功能提供支持，例如动画和形状生成器等。
