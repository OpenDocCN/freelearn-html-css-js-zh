- en: Node.js Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing Node.js applications, you must learn about Node.js modules and
    packages. Modules and packages are the building blocks for breaking down your
    application into smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CommonJS and ES2015 module specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ES2015/2016/2017 coding practices in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ES6 module format in Node.js code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Node.js finds modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The npm package management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are the basic building blocks for constructing Node.js applications.
    A Node.js module encapsulates functions, hiding details inside a well-protected
    container, and exposing an explicitly-declared list of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two module formats that we must consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The traditional Node.js format based on the CommonJS standard has been used
    since Node.js was created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ES2015/2016 a new format, ES6 Modules, has been defined with a new `import`
    keyword. ES6 modules will be (or is) supported in all JavaScript implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because ES6 modules are now the standard module format, the Node.js **Technical
    Steering Committee** (**TSC**) is committed to first-class support for ES6 modules.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen modules in action in the previous chapter. Every JavaScript
    file we use in Node.js is itself a module. It's time to see what they are and
    how they work. We'll start with CommonJS modules and then quickly bring in ES6
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ls.js` example in Chapter 2, *Setting up Node.js*, we wrote the following
    code to pull in the `fs` module, giving us access to its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `require` function searches for the named module, loading the module definition
    into the Node.js runtime, and making its functions available. In this case, the
    `fs` object contains the code (and data) exported by the `fs` module. The `fs`
    module is part of the Node.js core and provides filesystem functions.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring `fs` as `const`, we have a little bit of assurance against making
    coding mistakes that would modify the object holding the module reference.
  prefs: []
  type: TYPE_NORMAL
- en: In every Node.js module, the `exports` object within the module is the interface
    exported to other code. Anything assigned to a field of the `exports` object is
    available to other pieces of code, and everything else is hidden. By the way,
    this object is actually `module.exports`. The `exports` object is an alias for
    `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: The `require` function and `module.exports` objects both come from the CommonJS
    specification. ES6 modules have similar concepts, but a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a brief example of this before diving into the details. Ponder
    over the `simple.js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one variable, `count`, which is not attached to the `exports` object,
    and a function, `next`, which is attached. Now, let''s use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `exports` object in the module is the object that is returned by `require('./simple')`.
    Therefore, each call to `s.next` calls the `next` function in `simple.js`. Each
    returns (and increments) the value of the local variable, `count`. An attempt
    to access the private field, `count`, shows it's unavailable from outside the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything (functions or objects) assigned as a field of `exports` (as known as `module.exports`)
    is available to other code outside the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects not assigned to `exports` are not available to code outside the module,
    unless the module exports those objects via another mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how Node.js solves the global object problem of browser-based JavaScript.
    The variables that look like they're global variables are only global to the module
    containing that variable. These variables are not visible to any other code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a taste for modules, let's take a deeper look.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS and ES2015 module formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js's module implementation is strongly inspired by, but not identical to,
    the CommonJS module specification. The differences between them might only be
    important if you need to share code between Node and other CommonJS systems.
  prefs: []
  type: TYPE_NORMAL
- en: Among the changes in ES2015 is a standard module format meant for use everywhere.
    It has some interesting features, and by existing everywhere it should advance
    the state of JavaScript. Since it is incompatible with the CommonJS/Node.js module
    system, adopting ES2015 modules in Node.js means reworking our practices and accepted
    norms.
  prefs: []
  type: TYPE_NORMAL
- en: As a practical matter, Node.js programmers will be dealing with both module
    formats for some time during a transition period. Our long-term goal should be
    to adopt ES2015 modules across the board. The Node.js platform is slated to bring
    in support for ES2015 modules in Node.js 10\. As of Node.js 8.5, the feature is
    available by setting a command-line flag.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS/Node.js module format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a couple of examples of this module format, with the `simple.js`
    example, and the programs we examined in Chapter 2, *Setting up Node.js*. So let's
    take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules are stored in files with the extension `.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CommonJS module is a synchronous operation. That means that when the
    `require('modulename')` function call returns, the module has been located and
    completely read into memory and is ready to go. The module is cached in memory
    so that subsequent `require('modulename')` calls return immediately, and all return
    the exact same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js modules provide a simple encapsulation mechanism to hide implementation
    details while exposing an API. Modules are treated as if they were written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thus, everything within the module is contained within an anonymous private
    namespace context. This is how the global object problem is resolved; everything in
    a module that looks global is actually contained within this private context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects and functions can be exposed from a CommonJS module by means of two
    free variables Node.js inserts into this private context: `module` and `exports`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `module` object contains several fields that you might find useful. Refer
    to the online Node.js documentation for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `exports` object is an alias of the `module.exports` field. This means
    that the following two lines of code are equivalent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Your code can break the alias between the two if you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not do that, because `exports` will no longer be equivalent to `module.exports`.
    If your intent is to assign a single object or function to be what''s returned
    by `require`, do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Some modules do export a single function because that's how the module author
    envisioned delivering the desired functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js package format is derived from the CommonJS module system ([http://commonjs.org](http://commonjs.org)).
    When developed, the CommonJS team aimed to fill a gap in the JavaScript ecosystem.
    At that time, there was no standard module system, making it trickier to package
    JavaScript applications. The `require` function, the `exports` object, and other
    aspects of Node.js modules come directly from the CommonJS `Modules/1.0` spec.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 module format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 modules are a new module format designed for all JavaScript environments.
    While Node.js has had a good module system for its whole existence, browser-side
    JavaScript has not. That left the browser-side community with either relying on
    the `<script>` tag, or using non-standardized solutions. For that matter, traditional
    Node.js modules were never standardized, outside of the CommonJS effort. Therefore,
    ES6 modules stand to be a big improvement for the entire JavaScript world, by
    getting everyone on the same page with a common module format and mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The side effect is that the Node.js community needs to start looking at, learning
    about, and adopting the ES2015 module format.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 modules are referred to by Node.js with the extension `.mjs`. When it came
    to implementing the new module format, the Node.js team determined that they could
    not support both CommonJS and ES6 modules with the `.js` extension. The `.mjs`
    extension was decided as the solution, and you may see tongue-in-cheek references
    to *Michael Jackson Script* for this file extension.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting detail is that ES6 modules load asynchronously. This may not
    have an impact on Node.js programmers, except that this is part of the rationale
    behind requiring the new `.mjs` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `simple2.mjs` in the same directory as the `simple.js` example
    that we looked at earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'ES6 items exported from a module are declared with the `export` keyword. This
    keyword can be put in front of any top-level declaration, such as variable, function,
    or class declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of this is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent of both is essentially the same: to make a function, or other object,
    available to code outside the module. A statement such as `export function next()`
    is a named export, meaning the exported thing has a name, and that code outside
    the module uses that name to access the object. As we see here, named `exports`
    can be functions or objects, and they may also be class definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `export default` can be done once per module, and is the `default` export
    from the module. The `default` export is what code outside the module accesses
    when using the module object itself, rather than when using one of the exports
    from the module.
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare something, such as the `squared` function, and then export
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how to use this ES2015 module. Create a `simpledemo.mjs` file
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statement does what it means: it imports objects exported from
    a module. This version of the `import` statement is most similar to a traditional
    Node.js `require` statement, meaning that it creates an object through which you
    access the objects exported from the module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the code executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As of Node.js 8.5, the new module format is available behind an option flag
    as shown here. You're also presented with this nice warning that it's an experimental
    feature. Accessing the `default` export is accomplished by accessing the field
    named `default`. Accessing an exported value, such as the `meaning` field, is
    done without parentheses because it is a value and not a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to see a different way to import objects from a module, create another
    file, named `simpledemo2.mjs`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each imported object is its own thing rather than being attached
    to another object. Instead of writing `simple2.next()`, you simply write `next()`.
    The `as` clause is a way to declare an alias, if nothing else so you can use the
    default export. We already used an `as` clause earlier, and it can be used in
    other instances where you wish to provide an alias for the value being exported
    or imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js modules can be used from ES2015 `.mjs` code. Create a file named `ls.mjs`,
    containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You cannot, however, `require` an ES2015 module into regular Node.js code. The
    lookup algorithm for ES2015 modules is different, and as we mentioned earlier,
    ES2015 modules are loaded asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another wrinkle is handling the `fs.promises` submodule.  We are using that
    submodule in the example, but how?    This `import` statement does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This fails as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That leaves us with this construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the script gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to note about ES2015 module code is that `import` and `export`
    statements must be top-level code. Even putting an `export` inside a simple block
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While there are a few more details about ES2015 modules, these are their most
    important attributes.
  prefs: []
  type: TYPE_NORMAL
- en: JSON modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js supports using `require(''/path/to/file-name.json'')` to import a JSON
    file. It is equivalent to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the JSON file is read synchronously, and the text is parsed as JSON.
    The resultant object is available as the object exported from the module. Create
    a file named `data.json`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a file named `showdata.js`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It will execute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `util.inspect` function is a useful way to present an object in an easy-to-read
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting ES6 modules on older Node.js versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While support for ES6 modules arrived as an experimental feature in Node.js
    8.5, there are two ways to use these modules on earlier Node.js implementations.
  prefs: []
  type: TYPE_NORMAL
- en: One method is to use the Babel transpiler to rewrite ES6 code so it can execute
    on older Node.js versions. For an example, see [https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b](https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b).
  prefs: []
  type: TYPE_NORMAL
- en: 'The better method is the `esm` package in the Node.js registry. Simply do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To use this module, one simply invokes `require('esm')` once, and ES6 modules
    are retrofitted into Node.js.  The `--require` flag automatically loads the named
    module.  Without rewriting the code, we can selectively use the esm module with
    this the command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates retrofitting ES6 modules into older Node.js releases. 
    To successfully execute the `ls.mjs` example   we must have support for `async`/`await`
    functions, and arrow functions.  Since Node.js 6.x does not support either, the
    `ls.mjs` example will fail, and will necessitate rewriting such code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b](https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b). 
    That article describes an older release of the `esm` module, at the time named
    `@std/esm`.'
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating module-level encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key attribute of modules is encapsulation. The objects that are not exported
    from the module are private to the module, and cannot be accessed from code outside
    the module. To reiterate, modules are treated as if they were written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This JavaScript idiom defines an anonymous private scope. Anything declared
    within that scope cannot be accessed by code outside the scope. That is, unless
    some code makes object references available to other code outside this private
    scope. That''s what the `module.exports` object does: it is a mechanism for the
    module author to expose object references from the module. Other code can then
    access resources inside the module in a controlled fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: The top-level variables inside a module look like they exist in the global scope.
    Instead of being truly Global, they're safely private to the module and are completely
    inaccessible to other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a practical demonstration of that encapsulation. Create
    a file named `module1.js`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a file named `module2.js`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it as follows (you must have Node.js already installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This artificial example demonstrates encapsulation of the values in `module1.js` from
    those in `module2.js`. The `A` and `B` values in `module1.js` don't overwrite
    `A` and `B` in `module2.js` because they're encapsulated within `module1.js`.
    The `values` function in `module1.js` does allow code in `module2.js` access to
    the values; however, `module2.js` cannot directly access those values. We can
    modify the object `module2.js` received from `module1.js`. But doing so does not
    change the values within `module1.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and loading CommonJS and JSON modules using require
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have talked about several types of modules: CommonJS, JSON, ES2015, and
    native code modules. All but the ES2015 modules are loaded using the `require`
    function. That function has a very powerful and flexible algorithm for locating
    modules within a directory hierarchy. This algorithm, coupled with the npm package
    management system, gives the Node.js platform a lot of power and flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: File modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CommonJS and ES2015 modules we've just looked at are what the Node.js documentation
    describes as a **file module**. Such modules are contained within a single file,
    whose filename ends with `.js`, `.mjs`, `.json`, or `.node`. The latter are compiled
    from C or C++ source code, or even other languages such as Rust, while the former
    are of course written in JavaScript or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We've already looked at several examples of using these modules, as well as
    the difference between the CommonJS format traditionally used in Node.js, and
    the new ES2015 modules that are now supported.
  prefs: []
  type: TYPE_NORMAL
- en: Modules baked into Node.js binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some modules are pre-compiled into the Node.js binary. These are the core Node.js
    modules documented on the Node.js website at [https://nodejs.org/api/index.html](https://nodejs.org/api/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: They start out as source code within the Node.js build tree. The build process
    compiles them into the binary so that the modules are always available.
  prefs: []
  type: TYPE_NORMAL
- en: Directories as modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module can contain a whole directory structure full of stuff. Stuff here is
    a technical term referring to internal file modules, data files, template files,
    documentation, tests, assets, and more. Once stored within a properly constructed
    directory structure, Node.js will treat these as a module that satisfies a `require('moduleName')`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: This may be a little confusing because the word *module* is being overloaded
    with two meanings. In some cases, a module is a file, and in other cases, a module is
    a directory containing one or more file modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, a directory-as-module contains a `package.json` file. This file
    contains data about the module (known as package) that Node.js uses while loading
    the module. The Node.js runtime recognizes these two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If this `package.json` file is in a directory named `awesomelib`, then `require('./awesomelib')`
    will load the file module in `./awesomelib/lib/awesome.js`.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no `package.json`, then Node.js will look for either `index.js`
    or `index.node`. In such a case, `require('./awesomelib')` will load the file
    module in `./awesomelib/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, the directory module can easily contain other file modules.
    The module that's initially loaded would simply use `require('./anotherModule')` one
    or more times to load other, private modules.
  prefs: []
  type: TYPE_NORMAL
- en: The npm package management system can recognize a lot more data in the `package.json` file.
    That includes the package name, its author, the home page URL, the issue-queue
    URL, package dependencies, and more. We'll go over this later.
  prefs: []
  type: TYPE_NORMAL
- en: Module identifiers and pathnames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, the module name is a pathname, but with the file extension
    removed. Earlier, when we wrote `require('./simple')`, Node.js knew to add `.js`
    to the filename and load in `simple.js`. Similarly, Node.js would recognize `simple.json`
    or `simple.node` as the filename legitimately satisfying `require('./simple')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of module identifiers: relative, absolute, and top-level:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relative module identifiers**: These begin with `./` or `../` and absolute
    identifiers begin with `/`. The module name is identical with POSIX filesystem
    semantics. The resultant pathname is interpreted relative to the location of the
    file being executed. That is, a module identifier beginning with `./` is looked
    for in the current directory, whereas one starting with `../` is looked for in
    the parent directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Absolute module identifiers**: These begin with`/`and are, of course, looked
    for in the root of the filesystem, but this is not a recommended practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top-level module identifiers**: These begin with none of those strings and
    are just the module name, or else `module-name/path/to/module`. These must be
    stored in a `node_modules` directory, and the Node.js runtime has a nicely flexible
    algorithm for locating the correct `node_modules` directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `module-name/path/to/module` specifiers, what will be loaded
    is a module `path/to/module` within the top-level module named `module-name`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The baked-in modules are specified using top-level module names
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The search begins in the directory containing the file calling `require()`.
    If that directory contains a `node_modules` directory, which then contains either
    a matching directory module or a matching file module, then the search is satisfied.
    If the local `node_modules` directory does not contain a suitable module, it tries
    again in the parent directory, and it will continue upward in the filesystem until
    it either finds a suitable module or it reaches the root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, with a `require` call in `/home/david/projects/notes/foo.js`, the
    following directories will be consulted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/david/projects/notes/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/david/projects/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/david/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the module is not found through this search, there are global folders in
    which modules can be located. The first is specified in the `NODE_PATH` environment
    variable. This is interpreted as a colon-delimited list of absolute paths similar
    to the `PATH` environment variable. On Windows, the elements of `NODE_PATH` are
    of course separated by semicolons. Node.js will search those directories for a
    matching module.
  prefs: []
  type: TYPE_NORMAL
- en: The `NODE_PATH` approach is not recommended, because of surprising behavior
    which can happen if people are unaware that this variable must be set. If a specific
    module located in a specific directory referenced in `NODE_PATH` is required for
    proper function, and the variable is not set, the application will likely fail.
    As the Twelve-Factor Application model suggests, it is best for all dependencies
    to be explicitly declared, and with Node.js that means listing all dependencies
    in the `package.json` so that `npm` or `yarn` can manage the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This variable was implemented before the module resolution algorithm just described
    was finalized. Because of that algorithm, `NODE_PATH` is largely unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three additional locations that can hold modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$HOME/.node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$HOME/.node_libraries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$PREFIX/lib/node`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, `$HOME` is what you expect, the user's home directory, and `$PREFIX`
    is the directory where Node.js is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Some are beginning to recommend against using global modules. The rationale
    is the desire for repeatability and deployability. If you've tested an app, and
    all its code is conveniently located within a directory tree, you can copy that
    tree for deployment to other machines. But, what if the app depended on some other
    file that was magically installed elsewhere on the system? Will you remember to
    deploy such files?
  prefs: []
  type: TYPE_NORMAL
- en: An example of application directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the filesystem structure of a typical Node.js Express
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5c0a49b-762d-4675-9c45-5bcd4afb99e0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an Express application (we'll start using Express in [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml),
    *Your First Express Application*) containing a few modules installed in the `node_modules`
    directory. One of those, Express, has its own `node_modules` directory containing
    a couple of modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `app.js` to load `models-sequelize/notes.js`, it uses the following `require`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a relative module identifier, where the pathname is resolved relative
    to the directory containing the file making the reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to do the reverse in `models-sequelize/notes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is a relative module identifier, this time resolved relative to
    the subdirectory containing `models-sequelize/notes.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any reference to a top-level module identifier will first look in the `node_modules`
    directory shown here. This directory is populated from the dependencies listed
    in the `package.json`, as we''ll see in a few pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All of these are typical modules included in an Express application. Most of
    them are readily visible in the screenshot shown earlier. What's loaded is the
    main file in the corresponding subdirectory of `node_modules`, for example, `node_modules/express/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: But the application cannot directly reference the dependencies of the Express
    module that are in its internal `node_modules` directory. The module search algorithm
    only moves upward in the filesystem; it does not descend into subsidiary directory
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: One side effect of the upward search direction is the handling of conflicting
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose two modules (modules A and B) listed a dependency on the same module
    (C)?  In the normal case, the two dependencies on module C could be handled by
    the same instance of that module. As we'll see in a few pages, npm's dependency
    list in `package.json` can use loose or precise version number references. Depending
    on the current version number for module C, modules A and B may, or may not, be
    in agreement as to which version to use. If they do not agree, npm can arrange
    the module installation such that both module A and B get the version of module
    C they depend on, without either stepping on the other. If both are agreeable
    with the same module C instance, only one copy will be installed, but if they
    disagree then npm will install two copies. The two copies will be located such
    that the module search algorithm will cause each module to find the correct version
    of module C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a concrete example to clarify what was just said. In the screenshot
    earlier, you see two instances of the `cookie` module. We can use npm to query
    for all references to this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This says the `cookie-parser` module depends on version 0.1.3 of `cookie`, while
    Express depends on version 0.1.5\. How does npm avoid problems with these two
    conflicting versions?  By putting one inside the `node_modules` directory inside
    the `express` module. This way, when *Express* refers to this module, it will
    use the `0.1.5` instance in its own `node_modules` directory, while the `cookie-parser`
    module will use the `0.1.3` instance in the top-level `node_modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and loading ES6 modules using import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `import` statement is used to load ES6 modules, and it only works inside
    an ES6 module. Because ES6 modules are loaded asynchronously, the `require()`
    statement cannot load ES6 modules. As we said earlier, ES6 modules are recognized
    by Node.js by the `.mjs` extension.  The ECMAScript TC-39 committee has (or plans
    to) officially register that file extension with the recognized authorities so
    that regular tools will recognize both file extensions as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module specifier one hands to the `import` statement is interpreted as
    a URL. For the time being, Node.js will only accept `file:` URL because of the
    security implications of loading modules over the Internet. Because it''s a URL,
    some characters such as `:`, `?`, `#`, or `%` must receive special treatment.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These are valid module specifiers where `?search` and `#hash` have the sort
    of meaning you'd expect in a URL. So long as Node.js only supports `file:` URL
    for `import` statements, we cannot make use of that feature, but we have to keep
    it in mind and avoid using these strings in module URL.
  prefs: []
  type: TYPE_NORMAL
- en: One can install custom module loader hooks that could conceivably use those
    URL parts for some purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The module search algorithm is similar to what we described for `require`. If
    the specifier begins with `./`, `../`, or `/`, the specifier is interpreted as
    a pathname. Otherwise, it is interpreted as a top-level module similar to the
    `require` statement, with one big difference. The `import` statement will not
    search for a global module. This is frowned on, but if one must use a global module,
    that can be accomplished with a symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: For documentation, see [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html).
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid CommonJS/Node.js/ES6 module scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone over the format for CommonJS/Node.js modules, the format for ES6
    modules, and the algorithm for locating and importing both. The last thing to
    cover is those hybrid situations where our code will use both module formats at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a practical matter, ES6 modules are very new to the Node.js platform, and
    therefore we have a large body of existing code written as CommonJS/Node.js modules.
    Many tools in the Node.js market have implementation dependencies on the CommonJS
    format. This means we''ll be facing situations where ES6 modules will need to
    use CommonJS modules, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS module loads other CommonJS modules with `require()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CommonJS module cannot load ES6 modules—except for two methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic import, also known as `import()`, can load an ES6 module as an asynchronous
    operation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@std/esm` package supplies a `require()` function with one that can load
    ES6 modules as an asynchronous operation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 modules load other ES6 modules with `import`, with the full semantics of
    the `import` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 modules load CommonJS modules using `import`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, out of the box, three of the scenarios are directly supported. The
    fourth is supported with a workaround module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ES6 module loads a CommonJS module, its `module.exports` object is
    exposed as the `default` export of the module. This means your code uses this
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely similar to using a CommonJS module in another CommonJS module.
    You are simply transliterating the `require()` call into an `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic imports with import()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 modules do not cover all the requirements to fully replace Node.js/CommonJS
    modules. One of the missing capabilities is being addressed with the Dynamic Import
    feature currently on its way through the TC-39 committee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for dynamic imports landed in Node.js 9.7\. See the documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use dynamic imports to solve an issue in Chapter 7, *Data Storage and
    Retrieval*, about dynamically choosing the module to load.  In normal usage of
    the `require()` statement, can use a simple string literal to specify the module
    name.  But it is also possible to use a string literal to compute the module name,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We used this technique in earlier editions of this book to dynamically choose
    between several implementations of the same model API. The ES6 `import` statement
    does not support anything but a simple string literal, and therefore cannot compute
    the module specifier like this example.
  prefs: []
  type: TYPE_NORMAL
- en: With dynamic imports, we have an `import()` function where the module specifier
    is a regular string, letting us make a similar dynamic choice of module. Unlike
    the `require()` function, which is synchronous, `import()` is asynchronous, and
    returns a Promise. Hence, it's not a direct replacement for `require()` in that
    it's not terribly useful as a top-level function. You'll see how to use it in Chapter
    7, *Data Storage and Retrieval*.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important feature it brings is that CommonJS modules can use
    `import()` to load an ES6 module.
  prefs: []
  type: TYPE_NORMAL
- en: The import.meta feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new feature, `import.meta`, is making its way through the TC-39 committee,
    and is being implemented for Node.js 10.x. It is an object existing within the
    scope of an ES6 module providing some metadata about the module. See [https://github.com/tc39/proposal-import-meta](https://github.com/tc39/proposal-import-meta).
  prefs: []
  type: TYPE_NORMAL
- en: A partial implementation, supporting just `import.meta.url`, has landed in the
    Node.js source. Its use requires the `--harmony-import-meta` command-line flag.
    The content of `import.meta.url` is a fully qualified `file:` URL for the current
    module, such as `file:///Users/david/chap10/notes/app.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: Where this becomes important is that ES6 modules do not support the `__dirname`,
    `__filename`, and other global variables used historically in Node.js modules.
    The `__dirname` variable is routinely used to read in resource data from files
    sitting in the package directory. It is intended that for such cases, one parses
    the directory name out of `import.meta.url`.
  prefs: []
  type: TYPE_NORMAL
- en: npm - the Node.js package management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in Chapter2, *Setting **up **Node.js*, npm is a package management
    and distribution system for Node.js. It has become the de facto standard for distributing
    modules (packages) for use with Node.js. Conceptually, it's similar to tools such
    as `apt-get` (Debian), `rpm`/`yum` (Red Hat/Fedora), `MacPorts` (macOS), `CPAN`
    (Perl), or `PEAR` (PHP). Its purpose is publishing and distributing Node.js packages
    over the Internet using a simple command-line interface. With npm, you can quickly
    find packages to serve specific purposes, download them, install them, and manage
    packages you've already installed.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` application extends on the package format for Node.js, which in turn
    is largely based on the CommonJS package specification. It uses the same `package.json`
    file that's supported natively by Node.js, but with additional fields to build
    in additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The npm package format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An npm package is a directory structure with a `package.json` file describing
    the package. This is exactly what was referred to earlier as a directory module,
    except that npm recognizes many more `package.json` tags than Node.js does. The
    starting point for npm''s `package.json` are the CommonJS Packages/1.0 specification.
    The documentation for npm''s `package.json` implementation is accessed using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic `package.json` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The file is in JSON format, which, as a JavaScript programmer, you should be
    familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important tags are `name` and `version`. The name will appear in URLs
    and command names, so choose one that''s safe for both. If you desire to publish
    a package in the public `npm` repository, it''s helpful to check whether a particular
    name is already being used at [http://npmjs.com](http://npmjs.com) or with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `main` tag is treated the same as we discussed in the previous section on
    directory modules. It defines which file module will be returned when invoking
    `require('packageName')`. Packages can contain many modules within themselves
    and they can be listed in the `modules` list.
  prefs: []
  type: TYPE_NORMAL
- en: Packages can be bundled as tar-gzip archives (tarballs), especially to send
    them over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A package can declare dependencies on other packages. That way, npm can automatically
    install other modules required by the module being installed. Dependencies are
    declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` and `keyword` fields help people find the package when searching
    in an npm repository ([https://www.npmjs.com/](https://www.npmjs.com/)). Ownership
    of a package can be documented in the `homepage`, `author`, or `contributors`
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Some `npm` packages provide executable programs meant to be in the user''s
    `PATH`. These are declared using the `bin` tag. It''s a map of command names to
    the script that implements that command. The command scripts are installed into
    the directory containing the node executable using the name given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `directories` tag describes the package directory structure. The `lib`
    directory is automatically scanned for modules to load. There are other directory
    tags for binaries, manuals, and documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The script tags are script commands run at various events in the life cycle
    of the package. These events include `install`, `activate`, `uninstall`, `update`,
    and more. For more information about script commands, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We've already used the scripts feature when showing how to set up Babel. We'll
    use these later for automating the build, test, and execution processes.
  prefs: []
  type: TYPE_NORMAL
- en: This was only a taste of the npm package format; see the documentation (`npm
    help json`) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Finding npm packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `npm` modules are retrieved over the internet from the public package
    registry maintained on [http://npmjs.com](http://npmjs.com). If you know the module
    name, it can be installed simply by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But what if you don't know the module name? How do you discover the interesting
    modules? The website [http://npmjs.com](http://npmjs.com) publishes a searchable
    index of the modules in that registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The npm package also has a command-line search function to consult the same
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da103ddf-0088-4106-b1d3-7c9e1a79bc9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, upon finding a module, it''s installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing a module, you may want to see the documentation, which would
    be on the module''s website. The `homepage` tag in `package.json` lists that URL.
    The easiest way to look at the `package.json` file is with the `npm view` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `npm view` to extract any tag from `package.json`, like the following,
    which lets you view just the `homepage` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Other fields in the `package.json` can be viewed by simply giving the desired
    tag name.
  prefs: []
  type: TYPE_NORMAL
- en: Other npm commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main `npm` command has a long list of subcommands for specific package management
    operations. These cover every aspect of the life cycle of publishing packages
    (as a package author), and downloading, using, or removing packages (as an npm
    consumer).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the list of these commands just by typing `npm` (with no arguments).
    If you see one you want to learn more about, view the help information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Installing an npm package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `npm install` command makes it easy to install packages upon finding the
    one of your dreams, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The named module is installed in `node_modules` in the current directory. The
    specific version installed depends on any version number listed on the command
    line, as we see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package by version number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Version number matching in npm is powerful and flexible. The same sort of version
    specifiers used in `package.json` dependencies can also be used with the `npm
    install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The last two are what they sound like. You can specify `express@4.16.2` to target
    a precise version, or `express@">4.1.0 < 5.0"` to  target a range of Express V4
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version match specifiers include these choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exact version match**: 1.2.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At least version N**: >1.2.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Up to version N**: <1.2.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Between two releases**: >=1.2.3 <1.3.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@tag` attribute is a symbolic name such as `@latest`, `@stable`, or `@canary`.
    The package owner assigns these symbolic names to specific version numbers, and
    can reassign them as desired. The exception is `@latest`, which is updated whenever
    a new release of the package is published.
  prefs: []
  type: TYPE_NORMAL
- en: For more documentation, run these commands: `npm help json` and `npm help npm-dist-tag`.
  prefs: []
  type: TYPE_NORMAL
- en: Global package installs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some instances you want to install a module globally, so that it can be
    used from any directory. For example, the Grunt or Gulp build tools are widely
    useful, and conceivably you will find it useful if these tools are installed globally.
    Simply add the `-g` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get an error, and you''re on a Unix-like system (Linux/Mac), you may
    need to run this with `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A global install is most important for those packages which install executable
    commands. We'll get into this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a local package install lands in `node_modules`, where does a global package
    install land?  On a Unix-like system it lands in `PREFIX/lib/node_modules`, and
    on Windows it lands in `PREFIX/node_modules`. In this case PREFIX means the directory
    where Node.js is installed. You can inspect the location of this directory like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm used by Node.js for the `require` function automatically searches
    this directory for packages if the package is not found elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that ES6 modules do not support global packages.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding global module installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some in the Node.js community now frown on installing a package globally. One
    rationale exists in the Twelve Factor model. Namely, a software project is more
    reliable if all its dependencies are explicitly declared. If a build tool such
    as Grunt is required, but is not explicitly declared in `package.json`, the users
    of the application would have to receive instructions to install Grunt, and they
    would have to follow those instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Users being users, they might skip over the instructions, fail to install the
    dependency, and then complain the application doesn't work. Surely most of us
    have done that once or twice.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended to avoid this potential problem by installing everything locally
    via one mechanism—the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining package dependencies with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, the `npm install` command by itself installs the packages
    listed in the `dependencies` section of `package.json`. This is easy and convenient.
    Simply by listing all the dependencies, it's quick and easy to install the dependencies
    required for using the package. What happens is npm looks in `package.json` for
    the `dependencies` or `devDependencies` field, and it will automatically install
    the mentioned packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage the dependencies manually by editing `package.json`. Or you
    can use npm to assist you with editing the dependencies. You can add a new dependency
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, npm will add a `dependencies` tag to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, when your application is installed, `npm` will automatically also install
    that package along with any `dependencies` listed by that package.
  prefs: []
  type: TYPE_NORMAL
- en: The `devDependencies` are modules used during development. That field is initialized
    the same as above, but with the `--save-dev` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when an `npm` install is run, modules listed in both `dependencies` and `devDependencies` are
    installed. Of course, the purpose for having two lists is to not install the `devDependencies` in
    some cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This installs only the modules listed in `dependencies` and none of the `devDependencies` modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the Twelve-Factor application model, it's suggested that we explicitly identify
    the dependencies required by the application. This way we can reliably build our
    application, knowing that we've tested against a specific set of dependencies
    that we've carefully identified. By installing exactly the dependencies against
    which the application has been tested, we have more confidence in the application.
    On the Node.js platform, npm gives us this dependencies section, including a flexible
    mechanism to declare compatible package versions by their version number.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically updating package.json dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With npm@5 (also known as npm version 5), one change was that it''s no longer
    required to add `--save` to the `npm install` command. Instead, `npm` by default
    acts as if you ran the command with `--save`, and will automatically add the dependency
    to your `package.json`. This is meant to simplify using `npm`, and it is arguably
    more convenient that `npm` now does this. At the same time it can be very surprising
    and inconvenient for `npm` to go ahead and modify `package.json` for you. The
    behavior can be disabled by using the `--no-save` flag. This behavior can be permanently
    disabled using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `npm config` command supports a long list of settable options for tuning
    behavior of npm. See `npm help config` for the documentation, and `npm help 7
    config` for the list of options.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs by updating package dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bugs exist in every piece of software. An update to the Node.js platform may
    break an existing package, as might an upgrade to packages used by the application.
    Your application may trigger a bug in a package it uses. In these and other cases,
    fixing the problem might be as simple as updating a package dependency to a later
    (or earlier) version.
  prefs: []
  type: TYPE_NORMAL
- en: First identify whether the problem exists in the package or in your code. After
    determining it's a problem in another package, investigate whether the package
    maintainers have already fixed the bug. Is the package hosted on GitHub or another
    service with a public issue queue? Look for an open issue on this problem. That
    investigation will tell you whether to update the package dependency to a later
    version. Sometimes, it will tell you to revert to an earlier version; for example,
    if the package maintainer introduced a bug that doesn't exist in an earlier version.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will find that the package maintainers are unprepared to issue
    a new release. In such a case, you can fork their repository and create a patched
    version of their package.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to fixing this problem is **pinning** the package version number
    to one that''s known to work. You might know that version 6.1.2 was the last release
    against which your application functioned, and that starting with version 6.2.0
    your application breaks. Hence, in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This freezes your dependency to the specific version number. You're free, then,
    to take your time updating your code to work against later releases of that module.  Once
    your code is updated, or the upstream project is updated, change the dependency
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to host a version of the package somewhere outside of the
    npm repository. This is covered in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Packages that install commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some packages install command-line programs. A side effect of installing such
    packages is a new command that you can type at the shell prompt or use in shell
    scripts. An example is the hexy program that we briefly used in Chapter 2, *Setting
    up Node.js*. Another example is the widely used Grunt or Gulp build tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `package.json` file in such packages specifies the command-line tools that
    are installed. The command can be installed to one of two places:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Install**: It is installed either to a directory such as `/usr/local`,
    or to the `bin` directory where Node.js was installed. The `npm bin -g` command
    tells you the absolute pathname for this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local Install**: To `node_modules/.bin` in the package where the module is
    being installed. The `npm bin` command tells you the absolute pathname for this
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run the command, simply type the command name at a shell prompt. Except there's
    a little bit of configuration required to make that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the PATH variable to handle commands installed by modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typing the full pathname is not a user-friendly requirement to execute the command.
    We want to use the commands installed by modules, and we want a simple process
    for doing so. Meaning, we must add an appropriate value in the `PATH` variable,
    but what is it?
  prefs: []
  type: TYPE_NORMAL
- en: For global package installations, the executable lands in a directory that is
    probably already in your `PATH` variable, like `/usr/bin` or `/usr/local/bin`.
    Local package installations are what require special handling. The full path for
    the `node_modules/.bin` directory varies for each project, and obviously it won't
    work to add the full path for every `node_modules/.bin` directory to your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `./node_modules/.bin` to the `PATH` variable (or, on Windows, `.\node_modules\.bin`)
    works great. Any time your shell is in the root of a Node.js project, it will
    automatically find locally-installed commands from Node.js packages.
  prefs: []
  type: TYPE_NORMAL
- en: How we do this depends on the command shell you use, and your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Unix-like system the command shells are `bash` and `csh`. Your `PATH`
    variable would be set up in one of these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The next step is adding the command to your login scripts so the variable is
    always set. On `bash`, add the corresponding line to your `~/.bashrc`, and on
    `csh` add it to your `~/.cshrc`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the PATH variable on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows, this task is handled through a system-wide settings panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a75f2b97-76d6-4507-82e1-45df40c66272.png)'
  prefs: []
  type: TYPE_IMG
- en: This pane of the System Properties panel is found by searching for `PATH` in
    the Windows Settings screen. Click on the Environment Variables button, then select
    the Path variable, and finally click on the Edit button. In the screen here click
    the New button to add an entry to this variable, and enter `.\node_modules\.bin` as
    shown. You'll have to restart any open command shell windows. Once you do, the
    effect will be as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding modifications to the PATH variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you don't want to add these variables to your `PATH` at all times? 
    The `npm-path` module may be of interest. This is a small program that computes
    the correct `PATH` variable for your shell and operating system. See the package
    at  [https://www.npmjs.com/package/npm-path](https://www.npmjs.com/package/npm-path).
  prefs: []
  type: TYPE_NORMAL
- en: Updating outdated packages you've installed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coder codes, updating their package, leaving you in their dust unless you
    keep up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out if your installed packages are out of date, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The report shows the current npm packages, the currently-installed version,
    as well as the current version in the `npm` repository. Updating the outdated
    packages is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Installing packages from outside the npm repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As awesome as the npm repository is, we don''t want to push everything we do
    through their service. This is especially true for internal development teams
    who cannot publish their code for all the world to see. While you can rent or
    install a private npm repository, there''s another way. Packages can be installed
    from other locations. Details about this are in `npm help package.json` in the `dependencies`
    section. Some examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: You can specify any URL that downloads a tarball, that is, a `.tar.gz` file.
    For example, GitHub or GitLab repositories can easily export tarball URL. Simply
    go to the Releases tab to find them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git URL**: Similarly, any Git repository can be accessed with the right URL.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**GitHub Shortcut**: For GitHub repositories you can list just the repository
    specifier, such as `expressjs/express`.  A tag or a commit can be referenced using
    `expressjs/express#tag-name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local filesystem**: You can install from a local directory using a URL like
    this:  `file:../../path/to/dir`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a new npm package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to create a new package, you can create the `package.json` file
    by hand or you can get npm's help. The `npm init` command leads you through a
    little dialog to get starting values for the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get through the questions, the `package.json` file is written to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect to have to edit that file considerably before publishing to the npm
    repository. A few fields help give a good impression to folks looking at the package
    listing on `npmjs.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: Link to the home page, and issue queue URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords, so it can be linked with other similar packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good description that helps folks understand the purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good `README.md` file so folks can read some documentation right away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring Node.js version compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important that your Node.js software runs on the correct version of Node.js. 
    The primary reason being when new features are added to the platform.  You'll
    want to use those new features, whether it is the async functions added in 8.x
    or the ES Modules supported added in 10.x.  We need a way to declare the Node.js
    version required to run our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dependency is declared in `package.json` using the `engines` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, uses the same version number matching scheme discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an npm package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All those packages in the npm repository came from people like you with an idea
    of a better way of doing something. It is very easy to get started with publishing
    packages. Online docs can be found at [https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages).
  prefs: []
  type: TYPE_NORMAL
- en: You first use the `npm adduser` command to register yourself with the npm repository.
    You can also sign up with the website. Next, you log in using the `npm login`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, while sitting in the package root directory, use the `npm publish`
    command. Then, stand back so that you don't get stampeded by the crush of thronging
    fans. Or, maybe not. There are almost 600,000 packages in the repository, with
    almost 400 packages added every day. To get yours to stand out, you will require
    some marketing skill, which is another topic beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly specifying package dependency version numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One feature of the Twelve-Factor methodology is step two, explicitly declaring
    your dependencies. We've already touched on this, but it's worth reiterating and
    to seeing npm makes this easy to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Step one of the Twelve-Factor methodology is ensuring that your application
    code is checked into a source code repository. You probably already know this,
    and even have the best of intentions to ensure that everything is checked in.
    With Node.js, each module should have its own repository rather than putting every
    single last piece of code in one repository.
  prefs: []
  type: TYPE_NORMAL
- en: Each module can then progress on its own timeline. A breakage in one module
    is easy to back out by changing the version dependency in `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: This gets us to Twelve-Factor step two. There are two aspects of this step,
    one of which is the package versioning that we discussed previously. The next
    is explicitly declaring version numbers, which can be declared in `dependencies`
    and `devDependencies` sections of `package.json`. This ensures that everyone on
    the team is on the same page, developing against the same versions of the same
    modules. When it's time to deploy to testing, staging, or production servers,
    and the deployment script runs `npm install` or `npm update`, the code will use
    a known version of the module that everyone tested against.
  prefs: []
  type: TYPE_NORMAL
- en: The lazy way of declaring dependencies is putting `*` in the version field.
    That uses the latest version in the npm repository. Maybe this will work, until
    one day the maintainers of that package introduce a bug. You'll type `npm update`,
    and all of a sudden your code doesn't work. You'll head over to the GitHub site
    for the package, look in the issue queue, and possibly see that others have already
    reported the problem you're seeing. Some of them will say that they've pinned
    on the previous release until this bug is fixed. What that means is their `package.json`
    file does not depend on `*` for the latest version, but on a specific version
    number before the bug was created.
  prefs: []
  type: TYPE_NORMAL
- en: Don't do the lazy thing, do the smart thing.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect of explicitly declaring dependencies is to not implicitly depend
    on global packages. Earlier, we said that some in the Node.js community caution
    against installing modules in the global directories. This might seem like an
    easy shortcut to sharing code between applications. Just install it globally,
    and you don't have to install the code in each application.
  prefs: []
  type: TYPE_NORMAL
- en: But, doesn't that make deployment harder? Will the new team member be instructed
    on all the special files to install here and there to make the application run?
    Will you remember to install that global module on all destination machines?
  prefs: []
  type: TYPE_NORMAL
- en: For Node.js, that means listing all the module dependencies in `package.json`,
    and then the installation instructions are simply `npm install`, followed perhaps
    by editing a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The Yarn package management system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As powerful as npm is, it is not the only package management system for Node.js.
    Because the Node.js core team does not dictate a package management system, the
    Node.js community is free to roll up their sleeves and develop any system they
    feel best. That the vast majority of us use npm is a testament to its value and
    usefulness. But there is a competitor.
  prefs: []
  type: TYPE_NORMAL
- en: Yarn (see [https://yarnpkg.com/en/](https://yarnpkg.com/en/)) is a collaboration
    between engineers at Facebook, Google, and several other companies. They proclaim
    that Yarn is ultra fast, ultra-secure (by using checksums of everything), and
    ultra reliable (by using a `yarn-lock.json` file to record precise dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of running their own package repository, Yarn runs on top of npm's package
    repository at `npmjs.com`. This means that the Node.js community is not forked
    by Yarn, but enhanced by having an improved package management tool.
  prefs: []
  type: TYPE_NORMAL
- en: The npm team responded to Yarn in npm@5 (also known as npm version 5) by improving
    performance, and by introducing a `package-lock.json` file to improve reliability. 
    The npm team have announced additional improvements in npm@6.
  prefs: []
  type: TYPE_NORMAL
- en: Yarn has become very popular and is widely recommended over npm. They perform
    extremely similar functions, and the performance is not that different to npm@5\.
    The command-line options are worded differently. An important benefit Yarn brings
    to the Node.js community is that competition between Yarn and npm seems to be
    breeding faster advances in Node.js package management.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get you started, these are the most important commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yarn add`: Adds a package to use in your current package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn init`: Initializes the development of a package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn install`: Installs all the dependencies defined in a `package.json` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn publish`: Publishes a package to a package manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn remove`: Removes an unused package from your current package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `yarn` by itself does the `yarn install` behavior. There are several
    other commands in Yarn, and `yarn help` will list them all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about modules and packages for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered implementing modules and packages for Node.js, managing
    installed modules and packages, and saw how Node.js locates modules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about modules and packages, we're ready to use them
    to build applications, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
