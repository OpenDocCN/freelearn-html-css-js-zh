<html><head></head><body>
<article epub:type="bodymatter">
<header>
<h1 class="chap2"><a id="page1" class="calibre6"/><a href="toc.xhtml#c01" class="calibre6">C<small class="calibre8">HAPTER</small> 1</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c01" class="calibre6">Introduction to Node.js</a></h1>
</header>
<h1 class="sec" id="s1"><a href="toc.xhtml#s1a" class="calibre6">Introduction</a></h1>
<p class="nonindent">The popularity of Node.js is booming day by day in the IT market worldwide. Through this book, any JavaScript developer can easily learn about Node.js from basic to advanced levels. This chapter talks about the Node.js basics and architecture. We will also learn how to write a simple Node.js program.</p>
<h1 class="sec" id="s2"><a href="toc.xhtml#s2a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will be covering the following topics:</p>
<ul class="bull">
<li class="calibre9">Defining Node.Js and Where It is Used</li>
<li class="calibre9">Pros and Cons of Node.Js</li>
<li class="calibre9">Installing Node.Js on Various Platforms</li>
<li class="calibre9">Understanding Event-Driven Programming</li>
<li class="calibre9">Node.js Architectures</li>
<li class="calibre9">Writing HTTP and HTTPS Server</li>
<li class="calibre9">Using the Cluster Module</li>
</ul>
<h1 class="sec" id="s3"><a href="toc.xhtml#s3a" class="calibre6">Defining Node.Js</a></h1>
<p class="nonindent">When Ryan Dahl demonstrated his remarkable work, <em class="calibre4">Node.js at JSConf 2009</em>, it was the beginning of a new era. He stated that the concurrency was achieved by threads in most of the top languages and that using threads has certain problems as context switching between threads is costly. Using the event loop, he showed that Node.js achieves way higher concurrency than any of the existing languages. People at the conference welcomed the idea and applauded Dahl. Thus began the much-awaited shift in the programming world.</p>
<p class="nonindent"><a id="page2"/>Node.js is an open source cross-platform JavaScript runtime environment. It states that anyone can use it free of cost on any operating system such as Windows, Linux, Unix, Mac, and more. JavaScript is the foundation of Node.js. The code of any node.js application is written in JavaScript. This code runs on Google Chrome’s V8 JavaScript engine which converts source code to machine code directly without interpreting and then it gets executed without the need for a web browser. Node.js provides the necessary environment for the code to run.</p>
<figure class="img">
<img alt="" src="images/1.1.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_1"><strong class="calibre3">Figure 1.1:</strong> Node.js Architecture</p>
<p class="nonindent"><em class="calibre4"><a href="#fig1_1">Figure 1.1</a></em> shows a high level architecture of Node.js. Even though Node.js is single threaded, it still handles lots of concurrent requests at a time through a mechanism of asynchronous non-blocking I/O operations which provides hidden threads from the <code class="calibre7"><strong class="calibre3">libuv</strong></code> library that executes itself as multi-threaded.</p>
<p class="nonindent">Due to non-blocking I/O operation, Node.js is fast compared to other languages because the request does not wait for its response and parallelly executes another request. All requests are first sent to the event queue, processed in the event loop, and then sent back to the V8 engine through the queue as displayed in Node.js architecture. More about the event loop is elaborated in the section, “<em class="calibre4">Event-driven Mechanism</em>” later in this chapter.</p>
<p class="nonindent">Node.js is not only written for backend-side server programming applications but also developed as node modules and used on the client side, which is beneficial for developers as the same language is used on both sides.</p>
<h1 class="sec" id="s4"><a id="page3" class="calibre6"/><a href="toc.xhtml#s4a" class="calibre6">Applications of Node.js</a></h1>
<p class="nonindent">The usage of Node.js has been growing at a fast pace in IT Industries due to its features and different types of application. Here are a few examples of different types of applications related to Node.js.</p>
<h1 class="sec1" id="s5"><a href="toc.xhtml#s5a" class="calibre6">Single-Page Applications</a></h1>
<p class="nonindent">Currently, there are a lot of organizations and enterprises that provide complex and real time solutions to their clients by developing Node.js applications as server side applications through single-page applications. For example, Gmail, Twitter, Facebook, Trello, and many more applications are developed as SPA (Single-Page Applications). A single-page application communicates with the user’s actions by rewriting data on a single web page instead of reloading the whole web page.</p>
<h1 class="sec1" id="s6"><a href="toc.xhtml#s6a" class="calibre6">Real-time Applications</a></h1>
<p class="nonindent">Node.js is an ideal model for real-time applications because it gives responses to numerous requests at the same time. If there are a large number of users that need real-time response, Node.js is a better choice. You can use Node.js with WebSockets for continuous connection and to provide a faster response time. Applications such as audio, video, chat, multiplayer games, and stock trading are developed in this manner.</p>
<h1 class="sec1" id="s7"><a href="toc.xhtml#s7a" class="calibre6">IoT Devices Applications</a></h1>
<p class="nonindent">Due to its faster response time and ability to handle large numbers of requests concurrently, Node.js is a good choice for Internet of Things (IoT) apps where devices or sensors are connected to the internet and send huge amounts of data continuously. IoT use cases such as fire detection, noise pollution measure, fitness tracker, health monitoring are many such applications where Node.js is playing a big role.</p>
<h1 class="sec1" id="s8"><a href="toc.xhtml#s8a" class="calibre6">Data Streaming Application</a></h1>
<p class="nonindent">Node.js allows working with an abstract interface as a stream for data streaming. Large media files are divided into small chunks and sent as buffers. These buffers are transformed into meaningful data. Netflix-like streaming services use Node.js where data is transferred in chunks instead of whole large streams that reduce loading and delay while streaming happens.</p>
<p class="nonindent">The uses of Node.js are not limited to the preceding types of applications but also many more types of applications developed in Node.js such as making proxy or signaling servers, monitoring data-based applications, and more.</p>
<h1 class="sec" id="s9"><a id="page4" class="calibre6"/><a href="toc.xhtml#s9a" class="calibre6">Pros of Node.js</a></h1>
<p class="nonindent">Node.js is a very powerful runtime environment for JavaScript. It allows developers to build high performance and scalable applications. Some of the key advantages that Node.js offers are as follows:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Cross platform</strong>: Node.js comes up with cross-platform functionality so the application can be easily developed on any OS and deployed on any platform. Key platforms supported by Node.js are Windows, Mac(Intel), Mac(ARM), and Linux (Intel/ARM). Probably every major platform is supported.</li>
<li class="calibre9"><strong class="calibre3">High performance</strong>: Node.js offers high performance due to asynchronous non-blocking I/O operations which execute requests in parallel without waiting for the response of any other request.</li>
<li class="calibre9"><strong class="calibre3">Easy to scale</strong>: Node.js is itself single threaded but in heavy traffic, it handles a lot of requests at the same time to scale up with the “<em class="calibre4">cluster</em>” module which creates child processes and reduces the load on the application.</li>
<li class="calibre9"><strong class="calibre3">Caching</strong>: Node.js allows storing data in temporary memory that is not updated frequently, which reduces loading time and saves database transactions. This is called caching.</li>
<li class="calibre9"><strong class="calibre3">Huge community</strong>: Ever since Node.js appeared, its community size has been increasing day by day. The language used for programming is JavaScript which has been the backbone of the internet and almost every front-end developer was already familiar with it. This made learning easy and made the community grow rapidly. There are more than 1.3 million open-source libraries available for use.</li>
</ul>
<p class="nonindent">There are many other advantages as well such as cost-effectiveness, ease of learning, and adaptability. Node.js is a technique that has really made a difference.</p>
<h1 class="sec" id="s10"><a href="toc.xhtml#s10a" class="calibre6">Cons of Node.js</a></h1>
<p class="nonindent">There are some disadvantages of Node.js too. However many of these can be overcome using best practices.</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Single threaded</strong>: Node.js is single threaded, which is an advantage as well as a pitfall because it is unable to process heavy CPU oriented computation quickly. When requests which need more CPU for processing come in the event loop, they keep piling up because until it finishes one request, it will not pick other requests from the event queue. However, this happens only when there are only CPU centric tasks. If a request needs some IO to happen, another request will be picked while a request waits for IO to complete. CPU centric tasks make the performance low and delay the response. For example, for searching <a id="page5"/>algorithms and mathematical calculations where complexity is high at that time, Node.js is not recommended due to poor performance.</li>
<li class="calibre9"><strong class="calibre3">Callback hell:</strong> Asynchronous programming in Node.js can be challenging for some developers, especially when using callbacks. Callback hell is a situation when callback functions are nested. This can make code difficult to read and maintain. However to avoid this, developers can use promises, async-await, or libraries such as Async.js.</li>
<li class="calibre9"><strong class="calibre3">Library compatibility:</strong> Although there are more than a million libraries available yet those being open sourced by individual developers might not be up-to-date to the latest versions. This sometimes makes it difficult to use those libs in projects.</li>
</ul>
<h1 class="sec" id="s11"><a href="toc.xhtml#s11a" class="calibre6">Installing Node.js</a></h1>
<p class="nonindent">Now when we have a high level understanding of what Node.js is and what it offers, let us jump to the setup. There are different ways to download and install Node.js in your system but here, we give the easiest and best way. Download the LTS (Long Term Support) Version of Node.js from its official site (<a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a>) based on your operating system. On the site, there will be LTS and Current Version, choose the LTS version because it is stable and recommended for complex projects.</p>
<p class="nonindent">At the time of writing, Node.js version 20 is ACTIVE.</p>
<figure class="img">
<img alt="" src="images/1.2.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_2"><strong class="calibre3">Figure 1.2:</strong> Node.js Versions</p>
<p class="nonindent">The preceding up-to-date release schedule can be seen on Node.js GitHub page— <a href="https://github.com/nodejs/release#release-schedule">https://github.com/nodejs/release#release-schedule</a>.</p>
<h1 class="sec" id="s12"><a id="page6" class="calibre6"/><a href="toc.xhtml#s12a" class="calibre6">Installing Node For Linux/Ubuntu</a></h1>
<p class="nonindent"><strong class="calibre3">NPM</strong> (<strong class="calibre3">Node Package Manager</strong>) is the default package manager for node.js and also a library of JavaScript software packages. It is open source so that developers can install other modules in their project via npm free of cost.</p>
<p class="nonindent"><strong class="calibre3">Node Version Manager (NVM)</strong> is a shell script that manages multiple node versions and uses it on different projects.</p>
<p class="nonindent">We can highlight the importance of installing Node.js through <strong class="calibre3">NVM</strong> with real use cases.</p>
<p class="nonindent">Using NVM, you can easily manage multiple Node.js versions on the same machine. Here is how it helps:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Version Management</strong>: NVM allows you to install multiple versions of Node.js on your system. This means you can switch between different versions seamlessly based on the requirements of your projects.</li>
<li class="calibre9"><strong class="calibre3">Isolated Environments</strong>: Each Node.js version installed through NVM is isolated from others. This ensures that changes made to one version won’t affect the others. It is particularly useful when you are working on projects with conflicting dependencies or when you need to maintain compatibility with older versions.</li>
<li class="calibre9"><strong class="calibre3">Flexibility</strong>: With NVM, you have the flexibility to switch between Node.js versions effortlessly. This allows you to test your applications across different versions, ensuring compatibility and stability.</li>
<li class="calibre9"><strong class="calibre3">Project-specific Versioning</strong>: NVM allows you to specify the Node.js version required for a particular project. This ensures that each project uses the correct version of Node.js without interfering with others.</li>
<li class="calibre9"><strong class="calibre3">Easy Updates</strong>: NVM simplifies the process of updating Node.js to the latest version. You can easily upgrade or downgrade Node.js versions with a single command, ensuring that your development environment stays up-to-date.</li>
</ul>
<p class="nonindent">NVM for managing Node.js versions provides a streamlined and efficient workflow, enhancing productivity and reducing potential conflicts between projects. It is an essential tool for developers working on multiple Node.js projects simultaneously.</p>
<p class="nonindent">Based on the advantages of NVM, we will install Node.js through NVM on different platforms.</p>
<p class="nonindent">Let us first install NVM and then install Node.js by NVM. Open terminal/console or cmd and follow three given steps:</p>
<ol class="num">
<li class="calibre9">Update your system with the latest versions of packages.
<p class="code"><code class="calibre7"> $ sudo apt-get update</code></p></li>
<li class="calibre9"><a id="page7"/>Download and install NVM using this command:
<p class="code"><code class="calibre7">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</code></p></li>
<li class="calibre9">Before running the preceding command, make sure <code class="calibre7">curl</code> is installed on the system. If it is not installed then run the following commands to install and verify:
<p class="code"><code class="calibre7"> $ sudo apt install curl $ curl –version</code></p></li>
<li class="calibre9">Verify NVM version:
<p class="code"><code class="calibre7"> $ nvm –version</code></p></li>
<li class="calibre9">Install Node.js as follows:
<p class="code"><code class="calibre7">$ nvm install node</code></p>
<p class="nonindent">This command will install the latest stable version of node.</p></li>
<li class="calibre9">To install Node.js with LTS version, use this command:
<p class="code"><code class="calibre7"> $ nvm install -lts</code></p></li>
<li class="calibre9">If anyone wants specific version of node, then add specific version at end of NVM and install as follows:
<p class="code"><code class="calibre7">$ nvm install 18.15.0</code></p>
<p class="nonindent">Or</p>
<p class="code"><code class="calibre7">$ nvm install 18.x</code></p>
<p class="nonindent">In the preceding commands, 18.15.0 is a specific version of node.js and 18.x means it will consider the highest version of 18 above and below 19.</p></li>
<li class="calibre9">Verify Node.js version as follows:
<p class="code"><code class="calibre7">$ node –version</code></p></li>
</ol>
<p class="nonindent">After successfully executing the above steps, you can expect the following output to be displayed in the command prompt for your reference.</p>
<a id="page8"/>
<figure class="img">
<img alt="" src="images/1.3.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_3"><strong class="calibre3">Figure 1.3:</strong> Linux Node.js Installation</p>
<p class="nonindent">Once Node.js installed, by default NPM is also installed with Node.js installation package, which can be verified with<code class="calibre7"> $ npm –version</code></p>
<p class="nonindent">Other NVM commands which can be helpful for developers to play with node versions on different projects are as follows:</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7">$ nvm ls</code> - Checks list of node version in the system</li>
<li class="calibre9"><code class="calibre7">$ nvm use 18.x</code> – For specific use of node version on the project</li>
<li class="calibre9"><code class="calibre7">$ nvm alias default 18.x</code> – It is to set default for all projects in the system</li>
<li class="calibre9"><code class="calibre7">$ nvm uninstall 18.x</code>- It will uninstall that 18.x version from system</li>
</ul>
<h1 class="sec" id="s13"><a href="toc.xhtml#s13a" class="calibre6">Installing Node.js for Windows</a></h1>
<p class="nonindent">While we have covered Linux installation, now let us proceed with the installation process on Windows. You can follow the steps outlined below for Windows installation.</p>
<p class="nonindent">Installing Node.js through NVM on Windows via the command prompt (<code class="calibre7"><strong class="calibre3">cmd</strong></code>) requires the usage of a specialized tool called "<code class="calibre7"><strong class="calibre3">nvm-windows</strong></code>". Here are the steps to install Node.js on Windows using <code class="calibre7"><strong class="calibre3">nvm-windows</strong></code> via the command prompt:</p>
<ol class="num">
<li class="calibre9"><a id="page9"/>Download NVM for Windows:
<p class="nonindent">Go to the GitHub repository of <code class="calibre7">nvm-windows: nvm-windows</code>. You can explore more <code class="calibre7"><strong class="calibre3">nvm</strong></code> for windows on <a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a>.</p>
<p class="nonindent">Download the latest installer (.zip file) from the Releases section from following link: <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> Here, we will download <code class="calibre7"><strong class="calibre3">nvm-setup.zip</strong></code> file</p>
<figure class="img">
<img alt="" src="images/1.4.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_4"><strong class="calibre3">Figure 1.4:</strong> Windows Node.js Download Zip File</p></li>
<li class="calibre9">Extract the Zip File:
<p class="nonindent">Extract the downloaded .zip file to a directory on your system.</p></li>
<li class="calibre9">Install <code class="calibre7"><strong class="calibre3">NVM</strong></code> for Windows:
<p class="nonindent">Open the Command Prompt as an administrator (right-click and select "<code class="calibre7"><strong class="calibre3">Run as administrator</strong></code>"). Navigate to the directory where you extracted the <code class="calibre7"><strong class="calibre3">nvm-windows</strong></code> files.</p>
<a id="page10"/>
<figure class="img">
<img alt="" src="images/1.5.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_5"><strong class="calibre3">Figure 1.5:</strong> NVM Install Select Location</p></li>
<li class="calibre9">Click <code class="calibre7"><strong class="calibre3">Finish</strong></code> to complete the process:
<figure class="img">
<img alt="" src="images/1.6.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_6"><strong class="calibre3">Figure 1.6:</strong> NVM Finish Install Process</p>
<p class="nonindent">Run the <code class="calibre7"><strong class="calibre3">nvm-setup.zip</strong></code> executable to start the installation process. Follow the on-screen instructions to complete the installation.</p></li>
<li class="calibre9">Verify NVM Installation:
<p class="nonindent">Close and reopen the Command prompt as administrator. Run the command NVM version to ensure that NVM is installed correctly.</p></li>
<li class="calibre9"><a id="page11"/>Install Node.js:
<p class="nonindent">Once NVM is installed, you can use it to install Node.js. To install a specific version of Node.js, use the command <code class="calibre7"><strong class="calibre3">nvm install &lt;version&gt;</strong></code> (for example, <code class="calibre7"><strong class="calibre3">nvm install 18.0.0</strong></code>).</p>
<p class="nonindent">After the installation is complete, you can switch between Node.js versions using the <code class="calibre7"><strong class="calibre3">nvm use &lt;version&gt;</strong></code> command.</p></li>
<li class="calibre9">Verify Node.js Installation:
<p class="nonindent">Run the command <code class="calibre7"><strong class="calibre3">node -v</strong></code> to verify that Node.js is installed and the correct version is active.</p></li>
</ol>
<h1 class="sec" id="s14"><a href="toc.xhtml#s14a" class="calibre6">Installing Node.js for mac</a></h1>
<p class="nonindent">Installation of Node.js on Mac OS is similar to that of Linux. Follow the given steps:</p>
<ol class="num">
<li class="calibre9">Install NVM: To install NVM, we just need to run the following command: 
<p class="code"><code class="calibre7">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</code></p>
<p class="nonindent">Please make sure that <code class="calibre7"><strong class="calibre3">curl</strong></code> is available.</p></li>
<li class="calibre9">Install Node.js using NVM. In case, we just want to install latest Node.js, run the following command:
<p class="code"><code class="calibre7">nvm install node</code></p>
<p class="nonindent">This command will automatically download and install the latest Node.js version. In case you want to install the LTS (Long term support) version, run this command:</p>
<p class="code"><code class="calibre7">nvm install –-lts</code></p>
<p class="nonindent">(Please note that there are two <code class="calibre7">'</code>-’ hyphens before lts).</p></li>
<li class="calibre9">Verify the installation by opening the console and run the following command: 
<p class="code"><code class="calibre7">node --version</code></p>
<p class="nonindent">This will output the version installed, for example:</p>
<p class="code"><code class="calibre7"> v20.0.0</code></p></li>
<li class="calibre9">We can also check the npm version using this command:
<p class="code"><code class="calibre7">npm -- version</code></p>
<p class="code1"><code class="calibre7">9.6.4</code></p></li>
</ol>
<h1 class="sec" id="s15"><a id="page12" class="calibre6"/><a href="toc.xhtml#s15a" class="calibre6">Event-Driven Mechanism</a></h1>
<p class="nonindent">Node.js is an asynchronous non-blocking event-driven programming. Any action that happens is called an event and it is either done by the user or the system itself. Node.js provides an inbuilt module Event, which is an instance of <code class="calibre7"><strong class="calibre3">EventEmitter</strong></code>. Event is an I/O request that is first sent to the Event Queue. If there are multiple concurrent requests coming to the queue, then the queue passes it to the event loop.</p>
<figure class="img">
<img alt="" src="images/1.7.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_7"><strong class="calibre3">Figure 1.7:</strong> Event-Driven Diagram</p>
<p class="nonindent">Event loop monitors the event queue, collects the events from it, then processes it and executes based on blocking and non-blocking functions. Blocking functions are executed sequentially, one after the other, and the second function is not called until the first one responds. Sometimes it depends on external resources and waits for its response which takes longer time, whereas non-blocking functions do not need to wait for any response. It executes asynchronously, which means multiple functions run parallel at a time so that they are not depending on one another. Blocking and non-blocking functions send thread and I/O Pool to its pools, respectively. Once the actual operation is done, the response of that request is sent back to the event queue via event loop. In nutshell, events are emitted and then registered or unregistered through a queue, which is monitored by the event loop, binding the appropriate handlers accordingly.</p>
<p class="nonindent"><a id="page13"/>Node.js follows a non-blocking asynchronous model even though it has a single thread that handles multiple requests at a time, without blocking its call respective handlers.</p>
<h1 class="sec" id="s16"><a href="toc.xhtml#s16a" class="calibre6">Example of Event Programming</a></h1>
<p class="nonindent">Create a file save with <code class="calibre7"><strong class="calibre3">event_index.js</strong></code> and paste the following code:</p>
<p class="code"><code class="calibre7">// Import 'events' module</code></p>
<p class="code1"><code class="calibre7">const events = require('events');</code></p>
<p class="code"><code class="calibre7">// Initiate an EventEmitter object</code></p>
<p class="code1"><code class="calibre7">const eventEmitter = new events.EventEmitter();</code></p>
<p class="code"><code class="calibre7">// Binds event handler for send message</code></p>
<p class="code1"><code class="calibre7">eventEmitter.on('send_message', function () {</code></p>
<p class="code2"><code class="calibre7">console.log('Hi, This is my first message');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">// Handler associated with the connection event</code></p>
<p class="code1"><code class="calibre7">const connectHandler = function connected() {</code></p>
<p class="code2"><code class="calibre7">console.log('Connection is created');</code></p>
<p class="code2"><code class="calibre7">// Trigger the corresponding event</code></p>
<p class="code2"><code class="calibre7">eventEmitter.emit('send_message');</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="code"><code class="calibre7">// Binds the event with handler</code></p>
<p class="code1"><code class="calibre7">eventEmitter.on('connection', connectHandler);</code></p>
<p class="code"><code class="calibre7">// Trigger the connection event</code></p>
<p class="code1"><code class="calibre7">eventEmitter.emit('connection');</code></p>
<p class="code"><code class="calibre7">console.log("Finish");</code></p>
<p class="nonindent">Run the file with <code class="calibre7"><strong class="calibre3">$ node event_index.js</strong></code> and the following output will be shown:</p>
<p class="code"><code class="calibre7">Connection is created</code></p>
<p class="code1"><code class="calibre7">Hi, This is my first message</code></p>
<p class="code1"><code class="calibre7">Finish</code></p>
<h1 class="sec" id="s17"><a id="page14" class="calibre6"/><a href="toc.xhtml#s17a" class="calibre6">Example of Synchronous Code</a></h1>
<p class="nonindent">Create one file named hello.txt and paste the following text in it:</p>
<p class="code"><code class="calibre7">Hello, I am Developer</code></p>
<p class="nonindent">Create another file named index.js within the same folder, paste the following code and save it:</p>
<p class="code"><code class="calibre7">const fs = require('fs');</code></p>
<p class="code1"><code class="calibre7">console.log('Start');</code></p>
<p class="code1"><code class="calibre7">const data = fs.readFileSync('hello.txt');</code></p>
<p class="code1"><code class="calibre7">console.log(data.toString());</code></p>
<p class="code1"><code class="calibre7"><a id="page15"/>console.log('End');</code></p>
<p class="nonindent">Run the code as follows:</p>
<p class="code"><code class="calibre7"><strong class="calibre3">$ node sync_index.js</strong></code></p>
<p class="nonindent">You will get an output as follows:</p>
<p class="code"><code class="calibre7">Start</code></p>
<p class="code1"><code class="calibre7">Hello, I am Developer</code></p>
<p class="code1"><code class="calibre7">End</code></p>
<p class="nonindent">Here, fs is a file system module importing it and <code class="calibre7"><strong class="calibre3">fs.readFileSync()</strong></code> is a synchronous function which waits until file read is complete and assigns that response to the data variable. It prints line-by-line and executes synchronously.</p>
<h1 class="sec" id="s18"><a href="toc.xhtml#s18a" class="calibre6">Example of Asynchronous code</a></h1>
<p class="nonindent">Create one file named <code class="calibre7"><strong class="calibre3">hello.txt</strong></code> and paste the following text:</p>
<p class="code"><code class="calibre7">Hello, I am Developer</code></p>
<p class="nonindent">Create another file named <code class="calibre7"><strong class="calibre3">index.js</strong></code> within the same folder, paste the following code and save it:</p>
<p class="code"><code class="calibre7">const fs = require('fs');</code></p>
<p class="code1"><code class="calibre7">console.log('Start');</code></p>
<p class="code1"><code class="calibre7">fs.readFile('hello.txt', function (err, data) {</code></p>
<p class="code2"><code class="calibre7">if (err) {</code></p>
<p class="code3"><code class="calibre7">return console.error(err);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">console.log(data.toString());</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">console.log('End');</code></p>
<p class="nonindent">Run the code as follows:</p>
<p class="code"><code class="calibre7">$ node async_index.js</code></p>
<p class="nonindent">You will get an output as follows:</p>
<p class="code"><code class="calibre7">Start</code></p>
<p class="code1"><code class="calibre7">End</code></p>
<p class="code1"><code class="calibre7">Hello, I am Developer</code></p>
<p class="nonindent">Here, fs is a file system module. We import it, and <code class="calibre7"><strong class="calibre3">fs.readFile()</strong></code> is an asynchronous function. This function does not wait for the file read to complete. Instead, it has a callback function. Once the file read operation is finished, the <code class="calibre7"><strong class="calibre3">callback</strong></code> function executes and prints the data. Therefore, the line after the callback is executed asynchronously.</p>
<h1 class="sec" id="s19"><a href="toc.xhtml#s19a" class="calibre6">Types of Node.js Architectures</a></h1>
<p class="nonindent">When we start developing the applications using Node.js, it is important to decide how your application should be structured. There are many ways to structure your Node.js application with different kinds of architecture. Let us discuss those briefly here.</p>
<h1 class="sec" id="s20"><a href="toc.xhtml#s20a" class="calibre6">Monolithic Architecture</a></h1>
<p class="nonindent">In this architecture, all components or modules of business logic are blended together in a single unit. Almost all web servers or server-side frameworks are built using monolithic architecture (see <em class="calibre4"><a href="#fig1_8">Figure 1.8</a></em>), which is the easiest way for developers:</p>
<figure class="img">
<img alt="" src="images/1.8.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_8"><strong class="calibre3">Figure 1.8:</strong> Monolithic Architecture</p>
<p class="nonindent"><a id="page16"/>For smaller applications that do not require extensive scalability, this architecture can be suitable. However, it may not be well-suited for larger and more complex applications. As the traffic load on your server-side application grows, you will need to scale it to handle the increased demand. In this architecture, you have a single main Node.js server file that routes all API requests to controllers and services, managing database transactions.</p>
<p class="nonindent">You can scale a monolithic architecture using clusters to reduce the load. However, there are instances when a single server is unable to handle the incoming traffic. In such cases, you can deploy the same code on multiple servers, run application servers, and employ a load balancer like Nginx. The load balancer, using a round-robin approach, becomes a reliable solution, especially for very large and heavily used applications. We will delve into this aspect in more detail in the deployment section. The biggest drawback of this structure is that if there is a small change needed on any component, then it needs to be done in all servers and rebuilt and redeployed again.</p>
<h1 class="sec" id="s21"><a href="toc.xhtml#s21a" class="calibre6">Microservice Architecture</a></h1>
<p class="nonindent">A microservices architecture is a type of architecture that is developed as a collection of services. The framework provided here allows us to develop and deploy the microservices along with maintaining them independently. Microservices sort out the challenges of monolithic systems by fragmenting the application from a whole into several smaller parts. It is reliable and suitable for large and complex applications such as e-commerce platforms, social sites where multiple features are provided to millions of users at same time. Hence, during maintenance or while adding new features, it does not interrupt other existing features and deploy only updated services. Nowadays, it is trending more and more for its flexibility where multiple developers work individually and are only responsible for their own small code instead of whole system code.</p>
<p class="nonindent">In this architecture, all components or modules of business logic are individual. Many large enterprises use this kind of microservice architecture (see <em class="calibre4"><a href="#fig1_9">Figure 1.9</a></em>):</p>
<a id="page17"/>
<figure class="img">
<img alt="" src="images/1.9.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_9"><strong class="calibre3">Figure 1.9:</strong> Microservice Architecture</p>
<p class="nonindent">As per the preceding diagram, client as user or UI sends a request, which is collected by API Gateway and passed to the respective microservice, which has its own function (Lambda Function). This function connects to the database and gives back a response accordingly. Each microservice can be easily changed and deployed without affecting each other. In addition, these microservices also call each other through API HTTP service or gRPC (Google Remote Procedure Call) which is a generic flow of microservice architecture. However, while it is a cost-effective and time-saving architecture for development, it may not be suitable for smaller applications. This is because it relies on cloud-based solutions, which can become expensive even with minimal setup requirements. This cost issue can often be mitigated by adopting more budget-friendly solutions offered by monolithic architectures. In fact, microservices represent a way to leverage serverless architecture within the realm of cloud computing.</p>
<h1 class="sec" id="s22"><a href="toc.xhtml#s22a" class="calibre6">Serverless Architecture</a></h1>
<p class="nonindent">Serverless architecture is the approach for developing and building applications without managing infrastructure. Basically any app is developed and deployed on a specific server. However, managing the server hosting process can be a cumbersome task for developers. This is where serverless architecture becomes a boon for those who want to avoid server management and only pay for what they use. In serverless architecture, everything is handled by third-party services provided by cloud computing providers like AWS, Azure, Google, etc. These providers offer respective functions like AWS Lambda functions, Microsoft Azure functions, and Google Cloud functions, which is why it is also referred to as “<em class="calibre4">Function as a Service</em>” (FaaS). However, it is important to note that this approach has its drawbacks, as it involves entrusting everything to third parties, which can raise security concerns. Even though it has some limitations, it is still becoming more popular because organizations focus on actual products and services, not infrastructure, so it will be cost effective for those who spend a lot of effort on infrastructure.</p>
<a id="page18"/>
<figure class="img">
<img alt="" src="images/1.10.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_10"><strong class="calibre3">Figure 1.10:</strong> Serverless Architecture</p>
<p class="nonindent">In this serverless architecture, a transformative approach for application development and deployment that eliminates the need for traditional server management. Instead, it enables developers to focus solely on writing code while cloud providers handle the underlying infrastructure. Below is a visual representation of this serverless concept (see <em class="calibre4"><a href="#fig1_10">Figure 1.10</a></em>).</p>
<p class="nonindent">It is an example of AWS serverless architecture in which an AWS API gateway is used to route REST API calls and is based on the route Lambda function called with an attached gateway. Lambda functions can be written in different languages but we consider them to be written in Node.js code that have the actual business logic to perform action to the database. AWS Cloud provides various database instances such as DynamoDB, MySQL, PostgreSQL, and others. Furthermore, it can effortlessly scale to accommodate increasing workloads. AWS offers auto-scaling capabilities, which means it can automatically add more EC2 instances when there is a surge in load and reduce instances when the load decreases.</p>
<table border="1" class="table">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<tr class="calibre12">
<td class="calibre13">
<p class="tab"><strong class="calibre3">Aspect</strong></p>
</td>
<td class="calibre13">
<p class="tab"><strong class="calibre3">Monolithic Architecture</strong></p>
</td>
<td class="calibre13">
<p class="tab"><strong class="calibre3">Microservices Architecture</strong></p>
</td>
<td class="calibre13">
<p class="tab"><strong class="calibre3">Serverless Architecture</strong></p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Development</p>
</td>
<td class="calibre13">
<p class="tab1">Easier setup and development process</p>
</td>
<td class="calibre13">
<p class="tab1">Complex setup, but independent services promote scalability</p>
</td>
<td class="calibre13">
<p class="tab1">Focuses on writing functions without managing infrastructure</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Scalability</p>
</td>
<td class="calibre13">
<p class="tab1">Limited scalability due to the entire application being scaled</p>
</td>
<td class="calibre13">
<p class="tab1">Scalable, as each service can be independently scaled</p>
</td>
<td class="calibre13">
<p class="tab1">Automatically scales based on demand</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Maintenance</p>
</td>
<td class="calibre13">
<p class="tab1">Single codebase makes maintenance easier</p>
</td>
<td class="calibre13">
<p class="tab1">Requires management of multiple services and communication</p>
</td>
<td class="calibre13">
<p class="tab1">Less management overhead; managed by cloud provider</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1"><a id="page19"/>Technology Stack</p>
</td>
<td class="calibre13">
<p class="tab1">Limited flexibility; all components use the same technology stack</p>
</td>
<td class="calibre13">
<p class="tab1">Flexibility to use different technologies for each service</p>
</td>
<td class="calibre13">
<p class="tab1">Limited control over underlying infrastructure and runtime</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Deployment</p>
</td>
<td class="calibre13">
<p class="tab1">Simple deployment process; deploy as a single unit</p>
</td>
<td class="calibre13">
<p class="tab1">Deployment complexity due to multiple services</p>
</td>
<td class="calibre13">
<p class="tab1">Simplified deployment process</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Resource Utilization</p>
</td>
<td class="calibre13">
<p class="tab1">Resource utilization may be inefficient</p>
</td>
<td class="calibre13">
<p class="tab1">Optimized resource utilization with services scaled as needed</p>
</td>
<td class="calibre13">
<p class="tab1">Efficient resource utilization with on-demand execution</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Cost</p>
</td>
<td class="calibre13">
<p class="tab1">Lower upfront costs; higher operational costs in the long term</p>
</td>
<td class="calibre13">
<p class="tab1">Higher initial setup costs; potential cost savings with scale</p>
</td>
<td class="calibre13">
<p class="tab1">Pay-per-use model can be cost-effective for low traffic apps</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Fault Isolation</p>
</td>
<td class="calibre13">
<p class="tab1">A bug in one part can affect the entire application</p>
</td>
<td class="calibre13">
<p class="tab1">Faults are isolated to specific services; others remain unaffected</p>
</td>
<td class="calibre13">
<p class="tab1">Managed by cloud provider, potential vendor lock-in</p>
</td>
</tr>
<tr class="calibre14">
<td class="calibre13">
<p class="tab1">Flexibility</p>
</td>
<td class="calibre13">
<p class="tab1">Limited flexibility due to the monolithic structure</p>
</td>
<td class="calibre13">
<p class="tab1">Flexibility to use different technologies and languages</p>
</td>
<td class="calibre13">
<p class="tab1">Limited control over underlying infrastructure and runtime</p>
</td>
</tr>
</table>
<p class="figcap" id="tab1_1"><strong class="calibre3">Table 1.1:</strong> Comparisons of Architecture</p>
<p class="nonindent"><em class="calibre4"><a href="#tab1_1">Table 1.1</a></em> provides a comparison of various aspects of monolithic, microservices, and serverless architectures in Node.js, outlining their respective advantages and disadvantages. Depending on specific project requirements, one architecture may be more suitable than the others.</p>
<p class="nonindent">Let us create a basic http and https server with programming.</p>
<h1 class="sec" id="s23"><a href="toc.xhtml#s23a" class="calibre6">Writing an HTTP Server</a></h1>
<p class="nonindent">Now when Node.js is properly set up and running in your system, let us do the famous "<code class="calibre7"><strong class="calibre3">Hello World</strong></code>" in Node.js way by serving this through an HTTP server.</p>
<p class="nonindent">Let us create a file with name index.js, and copy the following code into it:</p>
<p class="code"><code class="calibre7">const http = require('http');</code></p>
<p class="code1"><code class="calibre7">const hostname = '127.0.0.1';</code></p>
<p class="code1"><code class="calibre7">const port = 3000;</code></p>
<p class="code"><code class="calibre7">const server = http.createServer((req, res) =&gt; {</code></p>
<p class="code2"><a id="page20"/><code class="calibre7">res.statusCode = 200;</code></p>
<p class="code2"><code class="calibre7">res.setHeader('Content-Type', 'text/plain');</code></p>
<p class="code2"><code class="calibre7">res.end('Hello World');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">server.listen(port, hostname, () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log(`Server running at http://${hostname}:${port}/`);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In the provided code, "<code class="calibre7"><strong class="calibre3">http</strong></code>" is a default module provided by Node.js, so there is no need to install it separately. However, for modules not included in Node.js’s built-in modules, you can install them from the npm library.</p>
<p class="nonindent">The npm library contains millions of registered packages, and you can install them using the following code:</p>
<p class="code"><code class="calibre7">$ npm install package-name</code></p>
<p class="code1"><code class="calibre7">ex. npm install express</code></p>
<p class="nonindent">package-name can be as "<code class="calibre7"><strong class="calibre3">body-parser</strong></code>", "<code class="calibre7"><strong class="calibre3">express</strong></code>", "<code class="calibre7"><strong class="calibre3">moment</strong></code>", and so on.</p>
<p class="nonindent">The http module creates a http server that runs on specific port 3000. Ideally, Node.js runs on port 3000 but developers can assign different ports such as 3001, 4000 or any port. Just need to make sure that the port number does not conflict with other applications on the system.</p>
<p class="nonindent">To run the program, open console with source code directory and paste the following command:</p>
<p class="code"><code class="calibre7">$ node index.js</code></p>
<p class="nonindent">Once it runs, open the browser and go to the URL as http://localhost:3000; it will print "<code class="calibre7"><strong class="calibre3">Hello World</strong></code>".</p>
<figure class="img">
<img alt="" src="images/1.11.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_11"><strong class="calibre3">Figure 1.11:</strong> HTTP Server Program Output</p>
<h1 class="sec" id="s24"><a id="page21" class="calibre6"/><a href="toc.xhtml#s24a" class="calibre6">Making it HTTPS</a></h1>
<p class="nonindent">The server we just created does not provide a secure way of serving APIs. Most often, we need to serve the APIs using HTTPS rather than HTTP.</p>
<p class="nonindent">HTTP does not encrypt the data, thus it is not secure where the information is leaked during transmission. On the other hand, HTTPS encrypts data during transmission on request from client to server that makes it secure.</p>
<p class="nonindent">Let us rewrite the same code with the https server. For HTTPS, we need SSL certificates.</p>
<p class="nonindent">Let us first create a self-signed SSL certificate:</p>
<ol class="num">
<li class="calibre9">Open console and install <code class="calibre7"><strong class="calibre3">openssl</strong></code> if not installed in your system.</li>
<li class="calibre9">For Debian Linux such as ubuntu, installation can be done using the <code class="calibre7"><strong class="calibre3">apt</strong></code> command:
<p class="code"><code class="calibre7"> $ sudo apt install openssl</code></p></li>
<li class="calibre9">For Centos, Fedora, and Rocky Linux, yum can be used to install <code class="calibre7"><strong class="calibre3">openssl</strong></code>:
<p class="code"><code class="calibre7"> $ sudo yum install openssl</code></p></li>
<li class="calibre9">Make <code class="calibre7"><strong class="calibre3">openssl</strong></code> directory as follows:
<p class="code"><code class="calibre7">$mkdir openssl</code></p>
<p class="code1"><code class="calibre7">$cd openssl</code></p></li>
<li class="calibre9">Request to generate <code class="calibre7"><strong class="calibre3">ssl</strong></code> certificate with the following command:
<p class="code"><code class="calibre7">$ openssl req -newkey rsa -x509 -sha256 -days 365 -nodes -out ssl.crt -keyout ssl.key</code></p>
<p class="nonindent">Let us understand the preceding command:</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-newkey rsa</strong></code> : create new key with <code class="calibre7"><strong class="calibre3">rsa</strong></code> algorithm default 2048 bit</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-x509</strong></code> : creates a X.509 Certificate</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-sha256</strong></code> : use 265-bit SHA (Secure Hash Algorithm)</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-days 365</strong></code> : The number of days to certify the certificate for 365. You can use any positive integer</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-nodes</strong></code> : creates a key without a passphrase.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-out ssl.crt</strong></code> : Specifies the filename to write the newly created certificate to. You can specify any file name.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">-keyout ssl.key</strong></code> : Specifies the filename to write the newly created private key to. You can specify any file name.</li>
</ul></li>
</ol>
<p class="nonindent">Once you enter this command, it will prompt the following questions (as shown in <a id="page22"/><em class="calibre4"><a href="#fig1_12">Figure 1.12</a></em>). Press enter until done and check that folder which has <code class="calibre7"><strong class="calibre3">ssl.crt</strong></code> and <code class="calibre7"><strong class="calibre3">ssl.key</strong></code> files:</p>
<figure class="img">
<img alt="" src="images/1.12.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_12"><strong class="calibre3">Figure 1.12:</strong> Openssl Certificate Generation</p>
<p class="nonindent">Now create <code class="calibre7"><strong class="calibre3">main.js</strong></code> and write the following code to create <code class="calibre7"><strong class="calibre3">https server</strong></code> with <code class="calibre7"><strong class="calibre3">port 3000</strong></code>:</p>
<p class="code"><code class="calibre7">// import https module</code></p>
<p class="code1"><code class="calibre7">const https = require(`https`);</code></p>
<p class="code1"><code class="calibre7">//import fs module to read files</code></p>
<p class="code1"><code class="calibre7">const fs = require(`fs`);</code></p>
<p class="code1"><code class="calibre7">const options = {</code></p>
<p class="code2"><code class="calibre7">key: fs.readFileSync(`./openssl/ssl.key`),</code></p>
<p class="code2"><code class="calibre7">cert: fs.readFileSync(`./openssl/ssl.crt`)</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="code1"><code class="calibre7">// create https server on port 3000</code></p>
<p class="code1"><code class="calibre7">https.createServer(options, (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.writeHead(200);</code></p>
<p class="code2"><code class="calibre7">res.end(`hello world from https server \n`);</code></p>
<p class="code1"><code class="calibre7">}).listen(3000);</code></p>
<p class="nonindent">Run the code with node main.js and open the browser with https://localhost:3000 which displays "<code class="calibre7"><strong class="calibre3">hello world from https server</strong></code>". This way a secure https server is built with very basic examples.</p>
<h1 class="sec" id="s25"><a id="page23" class="calibre6"/><a href="toc.xhtml#s25a" class="calibre6">Using Cluster Module</a></h1>
<p class="nonindent">Node.js can easily make applications highly scalable through the cluster module. Cluster is creating a child process so that it raises another process which splits single thread into multi thread. Due to that heavy traffic load is reduced and shared on different instances of thread with the same port. It is a built-in module of Node.js. As Node.js supports async single thread and sometimes when blocking functions are more, the application performance gets down. Cluster is most important and useful to improve it.</p>
<p class="nonindent">Node.js server initiates multiple incoming requests. First, it points to the main process that is called primary process or master, which is a single one. Afterwards it splits into different child processes from its parent process. Child process is called the worker process, which can be multiple and has its own event loop that processes it simultaneously. Clustering has two ways of distribution process. The first one is the default round robin method in which the master listens to server requests and sends them to the worker in an equally circular order, and the other one is socket based where the master listens and assigns only interested workers who want to do the process.</p>
<p class="nonindent">Cluster architecture harnesses the capabilities of multiple interconnected servers, elevating the performance, reliability, and scalability of contemporary applications. <em class="calibre4"><a href="#fig1_13">Figure 1.13</a></em> provides a visual representation of how cluster nodes collaborate seamlessly to efficiently manage incoming requests.</p>
<figure class="img">
<img alt="" src="images/1.13.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_13"><strong class="calibre3">Figure 1.13:</strong> Cluster Diagram</p>
<h1 class="sec" id="s26"><a id="page24" class="calibre6"/><a href="toc.xhtml#s26a" class="calibre6">Programming Without Cluster Module Example</a></h1>
<p class="nonindent">Create a file named as <code class="calibre7"><strong class="calibre3">without_cluster.js</strong></code> and save the following code:</p>
<p class="code"><code class="calibre7">//Import http module for create server</code></p>
<p class="code1"><code class="calibre7">const http = require('http');</code></p>
<p class="code1"><code class="calibre7">// create server and api for test</code></p>
<p class="code1"><code class="calibre7">http.createServer(function (req, res) {</code></p>
<p class="code2"><code class="calibre7">if (req.url === "/api/test" &amp;&amp; req.method === "GET") {</code></p>
<p class="code3"><code class="calibre7">console.time('API_without_cluster');</code></p>
<p class="code3"><code class="calibre7">let result = 0;</code></p>
<p class="code3"><code class="calibre7">for (let i = 0; i &lt; 5000000; i++) {</code></p>
<p class="code4"><code class="calibre7">result += i;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">console.timeEnd('API_without_cluster');</code></p>
<p class="code3"><code class="calibre7">console.log(`Result = ${result} - on process ${process.pid}`);</code></p>
<p class="code3"><code class="calibre7">res.end(`Result = ${result}`);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}).listen(3001);</code></p>
<p class="nonindent">Run the code with this command:</p>
<p class="code"><code class="calibre7">$ node without_cluster.js</code></p>
<p class="nonindent">Now we can test this in the browser with URL http://localhost:3001/api/test and call it multiple times continuously by hitting the refresh button multiple times.</p>
<p class="nonindent">The following output will be displayed in the console:</p>
<a id="page25"/>
<figure class="img">
<img alt="" src="images/1.14.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_14"><strong class="calibre3">Figure 1.14:</strong> Output Without Cluster</p>
<h1 class="sec" id="s27"><a href="toc.xhtml#s27a" class="calibre6">Programming With Cluster Module Example</a></h1>
<p class="nonindent">Now create another file named <code class="calibre7"><strong class="calibre3">cluster.js</strong></code> and save the following code:</p>
<p class="code"><code class="calibre7">//Import cluster module</code></p>
<p class="code1"><code class="calibre7">const cluster = require('cluster');</code></p>
<p class="code1"><code class="calibre7">//Import http module for create server</code></p>
<p class="code1"><code class="calibre7">const http = require('http');</code></p>
<p class="code1"><code class="calibre7">//check if it is master process then create child process through fork() method</code></p>
<p class="code1"><code class="calibre7">if (cluster.isMaster) {</code></p>
<p class="code2"><code class="calibre7">const numWorkers = require('os').cpus().length;</code></p>
<p class="code2"><code class="calibre7">console.log(`Master ${process.pid} started`);</code></p>
<p class="code2"><code class="calibre7">console.log(`Number of workers =&gt; ${numWorkers}`)</code></p>
<p class="code2"><code class="calibre7">for (var i = 0; i &lt; numWorkers; i++) {</code></p>
<p class="code3"><code class="calibre7">cluster.fork();</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">cluster.on('exit', (worker, code, signal) =&gt; {</code></p>
<p class="code3"><code class="calibre7">console.log(`worker ${worker.process.pid} died`);</code></p>
<p class="code3"><code class="calibre7"> console.log("Let's fork another worker!");</code></p>
<p class="code3"><code class="calibre7">cluster.fork();</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7"><a id="page26"/>} else {</code></p>
<p class="code2"><code class="calibre7">// it is worker process so run multiple process with same 3000 port</code></p>
<p class="code2"><code class="calibre7">console.log(`Worker ${process.pid} started`);</code></p>
<p class="code2"><code class="calibre7">http.createServer(function (req, res) {</code></p>
<p class="code3"><code class="calibre7">if (req.url === "/api/test" &amp;&amp; req.method === "GET") {</code></p>
<p class="code4"><code class="calibre7">console.time('API_with_cluster')</code></p>
<p class="code4"><code class="calibre7">let result = 0;</code></p>
<p class="code4"><code class="calibre7">for (let i = 0; i &lt; 5000000; i++) {</code></p>
<p class="code5"><code class="calibre7"> result += i;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7">console.timeEnd('API_with_cluster');</code></p>
<p class="code4"><code class="calibre7">console.log(`Result = ${result} - on process ${process.pid}`);</code></p>
<p class="code4"><code class="calibre7">res.end(`Result = ${result}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}).listen(3000);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Now run the code using this command:</p>
<p class="code"><code class="calibre7">$ node cluster.js</code></p>
<p class="nonindent">Open the browser with URL http://localhost:3000/api/test and call it multiple times. It will give the following output in the console:</p>
<a id="page27"/>
<figure class="img">
<img alt="" src="images/1.15.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig1_15"><strong class="calibre3">Figure 1.15:</strong> Output With Cluster</p>
<p class="nonindent">As we can see that when we use the cluster module, the responses take less time between 12 and 16 ms, but without the cluster module, the time goes higher – 14 to 22 ms. The difference here is not much since the code we are using has almost no logic, database operations, or any other IO. The time may be changed with implementation so cluster is useful when computation is heavy, but if there are not too many computations it might not be beneficial. Basically, cluster allows us to run multiple workers which can utilize more than one CPU.</p>
<p class="nonindent">The cluster module can also be used to set up a master-worker setup where master monitors the workers and in case a worker stops or crashes, master can start another worker. This way, we can handle errors safely in the application and prevent applications from completely crashing. In <em class="calibre4"><a href="c04.xhtml">Chapter 4, Planning the Application</a>,</em> we will see it in action.</p>
<h1 class="sec" id="s28"><a href="toc.xhtml#s28a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">In this chapter, we got an introduction to Node.js and what it offers along with its pros and cons. We learned how to install Node.js and created a simple server. We also got familiar with how Node.js makes use of event loop and different types of architecture. <a id="page28"/>Later we created a web server with HTTP and HTTPS. Finally, we saw how the cluster module can be used.</p>
<p class="nonindent">In this chapter, we used JavaScript as a programming language, which is not maintainable when the project size becomes big. A better approach is to use Typescript instead of JavaScript. In the next chapter, we will learn the basics of Typescript.</p>
<h1 class="sec" id="s29"><a href="toc.xhtml#s29a" class="calibre6">Multiple Choice Questions</a></h1>
<ol class="num">
<li class="calibre9">What is Node.js and which of the following statements about it is true?
<ol class="alfa">
<li class="calibre9">Node.js is a closed-source JavaScript runtime environment</li>
<li class="calibre9">Node.js can only be used on Windows operating systems</li>
<li class="calibre9"> Node.js is primarily based on Python code</li>
<li class="calibre9">Node.js is an open-source JavaScript runtime environment that can be used on various operating systems</li></ol></li>
<li class="calibre9">For which types of applications is Node.js commonly used?
<ol class="alfa">
<li class="calibre9">Node.js is mainly used for desktop applications and gaming</li>
<li class="calibre9">Node.js is primarily utilized for mobile app development</li>
<li class="calibre9">Node.js is commonly employed for single-page applications (SPAs), real-time applications, Internet of Things (IoT) devices applications, and data streaming applications</li>
<li class="calibre9">Node.js is exclusively used for web-based email services like Gmail</li></ol></li>
<li class="calibre9">What is one of the key advantages of using Node.js for real-time applications?
<ol class="alfa">
<li class="calibre9">Node.js is the only option for building real-time applications</li>
<li class="calibre9">Node.js provides a graphical user interface for real-time applications</li>
<li class="calibre9">Node.js offers a continuous connection through WebSockets, enabling faster response times</li>
<li class="calibre9">Node.js can only be used for audio and video streaming applications</li></ol></li>
<li class="calibre9">How can you check the version of Node.js installed on your system?
<ol class="alfa">
<li class="calibre9">Run the command <code class="calibre7"><strong class="calibre3">node version</strong></code> in the terminal</li>
<li class="calibre9">Run the command <code class="calibre7"><strong class="calibre3">node info</strong></code> in the terminal</li>
<li class="calibre9">Run the command <code class="calibre7"><strong class="calibre3">node --v</strong></code> in the terminal</li>
<li class="calibre9">Run the command <code class="calibre7"><strong class="calibre3">node -v</strong></code> in the terminal</li></ol></li>
<li class="calibre9"><a id="page29"/>What is the key characteristic of the event loop in Node.js?
<ol class="alfa">
<li class="calibre9">It executes blocking functions in parallel to improve performance</li>
<li class="calibre9">It waits for all functions to complete before moving to the next</li>
<li class="calibre9">It handles rendering and user interface tasks in Node.js applications</li>
<li class="calibre9">It manages asynchronous operations, ensuring non-blocking execution</li></ol></li>
<li class="calibre9">How does microservices architecture differ from monolithic architecture?
<ol class="alfa">
<li class="calibre9">Microservices use a single codebase for all components</li>
<li class="calibre9">Microservices are tightly coupled and run as a single application</li>
<li class="calibre9">Microservices are loosely coupled and consist of independently deployable services</li>
<li class="calibre9">Microservices communicate only via RESTful APIs</li></ol></li>
<li class="calibre9">When is serverless architecture a suitable choice for application development?
<ol class="alfa">
<li class="calibre9">When you want to focus on writing code and not worry about server provisioning</li>
<li class="calibre9">When the application has a monolithic codebase</li>
<li class="calibre9">When you want to minimize development costs</li>
<li class="calibre9">When you need full control over server management</li></ol></li>
<li class="calibre9">Which method in the HTTP module is used to create an HTTP server in Node.js?
<ol class="alfa">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">http.createServer()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">http.request()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">http.get()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">http.post()</strong></code></li></ol></li>
<li class="calibre9">Which method is used to create a cluster of Node.js processes using the Cluster module?
<ol class="alfa">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">cluster.start()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">cluster.fork()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">cluster.create()</strong></code></li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">cluster.spawn()</strong></code></li></ol></li>
<li class="calibre9"><a id="page30"/>How does the Cluster module enhance the performance of a Node.js application?
<ol class="alfa">
<li class="calibre9">By creating multiple instances of the Node.js application</li>
<li class="calibre9">By managing database connections more efficiently</li>
<li class="calibre9">By reducing the number of available CPU cores</li>
<li class="calibre9">By slowing down the application’s response time</li></ol></li>
</ol>
<h1 class="sec1" id="s30"><a href="toc.xhtml#s30a" class="calibre6">Answers</a></h1>
<ol class="num">
<li class="calibre9">d</li>
<li class="calibre9">c</li>
<li class="calibre9">c</li>
<li class="calibre9">d</li>
<li class="calibre9">d</li>
<li class="calibre9">c</li>
<li class="calibre9">d</li>
<li class="calibre9">a</li>
<li class="calibre9">b</li>
<li class="calibre9">a</li>
</ol>
<h1 class="sec" id="s31"><a href="toc.xhtml#s31a" class="calibre6">Further Reading</a></h1>
<p class="nonindent"><a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
</article>
</body></html>