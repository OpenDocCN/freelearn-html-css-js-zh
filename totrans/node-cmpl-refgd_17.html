<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consuming a RESTful API</h1>
                </header>
            
            <article>
                
<p>To demonstrate some more advanced topics related to the consumption of our API, we will implement a really simple web client. It will help us cover those topics, and it can serve as a reference implementation for the catalog's consumers. For this frontend client, we will use the famous JavaScript library, jQuery. Utilizing it will help us cover the following:</p>
<ul>
<li>Consuming RESTful services with jQuery</li>
<li>Content Delivery Network</li>
<li>Troubleshooting and identifying problems on the wire</li>
<li>Cross-Origin Resource Sharing policy</li>
<li>Client-side handling of different HTTP status codes</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consuming RESTful services with jQuery</h1>
                </header>
            
            <article>
                
<p>JQuery is a fast, light, and powerful JavaScript library; it eliminates DOM-related complexity by providing direct access to HTML elements once the DOM three has been loaded. To use jQuery within an HTML document, you have to import it:</p>
<p><kbd>&lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js "&gt;&lt;/script&gt;</kbd></p>
<p>Assume that somewhere within an HTML document, there is a button defined as <kbd>&lt;input type="button" id="btnDelete" value="Delete"/&gt;</kbd>.</p>
<p>To assign a function to the click event of this button with JQuery means we need to do the following:</p>
<ol>
<li>Import the jquery library in the HTML document</li>
<li>Assure that the DOM document of the HTML document is completely loaded</li>
<li>Access the button using the identifier defined by the ID attribute</li>
<li>Provide a handler function as an argument to the <kbd>click</kbd> event:</li>
</ol>
<pre style="padding-left: 60px">$(document).ready(function() {<br/>    $('#btn').click(function () {<br/>       alert('Clicked');<br/>    });<br/>});</pre>
<p>The <kbd>$('#identifier')</kbd> expression provides direct access to elements in DOM three, <kbd>$</kbd> states that an object is referenced, and the value within the bracket, prefix by <kbd>#</kbd> specifies its identifier. jQuery will have access to the element only after the entire document has been loaded; that's why elements should be accessed within <kbd>${document).ready()</kbd> block scope.</p>
<p>Similarly, you can access the value of a text input with an identifier <kbd>txt</kbd>:</p>
<pre class="mce-root">  $(document).ready(function() {<br/>    var textValue = $('#txt').val();<br/>    });<br/>  });</pre>
<p>The <kbd>$(document)</kbd><em> </em><span>object </span>is predefined in jQuery and represents the entire DOM document of the HTML page. In a similar way, jQuery predefines a function for AJAX-enabled communication, that is, for sending HTTP request to an HTTP endpoint. This function is named after <strong>Asynchronous JavaScript + XML-</strong> AJAX, which was the de facto standard that enabled a JavaScript application to communicate with HTTP-enabled backends. Nowadays, <strong>JSON</strong> is being widely used; however, naming conversion for AJAX is still used as a term for asynchronous communication, regardless of the data format; that is why the predefined function in jQuery is called <kbd>$.ajax(options, handlers)</kbd>.</p>
<p>To send an http request with the <kbd>$.ajax</kbd> function, invoke it by providing the endpoint URL, http method for the request, and its content type; the result will be returned in a callback function. The following example shows how an item with identifier 3 is requested from our catalog:</p>
<pre>  $.ajax({<br/>      contentType: 'application/json',<br/>      url: 'http://localhost:3000/catalog/v2/item/3',<br/>      type: 'GET',<br/>      success: function (item, status, xhr) {<br/>          if (status === 'success') {<br/>              //the item is successfully retrieved load &amp; display its details here<br/>          }<br/>      }<br/>      ,error: function (xhr, options, error) {<br/>        //Item was not retrieved due to an error handle it here<br/>      }<br/>    });<br/>  });</pre>
<p>Posting data to an endpoint is rather similar:</p>
<pre>  $.ajax({<br/>    url: "http://localhost:3000/catalog/v2/",<br/>    type: "POST",<br/>    dataType: "json",<br/>    data: JSON.stringify(newItem),<br/>     success: function (item, status, xhr) {<br/>       if (status === 'success') {<br/>         //item was created successfully<br/>       }<br/>     },<br/>     error: function(xhr, options, error) {<br/>       //Error occurred while creating the iteam<br/>     }<br/>   });<br/><br/></pre>
<p>Simply use the appropriate options <kbd>type</kbd> set to POST, and the <kbd>dateType</kbd> set to JSON. Those will specify that a POST request is to be sent to the endpoint in the JSON format. The payload of the object is provided as a value to the <kbd>data</kbd> attribute.</p>
<p>Invoking a <kbd>delete</kbd> method is quite similar:</p>
<pre>      $.ajax({<br/>        contentType: 'application/json',<br/>        url: 'http://localhost:3000/catalog/v2/item/3',<br/>        type: 'DELETE',<br/>        success: function (item, status, xhr) {<br/>            if (status === 'success') {<br/>              //handle successful deletion<br/>            }<br/>        }        <br/>        ,error: function (xhr, options, error) {<br/>            //handle errors on delete<br/>        }<br/>      });</pre>
<p>A basic understanding of how jQuery works is just about fine for the scope of this book. Now, let's glue all this together and create two HTML pages; that way, we will handle creating, displaying, and deleting an item in our catalog, starting with the page that displays an item and allows its deletion. This page loads an item from the catalog using <kbd>GET</kbd> request, and then displays the item's attributes in the HTML page in a table-like manner:</p>
<pre>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;Item&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js "&gt;&lt;/script&gt;<br/>  &lt;script&gt;<br/>  $(document).ready(function() {<br/>    $('#btnDelete').click(function () {<br/>      $.ajax({<br/>        contentType: 'application/json',<br/>        url: 'http://localhost:3000/catalog/v2/item/3',<br/>        type: 'DELETE',<br/>        success: function (item, status, xhr) {<br/>            if (status === 'success') {<br/>              $('#item').text('Deleted');<br/>              $('#price').text('Deleted');<br/>              $('#categories').text('Deleted');<br/>            }<br/>        }<br/>        ,error: function (xhr, options, error) {<br/>          alert('Unable to delete item');<br/>        }<br/>      });<br/>    });<br/>    $.ajax({<br/>      contentType: 'application/json',<br/>      url: 'http://localhost:3000/catalog/v2/item/3',<br/>      type: 'GET',<br/>      success: function (item, status, xhr) {<br/>          if (status === 'success') {<br/>            $('#item').text(item.itemName);<br/>            $('#price').text(item.price + ' ' + item.currency);<br/>            $('#categories').text(item.categories);<br/>          }<br/>      }<br/>      ,error: function (xhr, options, error) {<br/>        alert('Unable to load details');<br/>      }<br/>    });<br/>  });<br/>  &lt;/script&gt;<br/>  &lt;div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Item: &lt;/div&gt;<br/>      &lt;div&gt;&lt;span id="item"/&gt;k&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Price: &lt;/div&gt;<br/>      &lt;div&gt;&lt;span id="price"/&gt;jjj&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Categories: &lt;/div&gt;<br/>      &lt;div&gt;&lt;span id="categories"/&gt;jjj&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;&lt;input type="button" id="btnDelete" value="Delete"/&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The page that handles creation is quite similar. However, it provides text inputs instead of span labels for an item's fields, where the view page will display the data for the attributes of the loaded item. JQuery provides a simplified access model to the input controls, rather than DOM—simply access the input element as follows:</p>
<pre>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;Item&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js "&gt;&lt;/script&gt;<br/>  &lt;script&gt;<br/>  $(document).ready(function() {<br/>    $('#btnCreate').click(function(){<br/>      var txtItemName = $('#txtItem').val();<br/>      var txtItemPrice = $('#txtItemPrice').val();<br/>      var txtItemCurrency = $('#txtItemCurrency').val();<br/>      var newItem = {<br/>        itemId: 4,<br/>        itemName: txtItemName,<br/>        price: txtItemPrice,<br/>        currency: txtItemCurrency,<br/>        categories: [<br/>          "Watches"<br/>        ]<br/>      };<br/>      $.ajax({<br/>        url: "http://localhost:3000/catalog/v2/",<br/>        type: "POST",<br/>        dataType: "json",<br/>        data: JSON.stringify(newItem),<br/>        success: function (item, status, xhr) {<br/>              alert(status);<br/>            }<br/>      });<br/>    })<br/>  });<br/>  &lt;/script&gt;<br/>  &lt;div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Id: &lt;/div&gt;<br/>      &lt;div&gt;&lt;input type="text" id="id"/&gt;&lt;/div&gt;<br/><br/>      &lt;div style="float:left; width: 80px;"&gt;Item: &lt;/div&gt;<br/>      &lt;div&gt;&lt;input type="text" id="txtItem"/&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Price: &lt;/div&gt;<br/>      &lt;div&gt;&lt;input type="text" id="price"/&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div style="position: relative"&gt;<br/>      &lt;div style="float:left; width: 80px;"&gt;Categories: &lt;/div&gt;<br/>      &lt;div&gt;&lt;input type="text" id="categories"/&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;&lt;input type="button" id="btnCreate" value="Create"/&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Let's give that a try and load an existing item in the view page by opening our static page directly from the filesystem in a browser of your choice. It looks as if we have some kind of a problem, as nothing gets displayed. Enabling client-side debugging using the browser's developer suite doesn't give much more information either:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/0b436898-ce3a-401f-9f8a-03f6f24c5f06.png" width="1380" height="436"/></div>
<p>It states that the content is partially blocked; however, it is not quite clear whether this is due to a backend-related error, or something has gone wrong on the client side. We will look at how to troubleshoot such problematic situations in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Troubleshooting and identifying problems on the wire</h1>
                </header>
            
            <article>
                
<p>Sometimes the interaction between the client and the server fails, and the reason for such failures often requires analysis; otherwise, their root cause stays unknown. We spotted that our client application does not load and thus doesn't display data for an existing item. Let's try to investigate the root cause for that by setting up an <kbd>http</kbd> tunnel between the client and the server. This will be a kind of MiM (man-in-the-middle)-based investigation, as we will listen to one port and redirect the incoming request to another, to see whether the server returns correct responses or its pipe gets broken somewhere in the middle. There are various TCP tunnels available out there; I have been using a simple open source one available on GitHub at <a href="https://github.com/vakuum/tcptunnel">https://github.com/vakuum/tcptunnel</a>. Its author also maintains a separate website where you can download prebuilt binaries for the most common operating system; they are available at <a href="http://www.vakuumverpackt.de/tcptunnel/">http://www.vakuumverpackt.de/tcptunnel/</a>.</p>
<p>After you have built or downloaded a copy of the tunnel, start it as follows:</p>
<p><kbd>./tcptunnel --local-port=3001 --remote-port=3000 --remote-host=localhost --log</kbd></p>
<p>This will start the application listening on port 3001 and will forward each incoming request to location port 3000; the <kbd>--log</kbd> option specifies that all the data flow passing the tunnel should be logged in the console. Finally, modify HTML pages to use port 3001 instead of 3000, and let's see what the tunnel would show us after firing new GET request for the item with id 3, this time on port <kbd>3001: http://localhost:3001/catalog/v2/item/3</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/0cfcd321-5119-4be0-9ed5-bd6ba36433ed.png" width="1092" height="469"/></div>
<p>Surprisingly, the tunnel shows that the server responds normally with <kbd>200 OK</kbd> and a relevant payload. So it seems as if the problem is not on the server side.</p>
<p>Well, since the error is obviously not on the server side, let's try to investigate deeper what has happened on the client side. Nowadays, all popular browsers have so-called web developer tools. They provide access to <kbd>http</kbd> logs, dynamically-rendered code, the DOM three of the HTML document, and so on. Let's invoke our RESTful GET operation with Mozillas Firefox and see what its web console will log about our request. Open the Mozilla Firefox menu and select <kbd>Web Developer</kbd>, and then select <kbd>Browser Console</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/108af34a-7ae8-4c75-ae49-437241ba2207.png" width="900" height="271"/></div>
<p>Aha! Seems like we found it: <kbd>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remove resource at...</kbd>.<br/>
This error is blocking the server-side response at client level. In the next section, we will see what this actually means.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross Origin Resource Sharing</h1>
                </header>
            
            <article>
                
<p>Cross-site HTTP requests are requests that refer to resources to be loaded from a domain different from the one that initially requested them. In our case, we started the client from our filesystem, and it requested resources from a network address. This is considered a potential <strong>Cross-site scripting</strong> request, which, according to the <strong>W3C recommendation</strong> at <a href="http://w3.org/cors/TR/cors">http://w3.org/cors/TR/cors</a>, should be carefully handled. This means that if an external resource is requested, the domain where it is requested from—its Origin—should be explicitly specified in a header, as long as an external resource loading is not allowed in general. This mechanism prevents Cross-Side Scripting (XSS) attacks, and it is based on HTTP headers.</p>
<p>The following HTTP request headers specify how external resources should be handled on the client side:</p>
<ul>
<li><kbd>Origin</kbd> defines where the request originated from</li>
<li><kbd>Access-Control-Request-Method</kbd> defines the HTTP method that was used to request the resource</li>
<li><kbd>Access-Control-Request-Header</kbd> defines any headers that will be allowed in combination with the external resource request</li>
</ul>
<p>On the server side,  the following headers indicate whether a response is eligible for a CORS-enabled client request:</p>
<ul>
<li><kbd>Access-Control-Allow-Origin</kbd>: This header either, if exists, specifies that the requester's host is allowed by repeating it, or it could specify that all remote origins are allowed by returning a wildcard: '*'</li>
<li><kbd>Access-Control-Allow-Methods</kbd>: This header specifies the HTTP methods that the server would allow from cross-side's domain</li>
<li><kbd>Access-Control-Allow-Headers</kbd>: This header specifies the HTTP headers that the server would allow from cross-side's domain</li>
</ul>
<p>There are some more <kbd>Access-Control-*</kbd> headers that can be used for further granularity when incoming XSS requests are to be served, or not, based on credentials and request's max-age, but basically, the most important ones are for the allowed origin, allowed methods, and allowed headers.</p>
<p>There is a node module that handles <kbd>CORS</kbd> configuration at server side; it is installed by <kbd>npm install -g cors</kbd> and is easily enabled in our application via a middleware module. Simply use it in all the exposed routes by passing it to the application:</p>
<pre>app.use(cors());</pre>
<p>Use the tunnel after you enabled the <kbd>cors</kbd> middleware to see that the server would now gracefully handle requests from different origins by serving the "Access-Control-Allow-Origin' header set to '*'":</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/878c48f5-d925-4b5e-b648-d38828558808.png" width="1092" height="467"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Content Delivery Networks</h1>
                </header>
            
            <article>
                
<p>When we imported the jQuery library into our client application, we directly referred to its optimized source from its vendor as <kbd>&lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js "/&gt;</kbd>.</p>
<p>Now, imagine that for some reason this site goes down either temporarily or for good; this will make our application unusable, as the import wouldn't work.</p>
<p>Content Delivery Networks come to help in these cases. They serve as a repository for libraries or other static media content, assuring that the needed resources will be available without downtime, even when something goes wrong with their vendors. One of the most popular JavaScript CDNs is <a href="https://cdnjs.com/">https://cdnjs.com/</a>; it provides the most common JS libraries available out there. We will switch our clients to refer to the jquery library from this CDN rather than from its vendors' website at <kbd><span>&lt;script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js "/&gt;</span></kbd>.</p>
<p>While there is hardly anything wrong with directly downloading your JS libraries and placing them in the static directory of your node.js project, it may lead to having local changes and fixes directly in your library dependencies. This can easily result in incompatible changes and can prevent your application from easily switching to newer versions in the future. As long as your dependencies are open source, you should strive to improve them by contributing fixes or reporting bugs rather than having fixes in your own local fork. Still, if you are unfortunate enough to run into a bug that you can easily fix, you can fork the library to resolve your problem faster. However, always consider contributing <span>the fix</span><span> </span>back to the community. After it is accepted, switch back to the official version; otherwise, you will find yourself in a difficult situation the next time with another issue, and the community would track it much harder if reported from a forked version. That is the beauty of open source, and that is why you should always consider consuming JavaScript APIs' Content Delivery Networks. They will provide you with the stability and support you may need at any point in the life of your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling HTTP status codes on the client side</h1>
                </header>
            
            <article>
                
<p>We spent quite some time addressing how RESTful services should represent each state, including erroneous ones, gracefully. A well-defined API should demand from its consumers to handle all its errors gracefully and to provide as much information per state as required, rather than just stating "An error has occurred". That is why it should look up the returned status code and clearly distinguish between client requests such as <kbd>400 Bad Request</kbd> or <kbd>415 Unsupported media types</kbd> caused by faulty payload, caused by wrong media types, or authentication-related errors, such as <kbd>401 Unauthorized</kbd>.</p>
<p>The status code of an erroneous response is available in the <kbd>error</kbd> callback of the jQuery callback function and should be used to provide detailed information back to the request:</p>
<pre> $.ajax({<br/>        url: "http://localhost:3000/catalog/v2/",<br/>        type: "POST",<br/>        dataType: "json",<br/>        data: JSON.stringify(newItem),<br/>        success: function (item, status, jqXHR) {<br/>            alert(status);<br/>        },<br/>        error: function(jqXHR, statusText, error) {<br/>            switch(jqXHR.status) {<br/>               case 400: alert('Bad request'); break;<br/>               case 401: alert('Unauthroizaed'); break;<br/>               case 404: alert('Not found'); break;<br/>               //handle any other client errors below<br/>               case 500: alert('Internal server error); break;<br/>               //handle any other server errors below<br/>            }<br/>        }<br/>      });</pre>
<p>Unsuccessful requests are handled by the error callback function. It provides <kbd>jqXHR</kbd> - the <kbd>XmlHttpRequest</kbd> JavaScript<em>—</em>object <span>as its first argument</span>. It carries across all the request/response related information, such as status code and headers. Use it to determine what the requested server has returned so that your application can handle different errors more granularly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we implemented a simple web-based client with the jQuery library. We utilized this client to demonstrate how the Cross-Origin Resource Sharing policy works, and we used a man in the middle means to troubleshoot issues on the wire. Finally, we looked at how errors should be handled on the client side. This chapter brings us one step closer to the end of our journey, as we got the first consumer of our service. In the next chapter, we will walk you through the final step before bringing a service to production—choosing its security model.</p>


            </article>

            
        </section>
    </div>



  </body></html>