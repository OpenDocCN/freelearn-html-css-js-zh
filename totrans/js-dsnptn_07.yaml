- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Rendering Strategies and Page Hydration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染策略和页面激活
- en: Rendering strategies and page hydration approaches allow us to leverage the
    JavaScript client and server ecosystem to serve performant and scalable web applications,
    depending on the needs of our end users. The React and JavaScript techniques covered
    in this chapter are another set of tools to augment the [*Chapter 4*](B19109_04.xhtml#_idTextAnchor130)
    chapter. We’ll use the strengths of the client (browser) and server (specifically,
    Node.js) runtimes to deliver fast and scalable React websites to users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染策略和页面激活方法允许我们利用 JavaScript 客户端和服务器生态系统来提供高性能和可扩展的 Web 应用程序，这取决于我们最终用户的需求。本章中涵盖的
    React 和 JavaScript 技术是增强 [*第 4 章*](B19109_04.xhtml#_idTextAnchor130) 的另一套工具。我们将利用客户端（浏览器）和服务器（特别是
    Node.js）运行时的优势，为用户提供快速和可扩展的 React 网站。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What the trade-offs are between client and server rendering of React applications
    by implementing pure client and server rendering applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现纯客户端和服务器端渲染应用程序，了解 React 应用程序客户端和服务器渲染之间的权衡
- en: The types of advantages that frameworks such as Next.js can bring with static
    site generation functionality, alongside server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架如 Next.js 通过静态站点生成功能和服务器端渲染功能可以带来的优势类型
- en: Bridging the client-server rendering gap with a React page rehydration example
    and its gotchas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 页面激活示例及其注意事项来弥合客户端-服务器渲染差距
- en: Streaming server rendering in React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 中的流式服务器端渲染
- en: By the end of this chapter, you’ll be able to select appropriate rendering and
    page hydration strategies with React and be able to implement framework-level
    functionality, enabling you to make better technology choices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 React 选择合适的渲染和页面激活策略，并能够实现框架级别的功能，从而让你做出更好的技术选择。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，网址为 [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: Client and server rendering with React
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 的客户端和服务器渲染
- en: In a web context, client-side rendering is the process by which JavaScript is
    used inside a user’s browser to generate or update the page contents. A fully
    client-side-rendered application will only display meaningful content when the
    relevant JavaScript code has completed downloading, parsing, and running.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络环境中，客户端渲染是通过在用户的浏览器中使用 JavaScript 生成或更新页面内容的过程。一个完全客户端渲染的应用程序只有在相关的 JavaScript
    代码完成下载、解析和运行后才会显示有意义的内容。
- en: In the following sequence diagram, we use the term “origin” instead of something
    such as “server,” since one benefit of full client-side rendering is that the
    resources “serving” our content can be what’s called *static hosting*. This includes
    services such as **AWS Simple Storage Service** (**S3**), Netlify, Cloudflare
    Pages, and GitHub Pages, among others. There’s no dynamic server-side component
    in these services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的序列图中，我们使用“origin”而不是“服务器”等术语，因为全客户端渲染的一个好处是，为我们内容“提供服务”的资源可以是所谓的 *静态托管*。这包括
    AWS 简单存储服务（**S3**）、Netlify、Cloudflare Pages 和 GitHub Pages 等服务。在这些服务中没有动态的服务器端组件。
- en: '![Figure 5.1: A client-side-rendering sequence diagram](img/B19109_05_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：客户端渲染序列图](img/B19109_05_1.jpg)'
- en: 'Figure 5.1: A client-side-rendering sequence diagram'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：客户端渲染序列图
- en: In contrast, server-side rendering denotes the process by which a server generates
    a full HTML document when a browser requests it and returns it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，服务器端渲染指的是当浏览器请求时，服务器生成一个完整的 HTML 文档并返回的过程。
- en: "![Figure 5.2: A server-side-rendering sequence \uFEFFdiagram](img/B19109_05_2.jpg)"
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：服务器端渲染序列图](img/B19109_05_2.jpg)'
- en: 'Figure 5.2: A server-side-rendering sequence diagram'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：服务器端渲染序列图
- en: Client-side rendering in React
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 中的客户端渲染
- en: 'Client rendering is the default rendering method with React. Let’s build an
    application that renders client-side from scratch:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，客户端渲染是默认的渲染方法。让我们从头开始构建一个从客户端渲染的应用程序：
- en: 'We start with an **App** component that renders some text and its **type**
    prop:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个渲染一些文本及其 **type** 属性的 **App** 组件开始：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We then create an entry point file, **client.jsx**, which imports the app and
    uses **ReactDOM** to render it, with the **type** prop set to **"****client render"**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个入口点文件，**client.jsx**，它导入应用程序并使用 **ReactDOM** 来渲染它，将 **type** 属性设置为
    **"****client render"**。
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order for this example to run, we need an HTML document that allows **ReactDOM.createRoot**
    to run successfully. In other words, we need an HTML document that has an element
    with **id=app** and references our entry point:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此示例运行，我们需要一个允许 **ReactDOM.createRoot** 成功运行的 HTML 文档。换句话说，我们需要一个具有 **id=app**
    元素并引用我们的入口点的 HTML 文档：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the entry point is **dist/client.js** instead of **client.jsx**.
    That’s due to the fact that React’s JSX syntax can’t be run natively in the browser.
    Instead, we run our entry point file, **client.jsx**, through a compilation and
    bundling step using **esbuild**. Our build command looks something like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，入口点是 **dist/client.js** 而不是 **client.jsx**。这是因为 React 的 JSX 语法不能在浏览器中本地运行。相反，我们通过使用
    **esbuild** 进行编译和打包步骤来运行我们的入口点文件，**client.jsx**。我们的构建命令看起来像这样：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if we load the `index.html` file in the browser, we see the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们加载浏览器中的 `index.html` 文件，我们会看到以下内容：
- en: "![Figure 5.3: Hello from the “client render” app rendered in t\uFEFFhe browser](img/B19109_05_3.jpg)"
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：来自“客户端渲染”应用，在浏览器中渲染](img/B19109_05_3.jpg)'
- en: 'Figure 5.3: Hello from the “client render” app rendered in the browser'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：来自“客户端渲染”应用，在浏览器中渲染
- en: Server rendering in React
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 的服务器端渲染
- en: Node.js, introduced on its website as “an open-source, cross-platform JavaScript
    runtime environment,” gives us the ability to run JavaScript on a server. A commonly
    used package to build servers in Node.js is Express.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js，在其网站上介绍为“一个开源、跨平台的 JavaScript 运行时环境”，使我们能够在服务器上运行 JavaScript。在 Node.js
    中构建服务器的常用包是 Express。
- en: In this section, we’ll see how to use Node.js and Express to server-render a
    React application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用 Node.js 和 Express 来服务器端渲染一个 React 应用程序。
- en: 'A simple Express server that returns `''Server-rendered hello''` when the root
    path is loaded looks as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 Express 服务器，当加载根路径时返回 `'Server-rendered hello'`，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, we’ll use `esbuild` to bundle and compile the JSX to JavaScript:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用 `esbuild` 来打包和编译 JSX 到 JavaScript：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then start the server using the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令启动服务器：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, it runs on port `3000`, but that can be overridden with environment
    variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它运行在端口 `3000`，但可以通过环境变量来覆盖。
- en: When we load `localhost:3000`, we see this message in the browser.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载 `localhost:3000` 时，在浏览器中会看到以下消息。
- en: '![Figure 5.4: Server-rendered hello rendered in the browser](img/B19109_05_4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：在浏览器中渲染的服务器端渲染的“hello”](img/B19109_05_4.jpg)'
- en: 'Figure 5.4: Server-rendered hello rendered in the browser'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：在浏览器中渲染的服务器端渲染的“hello”
- en: This is a really minimal example of server-rendering using Node.js and Express.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 Node.js 和 Express 进行服务器端渲染的非常简单的示例。
- en: 'Next, we’ll see how to leverage the `ReactDOM` package to take React components
    and server-render them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何利用 **ReactDOM** 包将 React 组件服务器端渲染：
- en: The **ReactDOM** package provides both a **react-dom/client** entry point (which
    we used in the previous section) and a **react-dom/server** entry point. As the
    names allude to, the client entry point is meant to be used on the client (in
    the browser, “client-side” JavaScript), and the server entry point is meant to
    be used on the server (via Node.js or another server-side JavaScript runtime).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ReactDOM** 包提供了两个入口点：**react-dom/client**（我们在上一节中使用过）和 **react-dom/server**。正如名称所暗示的，客户端入口点旨在在客户端（在浏览器中，“客户端”JavaScript）使用，而服务器入口点则旨在在服务器（通过
    Node.js 或其他服务器端 JavaScript 运行时）使用。'
- en: The two methods we’ll use are **ReactDOMServer.renderToStaticMarkup** and **ReactDOMServer.renderToString**;
    these two methods will allow us to server-render our React application to HTML.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用两种方法：**ReactDOMServer.renderToStaticMarkup** 和 **ReactDOMServer.renderToString**；这两个方法将允许我们将
    React 应用程序服务器端渲染为 HTML。
- en: 'In a **src/server-render.jsx** file, we have the following **renderNav** and
    **serverRenderApp** functions, which use **ReactDOMServer.renderToStaticMarkup**
    and **ReactDOMServer.renderToString** to render **Nav** and **App**, respectively:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 **src/server-render.jsx** 文件中，我们有以下 **renderNav** 和 **serverRenderApp**
    函数，它们分别使用 **ReactDOMServer.renderToStaticMarkup** 和 **ReactDOMServer.renderToString**
    来渲染 **Nav** 和 **App**：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, `app.jsx` is the same as we had in the previous section, and `nav.jsx`
    is as follows:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`app.jsx` 与上一节中的相同，而 `nav.jsx` 如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then use **renderNav** and **serverRenderApp** in **server.js**. We
    modify the **app.get(''/'')** handler to render the navigation and the app:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在**server.js**中使用**renderNav**和**serverRenderApp**。我们修改**app.get('/')**处理程序以渲染导航和应用程序：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we rebuild the server, we run **node dist/server.js** and open **localhost:3000**
    to see the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们重新构建服务器时，我们运行**node dist/server.js**并打开**localhost:3000**以查看以下内容：
- en: '![Figure 5.5: Hello from the “server render” app being rendered alongside a
    heading and the nav](img/B19109_05_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：来自“服务器渲染”应用，与标题和导航一起渲染](img/B19109_05_5.jpg)'
- en: 'Figure 5.5: Hello from the “server render” app being rendered alongside a heading
    and the nav'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：来自“服务器渲染”应用，与标题和导航一起渲染
- en: What’s the difference between `ReactDOMServer.renderToStaticMarkup` and `ReactDOMServer.renderToString?`
    The short answer is that `renderToStaticMarkup` can’t be rehydrated client-side;
    in other words, it can’t be used as the initial HTML, and then the same React
    application code can be run client-side to give a fully interactive experience.
    We’ll revisit this in a later section of the chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOMServer.renderToStaticMarkup`和`ReactDOMServer.renderToString`之间的区别是什么？简短的回答是`renderToStaticMarkup`不能在客户端重新激活；换句话说，它不能用作初始HTML，然后相同的React应用程序代码可以在客户端运行以提供完全交互式的体验。我们将在本章的后续部分重新讨论这个问题。'
- en: Trade-offs between client and server rendering
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端和服务器渲染之间的权衡
- en: So, what are the benefits and drawbacks of client and server rendering?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，客户端和服务器渲染有什么优点和缺点？
- en: Client rendering’s main benefit is that the application’s “work” is done fully
    in the user’s browsers, which makes it highly scalable since the amount of users
    using the system will not put pressure on the origin servers. Client rendering’s
    main drawbacks relate to functionality that is only available on the server side
    – for example, server-side-only cookies or setting the `meta` tags for social
    media preview.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染的主要优势在于应用程序的“工作”完全在用户的浏览器中完成，这使得它具有高度的可扩展性，因为使用该系统的用户数量不会对原始服务器造成压力。客户端渲染的主要缺点与仅在服务器端可用的功能相关——例如，仅服务器端cookie或设置社交媒体预览的`meta`标签。
- en: Server rendering’s main drawback is that work has to happen on the server. As
    stated previously, the server being a “controlled” environment has some benefits,
    namely its latency to other co-located systems will tend to be lower than a full
    browser-server round trip, since the server’s network is known and unlikely to
    have as much variance in performance as an end user’s network. By not waiting
    for a full-page load, followed by an asset load, followed by a JavaScript “parse
    and execute” cascade, server-rendering can improve “core web vitals”, such as
    **largest** **contentful** **paint** (**LCP**) and **cumulative layout** **shift**
    (**CLS**).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器渲染的主要缺点是工作必须在服务器上完成。如前所述，服务器作为一个“受控”环境有一些好处，即其与其他协同定位系统的延迟通常低于完整的浏览器-服务器往返，因为服务器的网络是已知的，并且不太可能像最终用户网络那样有太多的性能差异。通过不等待完整页面加载，然后是资产加载，然后是JavaScript“解析和执行”级联，服务器渲染可以提高“核心Web指标”，如**最大内容绘制**（**LCP**）和**累积布局偏移**（**CLS**）。
- en: Ultimately, client-rendered functionality is a key reason we use JavaScript,
    which means removing that ability will only make sense in constrained use cases
    such as content sites (e.g., blogs, news sites, and documentation sites).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，客户端渲染的功能是我们使用JavaScript的关键原因，这意味着在受限的使用案例中移除这种能力才有意义，例如内容网站（例如博客、新闻网站和文档网站）。
- en: We’ve now seen the difference between client and server rendering, as well as
    how to implement both with React and Node.js. In the following section, we’ll
    look at rendering approaches enabled by the Next.js framework for React.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了客户端和服务器渲染之间的区别，以及如何使用React和Node.js实现它们。在接下来的部分，我们将探讨Next.js框架为React提供的渲染方法。
- en: Static rendering with Next.js
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Next.js进行静态渲染
- en: Next.js is a React framework for creating full stack web applications. What
    this means is that it provides tools and opinions that will help developers be
    more productive in the short and long term.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js是一个用于创建全栈Web应用的React框架。这意味着它提供了工具和观点，将帮助开发者短期和长期内提高生产力。
- en: Next.js includes a filesystem router for “pages”, a set of routing primitives
    for React, support for client and server rendering, and data fetching primitives,
    among others.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js包括用于“页面”的文件系统路由器、一组React路由原语、客户端和服务器渲染支持以及数据获取原语等。
- en: The features of Next.js we’ll focus on are the **static site generation** (**SSG**)
    ones. This type of rendering methodology resembles server rendering but mitigates
    some of its drawbacks, since the rendering pass is done at build time instead
    of at request time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注的 Next.js 功能是 **静态站点生成**（**SSG**）。这种渲染方法类似于服务器端渲染，但通过在构建时而不是在请求时进行渲染，缓解了一些缺点。
- en: '![Figure 5.6: A sequence diagram for a pre-rendered/static site generation
    use case](img/B19109_05_6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：预渲染/静态站点生成用例的序列图](img/B19109_05_6.jpg)'
- en: 'Figure 5.6: A sequence diagram for a pre-rendered/static site generation use
    case'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：预渲染/静态站点生成用例的序列图
- en: Now that we’ve looked at how static site generation changes the data flow when
    a user requests a website, we’ll look at Next.js automatic static generation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了当用户请求一个网站时，静态站点生成如何改变数据流，接下来我们将探讨 Next.js 的自动静态生成。
- en: Automatic static generation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动静态生成
- en: In Next.js, the filesystem-based routing means that each path in your web application
    corresponds to a file in the `pages` directory of your application. For example,
    `/` corresponds to `pages/index.js`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 中，基于文件系统的路由意味着您的 Web 应用程序中的每个路径都对应于应用程序 `pages` 目录中的一个文件。例如，`/` 对应于
    `pages/index.js`。
- en: Next.js defaults to static generation when no Next.js data fetching methods
    are used for a given page. You can find more information from the Next.js documentation
    – *Automatic Static* *Optimization* ([https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定页面没有使用 Next.js 数据获取方法时，Next.js 默认使用静态生成。您可以从 Next.js 文档中找到更多信息 – *自动静态优化*
    ([https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization))。
- en: Next.js automatically determines that a page is static (i.e., can be prerendered)
    if it has no blocking data requirements. This determination is made by the absence
    of getServerSideProps and getInitialProps on the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个页面没有阻塞数据需求（即，可以被预渲染），Next.js 会自动确定该页面是静态的。这种判断是通过页面上不存在 `getServerSideProps`
    和 `getInitialProps` 来实现的。
- en: 'For example, the following page in a Next.js application will be statically
    generated, since it only exports a page component (the default export of `Index`);
    no `getServerSideProps` or `getInitialProps` function is exported:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Next.js 应用程序中的以下页面将会被静态生成，因为它只导出了一个页面组件（`Index` 的默认导出）；没有导出 `getServerSideProps`
    或 `getInitialProps` 函数：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see this during `next build` in the following screenshot; `/ route (page)`
    is marked as `Static` in the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中的 `next build` 过程中看到这一点；输出中的 `/ route (page)` 被标记为 `Static`：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we run the built Next.js output with `next start`, the page behaves as
    expected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `next start` 运行构建的 Next.js 输出时，页面会按预期行为。
- en: '![Figure 5.7: Links to the Products and Cart pages rendering](img/B19109_05_7.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：产品页和购物车页面的链接渲染](img/B19109_05_7.jpg)'
- en: 'Figure 5.7: Links to the Products and Cart pages rendering'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：产品页和购物车页面的链接渲染
- en: This example is a relatively constrained use case since we have no dynamic data
    fetching requirements. It still showcases Next.js defaulting to static rendering
    if the page does not use any functionality that excludes static generation. For
    more advanced use cases, Next.js also allows use of “build-time” dynamic data,
    which means we can use a third-party data source to generate the page content,
    and more.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有动态数据获取需求，这个例子是一个相对受限的用例。它仍然展示了如果页面没有使用任何排除静态生成的功能，Next.js 默认会进行静态渲染。对于更高级的用例，Next.js
    还允许使用“构建时”动态数据，这意味着我们可以使用第三方数据源来生成页面内容，等等。
- en: We’ve seen how Next.js defaults to automatic static generation. Next, we’ll
    see how to configure a Next.js page to load data to render a page as static.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Next.js 默认使用自动静态生成。接下来，我们将看到如何配置 Next.js 页面以加载数据以将页面作为静态内容渲染。
- en: Static generation with a third-party data source
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方数据源的静态生成
- en: Next.js has a `getStaticProps` data fetching method that allows us to load data
    at build time, which will be passed to a page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 有一个 `getStaticProps` 数据获取方法，允许我们在构建时加载数据，这些数据将被传递给页面。
- en: 'The following sequence diagram illustrate what this involves:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图展示了这涉及的内容：
- en: '![Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps](img/B19109_05_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：使用 getStaticProps 进行 Next.js 预渲染的序列图](img/B19109_05_08.jpg)'
- en: 'Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：使用 getStaticProps 的 Next.js 预渲染序列图
- en: 'For example, if we want to build a “product list” page based on `fakestoreapi.com`
    data, we can write the following `getStaticProps` method in a `pages/products/index.js`
    page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想基于 `fakestoreapi.com` 的数据构建一个“产品列表”页面，我们可以在 `pages/products/index.js`
    页面中编写以下 `getStaticProps` 方法：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s a `product` example in the response to illustrate the data shape:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `product` 示例，以说明数据结构：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Based on the data provided by `getStaticProps`, we can build a `ProductIndexPage`
    component. We’ll loop through each product from `props.products` and render them
    in an unordered list. Each item will include a link to the `/products/[id]` page
    (which doesn’t exist yet):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `getStaticProps` 提供的数据，我们可以构建一个 `ProductIndexPage` 组件。我们将遍历 `props.products`
    中的每个产品，并将它们渲染在一个无序列表中。每个条目将包括一个链接到 `/products/[id]` 页面（该页面尚不存在）：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This page will now be built when `next build` is run. As we can see from the
    output, the `/products` page is marked as `SSG` (static site generation):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `next build` 时，此页面现在将被构建。正如我们从输出中可以看到的，`/products` 页面被标记为 `SSG`（静态站点生成）：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we start the Next.js server with `next start` and navigate to `/products`,
    we see the following. Note that the products on the page won’t change unless we
    rebuild the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `next start` 启动 Next.js 服务器并导航到 `/products` 时，我们会看到以下内容。请注意，除非我们重新构建应用程序，否则页面上的产品不会改变。
- en: '![Figure 5.9: The Products list page is statically pre-rendered with products
    from fakestoreapi.com](img/B19109_05_9.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：使用 fakestoreapi.com 的产品静态预渲染的产品列表页面](img/B19109_05_9.jpg)'
- en: 'Figure 5.9: The Products list page is statically pre-rendered with products
    from fakestoreapi.com'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：使用 fakestoreapi.com 的产品静态预渲染的产品列表页面
- en: We’ve seen how to use `getStaticProps` to generate pages based on a third-party
    API, but how would we generate the `/products/[id]` pages ahead of them being
    requested? To do that, we need to be able to provide the “required paths” (or
    URLs) that Next.js needs to generate. This is what we’ll look at in the following
    section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `getStaticProps` 根据第三方 API 生成页面，但在请求之前如何生成 `/products/[id]` 页面呢？为了做到这一点，我们需要能够提供
    Next.js 需要生成所需的“必需路径”（或 URL）。这就是我们将在下一节中要查看的内容。
- en: Static generation with dynamic paths
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于动态路径的静态生成
- en: It can be useful to pre-generate pages with dynamic paths and contents.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 预先生成具有动态路径和内容的页面可能很有用。
- en: We could use `getServerSideProps` and render the pages on demand. In the context
    that we’re working in, that would be valid for a “cart” page.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `getServerSideProps` 并按需渲染页面。在我们工作的上下文中，这对于“购物车”页面是有效的。
- en: '`getServerSideProps` is server-side rendering, as we’ve seen previously. The
    reason a cart page should probably be server-rendered is that it can change very
    quickly, based on end user interaction. An example of a page that is dynamic but
    wouldn’t change quickly based on an end user action is a “view single product”
    page. We’ll see how to statically generate that after the cart page example.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`getServerSideProps` 是服务器端渲染，正如我们之前所看到的。一个购物车页面可能应该使用服务器端渲染的原因是它可以根据最终用户的交互快速变化。一个动态但不会根据最终用户操作快速变化的页面示例是“查看单个产品”页面。我们将在购物车页面示例之后看到如何静态生成它。'
- en: 'We create a `pages/cart.js` file, where we provide the following `getServerSideProps`,
    which loads the cart, figures out the relevant product IDs (per cart content),
    and loads them (in order to display some information about them):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `pages/cart.js` 文件，其中我们提供了以下 `getServerSideProps`，它加载购物车，确定相关的产品 ID（按购物车内容），并加载它们（以便显示有关它们的信息）：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can then build a page component and make it the default export. In the component,
    we loop through the cart products, rendering some count information and some product
    information, based on `props.productsById`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以构建一个页面组件并将其作为默认导出。在组件中，我们遍历购物车产品，根据 `props.productsById` 渲染一些计数信息和一些产品信息：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We know this is a server-side rendered page because when we run `next build`,
    it gets marked as such (and doesn’t increase the `Generating static` `pages` count):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是一个服务器端渲染的页面，因为当我们运行 `next build` 时，它会将其标记为这样的（并且不会增加“生成静态”页面计数）：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can load the `/carts` page with a `?cartId=1` query param and see Cart 1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过带有 `?cartId=1` 查询参数加载 `/carts` 页面并查看购物车 1。
- en: '![Figure 5.10: The cart page with Cart 1 loaded and contents displaying](img/B19109_05_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：已加载购物车 1 并显示内容的购物车页面](img/B19109_05_10.jpg)'
- en: 'Figure 5.10: The cart page with Cart 1 loaded and contents displaying'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：已加载购物车 1 并显示内容的购物车页面
- en: We can also load the `/carts` page with `cartId=3` query param and see Cart
    3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `cartId=3` 查询参数加载 `/carts` 页面，并查看购物车 3。
- en: '![Figure 5.11: Cart page with Cart 3 loaded and contents displaying](img/B19109_05_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：已加载购物车 3 并显示内容的购物车页面](img/B19109_05_11.jpg)'
- en: 'Figure 5.11: Cart page with Cart 3 loaded and contents displaying'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：已加载购物车 3 并显示内容的购物车页面
- en: We’ve now seen how to render the cart page on demand; a page that we mentioned
    is a good fit for build-time pre-rendering (i.e., static site generation) is the
    `products/[id]` page. In order to render this page, we need to provide the “paths”
    that Next.js needs to attempt to pre-render, since `[id]` is dynamic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何按需渲染购物车页面；我们提到的一个非常适合构建时预渲染（即静态站点生成）的页面是 `products/[id]` 页面。为了渲染此页面，我们需要提供
    Next.js 需要尝试预渲染的“路径”，因为 `[id]` 是动态的。
- en: The following diagram shows how `getStaticPaths` and `getStaticProps` interact
    with each other. In short, `getStaticPaths` returns a list of “paths”; `getStaticProps`
    is then called on each item in that list of paths and can make the relevant I/O
    calls to provide the page’s props.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 `getStaticPaths` 和 `getStaticProps` 之间的交互方式。简而言之，`getStaticPaths` 返回一个“路径”列表；然后对路径列表中的每个项目调用
    `getStaticProps`，并可以执行相关的 I/O 调用来提供页面的 props。
- en: '![Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths
    and getStaticProps](img/B19109_05_12a.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：使用 getStaticPaths 和 getStaticProps 的 Next.js 预渲染序列图](img/B19109_05_12a.jpg)'
- en: 'Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths
    and getStaticProps'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：使用 getStaticPaths 和 getStaticProps 的 Next.js 预渲染序列图
- en: '![Figure 5.13: Sequence of a request to a pre-rendered Next.js app](img/B19109_05_12b.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13：对预渲染的 Next.js 应用程序请求的序列](img/B19109_05_12b.jpg)'
- en: 'Figure 5.13: Sequence of a request to a pre-rendered Next.js app'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：对预渲染的 Next.js 应用程序请求的序列
- en: 'In our sample Next.js app, we can create a `pages/products/[id].js` file with
    the following `getStaticPaths` and `getStaticProps` functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例 Next.js 应用程序中，我们可以创建一个 `pages/products/[id].js` 文件，并包含以下 `getStaticPaths`
    和 `getStaticProps` 函数：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One quirk of the `paths` generation is that we’re converting `product.id` from
    a number to a string, since the `[id]` path parameter needs to be a string. Next.js
    would error with `Error: A required parameter (id) was not provided as a string
    received number in getStaticPaths for /``products/[id]` otherwise.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`paths` 生成的一个特点是，我们将 `product.id` 从数字转换为字符串，因为 `[id]` 路径参数需要是字符串。否则，Next.js
    会报错 `Error: A required parameter (id) was not provided as a string received number
    in getStaticPaths for /``products/[id]`。'
- en: '`getStaticProps` takes the `params` object, which is contained in the objects
    returned from `getStaticPaths`, and makes further `fetch` calls to load the product
    by ID. Finally, it returns `product` for the `Page` component to use:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStaticProps` 接收包含在 `getStaticPaths` 返回的对象中的 `params` 对象，并进一步进行 `fetch`
    调用来通过 ID 加载产品。最后，它为 `Page` 组件返回 `product`：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our `ProductPage` component can then look like the following, where we use
    `product.title` both as the title of the page and as the page’s `h2` element content.
    From here, we could display anything contained in the product response, including
    price and stock information and images:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProductPage` 组件可以如下所示，其中我们使用 `product.title` 既是页面的标题也是页面 `h2` 元素的内容。从这里，我们可以显示产品响应中包含的任何内容，包括价格和库存信息以及图片：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we run `next build`, the build will take longer, since each `products/[id]`
    page needs to make a request to `fakestoreapi.com`. Note that the `products/[id]`
    pages are marked as `SSG`. We also see the number of static pages being generated
    increasing to 24 and a truncated subset of `products/[id]` pages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `next build` 时，构建将花费更长的时间，因为每个 `products/[id]` 页面都需要向 `fakestoreapi.com`
    发送请求。请注意，`products/[id]` 页面被标记为 `SSG`。我们还看到生成的静态页面数量增加到 24，以及 `products/[id]`
    页面的截断子集：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After building and starting the server with `next start`, when we load the `/products/1`
    path, we see product 1’s name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `next start` 构建并启动服务器后，当我们加载 `/products/1` 路径时，我们看到产品 1 的名称。
- en: '![Figure 5.14: /products/1 content](img/B19109_05_13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14：/products/1 内容](img/B19109_05_13.jpg)'
- en: 'Figure 5.14: /products/1 content'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：/products/1 内容
- en: And when we load the `/products/8` path, we see product 8’s name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载 `/products/8` 路径时，我们看到产品 8 的名称。
- en: '![Figure 5.15: /products/8 content](img/B19109_05_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：/products/8 内容](img/B19109_05_14.jpg)'
- en: 'Figure 5.15: /products/8 content'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：/products/8 内容
- en: We’ve now seen how to leverage Next.js features that automatically statically
    render pages with no data fetching, `getStaticProps` and `getStaticPaths` to render
    pages with dynamic content and with dynamic paths at build time, as well as how
    these approaches contrast with `getServerSideProps`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何利用 Next.js 的功能，自动静态渲染页面而不进行数据获取，`getStaticProps` 和 `getStaticPaths`
    在构建时渲染具有动态内容和动态路径的页面，以及这些方法与 `getServerSideProps` 的对比。
- en: Next, we’ll deep-dive into how to rehydrate a server-rendered react page on
    the client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨如何在客户端重新激活服务器端渲染的 React 页面。
- en: Page hydration strategies
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面激活策略
- en: As we’ve seen in the first section of the chapter, react provides primitives
    to render applications on the server and the client. However, we only looked at
    examples where we did exclusively client or server rendering. One key feature
    of React frameworks such as Next.js is that they allow you to seamlessly switch
    between static, client, and server rendering. We’ll look at how to achieve this
    using React primitives.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章第一部分所见，React 提供了在服务器和客户端渲染应用程序的原语。然而，我们只看了只进行客户端或服务器端渲染的示例。React 框架（如
    Next.js）的一个关键特性是它们允许您无缝地在静态、客户端和服务器端渲染之间切换。我们将探讨如何使用 React 原语实现这一点。
- en: '![Figure 5.16: A sequence diagram for a server-rendered page that is subsequently
    rehydrated on the client](img/B19109_05_15.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16：一个服务器端渲染并在客户端随后重新激活的页面的序列图](img/B19109_05_15.jpg)'
- en: 'Figure 5.16: A sequence diagram for a server-rendered page that is subsequently
    rehydrated on the client'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：一个服务器端渲染并在客户端随后重新激活的页面的序列图
- en: 'We’ll start by extending our React client/server rendering `app.jsx` with a
    `ClientCounter` component. Event handlers are one of the simplest ways to observe
    interactivity primitives. Our `ClientCounter` component displays a counter that
    initializes with `0`, and on every click of the `src/client-counter.jsx` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过添加一个 `ClientCounter` 组件来扩展我们的 React 客户端/服务器端渲染的 `app.jsx`。事件处理器是观察交互原语的最简单方法之一。我们的
    `ClientCounter` 组件显示一个计数器，其初始值为 `0`，并且每当点击 `src/client-counter.jsx` 文件时：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can render it in our `app.jsx` component, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `app.jsx` 组件中渲染它，如下所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we build the client-side entry point and load it in the browser, it works
    correctly, incrementing on each **Add** click:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建客户端入口点并在浏览器中加载它，它将正常工作，每次点击 **添加** 都会增加：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we open the `index.html` file (which is unchanged), we’ll be able to see
    the counter and increment it, as shown in the following screenshot.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `index.html` 文件（它没有改变），我们将能够看到计数器并增加它，如下面的截图所示。
- en: '![Figure 5.17: The React client-side rendered counter with an increment of
    7 displayed](img/B19109_05_16.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17：显示增加 7 的 React 客户端渲染计数器](img/B19109_05_16.jpg)'
- en: 'Figure 5.17: The React client-side rendered counter with an increment of 7
    displayed'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：显示增加 7 的 React 客户端渲染计数器
- en: 'However, if we build and run our server-side entry point, the component remains
    at 0:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们构建并运行我们的服务器端入口点，组件仍然保持在 0：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then start the server using the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下命令启动服务器：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As the following screenshot shows, no matter how many times we click **Add**,
    the component only ever displays **0**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，无论我们点击 **添加** 多少次，组件只显示 **0**。
- en: '![Figure 5.18: React server-rendering does not allow for interactive counter
    component, the count shows 0 despite multiple Add button clicks](img/B19109_05_17.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：React 服务器端渲染不允许交互式计数组件，尽管多次点击添加按钮，计数仍然显示为 0](img/B19109_05_17.jpg)'
- en: 'Figure 5.18: React server-rendering does not allow for interactive counter
    component, the count shows 0 despite multiple Add button clicks'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：React 服务器端渲染不允许交互式计数组件，尽管多次点击添加按钮，计数仍然显示为 0
- en: 'In order to “hydrate” our server-rendered page, we can create a new entry point,
    `rehydrate.jsx`. This uses `react-dom/client`’s `hydrateRoot` function on the
    element that contains our app:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了“激活”我们的服务器端渲染页面，我们可以创建一个新的入口点，`rehydrate.jsx`。它使用 `react-dom/client` 的 `hydrateRoot`
    函数在包含我们的应用程序的元素上：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ll bundle the rehydration entry point using `esbuild`, in a similar fashion
    to previous entry points:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `esbuild` 打包重新激活的入口点，类似于之前的入口点：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once our new `dist/rehydrate.js` file is built, we need to use it in our server-rendered
    app. We modify `server.js` to statically serve `dist`, which means that `dist/rehydrate.js`
    is available as `rehydrate.js`. We then create a new `GET` route, `/rehydrate`.
    This route returns the navigation elements seen previously, but now the application
    also has a script that will load `rehydrate.js`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的新 `dist/rehydrate.js` 文件构建完成，我们需要在我们的服务器端渲染应用程序中使用它。我们修改 `server.js` 以静态服务
    `dist`，这意味着 `dist/rehydrate.js` 可用作为 `rehydrate.js`。然后我们创建一个新的 `GET` 路由，`/rehydrate`。此路由返回之前看到的导航元素，但现在应用程序还有一个将加载
    `rehydrate.js` 的脚本：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also include `/rehydrate` in the `nav.jsx`, which now looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `nav.jsx` 中包含了 `/rehydrate`，现在看起来如下：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can then rebuild our entry points and start the server. When we navigate
    to `/rehydrate`, the counter is interactive, and we see the navigation and `h1`
    as rendered server-side.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重新构建我们的入口点并启动服务器。当我们导航到 `/rehydrate` 时，计数器是交互式的，我们看到导航和 `h1` 是在服务器端渲染的。
- en: "![Figure 5.19: The rehydrated server-rendered application allows the interactive\
    \ u\uFEFFse of a client-side counter, displayed here with a count of 5](img/B19109_05_18.jpg)"
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：重新激活的服务器端渲染应用程序允许客户端计数器的交互式使用，此处显示计数为 5](img/B19109_05_18.jpg)'
- en: 'Figure 5.19: The rehydrated server-rendered application allows the interactive
    use of a client-side counter, displayed here with a count of 5'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：重新激活的服务器端渲染应用程序允许客户端计数器的交互式使用，此处显示计数为 5
- en: We’ve now seen how to rehydrate a server-rendered React application, next we’ll
    delve into common React rehydration issues.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何重新激活服务器端渲染的 React 应用程序，接下来我们将深入了解常见的 React 重新激活问题。
- en: Common React rehydration issues
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 React 重新激活问题
- en: Rehydration has some key gotchas.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重新激活有一些关键陷阱。
- en: It’s quite common to see the following runtime environment detection code in
    an application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中看到以下运行时环境检测代码是很常见的。
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s say we placed `isServer` in a `src/rendering-utils.js` file; we can use
    it as follows to conditionally render content such as `''from client''` or `''not
    from client''`, or avoid rendering `ClientCounter` altogether when server-rendering:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将 `isServer` 放在 `src/rendering-utils.js` 文件中；我们可以如下使用它来条件性地渲染内容，例如 `'from
    client'` 或 `'not from client'`，或者在服务器端渲染时完全避免渲染 `ClientCounter`：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This works fine in the purely server-rendered use case, where we display `'not
    from client'` and hide `ClientCounter`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯粹的服务器端渲染用例中，这运行得很好，我们显示 `'not from client'` 并隐藏 `ClientCounter`。
- en: '![Figure 5.20: isServer detection working successfully for server-side-only
    rendering](img/B19109_05_19.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20：isServer 检测成功用于仅服务器端渲染](img/B19109_05_19.jpg)'
- en: 'Figure 5.20: isServer detection working successfully for server-side-only rendering'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：isServer 检测成功用于仅服务器端渲染
- en: At first glance, it looks to be working for the server-render followed by client-side
    rehydration use case. It displays **from client** and shows the client-side counter
    component.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，它似乎适用于服务器端渲染后跟客户端侧重新激活的使用案例。它显示 **from client** 并显示客户端计数器组件。
- en: '![Figure 5.21: isServer detection looking to work for server-side rendering
    followed rehydration](img/B19109_05_20.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21：isServer 检测看起来适用于服务器端渲染后重新激活](img/B19109_05_20.jpg)'
- en: 'Figure 5.21: isServer detection looking to work for server-side rendering followed
    rehydration'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：isServer 检测是否适用于服务器端渲染后重新激活
- en: However, if we look at the console, we can see that we have some errors.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们查看控制台，我们可以看到我们有一些错误。
- en: '![Figure 5.22: Console errors during rehydration](img/B19109_05_21.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22：重新激活期间的控制台错误](img/B19109_05_21.jpg)'
- en: 'Figure 5.22: Console errors during rehydration'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：重新激活期间的控制台错误
- en: The issue is client render versus server render mismatches – for example, `ReactDOM.rehydrateRoot`
    expects the application to render the same way on the server and the client. React,
    in this situation, falls back to full client-side rendering (**An error occurred
    during hydration. The server HTML was replaced with client content in <div>.**),
    meaning the server-rendered HTML is completely thrown away.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于客户端渲染与服务器端渲染不匹配 - 例如，`ReactDOM.rehydrateRoot` 预期应用程序在服务器和客户端以相同的方式渲染。在这种情况下，React
    会回退到完全的客户端渲染（**在激活过程中发生错误。服务器端 HTML 被客户端内容替换在 <div> 中。**），这意味着服务器端渲染的 HTML 完全被丢弃。
- en: 'To fix this, a better detection of server versus client is required. A simple
    detection would involve a hook using `useEffect`. The `useClientRenderingOnly`
    function will always be `false` until the application runs our `useEffect`, which
    is only run client-side:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，需要更好地检测服务器与客户端。简单的检测将涉及使用`useEffect`的钩子。`useClientRenderingOnly`函数将在应用程序运行我们的`useEffect`之前始终为`false`，而`useEffect`只在客户端运行：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It can be used as follows in `src/client-counter.jsx` instead of `isServer`
    in `app.jsx`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在`src/client-counter.jsx`中使用，而不是在`app.jsx`中使用`isServer`：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`app.jsx` can become the following, leveraging `isClientRendering` to display
    `''from client''` and `''not` `from client''`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.jsx`可以变成以下形式，利用`isClientRendering`来显示`''from client''`和`''not from client''`：'
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the server-rendering-only case, this works, and in the rehydration case,
    we now know whether to display something on the server or client without getting
    rehydration issues.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅服务器端渲染的情况下，这可以工作，在重新激活的情况下，我们现在知道是否在服务器或客户端显示某些内容，而不会出现重新激活问题。
- en: Other common issues that cause rehydration errors are invalid markup (some HTML
    tags are not supposed to be inside other HTML tags).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其他导致重新激活错误的常见问题包括无效的标记（某些HTML标签不应该放在其他HTML标签内）。
- en: React provides one more rendering approach that allows the server to start returning
    data to the client earlier via streaming.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一种额外的渲染方法，允许服务器通过流式传输更早地开始向客户端返回数据。
- en: React streaming server-side rendering
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React流式服务器端渲染
- en: React streaming server-side rendering leverages streaming so that the server
    can start return data to the browser earlier (chunks in a stream instead of a
    one-off response). This also means that the browser can start working on rendering
    earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: React流式服务器端渲染利用流式传输，使得服务器可以更早地开始向浏览器返回数据（流中的数据块而不是一次性响应）。这也意味着浏览器可以更早地开始渲染工作。
- en: There’s a major caveat to streaming, which is that one of its key advantages
    over non-streaming server-rendering is that it has support for the new suspense
    primitive. This primitive is supported by specific libraries and frameworks and
    is quite difficult to illustrate using React primitives.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 流式传输的一个主要缺点是，它相对于非流式服务器端渲染的一个关键优势是它支持新的suspense原语。这个原语由特定的库和框架支持，并且很难使用React原语来展示。
- en: 'According to the React documentation on suspense usage ([https://react.dev/reference/react/Suspense#usage](https://react.dev/reference/react/Suspense#usage)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 根据React关于suspense使用的文档（[https://react.dev/reference/react/Suspense#usage](https://react.dev/reference/react/Suspense#usage)）：
- en: Suspense-enabled data fetching without the use of an opinionated framework is
    not yet supported. The requirements for implementing a Suspense-enabled data source
    are unstable and undocumented. An official API for integrating data sources with
    Suspense will be released in a future version of React.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用有偏见的框架进行启用Suspense的数据获取尚不支持。实现启用Suspense的数据源的要求不稳定且未记录。将在React的下一个版本中发布一个官方API，用于将数据源与Suspense集成。
- en: When rehydrating a React streaming server rendered page, we need to replace
    the whole document, so we’ll create a new `<Page>` component, which will be a
    full page. We’ll also create a `streaming-rehydrate.jsx` entry point for use client-side.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新激活React流式服务器渲染的页面时，我们需要替换整个文档，因此我们将创建一个新的`<Page>`组件，它将是一个完整的页面。我们还将创建一个用于客户端的`streaming-rehydrate.jsx`入口点。
- en: 'The following are the contents of a new `src/page.jsx` file. The full page
    including `html` and `head` are necessary to do streaming server-side rendering:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个新的`src/page.jsx`文件的内容。为了进行流式服务器端渲染，需要包括`html`和`head`在内的完整页面：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our `streaming-rehydrate.jsx` entry point is quite similar to our `rehydrate.jsx`
    entry point with the exception that it hydrates `document`, instead of an element
    with the `app` ID. This is due to the aforementioned limitation of streaming server-side
    rendering – the whole document has to be controlled by React:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`streaming-rehydrate.jsx`入口点与我们的`rehydrate.jsx`入口点非常相似，唯一的区别是它激活`document`，而不是具有`app`
    ID的元素。这是由于上述流式服务器端渲染的限制——整个文档必须由React控制：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ll build the entry point to JavaScript using the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下方式构建JavaScript的入口点：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now start working on the server rendering in `src/server-rendering.jsx`.
    We create a new `serverRenderAppStream` function that takes an Express/Node.js
    `res` object as a parameter. It calls `ReactDOMServer.renderToPipeableStream`
    with the `Page` component, and with `bootstrapScripts` set to include our `streaming-rehydrate.js`
    entry point:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在`src/server-rendering.jsx`中处理服务器端渲染。我们创建了一个新的`serverRenderAppStream`函数，它接受一个Express/Node.js的`res`对象作为参数。它调用`ReactDOMServer.renderToPipeableStream`函数，使用`Page`组件，并将`bootstrapScripts`设置为包含我们的`streaming-rehydrate.js`入口点：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `server.js`, we can create a new `GET` route for the `/streaming` path,
    which simply calls `serverRenderAppStream` with the `res` object per the Express
    route handler definition:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们可以为`/streaming`路径创建一个新的`GET`路由，该路由简单地调用`serverRenderAppStream`函数，并按照Express路由处理器的定义使用`res`对象：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We’ll also add the `/streaming` route to `src/nav.jsx`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`/streaming`路由添加到`src/nav.jsx`中：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can now load the `/streaming` page and see it in action.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以加载`/streaming`页面并看到它的实际效果。
- en: '![Figure 5.23: React streaming server rendering with rehydration](img/B19109_05_22.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图5.23：带有重新加湿的React流式服务器端渲染](img/B19109_05_22.jpg)'
- en: 'Figure 5.23: React streaming server rendering with rehydration'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：带有重新加湿的React流式服务器端渲染
- en: We’ve now seen how to implement React streaming server rendering with rehydration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何实现带有重新加湿的React流式服务器端渲染。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how a deeper understanding of rendering and page
    hydration strategies can help us deliver optimal and scalable web user interfaces
    with React.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过更深入地理解渲染和页面加湿策略，可以帮助我们使用React提供最优和可扩展的Web用户界面。
- en: Client and server rendering have benefits and drawbacks that are complimentary
    to each other. Client rendering takes longer to start up but provides more interactivity
    and doesn’t require as much server-side computer power; server rendering can return
    content faster but requires infrastructure and doesn’t provide the same level
    of interactivity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器渲染各有优缺点，它们是互补的。客户端渲染启动时间较长，但提供了更多的交互性，并且不需要太多的服务器端计算能力；服务器渲染可以更快地返回内容，但需要基础设施，并且不提供相同的交互性水平。
- en: The static site generation functionality of Next.js can be leveraged alongside
    classic server rendering to judiciously decide on a rendering strategy for a given
    set of pages, based on the access pattern and how often the content changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js的静态站点生成功能可以与经典服务器端渲染结合使用，根据访问模式和内容更改的频率，明智地决定一组页面的渲染策略。
- en: Finally, page hydration and rehydration alongside streaming server-side rendering
    bridges the gap between server and client rendering, allowing the benefits of
    both to be included in one page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，页面加湿和重新加湿与流式服务器端渲染结合，弥合了服务器和客户端渲染之间的差距，使得两者的优点都能包含在一个页面中。
- en: Now that we’re familiar with rendering and page hydration strategies, we can
    look at implementing micro-frontends using both the “zones” and “islands” architectures
    in the next chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了渲染和页面加湿策略，我们可以在下一章中探讨使用“区域”和“岛屿”架构实现微前端。
