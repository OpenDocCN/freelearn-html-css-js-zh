- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering Strategies and Page Hydration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering strategies and page hydration approaches allow us to leverage the
    JavaScript client and server ecosystem to serve performant and scalable web applications,
    depending on the needs of our end users. The React and JavaScript techniques covered
    in this chapter are another set of tools to augment the [*Chapter 4*](B19109_04.xhtml#_idTextAnchor130)
    chapter. We’ll use the strengths of the client (browser) and server (specifically,
    Node.js) runtimes to deliver fast and scalable React websites to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What the trade-offs are between client and server rendering of React applications
    by implementing pure client and server rendering applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of advantages that frameworks such as Next.js can bring with static
    site generation functionality, alongside server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridging the client-server rendering gap with a React page rehydration example
    and its gotchas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming server rendering in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to select appropriate rendering and
    page hydration strategies with React and be able to implement framework-level
    functionality, enabling you to make better technology choices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: Client and server rendering with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web context, client-side rendering is the process by which JavaScript is
    used inside a user’s browser to generate or update the page contents. A fully
    client-side-rendered application will only display meaningful content when the
    relevant JavaScript code has completed downloading, parsing, and running.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sequence diagram, we use the term “origin” instead of something
    such as “server,” since one benefit of full client-side rendering is that the
    resources “serving” our content can be what’s called *static hosting*. This includes
    services such as **AWS Simple Storage Service** (**S3**), Netlify, Cloudflare
    Pages, and GitHub Pages, among others. There’s no dynamic server-side component
    in these services.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: A client-side-rendering sequence diagram](img/B19109_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: A client-side-rendering sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, server-side rendering denotes the process by which a server generates
    a full HTML document when a browser requests it and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2: A server-side-rendering sequence \uFEFFdiagram](img/B19109_05_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A server-side-rendering sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side rendering in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Client rendering is the default rendering method with React. Let’s build an
    application that renders client-side from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with an **App** component that renders some text and its **type**
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then create an entry point file, **client.jsx**, which imports the app and
    uses **ReactDOM** to render it, with the **type** prop set to **"****client render"**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order for this example to run, we need an HTML document that allows **ReactDOM.createRoot**
    to run successfully. In other words, we need an HTML document that has an element
    with **id=app** and references our entry point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the entry point is **dist/client.js** instead of **client.jsx**.
    That’s due to the fact that React’s JSX syntax can’t be run natively in the browser.
    Instead, we run our entry point file, **client.jsx**, through a compilation and
    bundling step using **esbuild**. Our build command looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we load the `index.html` file in the browser, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3: Hello from the “client render” app rendered in t\uFEFFhe browser](img/B19109_05_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Hello from the “client render” app rendered in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js, introduced on its website as “an open-source, cross-platform JavaScript
    runtime environment,” gives us the ability to run JavaScript on a server. A commonly
    used package to build servers in Node.js is Express.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll see how to use Node.js and Express to server-render a
    React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple Express server that returns `''Server-rendered hello''` when the root
    path is loaded looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll use `esbuild` to bundle and compile the JSX to JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then start the server using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, it runs on port `3000`, but that can be overridden with environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: When we load `localhost:3000`, we see this message in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Server-rendered hello rendered in the browser](img/B19109_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Server-rendered hello rendered in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: This is a really minimal example of server-rendering using Node.js and Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll see how to leverage the `ReactDOM` package to take React components
    and server-render them:'
  prefs: []
  type: TYPE_NORMAL
- en: The **ReactDOM** package provides both a **react-dom/client** entry point (which
    we used in the previous section) and a **react-dom/server** entry point. As the
    names allude to, the client entry point is meant to be used on the client (in
    the browser, “client-side” JavaScript), and the server entry point is meant to
    be used on the server (via Node.js or another server-side JavaScript runtime).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two methods we’ll use are **ReactDOMServer.renderToStaticMarkup** and **ReactDOMServer.renderToString**;
    these two methods will allow us to server-render our React application to HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a **src/server-render.jsx** file, we have the following **renderNav** and
    **serverRenderApp** functions, which use **ReactDOMServer.renderToStaticMarkup**
    and **ReactDOMServer.renderToString** to render **Nav** and **App**, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, `app.jsx` is the same as we had in the previous section, and `nav.jsx`
    is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use **renderNav** and **serverRenderApp** in **server.js**. We
    modify the **app.get(''/'')** handler to render the navigation and the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we rebuild the server, we run **node dist/server.js** and open **localhost:3000**
    to see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5: Hello from the “server render” app being rendered alongside a
    heading and the nav](img/B19109_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Hello from the “server render” app being rendered alongside a heading
    and the nav'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between `ReactDOMServer.renderToStaticMarkup` and `ReactDOMServer.renderToString?`
    The short answer is that `renderToStaticMarkup` can’t be rehydrated client-side;
    in other words, it can’t be used as the initial HTML, and then the same React
    application code can be run client-side to give a fully interactive experience.
    We’ll revisit this in a later section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs between client and server rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what are the benefits and drawbacks of client and server rendering?
  prefs: []
  type: TYPE_NORMAL
- en: Client rendering’s main benefit is that the application’s “work” is done fully
    in the user’s browsers, which makes it highly scalable since the amount of users
    using the system will not put pressure on the origin servers. Client rendering’s
    main drawbacks relate to functionality that is only available on the server side
    – for example, server-side-only cookies or setting the `meta` tags for social
    media preview.
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering’s main drawback is that work has to happen on the server. As
    stated previously, the server being a “controlled” environment has some benefits,
    namely its latency to other co-located systems will tend to be lower than a full
    browser-server round trip, since the server’s network is known and unlikely to
    have as much variance in performance as an end user’s network. By not waiting
    for a full-page load, followed by an asset load, followed by a JavaScript “parse
    and execute” cascade, server-rendering can improve “core web vitals”, such as
    **largest** **contentful** **paint** (**LCP**) and **cumulative layout** **shift**
    (**CLS**).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, client-rendered functionality is a key reason we use JavaScript,
    which means removing that ability will only make sense in constrained use cases
    such as content sites (e.g., blogs, news sites, and documentation sites).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen the difference between client and server rendering, as well as
    how to implement both with React and Node.js. In the following section, we’ll
    look at rendering approaches enabled by the Next.js framework for React.
  prefs: []
  type: TYPE_NORMAL
- en: Static rendering with Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js is a React framework for creating full stack web applications. What
    this means is that it provides tools and opinions that will help developers be
    more productive in the short and long term.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js includes a filesystem router for “pages”, a set of routing primitives
    for React, support for client and server rendering, and data fetching primitives,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: The features of Next.js we’ll focus on are the **static site generation** (**SSG**)
    ones. This type of rendering methodology resembles server rendering but mitigates
    some of its drawbacks, since the rendering pass is done at build time instead
    of at request time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: A sequence diagram for a pre-rendered/static site generation
    use case](img/B19109_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: A sequence diagram for a pre-rendered/static site generation use
    case'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at how static site generation changes the data flow when
    a user requests a website, we’ll look at Next.js automatic static generation.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic static generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Next.js, the filesystem-based routing means that each path in your web application
    corresponds to a file in the `pages` directory of your application. For example,
    `/` corresponds to `pages/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js defaults to static generation when no Next.js data fetching methods
    are used for a given page. You can find more information from the Next.js documentation
    – *Automatic Static* *Optimization* ([https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization)).
  prefs: []
  type: TYPE_NORMAL
- en: Next.js automatically determines that a page is static (i.e., can be prerendered)
    if it has no blocking data requirements. This determination is made by the absence
    of getServerSideProps and getInitialProps on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following page in a Next.js application will be statically
    generated, since it only exports a page component (the default export of `Index`);
    no `getServerSideProps` or `getInitialProps` function is exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this during `next build` in the following screenshot; `/ route (page)`
    is marked as `Static` in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we run the built Next.js output with `next start`, the page behaves as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Links to the Products and Cart pages rendering](img/B19109_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Links to the Products and Cart pages rendering'
  prefs: []
  type: TYPE_NORMAL
- en: This example is a relatively constrained use case since we have no dynamic data
    fetching requirements. It still showcases Next.js defaulting to static rendering
    if the page does not use any functionality that excludes static generation. For
    more advanced use cases, Next.js also allows use of “build-time” dynamic data,
    which means we can use a third-party data source to generate the page content,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how Next.js defaults to automatic static generation. Next, we’ll
    see how to configure a Next.js page to load data to render a page as static.
  prefs: []
  type: TYPE_NORMAL
- en: Static generation with a third-party data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js has a `getStaticProps` data fetching method that allows us to load data
    at build time, which will be passed to a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram illustrate what this involves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps](img/B19109_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to build a “product list” page based on `fakestoreapi.com`
    data, we can write the following `getStaticProps` method in a `pages/products/index.js`
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a `product` example in the response to illustrate the data shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the data provided by `getStaticProps`, we can build a `ProductIndexPage`
    component. We’ll loop through each product from `props.products` and render them
    in an unordered list. Each item will include a link to the `/products/[id]` page
    (which doesn’t exist yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This page will now be built when `next build` is run. As we can see from the
    output, the `/products` page is marked as `SSG` (static site generation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we start the Next.js server with `next start` and navigate to `/products`,
    we see the following. Note that the products on the page won’t change unless we
    rebuild the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: The Products list page is statically pre-rendered with products
    from fakestoreapi.com](img/B19109_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: The Products list page is statically pre-rendered with products
    from fakestoreapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to use `getStaticProps` to generate pages based on a third-party
    API, but how would we generate the `/products/[id]` pages ahead of them being
    requested? To do that, we need to be able to provide the “required paths” (or
    URLs) that Next.js needs to generate. This is what we’ll look at in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Static generation with dynamic paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be useful to pre-generate pages with dynamic paths and contents.
  prefs: []
  type: TYPE_NORMAL
- en: We could use `getServerSideProps` and render the pages on demand. In the context
    that we’re working in, that would be valid for a “cart” page.
  prefs: []
  type: TYPE_NORMAL
- en: '`getServerSideProps` is server-side rendering, as we’ve seen previously. The
    reason a cart page should probably be server-rendered is that it can change very
    quickly, based on end user interaction. An example of a page that is dynamic but
    wouldn’t change quickly based on an end user action is a “view single product”
    page. We’ll see how to statically generate that after the cart page example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `pages/cart.js` file, where we provide the following `getServerSideProps`,
    which loads the cart, figures out the relevant product IDs (per cart content),
    and loads them (in order to display some information about them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then build a page component and make it the default export. In the component,
    we loop through the cart products, rendering some count information and some product
    information, based on `props.productsById`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We know this is a server-side rendered page because when we run `next build`,
    it gets marked as such (and doesn’t increase the `Generating static` `pages` count):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can load the `/carts` page with a `?cartId=1` query param and see Cart 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: The cart page with Cart 1 loaded and contents displaying](img/B19109_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: The cart page with Cart 1 loaded and contents displaying'
  prefs: []
  type: TYPE_NORMAL
- en: We can also load the `/carts` page with `cartId=3` query param and see Cart
    3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Cart page with Cart 3 loaded and contents displaying](img/B19109_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Cart page with Cart 3 loaded and contents displaying'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to render the cart page on demand; a page that we mentioned
    is a good fit for build-time pre-rendering (i.e., static site generation) is the
    `products/[id]` page. In order to render this page, we need to provide the “paths”
    that Next.js needs to attempt to pre-render, since `[id]` is dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how `getStaticPaths` and `getStaticProps` interact
    with each other. In short, `getStaticPaths` returns a list of “paths”; `getStaticProps`
    is then called on each item in that list of paths and can make the relevant I/O
    calls to provide the page’s props.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths
    and getStaticProps](img/B19109_05_12a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths
    and getStaticProps'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Sequence of a request to a pre-rendered Next.js app](img/B19109_05_12b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Sequence of a request to a pre-rendered Next.js app'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample Next.js app, we can create a `pages/products/[id].js` file with
    the following `getStaticPaths` and `getStaticProps` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One quirk of the `paths` generation is that we’re converting `product.id` from
    a number to a string, since the `[id]` path parameter needs to be a string. Next.js
    would error with `Error: A required parameter (id) was not provided as a string
    received number in getStaticPaths for /``products/[id]` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`getStaticProps` takes the `params` object, which is contained in the objects
    returned from `getStaticPaths`, and makes further `fetch` calls to load the product
    by ID. Finally, it returns `product` for the `Page` component to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ProductPage` component can then look like the following, where we use
    `product.title` both as the title of the page and as the page’s `h2` element content.
    From here, we could display anything contained in the product response, including
    price and stock information and images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `next build`, the build will take longer, since each `products/[id]`
    page needs to make a request to `fakestoreapi.com`. Note that the `products/[id]`
    pages are marked as `SSG`. We also see the number of static pages being generated
    increasing to 24 and a truncated subset of `products/[id]` pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After building and starting the server with `next start`, when we load the `/products/1`
    path, we see product 1’s name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: /products/1 content](img/B19109_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: /products/1 content'
  prefs: []
  type: TYPE_NORMAL
- en: And when we load the `/products/8` path, we see product 8’s name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: /products/8 content](img/B19109_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: /products/8 content'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to leverage Next.js features that automatically statically
    render pages with no data fetching, `getStaticProps` and `getStaticPaths` to render
    pages with dynamic content and with dynamic paths at build time, as well as how
    these approaches contrast with `getServerSideProps`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll deep-dive into how to rehydrate a server-rendered react page on
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: Page hydration strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve seen in the first section of the chapter, react provides primitives
    to render applications on the server and the client. However, we only looked at
    examples where we did exclusively client or server rendering. One key feature
    of React frameworks such as Next.js is that they allow you to seamlessly switch
    between static, client, and server rendering. We’ll look at how to achieve this
    using React primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: A sequence diagram for a server-rendered page that is subsequently
    rehydrated on the client](img/B19109_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: A sequence diagram for a server-rendered page that is subsequently
    rehydrated on the client'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by extending our React client/server rendering `app.jsx` with a
    `ClientCounter` component. Event handlers are one of the simplest ways to observe
    interactivity primitives. Our `ClientCounter` component displays a counter that
    initializes with `0`, and on every click of the `src/client-counter.jsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can render it in our `app.jsx` component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we build the client-side entry point and load it in the browser, it works
    correctly, incrementing on each **Add** click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we open the `index.html` file (which is unchanged), we’ll be able to see
    the counter and increment it, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: The React client-side rendered counter with an increment of
    7 displayed](img/B19109_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The React client-side rendered counter with an increment of 7
    displayed'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we build and run our server-side entry point, the component remains
    at 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then start the server using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As the following screenshot shows, no matter how many times we click **Add**,
    the component only ever displays **0**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: React server-rendering does not allow for interactive counter
    component, the count shows 0 despite multiple Add button clicks](img/B19109_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: React server-rendering does not allow for interactive counter
    component, the count shows 0 despite multiple Add button clicks'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to “hydrate” our server-rendered page, we can create a new entry point,
    `rehydrate.jsx`. This uses `react-dom/client`’s `hydrateRoot` function on the
    element that contains our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll bundle the rehydration entry point using `esbuild`, in a similar fashion
    to previous entry points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our new `dist/rehydrate.js` file is built, we need to use it in our server-rendered
    app. We modify `server.js` to statically serve `dist`, which means that `dist/rehydrate.js`
    is available as `rehydrate.js`. We then create a new `GET` route, `/rehydrate`.
    This route returns the navigation elements seen previously, but now the application
    also has a script that will load `rehydrate.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also include `/rehydrate` in the `nav.jsx`, which now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can then rebuild our entry points and start the server. When we navigate
    to `/rehydrate`, the counter is interactive, and we see the navigation and `h1`
    as rendered server-side.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.19: The rehydrated server-rendered application allows the interactive\
    \ u\uFEFFse of a client-side counter, displayed here with a count of 5](img/B19109_05_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: The rehydrated server-rendered application allows the interactive
    use of a client-side counter, displayed here with a count of 5'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to rehydrate a server-rendered React application, next we’ll
    delve into common React rehydration issues.
  prefs: []
  type: TYPE_NORMAL
- en: Common React rehydration issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rehydration has some key gotchas.
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite common to see the following runtime environment detection code in
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say we placed `isServer` in a `src/rendering-utils.js` file; we can use
    it as follows to conditionally render content such as `''from client''` or `''not
    from client''`, or avoid rendering `ClientCounter` altogether when server-rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This works fine in the purely server-rendered use case, where we display `'not
    from client'` and hide `ClientCounter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: isServer detection working successfully for server-side-only
    rendering](img/B19109_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: isServer detection working successfully for server-side-only rendering'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it looks to be working for the server-render followed by client-side
    rehydration use case. It displays **from client** and shows the client-side counter
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: isServer detection looking to work for server-side rendering
    followed rehydration](img/B19109_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: isServer detection looking to work for server-side rendering followed
    rehydration'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we look at the console, we can see that we have some errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Console errors during rehydration](img/B19109_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Console errors during rehydration'
  prefs: []
  type: TYPE_NORMAL
- en: The issue is client render versus server render mismatches – for example, `ReactDOM.rehydrateRoot`
    expects the application to render the same way on the server and the client. React,
    in this situation, falls back to full client-side rendering (**An error occurred
    during hydration. The server HTML was replaced with client content in <div>.**),
    meaning the server-rendered HTML is completely thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, a better detection of server versus client is required. A simple
    detection would involve a hook using `useEffect`. The `useClientRenderingOnly`
    function will always be `false` until the application runs our `useEffect`, which
    is only run client-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used as follows in `src/client-counter.jsx` instead of `isServer`
    in `app.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`app.jsx` can become the following, leveraging `isClientRendering` to display
    `''from client''` and `''not` `from client''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the server-rendering-only case, this works, and in the rehydration case,
    we now know whether to display something on the server or client without getting
    rehydration issues.
  prefs: []
  type: TYPE_NORMAL
- en: Other common issues that cause rehydration errors are invalid markup (some HTML
    tags are not supposed to be inside other HTML tags).
  prefs: []
  type: TYPE_NORMAL
- en: React provides one more rendering approach that allows the server to start returning
    data to the client earlier via streaming.
  prefs: []
  type: TYPE_NORMAL
- en: React streaming server-side rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React streaming server-side rendering leverages streaming so that the server
    can start return data to the browser earlier (chunks in a stream instead of a
    one-off response). This also means that the browser can start working on rendering
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a major caveat to streaming, which is that one of its key advantages
    over non-streaming server-rendering is that it has support for the new suspense
    primitive. This primitive is supported by specific libraries and frameworks and
    is quite difficult to illustrate using React primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the React documentation on suspense usage ([https://react.dev/reference/react/Suspense#usage](https://react.dev/reference/react/Suspense#usage)):'
  prefs: []
  type: TYPE_NORMAL
- en: Suspense-enabled data fetching without the use of an opinionated framework is
    not yet supported. The requirements for implementing a Suspense-enabled data source
    are unstable and undocumented. An official API for integrating data sources with
    Suspense will be released in a future version of React.
  prefs: []
  type: TYPE_NORMAL
- en: When rehydrating a React streaming server rendered page, we need to replace
    the whole document, so we’ll create a new `<Page>` component, which will be a
    full page. We’ll also create a `streaming-rehydrate.jsx` entry point for use client-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the contents of a new `src/page.jsx` file. The full page
    including `html` and `head` are necessary to do streaming server-side rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `streaming-rehydrate.jsx` entry point is quite similar to our `rehydrate.jsx`
    entry point with the exception that it hydrates `document`, instead of an element
    with the `app` ID. This is due to the aforementioned limitation of streaming server-side
    rendering – the whole document has to be controlled by React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll build the entry point to JavaScript using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start working on the server rendering in `src/server-rendering.jsx`.
    We create a new `serverRenderAppStream` function that takes an Express/Node.js
    `res` object as a parameter. It calls `ReactDOMServer.renderToPipeableStream`
    with the `Page` component, and with `bootstrapScripts` set to include our `streaming-rehydrate.js`
    entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In `server.js`, we can create a new `GET` route for the `/streaming` path,
    which simply calls `serverRenderAppStream` with the `res` object per the Express
    route handler definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also add the `/streaming` route to `src/nav.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can now load the `/streaming` page and see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: React streaming server rendering with rehydration](img/B19109_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: React streaming server rendering with rehydration'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to implement React streaming server rendering with rehydration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how a deeper understanding of rendering and page
    hydration strategies can help us deliver optimal and scalable web user interfaces
    with React.
  prefs: []
  type: TYPE_NORMAL
- en: Client and server rendering have benefits and drawbacks that are complimentary
    to each other. Client rendering takes longer to start up but provides more interactivity
    and doesn’t require as much server-side computer power; server rendering can return
    content faster but requires infrastructure and doesn’t provide the same level
    of interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: The static site generation functionality of Next.js can be leveraged alongside
    classic server rendering to judiciously decide on a rendering strategy for a given
    set of pages, based on the access pattern and how often the content changes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, page hydration and rehydration alongside streaming server-side rendering
    bridges the gap between server and client rendering, allowing the benefits of
    both to be included in one page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re familiar with rendering and page hydration strategies, we can
    look at implementing micro-frontends using both the “zones” and “islands” architectures
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
