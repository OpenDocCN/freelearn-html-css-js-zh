- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Modern Frontend Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, the last two chapters have in large part focused on the backend. Not exclusively,
    of course, since we touched on some things that aren’t backend, but largely. In
    this chapter, we’re going to jump with both feet back onto the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the frontend goes, where are we so far? Well, you’ve gotten a pretty
    good look at HTML, CSS, and JavaScript, the basics of web development. Every web
    developer needs to know about these to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: But what would you think if I told you that, in most modern web development,
    you might not be working with them in exactly the form you’ve seen so far? In
    fact, in some cases, you might barely work with them at all. That would seem weird
    and contradictory, right?
  prefs: []
  type: TYPE_NORMAL
- en: Alas, it is, to a large degree, the reality!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at some technologies that are built *on
    top* of HTML, CSS, and JavaScript, in some cases extending them, and ultimately
    leading to a place where you aren’t working with plain old HTML, CSS, and JavaScript
    anymore. These include frameworks such as React, Angular, and Vue, frontend toolkits
    such as Bootstrap and Tailwind, and **TypeScript** (**TS**). You’ll also see how
    they have many benefits in terms of what you can deliver to your clients.
  prefs: []
  type: TYPE_NORMAL
- en: By the end, you’ll have a good understanding of why this trend of moving away
    from plain HTML, CSS, and JavaScript is so popular and so beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’ll cover the following main topics here:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting away the basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meeting the modern frontend frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting CSS capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpiling and data typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packing up and going – bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need the download the source code bundle from GitHub.
    Since I expect that you’ve already installed Node (and thus npm), that’s it! Everything
    you’ll need will be in the `ch-06` directory, ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting away the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long time ago, in an internet far, far away, developing websites was kind
    of a pain in the butt. You see, for a long time, browsers didn’t all work the
    same. You might write some HTML and have it look great in Netscape Navigator,
    but then find it didn’t look right in Internet Explorer. Or, you might write some
    JavaScript that worked perfectly in Internet Explorer but then caused an error
    in Opera. And CSS required all sorts of hacks to make it work even remotely the
    same across browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we tend to write to standards, which are well-defined guidelines that
    browsers follow for how HTML, JavaScript, and CSS work. So long as you write to
    standards, and the browsers implement the standards properly, what you write will
    nearly always work the same across the major browsers at least.
  prefs: []
  type: TYPE_NORMAL
- en: But it wasn’t always like that, not by a long shot.
  prefs: []
  type: TYPE_NORMAL
- en: Before standards were the order of the day, developers decided that building
    websites with plain HTML, JavaScript, and CSS wasn’t always the best experience.
    At that point, they started writing abstraction layers on top of HTML, JavaScript,
    and CSS. These came in the form of various JavaScript libraries that would do
    the work of creating the HTML, JavaScript, and CSS for you in effect. And they
    did so intelligently, meaning if they saw you were running in Internet Explorer,
    they knew how to output the right code for it, but could then output the right
    code for Netscape when running in that browser (don’t worry if you’ve never even
    heard of Netscape – it’s a long-defunct browser that was popular in the early
    days of the web – that is, the late 1990s and early 2000s).
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of these abstractions is primarily threefold:'
  prefs: []
  type: TYPE_NORMAL
- en: One is that they allow you to write less code! If there is a single function
    you can call that will produce a UI with a button and some text that the button
    can collapse and expand, then that’s a lot less code you have to write – a lot
    less custom HTML, CSS, and JavaScript that you could get wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following on from the previous point, writing less code yourself means you can
    deliver results quicker. Not having to write all that expand/collapse code yourself
    saves time, which clients tend to like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third key benefit is that shared code tends to be more robust code. If you
    use code that someone else wrote, and there are a lot of other people out there
    using it too, then there is a good chance that code is very sound, error-free,
    performs well, and is just generally problem-free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the biggest names ever in the area of abstractions was, and in some places
    still is, jQuery. It could be argued that the World Wide Web wouldn’t have become
    what it is today without jQuery, a JavaScript library that provides a long list
    of functions designed to work across all supported browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in plain JavaScript, you can get a reference to a DOM node with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you have a `<div id="mySpecialDiv">` element on the page, then the `node`
    variable will reference it and you can manipulate it in various ways. While that
    is a common, fully cross-browser function today, it wasn’t always. At one point,
    you might have to write different code for different browsers, and someone would
    have to determine which code to execute when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, enter jQuery, and you could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `$()` function – yes, `$` is a valid function name in JavaScript, despite
    it not looking like any of the function names you’ve seen to this point and it
    just being a single non-alphanumeric character – is provided by jQuery (if you
    import jQuery into your page that is, and it’s just a JavaScript file, so that’s
    easy enough) and it took care of whatever differences the browsers may have. With
    jQuery, that line of code works in all supported browsers equally, and you don’t
    have to worry about how one browser does things versus another because jQuery
    handles all that for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'jQuery is a library and a small one at that. But what does the word library
    mean in this context? And what does it mean compared to the terms framework and
    toolkit, which are commonly spoken about in software development in general, which
    of course includes web development? We can break it down like so:'
  prefs: []
  type: TYPE_NORMAL
- en: A *library* is a collection of functions and callable routines that can be written
    in any language. With a library, you are in command of the flow and structure
    of your application, and you use the library only when you need it. Your code
    always calls the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *framework*, on the other hand, provides the overall structure for your application.
    You have to fit your code into the structure the framework dictates (with varying
    degrees of rigidity, depending on the framework author’s basic thinking). The
    framework’s code controls the flow, at various points calling your code in response
    to various events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *toolkit* is a set of tools or components for a specific domain. Most commonly,
    a toolkit refers to user interface components – things such as buttons, grids,
    progress bars, and other elements you might see in a user interface. In fact,
    in my experience, you will rarely see the word toolkit used in any context other
    than building interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the three ultimately comes down mostly to what’s most
    in control. If your code is calling on other code, then your code is in control,
    and that other code is, therefore, most likely a library or toolkit. If, on the
    other hand, the other code calls your code most of the time, then that other code
    is more in control, and there is then a good bet that it’s a framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be sure, this is a borderline academic discussion: whether something is
    a library, framework, or toolkit isn’t usually something we need to worry about
    too much when developing a website. It’s worth understanding the difference, but
    at the end of the day, so long as a given thing helps us get our job done, then
    it can be whatever it wants to be!'
  prefs: []
  type: TYPE_NORMAL
- en: But, with that said, it’s also worth noting that there is some overlap and even
    some degree of fungibility to these terms. You can easily find online debates
    about whether *X* or *Y* is a library or framework (toolkits tend to be a bit
    more obvious). It’s less important what they are and more important what they
    can do for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s meet three of the most popular frontend frameworks out there today:
    React, Angular, and Vue.'
  prefs: []
  type: TYPE_NORMAL
- en: Meeting the modern frontend tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, there is a bit of a schism in web development. There is a group of web
    developers who like the “vanilla” approach, which means you use HTML, CSS, and
    JavaScript, just as you’ve seen so far. On the other hand, there is another group
    that feels there are better answers at higher levels of abstraction. They feel
    that there is a lot of benefit to libraries, frameworks, and toolkits since they
    can do things such as smooth over browser differences (as the jQuery library does),
    or even save us from writing a lot of what would be complex HTML, CSS, and JavaScript,
    as the MUI toolkit does by providing a wealth of premade widgets to build interfaces
    with. There are pluses and minuses to both approaches, and there is no canonically
    *correct* answer.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s not crazy to suggest that “team vanilla” is the smaller group
    these days, and the prevailing wisdom is that using modern libraries, frameworks,
    and toolkits is the better way to go in most ways. And, of course, even if you
    only ever use these things, you *still* need to know HTML, CSS, and JavaScript.
    That is foundational knowledge. These modern tools build on them, and extend them,
    but rarely replace them outright (you can find a few that do, but they tend to
    be the minority).
  prefs: []
  type: TYPE_NORMAL
- en: So, what you’ve learned so far is in absolutely no way a wasted effort – it
    was *required* to be able to understand something such as React.
  prefs: []
  type: TYPE_NORMAL
- en: React above them all
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem that I’m giving far more attention to React than any others, and
    that’s intentional: React is, by a fairly wide margin, the most popular frontend
    tool out there at the time of writing. It’s the one you’re most likely to use
    in most environments. It’s also arguably the simplest, and also in many regards
    looks similar to most others. While they’re all different, they have a common
    enough philosophy that I think if you understand React, then when and if you have
    to use something else, your React knowledge will provide a sufficient foundation
    to learn the other easily enough.'
  prefs: []
  type: TYPE_NORMAL
- en: Meeting React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React** comes from our friends at Facebook (or our enemies – it seems everyone
    has an opinion about Facebook, and it tends to be pretty extreme one way or the
    other, rarely neutral). React is a library that focuses on building the user interface
    of websites, and little else. There is some degree of debate in development circles
    about whether React is a framework, but given that its creator calls it a library,
    I think we can reasonably go with that!'
  prefs: []
  type: TYPE_NORMAL
- en: The underlying goal of React is to make it easy to reason about the state and
    structure of your interface at any given moment in time. What you see on the screen
    is a function of the underlying data – the state – that the UI is showing. It
    accomplishes this by way of components, which are essentially self-contained pieces
    of the interface. When you combine a whole bunch of components, you wind up with
    the overall interface, and a working website or web app ultimately, backed up
    by a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: React uses a concept called the **virtual DOM**, or **VDOM**, to do all of this
    effectively. When you write code with React, you don’t work with the VDOM directly,
    but it’s always there. React uses it under the covers to make everything work,
    so what exactly is it?
  prefs: []
  type: TYPE_NORMAL
- en: You were introduced to the DOM earlier, that tree of elements that the browser
    creates from your markup, and which is manipulated by both code and events. When
    such changes occur, the browser must perform a lot of work, which can be intensive
    and expensive in terms of performance. Some changes don’t impact the flow, or
    structure, of the page, and are therefore less expensive. Something such as changing
    the color of existing text falls into this category. But something such as inserting
    a new `<div>` element into the page changes the flow – the structure of the DOM
    essentially – and as a result, the browser has to recalculate a lot before it
    can then repaint the screen. The DOM handles all of this, and depending on the
    type and degree of change, it can result in a sluggish, slow interface that doesn’t
    react immediately to user interactions, which isn’t a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this problem, React introduces the concept of the VDOM. This is
    a secondary DOM that conceptually sits on top of the real DOM but is implemented
    in JavaScript. When something happens in React that requires the screen to be
    updated, rather than directly manipulating the real DOM immediately, the VDOM
    will be changed. This allows React to mediate and manage the changes to perform
    them more efficiently when they are ultimately done on the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: React uses what’s called a diffing algorithm, which is code that compares the
    VDOM to the real DOM and collects a list of the differences. React is then able
    to make intelligent decisions about the minimum set of changes that have to be
    made to the real DOM and can do things such as batch them all together (which
    tends to be more efficient than doing them one by one), or defer them until no
    other events occur, generally trying to minimize the amount of changes that have
    to occur to the real DOM. In general, assuming everything is done right, this
    approach can yield better performance than always manipulating the real DOM directly.
  prefs: []
  type: TYPE_NORMAL
- en: A simple React example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s jump right into a React example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Be it ever so humble – a (very) simple React example](img/B18315_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Be it ever so humble – a (very) simple React example'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a friendly greeting and a button that increments a counter
    when clicked. It’s simple, but it’ll demonstrate the basics well enough. We’ll
    need to create three files – `react.html`, `react.js`, and `react-greeting.js`
    – which you can find in the `ch-06` directory of the download bundle after that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with `react.html` (and work on the other two files shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To run this, you’ll need to put it on a web server; otherwise, you’ll run into
    problems with something called `react.development.js` script here can be a problem
    if the `unpkg.com` domain doesn’t allow requests from domains other than `unpkg.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as it turns out in this case, that’s not a problem because `unpkg.com`
    is what’s known as a `react.html` in your browser, namely that it won’t allow
    the JavaScript imports from a `file://` scheme. When a site is hosted on a web
    server, the scheme that’s used is `http://` or `https://`, as we previously talked
    about. But when you just load a file from your local filesystem, the browser uses
    the `file://` scheme, and most browsers today will have CORS rules that won’t
    let the content be imported into the page if it doesn’t come from the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To get around that, we need to put the files on a web server so that the `http://`
    scheme will be used instead, and the requests will then work. There are many ways
    you could do that, but one of the simplest is to use the `http-server` package,
    which is a Node package that implements a simple web server as an executable program
    without you having to write any code. You just run it, and it starts a web server
    that makes the files in the directory you run it from accessible via browser by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get set up, you need to create an npm/Node project, which you already
    know how to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You would do this in the `ch-06` directory (you’ll find it’s already been done;
    I’m just walking you through the steps I did already) and select all defaults
    as usual. Then, add the `http-server` package as a dev dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go into the `ch-06` directory and start the server, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you will be able to access the `react.html` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like what’s shown in *Figure 6**.2* in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: http-server, up and running, serving files](img/B18315_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: http-server, up and running, serving files'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have it running, let’s take a look at the HTML file and see what’s
    going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have three JavaScript files that have been imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`react.development.js` is React itself, and the development part indicates
    that this is a version suitable for development. There is also a non-development
    version, which is meant for when you deploy your site for real, and the difference
    is that the version will be reduced in size and obfuscated in a process called
    **minification**. Not only does this process reduce the size, but it also alters
    the code into a form that is more efficient, but also harder to debug. Once your
    site is fully working with the development version, that’s not a problem and it’ll
    be more important to have the more efficient version running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-dom.development.js` is a helper library that React uses to interface
    with the browser itself. Both are needed to use React in any meaningful way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babel.min.js` is the in-browser version of something called Babel. That’s
    a topic I’ll be covering in the *Transpiling and data typing* section later, but
    in short, it’s a library that can take code in one form and convert it into another.
    In this case, it will be converting something called JSX into plain old JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although it’s not what we’re primarily concerned with here, I’d be remiss if
    I didn’t mention the URLs that you see for these. As I mentioned earlier, these
    three files come from the [unpkg.com](http://unpkg.com) CDN. This is a popular
    site that hosts all sorts of libraries, frameworks, and toolkits. It hosts everything
    that can be found on npmjs.org, which is where npm gets everything you install
    from. The way you use it is to specify a URL in the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can get a copy of anything you want, and any version of it you
    want, without having to install it locally. This can not only be faster because
    CDNs like this will have multiple servers all around the world and will route
    requests to the nearest one for speed, but it also makes getting examples like
    this, or indeed real projects, up and running quickly and easily since you don’t
    have to worry about getting the dependencies yourself. It’s just another tool
    in the toolbox to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Our first component – RootComponent
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After the three imports are done, it’s just a simple HTML `<body>` with a single
    `<div>`. This is where React will create our app, where it will generate HTML
    and insert it (as well as CSS and JavaScript). But the app is defined in a second
    file, the `react.js` file, which is imported right after that `<div>`. Without
    it, we’d just have a blank page! So, let’s look at it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Every React app begins with a single root component. It can be the only component
    sometimes, though that doesn’t use the full power of React, which is building
    up an interface from several components.
  prefs: []
  type: TYPE_NORMAL
- en: 'A component can take a couple of different forms, but here, I’m focusing on
    the new form, which is generally considered better these days: functional components.
    In short, you have a JavaScript function that’s defined using arrow notation where
    a variable references `RootComponent`. That variable becomes a tag you can use
    later, as you’ll see shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The job of any React component is to return HTML that is shown on the page.
    With a functional component, you simply return that markup from the function itself.
    How you return the markup is entirely up to you, but perhaps the most common form
    is shown here: JSX.'
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside the function that is our root component, you return the markup for the
    component, which can be any HTML you wish. But you may be looking at that code
    thinking something doesn’t look quite right, and you’re right: it’s not valid
    JavaScript!'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, this is another language called JSX, which is an extended version of
    JavaScript where you can embed HTML in it. That may sound weird, but it makes
    for much simpler code. Without JSX, what you see here would require several dozen
    lines of somewhat complex JavaScript code to build up the HTML that is returned
    by the function. Instead, with JSX, we can just write (a form of) HTML and the
    Babel import from earlier will convert it into JavaScript that calls on React
    functions to produce the HTML, CSS, and JavaScript for this component.
  prefs: []
  type: TYPE_NORMAL
- en: The markup that’s returned is fairly simple. It’s just a `<div>` element with
    a `<GreetingComponent>` element (whatever that is – we’ll get to that soon), a
    `<button>` element, and a `<p>` element in it. The `<button>` element has an `onClick`
    handler, but the syntax there is different than you’ve seen before. With JSX,
    the values of HTML tag properties must be enclosed in braces, not quotes like
    you’ve seen before. The value is a JavaScript function that, when called, calls
    the `setCount()` function, passing it the value of the `count` variable incremented
    by one. Inside the `<p>` element, there is some static text, and then a JSX expression.
    As with interpolated strings, which I’ve talked about before, JSX allows you to
    insert the value of JavaScript expressions into the markup to be returned. Here
    is the value of the `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’ve skipped over a couple of things here, so let’s talk about them now,
    starting with that line of code before the `return` statement that implements
    something called state in our component.
  prefs: []
  type: TYPE_NORMAL
- en: Component state
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: React components can – but don’t *have* to – have state. That’s just a fancy
    way of saying it has data internal to it. Generally speaking, state can’t be touched
    from outside the component. There are many, many options for implementing state
    in a component, but the key thing that has to happen is inherent in the name React
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The name React comes from the fact that the UI you build with it is *reactive*,
    meaning it changes as data changes, whether triggered by user interaction or not.
    For example, since this app shows a counter and a button to increment it, we want
    the counter value to be updated on the screen when the user presses the button.
    In a web app using plain JavaScript, HTML, and CSS, you can imagine code that
    executes when the button is clicked which increments a JavaScript variable and
    then uses DOM methods to update the screen. But with React, much of that happens
    automatically, and it’s based on the notion of state.
  prefs: []
  type: TYPE_NORMAL
- en: When the state of a component – the data internal to it – changes, React will
    destroy the component and r-create it, which means the function you write is executed
    again to produce new markup which will use the new state data. The web app *reacts*
    to the change, in other words, without you directly updating the screen in code.
  prefs: []
  type: TYPE_NORMAL
- en: So, React has to be aware of the internal state data of a component because
    it has to monitor it for changes so that it knows when to destroy and re-create
    the component. Therefore, we can’t (usually) just have plain old JavaScript variables
    in there because React wouldn’t know about them. Instead, we have to create those
    variables in a way that makes React aware of them, and that’s what the call to
    `React.useState()` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass to it any JavaScript value we wish – in this case, just a number –
    and `React.useState()` returns a value that is two things: the current state of
    our new state variable, and a function to use to update it. It’s effectively that
    update function that makes React aware of changes: any time we call it, React
    knows the state of our component has changed, and it can decide whether the component
    needs to be destroyed and re-created or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to have a reference to both of the things returned by that call,
    we use a JavaScript capability called `const [ count, setCount ]` part of the
    line is for. When executed, it results in two variables being created, one named
    `count` and another named `setCount`. The `count` variable gets the current value
    we set in the state, which is 0, and the second gets a reference to the `update`
    function. Destructuring is a feature that allows you to copy the values from arrays
    or properties from objects into distinct variables. Without it, the code you would
    have to write to get the values from the array returned by `React.useState(0);`
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring is just a shorter way of writing that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having those variables available allows us to write the `onClick` handler on
    the `<button>` element now: the `setCount()` function is called, passing in the
    new value for the state variable, which is just `count+1`.'
  prefs: []
  type: TYPE_NORMAL
- en: React will decide that the component should be destroyed and recreated, so our
    function will be called again, and new markup will be returned. This time, notice
    that inside `<p>` is the `{count}` expression. This means that the current value
    of our state variable, `count`, will be inserted, so we’d see 1 on the screen
    after the first button click. It’s important to understand that state variables
    remain between component destruction and recreation. So, what’s returned by the
    call to `React.useState()` when the component is recreated won’t be 0, despite
    that being the value passed to it, because React will already be aware of this
    state variable and will have already created it with the default value when `React.useState()`
    was first called. So, it will return the current value, not the default value.
    It won’t recreate the component’s state – in other words, it’ll be kept no matter
    how many times the component is destroyed and recreated.
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code here – the call to `ReactDOM.render()` – is what creates
    our interface. This kind of code is often termed *bootstrapping*, meaning it’s
    where the work begins, or where everything is kicked off from more colloquially.
    We pass to it the React component that is to be the root component of our app,
    and then a reference to the DOM node where it should be inserted. Look back on
    the HTML and you’ll recognize the `<div>` element with an ID of root. Whatever
    markup this root component returns will be inserted into that `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what’s the deal with `<GreetingComponent>`? That’s not a real HTML tag!
    Well, it *could* be – you don’t know all HTML tags, after all – but it’s not,
    and the deal with it is that it’s another React component that I’ve created and
    it’s the one responsible for showing the greeting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another component – GreetingComponent
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll notice that `GreetingComponent` was imported into `react.html` before
    `react.js` was. This is important in that it has to be imported before it’s referenced
    in `react.js`; otherwise, when it’s referenced in `react.js`, we’d get a JavaScript
    error about it being undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does the code for that component look like? It’s quite simple, and
    it’s in the `react-greeting.js` file, which is the third of the three imported
    into the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, no state is needed, so it’s nothing but a return statement returning
    some plain old HTML. The only thing of real note is the value of the style attribute.
    Normally, this would be something like `"color:red;"`, but since our components
    are written using JSX, that won’t work. Instead, we need to use the brace syntax,
    and then we list out the style attributes to set, which is just the color of the
    text set to red.
  prefs: []
  type: TYPE_NORMAL
- en: But I seem to have glossed over something, haven’t I? What’s that `textColor`
    stuff all about? That gets into another core concept of React named props.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Props are the basic mechanism by which components can pass information to one
    another. Props always work from parent to child, meaning in our case that the
    root component can pass information to `GreetingComponent` since it’s the child
    of the root component, but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Props are simply attributes on the tags for the custom components you create,
    which is why you can write `<GreetingComponent textColor="red" />`. Since the
    `GreetingComponent` function has an object with a `textColor` attribute in its
    signature, that’s enough for React to know that’s a valid prop that can be passed
    into `GreetingComponent`. Inside the function, you can access the `textColor`
    variable as you can any JavaScript variable, so we can insert it into the style
    attribute, as shown in this code. This way, our parent component (`RootComponent`)
    can tell `GreetingComponent` what color to make the text.
  prefs: []
  type: TYPE_NORMAL
- en: Components can be as simple or as complex as you need them to be, can have as
    many props as you need (or none at all), and can have state (or not). But the
    whole point of React, and almost any modern frontend framework, is to compose
    your UI from many small components. This makes testing them easier and allows
    you to build complex interfaces with components that you can reuse many times,
    saving time as you progress.
  prefs: []
  type: TYPE_NORMAL
- en: As neat as React is, sometimes, it’s not quite enough, and that’s where something
    called a meta framework comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Meta frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **meta framework** is a framework that enhances other frameworks, sometimes
    combining multiple frameworks (or libraries or toolkits). It builds on top of
    another framework or platform, providing more capabilities, often in the form
    of automatic code generation.
  prefs: []
  type: TYPE_NORMAL
- en: In short, meta frameworks try to save you time by doing things such as supplying
    intelligent defaults for configuration and capabilities such as the ability to
    read in plain text files and generate a complete website from them. They can save
    a great deal of time and effort, with the main trade-off being a bit less developer
    control.
  prefs: []
  type: TYPE_NORMAL
- en: There are many meta frameworks, but one of the most popular is Next, built on
    top of React.
  prefs: []
  type: TYPE_NORMAL
- en: You have to remember that React is a pretty simple library. It provides the
    basic structure that components must follow, state and props, and a well-defined
    life cycle that all React apps and components go through. However, building a
    more complex web app will often require a lot more capabilities, all of which
    can be added to React piecemeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, you can use something such as Next, which adds a great many of
    them in for you at once, including the initial project setup. Some of the key
    things that Next adds on top of React are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Server-side rendering (SSR)*: Next allows React components to be rendered
    on the server, improving initial load times and **search engine optimization**
    (**SEO**, the art of getting as high as possible in search engine results).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Static site generation (SSG)*: You can pre-render pages at build time rather
    than at runtime, which is great for performance and SEO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*File-based routing*: Next uses a filesystem-based routing mechanism. Pages
    are automatically routed based on their filenames in a specified directory. This
    provides a common structure and navigational model to your website automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*API routes*: This allows you to create API endpoints as part of your Next
    application. This is useful for building full-stack applications with a unified
    codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zero configuration*: Next works out-of-the-box with minimal setup, yet it’s
    highly configurable for more complex needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automatic code splitting*: Next automatically splits code into manageable
    chunks, loading only what’s necessary for the current page, which enhances performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Built-in CSS and Sass support*: Next has built-in support for CSS and Sass
    (an extended form of CSS), allowing you to import styles directly into your components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Image optimization*: Next includes automatic image optimization for better
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next adds all of this, and more, to React, saving you the hassle of adding it
    all yourself. Therefore, it is the quintessential meta framework, making use of
    many other libraries and frameworks to deliver these abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a competitor to React, another relatively small library
    that has gained a lot of traction quickly: Vue.'
  prefs: []
  type: TYPE_NORMAL
- en: Meeting Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Vue**, created by Evan You and first released in 2014, is a JavaScript library
    that’s used for building user interfaces and SPAs. It is designed to be incrementally
    adoptable, meaning it can be easily integrated into projects where jQuery or another
    library is already in use, or it can be used to build more sophisticated applications
    when combined with modern tooling and supporting libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of Vue’s core features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive and composable view layer*: At its core, Vue focuses on the view
    layer – that is, the user interface. It supplies a reactive way to render data
    to the DOM using straightforward template syntax, meaning that like React, it
    knows when to re-draw parts of the page when state changes, and the components
    you build use a simple string-based markup generation approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Component-based architecture*: Vue encourages the use of components to build
    UIs. Each component in Vue is essentially a reusable instance with data, methods,
    and life cycle events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Directives*: Vue uses special attributes, known as directives, to provide
    added functionality to existing HTML elements – for example, `v-if` for conditional
    rendering and `v-on` for handling events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transition effects*: Vue provides ways to apply transition animation effects
    when items are inserted, updated, or removed from the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vue CLI*: This is a command-line tool for scaffolding (generating the basic
    skeleton of) Vue applications. It offers a range of build setups to start with
    and is highly configurable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vue router*: The official router for Vue. It integrates deeply with Vue Core
    to make building SPAs and managing the navigation between its screens with Vue
    a breeze.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ease of learning*: Vue’s learning curve is generally considered to be less
    steep than other libraries. Its straightforward syntax and excellent documentation
    make it accessible to beginners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flexibility*: Vue’s design allows it to be as simple or complex as your project
    requires. It can be dropped into an existing project or used to build an entire
    project from scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance*: Vue is lightweight and offers good performance. Its small size
    and efficient change detection mechanism make it fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Community support*: Although younger than some of its counterparts, Vue has
    a vibrant and growing community, with many resources for learning and a wide array
    of third-party plugins and components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue is well-suited for those starting in the world of modern JavaScript frameworks,
    as well as for developers building complex, large-scale applications. Its simplicity,
    combined with its power, makes it a popular choice among both beginners and seasoned
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a brief look at a Vue app in action, starting with `vue.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This shouldn’t look too different from the React example from earlier. Similar
    to that example, we have a single `<div>` element; this is where the interface
    built by Vue will live. However, as opposed to React, just a single import is
    required: Vue itself in `vue.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: But, unlike React, we have to put something there, namely our root component.
    I’ve created a custom component named `example-component`, so I can put the `<example-component>`
    custom tag there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vueApp.js` file is then imported, which houses that custom component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With Vue, there’s no JSX (there doesn’t *have* to be with React either – it’s
    just easier this way), and instead we call the `Vue.component()` function to define
    a custom component. We give it a name as the first argument, and then pass in
    a JavaScript object that defines the component.
  prefs: []
  type: TYPE_NORMAL
- en: We can have internal state data as in React by defining a `data` attribute that
    is a function that returns an object having whatever state data we want as fields
    in it. Vue knows how to take this and monitor it like React so that it can update
    the interface as necessary when state changes, making everything reactive.
  prefs: []
  type: TYPE_NORMAL
- en: But rather than a React function returning markup, a Vue component must provide
    a `template` string that defines the markup this component produces. Here, I’ve
    used JavaScript string interpolation to allow the `template` string to flow across
    multiple lines so that I can insert elements from the state data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is very similar to the React example, as shown in *Figure 6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The Vue example, after a couple of button clicks](img/B18315_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The Vue example, after a couple of button clicks'
  prefs: []
  type: TYPE_NORMAL
- en: This time, though, the color of the message is defined in state directly rather
    than passed into the child component. The `:style` attribute syntax, that leading
    semicolon specifically, is necessary for Vue to be able to recognize that we want
    to output the `color` value in the generated HTML. Without it, you’d find that
    the style property isn’t present in the generated HTML and the text wouldn’t be
    red. Then, the `{{message}}` token has the effect of inserting the message text
    into the returned string.
  prefs: []
  type: TYPE_NORMAL
- en: The `<button>` element uses a Vue directive, `v-on`, to define a click handler.
    Unlike with React, we can change – or *mutate*, as we like to say in computer
    science circles – the `count` value directly because Vue has intelligently hooked
    into it and so knows what to do when it sees this code. Note that this is shorter
    than the React equivalent. The current value of `count` is inserted with `{{count}}`,
    giving us, more or less, the same result as the React version.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as with React, we have to bootstrap our app, but it’s a bit simpler here
    too. We create a new `Vue` object, passing it the ID of the existing HTML element
    to insert our root component into (`el` standing for element, and `#app` being
    like a CSS selector to find the `<div>` element with an ID of `app`), and that’s
    it! Vue takes care of the rest for us.
  prefs: []
  type: TYPE_NORMAL
- en: So, you’ve seen plain HTML/CSS/JSS, you’ve seen React, and now you’ve seen Vue.
    Those aren’t your only choices, of course. There are meta frameworks too, but
    there are also other frameworks out there that can be your one-stop shop for frontend
    development, and probably the biggest one is Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Meeting Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Angular** is a free, open source web framework for building single-page web
    applications. It’s developed and maintained by Google, in addition to a larger
    community of individuals and corporations. Angular’s first release, known as Angular
    2.0, was released on September 14, 2016\. It was a complete rewrite of an earlier
    framework named AngularJS. While they share a similar name, they are rather different
    and are considered two different things entirely (if for no other reason than
    apps written using AngularJS will rarely work with Angular).'
  prefs: []
  type: TYPE_NORMAL
- en: Angular has had many rapid-fire updates since its creation, some more notable
    than others. For example, Angular 4 was released on March 23, 2017, with Angular
    5 following on November 1, 2017, the latter of which brought improvements such
    as support for progressive web apps. Angular 6, released on May 4, 2018, focused
    on the toolchain (the command-line tools you use to build Angular apps, which
    is a big part of what it does, and some would say its appeal), and ease of future
    development. Subsequent versions continued to add features and improvements regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is known for several key features. One is two-way data binding, which
    is a way to tie the UI components on the screen together with data. Essentially,
    a change in a UI component results in a change to the data, and vice versa, automatically,
    which leads to developers having to write less code in most cases while maintaining
    reactivity. Dependency injection is another key capability. This allows objects
    in code to be created by the framework and provided to application code, rather
    than the application code having to create them itself.
  prefs: []
  type: TYPE_NORMAL
- en: Like React and Vue, Angular follows a component-based architecture, allowing
    for reusable components and efficient development practices. However, Angular’s
    structure tends to be more complex. While React components are usually a combination
    of HTML, JavaScript, and CSS, Angular apps will usually break those out into separate
    files, so a component will be made up of multiple source files rather than (usually)
    just one in React or Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Angular tends to be used in large-scale “enterprise” web apps due to its robust
    feature set and scalability. Angular supplies virtually everything a developer
    may need to build such apps under one roof. This is in contrast to lighter libraries
    such as React or Vue, where you’ll typically need to add other libraries as you
    need them. For example, having your client-side code communicate with your server-side
    code will often mean adding a library such as Axios, an open-source communication
    library, to your React or Vue app. By contrast, Angular provides that function
    (you don’t *have* to use it, but one of the big draws of Angular is having just
    one dependency to deal with, so most Angular developers would tend to use it).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what separates Angular from React and Vue? Let’s look at some key highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Core philosophy*: Angular is a full-fledged framework offering a strong opinion
    on how your app should be structured and, as mentioned before, providing – theoretically
    – everything a developer needs in one place. React and Vue are libraries that
    focus just on UI components, giving you more freedom to use other libraries for
    different aspects of your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Language*: Angular uses TS, a language we’ll look at later, but in short,
    it’s an extended version of JavaScript that adds some key features, primarily
    strong typing. While you can develop React and Vue apps with TS as well, and many
    people do, Angular requires it (well, at least once you move beyond very basic
    example territory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data binding*: As mentioned previously, Angular has two-way data binding,
    meaning changes in the UI are automatically reflected in the app state and vice
    versa. React and Vue use a one-way data flow, where the UI is updated via state
    changes, making it more predictable but requiring more boilerplate to update the
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning curve*: Angular’s comprehensive nature makes its learning curve steeper
    compared to React and Vue, which is more straightforward to start with due to
    its simplicity and focus on UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance*: While Angular has good performance overall, React and Vue tend
    to have better performance due to its virtual DOM system in the case of React
    and simplicity in the case of Vue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you’re talking about Angular, React, or Vue, all three are powerful
    in their own right, and the choice often comes down to the specific needs and
    preferences of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at an Angular version of our counter example. As with
    React and Vue, we start with a plain HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This basic form should start to look familiar at this point! Angular, at its
    most basic level, just requires a single `angular.min.js` file to be imported.
    With Angular, the element that the app will be rendered into (that the root component
    will be rendered into, in other words) is usually the `<body>` element itself.
  prefs: []
  type: TYPE_NORMAL
- en: And on the `<body>` tag, you can see one thing that Angular does differently
    than React and Vue, and does so a lot, and that’s the use of `ng-app` is an example
    of.
  prefs: []
  type: TYPE_NORMAL
- en: You see, when a page that uses Angular loads, the Angular code goes through
    the HTML and looks for these directives, converting them (and often the entire
    tag it’s on) into other HTML markup that Angular needs. Here, `ng-app="app"` identifies
    the `<body>` element as containing an Angular app. Angular contains many directives
    for doing many things, some of which include creating repeating sections of markup
    (`NGFor`), adding or removing elements based on some logic condition (`NGIf`),
    and binding things together using two-way data binding (`NGModel`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a container element for the app marked with the `ng-app` directive,
    we can begin to use custom components inside of it, and the `<root-component>`
    element is exactly that: a custom root component. As with React and Vue, all components
    will be children, direct or indirect, of a root component. Here’s the code for
    that component, contained in the imported `angular.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an Angular module named `app`. Modules allow us to organize
    our code into discrete units more logically. The first argument is simply the
    name of the module, which is typically `app` – as shown here – for the module
    representing the app itself. The second argument, an empty array, indicates that
    this module doesn’t have dependencies on other modules, which they often will,
    but not in such a simple example as this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a component named `rootComponent` is defined. The approach you can see
    here is perhaps the simplest – that is, using the `template` attribute of the
    object that was passed to `app.component()` as the second argument. The value
    of this defines the HTML structure for the component. It shouldn’t look that different
    to you than the Vue example from earlier. Once again, tokens can be inserted into
    the markup based on the state of the component, which Angular also has a notion
    of. The `style` attribute of the first `<p>` element uses Angular’s data binding
    to set its color based on the `textColor` property in the scope, which is essentially
    the same idea as state in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `controller` function defines the behavior of the component. The `$scope`
    argument is an example of Angular’s dependency injection and is created and injected
    into the controller automatically by the framework when the component is created.
    The `controller` function sets up three properties on `$scope`: `message`, `count`,
    and `textColor`. These are then used in the component’s template when the component
    is rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: To use this component in an Angular application, you must use the custom `<root-component>`
    HTML element. Note that Angular automatically alters the name in this fashion
    for all components so that you wind up with a consistent naming pattern for your
    custom components. When Angular runs, it will replace this element with the specified
    `template` content, and the controller will manage the component’s behavior, such
    as when the user clicks the button, triggering a re-render of the component with
    the updated scope value for the `count` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example of Angular’s declarative approach to building UIs,
    where you define what you want and let the framework handle the DOM manipulations
    and data bindings. This time, I’ll save a few trees and not drop a screenshot
    onto the page because it looks no different from the React and Vue examples. But
    that’s on purpose: this exercise was to show you the same basic example done three
    ways so that you can compare and contrast them a little bit.'
  prefs: []
  type: TYPE_NORMAL
- en: I feel that it’s important to reiterate the point that this is just about as
    simple as Angular can get. A more full-featured Angular app will be noticeably
    more complex in many ways and will be written using TS, which we’ll be looking
    at later in this chapter. So far, we’ve talked about JavaScript libraries and
    frameworks, so let’s switch gears and talk about how CSS can be enhanced in a
    similar way to provide a more robust feature set.
  prefs: []
  type: TYPE_NORMAL
- en: Boosting CSS capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While libraries and frameworks such as React and Angular tend to be the big
    hitters these days and tend to cover most of the bases in terms of HTML, CSS,
    and JavaScript, there are ways to augment those technologies, such as when using
    jQuery to augment JavaScript, and leave the other two entirely unchanged. CSS
    can also be augmented in this way, by using a CSS library. These can be as simple
    as a stylesheet file you import, or as complex as actually a combination of CSS
    and JavaScript working together to dynamically generate CSS based on simple configuration
    on your part.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not impossible or even necessarily unusual to use such a CSS library in
    conjunction with a framework such as Angular, though that’s becoming less and
    less common as these frameworks gain more capabilities. But regardless of whether
    you use them alone or in conjunction with something else, let’s take a look at
    two of the most popular out there: Bootstrap and Tailwind.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bootstrap** is billed as a frontend toolkit, and it is used for developing
    responsive and mobile-first web pages. It provides a collection of HTML, CSS,
    and JavaScript tools for creating websites and web apps. Bootstrap includes pre-designed
    components such as buttons, forms, navigation bars, modals, and much more, which
    can be easily customized. Using Bootstrap is simple, as this example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All it takes is importing a Bootstrap CSS file, and optionally (though usually)
    a JavaScript file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s done, the majority of what you do with Bootstrap is apply style
    classes, such as `container`, to say you want a container that will resize based
    on the available width of the screen, as shown in the first `<div>` element. The
    `btn` class transforms a regular `<button>` element into a Bootstrap-controlled
    button, which means you can then apply further styles to it, such as `btn-info`,
    which gives us a bluish button with rounded edges, a bit nicer than a typical
    browser-supplied button.
  prefs: []
  type: TYPE_NORMAL
- en: This makes Bootstrap aware of this button and then allows us to attach behaviors
    to it by using `data-*` attributes. Any time you see `data-*` on a tag, that’s
    custom data that something else likely depends on. You can add `data-*` elements
    like this any time you like, and they have no bearing on the appearance of your
    markup, at least not directly. The browser simply ignores them because they’re
    for you, not it.
  prefs: []
  type: TYPE_NORMAL
- en: But when Bootstrap sees those attributes on elements, it knows that you want
    to do something with it. In this case, `data-bs-toggle` tells it that you want
    the button to expand and collapse a section of content, namely the one with an
    ID of `text` here, which is then named in the `data-bs-target` attribute. The
    `<div>` element that follows the button has an ID of `text`, and also has the
    Bootstrap `collapse` style class applied. The result is that, without having to
    write any JavaScript or CSS ourselves, we can click the button to expand and collapse
    the content in that `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is a bit more than just a CSS library. While it certainly does include
    a lot of CSS styles you can use right out of the box, it also offers components
    (such as the buttons and collapsible container seen in this sample), various other
    kinds of containers for doing layouts, including breakpoints for responsive design,
    and even JavaScript helper functions. It’s also extensible in that you can add
    plugins to extend its capabilities and themes to change the look and feel of its
    components wholesale. Bootstrap is also customizable in that you can override
    most of its styles and change how the results look without much difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: All of this has made Bootstrap popular for a long time, and also because it
    tends to be quite simple to use but offers a fair bit of power. But its popularity
    is waning a little bit, in large part because sites built with Bootstrap all tend
    to look the same since it supplies components that largely define the look and
    feel of a site, and people generally don’t like that. While in no way an outright
    replacement, the new kid on the block, Tailwind, has been gaining developer mindshare
    rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Tailwind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tailwind** is billed as a utility-first CSS framework for rapidly building
    custom designs. Unlike other CSS frameworks, such as Bootstrap, which come with
    predefined components, Tailwind provides low-level utility classes only, which
    lets the developer more easily build completely custom designs without ever leaving
    your HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tailwind comes with *a lot* more style classes than Bootstrap, which is kind
    of the point. Rather than drop a `btn` class on a `<button>` element, as in Bootstrap,
    with Tailwind, you might write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is equivalent to the Bootstrap example, but you can see some key
    differences. First, Tailwind only requires us to import a stylesheet, not a JavaScript
    file, and no jQuery dependency. It’s generally nice to have fewer things to import,
    but there is a cost here: we don’t get the automatic expand/collapse functionality
    like with Bootstrap, and we have to write some JavaScript ourselves for that.
    That’s down on the `<button>` element. In response to the `onClick` event, we
    get a reference to the text content by calling `document.getElementById()`, which
    returns a DOM node. This has a list of classes applied, and calling `toggle()`
    on that list and passing it the name of a class adds or removes it, depending
    on the current state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing to notice here, which is the hallmark of Tailwind, is all the
    style classes applied to the `<button>` element (this is true for other elements,
    but let’s focus on `<button>`). These are the Tailwind utility-style classes.
    Rather than a single `btn` class that has all the styles for a button like with
    Bootstrap, instead, you apply just the utility class you want:'
  prefs: []
  type: TYPE_NORMAL
- en: The `bg-blue-500` class gives the button a blue background color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hover:bg-blue-700` class defines a hover pseudo style to make it a different
    shade of blue when you hover over it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `text-white` class makes the text on it white and `font-bold` bolds it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `py-2` class applies padding on the top and bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `px-4` class applies padding on the left and right around the text in the
    button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rounded` class gives the button rounded corners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, you have much more fine-grained control over how the button
    looks. You can easily make the text red, for example, or change the amount of
    padding. With Bootstrap, you would need to override the styles that it provides,
    but with Tailwind, you only ever get what you want. There are more style classes
    to deal with – a lot more – but you have more control and flexibility by default,
    which means with Tailwind, there’s a better chance that your site won’t look like
    every other one using Tailwind out there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to another topic that largely defines what most people consider
    modern web development, that being the concept of transpiling, specifically with
    a tool called Babel.
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling and data typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a fun language in many ways, being extremely flexible and relatively
    easy to learn. However, while it’s fun to some, to others, they’ll tell you it’s
    an absolute nightmare! For that latter group, the complaints largely come down
    to one thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is perfectly valid JavaScript code, but it’s also code that will cause
    an error. Why? What gives?!
  prefs: []
  type: TYPE_NORMAL
- en: First, the `myVar` variable is given a value of `abc`, which is a string. Then,
    we call the `toUpperCase()` method on that string, which is a method that all
    JavaScript strings have to convert into uppercase. After that, the value of `myVar`
    is changed to `123`, which is a number. The error then occurs on the second `toUpperCase()`
    call because that method isn’t available on a number.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we’re running into is related to a concept in programming called
    **data typing**. It’s the idea that a variable holds some data, and usually, we
    need to explicitly state in our code what type of data it is. The language often
    needs to know this because not all operations are valid for all types of data.
    As described before, you can’t convert a number into uppercase because that doesn’t
    make logical sense like it does with a string. Therefore, so long as the language
    knows what type of data a variable holds, it can proactively inform us of any
    mistakes we might make in terms of data typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem in this example is that JavaScript is what’s called a *dynamically
    typed* language (sometimes called loosely typed), meaning the type of a variable
    can change on a whim. This is opposed to a *statically typed* language (or strongly
    typed), such as Java, where you have to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, the error will occur on the third line. When `myVar` is declared, in Java,
    we have to specify a type for it – `String` – so that Java knows that `myVar`
    is only allowed to contain a string. The code won’t even make it to the second
    call to `toUpperCase()` because trying to set `myVar` to `123` will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'But here’s the key point: *this error will occur at compile time*. You see,
    JavaScript doesn’t need to be compiled – that is, converted from source code into
    a form the computer can execute. Instead, the source code itself is executed.
    JavaScript only has a runtime, meaning when the code runs.'
  prefs: []
  type: TYPE_NORMAL
- en: Java, on the other hand, has to be compiled, which is when source code is transformed
    into another form (in the case of Java, that form is called **Intermediate Language**,
    or **IL** for short) so that it can be executed by the computer. That’s not particularly
    important for this discussion, but the part that matters is that the error on
    the third line will be caught when we try to compile the code. In other words,
    *we would never be able to even try to execute it because the Java compiler won’t
    even produce IL*. It’ll see the error during compilation and tell us about it
    before it gets that far. This will all happen during your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, you would only find out about the error in the JavaScript code
    when you go to run it for real. If you’re lucky, this means during development.
    But what happens if that code doesn’t get executed during development? Maybe it’s
    in a function that’s rarely used. Now, guess who’s going to find the error? The
    answer is *your users* when they hit that line of code on your live site!
  prefs: []
  type: TYPE_NORMAL
- en: This problem, primarily, is what led to the creation of something called a **transpiler**.
    A transpiler is like a compiler in that it converts code from one form into another.
    But while a compile converts source code into an executable form, a transpiler
    converts from one form of source code into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other big problem that transpilers can help with is where there are differences
    in the runtime environment (which usually means a web browser in the case of JavaScript).
    Transpilers can smooth these over for you. For example, let’s say that Google
    Chrome supports that `toUpperCase()` method on strings, but maybe you find that
    Firefox doesn’t (don’t worry – they both do support it!). You could certainly
    write some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then have to figure out how to determine whether your code is running
    in Chrome or Firefox (giving a `true` or `false` value to that `running_in_chrome`
    variable), so you would have to write the code for `myOwnFunctionToDoUpperCase()`
    yourself, which does the equivalent of `toUpperCase()`. In this case, that’s not
    all that tall of an order, but you can imagine not all cases being quite so easy.
    This technique is called **polyfill**: writing code that allows you to use modern
    browser features in browsers that don’t yet support it.'
  prefs: []
  type: TYPE_NORMAL
- en: A transpiler essentially does this work for you. With a transpiler, it will
    see that the `toUpperCase()` function is used, recognize that it won’t work in
    the browser you specify that you want your code to work in, and automatically
    add the necessary polyfill. It will produce JavaScript that will work across all
    browsers that way. Yes, it’s converting JavaScript into JavaScript, but modified
    JavaScript on the output side.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, though, let’s talk about perhaps the most famous transpiler out there,
    certainly in the realm of web development: Babel.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Babel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Babel is a JavaScript transpiler that allows you to use next-generation JavaScript
    today. It converts newer forms of JavaScript code into a backward-compatible version
    for older browsers or environments (such as Node). Key features include transforming
    syntax (for example, converting functions in the `() => { }` form into the original
    `function xxx() { }` form), polyfilling features that are missing in your target
    environment, and source code transformations (typically things such as applying
    specific coding standards to make all your source code look the same). Babel is
    widely used in web development to ensure broad compatibility and to leverage the
    latest JavaScript features while maintaining support for older platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key points about Babel are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Plugins and presets*: Babel’s functionality can be extended through plugins.
    For example, things such as JSX can be supported through plugins. Presets essentially
    combine many different configuration options into a single option. For example,
    the `@babel/preset-env` preset will provide support for modern browsers without
    you having to configure every available option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configuration*: Babel can be configured by creating a `.babelrc` file, or
    by adding a babel section in a `package.json` file. This configuration specifies
    the presets and plugins to be used, as well as other available options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integration with build tools*: Babel is used by bundlers such as Webpack,
    Rollup, and Vite. Babel provides a lot of the functionality these bundlers offer
    (certainly not all of it, of course).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Community and ecosystem*: Babel has a large community and ecosystem, with
    many third-party plugins and tools available. This makes it a versatile tool that
    can adapt to many different project requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Babel’s role is crucial in ensuring that developers can use the latest JavaScript
    features without sacrificing compatibility, making it a cornerstone of modern
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: As useful and powerful as Babel is, you may have noticed that it doesn’t solve
    the type problem. JavaScript is still loosely typed, despite all that Babel can
    do for you. To solve that problem, we need to look at something else called TS,
    and the transpiler it provides, which can take the place of Babel (though Babel
    can handle TS too!).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing TS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript, or TS for short, is a product of Microsoft. It’s a programming language
    that is a superset of JavaScript, meaning it adds new features to JavaScript,
    most importantly static typing. This helps catch errors early in development.
    You transpile it to plain JavaScript so that it can run anywhere JavaScript does.
    TS is popular for large-scale projects due to its robust tooling and ability to
    make code more maintainable and understandable, but it’s certainly not just for
    big, enterprise projects!
  prefs: []
  type: TYPE_NORMAL
- en: 'TS isn’t just about static typing though – it has other benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Interfaces and classes*: TS supports **object-oriented programming** (**OOP**)
    concepts such as interfaces and classes, making it easier to structure complex
    systems and enforce contracts between different parts of your code. This is a
    more advanced topic that I won’t be covering in this book, but it’s something
    important for TS to support (JavaScript supports classes natively, though TS enhances
    this a fair bit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced types*: TS includes advanced types such as enums, tuples, and generics,
    allowing for more precise and flexible code (these, too, are more advanced topics
    not covered in this book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Type inference*: TS can often infer types, reducing the need to explicitly
    annotate code. This means that you don’t *always* have to specify a type because
    TS can oftentimes figure out what the right type is on its own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compatibility with JS*: TS is a superset of JavaScript, so any valid JavaScript
    code is also valid TS code. This makes it easier to adopt incrementally if you
    have an existing JavaScript code base that you want to convert into TS. You don’t
    need to do it all at once, which is very helpful if it’s a large code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tooling*: TS offers powerful tools for large projects, such as auto-completion,
    navigation, and refactoring, owing to its high level of support in IDEs and other
    developer tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s take a look at TS in action.
  prefs: []
  type: TYPE_NORMAL
- en: A simple TS example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with TS, the first step is installing the TS compiler (well,
    really transpiler). To do so, start by using `npm init` in a new project with
    npm, then install TS itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, this has already been done in the `ch-06/typescript` directory.
    In that same directory, you’ll find a file called `example.ts`. To compile it,
    execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tsc` command is the TS compiler. It will produce an `example.js` file,
    transpiling our TS code into pure JavaScrfipt. You can then run that JavaScript
    file (which you could not do with the TS file – go ahead and try it!) with Node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the code in `example.ts`. This is our actual TS source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we did is create a class. This is part of OOP that I mentioned
    earlier, and in simple terms, a class is a blueprint. It defines a thing that
    we can then create instances of earlier. Here, we have a `Person` class. Classes
    usually hold some kind of data, in fields, and here, there are two: `name` and
    `age`. This is also the first time you can see some data types being used: the
    part after the field name and semicolon is the type of that field. So, we’re saying
    that the name field must be a `string` type, and the age field must be a `number`
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add a function to the class. In this case, it’s a special function
    named `constructor()`. A constructor is a function in a class that will be executed
    whenever we create an instance of that class (and you can have multiple instances
    of a class in most cases). This particular function takes in two arguments, `inName`
    and `inAge`. And here, again, types – which are referred to as `inName`, we’ll
    get an error when we compile this code. Inside the function, the values of the
    `name` and `age` fields are set to the values that were passed in (`inName` and
    `inAge`, respectively). Writing `this` before the field names means that we’re
    setting the value on the instance of the class created later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add another function, this one named `speak()`. This will output a
    simple string telling us the person’s name, how old the person is, and a little
    bit of wisdom we’ll provide later. This just uses basic string interpolation to
    output the value of the fields, again referenced using `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ve defined the `Person` class, but on its own, that does nothing. We
    have to make use of this class by creating one or more instances of it. That’s
    the first line of code after the end of the class definition. Here, a variable
    named `p` is defined, and we apply a type annotation of the `Person` type. To
    create an instance of a class, we use the `new Person()` code as the value of
    the variable, and pass `name` and `age` values to it. This executes that `constructor()`
    function, and we now have a `Person` object referenced by the `p` variable with
    the `name` field having a value of “Xander” and the `age` field with a value of
    36.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to make Xander speak, so we call the `speak()` method on `p`,
    passing it the bit of wisdom to show via `console.log()` (a witty bit of dialogue
    from an old movie named *Jekyll and Hyde… Together Again* – check it out, it’s
    funny!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see what the results of compiling that TS code are in the `example.js`
    file that’s created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that looks a bit different, doesn’t it? The differences start with that
    first line. Since classes may not be natively supported by the browser (or version
    of Node) that runs this code, `tsc` has used a trick called an **IIFE**, which
    stands for **Immediately Invoked Function Expression**. This is a nifty little
    trick where you create a function (an anonymous function, because it doesn’t have
    a name), and then immediately call it while wrapping that execution in parenthesis.
    Here’s the basic form of this technique in plain JavaScript and without all the
    preceding code to confuse matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The reason we do this is so that everything inside the enclosing parenthesis
    creates what we call a `Person`, and then returning it, which is assigned to the
    `Person` variable outside. If we didn’t return it, then it wouldn’t be accessible
    to code outside the enclosing parenthesis. The result is the equivalent in JavaScript
    of defining a class in TS, but as you can see, it’s a bit more code.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the `/** @class */` line in the `example.js` code is a hint to certain
    tools (some of which are discussed in the next chapter) that help it do its job.
    They’re markers – that is, signs that provide some metadata to the tools. In this
    case, they’re telling it this is a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the IIFE, you can see how the `speak()` function is added to the `Person`
    function. This is a thing you can do in JavaScript because functions are objects.
    Every object has a prototype, which conceptually is the same as a class in OOP:
    it’s a blueprint from which all instances come, so anything that prototype has,
    all the instances of it will also have. So, with the `Person.prototype.speak`
    code, we’re saying that we want to add a thing called `speak` to all instances
    of `Person`, and the thing we want speak to is the function we assign to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside that `speak()` function, you can see how `tsc` has replaced our
    string interpolation tokens with the `concat()` function, which is a function
    JavaScript provides on strings to cram them together. Since string interpolation
    is a somewhat newer feature of JavaScript, it may not be supported yet in some
    browsers of versions of Node. `tsc` knows this by default and polyfills them with
    the use of `concat()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the type annotations have been removed throughout this code. That’s
    because they would be syntax errors in pure JavaScript, and anyway, they aren’t
    needed anymore. Remember that the whole point of TS is to catch data typing errors
    at compile time, so after the code is compiled (transpiled, really) to JavaScript,
    they no longer serve a purpose anyway.
  prefs: []
  type: TYPE_NORMAL
- en: From this relatively simple example, you can get a sense of TS. You can see
    how it is just an extension of JavaScript, including building classes and annotating
    things with types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now would be a good time to see why we want to do this, and what happens when
    you have a data typing issue. So, after the last line of code, add this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute `npx tsc example.ts` again; you should see an error telling you
    about the mistake and exactly where it is. This is the big thing TS is about:
    that error won’t occur when your site is live, and there isn’t any mystery about
    what the error is given the message `tsc` gives you. It’s a big benefit, and it’s
    why TS has rapidly become almost the de facto way modern website code is written.
    It’s getting more and more rare to see people writing “naked” JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: TS is a far more robust language than I’m showing here, but it would take far
    more pages than this to detail it all. As with the overarching theme of this book,
    I’m not trying to teach you every last detail of TS – I’m just introducing the
    concept and giving you some foundation of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about transpilers and TS, let’s look at a category of tools
    that can make use of both, namely bundlers.
  prefs: []
  type: TYPE_NORMAL
- en: Packing up and going – bundlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when web development was easy. You’d create some HTML, CSS,
    and JavaScript files, import the CSS and JavaScript files into your page, and
    you were good to go. After a while, though, things got much more complex. This
    JavaScript file depended on that one, and maybe parts of a given library you were
    using weren’t even needed, so why bother loading it on your page?
  prefs: []
  type: TYPE_NORMAL
- en: When your project outgrows one or two source files, matters get complicated
    very quickly if you want to keep some semblance of sanity while ensuring the optimal
    performance of your website.
  prefs: []
  type: TYPE_NORMAL
- en: Managing all that complexity is where something called a **bundler** comes into
    the picture.
  prefs: []
  type: TYPE_NORMAL
- en: The overall purpose of a bundler – which typically is just a command-line interface
    tool – is to streamline and optimize the process of turning your development code
    into a production-ready package. This typically involves combining multiple JavaScript
    files into a single JavaScript file that has all unnecessary code removed. This
    can also involve things such as combining CSS files, converting images into JavaScript
    structure, transpiling TS and JSX into JavaScript, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key reasons why bundlers are important to modern web development:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Handling dependencies*: Modern websites and apps often use a variety of libraries,
    frameworks, and toolkits. Bundlers manage these dependencies efficiently, ensuring
    that everything your app needs is included in your final build artifact and nothing
    unnecessary bloats the final product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Module bundling*: JavaScript has evolved to use modules, which is a way to
    better organize your code, but browsers have varying levels of support for module
    systems. Bundlers can take modules written in different formats and combine them
    into a single file, or a few files that work universally. We call these files
    **bundles**, but at the end of the day, they’re nothing but JavaScript files,
    though they can include things other than JavaScript in some cases – things such
    as images and CSS files can be converted into a form of JavaScript so that only
    a single file has to be requested when your website loads rather than multiple
    if these things were separate files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance optimization*: Bundlers minify and compress your code, which reduces
    load times for your users. This includes tree shaking (hold that thought!), splitting
    code into smaller chunks for faster loading, and optimizing asset loading, like
    images and stylesheets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Development efficiency*: Bundlers often come with features such as hot reloading,
    which allows you to see changes in real time without a full page reload. This
    speeds up development and debugging. They also typically include a built-in development
    server, which saves you from having to set up a web server (as simple as that
    can be, as you saw earlier).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transpilation support*: They also integrate with tools such as Babel to allow
    you to use more modern JavaScript features that aren’t yet supported in all browsers,
    ensuring compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Environment variables*: Bundlers allow you to use different settings or configurations,
    depending on whether you’re in development or production. In other words, just
    by setting a variable in, say, a configuration file, a bundler can know to perform
    other steps that you would only want to be done in your final, ready-for-the-real-world
    product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundlers work by building a *dependency graph*. This is a fancy way of saying
    that it scans all the source files for your project and determines what code depends
    on what other code. It then uses a technique called *tree shaking* to get rid
    of what isn’t needed. It’s a lot like when you go to cut down a Christmas tree
    and they put the tree in those machines that shake the tree so any loose branches
    and such fall out. With tree shaking, unused code can be removed safely.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this process is one or more JavaScript files that are highly optimized
    and contain only what your website needs to work. That means the files will load
    faster since there’s less to transfer over the network, and the browser can use
    them more efficiently since there’s less code for it to deal with. In addition,
    things such as CSS and even images can be embedded in these JavaScript files,
    which means that when your HTML page is loaded, fewer requests need to be made,
    further leading to improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few big names in bundlers today, including Webpack, Rollup, and
    Vite. They all have the same basic goal and work in similar ways, but they have
    their differences too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack is kind of the village elder at this point, being one of the first
    bundlers (though not the first: that honor goes to Browserify in 2011) and certainly
    the most successful and well-known at the time of writing. You configure it using
    JSON files, telling it about your project’s structure and defining what you want
    it to do when you bundle your project. It has a large number of plugins available
    to extend its capabilities. For example, `HtmlWebpackPlugin` can save you the
    effort of even writing an HTML file yourself, creating it for you on the fly.
    `ImageMinimizerWebpackPlugin` can compress images so that they are smaller in
    size, thereby making them load faster. There are around 30 official plugins and
    probably another dozen or so created by the Webpack community of users. It is
    a full-featured bundler that can do practically everything a bundler should.'
  prefs: []
  type: TYPE_NORMAL
- en: But it’s fallen out of favor a little bit due to the emergence of rivals such
    as Vite and Rollup. These two seek to outdo Webpack in terms of being simpler
    to configure, easier to understand overall (Webpack can sometimes be a challenge
    to follow mentally), and often faster and more lightweight. All of them provide
    a plugin ecosystem, basic module bundling, and the ability to act as a development
    web server for you as you code, and they can all do what’s called **code splitting**,
    which is dividing up your code into logical units that you can then only load
    when necessary rather than just loading everything upfront when it may not yet
    be needed (and may *never* be needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'While all three serve the same basic purpose and have a lot in common, they
    also have their differences (and to state the obvious: I’m talking in broad generalities
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comprehensiveness*: While Vite and Rollup provide a lot of the same functionality,
    Webpack tends to offer a bit more, owing to its age. Webpack is a full-featured
    bundler, handling a wide range of tasks beyond just bundling (such as asset management
    and loader transformations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configuration*: Webpack is known for being highly configurable, but this can
    be complex and overwhelming. Vite and Rollup tend to be simpler, sometimes greatly
    so. They do this largely by having intelligent defaults, which means you simply
    tend to have to write your own configuration less with these than with Webpack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build time*: Webpack will generally have the slowest build times compared
    to Vite and Rollup, especially the larger a project gets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Development experience*: Vite and Rollup support **hot module replacement**
    (**HMR**), better than Webpack, which means that as you develop with these tools
    you can have a better experience when your code changes since reloading things
    will largely be handled automatically. While Webpack can do some of this too,
    Vite and Rollup tend to be better at it, especially with more modern code bases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Output efficiency*: Vite, and especially Rollup, tend to do a better job at
    optimizing output bundles than Webpack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overhead*: Vite and Rollup don’t include as many built-in features as Webpack,
    leading to less overhead but potentially more manual setup for complex tasks.
    They are very much 80/20 tools, meaning they’ll do 80% of the work you need them
    to do very easily, but the last 20% can be rather difficult (whereas Webpack tends
    to be more difficult – relatively speaking – all the time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While bundlers are very common in modern web development, they are a slightly
    more advanced topic because they are always optional. First, you may not need
    what they provide at all. Second, even if you do, you could simply write things
    such as shell scripts, batch files, or simple Python or Node scripts to do what
    they do in a way more specific to your needs. However, they do provide a lot of
    features and capabilities that modern web developers need, which is why they have
    become so popular over the years.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, bundlers are a good thing because they handle the complexities of
    modern web development, optimize performance, and enhance the development experience,
    making it easier to build sophisticated and efficient websites and web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mystery of the squares is falling away quickly now, isn’t it?! *Figure
    6**.4* shows the updated web developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: The roadmap, with a few more boxes filled in](img/B18315_06_04_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The roadmap, with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: This time around, you’ve uncovered the **Frameworks**, **TypeScript**, and **Bundlers**
    boxes. There’s not many left now, is there? Woo-hoo!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the tools that, in general terms, make
    up what we think of as *modern* web development. This includes libraries such
    as React and Vue (and also jQuery, though that one isn’t considered modern anymore),
    frameworks such as Angular, and meta frameworks such as Next. We looked at some
    CSS tools too, Bootstrap and Tailwind in particular. All of these were shown to
    provide a lot of benefits in terms of writing as little code as possible to get
    the job done, improving delivery velocity and robustness of the end product.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about TS and Babel, and you learned how data typing is a benefit
    in modern development, but at the cost of the need to transpile.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we talked about some modern build tools such as packers and bundlers,
    and how they help you deploy just the code you need and remove a lot of the tedium
    of building your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll jump back to the server side of things and talk about
    some other technologies besides Node that you might choose to build your server-side
    code with. This will include PHP, Python (a bit more), Java, and its popular Spring
    Boot framework, and .NET. We’ll also talk about some general topics that are very
    important on the server side, including databases and something called REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Grab a quick snack and a drink (alcoholic or non-alcoholic is entirely up to
    you!) and come right back here for the next exciting chapter!
  prefs: []
  type: TYPE_NORMAL
