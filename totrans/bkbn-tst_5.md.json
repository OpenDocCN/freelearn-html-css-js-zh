["```js\nvar obj = {\n  multiply: function (a, b) { return a * b; },\n  error: function (msg) { throw new Error(msg); }\n};\n```", "```js\nit(\"stubs multiply\", function () {\n  // Stub with a hard-coded return value.\n  sinon.stub(obj, \"multiply\").returns(5);\n  expect(obj.multiply(1, 2)).to.equal(5);\n  obj.multiply.restore();\n\n  // Stub with a function.\n  sinon.stub(obj, \"multiply\", function (a, b) {\n    return a + b;\n  });\n  expect(obj.multiply(1, 2)).to.equal(3);\n  obj.multiply.restore();\n});\n```", "```js\nit(\"stubs error\", sinon.test(function () {\n  this.stub(obj, \"error\");\n  expect(obj.error).to.not.throw();\n}));\n```", "```js\n    it(\"stubs with yields\", function (done) {\n      var obj = {\n        async: function (callback) { callback(\"a\", \"b\"); }\n      };\n\n      sinon.stub(obj, \"async\").yields(1, 2);\n\n      // Verify stub calls with (1, 2), *not* (\"a\", \"b\").\n      obj.async(function (first, second) {\n        expect(first).to.equal(1);\n        expect(second).to.equal(2);\n\n        obj.async.restore();\n        done();\n      });\n    });\n    ```", "```js\n// Our (now very familiar) object under test.\nvar obj = {\n  multiply: function (a, b) { return a * b; },\n  error: function (msg) { throw new Error(msg); }\n};\n\nit(\"mocks multiply\", function () {\n  // Create the mock.\n  var mock = sinon.mock(obj);\n\n  // The multiply method is expected to be called:\n  mock.expects(\"multiply\")\n    .atLeast(2)    // 2+ times,\n    .atMost(4)     // no more than 4 times, and\n    .withArgs(2);  // 2 was first arg on *all* calls.\n\n  // Make 3 calls to `multiply()`.\n  obj.multiply(2, 1);\n  obj.multiply(2, 2);\n  obj.multiply(2, 3);\n\n  // Verify **all** of the previous expectations.\n  mock.verify();\n\n  // Restore the object.\n  mock.restore();\n});\n```", "```js\nvar MyView = Backbone.View.extend({\n\n  initialize: function () {\n    this.on(\"wrapped\", function () { this.foo(); });\n    this.on(\"unwrapped\", this.foo);\n  },\n\n  foo: function () {\n    return \"I'm real\";\n  }\n\n});\n```", "```js\nit(\"stubs after initialization\", sinon.test(function () {\n  var myView = new MyView();\n\n  // Stub prototype **after** initialization.\n  // Equivalent to:\n  // this.stub(myView, \"foo\").returns(\"I'm fake\");\n  this.stub(MyView.prototype, \"foo\").returns(\"I'm fake\");\n\n  // The wrapped version calls the **stub**.\n  myView.foo.reset();\n  myView.trigger(\"wrapped\");\n  expect(myView.foo)\n    .to.be.calledOnce.and\n    .to.have.returned(\"I'm fake\");\n\n  // However, the unwrapped version calls the **real** function.\n  myView.foo.reset();\n  myView.trigger(\"unwrapped\");\n  expect(myView.foo).to.not.be.called;\n}));\n```", "```js\nit(\"stubs before initialization\", sinon.test(function () {\n  // Stub prototype **before** initialization.\n  this.stub(MyView.prototype, \"foo\").returns(\"I'm fake\");\n\n  var myView = new MyView();\n\n  // Now, both versions are correctly stubbed.\n  myView.foo.reset();\n  myView.trigger(\"wrapped\");\n  expect(myView.foo)\n    .to.be.calledOnce.and\n    .to.have.returned(\"I'm fake\");\n\n  myView.foo.reset();\n  myView.trigger(\"unwrapped\");\n  expect(myView.foo)\n    .to.be.calledOnce.and\n    .to.have.returned(\"I'm fake\");\n}));\n```", "```js\n    events: {\n      \"click #id\": \"foo\"\n    }\n    ```", "```js\nApp.Templates[\"template-notes-item\"] =\n  \"<td class=\\\"note-name\\\">\" +\n  \"  <div class=\\\"note-title note-view\\\"><%= title %></div>\" +\n  \"</td>\" +\n  \"<td class=\\\"note-action\\\">\" +\n  \"  <div class=\\\"btn-group pull-right\\\">\" +\n  \"    <button class=\\\"btn note-edit\\\">\" +\n  \"      <i class=\\\"icon-pencil\\\"></i>\" +\n  \"    </button>\" +\n  \"    <button class=\\\"btn note-delete\\\">\" +\n  \"      <i class=\\\"icon-trash\\\"></i>\" +\n  \"    </button>\" +\n  \"  </div>\" +\n  \"</td>\";\n```", "```js\nApp.Views.NotesItem = Backbone.View.extend({\n\n  id: function () { return this.model.id; },\n\n  tagName: \"tr\",\n\n  className: \"notes-item\",\n\n  template: _.template(App.Templates[\"template-notes-item\"]),\n```", "```js\n  events: {\n    \"click .note-view\":   function () { this.viewNote(); },\n    \"click .note-edit\":   function () { this.editNote(); },\n    \"click .note-delete\": function () { this.deleteNote(); }\n  },\n```", "```js\n  initialize: function (attrs, opts) {\n    opts || (opts = {});\n    this.router = opts.router || app.router;\n\n    this.listenTo(this.model, {\n      \"change\":   function () { this.render(); },\n      \"destroy\":  function () { this.remove(); }\n    });\n  },\n\n  render: function () {\n    this.$el.html(this.template(this.model.toJSON()));\n    return this;\n  },\n```", "```js\n  viewNote: function () {\n    var loc = [\"note\", this.model.id, \"view\"].join(\"/\");\n    this.router.navigate(loc, { trigger: true });\n  },\n\n  editNote: function () {\n    var loc = [\"note\", this.model.id, \"edit\"].join(\"/\");\n    this.router.navigate(loc, { trigger: true });\n  },\n\n  deleteNote: function () {\n    // Destroying model triggers view cleanup.\n    this.model.destroy();\n  }\n});\n```", "```js\ndescribe(\"App.Views.NotesItem\", function () {\n\n  before(function () {\n    this.navigate = sinon.stub();\n    this.view = new App.Views.NotesItem({\n      model: new App.Models.Note({ id: \"0\", title: \"title\" })\n    }, {\n      router: { navigate: this.navigate }\n    });\n  });\n\n  afterEach(function () {\n    this.navigate.reset();\n  });\n\n  after(function () {\n    this.view.remove();\n  });\n```", "```js\n  describe(\"remove\", function () {\n    it(\"is removed on model destroy\", sinon.test(function () {\n      // Empty stub for view removal to prevent side effects.\n      this.stub(this.view, \"remove\");\n      this.view.model.trigger(\"destroy\");\n      expect(this.view.remove).to.be.calledOnce;\n    }));\n  });\n```", "```js\n  describe(\"render\", function () {\n    // One way to verify is with a stub.\n    it(\"renders on model change w/ stub\", sinon.test(function () {\n      this.stub(this.view);\n      this.view.model.trigger(\"change\");\n      expect(this.view.render).to.have.been.calledOnce;\n    }));\n```", "```js\n    // Here is another way to do the same check with a mock.\n    it(\"renders on model change w/ mock\", sinon.test(function () {\n      var exp = this.mock(this.view).expects(\"render\").once();\n      this.view.model.trigger(\"change\");\n      exp.verify();\n    }));\n  });\n```", "```js\n  describe(\"actions\", function () {\n    it(\"views on click\", function () {\n      this.view.$(\".note-view\").click();\n\n      expect(this.navigate)\n        .to.be.calledOnce.and\n        .to.be.calledWith(\"note/0/view\");\n    });\n\n    it(\"edits on click\", function () {\n      this.view.$(\".note-edit\").click();\n\n      expect(this.navigate)\n        .to.be.calledOnce.and\n        .to.be.calledWith(\"note/0/edit\");\n    });\n```", "```js\n    it(\"deletes on click\", sinon.test(function () {\n      // Empty stub for model destroy to prevent side effects.\n      this.stub(this.view.model, \"destroy\");\n      this.view.$(\".note-delete\").click();\n\n      expect(this.view.model.destroy).to.be.calledOnce;\n    }));\n  });\n});\n```", "```js\nApp.Routers.Router = Backbone.Router.extend({\n\n  routes: {\n    \"\": \"notes\",\n    \"note/:id/:action\": \"note\",\n  },\n\n  // Show notes list.\n  notes: function () {\n    // ... omitted ...\n  },\n\n  // Common single note edit/view.\n  note: function (noteId, action) {\n    // ... omitted ...\n  }\n\n});\n```", "```js\ndescribe(\"App.Routers.Router\", function () {\n\n  // Default option: Trigger and replace history.\n  var opts = { trigger: true, replace: true };\n\n  beforeEach(function () {\n    // Stub route methods.\n    sinon.stub(App.Routers.Router.prototype, \"note\");\n    sinon.stub(App.Routers.Router.prototype, \"notes\");\n\n    // Create router with stubs and manual fakes.\n    this.router = new App.Routers.Router();\n\n    // Start history to enable routes to fire.\n    Backbone.history.start();\n\n    // Spy on all route events.\n    this.routerSpy = sinon.spy();\n    this.router.on(\"route\", this.routerSpy);\n  });\n```", "```js\n  afterEach(function () {\n    Backbone.history.stop();\n\n    App.Routers.Router.prototype.note.restore();\n    App.Routers.Router.prototype.notes.restore();\n  });\n```", "```js\n  it(\"can route to note\", function () {\n    this.router.navigate(\"note/1/edit\", opts);\n\n    // Check router method.\n    expect(App.Routers.Router.prototype.note)\n      .to.have.been.calledOnce.and\n      .to.have.been.calledWithExactly(\"1\", \"edit\");\n\n    // Check route event.\n    expect(this.routerSpy)\n      .to.have.been.calledOnce.and\n      .to.have.been.calledWith(\"note\", [\"1\", \"edit\"]);\n  });\n```", "```js\n  it(\"can route around\", function () {\n    // Bounce between routes.\n    this.router.navigate(\"\", opts);\n    this.router.navigate(\"note/1/edit\", opts);\n    this.router.navigate(\"\", opts);\n\n    // Check router method.\n    expect(App.Routers.Router.prototype.notes)\n      .to.have.been.calledTwice.and\n      .to.have.been.calledWithExactly();\n\n    // Check route event.\n    expect(this.routerSpy)\n      .to.have.been.calledThrice.and\n      .to.have.been.calledWith(\"notes\");\n  });\n\n});\n```", "```js\n<head>\n  <!-- ... snipped ... -->\n\n  <!-- JavaScript Application Libraries -->\n  <script src=\"img/namespace.js\"></script>\n  <script src=\"img/config.js\"></script>\n  <script>\n    // Test overrides (before any app components).\n    App.Config = _.extend(App.Config, {\n      storeName: \"notes-test\" // localStorage for tests.\n    });\n  </script>\n  <script src=\"img/note.js\"></script>\n  <script src=\"img/notes.js\"></script>\n  <script src=\"img/templates.js\"></script>\n  <script src=\"img/note-nav.js\"></script>\n  <script src=\"img/note-view.js\"></script>\n  <script src=\"img/note.js\"></script>\n  <script src=\"img/notes-item.js\"></script>\n\n  <!-- The shortened, teaching router for Chapter 05 -->\n  <script src=\"img/router.js\"></script>\n\n  <!-- ... snipped ... -->\n\n  <!-- Tests. -->\n  <script src=\"img/notes-item.spec.js\"></script>\n  <script src=\"img/router.spec.js\"></script>\n</head>\n```", "```js\nApp.Collections.Notes = Backbone.Collection.extend({\n\n  model: App.Models.Note,\n\n  url: \"/api/notes\"\n\n});\n```", "```js\ndescribe(\"App.Collections.Notes\", function () {\n\n  beforeEach(function () {\n    this.server = sinon.fakeServer.create();\n    this.server.autoRespond = true;\n    this.notes = new App.Collections.Notes();\n  });\n\n  afterEach(function () {\n    this.server.restore();\n  });\n```", "```js\n  describe(\"retrieval\", function () {\n\n    it(\"has a single note\", function (done) {\n      var notes = this.notes, note;\n\n      // Return a single model on GET.\n      this.server.respondWith(\"GET\", \"/api/notes\", [\n        200,\n        { \"Content-Type\": \"application/json\" },\n        JSON.stringify([{\n          id: 1,\n          title: \"Test note #1\",\n          text: \"A pre-existing note from beforeEach.\"\n        }])\n\n      ]);\n\n      // After fetch.\n      notes.once(\"reset\", function () {\n        expect(notes).to.have.length(1);\n\n        // Check model attributes.\n        note = notes.at(0);\n        expect(note).to.be.ok;\n        expect(note.get(\"title\")).to.contain(\"#1\");\n        expect(note.get(\"text\")).to.contain(\"pre-existing\");\n\n        done();\n      });\n\n      notes.fetch({ reset: true });\n    });\n\n  });\n```"]