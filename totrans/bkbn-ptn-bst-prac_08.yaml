- en: Chapter 8. Unit Test, Stub, Spy, and Mock Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Majority of developers believe that testing is essential, but in reality only
    a few of them actually go for test-driven development. Testing falls under one
    of the best practices of the JavaScript development process. Hence, we decided
    to include a chapter on how to unit test Backbone-based applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of popular testing libraries, such as `QUnit`, `Jasmine`, `Mocha`,
    and `SinonJS`, are available to unit test JavaScript applications. In this chapter,
    we are going to show you how to test with `QUnit`, the simplest yet robust testing
    platform, which is pretty easy to learn as well. In the latter part, we will look
    into `SinonJS` to learn test spies, stubs, and mocks. Together, `QUnit` and `SinonJS`
    create a strong tool to test every part of your app. The main points to be discussed
    in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Why unit testing is important**: Testing is a habit. Continuing this along
    with development may take some extra time initially, but it is essential especially
    while working in a team or developing complex applications.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing with QUnit**: We will look into the basic aspects of `QUnit`, and
    we will see how to use them for the `Backbone.js` components.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using spies, stubs, and mocks with SinonJS**: Spying on the behavior of JavaScript
    functions and controlling their behavior whenever needed from a test environment
    is absolutely necessary for unit testing. We will look into this concept briefly
    with the `SinonJS` test framework.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why unit testing is important
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you already know the benefits of testing and follow the best practices while
    developing your JavaScript apps, you can skip this section. If you still wonder
    why you should actually test your application while you are already writing clean
    and maintainable code, the following are a few reasons to consider:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Testing is never a waste of time. You do not need to run your code repeatedly
    to see whether it works or not. You can run all the test cases at once to see
    whether everything is functioning as expected. Testing gives you the confidence
    that your code is working fine.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are really fast to create and fast to run too.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update your code without worry. Your test will tell you whether the function
    is working as it is expected to or not. You will find this very helpful, especially
    when you work in a team.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you start writing unit tests for your code, you will soon find that you
    are writing more modular, flexible, and testable code than you used to.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Test Driven Development** (**TDD**), you write failing test cases first
    and then develop the code. In that case, a passing test case ensures that your
    developed code works fine without any issues.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is fun. It's not very easy, sure, and not something that you can master
    in a day. It is not very difficult either—lots of developers are doing it and
    you can do it too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Testing with QUnit
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QUnit` ([http://qunitjs.com](http://qunitjs.com)), a lightweight unit testing
    framework maintained by the jQuery team, which is quite easy to work with compared
    to other frameworks. Discussing `QUnit` in complete detail is beyond the scope
    of this book, but we will learn about the simple features of it and explore how
    we can use it with our Backbone components.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions are the most essential elements of any unit test framework. You
    need to compare your actual implementation values to the results that the test
    produces. Assertions are the methods that serve this comparison functionality.
    `QUnit` has only eight assertions; we are going to use some of them in the next
    section. Let''s discuss a few of them here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`ok (state, message)`: This passes if the first argument is true'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal (actual, expected, message)`: This returns true if `actual` and `expected`
    are equal'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deepEqual (actual, expected, message)`: This is a deep recursive-comparison
    assertion, working on primitive types, arrays, objects, regular expressions, dates,
    and functions'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictEqual (actual, expected, message)`: This is a strict type and a value
    comparison assertion'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throws (block, actual, message)`: This is an assertion to test whether a callback
    throws an exception when run'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few more asserts: `notEqual()`, `notDeepEqual()`, and `notStrictEqual()`.
    The functionalities of these are clearly the opposite of their counterparts. In
    addition to these, `QUnit` has a number of test methods that are used to initiate
    the tests. They are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncTest()`: This adds an asynchronous test to run'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect()`: This specifies how many assertions are expected to run within a
    test'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module()`: This consists of group-related tests under a single label'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test()`: This adds a test to run'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up `QUnit` is fairly straightforward. First we will create a `test`
    directory and put it inside our project directory. This `test` folder is going
    to hold all our test files of the project. Then, inside this folder, we will create
    an HTML file, which will show all the test results in our browser. In general,
    `QUnit` comes up with `qunit.js` and a `qunit.css` files. You need to just include
    the following code snippet as given in the QUnit website ([http://qunitjs.com](http://qunitjs.com))
    in your HTML file and you are done with the QUnit setup:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `tests.js` file will hold all your test cases. You can have multiple test
    files depending on your requirements. If you found that this section is a little
    complex and it is difficult to understand all the definitions of assertion methods,
    do not worry. In the next section, we will show you a simple `QUnit` test case
    with few of these assertions, and you will see how easy it is to get started with
    `QUnit`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Performing a basic test case
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned the basic and important API methods of `QUnit`. Now, let''s use
    few of them to create a simple test case. We will write a method that checks whether
    a number is prime or not. Then we will make a couple of calls to the `isPrime()`
    method from our test and analyze the results as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 `QUnit` 的基本和重要的 API 方法。现在，让我们使用其中的一些方法来创建一个简单的测试用例。我们将编写一个检查一个数字是否为素数的方法。然后我们将从我们的测试中对
    `isPrime()` 方法进行几次调用，并如下分析结果：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A rather simple example is shared in the previous code snippet to show how easy
    it is to get started with `QUnit`. We use the `expect()` method at first to assure
    that we will be doing two assertions in this test case. If we do more than two
    assertions, then this test will fail. Now, those two asserts, namely `ok()` and
    `equal()`, call the `isPrime()` method with two different inputs and check whether
    those input values are prime numbers or not. When you run this test, you can see
    both the tests to pass through.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中共享了一个相当简单的示例，以展示如何轻松地开始使用 `QUnit`。我们首先使用 `expect()` 方法来确保在这个测试用例中我们将进行两个断言。如果我们进行超过两个断言，那么这个测试将失败。现在，这两个断言，即
    `ok()` 和 `equal()`，使用两个不同的输入调用 `isPrime()` 方法，并检查这些输入值是否为素数。当你运行这个测试时，你可以看到两个测试都通过了。
- en: Understanding the QUnit module (), setup (), and teardown () methods
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 QUnit 的模块（module）、setup 和 teardown 方法
- en: 'To organize multiple test cases, we need something that can provide a block
    structure and hold multiple tests together. The `module()` method allows us to
    group the test cases together. Furthermore, it introduces the two methods, `setup()`
    and `teardown()`, that run before and after each test case, as shown in the following
    code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织多个测试用例，我们需要一种能够提供块结构并将多个测试组合在一起的东西。`module()` 方法允许我们将测试用例分组在一起。此外，它引入了两个方法，`setup()`
    和 `teardown()`，它们在每个测试用例前后运行，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `setup()` method is quite useful when you need to instantiate an object
    (such as a view or a collection) that will be used in multiple tests. The `teardown()`
    method, on the other hand, is mostly used to clean up the resources that you added
    as global variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要实例化一个将在多个测试中使用的对象（例如视图或集合）时，`setup()` 方法非常有用。另一方面，`teardown()` 方法主要用于清理你添加为全局变量的资源。
- en: Testing Backbone.js components with QUnit
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 QUnit 测试 Backbone.js 组件
- en: 'Now as we understand the basics of `QUnit`, let''s try it with some Backbone
    components. We will first start with a Backbone model and we will create a simple
    `User` model, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `QUnit` 的基础知识，让我们尝试使用一些 Backbone 组件。我们首先从 Backbone 模型开始，我们将创建一个简单的
    `User` 模型，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we tested the Backbone model with one of its default values and another
    attribute that we changed in the `setup()` method, but intentionally tested it
    with another value. So, this test should fail for one assert case. The following
    screenshot shows how it will look in a browser:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Backbone 模型的一个默认值和我们在 `setup()` 方法中更改的另一个属性进行了测试，但故意使用另一个值进行测试。因此，这个测试应该因为一个断言案例而失败。以下截图显示了它在浏览器中的样子：
- en: '![Testing Backbone.js components with QUnit](img/3576_08_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QUnit 测试 Backbone.js 组件](img/3576_08_01.jpg)'
- en: Using test spies, stubs, and mocks with SinonJS
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SinonJS 的测试间谍、存根和模拟
- en: We use unit testing to test one component of an application. That component
    can be a function, an object, a variable, or any outcome which is not known yet,
    and your unit test wants to make sure whether that particular component is working
    fine or not. Often, besides testing separate components, you may find testing
    the behavior of your methods is of the same importance. For example, how many
    times a method is called, what it returns, whether it has thrown any exception,
    what arguments it is called with, and so on. To perform these types of behavioral
    testing, we use test spies, stubs, and mocks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单元测试来测试应用程序的一个组件。这个组件可以是一个函数、一个对象、一个变量，或者任何尚未知的任何结果，而你的单元测试想要确保该特定组件是否运行良好。通常，除了测试单独的组件外，你可能还会发现测试方法的行为同样重要。例如，一个方法被调用的次数、它返回的内容、是否抛出了任何异常、它被调用的参数等等。为了执行这些类型的测试，我们使用测试间谍、存根和模拟。
- en: 'There are few testing libraries which support test spies, stubs, and mocks.
    However, we found `SinonJS` quite easy to work with and robust as well. `SinonJS`
    works seamlessly with `QUnit` and you can use it with or without `QUnit` too.
    The definition of `SinonJS`, as given on their website, is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Standalone test spies, stubs and mocks for JavaScript. No dependencies, works
    with any unit testing framework.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Testing with spies
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to know what a spy is. By definition, as given on the `SinonJS`
    website, a spy is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A test spy is a function that records arguments, return value, the value of
    this and exception thrown (if any) for all its calls. A test spy can be an anonymous
    function or it can wrap an existing function.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So your next question should be why a spy should be used. We use test spies
    to test the behavior of callback and other methods, and to understand how they
    work. You will find out the answer in more detail once you look into some API
    methods associated with spies:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`called()`: This returns true if the spy was called at least once'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calledOnce()`: This returns true if the spy was called exactly once'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returned()`: This returns true if the spy returned the provided value at least
    once'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are few of the supported methods of the spy API. Hopefully, now you can
    understand why a spy is used—it allows you to test multiple characteristics of
    a function, to know whether it gets called only once, or to check what value it
    returns. A spy allows you every possibility to test the complete flow of a function.
    Now let''s see how to use a spy from the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We used the same `User` model and added a `getNameAsArray()` method to it. We
    spied on this method to test whether it gets called only once and returns an array.
    The previous test case passes fine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can use spies for any or all of the following cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Check for the invocation of a callback
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate whether callbacks are executed with certain arguments
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate if internal functions provide the correct return value
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate a certain simple calling behavior
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with stubs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A test stub, on the other hand, extends from a spy and adds some extra functionality
    to it. It is a function with preprogramed behavior and supports the complete spy
    API. It is used to replace (or fake) the behavior of an existing method with something.
    It is quite useful when you want to prevent a specific method from being called
    directly, or force a method to throw an error in order to test error handling.
    Like spies, stubs can either be anonymous, or they can wrap the existing functions.
    When wrapping an existing function with a stub, the original function is not called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'An anonymous stub can be defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a wrapper to a method of an object, it can be defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here the function `object.method` is replaced with an anonymous stub function.
    You can also add one more function as the third parameter to the `stub()` function,
    which will work as a spy on `object.method` and will replace the original method
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数`object.method`被替换为一个匿名存根函数。你还可以将一个额外的函数作为`stub()`函数的第三个参数添加，它将作为`object.method`的间谍，并替换原始方法如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To understand how a spy works with a real example, we can use the same `User`
    model that we previously used. This is shown in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过一个真实示例了解间谍是如何工作的，我们可以使用之前使用的相同的`User`模型。如下代码片段所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we stub the `getNameAsArray()` method of the `User` model and return an
    empty array. So while you call the `getNameAsArray()` method, *not the method
    but the stub will get called*. We made sure that the stub returns an empty array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存根了`User`模型的`getNameAsArray()`方法，并返回一个空数组。所以当你调用`getNameAsArray()`方法时，*不是方法而是存根将被调用*。我们确保存根返回一个空数组。
- en: Now the test is as simple as the one we did earlier. We just call the `getNameAsArray()`
    method on the `User` instance and check the length of the returned value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的测试就像我们之前做的那样简单。我们只需在`User`实例上调用`getNameAsArray()`方法，并检查返回值的长度。
- en: Testing with mocks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟进行测试
- en: Mocks (and mock expectations) are fake methods (like spies) with pre-programmed
    behavior (like stubs) as well as pre-programmed expectations. A mock will fail
    your test if it is not used as expected.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模拟（以及模拟期望）是具有预编程行为（如存根）的假方法（如间谍），以及预编程的期望。如果模拟没有被按预期使用，它将使你的测试失败。
- en: This is the definition of mock as given in the `SinonJS` website ([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks)).
    Mocks are quite similar to stubs, but they come with built-in expectations. They
    implement both the spy and stub APIs. With a mock, you define all the expectations
    that should happen in your test. When all those things are done, you assert whether
    those things happened exactly the way they were planned. So you define the expectations
    and if they aren't met, the test fails.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SinonJS`网站上给出的模拟定义([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks))。模拟与存根非常相似，但它们自带内置的期望。它们实现了间谍和存根API。使用模拟，你可以定义测试中应该发生的所有期望。当所有这些事情都完成时，你断言这些事情是否按照计划发生。因此，你定义期望，如果它们没有满足，测试就会失败。
- en: 'Now, how do we use a mock? We mock an object, set expectations on its methods,
    and apply modifiers on these expectations. Then we verify whether the test passes
    all the expectations or not. To understand it better, let''s explore a simple
    example with mock, as shown in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用模拟？我们模拟一个对象，对其方法设置期望，并对这些期望应用修饰符。然后我们验证测试是否通过了所有期望。为了更好地理解，让我们通过以下代码片段探索一个简单的模拟示例：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the same `User` model here and create a mock with a `User` instance.
    Then we set the expectation on the mock to see whether the `getNameAsArray()`
    method is called only once on that `User` instance. All these expectations are
    set beforehand and we verify them all together at the end.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用相同的`User`模型，并创建一个带有`User`实例的模拟。然后我们在模拟上设置期望，以查看`getNameAsArray()`方法是否只在该`User`实例上调用一次。所有这些期望都是事先设置的，并在最后一起验证。
- en: Difference between mocks and stubs
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟与存根的区别
- en: 'Now, because stubs and mocks are similar in functionality, you may wonder why
    and when you should use a mock instead of a stub. As given by the website, you
    would use a mock only when you want to provide both alternate functionality and
    an expectation in your test. The main difference you can see is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为存根和模拟在功能上相似，你可能会想知道为什么和何时你应该使用模拟而不是存根。根据网站上的说明，你只有在想要在测试中提供替代功能和一个期望时才使用模拟。你可以看到的主要区别如下：
- en: Mock objects are used to define expectations, that is, in a particular scenario,
    we expect the `Foo()` method to be called with a set of parameters. Mock records
    and verifies such expectations that whether the `foo()` method actually got called
    with those parameters or not.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象用于定义期望，即在特定场景中，我们期望`Foo()`方法使用一组参数被调用。模拟记录并验证这样的期望，即`foo()`方法是否实际上使用这些参数被调用。
- en: Stubs, on the other hand, have a different purpose—they do not record or verify
    expectations, but rather allow us to "replace" the behavior and the state of the
    "fake" object in order to utilize a test scenario.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，存根有不同的目的——它们不记录或验证期望，而是允许我们“替换”假对象的行为和状态，以便利用测试场景。
- en: 'To test the life cycle with stubs, proceed with the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用存根来测试生命周期，请按照以下步骤进行：
- en: 'Set up data: Prepare the object that is being tested and its stubs collaborators.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据：准备待测试的对象及其存根协作者。
- en: 'Exercise: Test the functionality.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习：测试功能。
- en: 'Verify state: Use asserts to check the object''s state.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证状态：使用断言来检查对象的状态。
- en: 'Teardown: Clean up the resources.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理：清理资源。
- en: 'To test the life cycle with mocks, proceed with the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模拟来测试生命周期，请按照以下步骤进行：
- en: 'Set up data: Prepare object that is being tested.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据：准备待测试的对象。
- en: 'Set up expectations: Prepare expectations in a mock that is being used by the
    primary object.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置期望：在主对象使用的模拟中准备期望。
- en: 'Exercise: Test the functionality.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习：测试功能。
- en: 'Verify expectations: Verify that correct methods have been invoked in the mock.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证期望：验证在模拟中是否调用了正确的方法。
- en: 'Verify state: Use asserts to check the object''s state.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证状态：使用断言来检查对象的状态。
- en: 'Teardown: Clean up the resources.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理：清理资源。
- en: As you can see, there are pre and post states for a mock. We set the expectation
    before the test and verify it afterwards. Anyway, the purpose of both stub and
    mock is to eliminate testing all the dependencies of a class or function so that
    your tests are more focused and simple in what they are trying to prove.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模拟有预状态和后状态。我们在测试之前设置期望，并在之后验证它。无论如何，存根和模拟的目的是消除测试一个类或函数的所有依赖项，这样你的测试就可以更加专注于它们试图证明的内容。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have included a number of books and tutorials related to `QUnit` and `SinonJS`
    in the [Appendix A](apa.html "Appendix A. Books, Tutorials, and References"),
    *Books, Tutorials, and References*. You can follow them to get a more detailed
    idea about these two technologies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[附录A](apa.html "附录 A. 书籍、教程和参考")中包含了与`QUnit`和`SinonJS`相关的书籍和教程，*书籍、教程和参考*。你可以参考它们来获取这两个技术的更详细的信息。
- en: A few testing concepts were described in this chapter. You got an idea about
    the power of `QUnit` and `SinonJS`, and how to use them extensively to unit test
    your JavaScript application. Though that barely scratches the surface, we never
    intended to cover everything about testing in this book either. We just tried
    to make you aware of the fact that testing is an absolutely important part of
    the application development process, and you should make it a habit to write test
    cases whenever you develop. It will make your code more structured, flexible,
    and easier to use for your teammates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一些测试概念。你对`QUnit`和`SinonJS`的力量以及如何广泛地使用它们进行单元测试JavaScript应用程序有了了解。尽管这仅仅触及了表面，但我们也不打算在这本书中涵盖测试的所有内容。我们只是试图让你意识到测试是应用程序开发过程中的一个绝对重要的部分，你应该养成在开发时编写测试用例的习惯。这将使你的代码更加结构化、灵活，并且更容易让你的队友使用。
