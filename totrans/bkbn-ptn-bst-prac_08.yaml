- en: Chapter 8. Unit Test, Stub, Spy, and Mock Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Majority of developers believe that testing is essential, but in reality only
    a few of them actually go for test-driven development. Testing falls under one
    of the best practices of the JavaScript development process. Hence, we decided
    to include a chapter on how to unit test Backbone-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of popular testing libraries, such as `QUnit`, `Jasmine`, `Mocha`,
    and `SinonJS`, are available to unit test JavaScript applications. In this chapter,
    we are going to show you how to test with `QUnit`, the simplest yet robust testing
    platform, which is pretty easy to learn as well. In the latter part, we will look
    into `SinonJS` to learn test spies, stubs, and mocks. Together, `QUnit` and `SinonJS`
    create a strong tool to test every part of your app. The main points to be discussed
    in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why unit testing is important**: Testing is a habit. Continuing this along
    with development may take some extra time initially, but it is essential especially
    while working in a team or developing complex applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing with QUnit**: We will look into the basic aspects of `QUnit`, and
    we will see how to use them for the `Backbone.js` components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using spies, stubs, and mocks with SinonJS**: Spying on the behavior of JavaScript
    functions and controlling their behavior whenever needed from a test environment
    is absolutely necessary for unit testing. We will look into this concept briefly
    with the `SinonJS` test framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why unit testing is important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you already know the benefits of testing and follow the best practices while
    developing your JavaScript apps, you can skip this section. If you still wonder
    why you should actually test your application while you are already writing clean
    and maintainable code, the following are a few reasons to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing is never a waste of time. You do not need to run your code repeatedly
    to see whether it works or not. You can run all the test cases at once to see
    whether everything is functioning as expected. Testing gives you the confidence
    that your code is working fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are really fast to create and fast to run too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update your code without worry. Your test will tell you whether the function
    is working as it is expected to or not. You will find this very helpful, especially
    when you work in a team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you start writing unit tests for your code, you will soon find that you
    are writing more modular, flexible, and testable code than you used to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Test Driven Development** (**TDD**), you write failing test cases first
    and then develop the code. In that case, a passing test case ensures that your
    developed code works fine without any issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is fun. It's not very easy, sure, and not something that you can master
    in a day. It is not very difficult either—lots of developers are doing it and
    you can do it too.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with QUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QUnit` ([http://qunitjs.com](http://qunitjs.com)), a lightweight unit testing
    framework maintained by the jQuery team, which is quite easy to work with compared
    to other frameworks. Discussing `QUnit` in complete detail is beyond the scope
    of this book, but we will learn about the simple features of it and explore how
    we can use it with our Backbone components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions are the most essential elements of any unit test framework. You
    need to compare your actual implementation values to the results that the test
    produces. Assertions are the methods that serve this comparison functionality.
    `QUnit` has only eight assertions; we are going to use some of them in the next
    section. Let''s discuss a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ok (state, message)`: This passes if the first argument is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal (actual, expected, message)`: This returns true if `actual` and `expected`
    are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deepEqual (actual, expected, message)`: This is a deep recursive-comparison
    assertion, working on primitive types, arrays, objects, regular expressions, dates,
    and functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictEqual (actual, expected, message)`: This is a strict type and a value
    comparison assertion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throws (block, actual, message)`: This is an assertion to test whether a callback
    throws an exception when run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few more asserts: `notEqual()`, `notDeepEqual()`, and `notStrictEqual()`.
    The functionalities of these are clearly the opposite of their counterparts. In
    addition to these, `QUnit` has a number of test methods that are used to initiate
    the tests. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncTest()`: This adds an asynchronous test to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect()`: This specifies how many assertions are expected to run within a
    test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module()`: This consists of group-related tests under a single label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test()`: This adds a test to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up `QUnit` is fairly straightforward. First we will create a `test`
    directory and put it inside our project directory. This `test` folder is going
    to hold all our test files of the project. Then, inside this folder, we will create
    an HTML file, which will show all the test results in our browser. In general,
    `QUnit` comes up with `qunit.js` and a `qunit.css` files. You need to just include
    the following code snippet as given in the QUnit website ([http://qunitjs.com](http://qunitjs.com))
    in your HTML file and you are done with the QUnit setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `tests.js` file will hold all your test cases. You can have multiple test
    files depending on your requirements. If you found that this section is a little
    complex and it is difficult to understand all the definitions of assertion methods,
    do not worry. In the next section, we will show you a simple `QUnit` test case
    with few of these assertions, and you will see how easy it is to get started with
    `QUnit`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a basic test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned the basic and important API methods of `QUnit`. Now, let''s use
    few of them to create a simple test case. We will write a method that checks whether
    a number is prime or not. Then we will make a couple of calls to the `isPrime()`
    method from our test and analyze the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A rather simple example is shared in the previous code snippet to show how easy
    it is to get started with `QUnit`. We use the `expect()` method at first to assure
    that we will be doing two assertions in this test case. If we do more than two
    assertions, then this test will fail. Now, those two asserts, namely `ok()` and
    `equal()`, call the `isPrime()` method with two different inputs and check whether
    those input values are prime numbers or not. When you run this test, you can see
    both the tests to pass through.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the QUnit module (), setup (), and teardown () methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To organize multiple test cases, we need something that can provide a block
    structure and hold multiple tests together. The `module()` method allows us to
    group the test cases together. Furthermore, it introduces the two methods, `setup()`
    and `teardown()`, that run before and after each test case, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` method is quite useful when you need to instantiate an object
    (such as a view or a collection) that will be used in multiple tests. The `teardown()`
    method, on the other hand, is mostly used to clean up the resources that you added
    as global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Backbone.js components with QUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now as we understand the basics of `QUnit`, let''s try it with some Backbone
    components. We will first start with a Backbone model and we will create a simple
    `User` model, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we tested the Backbone model with one of its default values and another
    attribute that we changed in the `setup()` method, but intentionally tested it
    with another value. So, this test should fail for one assert case. The following
    screenshot shows how it will look in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing Backbone.js components with QUnit](img/3576_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using test spies, stubs, and mocks with SinonJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use unit testing to test one component of an application. That component
    can be a function, an object, a variable, or any outcome which is not known yet,
    and your unit test wants to make sure whether that particular component is working
    fine or not. Often, besides testing separate components, you may find testing
    the behavior of your methods is of the same importance. For example, how many
    times a method is called, what it returns, whether it has thrown any exception,
    what arguments it is called with, and so on. To perform these types of behavioral
    testing, we use test spies, stubs, and mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few testing libraries which support test spies, stubs, and mocks.
    However, we found `SinonJS` quite easy to work with and robust as well. `SinonJS`
    works seamlessly with `QUnit` and you can use it with or without `QUnit` too.
    The definition of `SinonJS`, as given on their website, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone test spies, stubs and mocks for JavaScript. No dependencies, works
    with any unit testing framework.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Testing with spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to know what a spy is. By definition, as given on the `SinonJS`
    website, a spy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A test spy is a function that records arguments, return value, the value of
    this and exception thrown (if any) for all its calls. A test spy can be an anonymous
    function or it can wrap an existing function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So your next question should be why a spy should be used. We use test spies
    to test the behavior of callback and other methods, and to understand how they
    work. You will find out the answer in more detail once you look into some API
    methods associated with spies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`called()`: This returns true if the spy was called at least once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calledOnce()`: This returns true if the spy was called exactly once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returned()`: This returns true if the spy returned the provided value at least
    once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are few of the supported methods of the spy API. Hopefully, now you can
    understand why a spy is used—it allows you to test multiple characteristics of
    a function, to know whether it gets called only once, or to check what value it
    returns. A spy allows you every possibility to test the complete flow of a function.
    Now let''s see how to use a spy from the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We used the same `User` model and added a `getNameAsArray()` method to it. We
    spied on this method to test whether it gets called only once and returns an array.
    The previous test case passes fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can use spies for any or all of the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for the invocation of a callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate whether callbacks are executed with certain arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate if internal functions provide the correct return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate a certain simple calling behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A test stub, on the other hand, extends from a spy and adds some extra functionality
    to it. It is a function with preprogramed behavior and supports the complete spy
    API. It is used to replace (or fake) the behavior of an existing method with something.
    It is quite useful when you want to prevent a specific method from being called
    directly, or force a method to throw an error in order to test error handling.
    Like spies, stubs can either be anonymous, or they can wrap the existing functions.
    When wrapping an existing function with a stub, the original function is not called.
  prefs: []
  type: TYPE_NORMAL
- en: 'An anonymous stub can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a wrapper to a method of an object, it can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the function `object.method` is replaced with an anonymous stub function.
    You can also add one more function as the third parameter to the `stub()` function,
    which will work as a spy on `object.method` and will replace the original method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how a spy works with a real example, we can use the same `User`
    model that we previously used. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we stub the `getNameAsArray()` method of the `User` model and return an
    empty array. So while you call the `getNameAsArray()` method, *not the method
    but the stub will get called*. We made sure that the stub returns an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Now the test is as simple as the one we did earlier. We just call the `getNameAsArray()`
    method on the `User` instance and check the length of the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mocks (and mock expectations) are fake methods (like spies) with pre-programmed
    behavior (like stubs) as well as pre-programmed expectations. A mock will fail
    your test if it is not used as expected.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the definition of mock as given in the `SinonJS` website ([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks)).
    Mocks are quite similar to stubs, but they come with built-in expectations. They
    implement both the spy and stub APIs. With a mock, you define all the expectations
    that should happen in your test. When all those things are done, you assert whether
    those things happened exactly the way they were planned. So you define the expectations
    and if they aren't met, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how do we use a mock? We mock an object, set expectations on its methods,
    and apply modifiers on these expectations. Then we verify whether the test passes
    all the expectations or not. To understand it better, let''s explore a simple
    example with mock, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use the same `User` model here and create a mock with a `User` instance.
    Then we set the expectation on the mock to see whether the `getNameAsArray()`
    method is called only once on that `User` instance. All these expectations are
    set beforehand and we verify them all together at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between mocks and stubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, because stubs and mocks are similar in functionality, you may wonder why
    and when you should use a mock instead of a stub. As given by the website, you
    would use a mock only when you want to provide both alternate functionality and
    an expectation in your test. The main difference you can see is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects are used to define expectations, that is, in a particular scenario,
    we expect the `Foo()` method to be called with a set of parameters. Mock records
    and verifies such expectations that whether the `foo()` method actually got called
    with those parameters or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs, on the other hand, have a different purpose—they do not record or verify
    expectations, but rather allow us to "replace" the behavior and the state of the
    "fake" object in order to utilize a test scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the life cycle with stubs, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up data: Prepare the object that is being tested and its stubs collaborators.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise: Test the functionality.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify state: Use asserts to check the object''s state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Teardown: Clean up the resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the life cycle with mocks, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up data: Prepare object that is being tested.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up expectations: Prepare expectations in a mock that is being used by the
    primary object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise: Test the functionality.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify expectations: Verify that correct methods have been invoked in the mock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify state: Use asserts to check the object''s state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Teardown: Clean up the resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there are pre and post states for a mock. We set the expectation
    before the test and verify it afterwards. Anyway, the purpose of both stub and
    mock is to eliminate testing all the dependencies of a class or function so that
    your tests are more focused and simple in what they are trying to prove.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have included a number of books and tutorials related to `QUnit` and `SinonJS`
    in the [Appendix A](apa.html "Appendix A. Books, Tutorials, and References"),
    *Books, Tutorials, and References*. You can follow them to get a more detailed
    idea about these two technologies.
  prefs: []
  type: TYPE_NORMAL
- en: A few testing concepts were described in this chapter. You got an idea about
    the power of `QUnit` and `SinonJS`, and how to use them extensively to unit test
    your JavaScript application. Though that barely scratches the surface, we never
    intended to cover everything about testing in this book either. We just tried
    to make you aware of the fact that testing is an absolutely important part of
    the application development process, and you should make it a habit to write test
    cases whenever you develop. It will make your code more structured, flexible,
    and easier to use for your teammates.
  prefs: []
  type: TYPE_NORMAL
