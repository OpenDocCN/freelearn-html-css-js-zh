- en: The State of JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: avaScript has not traditionally been considered a backend language; that space
    belonged to the likes of Java, Python, C/C++, C#/.NET, PHP, Ruby and so on. JavaScript
    was just a 'toy language' that allowed web developers to add animation to websites
    in order to improve its aesthetics. But this all changed with the advent of **Node.js**.
    With Node.js, developers can now write JavaScript code that executes on the server,
    as well as the client. In other words, developers can now write both front and
    backend code using *the same language*!
  prefs: []
  type: TYPE_NORMAL
- en: This provides huge productivity benefits, as common code can now be shared across
    the stack. Furthermore, developers can avoid context switching between different
    languages, which often breaks concentration and reduces output.
  prefs: []
  type: TYPE_NORMAL
- en: It also led to the rise in **Isomorphic**, or **Universal**, JavaScript frameworks,
    such as *Meteor*. These types of frameworks allow you to write applications entirely
    in JavaScript that run on both the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining a short history on the evolution of the web application and its transition
    from the **client-server model** to **Single-Page Applications (SPAs)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of Isomorphic JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the benefits of using JavaScript across the entire stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolution of the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you type a URL, such as `www.example.com`, into your browser, what actually
    happens? First, the browser would send a request to one of Example Corp''s servers,
    which retrieves the resource requested (for example, an HTML file), and sends
    it back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/142965cf-7095-49d0-b30b-51d24cc0dd30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The browser then parses the HTML, retrieves all the files the web page depends
    on, such as CSS, JavaScript, and media files, and renders it onto the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf7fadd0-1869-4b96-8c8c-263b01bb6f27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The browser consumes flat, one-dimensional texts (HTML, CSS) and parses them
    into tree-like structures (DOM, CSSOM) before rendering it onto the page.
  prefs: []
  type: TYPE_NORMAL
- en: This scheme is known as the *client-server model*. In this model, most of the
    processing is handled server-side; the client's role is limited to simple and
    superficial uses, such as rendering the page, animating menus and image carousels,
    and providing event-based interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: This model was popular in the 1990s and 2000s, when web browsers were not very
    powerful. Creating entire applications with JavaScript on the client side was
    unheard of, and those that had that requirement resorted to Java applets and Adobe
    Flash (and, to a certain extent, Microsoft Silverlight). However, over time, the
    computing power of personal devices, such as desktop computers, laptops, and smartphones
    increased dramatically, and this allowed browsers to handle more elaborate operations.
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-time (JIT) compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between 2008 and 2009, Mozilla, the company behind Firefox, slowly introduced
    *TraceMonkey*, the first **Just-in-time (JIT)** compiler for JavaScript, in different
    versions of Firefox 3.x, starting with 3.1\. Similarly, the *V8* JavaScript Engine,
    which powers Chrome and Safari, and *Chakra*, which powers Internet Explorer and
    Edge, also included a JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the JavaScript engine uses an **interpreter**, which translates
    the JavaScript source code into **machine code** that your computer can run. The
    JIT compiler improved the performance of the engine by identifying blocks of code
    that are frequently run, compiling them, and adding them to a cache. When the
    same block of code needs to be run again at a later time, the JavaScript engine
    can simply run the cached, pre-compiled machine code, skipping the interpreter
    altogether. Needless to say, this is much faster and the JavaScript engine can
    execute more operations per unit time, greatly increasing performance.
  prefs: []
  type: TYPE_NORMAL
- en: Single page applications (SPAs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of this increased performance, developers can now build feature-rich
    JavaScript applications that run on the browser. Google was the first major company
    to take advantage of this, when they released the first **client-side web application
    framework**—*Angular* - on 20 October 2010\. Since then, many competitors have
    emerged, including *Ember*, *React*, and *Vue.js*, but Angular still remains relevant
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is a framework for building SPAs. Instead of delegating the bulk of
    the processing to the server, the client takes on most of the responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an e-commerce web application as an example. In the client-server
    model, when the server receives a request from the client, it will compose a fully-formed
    HTML and attach it as the payload of the response. If it needs data from the database,
    it will query the database and inject the data into an HTML template to produce
    the fully-formed HTML. The client, usually a browser, is then entrusted with the
    simple task of rendering the HTML onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the SPA model, the server would initially send the entire application, including
    any HTML, CSS, and JavaScript files, to the client. All the application logic,
    including routing, now resides on the client. Because of this, the client can
    update the UI of the application very quickly, as it does not need to wait for
    a response from the server. Whenever the client requires information it does not
    have, such as certain entries in the database, it will send a request to the server.
    The server would then respond with the raw data, usually presented in JSON format,
    and nothing else. It is then the client''s job to process this information and
    update the UI appropriately. With SPAs, most of the logic is handled client-side;
    the server''s job is simply to retrieve and send back data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23fcb8b6-092c-4a84-9d8b-278dee9a49c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The SPA model has many benefits over the client-server model:'
  prefs: []
  type: TYPE_NORMAL
- en: It frees up the server to handle more requests, as requests are simpler to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the UI of the app to respond more quickly to user interaction because
    the UI does not need to wait for the server to respond before updating itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, most web applications are built with an SPA framework. Tesla, Sony,
    Microsoft Support, Genius, Renault, Staples, Udemy, and Healthcare.gov are all
    websites built with Angular; Airbnb, Asana, BBC, Dropbox, Facebook, Lyft, Netflix,
    PayPal, and Uber all use React on their websites; although Vue.js is relatively
    new, several major Asian companies have already adopted it, such as Alibaba, Baidu,
    Tencent, Xiaomi, and Line.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic JavaScript applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, everything has its drawbacks, and SPAs are no exception. The most obvious
    shortcoming of SPAs is that more code needs to be transferred at the beginning,
    which can increase the initial load time of the page. To counteract this deficiency,
    a technique called **server-side rendering** (**SSR**) can be employed.
  prefs: []
  type: TYPE_NORMAL
- en: With SSR, the initial page is processed and rendered on the server in the same
    way as the traditional client-server model. However, the returned HTML contains
    a tag that'll request the rest of the application to be downloaded at a later
    time, after the initial page has been successfully rendered. This allows us to improve
    the initial page load speed, whilst keeping all the benefits of the SPA. Furthermore,
    SSR is also useful for ensuring **Search Engine Optimization** (**SEO**) performance,
    as it helps web crawlers to quickly decipher how a page should look, without having
    to download all the assets.
  prefs: []
  type: TYPE_NORMAL
- en: SSR can be used alongside other techniques, such as **code splitting** and **tree
    shaking**, to reduce the size of the initial response payload, thus reducing the
    **time-to-first-render** (**TTFR**) and improving the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: This is the state of the web application today. New web standards such as **HTTP/2**
    and **WebAssembly** (a.k.a. *Wasm*) may all change how we approach building web
    applications in the near future. In the fast-moving world of front-end development,
    this SPA + SSR model may soon be superseded by a new paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is the language of the browser. There's no denying that. Next, let's
    examine the reasons why a developer should pick Node.js as the back-end language
    for their application. Although there are many reasons, here we've boiled it down
    to two factors—**context switching** and **shared code**.
  prefs: []
  type: TYPE_NORMAL
- en: Context switching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context switching, or *task switching*, is when a developer is working on multiple
    projects, or in different languages, at the same time and has to switch between
    them regularly.
  prefs: []
  type: TYPE_NORMAL
- en: '"Doing more than one task at a time, especially more than one complex task,
    takes a toll on productivity."'
  prefs: []
  type: TYPE_NORMAL
- en: '– Multitasking: Switching costs (American Psychological Association)'
  prefs: []
  type: TYPE_NORMAL
- en: ([http://www.apa.org/research/action/multitask.aspx](http://www.apa.org/research/action/multitask.aspx))
  prefs: []
  type: TYPE_NORMAL
- en: Switching between projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is an activity that requires you to keep many variables in memory
    at the same time—variable names, interfaces of different modules, application
    structure and many more. If you switch to a different project, you'll have to
    dump the context of the current project and load in the context of the new project.
    The time required for this switch increases with the complexity of the project,
    and varies from one individual to the next, but can take anything from a few minutes
    to a few hours. This makes development extremely inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, instead of multitasking, you should complete one project before
    moving on to another.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same principle applies when switching between different programming languages.
    When switching between projects, you need to juggle between different contexts;
    when switching between languages, you need to juggle between different syntax,
    data structures, and ecosystems. To demonstrate, the following table illustrates
    some key differences between Python and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '| Has many data types, including `None`, Boolean, `int`, `float`, `complex`, `list`,
    `tuple`, `range`, `str`, `bytes`, `bytearray`, `memoryview`, `set`, `frozenset`,
    `dict`, and many more | Has seven data types: `undefined`, `null`, `Boolean`,
    `number`, `string`, `symbol`, and `object` |'
  prefs: []
  type: TYPE_TB
- en: '| Statements are grouped by indentation | Statements are grouped by blocks,
    expressed using enclosing braces (`{}`) |'
  prefs: []
  type: TYPE_TB
- en: '| Uses [`virtualenv`](https://virtualenv.pypa.io/en/stable/) to create isolated
    environments | Uses **Node Version Manager** ([https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    (**nvm**), `package.json`, and the local `node_modules` directory to create isolated
    environments |'
  prefs: []
  type: TYPE_TB
- en: '| Uses a class-based inheritance model | Uses a prototype-based inheritance
    model |'
  prefs: []
  type: TYPE_TB
- en: In addition to syntactical differences, different languages may also follow
    different paradigms—Elixir is a functional language, whereas Java is an **object-oriented**
    (**OO**) **language**.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, context-switching between different languages also makes the development
    process very inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: The business perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a business point of view, using different languages for the front- and
    back-end means they need to hire two different types of developer: JavaScript
    developers for the front-end and, say, Python developers for the back-end. If
    there''s a large backlog in back-end tasks, front-end developers wouldn''t be
    able to help (unless they also know Python). This makes resource allocation more
    difficult for project managers. But if everyone develops in JavaScript, then this
    problem becomes null.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, using JavaScript for the entire stack makes the development process
    more efficient. Apart from the efficiencies gained by avoiding context switching,
    a single developer can now develop an entire feature from start to finish, as
    they can code both the front- and back-end.
  prefs: []
  type: TYPE_NORMAL
- en: Shared code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Node.js and SPAs have became more popular, more and more JavaScript libraries
    are being written every day. At the time of writing, over 775,000 packages are
    listed on [npmjs.com](http://npmjs.com), the *de facto* package manager for JavaScript. These
    include libraries for handling time and date (`moment.js`), utility libraries
    (`lodash`), and even a deep learning library (`convnetjs`).
  prefs: []
  type: TYPE_NORMAL
- en: '**npm packages** were originally only meant to be installed and run by server-side
    Node.js; however, tools such as **Browserify** and **Webpack** allowed us to bundle
    these dependencies and send them to the client. Now, many npm packages can be
    used in both the front- and back-end.'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, by using JavaScript across your entire stack, you can encapsulate
    common logic and use it across both environments. For example, authentication
    checks should be performed on both the server (for security reasons) as well as
    the client (to ensure performance by preventing unnecessary requests).
  prefs: []
  type: TYPE_NORMAL
- en: If JavaScript is used for front- and back-end code, then the code can be shared
    and reused. If, however, we use Python in the back-end, then the same logic must
    be duplicated in JavaScript. This violates the **Don't Repeat Yourself** (**DRY**)
    principle and makes our development process slower and more error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The project also becomes harder to maintain. Now, when we need to make changes
    to the code, we must update it twice, in two different languages, possibly across
    two different projects; both projects may also need to be deployed at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, using JavaScript in the front-end and Node.js in the back-end allows
    you to improve maintainability, reduce compatibility issues, and conserve manpower
    and development time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the evolution of web applications from using the
    client-server model to SPAs, and how advances in JavaScript engines facilitated
    this transformation. Then, we discussed the benefits of using JavaScript across
    the stack, focusing on the topics of context switching and shared code.
  prefs: []
  type: TYPE_NORMAL
