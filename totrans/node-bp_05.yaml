- en: Chapter 5. Creating a To-do Application with Backbone.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to create real-time chat with Socket.IO.
    We made a blog application with AngularJS and used Express to create a simple
    website. This chapter is dedicated to another popular framework—Backbone.js. Backbone.js
    is one of the first JavaScript frameworks that gained popularity. There are models
    that deal with the data, views that control the logic and the user interface,
    and the built-in router that handles the changes in the browser's address. The
    framework plays really well with jQuery, which makes it attractive to almost every
    JavaScript developer. In this chapter, we are going to build a simple application
    for storing short tasks. At the end, we will be able to create, edit, delete tasks,
    and mark them as finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Backbone.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Node.js code that manages the to-do lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the frontend using Backbone.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Backbone.js framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting with the example's application, we should check out the main
    features of the framework. Sometimes, it's good to know what is going on under
    the hood. So, let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing the framework dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the software that we use nowadays is built on top of other libraries
    or tools. Normally, they are called **dependencies**. Backbone.js has only one
    hard dependency—that's Underscore.js, which is a library full of utility functions.
    There are functions such as `forEach`, `map`, or `union` for arrays. We can extend
    an object and retrieve its keys or values. All these are functionalities we need
    sometimes, but they are missing in the built-in JavaScript objects. So, we should
    include the library in our page. Otherwise, Backbone.js will throw an error because
    of the missing functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js works really well with jQuery. It checks whether the library is
    available and starts using it right away. It's a nice collaboration because we
    can speed up our work with the various jQuery methods. It's not a must-have dependency
    and the framework still works without it, but it simplifies the DOM manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The framework has a few independent components that we will use. So, the idea
    is that we will create new classes that inherit the functionality of the base
    implementations. These components have the `extend` method, which accepts an object—our
    custom logic. At the end, our properties will overwrite the original code. The
    following is a new view class that we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are no mandatory modules. There is no strictly defined central entry point
    of our application. Everything is up to us, which is good. All the parts are so
    decoupled, which makes Backbone.js easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Backbone.js as an event-driven framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By event driven, we mean that the application flow is determined by events,
    that is, every class/object in the framework dispatches messages that notify the
    rest of the components about some action. In other words, every object we create
    can accept listeners and can trigger events. This makes our application extremely
    flexible and communicative. This approach encourages modular programming, and
    it really helps in building solid architectures. The `Backbone.Events` module
    is a module that delivers this functionality. The following example code explains
    how we can extend the `Backbone.Events` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Underscore.js `extend` method merges the passed objects into one. In our case,
    we will produce an object that has the observer pattern implemented. This leads
    us to conclude that every view, model, or collection produced by Backbone.js has
    the `on` and `trigger` methods available.
  prefs: []
  type: TYPE_NORMAL
- en: Using models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model is an important part of every Backbone.js project. Its primary function
    is to hold our data. The model keeps, validates, and synchronizes data with the
    server. Together with this, the model can notify the outside world of the events
    that happen inside the module. The following example code explains how we can
    extend the `Backbone.Model` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The information in the model is kept in a hash table. There are properties and
    values. We have the `set` and `get` methods to access the data. Once something
    is changed, the model triggers an event. You may wonder why we need to wrap the
    data into a class. In the beginning, `Backbone.Model` looks like an unnecessary
    abstraction. However, very soon you will realize that such a concept is really
    powerful. First, we can attach as many views as we want to the same model, and
    by attach we mean listening to a `change` event. We can update the model and change
    the user interface as well. The second thing is that we can connect the model
    to a server-side API and immediately synchronize the information via an Ajax request.
    We will do this in an example application later.
  prefs: []
  type: TYPE_NORMAL
- en: Using collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Very often, we will need to store the models in an array. The collections are
    made for such cases. The `Backbone.Collection` module has methods such as `add`,
    `remove`, and `forEach` for interaction with the stored items. It can also fetch
    multiple models from an external source and that''s what it is used mostly for.
    Of course, the collection needs to know what is the type of the model. The following
    example code explains how we can extend the `Backbone.Collection` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The example shows the same `User` model class, but this is placed inside a collection.
    We can easily add new users and retrieve their names. Similar to the `Backbone.Model`
    module, every collection can sync our data with an external server via HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The views in Backbone.js take care of the user interface and its business logic,
    that is, when compared to the usual **Model-View-Controller** (**MVC**) pattern,
    here, the view and the controller are merged in one place. Again, there is a base
    class that we have to extend. An interesting thing is that a DOM element is automatically
    created for us. We can control its type, class, or ID, and it is always there.
    This is really handy because we can build our interface dynamically behind the
    scenes and add it to the page only once, avoiding the multiple reflows and repaints
    of the browser. This can increase the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a certain popular wrong implementation of Backbone.js views. I myself
    made a lot of mistakes till I understood how everything is supposed to work. The
    idea is to bind the view''s `render` method to a change in the model. By doing
    this, the interface will be automatically updated. It is also important to find
    the balance and keep the classes short. Sometimes, we may end up with a really
    long view, which controls a big portion of our page. A good practice is to divide
    the parts into smaller pieces. It''s just a lot easier for maintenance and testing.
    The following example code explains how we can extend the `Backbone.View` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `tagName` property determines the type of the generated DOM element. It's
    a good practice to operate only with that created element. It's not a good idea
    to attach it to another view or somewhere in the DOM tree. This should happen
    outside the class. There are some tricky sections we must watch out for when we
    need to attach event listeners, for example, `click`. However, the framework has
    a solution for such cases. We will see it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we learned about models, collections, and views. There is one more thing
    that is widely used, especially when we need to build a single-page application
    like ours—the router. It's a module that maps a function to a specific URL. It
    supports the new history API so that it can handle addresses such as `/page/action/32`.
    The HTML5 history API is a standardized way to manipulate the browser history
    via a script. If the browser doesn't support this API, then it works with the
    good old fragment version, that is, `#page/action/32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code explains how we can extend the `Backbone.Router`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We just have to define our routes and the module is responsible for the rest.
    Keep in mind that we may use dynamic URLs, that is, URLs that contain dynamic
    parts, like with the `search` route in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The router itself collaborates with another module called `Backbone.history`.
    This is the class that listens to `hashchange` events or `pushState` events triggered
    by the browser. So, once the routes are initialized, we should run `Backbone.history.start()`
    in order to fire the matched route handler. We will see this in action while writing
    the client-side part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Talking to the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned, Backbone.js offers automatic synchronization with the server-side
    data. This, of course, needs some efforts from our side, and they are more like
    the things we need to do at the backend part of the application. The client-side
    JavaScript makes **CRUD** (**create**, **read**, **update**, and **delete**) HTTP
    requests and the server will process them. Every model and collection should have
    a `url` property (or method) set, and we will send the information to this address.
    It's only one URL, so the different operations are using different request methods—`GET`,
    `POST`, `PUT`, and `DELETE`. In our example, the key moment is to wire Backbone.js's
    objects to the Node.js server. Once this is done, we will be able to manage the
    to-do lists easily directly from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the backend of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backend is the Node.js part, which will take care of the data delivery and
    will serve the necessary HTML, CSS, and JavaScript functionalities. In order to
    learn something new in every chapter, we will use different approaches for the
    common tasks. For sure, there are things that we need to do every time, for example,
    running a server that listens on a particular port. JavaScript is a really interesting
    language, and in most cases, we can solve the same problems in completely different
    ways. In the previous chapters, we used Express to send assets to the users. In
    addition, there were examples where we did this directly by reading the files
    with the filesystem API. However, this time, we will combine the ideas of the
    two methods, that is, the code that we will use will read the resources from the
    hard disk and we will work with dynamic paths.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Node.js server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start the project in an empty directory. In the beginning, we need
    an empty `index.js` file that will host the Node.js server. Let''s put the following
    content in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The script starts with the definition of some global variables. The `http`
    module is used to run the Node.js server and `fs` is run to access the files.
    The `files` object acts as a cache for already requested files. Reading the files
    from the hard disk can be a very expensive operation, so there is really no need
    to do this in every single request. It''s a good practice to cache the content
    whenever possible. The `debug` variable is set to `true` while we are developing
    the application. This actually turns off our caching mechanisms because otherwise,
    we need to restart the server every time we make changes to some of the HTML,
    CSS, or JavaScript files. There is a short `respond` method, which accepts an
    object with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `content` property is the actual file's content and the `ext` property represents
    the file's extension. The same method also needs the `response` object, so it
    can send information to the browser. Based on the file's type, we set the proper
    `Content-Type` header. This is important because if we skip this, the browser
    may not process the resource correctly. Next, the `serveAssets` method gets the
    current requested path and tries to read the actual file from the system. It also
    checks whether the file is not in the cache or whether we are in the debug mode.
    If the file is missing, it sends a 404 error page to the browser. The last lines
    simply run the server and pass the `request` and `response` objects to `serveAssets`.
    With this code, we are able to request files with URLs that match their actual
    directory path.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the to-do lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have set up the server, so we can now continue writing the business logic,
    that is, the logic that will manage the tasks from our to-do list. Let''s define
    the following two new variables at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `todos` array will keep our tasks. Every task will be a simple JavaScript
    object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will increment the `ids` variable every time we need to add a new to-do
    activity. So, every object in the array will have a unique ID attached to it.
    Of course, normally, we will not rely on a single number to identify the different
    tasks, but the `ids` variable will work for our little experiment. The following
    is the function that will add a new element to the `todos` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We should have two other methods for deleting and editing a to-do list. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `deleteToDo` function loops through the elements and skips the one that
    matches the passed ID. The `editToDo` function is almost the same, except that
    it updates the properties of the stored object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have methods to manage the data; now, we have to write the part that will
    use them. In general, our server has two roles. The first one is to deliver the
    usual HTML, CSS, and JavaScript functionalities to the browser. The other one
    is to act as a REST service, that is, accept the CRUD type of requests and respond
    to them. Backbone.js will send JSON objects and will expect to receive resources
    in the same format. So, we have the `respond` function and the following code
    defines the `respondJSON` function, which will send the data to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point of our server is the handler of the `http.createServer` method.
    This is where we need to divide the application''s flow, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will check whether the current URL starts with `/api`. If not, then we serve
    the assets. Otherwise, the request is considered as a CRUD operation, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two paths that control everything. The `/api/all` path responds with
    a JSON code that contains all the to-do lists available. The next `/api/todo`
    path is responsible for creating, editing, and deleting a task. The actual address
    that is used is `http://localhost:3000/api/todo/4`, where the number at the end
    is the ID of an element in the `todos` array. That''s why we need `req.url.split("/").pop()`,
    which extracts the number from the URL. There is one additional function called
    `processPOSTRequest`. It''s a helper that gets the data sent via the `POST` or
    `PUT` methods. In Express, the same functionality is provided by the `bodyParser`
    middleware. The `processPOSTRequest` function is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, maybe it''s a good idea to fill the `todos` array with some tasks.
    Add the following methods just to have something to display once we build the
    frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Writing the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop the client-side logic—the code that will run
    in the browser of the users. This includes the listing and managing of the to-do
    lists delivered by the Node.js part.
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the base of the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start coding, let''s have a look at the file structure. The following
    figure shows how our project should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking into the base of the application](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `index.js` file contains the Node.js code that we already wrote. The `.css`
    and `.html` directories hold the styles and the HTML markup of the page. In the
    `.js` folder, we will put the collection, model, and views of Backbone.js. Along
    with that, there are the framework''s dependencies and the main application''s
    `app.js` file. Let''s start with the `page.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The styles are added to the `head` tag of the page. The scripts are put at the
    end, just before closing the `body` tag. We do this because the JavaScript files
    usually block the rendering of the page. Adding them at the top of the page means
    that the browser will not get the necessary styles and HTML markup and will not
    display anything to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a menu with two buttons. The first one will show a form where the user
    can add a new to-do list. The second one shows the home page, that is, a list
    with all the tasks. The content `div` element will be the host container where
    we will render Backbone.js''s views. The bootstrapping of the application is done
    in the `init` method of the `app` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will use the **Revealing Module** pattern. The `app` object has its own private
    scope. Its public API consists of namespaces for the models, collections, and
    views. The last thing is the `init` method. It's a good practice to use namespaces.
    They encapsulate our application and prevent collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to display the current available tasks. Let''s
    write a few things in advance. It is clear that we will put the user interface
    in the content `div` element. So, it is a good idea to cache a reference to that
    element because we will use it multiple times. We can define a variable and assign
    a jQuery object to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a view class that will list the data. However, the view itself
    should not make requests to the backend. That''s the job of the model—`/js/models/ToDo.js`;
    its code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are using the namespace created in `/js/app.js`. Backbone.js offers the `defaults`
    property, which we may use to define the initial values. Here, the `url` method
    is very important. Without it, the framework can't send requests to the server.
    The logic that manages the to-do lists at the backend requires an ID. That's why
    we need to construct the URL dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, we may have a lot of tasks, so we need a`/js/collections/ToDos.js`
    collection, and its code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the URL directly as a string. The collection should also know what
    kind of models are stored in it and we pass the model''s class. Keep in mind that
    we actually extended the classes here. In the following code, we will create an
    instance of the collection class and call the `fetch` method, which gets the to-do
    lists stored in the Node.js part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our application is useless without the data. We will use the `success` callback
    and will render the list view once the information arrives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed with the code of the /`js/views/list.js` file, we will clarify
    a few things about the Backbone.js''s views. We mentioned in the beginning of
    the chapter that there is a DOM element that is automatically created for us.
    It''s available as a `.el` property of the view. There are a few common tasks
    that we will probably do. The first one is binding DOM events to functions inside
    the view class. This can happen by applying a value to the `events` property,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We start with the type of the event followed by an element selector. The value
    is a function of the view. A big advantage of this technique for event handling
    is that the `this` keyword in the handler points to the right place, that is,
    the view. We may need to call `delegateEvents` to reassign the listeners. This
    is needed when we update the HTML code of the view's DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other interesting thing regarding Backbone.js''s views is the `render`
    method. What we normally do there is update the content of the `.el` object. We
    can use any code we like, but it is good practice to avoid placing HTML tags.
    That''s the function where most developers use a template engine. In our example,
    we will use the Underscore.js template. It accepts a string and an object with
    data. As we don''t want to place the HTML as a string inside the view, we will
    add it to the `page.html` file. The markup will be placed inside a script tag,
    so it doesn''t mess up the rest of the valid HTML code. The good news is that
    we could still get it via jQuery by simply querying the tag. For example, the
    following is the template used in `/js/views/list.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are data placeholders for the item's index, text, and status. We will
    replace them with actual values during the rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the to-do activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s continue with the code of the list view. The one that will show the
    current added to-do activity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We define the view class in the correct namespace. We will pass the collection
    of to-do activities as a model, so the `this.model` statement will give us an
    access to all the tasks. In the `render` method, we loop through every model and
    construct an unordered list, which is at the end and appended to the DOM element.
    We are using `$el` instead of `el` because our project has jQuery included, and
    Backbone.js automatically starts working with it. Note that we are sending different
    values of `done` and `statusLabel` based on the status of the task. If we check
    the preceding template, we will see that `done` is actually a CSS class. Applying
    a different class will allow us to distinguish the items in the list. We should
    not forget to run the `delegateEvents` method at the end. We are updating the
    children elements of `$el`, so every event listener that is attached is removed.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning of the class, we define two events. The first one deletes a
    to-do activity from the system. Backbone.js has a destroy method for such cases.
    However, to reach the exact model from the collection, we need its index (ID).
    If we check the HTML template, will see that every `li` tag has a `data-index`
    attribute that contains exactly what we need. That's what the `getIndex` helper
    does—it gets the value of that attribute. Similarly, `changeStatus` updates the
    `done` field of the to-do lists. After every modification, we call the `render`
    method. This is quite important for the users because they have to see that the
    change is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change the `app.js` file a bit and render the view, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is one new method, `showList`, which triggers the rendering of the view
    and appends its DOM element to the content `div` element. Now, if we run the application
    by typing `node ./index.js` in our console, we will see the three to-do activities,
    which we added, being displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding, deleting, and editing the to-do lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next logical step is to develop the code for the adding, editing, and deleting
    of tasks. So, we need two new pages, additional logic to show the two new views,
    and a few lines that will remove tasks. We will also need a router that will handle
    the new content. To simplify the process, let''s directly see how the final `/js/app.js`
    file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have put a few new variables at the top. The `add` and `edit` variables
    represent the two new views. There are two new functions that change the content
    `div` element. Note that we are not calling the `render` method of the `add` view.
    This is because there is nothing dynamic in it, which means that there is no need
    to render it repeatedly. It''s just a form that submits data. The `showEditToDoForm`
    function is almost the same as the `showList` function, except that we expect
    one additional parameter—`data`. This should be an object with a format `{index:
    <number>}`. Once we have the index of the to-do list, we can easily get its fields.
    We will need these fields because we have to fill the form for editing.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the home method simply uses the `navigate` method of the router and returns
    the user to the `list` view. The next thing in the script is the definition of
    the router. The described paths call the functions that we just went through.
    It's the mapping of URL addresses to JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few new things inside the `init` method, so let's have a closer
    look. The two new views, `add` and `edit`, are initialized, and again they accept
    the collection's to-do activities. We will also start listening for two events.
    The views dispatch the `saved` event when a new to-do activity is added and the
    `edited` event when some of the tasks are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view for adding new tasks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is validation of the user''s input. If there is text entered in the `textarea`
    element, we call the `create` method of the collection that initializes a new
    model. It also sends a `POST` request to the server. Once the operation finishes,
    we empty the textbox and trigger the `saved` event so that the code in `/js/app.js`
    can forward the user to the home page. The views for adding and editing need a
    separate template. The following is the code of that template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/js/views/edit.js` file has almost the same code, which is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that it puts a value in the `textarea` element and calls the
    `save` method of the edited model instead of the `create` function of the whole
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with Backbone.js. We used a model, collection,
    router, and several views to implement a simple to-do application. Thankfully,
    due to the event-driven nature of the framework, we bound everything together.
    Node.js took an interesting and important part in this small project. It handled
    the requests from the client-side's JavaScript and acted as a REST service.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is dedicated to command-line programming. We will see how to
    use Node.js from the command line and will develop a script that uploads our photos
    to Flickr.
  prefs: []
  type: TYPE_NORMAL
