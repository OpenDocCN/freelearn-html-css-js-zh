<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Adding User Interactivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Adding User Interactivity</h1></div></div></div><p>Great visualizations provide more than a pretty picture and animations; they allow the user to interact with the data, giving them the ability to play with the data to discover the meaning in the data that may not be obvious through a given static presentation.</p><p>Exceptional interactions allow the users to steer their way through large amounts of information. It allows them to pan through data too large for a single display, to dive into summary information, and also zoom out to get a higher level view—in essence, it allows users to see the forest from the trees.</p><p>Also of great value is the capability to allow the user to easily select, reorder, and reposition visual elements. Through these actions, the user is able to see details of a datum simply by mouseover or touch, to rearrange items for exposing other insights, and to also see how data moves around when reordered. This provides the user a sense of constancy and shows how the data changes when asked to reshuffle on demand.</p><p>In this chapter, we will examine a number of techniques for adding interactivity to your D3.js visualizations. We will examine concepts involved in using the mouse to highlight information and provide contextual information, to pan and zoom your visualizations, and to use brushing to select and zoom the view of information in and out.</p><p>Specifically, in this chapter we will learn the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hooking into mouse events on D3.js visuals</li><li class="listitem" style="list-style-type: disc">Clicking and responding to mouse events</li><li class="listitem" style="list-style-type: disc">Building several models of visual animation to provide feedback on interaction</li><li class="listitem" style="list-style-type: disc">Handling mouse hovers to provide detailed information on specific visuals</li><li class="listitem" style="list-style-type: disc">Creating fluid animations that respond to mouse events </li><li class="listitem" style="list-style-type: disc">Brushing and its use in selecting data</li><li class="listitem" style="list-style-type: disc">Implementing a context-focus pattern of interaction for viewing stock data</li></ul></div><div class="section" title="Handling mouse events"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Handling mouse events</h1></div></div></div><p>The mouse is the <a id="id352" class="indexterm"/>most common device available to users for interacting with D3.js visualizations. Touch is commonly used in case of tablets, and in many cases, touch events can be mapped to mouse events. In this chapter, we will focus exclusively on the mouse. But most of everything we cover also applies to touch. Touch concepts such as pinching can also be easily supported on touch devices with D3.js.</p><p>To work with mouse events in D3.js, we attach event listeners to the SVG elements for which we desire to handle the events. The handlers are added using the <code class="literal">.on()</code> function, which takes as parameters the name of the event and a function to call when the mouse event happens.</p><p>We will examine the handling of four mouse events: <code class="literal">mousemove</code>, <code class="literal">mouseenter</code>, <code class="literal">mouseout</code>, and <code class="literal">click</code>.</p><div class="section" title="Tracking the mouse position using mousemove"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec43"/>Tracking the mouse position using mousemove</h2></div></div></div><p>The <a id="id353" class="indexterm"/>movement of the mouse on an <a id="id354" class="indexterm"/>SVG visual is reported to your code by listening for the <code class="literal">mousemove</code> event. This following example demonstrates tracking and reporting the mouse position:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note101"/>Note</h3><p>bl.ock (8.1): <a class="ulink" href="http://goo.gl/VK67C4">http://goo.gl/VK67C4</a>
</p></div></div><div class="informalexample"><pre class="programlisting">var svg = d3.select('body')
    .append('svg')
    .attr({
        width: 450,
        height: 450
    });
var label = svg.append('text')
    .attr('x', 10)
    .attr('y', 30);

svg.on('mousemove', function () {
    var position = d3.mouse(svg.node());
    label.text('X=' + position[0] + ' , Y=' + position[1]);
});</pre></div><p>We listen to <code class="literal">mousemove</code> events using <code class="literal">.on()</code>, passing it when the event fires, and the example updates the content of the text in the SVG text element:</p><div class="mediaobject"><img src="graphics/B04230_08_01.jpg" alt="Tracking the mouse position using mousemove"/></div><p>The position of the <a id="id355" class="indexterm"/>mouse is not <a id="id356" class="indexterm"/>passed to the function as parameters. To get the actual mouse position, we need to call the <code class="literal">d3.mouse()</code> function, passing it to the return value of <code class="literal">svg.node()</code>. This function then calculates the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> mouse position relative to the SVG element for which the mouse is moving over.</p></div><div class="section" title="Capturing the mouse entering and exiting an SVG element"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec44"/>Capturing the mouse entering and exiting an SVG element</h2></div></div></div><p>The <a id="id357" class="indexterm"/>mouse entering and exiting a <a id="id358" class="indexterm"/>particular SVG element is captured using the respective <code class="literal">mouseenter</code> and <code class="literal">mouseout</code> events. The following example shows this by creating several circles and then changing their color while the mouse is within <a id="id359" class="indexterm"/>the area of the circle (also known as <span class="strong"><strong>hovering</strong></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note102"/>Note</h3><p>bl.ock (8.2): <a class="ulink" href="http://goo.gl/4cfrdq">http://goo.gl/4cfrdq</a>
</p></div></div><p>This code creates three circles of varying size (<code class="literal">30</code>, <code class="literal">20</code>, and <code class="literal">40</code> pixel radius):</p><div class="informalexample"><pre class="programlisting">var data = [30, 20, 40],</pre></div><p>Tracking the enter and exit of the mouse is performed by hooking into those two events:</p><div class="informalexample"><pre class="programlisting">    .on('mouseenter', function() {
        d3.select(this).attr('fill', 'red');
    })
    .on('mouseout', function() {
        d3.select(this).attr('fill', 'steelblue');
    });</pre></div><p>When you run this example, you will be presented by three <code class="literal">steelblue</code> circles of slightly varying size, and when you hover the mouse over any of them you will see it change to <code class="literal">red</code>:</p><div class="mediaobject"><img src="graphics/B04230_08_02.jpg" alt="Capturing the mouse entering and exiting an SVG element"/></div><p>Note that <a id="id360" class="indexterm"/>the SVG element <a id="id361" class="indexterm"/>which the mouse is currently entering or exiting is not passed to the functions, so we need to retrieve them using <code class="literal">d3.select(this)</code>.</p></div><div class="section" title="Letting the user know they have clicked the mouse"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec45"/>Letting the user know they have clicked the mouse</h2></div></div></div><p>When the user <a id="id362" class="indexterm"/>clicks a button on the mouse, the mouse can track the mouse being clicked by using the <code class="literal">mouseclick</code> event. The code at the following link demonstrates handling the click event handler:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note103"/>Note</h3><p>bl.ock (8.3): <a class="ulink" href="http://goo.gl/91rt4S">http://goo.gl/91rt4S</a>
</p></div></div><p>This code adds an event handler to the code in example <span class="emphasis"><em>8.2</em></span> to capture the click event and pop up an alert box that shows the value of the datum and its position in the collection:</p><div class="informalexample"><pre class="programlisting">.on('click', function(d, i) {
    alert(d + ' ' + i);
});</pre></div><div class="mediaobject"><img src="graphics/B04230_08_03.jpg" alt="Letting the user know they have clicked the mouse"/></div><p>This is pretty neat as you are given the data underlying the visual that you clicked. There is no need to retain a map of the visuals to the data to just look this up.</p></div></div></div>
<div class="section" title="Using behaviors to drag, pan, and zoom"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Using behaviors to drag, pan, and zoom</h1></div></div></div><p>Mouse events often <a id="id363" class="indexterm"/>need to be combined to create more complex interactions such as drag, pan, and zoom. Normally, this requires a good quantity of code to track sequences of the <code class="literal">mouseenter</code>, <code class="literal">mousemove</code>, and <code class="literal">mouseexit</code> events.</p><p>D3.js provides us with a better way of implementing these interactions through the use of <span class="strong"><strong>behaviors</strong></span>. These behaviors <a id="id364" class="indexterm"/>are a complex set of DOM/SVG interactions through D3.js itself handling the mouse events. In a sense, behaviors function similarly to gesture recognizers on mobile platforms.</p><p>D3.js currently provides two built-in behaviors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Drag</strong></span>: This tracks <a id="id365" class="indexterm"/>mouse or multi-touch movements relative to <a id="id366" class="indexterm"/>an origin</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Zoom</strong></span>: This emits <a id="id367" class="indexterm"/>zoom and pan events in response to dragging or <a id="id368" class="indexterm"/>pinching</li></ul></div><p>Let's examine an example of implementing drag and another that also adds pan and zoom capabilities.</p><div class="section" title="Drag"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec46"/>Drag</h2></div></div></div><p>Drag is a common behavior in <a id="id369" class="indexterm"/>interactive visualization that allows the movement of visual elements by the user via the mouse or touch. The following example demonstrates using the drag behavior:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note104"/>Note</h3><p>bl.ock (8.4): <a class="ulink" href="http://goo.gl/wxn6iN">http://goo.gl/wxn6iN</a>
</p></div></div><p>The preceding example renders four circles and lets you move them around the SVG area using the mouse, but also constrains the movement so that the circles remain completely within the SVG element's visual area:</p><div class="mediaobject"><img src="graphics/B04230_08_04.jpg" alt="Drag"/></div><p>The code begins by calculating the positions for the circles and rendering them using a selection. The drag behavior is then implemented with the following code:</p><div class="informalexample"><pre class="programlisting">var dragBehavior = d3.behavior.drag()
                              .on('drag', onDrag);
circles.call(dragBehavior);

function onDrag(d) {
    var x = d3.event.x,
        y = d3.event.y;
    if ((x &gt;= radius) &amp;&amp; (x &lt;= width - radius) &amp;&amp;
        (y &gt;= radius) &amp;&amp; (y &lt;= height - radius)) {
        d3.select(this)
            .attr('transform', function () {
                return 'translate(' + x + ', ' + y + ')';
            });
    }
}</pre></div><p>The behavior is created using <code class="literal">d3.behavior.drag()</code>. This object then requires us to tell it that we are interested in listening to <code class="literal">drag</code> events. You can also specify handlers for <code class="literal">dragstart</code> and <code class="literal">dragged</code> events to identify the start and completion of a drag behavior.</p><p>Next, we need to inform D3.js to hook up the behavior to SVG elements. This is done by using the <code class="literal">.call()</code> function on the selection. As we saw when rendering axes, the function we specified will be called <a id="id370" class="indexterm"/>by D3.js during the rendering of each selected item. In this case, this will be our drag behavior, and hence, the implementation of this function can perform all the event processing needed for dragging an SVG element on our behalf.</p><p>Our event handler for the drag behavior is then called whenever the user drags an associated SVG element. This function first retrieves the new <code class="literal">x</code> and <code class="literal">y</code> position for the item being dragged from the <code class="literal">d3.event</code> object. These values are computed and set by D3.js prior to this function being called.</p><p>All that is required at this point is to set a new transform for the respective SVG element to move it into the new position. This example also checks that the circle is still completely within the SVG element and only sets the new position if that is <code class="literal">true</code>.</p></div><div class="section" title="Pan and zoom"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Pan and zoom</h2></div></div></div><p>Panning and zooming <a id="id371" class="indexterm"/>are two common techniques in data visualization. Panning <a id="id372" class="indexterm"/>allows the user to drag the entire visual around the screen. This exposes visuals that would otherwise be rendered outside of the bounds of the visual area. A common scenario for panning is to move a map around to expose areas previously out of view.</p><p>Zooming allows you to scale up or down the perceived distance of the user from the visual. This can be used to make small items bigger or to zoom out to see items that were too big or out of the extent of the visual display.</p><p>Both panning and zooming are implemented by the same D3.js behavior, <code class="literal">d3.behavior.zoom()</code>. The following example demonstrates its use:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note105"/>Note</h3><p>bl.ock (8.5): <a class="ulink" href="http://goo.gl/tEY0hm">http://goo.gl/tEY0hm</a>
</p></div></div><p>When running this <a id="id373" class="indexterm"/>example, you can not only drag the circles, but you can drag the <a id="id374" class="indexterm"/>background to move all the circles at once (the pan) and use your mouse wheel to zoom in and out:</p><div class="mediaobject"><img src="graphics/B04230_08_05.jpg" alt="Pan and zoom"/></div><p>There are a few small changes to the previous example for adding these additional features. These start with the declaration of the zoom behavior:</p><div class="informalexample"><pre class="programlisting">var zoomBehavior = d3.behavior.zoom()
    .scaleExtent([0.1, 10])
    .on('zoom', onZoom);</pre></div><p>The initial zoom level is <code class="literal">1.0</code>. The call <code class="literal">to .scaleExtent()</code> informs the behavior that it should zoom down to <code class="literal">0.1</code>, one-tenth of the original size, and up to <code class="literal">10</code>, or 10x of the original. Moreover, the behavior should call the <code class="literal">onZoom()</code> function when zoom events occur .</p><p>Now we create the main SVG element and attach the zoom behavior to it using <code class="literal">.call()</code>:</p><div class="informalexample"><pre class="programlisting">var svg = d3.select('body')
    .append('svg')
    .attr({
        width: width,
        height: height
    })
    .call(zoomBehavior)
    .append('g');</pre></div><p>The code also appends a group element to the SVG element and the <code class="literal">svg</code> variable then refers to this group. The pan and zoom events are routed by the top level SVG element to our handler, which then sets the translate and scale factor on this group, therefore creating the effects on the circles.</p><p>Now we just need to implement the <code class="literal">zoomIt</code> function:</p><div class="informalexample"><pre class="programlisting">function onZoom() {
    svg.attr('transform', 'translate(' + d3.event.translate + 
              ')' + 'scale(' + d3.event.scale + ')');
}</pre></div><p>Just before the behavior calls this function, it sets the <code class="literal">d3.event.translate</code> variable to represent the extent of translation that should occur on the entire visual.</p><p>The <code class="literal">d3.event.scale</code> variable is also set by D3.js to represent the appropriate level of zoom. In this example, this ranges from 0.1 to 10.</p><p>Another small change is in <a id="id375" class="indexterm"/>the way the drag behavior is declared.</p><div class="informalexample"><pre class="programlisting">var dragBehavior = d3.behavior.drag()
    .on("drag", onDrag)
    .on("dragstart", function() {
        d3.event.sourceEvent.stopPropagation();
    });</pre></div><p>This is done because there will be an issue with the example if this is not modified in the preceding manner. If left as-is, the pan and zoom behavior and the drag behavior will conflict with each other. When dragging a circle, the <code class="literal">svg</code> element will also pan when it should stay in place.</p><p>By handling the <code class="literal">dragstart</code> <a id="id376" class="indexterm"/>event and calling <code class="literal">d3.event.sourceEvent.stopPropagation()</code>, we prevent this mouse event on a circle from <span class="strong"><strong>bubbling up</strong></span> to the <code class="literal">svg</code> element and starting a pan. Problem solved!</p></div></div>
<div class="section" title="Enhancing a bar graph with interactivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Enhancing a bar graph with interactivity</h1></div></div></div><p>Now let's <a id="id377" class="indexterm"/>apply what we have learned about mouse event handling to create an interactive bar graph. Mouse events on a bar chart can provide useful contextual information to the person interacting with the graph.</p><p>The data for the examples will use a stripped-down version of the life expectancy vs fertility dataset that was used in earlier chapters. This dataset will use the data for the Latin American and Caribbean economic regions only, which contain roughly 35 countries, for the year 2013.</p><p>The bars in the examples will represent the longevity, will be annotated at the top with the country code, and have vertically oriented text representing the actual longevity value and the full country name. The examples will omit axes and margins to keep things simple.</p><p>The code and live example for this example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note106"/>Note</h3><p>bl.ock (8.6): <a class="ulink" href="http://goo.gl/8jb9Rn">http://goo.gl/8jb9Rn</a>
</p></div></div><p>This interaction pattern can be used to visually accentuate a particular bar in a bar chart when the mouse is moved over it. We have seen this when using <code class="literal">mouseenter</code> and <code class="literal">mouseout</code> events <a id="id378" class="indexterm"/>earlier as applied to circles. Here, we will use it to highlight the bar:</p><div class="mediaobject"><img src="graphics/B04230_08_06.jpg" alt="Enhancing a bar graph with interactivity"/></div><p>The rectangles representing the bars are created with the following code:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr({
        width: barWidth,
        height: 0,
        y: height
    })</pre></div><p>After the creation of the bars, the code hooks up the <code class="literal">mouseover</code> and <code class="literal">mouseout</code> events. The <code class="literal">mouseover</code> event makes the vertical text completely opaque and sets the bar color to orange:</p><div class="informalexample"><pre class="programlisting">    .on('mouseover', function (d) {
        d3.select('text.vert#' + d.CountryCode)
          .style('opacity', maxOpacity);
        d3.select(this).attr('fill', 'orange');
    })</pre></div><p>The <code class="literal">mouseout</code> event animates and sets the text opacity back to the original value and starts an animation to set the color back to its original shade. This animation gives the appearance of mouse trails when moving across the bars:</p><div class="informalexample"><pre class="programlisting">    .on('mouseout', function (d) {
        d3.select('text.vert#' + d.CountryCode)
          .style('opacity', minOpacity);
        d3.select(this)
          .transition()
          .duration(returnToColorDuration)
          .attr('fill', 'rgb(0, 0, ' + 
                         Math.floor(colorScale(d.LifeExp)) + ')');
    })</pre></div><p>The last portion of the <a id="id379" class="indexterm"/>selection creating the bars performs an animation to make the bars grow and transition from black to their eventual colors which the graph loads:</p><div class="informalexample"><pre class="programlisting">    .transition()
    .duration(barGrowDuration)
    .attr({
        height: function (d) { return yScale(d.LifeExp); },
        x: function (d, i) { return xScale(i); },
        y: function (d) {
            return height - yScale(d.LifeExp);
        },
        fill: function (d) {
            return 'rgb(0, 0, ' + 
                   Math.floor(colorScale(d.LifeExp)) + ')';
        }
    });</pre></div><p>To also enhance the presentation of the underlying information, we will place two pieces of data on each bar: the country code as horizontal text at the top and a piece of vertical text which shows the actual value of the datum and the full name of the country. The following code creates the horizontal text:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('text')
    .data(data)
    .enter()
    .append('text')
    .text(function (d) { return d.CountryCode; })
    .attr({
        x: function (d, i) { return xScale(i) + barWidth / 2; },
        y: height,
        fill: 'white',
        'text-anchor': 'middle',
        'font-family': 'sans-serif',
        'font-size': '11px'
    })
    .transition()
    .duration(barGrowDuration)
    .attr('y', function (d) { 
                      return height - yScale(d.LifeExp) + 
                                      horzTextOffsetY; });</pre></div><p>The vertical <a id="id380" class="indexterm"/>text is created by the following code:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('text.vert')
    .data(data)
    .enter()
    .append('text')
    .text(function (d) { return d.LifeExp.toFixed(2) + ' ' +
                                d.CountryName; })
    .attr({
        id: function (d) { return d.CountryCode; },
        opacity: minOpacity,
        transform: function (d, i) {
            var x = xScale(i) + halfBarWidth – 
                    verticalTextOffsetX;
            var y = height - yScale(d.LifeExp) + 
                    verticalTextOffsetY;
            return 'translate(' + x + ',' + y + ')rotate(90)';
        },
        'class': 'vert',
        'font-family': 'sans-serif',
        'font-size': 11,
        'fill': 'white'
    });</pre></div></div>
<div class="section" title="Highlighting selected items using brushes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Highlighting selected items using brushes</h1></div></div></div><p>A <span class="strong"><strong>brush</strong></span> in D3.js <a id="id381" class="indexterm"/>provides the ability for the user to interact with your visualization by allowing the selection of one or more visual elements (and the underlying data items) using the mouse.</p><p>This is a very important concept in exploratory data analysis and visualization, as it allows users to easily drill in and out of data or select specific data items for further analysis.</p><p>Brushing in D3.js is very flexible, and how you implement it depends upon the type of visualization you <a id="id382" class="indexterm"/>are presenting to the user. We will look at several examples or brushes and then implement a real example that lets us use a brush to examine stock data.</p><div class="section" title="Online examples of brushes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec48"/>Online examples of brushes</h2></div></div></div><p>To understand <a id="id383" class="indexterm"/>brushes, let's first take a look at several brush examples on the Internet. These are all examples available on the web that you can go and play with.</p><p>The following brush shows the use of rectangular selection for selecting data that is within the brush (<a class="ulink" href="http://bl.ocks.org/mbostock/4343214">http://bl.ocks.org/mbostock/4343214</a>):</p><div class="mediaobject"><img src="graphics/B04230_08_07.jpg" alt="Online examples of brushes"/></div><p>Another example of this brushing is the scatterplot matrix brush at <a class="ulink" href="http://bl.ocks.org/mbostock/4063663">http://bl.ocks.org/mbostock/4063663</a>. This example is notable for the way in which you can select points on any one of the scatter plots. The app then selects the points on all the other plots so that the data is highlighted on those too:</p><div class="mediaobject"><img src="graphics/B04230_08_08.jpg" alt="Online examples of brushes"/></div><p>The following <a id="id384" class="indexterm"/>example demonstrates using a brush to select a point within a force-directed network visualization (<a class="ulink" href="http://bl.ocks.org/mbostock/4565798">http://bl.ocks.org/mbostock/4565798</a>):</p><div class="mediaobject"><img src="graphics/B04230_08_09.jpg" alt="Online examples of brushes"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note107"/>Note</h3><p>We will learn about force-directed network visualizations in greater detail in <a class="link" href="ch11.html" title="Chapter 11. Visualizing Information Networks">Chapter 11</a>, <span class="emphasis"><em>Visualizing Information Networks</em></span>.</p></div></div><p>The creation of custom brush handles is a common scenario you will see when using brushes. Handles provide you a means of providing a custom rendering of the edges of the brush to provide a visual cue to the user.</p><p>As an example of a <a id="id385" class="indexterm"/>custom brush, the following creates semicircles as the handles: <a class="ulink" href="http://bl.ocks.org/mbostock/4349545">http://bl.ocks.org/mbostock/4349545</a>.</p><p>You can resize the brush by dragging either handle and reposition it by dragging the area between the handles:</p><div class="mediaobject"><img src="graphics/B04230_08_10.jpg" alt="Online examples of brushes"/></div><p>The last example of a brush (before we create our own) is the following, which demonstrates a concept referred to as <code class="literal">focus + context</code>:</p><div class="mediaobject"><img src="graphics/B04230_08_11.jpg" alt="Online examples of brushes"/></div><p>In this example, the brush is drawn atop the smaller graph (the context). The context graph is static in nature, showing a summary of the entire range of data. As the brush is changed upon the context, the larger graph (the focus) animates in real-time while the brush is changed.</p><p>In the next section, we will examine creating a similar version of this graph which utilizes financial data, a common domain for this type of interactive visualization.</p></div><div class="section" title="Implementing focus + context"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec49"/>Implementing focus + context</h2></div></div></div><p>Now let's <a id="id386" class="indexterm"/>examine how to implement <span class="strong"><strong>focus + context</strong></span>. The following example that we will use will apply this concept to a series of stock data:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note108"/>Note</h3><p>bl.ock (8.7): <a class="ulink" href="http://goo.gl/Niyc56">http://goo.gl/Niyc56</a>
</p></div></div><p>The resulting graph will look like the following graph:</p><div class="mediaobject"><img src="graphics/B04230_08_12.jpg" alt="Implementing focus + context"/></div><p>The top graph is the focus of the chart and represents the detail of the stock data that we are examining. The bottom graph is the context and is always a plot of the full series of data. In this example, we focus on data from just before the start of 2010 until just after the start of 2012.</p><p>The context <a id="id387" class="indexterm"/>area supports brushing. You can create a new brush by clicking on the context graph and dragging the mouse to select the extents of the brush. The brush can then be slid back and forth by dragging it, and it can be resized on the left and right by dragging either boundary. The focus area will always display the details of the area selected by the context.</p><p>To create this visualization, we will be drawing two different graphs, and hence, we need to layout the vertical areas for each and create the main SVG element with a size enough to hold both:</p><div class="informalexample"><pre class="programlisting">var width = 960, height = 600;

var margins = { top: 10, left: 50, right: 50, 
                bottom: 50, between: 50 };

var bottomGraphHeight = 50;
var topGraphHeight = height - (margins.top + margins.bottom + margins.between + bottomGraphHeight);
var graphWidths = width - margins.left - margins.right;</pre></div><p>This example will also require the creation of a clipping area. As the line drawn in the focus area scales, it may be drawn overlapping on the left with the <span class="emphasis"><em>y</em></span> axis. The clipping area prevents the line from flowing off to the left over the axis:</p><div class="informalexample"><pre class="programlisting">svg.append('defs')
    .append('clipPath')
    .attr('id', 'clip')
    .append('rect')
    .attr('width', width)
    .attr('height', height);</pre></div><p>This clipping rectangle is referred to in the styling for the lines. When the lines are drawn, they will be clipped to this boundary. We will see how this is specified when examining the function to style the lines.</p><p>Now we add two groups that will hold the renderings for both the focus and context graphs:</p><div class="informalexample"><pre class="programlisting">var focus = svg
    .append('g')
    .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')');

var context = svg.append('g')
    .attr('class', 'context')
    .attr('transform', 'translate(' + margins.left + ',' +
            (margins.top + topGraphHeight + margins.between) + ')');</pre></div><p>This visual <a id="id388" class="indexterm"/>requires one <span class="emphasis"><em>y</em></span> axis, two <span class="emphasis"><em>x</em></span> axes, and the appropriate scales for each. These are created with the following code:</p><div class="informalexample"><pre class="programlisting">var xScaleTop = d3.time.scale().range([0, graphWidths]),
    xScaleBottom = d3.time.scale().range([0, graphWidths]),
    yScaleTop = d3.scale.linear().range([topGraphHeight, 0]),
    yScaleBottom = d3.scale.linear()
                     .range([bottomGraphHeight, 0]);

var xAxisTop = d3.svg.axis().scale(xScaleTop)
                 .orient('bottom'),
    xAxisBottom = d3.svg.axis().scale(xScaleBottom)
                        .orient('bottom');
var yAxisTop = d3.svg.axis().scale(yScaleTop).orient('left');</pre></div><p>We will be drawing two lines, so we create the two line generators, one for each of the lines:</p><div class="informalexample"><pre class="programlisting">var lineTop = d3.svg.line()
    .x(function (d) { return xScaleTop(d.date); })
    .y(function (d) { return yScaleTop(d.close); });

var lineBottom = d3.svg.line()
    .x(function (d) { return xScaleBottom(d.date); })
    .y(function (d) { return yScaleBottom(d.close); });</pre></div><p>The last thing we need to do before loading the data and actually rendering it is to create our brush using <code class="literal">d3.svg.brush()</code>:</p><div class="informalexample"><pre class="programlisting">var brush = d3.svg.brush()
    .x(xScaleBottom)
    .on('brush', function brushed() {
        xScaleTop.domain(brush.empty() ? xScaleBottom.domain() : 
                                         brush.extent());
        focus.select('.x.axis').call(xAxisTop);
    });</pre></div><p>This preceding snippet informs the brush that we want to brush along the <code class="literal">x</code> values using the scale defined in <code class="literal">xScaleBottom</code>. Brushes are event-driven and will handle the <code class="literal">brush</code> event, which is raised every time the brush is moved or resized.</p><p>And finally, the last major thing the code does is load the data and establish the initial visuals. You've seen this code before, so we won't explain it step by step. In short, it consists of loading the data, setting the domains on the scales, and adding and drawing the axes and lines:</p><div class="informalexample"><pre class="programlisting">d3.tsv('https://gist.githubusercontent.com/d3byex/b6b753b6ef178fdb06a2/raw/0c13e82b6b59c3ba195d7f47c33e3fe00cc3f56f/aapl.tsv', function (error, data) {
    data.forEach(function (d) {
        d.date = d3.time.format('%d-%b-%y').parse(d.date);
        d.close = +d.close;
    });

    xScaleTop.domain(d3.extent(data, function (d) { 
                  return d.date; 
    }));
    yScaleTop.domain(d3.extent(data, function (d) { 
        return d.close; 
    }));
    xScaleBottom.domain(d3.extent(data, function (d) { 
        return d.date; 
    }));
    yScaleBottom.domain(d3.extent(data, function (d) { 
        return d.close; 
    }));

    var topXAxisNodes = focus.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(' + 0 + ',' + 
                           (margins.top + topGraphHeight) + ')')
        .call(xAxisTop);
    styleAxisNodes(topXAxisNodes, 0);

    focus.append('path')
        .datum(data)
        .attr('class', 'line')
        .attr('d', lineTop);

    var topYAxisNodes = focus.append('g')
        .call(yAxisTop);
    styleAxisNodes(topYAxisNodes);

    context.append('path')
        .datum(data)
        .attr('class', 'line')
        .attr('d', lineBottom);

    var bottomXAxisNodes = context.append('g')
        .attr('transform', 'translate(0,' + 
                           bottomGraphHeight + ')')
        .call(xAxisBottom);
    styleAxisNodes(bottomXAxisNodes, 0);

    context.append('g')
        .attr('class', 'x brush')
        .call(brush)
        .selectAll('rect')
        .attr('y', -6)
        .attr('height', bottomGraphHeight + 7);

    context.selectAll('.extent')
        .attr({
            stroke: '#000',
            'fill-opacity': 0.125,
            'shape-rendering': 'crispEdges'
        });

    styleLines(svg);
});</pre></div><p>Congratulations! You <a id="id389" class="indexterm"/>have stepped through creating a fairly complicated interactive display of stock data. But the beauty is that through the underlying capabilities of D3.js, it was comprised of a relatively small set of simple steps that result in <span class="strong"><strong>Beautiful Data</strong></span>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, you learned how to use mouse events provided by D3.js to create interactive visualization. We started by explaining how to hook up mouse events and respond to them, changing the visualization as the events occurred. Then we examined behaviors and how we can use them to implement drag, pan, and zoom, which allow the user to move around data, take a closer look, as well as zoom in and out. Finally, we covered brushing and how it can be used to select multiple visuals/data items, ending with a slick example of applying <span class="strong"><strong>focus + context</strong></span> to visualize financial data.</p><p>In the next chapter on layouts, we will move a little higher up the visual stack of D3.js to examine layouts, which are essentially generators for complex data visualizations.</p></div></body></html>