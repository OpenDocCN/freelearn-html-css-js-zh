<html><head></head><body>
<div id="_idContainer087" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor238" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-127" class="calibre5"><a id="_idTextAnchor239" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Asynchronous Programming Performance Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">A key strength of JavaScript runtimes is the event loop, which couples “non-blocking input/output” within a single-threaded execution model. </span><span class="kobospan" id="kobo.3.2">This means JavaScript is great for high-concurrency systems as long as they are not compute-bound systems (i.e., </span><span><span class="kobospan" id="kobo.4.1">they’re IO-bound).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">With the asynchronous and non-blocking IO, JavaScript has strong built-ins to orchestrate requests. </span><span class="kobospan" id="kobo.5.2">In this chapter, we’ll cover the </span><span><span class="kobospan" id="kobo.6.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Sequential and parallel asynchronous operation patterns in JavaScript, both with Promises only and </span><span><span class="kobospan" id="kobo.8.1">with async/await</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">The cancellation and timeout of fetch requests </span><span><span class="kobospan" id="kobo.10.1">with AbortController</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Advanced asynchronous operation patterns: throttling, debouncing, </span><span><span class="kobospan" id="kobo.12.1">and batching</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">At the end of this chapter, you’ll be able to spot and remedy situations where the asynchronous operation orchestration could be improved </span><span><span class="kobospan" id="kobo.14.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor240" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.17.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.18.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-129" class="calibre5"><a id="_idTextAnchor241" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.19.1">Controlling sequential asynchronous operations with async/await and Promises</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.20.1">Promises </span><a id="_idIndexMarker392" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.21.1">were </span><a id="_idIndexMarker393" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.22.1">introduced in ES2015 (ES6), along with other modern </span><span><span class="kobospan" id="kobo.23.1">data structures.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">For those familiar with JavaScript prior to ES2015, asynchronous behavior was modeled with callback-based interfaces, for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.25.1">request(url, (error, response) =&gt; { /* do work with response */ })</span></strong><span class="kobospan" id="kobo.26.1">. </span><span class="kobospan" id="kobo.26.2">The key issues that Promises resolved were the chaining of asynchronous requests and issues around managing parallel requests, which we’ll cover in </span><span><span class="kobospan" id="kobo.27.1">this section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">ES2016 </span><a id="_idIndexMarker394" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.29.1">included the initial specification for the async/await syntax. </span><span class="kobospan" id="kobo.29.2">It built on top of the Promise object </span><a id="_idIndexMarker395" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.30.1">in order to write asynchronous code that didn’t involve “Promise chains,” where different Promises are processed using the </span><strong class="source-inline"><span class="kobospan" id="kobo.31.1">Promise().then</span></strong><span class="kobospan" id="kobo.32.1"> function. </span><span class="kobospan" id="kobo.32.2">Promise functionality and async/await interoperate nicely. </span><span class="kobospan" id="kobo.32.3">In fact, calling an async function returns </span><span><span class="kobospan" id="kobo.33.1">a Promise.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">We’ll </span><a id="_idIndexMarker396" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.35.1">start by showing how to use Promises to manage sequential asynchronous operations. </span><span class="kobospan" id="kobo.35.2">We’ll use </span><a id="_idIndexMarker397" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.36.1">the Fetch API (which returns a Promise) to load </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">fakestoreapi.com/auth/login</span></strong><span class="kobospan" id="kobo.38.1">. </span><span class="kobospan" id="kobo.38.2">Given a username and password, and based on the output, we’ll load all the relevant carts for that user. </span><span class="kobospan" id="kobo.38.3">Subsequently, we’ll load the relevant carts for that user using the </span><strong class="source-inline"><span class="kobospan" id="kobo.39.1">fakestoreapi.com/carts/user/{userId}</span></strong><span class="kobospan" id="kobo.40.1"> endpoint. </span><span class="kobospan" id="kobo.40.2">This request flow is visualized in the </span><span><span class="kobospan" id="kobo.41.1">following diagram.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<span class="kobospan" id="kobo.42.1"><img alt="Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests" src="image/B19109_07_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.43.1">Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.44.1">We’ll start by sending a POST request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.45.1">auth/login</span></strong><span class="kobospan" id="kobo.46.1"> endpoint. </span><span class="kobospan" id="kobo.46.2">We add </span><strong class="source-inline"><span class="kobospan" id="kobo.47.1">.then((res) =&gt; res.json())</span></strong><span class="kobospan" id="kobo.48.1">, which will wait for the initial </span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">fetch()</span></strong><span class="kobospan" id="kobo.50.1"> output Promise to resolve to a “response” (hence the </span><strong class="source-inline"><span class="kobospan" id="kobo.51.1">res</span></strong><span class="kobospan" id="kobo.52.1"> name). </span><span class="kobospan" id="kobo.52.2">We then call the </span><strong class="source-inline"><span class="kobospan" id="kobo.53.1">.json()</span></strong><span class="kobospan" id="kobo.54.1"> method on the response, which again is a Promise, which resolves to the JSON-decoded </span><span><span class="kobospan" id="kobo.55.1">response body:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.56.1">
function fetchAuthUserThenCartsPromiseThen(username,
  password) {
  return fetch('https://fakestoreapi.com/auth/login', {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((res) =&gt; res.json());
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.57.1">The </span><a id="_idIndexMarker398" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.58.1">Promise returned from </span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">res.json()</span></strong><span class="kobospan" id="kobo.60.1"> can be accessed in another </span><strong class="source-inline"><span class="kobospan" id="kobo.61.1">.then()</span></strong><span class="kobospan" id="kobo.62.1"> callback, in which </span><a id="_idIndexMarker399" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.63.1">we parse the </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">token</span></strong><span class="kobospan" id="kobo.65.1"> field, which </span><a id="_idIndexMarker400" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.66.1">is a </span><strong class="bold"><span class="kobospan" id="kobo.67.1">JSON Web Token</span></strong><span class="kobospan" id="kobo.68.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.69.1">JWT</span></strong><span class="kobospan" id="kobo.70.1">), using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.71.1">jwt-decode</span></strong></span><span><span class="kobospan" id="kobo.72.1"> package.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">We extract the </span><strong class="source-inline"><span class="kobospan" id="kobo.74.1">sub</span></strong><span class="kobospan" id="kobo.75.1"> field from the decoded token. </span><span class="kobospan" id="kobo.75.2">This is the “subject” claim, which tells us which </span><a id="_idIndexMarker401" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.76.1">user this token </span><a id="_idIndexMarker402" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.77.1">is about. </span><span class="kobospan" id="kobo.77.2">In the case of the </span><strong class="source-inline"><span class="kobospan" id="kobo.78.1">fakestoreapi</span></strong><span class="kobospan" id="kobo.79.1"> token, </span><strong class="source-inline"><span class="kobospan" id="kobo.80.1">userId</span></strong><span class="kobospan" id="kobo.81.1"> is used as the “subject” claim. </span><span class="kobospan" id="kobo.81.2">We can therefore use the </span><strong class="source-inline"><span class="kobospan" id="kobo.82.1">sub</span></strong><span class="kobospan" id="kobo.83.1"> claim as the user ID for which to load the carts in our following API call </span><span><span class="kobospan" id="kobo.84.1">to </span></span><a href="https://fakestoreapi.com/carts/user/" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.85.1">https://fakestoreapi.com/carts/user/</span></span></a><span><strong class="source-inline"><span class="kobospan" id="kobo.86.1">{userId}</span></strong></span><span><span class="kobospan" id="kobo.87.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.88.1">
import jwt_decode from 'https://esm.sh/jwt-decode';
function fetchAuthUserThenCartsPromiseThen(username,
  password) {
  return // no change to the fetch() call
    .then((res) =&gt; res.json())
    .then((responseData) =&gt; {
      const parsedValues = jwt_decode(responseData.token);
      const userId = parsedValues.sub;
      return userId;
    })
    .then((userId) =&gt;
      fetch(`https://fakestoreapi.com/carts/user/${userId}
        ?sort=desc`)
    )
    .then((res) =&gt; res.json());
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.89.1">This </span><a id="_idIndexMarker403" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.90.1">function can </span><a id="_idIndexMarker404" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.91.1">then be used as follows. </span><span class="kobospan" id="kobo.91.2">Note that a password shouldn’t be stored in the source of a production application (as it is in </span><span><span class="kobospan" id="kobo.92.1">this example).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">When </span><a id="_idIndexMarker405" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.94.1">we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.95.1">fetchAuthUserThenCartsPromiseThen</span></strong><span class="kobospan" id="kobo.96.1"> function, it makes both the </span><strong class="source-inline"><span class="kobospan" id="kobo.97.1">/auth/login</span></strong><span class="kobospan" id="kobo.98.1"> call and then the </span><strong class="source-inline"><span class="kobospan" id="kobo.99.1">/carts/user/{userId}</span></strong><span class="kobospan" id="kobo.100.1"> call, which </span><a id="_idIndexMarker406" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.101.1">means we receive an array with the relevant carts for the requested user (note </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">userId</span></strong><span class="kobospan" id="kobo.103.1"> = </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">3</span></strong><span class="kobospan" id="kobo.105.1">, which is the correct ID for the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.106.1">kevinryan</span></strong></span><span><span class="kobospan" id="kobo.107.1"> user).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.108.1">Note that we’re using async/await here to “flatten” the Promise output into </span><strong class="source-inline"><span class="kobospan" id="kobo.109.1">userCartsDataPromiseThen</span></strong><span class="kobospan" id="kobo.110.1">, which we can </span><span><span class="kobospan" id="kobo.111.1">assert on:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.112.1">
const username = 'kevinryan';
const password = 'kev02937@';
const userCartsDataPromiseThen = await
  fetchAuthUserThenCartsPromiseThen(
  username,
  password
);
assert.deepEqual(userCartsDataPromiseThen, [
  {
    __v: 0,
    date: '2020-01-01T00:00:00.000Z',
    id: 4,
    products: [
      {
        productId: 1,
        quantity: 4,
      },
    ],
    userId: 3,
  },
  {
    __v: 0,
    date: '2020-03-01T00:00:00.000Z',
    id: 5,
    products: [
      {
        productId: 7,
        quantity: 1,
      },
      {
        productId: 8,
        quantity: 1,
      },
    ],
    userId: 3,
  },
]);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.113.1">As </span><a id="_idIndexMarker407" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.114.1">we’ve just seen in the code that calls </span><strong class="source-inline"><span class="kobospan" id="kobo.115.1">fetchAuthUserThenCartsPromiseThen</span></strong><span class="kobospan" id="kobo.116.1">, the </span><a id="_idIndexMarker408" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.117.1">key benefit of async/await over </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">Promise().then()</span></strong><span class="kobospan" id="kobo.119.1"> chains is that the code is structured more similarly to </span><span><span class="kobospan" id="kobo.120.1">synchronous code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.121.1">In </span><a id="_idIndexMarker409" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.122.1">synchronous code, the </span><a id="_idIndexMarker410" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.123.1">output of an operation can be, for example, assigned to </span><span><span class="kobospan" id="kobo.124.1">a constant:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.125.1">
const output = syncGetAuthUserCarts();
console.log(output);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.126.1">Whereas with </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">Promise().then()</span></strong><span class="kobospan" id="kobo.128.1">, the output is available only in an additional </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">.</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.130.1">then</span></strong></span><span><span class="kobospan" id="kobo.131.1"> callback:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.132.1">
promisifiedGetAuthUserCarts().then((output) =&gt; {
  console.log(output);
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.133.1">What </span><strong class="source-inline"><span class="kobospan" id="kobo.134.1">await</span></strong><span class="kobospan" id="kobo.135.1"> allows us to do is to structure the code </span><span><span class="kobospan" id="kobo.136.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.137.1">
const output = await promisifiedGetAuthUserCarts();
console.log(output);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.138.1">One way to think of it is that </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">await</span></strong><span class="kobospan" id="kobo.140.1"> can unfurl Promises. </span><span class="kobospan" id="kobo.140.2">A Promise’s “resolved value”, usually only accessible in a </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">Promise().then()</span></strong><span class="kobospan" id="kobo.142.1"> callback is </span><span><span class="kobospan" id="kobo.143.1">available directly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">For </span><a id="_idIndexMarker411" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.145.1">sequential operations, this is very useful, since it makes the code structured with a set of </span><a id="_idIndexMarker412" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.146.1">variable assignments per </span><span><span class="kobospan" id="kobo.147.1">async operation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.148.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">await</span></strong><span class="kobospan" id="kobo.150.1"> operator is available at the top level of ECMAScript modules in modern runtime </span><a id="_idIndexMarker413" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.151.1">environments as part of the </span><span><span class="kobospan" id="kobo.152.1">ES2022 specification.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.153.1">However, in </span><a id="_idIndexMarker414" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.154.1">order to use </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">await</span></strong><span class="kobospan" id="kobo.156.1"> inside of a function, we need to mark the function as </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">async</span></strong><span class="kobospan" id="kobo.158.1">. </span><span class="kobospan" id="kobo.158.2">This usage of </span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">await</span></strong><span class="kobospan" id="kobo.160.1"> in </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">async</span></strong><span class="kobospan" id="kobo.162.1"> functions has been available </span><span><span class="kobospan" id="kobo.163.1">since ES2016.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">Code editors and IDEs such as Visual Studio Code provide a refactor from chained </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">Promise().then()</span></strong><span class="kobospan" id="kobo.166.1"> calls to async/await. </span><span class="kobospan" id="kobo.166.2">In our case, we can build a </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">fetchAuthUserThenCartsAsyncAwait</span></strong><span class="kobospan" id="kobo.168.1"> function </span><span><span class="kobospan" id="kobo.169.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.170.1">Instead of using </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">fetch().then(res =&gt; res.json())</span></strong><span class="kobospan" id="kobo.172.1">, we’ll first use </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">await fetch()</span></strong><span class="kobospan" id="kobo.174.1"> and then </span><span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">await authResponse.json()</span></strong></span><span><span class="kobospan" id="kobo.176.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.177.1">
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  const authResponse = await fetch('https://fakestoreapi.com/auth/login', {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  });
  const authData = await authResponse.json();
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.178.1">We now have access to </span><strong class="source-inline"><span class="kobospan" id="kobo.179.1">authData</span></strong><span class="kobospan" id="kobo.180.1">. </span><span class="kobospan" id="kobo.180.2">We can decode </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">authData.token</span></strong><span class="kobospan" id="kobo.182.1"> as before using the </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">jwt-decode</span></strong><span class="kobospan" id="kobo.184.1"> package. </span><span class="kobospan" id="kobo.184.2">This gives us access to the </span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">sub</span></strong><span class="kobospan" id="kobo.186.1"> (subject) claim, which is the </span><span><span class="kobospan" id="kobo.187.1">user ID:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.188.1">
Import jwt_decode from 'https://esm.sh/jwt-decode';
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  // no change to /auth/login API call code
  const parsedValues = jwt_decode(authData.token);
  const userId = parsedValues.sub;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.189.1">Now </span><a id="_idIndexMarker415" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.190.1">that we </span><a id="_idIndexMarker416" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.191.1">have the relevant </span><a id="_idIndexMarker417" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.192.1">user ID, we </span><a id="_idIndexMarker418" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.193.1">can call the </span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">/carts/user/{userId}</span></strong><span class="kobospan" id="kobo.195.1"> endpoint to load the </span><span><span class="kobospan" id="kobo.196.1">user’s carts:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.197.1">
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  // no change to /auth/login call or token parsing logic
  const userCartsResponse = await fetch(
    `https://fakestoreapi.com/carts/user/${userId}?sort=desc`
  );
  const userCartsResponseData = await userCartsResponse.
</span><span class="kobospan1" id="kobo.197.2">    json();
  return userCartsResponseData;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.198.1">Given the same input data as the approach using </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">Promise().then()</span></strong><span class="kobospan" id="kobo.200.1">, the loaded carts are the same. </span><span class="kobospan" id="kobo.200.2">Note, again, that passwords and credentials should not be stored in source </span><span><span class="kobospan" id="kobo.201.1">code files:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.202.1">
const username = 'kevinryan';
const password = 'kev02937@';
const userCartsDataAsyncAwait = await fetchAuthUserThenCartsAsyncAwait(
  username,
  password
);
assert.deepEqual(userCartsDataAsyncAwait, userCartsDataPromiseThen);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.203.1">One </span><a id="_idIndexMarker419" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.204.1">difference between the approaches is that with async/await, all the variables are defined </span><a id="_idIndexMarker420" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.205.1">in a single function scope, whereas the </span><strong class="source-inline"><span class="kobospan" id="kobo.206.1">Promise().then()</span></strong><span class="kobospan" id="kobo.207.1"> approach uses multiple function </span><a id="_idIndexMarker421" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.208.1">scopes (for each of the callbacks passed to </span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">.then()</span></strong><span class="kobospan" id="kobo.210.1">). </span><span class="kobospan" id="kobo.210.2">With a single large function scope, variable </span><a id="_idIndexMarker422" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.211.1">names can’t clash, which makes the code more verbose since, for example, each </span><strong class="source-inline"><span class="kobospan" id="kobo.212.1">response</span></strong><span class="kobospan" id="kobo.213.1"> object needs a qualifier to avoid variable name clashes, for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">authResponse</span></strong> <span><span class="kobospan" id="kobo.215.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">userCartsResponse</span></strong></span><span><span class="kobospan" id="kobo.217.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">The benefit of a single larger function scope is that all the outputs of previous API calls are available to subsequent ones without having to explicitly set them as values passed as a return in the callback passed </span><span><span class="kobospan" id="kobo.219.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">.then()</span></strong></span><span><span class="kobospan" id="kobo.221.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.222.1">Finally, a </span><strong class="source-inline"><span class="kobospan" id="kobo.223.1">fetch()</span></strong><span class="kobospan" id="kobo.224.1">-specific example, is that since there are multiple Promises that require handling when doing a fetch and accessing the JSON response, the await approach can be a </span><span><span class="kobospan" id="kobo.225.1">bit “noisier.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.226.1">See the two following samples. </span><span class="kobospan" id="kobo.226.2">First, with async/await, we assign a variable for the fetch </span><span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">response</span></strong></span><span><span class="kobospan" id="kobo.228.1"> value:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.229.1">
const response = await fetch(url);
const data = await response.json();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.230.1">Next, with </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">.then()</span></strong><span class="kobospan" id="kobo.232.1">, we assign only a </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">data</span></strong><span class="kobospan" id="kobo.234.1"> variable and use an arrow function to handle the </span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">.</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">json()</span></strong></span><span><span class="kobospan" id="kobo.237.1"> unfurling:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.238.1">
const data = await fetch(url).then((response) =&gt; response.json());</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.239.1">As you see, our final example is a mix of </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">async/await</span></strong><span class="kobospan" id="kobo.241.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">Promise().then()</span></strong><span class="kobospan" id="kobo.243.1"> so that the most “important” parts of the code are obvious. </span><span class="kobospan" id="kobo.243.2">The specifics of how we extract the JSON output from </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">fetch</span></strong><span class="kobospan" id="kobo.245.1"> are not necessarily core to our logic so might be better expressed </span><span><span class="kobospan" id="kobo.246.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">Promise().then()</span></strong></span><span><span class="kobospan" id="kobo.248.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.249.1">In </span><a id="_idIndexMarker423" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.250.1">general, this slight difference in style wouldn’t occur since parts of the code that are “less important,” such as how we interact with the fetch API to process a request to JSON, tend </span><a id="_idIndexMarker424" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.251.1">to be abstracted – in this case, in an HTTP client of some kind. </span><span class="kobospan" id="kobo.251.2">We would expect that the HTTP client </span><a id="_idIndexMarker425" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.252.1">could handle checking </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">response.ok</span></strong><span class="kobospan" id="kobo.254.1"> and accessing the response body as parsed JSON (</span><span><span class="kobospan" id="kobo.255.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">response.json()</span></strong></span><span><span class="kobospan" id="kobo.257.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.258.1">We’ve </span><a id="_idIndexMarker426" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.259.1">now seen how to implement sequential asynchronous operations using a Promise-only approach, an async/await-based approach, and finally, how both the async/await and Promise techniques can be used together to improve </span><a id="_idTextAnchor242" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.260.1">code readability </span><span><span class="kobospan" id="kobo.261.1">and performance.</span></span></p>
<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor243" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.262.1">Parallel asynchronous operation patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.263.1">A common </span><a id="_idIndexMarker427" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.264.1">source of bad performance is running operations sequentially that could be completed </span><span><span class="kobospan" id="kobo.265.1">in parallel.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">For example, a naive implementation of loading a cart and then the contained products would be </span><span><span class="kobospan" id="kobo.267.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<span class="kobospan" id="kobo.268.1"><img alt="Figure 7.2: Load cart then each of the three products contained from fakestoreapi" src="image/B19109_07_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.269.1">Figure 7.2: Load cart then each of the three products contained from fakestoreapi</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.270.1">In this case, the </span><a id="_idIndexMarker428" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.271.1">operation completion time is composed of the sum of </span><span><span class="kobospan" id="kobo.272.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.273.1">Request-response time for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.274.1">GET /carts/{cartId}</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.275.1">Request-response time for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">GET /products/1</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.277.1">Request-response time for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.278.1">GET /products/2</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.279.1">Request-response time for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.280.1">GET /products/3</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.281.1">There is a requirement for the </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">/products/{productId}</span></strong><span class="kobospan" id="kobo.283.1"> calls to be done after the </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">GET /carts/{cartId}</span></strong><span class="kobospan" id="kobo.285.1"> call completes since that’s where the product IDs are coming from. </span><span class="kobospan" id="kobo.285.2">What isn’t required is for each product call to wait for the previous one to complete; the calls only depend on data from the </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">GET /carts/{cartId}</span></strong><span class="kobospan" id="kobo.287.1"> call. </span><span class="kobospan" id="kobo.287.2">This is an optimization opportunity. </span><span class="kobospan" id="kobo.287.3">We can start all of the </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">GET /products/{id}</span></strong><span class="kobospan" id="kobo.289.1"> API calls together. </span><span class="kobospan" id="kobo.289.2">We get the </span><span><span class="kobospan" id="kobo.290.1">following sequence:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<span class="kobospan" id="kobo.291.1"><img alt="Figure 7.3: Load cart then each of the three products contained in parallel" src="image/B19109_07_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.292.1">Figure 7.3: Load cart then each of the three products contained in parallel</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.293.1">In this </span><a id="_idIndexMarker429" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.294.1">case, the operation completion time is composed of the sum of </span><span><span class="kobospan" id="kobo.295.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.296.1">Request-response time for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">GET /carts/{cartId}</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.298.1">The longest request-response time between </span><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">GET /products/1</span></strong><span class="kobospan" id="kobo.300.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.301.1">GET /products/2</span></strong><span class="kobospan" id="kobo.302.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">GET /products/3</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.304.1">This means we’re saving the request-response time of two API calls </span><span><span class="kobospan" id="kobo.305.1">at least.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">JavaScript is especially well suited to these workloads since its concurrency model is based on an event loop. </span><span class="kobospan" id="kobo.306.2">While JavaScript waits for an asynchronous operation to complete, it can complete other </span><span><span class="kobospan" id="kobo.307.1">synchronous operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.308.1">In layman’s terms, triggering an asynchronous operation in JavaScript is “cheap and lightweight” compared to thread-based concurrency models that are common in popular programming languages such as Java </span><span><span class="kobospan" id="kobo.309.1">and C++.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">There are multiple constructs in JavaScript that allow us to convert an array of Promises into a Promise that resolves to an array. </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">Promise.all</span></strong><span class="kobospan" id="kobo.312.1"> is one </span><span><span class="kobospan" id="kobo.313.1">such construct.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">Implementing the scenario we described earlier, where we load a cart and then load the relevant product details, would look as follows with </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">Promise.all</span></strong> <span><span class="kobospan" id="kobo.316.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.317.1">Promise().then</span></strong></span><span><span class="kobospan" id="kobo.318.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.319.1">First, we need to make the API call to load the cart and extract the JSON in the </span><span><span class="kobospan" id="kobo.320.1">response body:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.321.1">
function fetchCartPromiseThen(cartId = '1') {
  return fetch(`https://fakestoreapi.com/carts/${cartId}`).
</span><span class="kobospan1" id="kobo.321.2">    then((res) =&gt;
    res.json()
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.322.1">We then </span><a id="_idIndexMarker430" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.323.1">need to set up the fetching of the right product URLs once the request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">/carts/{cartId}</span></strong><span class="kobospan" id="kobo.325.1"> URL has loaded. </span><span class="kobospan" id="kobo.325.2">The pattern used in order to execute our code after the fetch completes uses </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">.then()</span></strong><span class="kobospan" id="kobo.327.1"> on the </span><span><span class="kobospan" id="kobo.328.1">returned promise:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.329.1">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then((cart) =&gt; {
      const productUrls = cart.products.map(
        (p) =&gt; `https://fakestoreapi.com/products/$
           {p.productId}`
      );
    })
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.330.1">Next, we’ll use </span><strong class="source-inline"><span class="kobospan" id="kobo.331.1">Promise.all</span></strong><span class="kobospan" id="kobo.332.1"> to load all the product URLs with </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">fetch</span></strong><span class="kobospan" id="kobo.334.1">. </span><span class="kobospan" id="kobo.334.2">Since our goal is to return both the cart </span><em class="italic"><span class="kobospan" id="kobo.335.1">and</span></em><span class="kobospan" id="kobo.336.1"> the products, we’ll return </span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">{ cart }</span></strong><span class="kobospan" id="kobo.338.1"> as the first item in the array we’re passing to </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">Promise.all()</span></strong><span class="kobospan" id="kobo.340.1">. </span><span class="kobospan" id="kobo.340.2">The rest of the array passed to </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">Promise.all</span></strong><span class="kobospan" id="kobo.342.1"> will be the Promises generated by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">fetch().then((res) =&gt; res.json())</span></strong><span class="kobospan" id="kobo.344.1"> on each of the product URLs. </span><span class="kobospan" id="kobo.344.2">In order to do this, we use the spread operation (</span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">...</span></strong><span class="kobospan" id="kobo.346.1">) on </span><strong class="source-inline"><span class="kobospan" id="kobo.347.1">...productUrls.map(/* mapping function */)</span></strong><span class="kobospan" id="kobo.348.1"> in </span><span><span class="kobospan" id="kobo.349.1">the array:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.350.1">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then((cart) =&gt; {
      // no change to productUrls generation
      return Promise.all([
        { cart },
        ...productUrls.map((url) =&gt; fetch(url).then
          ((res) =&gt; res.json())),
      ]);
    })
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.351.1">Finally, we’re </span><a id="_idIndexMarker431" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.352.1">going to create an object with all the cart fields and a new products field based on the output of the </span><strong class="source-inline"><span class="kobospan" id="kobo.353.1">/</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.354.1">products/{id}</span></strong></span><span><span class="kobospan" id="kobo.355.1"> fetches:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.356.1">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then(([prev, ...products]) =&gt; {
      return {
        ...prev,
        products,
      };
    });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.357.1">We can test the output of the function by loading cart </span><span><span class="kobospan" id="kobo.358.1">ID </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">1</span></strong></span><span><span class="kobospan" id="kobo.360.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.361.1">
const cartDataFromPromiseThen = await fetchCartPromiseThen
  ('1');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.362.1">The cart is as we expect – it returns </span><span><span class="kobospan" id="kobo.363.1">three products:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.364.1">
assert.deepEqual(cartDataFromPromiseThen.cart, {
  __v: 0,
  date: '2020-03-02T00:00:00.000Z',
  id: 1,
  products: [
    {
      productId: 1,
      quantity: 4,
    },
    {
      productId: 2,
      quantity: 1,
    },
    {
      productId: 3,
      quantity: 6,
    },
  ],
  userId: 1,
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.365.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">products</span></strong><span class="kobospan" id="kobo.367.1"> field of </span><a id="_idIndexMarker432" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.368.1">our response contains the correct items in positions at indexes 0, 1, </span><span><span class="kobospan" id="kobo.369.1">and 2:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.370.1">
assert.deepEqual(cartDataFromPromiseThen.products[0], {
  category: "men's clothing",
  description:
    'Your perfect pack for everyday use and walks in the
     forest. </span><span class="kobospan1" id="kobo.370.2">Stash your laptop (up to 15 inches) in the
     padded sleeve, your everyday',
  id: 1,
  image: 'https://fakestoreapi.com/img/
    81fPKd-2AYL._AC_SL1500_.jpg',
  price: 109.95,
  rating: {
    count: 120,
    rate: 3.9,
  },
  title: 'Fjallraven - Foldsack No. </span><span class="kobospan1" id="kobo.370.3">1 Backpack, Fits 15
    Laptops',
});
assert.deepEqual(cartDataFromPromiseThen.
</span><span class="kobospan1" id="kobo.370.4">  products[1], {
  category: "men's clothing",
  description:
    'Slim-fitting style, contrast raglan long sleeve, three-button henley placket, light weight &amp; soft fabric for breathable and comfortable wearing. </span><span class="kobospan1" id="kobo.370.5">And Solid stitched shirts with round neck made for durability and a great fit for casual fashion wear and diehard baseball fans. </span><span class="kobospan1" id="kobo.370.6">The Henley style round neckline includes a three-button placket.',
  id: 2,
  image:
    'https://fakestoreapi.com/img/
       71-3HjGNDUL._AC_SY879._SX._UX._SY._UY_.jpg',
  price: 22.3,
  rating: {
    count: 259,
    rate: 4.1,
  },
  title: 'Mens Casual Premium Slim Fit T-Shirts ',
});
assert.deepEqual(cartDataFromPromiseThen.products[2], {
  category: "men's clothing",
  description:
    'great outerwear jackets for Spring/Autumn/Winter, suitable for many occasions, such as working, hiking, camping, mountain/rock climbing, cycling, traveling or other outdoors. </span><span class="kobospan1" id="kobo.370.7">Good gift choice for you or your family member. </span><span class="kobospan1" id="kobo.370.8">A warm hearted love to Father, husband or son in this thanksgiving or Christmas Day.',
  id: 3,
  image: 'https://fakestoreapi.com/img/
    71li-ujtlUL._AC_UX679_.jpg',
  price: 55.99,
  rating: {
    count: 500,
    rate: 4.7,
  },
  title: 'Mens Cotton Jacket',
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.371.1">We’ve now seen how to leverage </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">Promise.all</span></strong><span class="kobospan" id="kobo.373.1"> to run multiple promises in parallel and handle their output with </span><span><span class="kobospan" id="kobo.374.1">one handler.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.375.1">You’ll have noticed the “trick” we did by passing the </span><strong class="source-inline"><span class="kobospan" id="kobo.376.1">{ cart }</span></strong><span class="kobospan" id="kobo.377.1"> object in </span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">Promise.all</span></strong><span class="kobospan" id="kobo.379.1"> and then extracting the first item of the resolved array as the previous response. </span><span class="kobospan" id="kobo.379.2">This is a limitation of </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">Promise().then()</span></strong><span class="kobospan" id="kobo.381.1"> chaining, as mentioned in the </span><em class="italic"><span class="kobospan" id="kobo.382.1">Controlling sequential asynchronous operations with async/await and Promises</span></em><span class="kobospan" id="kobo.383.1"> section. </span><span class="kobospan" id="kobo.383.2">Each function argument to </span><strong class="source-inline"><span class="kobospan" id="kobo.384.1">.then()</span></strong><span class="kobospan" id="kobo.385.1"> gets its </span><span><span class="kobospan" id="kobo.386.1">own scope:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.387.1">
Promise.resolve({ id: 1 })
  .then((cart) =&gt; {
    const productUrls = [];
    return Promise.all([{ cart }, ...productUrls.map(()
      =&gt; {})]);
  })
  .then(([prev, ...products]) =&gt; {});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.388.1">An alternative </span><a id="_idIndexMarker433" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.389.1">way to write this is to store the cart in the </span><span><span class="kobospan" id="kobo.390.1">function scope:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.391.1">
function fetchCartFunctionVariable() {
  let loadedCart = null;
  return Promise.resolve({ id: 1 })
    .then((cart) =&gt; {
      loadedCart = cart;
      const productUrls = [];
      return Promise.all(productUrls.map(() =&gt; {}));
    })
    .then((products) =&gt; ({
      cart: loadedCart,
      products,
    }));
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.392.1">This works as expected. </span><span class="kobospan" id="kobo.392.2">We’ve obviously removed the actual cart and product fetching logic from the API, but the cart that </span><strong class="source-inline"><span class="kobospan" id="kobo.393.1">{ id: 1 }</span></strong><span class="kobospan" id="kobo.394.1"> relates to, which we resolved in the initial </span><strong class="source-inline"><span class="kobospan" id="kobo.395.1">Promise.resolve()</span></strong><span class="kobospan" id="kobo.396.1"> function call, is cached through the </span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">.</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.398.1">then()</span></strong></span><span><span class="kobospan" id="kobo.399.1"> calls:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.400.1">
assert.deepEqual(await fetchCartFunctionVariable(), {
  cart: { id: 1 },
  products: [],
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.401.1">Another way to improve our implementation without resorting to function-scoped variables, which can be hard to keep track of, is to convert it to </span><span><span class="kobospan" id="kobo.402.1">use async/await.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.403.1">Our logic would be as follows. </span><span class="kobospan" id="kobo.403.2">We start by loading the cart and converting the JSON </span><span><span class="kobospan" id="kobo.404.1">response body:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.405.1">
async function fetchCartAsyncAwait(cartId = '1') {
  const cart = await fetch(`https://fakestoreapi.com/carts/${cartId}`).then(
    (res) =&gt; res.json()
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.406.1">Once the </span><a id="_idIndexMarker434" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.407.1">cart is loaded, we proceed to fetch the relevant products by generating URLs based on the </span><strong class="source-inline"><span class="kobospan" id="kobo.408.1">cart.products</span></strong><span class="kobospan" id="kobo.409.1"> contents (mainly the </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">productId</span></strong><span class="kobospan" id="kobo.411.1"> field). </span><span class="kobospan" id="kobo.411.2">We also fetch these URLs </span><span><span class="kobospan" id="kobo.412.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">Promise.all</span></strong></span><span><span class="kobospan" id="kobo.414.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.415.1">
async function fetchCartAsyncAwait(cartId = '1') {
  // no change to cart fetching
  const productUrls = cart.products.map(
    (p) =&gt; `https://fakestoreapi.com/products/${p.productId}`
  );
  const products = await Promise.all(
    productUrls.map((url) =&gt; fetch(url).then((res)
      =&gt; res.json()))
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.416.1">Finally, we can return the cart and the </span><span><span class="kobospan" id="kobo.417.1">loaded products:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.418.1">
async function fetchCartAsyncAwait(cartId = '1') {
  // no changes to cart or products fetching
  return {
    cart,
    products,
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.419.1">The implementation is equivalent to our previous, strict </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">Promise().then()</span></strong><span class="kobospan" id="kobo.421.1">-based one, as the following </span><span><span class="kobospan" id="kobo.422.1">checks attest:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.423.1">
const cartDataFromAsyncAwait = await fetchCartAsyncAwait
  ('1');
assert.deepEqual(cartDataFromPromiseThen.cart,
  cartDataFromAsyncAwait.cart);
assert.deepEqual(
  cartDataFromPromiseThen.products,
  cartDataFromAsyncAwait.products
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.424.1">The benefit of using async/await in this case was, again, an increase in readability. </span><span class="kobospan" id="kobo.424.2">The syntax gets </span><a id="_idIndexMarker435" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.425.1">less in the way than chained </span><strong class="source-inline"><span class="kobospan" id="kobo.426.1">.then()</span></strong><span class="kobospan" id="kobo.427.1"> calls and we don’t have to resort to either returning the first response as an item in </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">Promise.all([{ cart }])</span></strong><span class="kobospan" id="kobo.429.1"> or adding a function-scoped variable that we store the </span><span><span class="kobospan" id="kobo.430.1">cart in.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">We’ve now seen how to leverage </span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">Promise.all</span></strong><span class="kobospan" id="kobo.433.1"> to complete asynchronous operations in parallel both with a </span><strong class="source-inline"><span class="kobospan" id="kobo.434.1">Promise().then()</span></strong><span class="kobospan" id="kobo.435.1">-exclusive approach and with judicious refactors to </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">async/await</span></strong><span class="kobospan" id="kobo.437.1"> to simplify </span><span><span class="kobospan" id="kobo.438.1">the code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">Next, we’ll see how we can cancel and time out requ</span><a id="_idTextAnchor244" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.440.1">ests with </span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">AbortController</span></strong> <span><span class="kobospan" id="kobo.442.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor245" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.443.1">Asynchronous cancellation and timeouts with AbortController</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.444.1">Another source </span><a id="_idIndexMarker436" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.445.1">of bad performance </span><a id="_idIndexMarker437" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.446.1">in applications in general is </span><a id="_idIndexMarker438" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.447.1">doing work that’s not necessary. </span><span class="kobospan" id="kobo.447.2">In </span><a id="_idIndexMarker439" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.448.1">the context of a JavaScript web application, one of the types of “work” that can be unnecessary (and therefore a drain on performance) is having HTTP requests that aren’t required any more. </span><span class="kobospan" id="kobo.448.2">For example, in a photo gallery system or any paginated system, when moving across photos, the request for the previous photo might not have completed before the next one is started. </span><span class="kobospan" id="kobo.448.3">In this case, the previous request data is not necessary any more, as we’re essentially on a completely </span><span><span class="kobospan" id="kobo.449.1">different page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.450.1">In these instances, cancelling the request might </span><span><span class="kobospan" id="kobo.451.1">be useful.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.452.1">AbortController</span></strong><span class="kobospan" id="kobo.453.1"> is a Web/DOM API that allows us to abort web requests. </span><span class="kobospan" id="kobo.453.2">It’s created </span><a id="_idIndexMarker440" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.454.1">using its constructor, </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">new AbortController</span></strong><span class="kobospan" id="kobo.456.1">, and controlling a request (to potentially cancel it) is </span><a id="_idIndexMarker441" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.457.1">done with the </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">AbortController().signal</span></strong><span class="kobospan" id="kobo.459.1"> value, which is an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">AbortSignal</span></strong></span><span><span class="kobospan" id="kobo.461.1"> object.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.462.1">We </span><a id="_idIndexMarker442" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.463.1">instantiate the controller using </span><a id="_idIndexMarker443" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.464.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">new AbortController()</span></strong><span class="kobospan" id="kobo.466.1"> constructor call. </span><span class="kobospan" id="kobo.466.2">If we want to make a </span><strong class="source-inline"><span class="kobospan" id="kobo.467.1">fetch</span></strong><span class="kobospan" id="kobo.468.1"> call cancellable, we pass </span><strong class="source-inline"><span class="kobospan" id="kobo.469.1">abortController.signal</span></strong><span class="kobospan" id="kobo.470.1"> as the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">signal</span></strong></span><span><span class="kobospan" id="kobo.472.1"> option:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.473.1">
function fetchWithCancel(url) {
  const abortController = new AbortController();
  const response = fetch(url, { signal:
    abortController.signal }).then((res) =&gt;
    res.json()
  );
  return {
    response,
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.474.1">If we want to cancel the </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">fetch</span></strong><span class="kobospan" id="kobo.476.1"> request, we can then call </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">abortController.cancel</span></strong><span class="kobospan" id="kobo.478.1">. </span><span class="kobospan" id="kobo.478.2">We’ll add this as a </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">cancel</span></strong><span class="kobospan" id="kobo.480.1"> function on the </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">fetchWithCancel</span></strong> <span><span class="kobospan" id="kobo.482.1">returned output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.483.1">
function fetchWithCancel(url) {
  // no changes to contents
  return {
    // no changes to other keys in the object
    cancel: () =&gt; abortController.abort(),
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.484.1">Finally, we need to ensure that when we see </span><strong class="source-inline"><span class="kobospan" id="kobo.485.1">AbortError</span></strong><span class="kobospan" id="kobo.486.1">, we handle it. </span><span class="kobospan" id="kobo.486.2">In this case, we’ll handle it with a </span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">Promise().catch</span></strong><span class="kobospan" id="kobo.488.1"> handler, which, on seeing an </span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">AbortError</span></strong><span class="kobospan" id="kobo.490.1">, will return ‘</span><strong class="source-inline"><span class="kobospan" id="kobo.491.1">Aborted'</span></strong><span class="kobospan" id="kobo.492.1">, and re-throw the </span><span><span class="kobospan" id="kobo.493.1">error otherwise.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.494.1">An </span><strong class="source-inline"><span class="kobospan" id="kobo.495.1">AbortError</span></strong><span class="kobospan" id="kobo.496.1"> error instance has a name property equal to </span><strong class="source-inline"><span class="kobospan" id="kobo.497.1">'AbortError'</span></strong><span class="kobospan" id="kobo.498.1">, but also a message such as </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">DOMException [AbortError]: This operation was aborted</span></strong><span class="kobospan" id="kobo.500.1">, along with its </span><span><span class="kobospan" id="kobo.501.1">stack trace:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.502.1">
function fetchWithCancel(url) {
  // no change to abortController initiationisalition
  const response = fetch(url, { signal: abortController.signal })
    .then((res) =&gt; res.json())
    .catch((err) =&gt; {
      if (err.name === 'AbortError') return 'Aborted';
      throw err;
    });
  // no change to return value
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.503.1">Given </span><a id="_idIndexMarker444" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.504.1">two API calls to fakestoreapi, </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">/products/1</span></strong><span class="kobospan" id="kobo.506.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">/products/2</span></strong><span class="kobospan" id="kobo.508.1">, we can cancel one of them without affecting </span><a id="_idIndexMarker445" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.509.1">the other request as follows, by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">fetchWithCancel</span></strong><span class="kobospan" id="kobo.511.1"> with both URLs and storing the output in two </span><a id="_idIndexMarker446" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.512.1">variables. </span><span class="kobospan" id="kobo.512.2">Note that we’re not using </span><span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">await</span></strong></span><span><span class="kobospan" id="kobo.514.1"> yet.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.515.1">We can </span><a id="_idIndexMarker447" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.516.1">then cancel the fetch for </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">/products/1</span></strong><span class="kobospan" id="kobo.518.1"> by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">.cancel()</span></strong><span class="kobospan" id="kobo.520.1"> function we </span><span><span class="kobospan" id="kobo.521.1">built earlier:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.522.1">
const fetchProduct1 = fetchWithCancel
  ('https://fakestoreapi.com/products/1');
const fetchProduct2 = fetchWithCancel('https://fakestoreapi.com/products/2');
fetchProduct1.cancel();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.523.1">The outcome of this is that when we await </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">fetchProduct1.response</span></strong><span class="kobospan" id="kobo.525.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">fetchProduct2.response</span></strong><span class="kobospan" id="kobo.527.1">, the output for </span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">fetchProduct1.response</span></strong><span class="kobospan" id="kobo.529.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">'Aborted'</span></strong><span class="kobospan" id="kobo.531.1">, which means an </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">AbortError</span></strong><span class="kobospan" id="kobo.533.1"> instance was handled in </span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">fetchWithCancel</span></strong><span class="kobospan" id="kobo.535.1"> (i.e., our </span><span><span class="kobospan" id="kobo.536.1">cancellation succeeded).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.537.1">The output for </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">fetchProduct2.response</span></strong><span class="kobospan" id="kobo.539.1"> is the </span><span><span class="kobospan" id="kobo.540.1">product object:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.541.1">
assert.deepEqual(await fetchProduct1.response, 'Aborted');
assert.deepEqual(await fetchProduct2.response, {
  category: "men's clothing",
  description:
    'Slim-fitting style, contrast raglan long sleeve, three-button henley placket, light weight &amp; soft fabric for breathable and comfortable wearing. </span><span class="kobospan1" id="kobo.541.2">And Solid stitched shirts with round neck made for durability and a great fit for casual fashion wear and diehard baseball fans. </span><span class="kobospan1" id="kobo.541.3">The Henley style round neckline includes a three-button placket.',
  id: 2,
  image:
    'https://fakestoreapi.com/img
      /71-3HjGNDUL._AC_SY879._SX._UX._SY._UY_.jpg',
  price: 22.3,
  rating: {
    count: 259,
    rate: 4.1,
  },
  title: 'Mens Casual Premium Slim Fit T-Shirts ',
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.542.1">Manually </span><a id="_idIndexMarker448" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.543.1">cancelling a request is useful, but a </span><a id="_idIndexMarker449" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.544.1">more widespread use case </span><a id="_idIndexMarker450" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.545.1">is to time a request out when </span><a id="_idIndexMarker451" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.546.1">it takes more than a certain amount of time. </span><span class="kobospan" id="kobo.546.2">This is useful to ensure a responsive user experience for customers. </span><span class="kobospan" id="kobo.546.3">Different situations call for longer or shorter </span><span><span class="kobospan" id="kobo.547.1">timeout delays.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.548.1">We can implement a </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">fetchWithTimeout</span></strong><span class="kobospan" id="kobo.550.1"> function using </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">fetch</span></strong><span class="kobospan" id="kobo.552.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">AbortController</span></strong><span class="kobospan" id="kobo.554.1">, </span><span><span class="kobospan" id="kobo.555.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.556.1">setTimeout</span></strong></span><span><span class="kobospan" id="kobo.557.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.558.1">Our function takes a URL and an optional timeout, which we’ll default to </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">500</span></strong><span class="kobospan" id="kobo.560.1"> (for 500 ms). </span><span class="kobospan" id="kobo.560.2">Similar to our manual cancellation scenario (see </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">fetchWithCancel</span></strong><span class="kobospan" id="kobo.562.1">), we’ll create an </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">abortController</span></strong><span class="kobospan" id="kobo.564.1"> object and pass its </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">signal</span></strong><span class="kobospan" id="kobo.566.1"> property as an option </span><span><span class="kobospan" id="kobo.567.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.568.1">fetch</span></strong></span><span><span class="kobospan" id="kobo.569.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.570.1">
async function fetchWithTimeout(url, timeout = 500) {
  const abortController = new AbortController();
  return fetch(url, { signal: abortController.signal });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.571.1">In order </span><a id="_idIndexMarker452" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.572.1">to cancel the fetch after a certain </span><a id="_idIndexMarker453" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.573.1">amount of time, we’ll use </span><strong class="source-inline"><span class="kobospan" id="kobo.574.1">setTimeout</span></strong><span class="kobospan" id="kobo.575.1">. </span><span class="kobospan" id="kobo.575.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.576.1">setTimeout</span></strong><span class="kobospan" id="kobo.577.1"> handler will simply call </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">abortController.abort()</span></strong><span class="kobospan" id="kobo.579.1"> and we’ll set the timeout delay to our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">timeout</span></strong></span><span><span class="kobospan" id="kobo.581.1"> variable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.582.1">
async function fetchWithTimeout(url, timeout = 500) {
  // no change to abortController
  setTimeout(() =&gt; {
    abortController.abort();
  }, timeout);
  // no change to fetch call or return
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.583.1">When </span><a id="_idIndexMarker454" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.584.1">the request takes less time </span><a id="_idIndexMarker455" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.585.1">than the </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">fetch</span></strong><span class="kobospan" id="kobo.587.1"> request takes to complete, we receive the </span><span><span class="kobospan" id="kobo.588.1">response data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.589.1">
const timedoutFetchShouldSucceedData = await fetchWithTimeout(
  'https://fakestoreapi.com/products/1',500
)
  .then((res) =&gt; res.json())
  .catch((error) =&gt; {
    if (error.name === 'AbortError') {
      return 'Aborted';
    }
    throw error;
  });
console.assert(
  timedoutFetchShouldSucceedData.id === 1,
  'fetchWithTimeout with 500ms timeout should have
    succeeded'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.590.1">When a </span><strong class="source-inline"><span class="kobospan" id="kobo.591.1">fetch</span></strong><span class="kobospan" id="kobo.592.1"> request takes longer than the configured timeout, we receive an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.593.1">AbortError</span></strong></span><span><span class="kobospan" id="kobo.594.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.595.1">
const timedoutFetchShouldAbort = await fetchWithTimeout(
  'https://fakestoreapi.com/products/1',10
)
  .then((res) =&gt; res.json())
  .catch((error) =&gt; {
    if (error.name === 'AbortError') {
      return 'Aborted';
    }
    throw error;
  });
console.assert(
  timedoutFetchShouldAbort === 'Aborted',
  'fetchWithTimeout with 10ms timeout should have
    aborted but did not'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.596.1">We’ve </span><a id="_idIndexMarker456" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.597.1">now seen how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">AbortController</span></strong><span class="kobospan" id="kobo.599.1"> to control </span><strong class="source-inline"><span class="kobospan" id="kobo.600.1">fetch</span></strong><span class="kobospan" id="kobo.601.1"> cancellation manually and how to use it to create a “fetch </span><a id="_idIndexMarker457" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.602.1">with timeout” utility. </span><span class="kobospan" id="kobo.602.2">We can use </span><strong class="source-inline"><span class="kobospan" id="kobo.603.1">AbortController</span></strong><span class="kobospan" id="kobo.604.1"> to cancel operations that aren’t required </span><a id="_idIndexMarker458" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.605.1">any more, thereby reducing </span><a id="_idIndexMarker459" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.606.1">network usage.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">Next, we’ll look at further patterns </span><a id="_idTextAnchor246" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.608.1">that can help optimize situations with high volumes </span><span><span class="kobospan" id="kobo.609.1">of requests.</span></span></p>
<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor247" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.610.1">Throttling, debouncing, and batching asynchronous operations</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.611.1">Throttling is </span><a id="_idIndexMarker460" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.612.1">an operation in which requests are dropped until a certain time is reached. </span><span class="kobospan" id="kobo.612.2">For example, for a 10 ms throttle timeout, once a request is made, no request in the next 10 ms will be sent. </span><span class="kobospan" id="kobo.612.3">If multiple requests are made between 0 ms and 10 ms, only the last request will be sent after the 10 ms </span><span><span class="kobospan" id="kobo.613.1">timeout expires.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.614.1">In JavaScript, such a throttle function can be implemented </span><span><span class="kobospan" id="kobo.615.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">A higher-order function, </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">throttle</span></strong><span class="kobospan" id="kobo.618.1"> takes in an </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">fn</span></strong><span class="kobospan" id="kobo.620.1"> parameter and returns an executable </span><a id="_idIndexMarker461" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.621.1">function with the same input signature as the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">fn</span></strong></span><span><span class="kobospan" id="kobo.623.1"> parameter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.624.1">When the “throttled” </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">fn</span></strong><span class="kobospan" id="kobo.626.1"> function is called, we set </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">isThrottled = true</span></strong><span class="kobospan" id="kobo.628.1"> in order to be able to discard calls between the first call and a </span><span><span class="kobospan" id="kobo.629.1">configured timeout:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.630.1">
function throttle(fn, timeout) {
  let isThrottled = false;
  return (...args) =&gt; {
    isThrottled = true;
    return fn(...args);
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.631.1">We now need to ensure </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">fn</span></strong><span class="kobospan" id="kobo.633.1"> is not called while </span><strong class="source-inline"><span class="kobospan" id="kobo.634.1">isThrottled</span></strong><span class="kobospan" id="kobo.635.1"> is true. </span><span class="kobospan" id="kobo.635.2">We achieve this by returning early from our returned “throttled” </span><span><strong class="source-inline"><span class="kobospan" id="kobo.636.1">fn</span></strong></span><span><span class="kobospan" id="kobo.637.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.638.1">We save the arguments with which the “throttled” </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">fn</span></strong><span class="kobospan" id="kobo.640.1"> function was called so that they can be used when the </span><span><span class="kobospan" id="kobo.641.1">timeout expires:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.642.1">
function throttle(fn, timeout) {
  // no change to existing variable definitions
  let lastCallArgs = null;
  return (...args) =&gt; {
    if (isThrottled) {
      lastCallArgs = args;
      return;
    }
    // no change to "initial call" case
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.643.1">Finally, we configure </span><strong class="source-inline"><span class="kobospan" id="kobo.644.1">setTimeout</span></strong><span class="kobospan" id="kobo.645.1"> to trigger a reset of the throttled state and execute the last </span><span><span class="kobospan" id="kobo.646.1">function call:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.647.1">
function throttle(fn, timeout) {
  // no change to existing variable definitions
  return (...args) =&gt; {
    // no change to short-circuit logic
    setTimeout(() =&gt; {
      isThrottled = false;
      return fn(...lastCallArgs);
    }, timeout);
    // no change to "initial call" case
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.648.1">A simple </span><a id="_idIndexMarker462" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.649.1">example of this in use is the following scenario, where many messages could be sent in a given time. </span><span class="kobospan" id="kobo.649.2">Instead, we want to throttle to 1 message every 1 </span><span><span class="kobospan" id="kobo.650.1">ms interval.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">storeMessage</span></strong><span class="kobospan" id="kobo.653.1"> function is </span><span><span class="kobospan" id="kobo.654.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.655.1">
let messages = [];
const storeMessage = (message) =&gt; {
  messages.push(message);
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.656.1">We can generate a </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">throttledStoreMessage</span></strong><span class="kobospan" id="kobo.658.1"> function with a 1 ms timeout </span><span><span class="kobospan" id="kobo.659.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">When called ten times synchronously and subsequently waiting for timers to complete, only the first (</span><strong class="source-inline"><span class="kobospan" id="kobo.661.1">'throttle-1'</span></strong><span class="kobospan" id="kobo.662.1">) and last (</span><strong class="source-inline"><span class="kobospan" id="kobo.663.1">'throttle-10'</span></strong><span class="kobospan" id="kobo.664.1">) calls </span><span><span class="kobospan" id="kobo.665.1">are recorded:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.666.1">
const throttledStoreMessage = throttle(storeMessage, 1);
throttledStoreMessage('throttle-1');
throttledStoreMessage('throttle-2');
throttledStoreMessage('throttle-3');
throttledStoreMessage('throttle-4');
throttledStoreMessage('throttle-5');
throttledStoreMessage('throttle-6');
throttledStoreMessage('throttle-7');
throttledStoreMessage('throttle-8');
throttledStoreMessage('throttle-9');
throttledStoreMessage('throttle-10');
await timeout();
assert.deepEqual(messages, ['throttle-1', 'throttle-10']);
function timeout(ms = 0) {
  return new Promise((r) =&gt; setTimeout(r, ms));
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.667.1">If we reset </span><a id="_idIndexMarker463" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.668.1">the messages and wait for the timers to complete after our call with </span><strong class="source-inline"><span class="kobospan" id="kobo.669.1">'throttle-5'</span></strong><span class="kobospan" id="kobo.670.1">, we finish with </span><strong class="source-inline"><span class="kobospan" id="kobo.671.1">['throttle-1', 'throttle-5', 'throttle-6']</span></strong><span class="kobospan" id="kobo.672.1">, that is, the first call, and the calls before and after the timers </span><span><span class="kobospan" id="kobo.673.1">are cleared.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.674.1">If we clear the timers one more time after completing all our calls, </span><strong class="source-inline"><span class="kobospan" id="kobo.675.1">'throttle-10'</span></strong><span class="kobospan" id="kobo.676.1"> is also present in our messages list, meaning that </span><span><span class="kobospan" id="kobo.677.1">call completed:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.678.1">
messages = [];
throttledStoreMessage('throttle-1');
throttledStoreMessage('throttle-2');
throttledStoreMessage('throttle-3');
throttledStoreMessage('throttle-4');
throttledStoreMessage('throttle-5');
await timeout();
throttledStoreMessage('throttle-6');
throttledStoreMessage('throttle-7');
throttledStoreMessage('throttle-8');
throttledStoreMessage('throttle-9');
throttledStoreMessage('throttle-10');
assert.deepEqual(messages, ['throttle-1', 'throttle-5', 'throttle-6']);
await timeout();
assert.deepEqual(messages, [
  'throttle-1',
  'throttle-5',
  'throttle-6',
  'throttle-10',
]);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.679.1">We’ve now seen how to throttle a function. </span><span class="kobospan" id="kobo.679.2">We can now look </span><span><span class="kobospan" id="kobo.680.1">at debouncing.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.681.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.682.1">debounce</span></strong><span class="kobospan" id="kobo.683.1"> function in JavaScript takes an </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">fn</span></strong><span class="kobospan" id="kobo.685.1"> parameter, which is a function. </span><span class="kobospan" id="kobo.685.2">The goal is that the debounced </span><strong class="source-inline"><span class="kobospan" id="kobo.686.1">fn</span></strong><span class="kobospan" id="kobo.687.1"> function should discard all calls except the last call before it’s not called for a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.688.1">timeout</span></strong></span><span><span class="kobospan" id="kobo.689.1"> period.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.690.1">In order to </span><a id="_idIndexMarker464" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.691.1">do this, we should “delay” the function call until after a timeout completes. </span><span class="kobospan" id="kobo.691.2">We save the </span><strong class="source-inline"><span class="kobospan" id="kobo.692.1">timeoutId</span></strong><span class="kobospan" id="kobo.693.1"> reference in order to cancel the call if the debounced </span><strong class="source-inline"><span class="kobospan" id="kobo.694.1">fn</span></strong><span class="kobospan" id="kobo.695.1"> function is called again. </span><span class="kobospan" id="kobo.695.2">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.696.1">setTimeout</span></strong><span class="kobospan" id="kobo.697.1"> and forward the arguments with which the debounced </span><strong class="source-inline"><span class="kobospan" id="kobo.698.1">fn</span></strong><span class="kobospan" id="kobo.699.1"> function </span><span><span class="kobospan" id="kobo.700.1">was called:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.701.1">
function debounce(fn, timeout) {
  let timeoutId;
  return (...args) =&gt; {
    timeoutId = setTimeout(() =&gt; {
      fn(...args);
    }, timeout);
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.702.1">With the current state of the </span><strong class="source-inline"><span class="kobospan" id="kobo.703.1">debounce</span></strong><span class="kobospan" id="kobo.704.1"> function, there would still be as many calls to </span><strong class="source-inline"><span class="kobospan" id="kobo.705.1">fn</span></strong><span class="kobospan" id="kobo.706.1"> as there are to the debounced </span><strong class="source-inline"><span class="kobospan" id="kobo.707.1">fn</span></strong><span class="kobospan" id="kobo.708.1"> function; they would just be queued for delayed execution based on the timeout. </span><span class="kobospan" id="kobo.708.2">To avoid this, we can cancel the previous call timeout by </span><span><span class="kobospan" id="kobo.709.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.710.1">clearTimeout(timeoutId)</span></strong></span><span><span class="kobospan" id="kobo.711.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.712.1">
function debounce(fn, timeout) {
  // no change to variable declarations
  return (...args) =&gt; {
    clearTimeout(timeoutId);
    // no change to setTimeout logic
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.713.1">With these changes in place, if we create a </span><strong class="source-inline"><span class="kobospan" id="kobo.714.1">debouncedStoredMessage</span></strong><span class="kobospan" id="kobo.715.1"> function with a 1 ms timeout and call it 10 times, it will not execute until we wait for the timer </span><span><span class="kobospan" id="kobo.716.1">to complete:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.717.1">
messages = [];
const debouncedStoredMessage = debounce(storeMessage, 1);
debouncedStoredMessage('debounce-1');
debouncedStoredMessage('debounce-2');
debouncedStoredMessage('debounce-3');
debouncedStoredMessage('debounce-4');
debouncedStoredMessage('debounce-5');
debouncedStoredMessage('debounce-6');
debouncedStoredMessage('debounce-7');
debouncedStoredMessage('debounce-8');
debouncedStoredMessage('debounce-9');
debouncedStoredMessage('debounce-10');
assert.deepEqual(messages, []);
await timeout();
assert.deepEqual(messages, ['debounce-10']);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.718.1">We can </span><a id="_idIndexMarker465" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.719.1">further showcase this by waiting for timers to complete after the fifth call. </span><span class="kobospan" id="kobo.719.2">In that case, the fifth call will trigger and, given another timeout window clears, the tenth call will </span><span><span class="kobospan" id="kobo.720.1">also trigger:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.721.1">
messages = [];
debouncedStoredMessage('debounce-1');
debouncedStoredMessage('debounce-2');
debouncedStoredMessage('debounce-3');
debouncedStoredMessage('debounce-4');
debouncedStoredMessage('debounce-5');
await timeout();
debouncedStoredMessage('debounce-6');
debouncedStoredMessage('debounce-7');
debouncedStoredMessage('debounce-8');
debouncedStoredMessage('debounce-9');
debouncedStoredMessage('debounce-10');
assert.deepEqual(messages, ['debounce-5']);
await timeout();
assert.deepEqual(messages, ['debounce-5', 'debounce-10']);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.722.1">We’ve now seen how to throttle and debounce functions, which allows us to ensure operations don’t trigger more </span><span><span class="kobospan" id="kobo.723.1">than necessary.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.724.1">In a scenario where we have a “search as you type” or “suggest as you type” input (sometimes referred to as a “typeahead”), which needs to make API requests to get search results or suggestions, it usually makes sense to use either </span><strong class="source-inline"><span class="kobospan" id="kobo.725.1">debounce</span></strong><span class="kobospan" id="kobo.726.1">, to wait for the user to stop typing before making a request, or to throttle the requests so that an API request is made every window instead of </span><span><span class="kobospan" id="kobo.727.1">every keystroke.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.728.1">This can also be coupled with other heuristics to avoid overwhelming the API server with unnecessary requests. </span><span class="kobospan" id="kobo.728.2">For example, it’s usual to avoid sending requests until a few characters have been typed since the search request is too broad with only 1 or </span><span><span class="kobospan" id="kobo.729.1">2 characters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.730.1">We’ve seen how to protect an API by reducing the number of requests using throttling or debouncing. </span><span class="kobospan" id="kobo.730.2">In the </span><em class="italic"><span class="kobospan" id="kobo.731.1">Parallel asynchronous operation patterns</span></em><span class="kobospan" id="kobo.732.1"> section, we used </span><strong class="source-inline"><span class="kobospan" id="kobo.733.1">Promise.all</span></strong><span class="kobospan" id="kobo.734.1"> to send requests in parallel. </span><span class="kobospan" id="kobo.734.2">This can be another scenario where the target of our asynchronous operations can get overwhelmed. </span><span class="kobospan" id="kobo.734.3">To avoid an overload scenario, it can be useful to batch </span><span><span class="kobospan" id="kobo.735.1">our requests.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">“Batching” is a way to limit concurrency, for example, instead of sending 20 requests at the same time (in parallel), we want to send 5 at </span><span><span class="kobospan" id="kobo.737.1">a time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.739.1">batch</span></strong><span class="kobospan" id="kobo.740.1"> function takes an </span><a id="_idIndexMarker466" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.741.1">array and a batch size and returns an array of arrays. </span><span class="kobospan" id="kobo.741.2">The nested arrays have a maximum length of “</span><span><span class="kobospan" id="kobo.742.1">batch size.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.743.1">We start by calculating how many </span><strong class="source-inline"><span class="kobospan" id="kobo.744.1">batchItem</span></strong><span class="kobospan" id="kobo.745.1"> list items we’ll need in our </span><strong class="source-inline"><span class="kobospan" id="kobo.746.1">batches</span></strong><span class="kobospan" id="kobo.747.1"> array. </span><span class="kobospan" id="kobo.747.2">In order to do this, we divide the input array length by the batch size and apply the </span><strong class="source-inline"><span class="kobospan" id="kobo.748.1">ceil</span></strong><span class="kobospan" id="kobo.749.1"> function to the value. </span><span class="kobospan" id="kobo.749.2">In other words, we round up </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">inputLength</span></strong><span class="kobospan" id="kobo.751.1"> divided by </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">batchSize</span></strong><span class="kobospan" id="kobo.753.1"> to the next largest </span><span><span class="kobospan" id="kobo.754.1">integer value.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.755.1">We can then generate our </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">batches</span></strong><span class="kobospan" id="kobo.757.1"> array with the right size (</span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">batchCount</span></strong><span class="kobospan" id="kobo.759.1">, </span><span><span class="kobospan" id="kobo.760.1">as computed):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.761.1">
function batch(inputArray, batchSize) {
  const batchCount = Math.ceil(inputArray.length /
    batchSize);
  const batches = Array.from({ length: batchCount });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.762.1">We then go through each of the batches using </span><strong class="source-inline"><span class="kobospan" id="kobo.763.1">Array.prototype.map()</span></strong><span class="kobospan" id="kobo.764.1">. </span><span class="kobospan" id="kobo.764.2">The items in </span><strong class="source-inline"><span class="kobospan" id="kobo.765.1">batches</span></strong><span class="kobospan" id="kobo.766.1"> are initially undefined, but we use the index of the item (which we’ll call </span><strong class="source-inline"><span class="kobospan" id="kobo.767.1">batchNumber</span></strong><span class="kobospan" id="kobo.768.1">). </span><span class="kobospan" id="kobo.768.2">For each item in </span><strong class="source-inline"><span class="kobospan" id="kobo.769.1">batches</span></strong><span class="kobospan" id="kobo.770.1">, we take the items from </span><strong class="source-inline"><span class="kobospan" id="kobo.771.1">batchNumber * batchSize</span></strong><span class="kobospan" id="kobo.772.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">(batchNumber + 1) * batchSize</span></strong><span class="kobospan" id="kobo.774.1"> and they constitute the contents of our </span><strong class="source-inline"><span class="kobospan" id="kobo.775.1">batches[batchNumber]</span></strong> <span><span class="kobospan" id="kobo.776.1">array item:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.777.1">
function batch(inputArray, batchSize) {
  // no change to existing size computations
  return batches.map((_, batchNumber) =&gt; {
    return inputArray.slice(
      batchNumber * batchSize,
      (batchNumber + 1) * batchSize
    );
  });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.778.1">You’ll note </span><a id="_idIndexMarker467" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.779.1">that we’re generating the array with </span><strong class="source-inline"><span class="kobospan" id="kobo.780.1">Array.from</span></strong> <em class="italic"><span class="kobospan" id="kobo.781.1">and then</span></em><span class="kobospan" id="kobo.782.1"> populating it using </span><strong class="source-inline"><span class="kobospan" id="kobo.783.1">Array.prototype.map()</span></strong><span class="kobospan" id="kobo.784.1">, however, </span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">Array.from()</span></strong><span class="kobospan" id="kobo.786.1"> supports a second parameter, which is a mapping function. </span><span class="kobospan" id="kobo.786.2">Our code could therefore be </span><span><span class="kobospan" id="kobo.787.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.788.1">
function batch(inputArray, batchSize) {
  const batchCount = Math.ceil(inputArray.length /
    batchSize);
  return Array.from({ length: batchCount }, (_,
    batchNumber) =&gt; {
    return inputArray.slice(
      batchNumber * batchSize,
      (batchNumber + 1) * batchSize
    );
  });
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.789.1">In any case, our </span><strong class="source-inline"><span class="kobospan" id="kobo.790.1">batch</span></strong><span class="kobospan" id="kobo.791.1"> function work for any array, for example, a 10-element array can be batched into chunks of 4 or 3 correctly by </span><span><span class="kobospan" id="kobo.792.1">our function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.793.1">
assert.deepEqual(batch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 4), [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11],
]);
assert.deepEqual(batch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 3), [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [10, 11],
]);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.794.1">The preceding example showcased a synchronous example. </span><span class="kobospan" id="kobo.794.2">For our use case – improving the performance of asynchronous operations, we need to handle Promises. </span><span class="kobospan" id="kobo.794.3">The good news is that Promises can be stored in an array just </span><span><span class="kobospan" id="kobo.795.1">as well:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.796.1">
const numberResolverBatches = batch(
  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
  2
);
console.assert(numberResolverBatches.length === 2);
console.assert(numberResolverBatches[0].length === 2);
console.assert(numberResolverBatches[1].length === 1);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.797.1">To get the batched </span><a id="_idIndexMarker468" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.798.1">output of the Promises, however, we need to write a function that awaits all the Promises in each batch to resolve </span><span><span class="kobospan" id="kobo.799.1">them sequentially.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.800.1">This can be achieved by using a </span><strong class="source-inline"><span class="kobospan" id="kobo.801.1">for ... </span><span class="kobospan" id="kobo.801.2">of</span></strong><span class="kobospan" id="kobo.802.1"> loop and </span><strong class="source-inline"><span class="kobospan" id="kobo.803.1">Promise.all</span></strong><span class="kobospan" id="kobo.804.1">, as follows. </span><span class="kobospan" id="kobo.804.2">We flatten out the </span><span><span class="kobospan" id="kobo.805.1">resolved values:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.806.1">
async function resolveBatches(batchedPromises) {
  const flattenedBatchOutput = [];
  for (const batch of batchedPromises) {
    const resolved = await Promise.all(batch);
    flattenedBatchOutput.push(...resolved);
  }
  return flattenedBatchOutput;
}
const batchOutput = await resolveBatches(numberResolverBatches);
assert.deepEqual(batchOutput, [1, 2, 3]);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.807.1">In our example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.808.1">Promise.resolve()</span></strong><span class="kobospan" id="kobo.809.1"> calls with </span><strong class="source-inline"><span class="kobospan" id="kobo.810.1">1</span></strong><span class="kobospan" id="kobo.811.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.812.1">2</span></strong><span class="kobospan" id="kobo.813.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.814.1">3</span></strong><span class="kobospan" id="kobo.815.1"> can indeed be batched </span><span><span class="kobospan" id="kobo.816.1">and resolved.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.817.1">We’ve now seen how to build and use throttling, debouncing, and batching</span><a id="_idTextAnchor248" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.818.1"> to improve the performance of our asynchronous operations </span><span><span class="kobospan" id="kobo.819.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor249" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.820.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.821.1">In this chapter, we’ve covered asynchronous operation orchestration patterns with Promises and async/await to manage sequential and parallel operations. </span><span class="kobospan" id="kobo.821.2">We also covered advanced patterns such as request cancellation, implementing timeouts, the difference between throttling and debouncing, and finally, how to use batching in an asynchronous </span><span><span class="kobospan" id="kobo.822.1">operation context.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.823.1">In order to manage sequential asynchronous operations, we can use a Promise-based approach with </span><strong class="source-inline"><span class="kobospan" id="kobo.824.1">Promise().then()</span></strong><span class="kobospan" id="kobo.825.1">, async/await, or mix both approaches. </span><span class="kobospan" id="kobo.825.2">This helps keep our code simple to reason about. </span><span class="kobospan" id="kobo.825.3">For parallel execution, we can leverage </span><strong class="source-inline"><span class="kobospan" id="kobo.826.1">Promise.all()</span></strong><span class="kobospan" id="kobo.827.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.828.1">Promise.then()</span></strong><span class="kobospan" id="kobo.829.1"> or async/await. </span><span class="kobospan" id="kobo.829.2">We also have multiple approaches to maintaining response data across </span><span><span class="kobospan" id="kobo.830.1">asynchronous operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.831.1">We can leverage </span><strong class="source-inline"><span class="kobospan" id="kobo.832.1">AbortController</span></strong><span class="kobospan" id="kobo.833.1"> to cancel requests. </span><span class="kobospan" id="kobo.833.2">We implemented a timeout for the </span><strong class="source-inline"><span class="kobospan" id="kobo.834.1">fetch</span></strong><span class="kobospan" id="kobo.835.1"> response time using </span><strong class="source-inline"><span class="kobospan" id="kobo.836.1">AbortController</span></strong><span class="kobospan" id="kobo.837.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.838.1">setTimeout</span></strong><span class="kobospan" id="kobo.839.1">. </span><span class="kobospan" id="kobo.839.2">Stopping in-flight requests is a useful cleanup step that can improve performance by reducing unnecessary load on our </span><span><span class="kobospan" id="kobo.840.1">API origin.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">Finally, the advanced asynchronous programming patterns allow fewer requests to happen via throttling and debouncing. </span><span class="kobospan" id="kobo.841.2">We can also control the concurrency of our parallel requests using batching and resolving the batches. </span><span class="kobospan" id="kobo.841.3">Again, these approaches can reduce unnecessary network traffic and load on the </span><span><span class="kobospan" id="kobo.842.1">API servers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.843.1">Now that we’ve covered asynchronous programming performance patterns, with Promise, async/await, and advanced patterns, we can look at patterns for event-driven programming </span><span><span class="kobospan" id="kobo.844.1">in JavaScript.</span></span></p>
</div>
</body></html>