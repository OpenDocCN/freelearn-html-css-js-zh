<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor238" class="pcalibre1 calibre6 pcalibre"/>7</h1>
<h1 id="_idParaDest-127" class="calibre5"><a id="_idTextAnchor239" class="pcalibre1 calibre6 pcalibre"/>Asynchronous Programming Performance Patterns</h1>
<p class="calibre3">A key strength of JavaScript runtimes is the event loop, which couples “non-blocking input/output” within a single-threaded execution model. This means JavaScript is great for high-concurrency systems as long as they are not compute-bound systems (i.e., they’re IO-bound).</p>
<p class="calibre3">With the asynchronous and non-blocking IO, JavaScript has strong built-ins to orchestrate requests. In this chapter, we’ll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Sequential and parallel asynchronous operation patterns in JavaScript, both with Promises only and with async/await</li>
<li class="calibre11">The cancellation and timeout of fetch requests with AbortController</li>
<li class="calibre11">Advanced asynchronous operation patterns: throttling, debouncing, and batching</li>
</ul>
<p class="calibre3">At the end of this chapter, you’ll be able to spot and remedy situations where the asynchronous operation orchestration could be improved in JavaScript.</p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor240" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-129" class="calibre5"><a id="_idTextAnchor241" class="pcalibre1 calibre6 pcalibre"/>Controlling sequential asynchronous operations with async/await and Promises</h1>
<p class="calibre3">Promises <a id="_idIndexMarker392" class="pcalibre1 calibre6 pcalibre"/>were <a id="_idIndexMarker393" class="pcalibre1 calibre6 pcalibre"/>introduced in ES2015 (ES6), along with other modern data structures.</p>
<p class="calibre3">For those familiar with JavaScript prior to ES2015, asynchronous behavior was modeled with callback-based interfaces, for example, <code>request(url, (error, response) =&gt; { /* do work with response */ })</code>. The key issues that Promises resolved were the chaining of asynchronous requests and issues around managing parallel requests, which we’ll cover in this section.</p>
<p class="calibre3">ES2016 <a id="_idIndexMarker394" class="pcalibre1 calibre6 pcalibre"/>included the initial specification for the async/await syntax. It built on top of the Promise object <a id="_idIndexMarker395" class="pcalibre1 calibre6 pcalibre"/>in order to write asynchronous code that didn’t involve “Promise chains,” where different Promises are processed using the <code>Promise().then</code> function. Promise functionality and async/await interoperate nicely. In fact, calling an async function returns a Promise.</p>
<p class="calibre3">We’ll <a id="_idIndexMarker396" class="pcalibre1 calibre6 pcalibre"/>start by showing how to use Promises to manage sequential asynchronous operations. We’ll use <a id="_idIndexMarker397" class="pcalibre1 calibre6 pcalibre"/>the Fetch API (which returns a Promise) to load <code>fakestoreapi.com/auth/login</code>. Given a username and password, and based on the output, we’ll load all the relevant carts for that user. Subsequently, we’ll load the relevant carts for that user using the <code>fakestoreapi.com/carts/user/{userId}</code> endpoint. This request flow is visualized in the following diagram.</p>
<div><div><img alt="Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests" src="img/B19109_07_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1: Sequence of /auth/login and /carts/user/{userId} requests</p>
<p class="calibre3">We’ll start by sending a POST request to the <code>auth/login</code> endpoint. We add <code>.then((res) =&gt; res.json())</code>, which will wait for the initial <code>fetch()</code> output Promise to resolve to a “response” (hence the <code>res</code> name). We then call the <code>.json()</code> method on the response, which again is a Promise, which resolves to the JSON-decoded response body:</p>
<pre class="source-code">
function fetchAuthUserThenCartsPromiseThen(username,
  password) {
  return fetch('https://fakestoreapi.com/auth/login', {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  }).then((res) =&gt; res.json());
}</pre> <p class="calibre3">The <a id="_idIndexMarker398" class="pcalibre1 calibre6 pcalibre"/>Promise returned from <code>res.json()</code> can be accessed in another <code>.then()</code> callback, in which <a id="_idIndexMarker399" class="pcalibre1 calibre6 pcalibre"/>we parse the <code>token</code> field, which <a id="_idIndexMarker400" class="pcalibre1 calibre6 pcalibre"/>is a <code>jwt-decode</code> package.</p>
<p class="calibre3">We extract the <code>sub</code> field from the decoded token. This is the “subject” claim, which tells us which <a id="_idIndexMarker401" class="pcalibre1 calibre6 pcalibre"/>user this token <a id="_idIndexMarker402" class="pcalibre1 calibre6 pcalibre"/>is about. In the case of the <code>fakestoreapi</code> token, <code>userId</code> is used as the “subject” claim. We can therefore use the <code>sub</code> claim as the user ID for which to load the carts in our following API call to <a href="https://fakestoreapi.com/carts/user/" class="pcalibre1 calibre6 pcalibre">https://fakestoreapi.com/carts/user/</a><code>{userId}</code>:</p>
<pre class="source-code">
import jwt_decode from 'https://esm.sh/jwt-decode';
function fetchAuthUserThenCartsPromiseThen(username,
  password) {
  return // no change to the fetch() call
    .then((res) =&gt; res.json())
    .then((responseData) =&gt; {
      const parsedValues = jwt_decode(responseData.token);
      const userId = parsedValues.sub;
      return userId;
    })
    .then((userId) =&gt;
      fetch(`https://fakestoreapi.com/carts/user/${userId}
        ?sort=desc`)
    )
    .then((res) =&gt; res.json());
}</pre> <p class="calibre3">This <a id="_idIndexMarker403" class="pcalibre1 calibre6 pcalibre"/>function can <a id="_idIndexMarker404" class="pcalibre1 calibre6 pcalibre"/>then be used as follows. Note that a password shouldn’t be stored in the source of a production application (as it is in this example).</p>
<p class="calibre3">When <a id="_idIndexMarker405" class="pcalibre1 calibre6 pcalibre"/>we call the <code>fetchAuthUserThenCartsPromiseThen</code> function, it makes both the <code>/auth/login</code> call and then the <code>/carts/user/{userId}</code> call, which <a id="_idIndexMarker406" class="pcalibre1 calibre6 pcalibre"/>means we receive an array with the relevant carts for the requested user (note <code>userId</code> = <code>3</code>, which is the correct ID for the <code>kevinryan</code> user).</p>
<p class="calibre3">Note that we’re using async/await here to “flatten” the Promise output into <code>userCartsDataPromiseThen</code>, which we can assert on:</p>
<pre class="source-code">
const username = 'kevinryan';
const password = 'kev02937@';
const userCartsDataPromiseThen = await
  fetchAuthUserThenCartsPromiseThen(
  username,
  password
);
assert.deepEqual(userCartsDataPromiseThen, [
  {
    __v: 0,
    date: '2020-01-01T00:00:00.000Z',
    id: 4,
    products: [
      {
        productId: 1,
        quantity: 4,
      },
    ],
    userId: 3,
  },
  {
    __v: 0,
    date: '2020-03-01T00:00:00.000Z',
    id: 5,
    products: [
      {
        productId: 7,
        quantity: 1,
      },
      {
        productId: 8,
        quantity: 1,
      },
    ],
    userId: 3,
  },
]);</pre> <p class="calibre3">As <a id="_idIndexMarker407" class="pcalibre1 calibre6 pcalibre"/>we’ve just seen in the code that calls <code>fetchAuthUserThenCartsPromiseThen</code>, the <a id="_idIndexMarker408" class="pcalibre1 calibre6 pcalibre"/>key benefit of async/await over <code>Promise().then()</code> chains is that the code is structured more similarly to synchronous code.</p>
<p class="calibre3">In <a id="_idIndexMarker409" class="pcalibre1 calibre6 pcalibre"/>synchronous code, the <a id="_idIndexMarker410" class="pcalibre1 calibre6 pcalibre"/>output of an operation can be, for example, assigned to a constant:</p>
<pre class="source-code">
const output = syncGetAuthUserCarts();
console.log(output);</pre> <p class="calibre3">Whereas with <code>Promise().then()</code>, the output is available only in an additional <code>.</code><code>then</code> callback:</p>
<pre class="source-code">
promisifiedGetAuthUserCarts().then((output) =&gt; {
  console.log(output);
});</pre> <p class="calibre3">What <code>await</code> allows us to do is to structure the code as follows:</p>
<pre class="source-code">
const output = await promisifiedGetAuthUserCarts();
console.log(output);</pre> <p class="calibre3">One way to think of it is that <code>await</code> can unfurl Promises. A Promise’s “resolved value”, usually only accessible in a <code>Promise().then()</code> callback is available directly.</p>
<p class="calibre3">For <a id="_idIndexMarker411" class="pcalibre1 calibre6 pcalibre"/>sequential operations, this is very useful, since it makes the code structured with a set of <a id="_idIndexMarker412" class="pcalibre1 calibre6 pcalibre"/>variable assignments per async operation.</p>
<p class="calibre3">The <code>await</code> operator is available at the top level of ECMAScript modules in modern runtime <a id="_idIndexMarker413" class="pcalibre1 calibre6 pcalibre"/>environments as part of the ES2022 specification.</p>
<p class="calibre3">However, in <a id="_idIndexMarker414" class="pcalibre1 calibre6 pcalibre"/>order to use <code>await</code> inside of a function, we need to mark the function as <code>async</code>. This usage of <code>await</code> in <code>async</code> functions has been available since ES2016.</p>
<p class="calibre3">Code editors and IDEs such as Visual Studio Code provide a refactor from chained <code>Promise().then()</code> calls to async/await. In our case, we can build a <code>fetchAuthUserThenCartsAsyncAwait</code> function as follows.</p>
<p class="calibre3">Instead of using <code>fetch().then(res =&gt; res.json())</code>, we’ll first use <code>await fetch()</code> and then <code>await authResponse.json()</code>:</p>
<pre class="source-code">
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  const authResponse = await fetch('https://fakestoreapi.com/auth/login', {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  });
  const authData = await authResponse.json();
}</pre> <p class="calibre3">We now have access to <code>authData</code>. We can decode <code>authData.token</code> as before using the <code>jwt-decode</code> package. This gives us access to the <code>sub</code> (subject) claim, which is the user ID:</p>
<pre class="source-code">
Import jwt_decode from 'https://esm.sh/jwt-decode';
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  // no change to /auth/login API call code
  const parsedValues = jwt_decode(authData.token);
  const userId = parsedValues.sub;
}</pre> <p class="calibre3">Now <a id="_idIndexMarker415" class="pcalibre1 calibre6 pcalibre"/>that we <a id="_idIndexMarker416" class="pcalibre1 calibre6 pcalibre"/>have the relevant <a id="_idIndexMarker417" class="pcalibre1 calibre6 pcalibre"/>user ID, we <a id="_idIndexMarker418" class="pcalibre1 calibre6 pcalibre"/>can call the <code>/carts/user/{userId}</code> endpoint to load the user’s carts:</p>
<pre class="source-code">
async function fetchAuthUserThenCartsAsyncAwait
  (username, password) {
  // no change to /auth/login call or token parsing logic
  const userCartsResponse = await fetch(
    `https://fakestoreapi.com/carts/user/${userId}?sort=desc`
  );
  const userCartsResponseData = await userCartsResponse.
    json();
  return userCartsResponseData;
}</pre> <p class="calibre3">Given the same input data as the approach using <code>Promise().then()</code>, the loaded carts are the same. Note, again, that passwords and credentials should not be stored in source code files:</p>
<pre class="source-code">
const username = 'kevinryan';
const password = 'kev02937@';
const userCartsDataAsyncAwait = await fetchAuthUserThenCartsAsyncAwait(
  username,
  password
);
assert.deepEqual(userCartsDataAsyncAwait, userCartsDataPromiseThen);</pre> <p class="calibre3">One <a id="_idIndexMarker419" class="pcalibre1 calibre6 pcalibre"/>difference between the approaches is that with async/await, all the variables are defined <a id="_idIndexMarker420" class="pcalibre1 calibre6 pcalibre"/>in a single function scope, whereas the <code>Promise().then()</code> approach uses multiple function <a id="_idIndexMarker421" class="pcalibre1 calibre6 pcalibre"/>scopes (for each of the callbacks passed to <code>.then()</code>). With a single large function scope, variable <a id="_idIndexMarker422" class="pcalibre1 calibre6 pcalibre"/>names can’t clash, which makes the code more verbose since, for example, each <code>response</code> object needs a qualifier to avoid variable name clashes, for example, <code>authResponse</code> and <code>userCartsResponse</code>.</p>
<p class="calibre3">The benefit of a single larger function scope is that all the outputs of previous API calls are available to subsequent ones without having to explicitly set them as values passed as a return in the callback passed to <code>.then()</code>.</p>
<p class="calibre3">Finally, a <code>fetch()</code>-specific example, is that since there are multiple Promises that require handling when doing a fetch and accessing the JSON response, the await approach can be a bit “noisier.”</p>
<p class="calibre3">See the two following samples. First, with async/await, we assign a variable for the fetch <code>response</code> value:</p>
<pre class="source-code">
const response = await fetch(url);
const data = await response.json();</pre> <p class="calibre3">Next, with <code>.then()</code>, we assign only a <code>data</code> variable and use an arrow function to handle the <code>.</code><code>json()</code> unfurling:</p>
<pre class="source-code">
const data = await fetch(url).then((response) =&gt; response.json());</pre> <p class="calibre3">As you see, our final example is a mix of <code>async/await</code> and <code>Promise().then()</code> so that the most “important” parts of the code are obvious. The specifics of how we extract the JSON output from <code>fetch</code> are not necessarily core to our logic so might be better expressed with <code>Promise().then()</code>.</p>
<p class="calibre3">In <a id="_idIndexMarker423" class="pcalibre1 calibre6 pcalibre"/>general, this slight difference in style wouldn’t occur since parts of the code that are “less important,” such as how we interact with the fetch API to process a request to JSON, tend <a id="_idIndexMarker424" class="pcalibre1 calibre6 pcalibre"/>to be abstracted – in this case, in an HTTP client of some kind. We would expect that the HTTP client <a id="_idIndexMarker425" class="pcalibre1 calibre6 pcalibre"/>could handle checking <code>response.ok</code> and accessing the response body as parsed JSON (using <code>response.json()</code>).</p>
<p class="calibre3">We’ve <a id="_idIndexMarker426" class="pcalibre1 calibre6 pcalibre"/>now seen how to implement sequential asynchronous operations using a Promise-only approach, an async/await-based approach, and finally, how both the async/await and Promise techniques can be used together to improve <a id="_idTextAnchor242" class="pcalibre1 calibre6 pcalibre"/>code readability and performance.</p>
<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor243" class="pcalibre1 calibre6 pcalibre"/>Parallel asynchronous operation patterns</h1>
<p class="calibre3">A common <a id="_idIndexMarker427" class="pcalibre1 calibre6 pcalibre"/>source of bad performance is running operations sequentially that could be completed in parallel.</p>
<p class="calibre3">For example, a naive implementation of loading a cart and then the contained products would be as follows:</p>
<div><div><img alt="Figure 7.2: Load cart then each of the three products contained from fakestoreapi" src="img/B19109_07_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2: Load cart then each of the three products contained from fakestoreapi</p>
<p class="calibre3">In this case, the <a id="_idIndexMarker428" class="pcalibre1 calibre6 pcalibre"/>operation completion time is composed of the sum of the following:</p>
<ul class="calibre10">
<li class="calibre11">Request-response time for <strong class="source-inline1">GET /carts/{cartId}</strong></li>
<li class="calibre11">Request-response time for <strong class="source-inline1">GET /products/1</strong></li>
<li class="calibre11">Request-response time for <strong class="source-inline1">GET /products/2</strong></li>
<li class="calibre11">Request-response time for <strong class="source-inline1">GET /products/3</strong></li>
</ul>
<p class="calibre3">There is a requirement for the <code>/products/{productId}</code> calls to be done after the <code>GET /carts/{cartId}</code> call completes since that’s where the product IDs are coming from. What isn’t required is for each product call to wait for the previous one to complete; the calls only depend on data from the <code>GET /carts/{cartId}</code> call. This is an optimization opportunity. We can start all of the <code>GET /products/{id}</code> API calls together. We get the following sequence:</p>
<div><div><img alt="Figure 7.3: Load cart then each of the three products contained in parallel" src="img/B19109_07_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3: Load cart then each of the three products contained in parallel</p>
<p class="calibre3">In this <a id="_idIndexMarker429" class="pcalibre1 calibre6 pcalibre"/>case, the operation completion time is composed of the sum of the following:</p>
<ul class="calibre10">
<li class="calibre11">Request-response time for <strong class="source-inline1">GET /carts/{cartId}</strong></li>
<li class="calibre11">The longest request-response time between <strong class="source-inline1">GET /products/1</strong>, <strong class="source-inline1">GET /products/2</strong>, and <strong class="source-inline1">GET /products/3</strong></li>
</ul>
<p class="calibre3">This means we’re saving the request-response time of two API calls at least.</p>
<p class="calibre3">JavaScript is especially well suited to these workloads since its concurrency model is based on an event loop. While JavaScript waits for an asynchronous operation to complete, it can complete other synchronous operations.</p>
<p class="calibre3">In layman’s terms, triggering an asynchronous operation in JavaScript is “cheap and lightweight” compared to thread-based concurrency models that are common in popular programming languages such as Java and C++.</p>
<p class="calibre3">There are multiple constructs in JavaScript that allow us to convert an array of Promises into a Promise that resolves to an array. <code>Promise.all</code> is one such construct.</p>
<p class="calibre3">Implementing the scenario we described earlier, where we load a cart and then load the relevant product details, would look as follows with <code>Promise.all</code> and <code>Promise().then</code>.</p>
<p class="calibre3">First, we need to make the API call to load the cart and extract the JSON in the response body:</p>
<pre class="source-code">
function fetchCartPromiseThen(cartId = '1') {
  return fetch(`https://fakestoreapi.com/carts/${cartId}`).
    then((res) =&gt;
    res.json()
  );
}</pre> <p class="calibre3">We then <a id="_idIndexMarker430" class="pcalibre1 calibre6 pcalibre"/>need to set up the fetching of the right product URLs once the request to the <code>/carts/{cartId}</code> URL has loaded. The pattern used in order to execute our code after the fetch completes uses <code>.then()</code> on the returned promise:</p>
<pre class="source-code">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then((cart) =&gt; {
      const productUrls = cart.products.map(
        (p) =&gt; `https://fakestoreapi.com/products/$
           {p.productId}`
      );
    })
}</pre> <p class="calibre3">Next, we’ll use <code>Promise.all</code> to load all the product URLs with <code>fetch</code>. Since our goal is to return both the cart <em class="italic">and</em> the products, we’ll return <code>{ cart }</code> as the first item in the array we’re passing to <code>Promise.all()</code>. The rest of the array passed to <code>Promise.all</code> will be the Promises generated by calling <code>fetch().then((res) =&gt; res.json())</code> on each of the product URLs. In order to do this, we use the spread operation (<code>...</code>) on <code>...productUrls.map(/* mapping function */)</code> in the array:</p>
<pre class="source-code">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then((cart) =&gt; {
      // no change to productUrls generation
      return Promise.all([
        { cart },
        ...productUrls.map((url) =&gt; fetch(url).then
          ((res) =&gt; res.json())),
      ]);
    })
}</pre> <p class="calibre3">Finally, we’re <a id="_idIndexMarker431" class="pcalibre1 calibre6 pcalibre"/>going to create an object with all the cart fields and a new products field based on the output of the <code>/</code><code>products/{id}</code> fetches:</p>
<pre class="source-code">
function fetchCartPromiseThen(cartId = '1') {
    // no change to previous operations
    .then(([prev, ...products]) =&gt; {
      return {
        ...prev,
        products,
      };
    });
}</pre> <p class="calibre3">We can test the output of the function by loading cart ID <code>1</code>:</p>
<pre class="source-code">
const cartDataFromPromiseThen = await fetchCartPromiseThen
  ('1');</pre> <p class="calibre3">The cart is as we expect – it returns three products:</p>
<pre class="source-code">
assert.deepEqual(cartDataFromPromiseThen.cart, {
  __v: 0,
  date: '2020-03-02T00:00:00.000Z',
  id: 1,
  products: [
    {
      productId: 1,
      quantity: 4,
    },
    {
      productId: 2,
      quantity: 1,
    },
    {
      productId: 3,
      quantity: 6,
    },
  ],
  userId: 1,
});</pre> <p class="calibre3">The <code>products</code> field of <a id="_idIndexMarker432" class="pcalibre1 calibre6 pcalibre"/>our response contains the correct items in positions at indexes 0, 1, and 2:</p>
<pre class="source-code">
assert.deepEqual(cartDataFromPromiseThen.products[0], {
  category: "men's clothing",
  description:
    'Your perfect pack for everyday use and walks in the
     forest. Stash your laptop (up to 15 inches) in the
     padded sleeve, your everyday',
  id: 1,
  image: 'https://fakestoreapi.com/img/
    81fPKd-2AYL._AC_SL1500_.jpg',
  price: 109.95,
  rating: {
    count: 120,
    rate: 3.9,
  },
  title: 'Fjallraven - Foldsack No. 1 Backpack, Fits 15
    Laptops',
});
assert.deepEqual(cartDataFromPromiseThen.
  products[1], {
  category: "men's clothing",
  description:
    'Slim-fitting style, contrast raglan long sleeve, three-button henley placket, light weight &amp; soft fabric for breathable and comfortable wearing. And Solid stitched shirts with round neck made for durability and a great fit for casual fashion wear and diehard baseball fans. The Henley style round neckline includes a three-button placket.',
  id: 2,
  image:
    'https://fakestoreapi.com/img/
       71-3HjGNDUL._AC_SY879._SX._UX._SY._UY_.jpg',
  price: 22.3,
  rating: {
    count: 259,
    rate: 4.1,
  },
  title: 'Mens Casual Premium Slim Fit T-Shirts ',
});
assert.deepEqual(cartDataFromPromiseThen.products[2], {
  category: "men's clothing",
  description:
    'great outerwear jackets for Spring/Autumn/Winter, suitable for many occasions, such as working, hiking, camping, mountain/rock climbing, cycling, traveling or other outdoors. Good gift choice for you or your family member. A warm hearted love to Father, husband or son in this thanksgiving or Christmas Day.',
  id: 3,
  image: 'https://fakestoreapi.com/img/
    71li-ujtlUL._AC_UX679_.jpg',
  price: 55.99,
  rating: {
    count: 500,
    rate: 4.7,
  },
  title: 'Mens Cotton Jacket',
});</pre> <p class="calibre3">We’ve now seen how to leverage <code>Promise.all</code> to run multiple promises in parallel and handle their output with one handler.</p>
<p class="calibre3">You’ll have noticed the “trick” we did by passing the <code>{ cart }</code> object in <code>Promise.all</code> and then extracting the first item of the resolved array as the previous response. This is a limitation of <code>Promise().then()</code> chaining, as mentioned in the <em class="italic">Controlling sequential asynchronous operations with async/await and Promises</em> section. Each function argument to <code>.then()</code> gets its own scope:</p>
<pre class="source-code">
Promise.resolve({ id: 1 })
  .then((cart) =&gt; {
    const productUrls = [];
    return Promise.all([{ cart }, ...productUrls.map(()
      =&gt; {})]);
  })
  .then(([prev, ...products]) =&gt; {});</pre> <p class="calibre3">An alternative <a id="_idIndexMarker433" class="pcalibre1 calibre6 pcalibre"/>way to write this is to store the cart in the function scope:</p>
<pre class="source-code">
function fetchCartFunctionVariable() {
  let loadedCart = null;
  return Promise.resolve({ id: 1 })
    .then((cart) =&gt; {
      loadedCart = cart;
      const productUrls = [];
      return Promise.all(productUrls.map(() =&gt; {}));
    })
    .then((products) =&gt; ({
      cart: loadedCart,
      products,
    }));
}</pre> <p class="calibre3">This works as expected. We’ve obviously removed the actual cart and product fetching logic from the API, but the cart that <code>{ id: 1 }</code> relates to, which we resolved in the initial <code>Promise.resolve()</code> function call, is cached through the <code>.</code><code>then()</code> calls:</p>
<pre class="source-code">
assert.deepEqual(await fetchCartFunctionVariable(), {
  cart: { id: 1 },
  products: [],
});</pre> <p class="calibre3">Another way to improve our implementation without resorting to function-scoped variables, which can be hard to keep track of, is to convert it to use async/await.</p>
<p class="calibre3">Our logic would be as follows. We start by loading the cart and converting the JSON response body:</p>
<pre class="source-code">
async function fetchCartAsyncAwait(cartId = '1') {
  const cart = await fetch(`https://fakestoreapi.com/carts/${cartId}`).then(
    (res) =&gt; res.json()
  );
}</pre> <p class="calibre3">Once the <a id="_idIndexMarker434" class="pcalibre1 calibre6 pcalibre"/>cart is loaded, we proceed to fetch the relevant products by generating URLs based on the <code>cart.products</code> contents (mainly the <code>productId</code> field). We also fetch these URLs using <code>Promise.all</code>:</p>
<pre class="source-code">
async function fetchCartAsyncAwait(cartId = '1') {
  // no change to cart fetching
  const productUrls = cart.products.map(
    (p) =&gt; `https://fakestoreapi.com/products/${p.productId}`
  );
  const products = await Promise.all(
    productUrls.map((url) =&gt; fetch(url).then((res)
      =&gt; res.json()))
  );
}</pre> <p class="calibre3">Finally, we can return the cart and the loaded products:</p>
<pre class="source-code">
async function fetchCartAsyncAwait(cartId = '1') {
  // no changes to cart or products fetching
  return {
    cart,
    products,
  };
}</pre> <p class="calibre3">The implementation is equivalent to our previous, strict <code>Promise().then()</code>-based one, as the following checks attest:</p>
<pre class="source-code">
const cartDataFromAsyncAwait = await fetchCartAsyncAwait
  ('1');
assert.deepEqual(cartDataFromPromiseThen.cart,
  cartDataFromAsyncAwait.cart);
assert.deepEqual(
  cartDataFromPromiseThen.products,
  cartDataFromAsyncAwait.products
);</pre> <p class="calibre3">The benefit of using async/await in this case was, again, an increase in readability. The syntax gets <a id="_idIndexMarker435" class="pcalibre1 calibre6 pcalibre"/>less in the way than chained <code>.then()</code> calls and we don’t have to resort to either returning the first response as an item in <code>Promise.all([{ cart }])</code> or adding a function-scoped variable that we store the cart in.</p>
<p class="calibre3">We’ve now seen how to leverage <code>Promise.all</code> to complete asynchronous operations in parallel both with a <code>Promise().then()</code>-exclusive approach and with judicious refactors to <code>async/await</code> to simplify the code.</p>
<p class="calibre3">Next, we’ll see how we can cancel and time out requ<a id="_idTextAnchor244" class="pcalibre1 calibre6 pcalibre"/>ests with <code>AbortController</code> in JavaScript.</p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor245" class="pcalibre1 calibre6 pcalibre"/>Asynchronous cancellation and timeouts with AbortController</h1>
<p class="calibre3">Another source <a id="_idIndexMarker436" class="pcalibre1 calibre6 pcalibre"/>of bad performance <a id="_idIndexMarker437" class="pcalibre1 calibre6 pcalibre"/>in applications in general is <a id="_idIndexMarker438" class="pcalibre1 calibre6 pcalibre"/>doing work that’s not necessary. In <a id="_idIndexMarker439" class="pcalibre1 calibre6 pcalibre"/>the context of a JavaScript web application, one of the types of “work” that can be unnecessary (and therefore a drain on performance) is having HTTP requests that aren’t required any more. For example, in a photo gallery system or any paginated system, when moving across photos, the request for the previous photo might not have completed before the next one is started. In this case, the previous request data is not necessary any more, as we’re essentially on a completely different page.</p>
<p class="calibre3">In these instances, cancelling the request might be useful.</p>
<p class="calibre3"><code>AbortController</code> is a Web/DOM API that allows us to abort web requests. It’s created <a id="_idIndexMarker440" class="pcalibre1 calibre6 pcalibre"/>using its constructor, <code>new AbortController</code>, and controlling a request (to potentially cancel it) is <a id="_idIndexMarker441" class="pcalibre1 calibre6 pcalibre"/>done with the <code>AbortController().signal</code> value, which is an <code>AbortSignal</code> object.</p>
<p class="calibre3">We <a id="_idIndexMarker442" class="pcalibre1 calibre6 pcalibre"/>instantiate the controller using <a id="_idIndexMarker443" class="pcalibre1 calibre6 pcalibre"/>the <code>new AbortController()</code> constructor call. If we want to make a <code>fetch</code> call cancellable, we pass <code>abortController.signal</code> as the <code>signal</code> option:</p>
<pre class="source-code">
function fetchWithCancel(url) {
  const abortController = new AbortController();
  const response = fetch(url, { signal:
    abortController.signal }).then((res) =&gt;
    res.json()
  );
  return {
    response,
  };
}</pre> <p class="calibre3">If we want to cancel the <code>fetch</code> request, we can then call <code>abortController.cancel</code>. We’ll add this as a <code>cancel</code> function on the <code>fetchWithCancel</code> returned output:</p>
<pre class="source-code">
function fetchWithCancel(url) {
  // no changes to contents
  return {
    // no changes to other keys in the object
    cancel: () =&gt; abortController.abort(),
  };
}</pre> <p class="calibre3">Finally, we need to ensure that when we see <code>AbortError</code>, we handle it. In this case, we’ll handle it with a <code>Promise().catch</code> handler, which, on seeing an <code>AbortError</code>, will return ‘<code>Aborted'</code>, and re-throw the error otherwise.</p>
<p class="calibre3">An <code>AbortError</code> error instance has a name property equal to <code>'AbortError'</code>, but also a message such as <code>DOMException [AbortError]: This operation was aborted</code>, along with its stack trace:</p>
<pre class="source-code">
function fetchWithCancel(url) {
  // no change to abortController initiationisalition
  const response = fetch(url, { signal: abortController.signal })
    .then((res) =&gt; res.json())
    .catch((err) =&gt; {
      if (err.name === 'AbortError') return 'Aborted';
      throw err;
    });
  // no change to return value
}</pre> <p class="calibre3">Given <a id="_idIndexMarker444" class="pcalibre1 calibre6 pcalibre"/>two API calls to fakestoreapi, <code>/products/1</code>, and <code>/products/2</code>, we can cancel one of them without affecting <a id="_idIndexMarker445" class="pcalibre1 calibre6 pcalibre"/>the other request as follows, by calling <code>fetchWithCancel</code> with both URLs and storing the output in two <a id="_idIndexMarker446" class="pcalibre1 calibre6 pcalibre"/>variables. Note that we’re not using <code>await</code> yet.</p>
<p class="calibre3">We can <a id="_idIndexMarker447" class="pcalibre1 calibre6 pcalibre"/>then cancel the fetch for <code>/products/1</code> by using the <code>.cancel()</code> function we built earlier:</p>
<pre class="source-code">
const fetchProduct1 = fetchWithCancel
  ('https://fakestoreapi.com/products/1');
const fetchProduct2 = fetchWithCancel('https://fakestoreapi.com/products/2');
fetchProduct1.cancel();</pre> <p class="calibre3">The outcome of this is that when we await <code>fetchProduct1.response</code> and <code>fetchProduct2.response</code>, the output for <code>fetchProduct1.response</code> is <code>'Aborted'</code>, which means an <code>AbortError</code> instance was handled in <code>fetchWithCancel</code> (i.e., our cancellation succeeded).</p>
<p class="calibre3">The output for <code>fetchProduct2.response</code> is the product object:</p>
<pre class="source-code">
assert.deepEqual(await fetchProduct1.response, 'Aborted');
assert.deepEqual(await fetchProduct2.response, {
  category: "men's clothing",
  description:
    'Slim-fitting style, contrast raglan long sleeve, three-button henley placket, light weight &amp; soft fabric for breathable and comfortable wearing. And Solid stitched shirts with round neck made for durability and a great fit for casual fashion wear and diehard baseball fans. The Henley style round neckline includes a three-button placket.',
  id: 2,
  image:
    'https://fakestoreapi.com/img
      /71-3HjGNDUL._AC_SY879._SX._UX._SY._UY_.jpg',
  price: 22.3,
  rating: {
    count: 259,
    rate: 4.1,
  },
  title: 'Mens Casual Premium Slim Fit T-Shirts ',
});</pre> <p class="calibre3">Manually <a id="_idIndexMarker448" class="pcalibre1 calibre6 pcalibre"/>cancelling a request is useful, but a <a id="_idIndexMarker449" class="pcalibre1 calibre6 pcalibre"/>more widespread use case <a id="_idIndexMarker450" class="pcalibre1 calibre6 pcalibre"/>is to time a request out when <a id="_idIndexMarker451" class="pcalibre1 calibre6 pcalibre"/>it takes more than a certain amount of time. This is useful to ensure a responsive user experience for customers. Different situations call for longer or shorter timeout delays.</p>
<p class="calibre3">We can implement a <code>fetchWithTimeout</code> function using <code>fetch</code>, <code>AbortController</code>, and <code>setTimeout</code>.</p>
<p class="calibre3">Our function takes a URL and an optional timeout, which we’ll default to <code>500</code> (for 500 ms). Similar to our manual cancellation scenario (see <code>fetchWithCancel</code>), we’ll create an <code>abortController</code> object and pass its <code>signal</code> property as an option to <code>fetch</code>:</p>
<pre class="source-code">
async function fetchWithTimeout(url, timeout = 500) {
  const abortController = new AbortController();
  return fetch(url, { signal: abortController.signal });
}</pre> <p class="calibre3">In order <a id="_idIndexMarker452" class="pcalibre1 calibre6 pcalibre"/>to cancel the fetch after a certain <a id="_idIndexMarker453" class="pcalibre1 calibre6 pcalibre"/>amount of time, we’ll use <code>setTimeout</code>. The <code>setTimeout</code> handler will simply call <code>abortController.abort()</code> and we’ll set the timeout delay to our <code>timeout</code> variable:</p>
<pre class="source-code">
async function fetchWithTimeout(url, timeout = 500) {
  // no change to abortController
  setTimeout(() =&gt; {
    abortController.abort();
  }, timeout);
  // no change to fetch call or return
}</pre> <p class="calibre3">When <a id="_idIndexMarker454" class="pcalibre1 calibre6 pcalibre"/>the request takes less time <a id="_idIndexMarker455" class="pcalibre1 calibre6 pcalibre"/>than the <code>fetch</code> request takes to complete, we receive the response data:</p>
<pre class="source-code">
const timedoutFetchShouldSucceedData = await fetchWithTimeout(
  'https://fakestoreapi.com/products/1',500
)
  .then((res) =&gt; res.json())
  .catch((error) =&gt; {
    if (error.name === 'AbortError') {
      return 'Aborted';
    }
    throw error;
  });
console.assert(
  timedoutFetchShouldSucceedData.id === 1,
  'fetchWithTimeout with 500ms timeout should have
    succeeded'
);</pre> <p class="calibre3">When a <code>fetch</code> request takes longer than the configured timeout, we receive an <code>AbortError</code> instance:</p>
<pre class="source-code">
const timedoutFetchShouldAbort = await fetchWithTimeout(
  'https://fakestoreapi.com/products/1',10
)
  .then((res) =&gt; res.json())
  .catch((error) =&gt; {
    if (error.name === 'AbortError') {
      return 'Aborted';
    }
    throw error;
  });
console.assert(
  timedoutFetchShouldAbort === 'Aborted',
  'fetchWithTimeout with 10ms timeout should have
    aborted but did not'
);</pre> <p class="calibre3">We’ve <a id="_idIndexMarker456" class="pcalibre1 calibre6 pcalibre"/>now seen how to use <code>AbortController</code> to control <code>fetch</code> cancellation manually and how to use it to create a “fetch <a id="_idIndexMarker457" class="pcalibre1 calibre6 pcalibre"/>with timeout” utility. We can use <code>AbortController</code> to cancel operations that aren’t required <a id="_idIndexMarker458" class="pcalibre1 calibre6 pcalibre"/>any more, thereby reducing <a id="_idIndexMarker459" class="pcalibre1 calibre6 pcalibre"/>network usage.</p>
<p class="calibre3">Next, we’ll look at further patterns <a id="_idTextAnchor246" class="pcalibre1 calibre6 pcalibre"/>that can help optimize situations with high volumes of requests.</p>
<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor247" class="pcalibre1 calibre6 pcalibre"/>Throttling, debouncing, and batching asynchronous operations</h1>
<p class="calibre3">Throttling is <a id="_idIndexMarker460" class="pcalibre1 calibre6 pcalibre"/>an operation in which requests are dropped until a certain time is reached. For example, for a 10 ms throttle timeout, once a request is made, no request in the next 10 ms will be sent. If multiple requests are made between 0 ms and 10 ms, only the last request will be sent after the 10 ms timeout expires.</p>
<p class="calibre3">In JavaScript, such a throttle function can be implemented as follows.</p>
<p class="calibre3">A higher-order function, <code>throttle</code> takes in an <code>fn</code> parameter and returns an executable <a id="_idIndexMarker461" class="pcalibre1 calibre6 pcalibre"/>function with the same input signature as the <code>fn</code> parameter.</p>
<p class="calibre3">When the “throttled” <code>fn</code> function is called, we set <code>isThrottled = true</code> in order to be able to discard calls between the first call and a configured timeout:</p>
<pre class="source-code">
function throttle(fn, timeout) {
  let isThrottled = false;
  return (...args) =&gt; {
    isThrottled = true;
    return fn(...args);
  };
}</pre> <p class="calibre3">We now need to ensure <code>fn</code> is not called while <code>isThrottled</code> is true. We achieve this by returning early from our returned “throttled” <code>fn</code> function.</p>
<p class="calibre3">We save the arguments with which the “throttled” <code>fn</code> function was called so that they can be used when the timeout expires:</p>
<pre class="source-code">
function throttle(fn, timeout) {
  // no change to existing variable definitions
  let lastCallArgs = null;
  return (...args) =&gt; {
    if (isThrottled) {
      lastCallArgs = args;
      return;
    }
    // no change to "initial call" case
  };
}</pre> <p class="calibre3">Finally, we configure <code>setTimeout</code> to trigger a reset of the throttled state and execute the last function call:</p>
<pre class="source-code">
function throttle(fn, timeout) {
  // no change to existing variable definitions
  return (...args) =&gt; {
    // no change to short-circuit logic
    setTimeout(() =&gt; {
      isThrottled = false;
      return fn(...lastCallArgs);
    }, timeout);
    // no change to "initial call" case
  };
}</pre> <p class="calibre3">A simple <a id="_idIndexMarker462" class="pcalibre1 calibre6 pcalibre"/>example of this in use is the following scenario, where many messages could be sent in a given time. Instead, we want to throttle to 1 message every 1 ms interval.</p>
<p class="calibre3">Our <code>storeMessage</code> function is as follows:</p>
<pre class="source-code">
let messages = [];
const storeMessage = (message) =&gt; {
  messages.push(message);
};</pre> <p class="calibre3">We can generate a <code>throttledStoreMessage</code> function with a 1 ms timeout as follows.</p>
<p class="calibre3">When called ten times synchronously and subsequently waiting for timers to complete, only the first (<code>'throttle-1'</code>) and last (<code>'throttle-10'</code>) calls are recorded:</p>
<pre class="source-code">
const throttledStoreMessage = throttle(storeMessage, 1);
throttledStoreMessage('throttle-1');
throttledStoreMessage('throttle-2');
throttledStoreMessage('throttle-3');
throttledStoreMessage('throttle-4');
throttledStoreMessage('throttle-5');
throttledStoreMessage('throttle-6');
throttledStoreMessage('throttle-7');
throttledStoreMessage('throttle-8');
throttledStoreMessage('throttle-9');
throttledStoreMessage('throttle-10');
await timeout();
assert.deepEqual(messages, ['throttle-1', 'throttle-10']);
function timeout(ms = 0) {
  return new Promise((r) =&gt; setTimeout(r, ms));
}</pre> <p class="calibre3">If we reset <a id="_idIndexMarker463" class="pcalibre1 calibre6 pcalibre"/>the messages and wait for the timers to complete after our call with <code>'throttle-5'</code>, we finish with <code>['throttle-1', 'throttle-5', 'throttle-6']</code>, that is, the first call, and the calls before and after the timers are cleared.</p>
<p class="calibre3">If we clear the timers one more time after completing all our calls, <code>'throttle-10'</code> is also present in our messages list, meaning that call completed:</p>
<pre class="source-code">
messages = [];
throttledStoreMessage('throttle-1');
throttledStoreMessage('throttle-2');
throttledStoreMessage('throttle-3');
throttledStoreMessage('throttle-4');
throttledStoreMessage('throttle-5');
await timeout();
throttledStoreMessage('throttle-6');
throttledStoreMessage('throttle-7');
throttledStoreMessage('throttle-8');
throttledStoreMessage('throttle-9');
throttledStoreMessage('throttle-10');
assert.deepEqual(messages, ['throttle-1', 'throttle-5', 'throttle-6']);
await timeout();
assert.deepEqual(messages, [
  'throttle-1',
  'throttle-5',
  'throttle-6',
  'throttle-10',
]);</pre> <p class="calibre3">We’ve now seen how to throttle a function. We can now look at debouncing.</p>
<p class="calibre3">A <code>debounce</code> function in JavaScript takes an <code>fn</code> parameter, which is a function. The goal is that the debounced <code>fn</code> function should discard all calls except the last call before it’s not called for a <code>timeout</code> period.</p>
<p class="calibre3">In order to <a id="_idIndexMarker464" class="pcalibre1 calibre6 pcalibre"/>do this, we should “delay” the function call until after a timeout completes. We save the <code>timeoutId</code> reference in order to cancel the call if the debounced <code>fn</code> function is called again. We use <code>setTimeout</code> and forward the arguments with which the debounced <code>fn</code> function was called:</p>
<pre class="source-code">
function debounce(fn, timeout) {
  let timeoutId;
  return (...args) =&gt; {
    timeoutId = setTimeout(() =&gt; {
      fn(...args);
    }, timeout);
  };
}</pre> <p class="calibre3">With the current state of the <code>debounce</code> function, there would still be as many calls to <code>fn</code> as there are to the debounced <code>fn</code> function; they would just be queued for delayed execution based on the timeout. To avoid this, we can cancel the previous call timeout by using <code>clearTimeout(timeoutId)</code>:</p>
<pre class="source-code">
function debounce(fn, timeout) {
  // no change to variable declarations
  return (...args) =&gt; {
    clearTimeout(timeoutId);
    // no change to setTimeout logic
  };
}</pre> <p class="calibre3">With these changes in place, if we create a <code>debouncedStoredMessage</code> function with a 1 ms timeout and call it 10 times, it will not execute until we wait for the timer to complete:</p>
<pre class="source-code">
messages = [];
const debouncedStoredMessage = debounce(storeMessage, 1);
debouncedStoredMessage('debounce-1');
debouncedStoredMessage('debounce-2');
debouncedStoredMessage('debounce-3');
debouncedStoredMessage('debounce-4');
debouncedStoredMessage('debounce-5');
debouncedStoredMessage('debounce-6');
debouncedStoredMessage('debounce-7');
debouncedStoredMessage('debounce-8');
debouncedStoredMessage('debounce-9');
debouncedStoredMessage('debounce-10');
assert.deepEqual(messages, []);
await timeout();
assert.deepEqual(messages, ['debounce-10']);</pre> <p class="calibre3">We can <a id="_idIndexMarker465" class="pcalibre1 calibre6 pcalibre"/>further showcase this by waiting for timers to complete after the fifth call. In that case, the fifth call will trigger and, given another timeout window clears, the tenth call will also trigger:</p>
<pre class="source-code">
messages = [];
debouncedStoredMessage('debounce-1');
debouncedStoredMessage('debounce-2');
debouncedStoredMessage('debounce-3');
debouncedStoredMessage('debounce-4');
debouncedStoredMessage('debounce-5');
await timeout();
debouncedStoredMessage('debounce-6');
debouncedStoredMessage('debounce-7');
debouncedStoredMessage('debounce-8');
debouncedStoredMessage('debounce-9');
debouncedStoredMessage('debounce-10');
assert.deepEqual(messages, ['debounce-5']);
await timeout();
assert.deepEqual(messages, ['debounce-5', 'debounce-10']);</pre> <p class="calibre3">We’ve now seen how to throttle and debounce functions, which allows us to ensure operations don’t trigger more than necessary.</p>
<p class="calibre3">In a scenario where we have a “search as you type” or “suggest as you type” input (sometimes referred to as a “typeahead”), which needs to make API requests to get search results or suggestions, it usually makes sense to use either <code>debounce</code>, to wait for the user to stop typing before making a request, or to throttle the requests so that an API request is made every window instead of every keystroke.</p>
<p class="calibre3">This can also be coupled with other heuristics to avoid overwhelming the API server with unnecessary requests. For example, it’s usual to avoid sending requests until a few characters have been typed since the search request is too broad with only 1 or 2 characters.</p>
<p class="calibre3">We’ve seen how to protect an API by reducing the number of requests using throttling or debouncing. In the <em class="italic">Parallel asynchronous operation patterns</em> section, we used <code>Promise.all</code> to send requests in parallel. This can be another scenario where the target of our asynchronous operations can get overwhelmed. To avoid an overload scenario, it can be useful to batch our requests.</p>
<p class="calibre3">“Batching” is a way to limit concurrency, for example, instead of sending 20 requests at the same time (in parallel), we want to send 5 at a time.</p>
<p class="calibre3">A <code>batch</code> function takes an <a id="_idIndexMarker466" class="pcalibre1 calibre6 pcalibre"/>array and a batch size and returns an array of arrays. The nested arrays have a maximum length of “batch size.”</p>
<p class="calibre3">We start by calculating how many <code>batchItem</code> list items we’ll need in our <code>batches</code> array. In order to do this, we divide the input array length by the batch size and apply the <code>ceil</code> function to the value. In other words, we round up <code>inputLength</code> divided by <code>batchSize</code> to the next largest integer value.</p>
<p class="calibre3">We can then generate our <code>batches</code> array with the right size (<code>batchCount</code>, as computed):</p>
<pre class="source-code">
function batch(inputArray, batchSize) {
  const batchCount = Math.ceil(inputArray.length /
    batchSize);
  const batches = Array.from({ length: batchCount });
}</pre> <p class="calibre3">We then go through each of the batches using <code>Array.prototype.map()</code>. The items in <code>batches</code> are initially undefined, but we use the index of the item (which we’ll call <code>batchNumber</code>). For each item in <code>batches</code>, we take the items from <code>batchNumber * batchSize</code> to <code>(batchNumber + 1) * batchSize</code> and they constitute the contents of our <code>batches[batchNumber]</code> array item:</p>
<pre class="source-code">
function batch(inputArray, batchSize) {
  // no change to existing size computations
  return batches.map((_, batchNumber) =&gt; {
    return inputArray.slice(
      batchNumber * batchSize,
      (batchNumber + 1) * batchSize
    );
  });
}</pre> <p class="calibre3">You’ll note <a id="_idIndexMarker467" class="pcalibre1 calibre6 pcalibre"/>that we’re generating the array with <code>Array.from</code> <em class="italic">and then</em> populating it using <code>Array.prototype.map()</code>, however, <code>Array.from()</code> supports a second parameter, which is a mapping function. Our code could therefore be as follows:</p>
<pre class="source-code">
function batch(inputArray, batchSize) {
  const batchCount = Math.ceil(inputArray.length /
    batchSize);
  return Array.from({ length: batchCount }, (_,
    batchNumber) =&gt; {
    return inputArray.slice(
      batchNumber * batchSize,
      (batchNumber + 1) * batchSize
    );
  });
}</pre> <p class="calibre3">In any case, our <code>batch</code> function work for any array, for example, a 10-element array can be batched into chunks of 4 or 3 correctly by our function:</p>
<pre class="source-code">
assert.deepEqual(batch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 4), [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11],
]);
assert.deepEqual(batch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 3), [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [10, 11],
]);</pre> <p class="calibre3">The preceding example showcased a synchronous example. For our use case – improving the performance of asynchronous operations, we need to handle Promises. The good news is that Promises can be stored in an array just as well:</p>
<pre class="source-code">
const numberResolverBatches = batch(
  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
  2
);
console.assert(numberResolverBatches.length === 2);
console.assert(numberResolverBatches[0].length === 2);
console.assert(numberResolverBatches[1].length === 1);</pre> <p class="calibre3">To get the batched <a id="_idIndexMarker468" class="pcalibre1 calibre6 pcalibre"/>output of the Promises, however, we need to write a function that awaits all the Promises in each batch to resolve them sequentially.</p>
<p class="calibre3">This can be achieved by using a <code>for ... of</code> loop and <code>Promise.all</code>, as follows. We flatten out the resolved values:</p>
<pre class="source-code">
async function resolveBatches(batchedPromises) {
  const flattenedBatchOutput = [];
  for (const batch of batchedPromises) {
    const resolved = await Promise.all(batch);
    flattenedBatchOutput.push(...resolved);
  }
  return flattenedBatchOutput;
}
const batchOutput = await resolveBatches(numberResolverBatches);
assert.deepEqual(batchOutput, [1, 2, 3]);</pre> <p class="calibre3">In our example, the <code>Promise.resolve()</code> calls with <code>1</code>, <code>2</code>, and <code>3</code> can indeed be batched and resolved.</p>
<p class="calibre3">We’ve now seen how to build and use throttling, debouncing, and batching<a id="_idTextAnchor248" class="pcalibre1 calibre6 pcalibre"/> to improve the performance of our asynchronous operations in JavaScript.</p>
<h1 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor249" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve covered asynchronous operation orchestration patterns with Promises and async/await to manage sequential and parallel operations. We also covered advanced patterns such as request cancellation, implementing timeouts, the difference between throttling and debouncing, and finally, how to use batching in an asynchronous operation context.</p>
<p class="calibre3">In order to manage sequential asynchronous operations, we can use a Promise-based approach with <code>Promise().then()</code>, async/await, or mix both approaches. This helps keep our code simple to reason about. For parallel execution, we can leverage <code>Promise.all()</code> with <code>Promise.then()</code> or async/await. We also have multiple approaches to maintaining response data across asynchronous operations.</p>
<p class="calibre3">We can leverage <code>AbortController</code> to cancel requests. We implemented a timeout for the <code>fetch</code> response time using <code>AbortController</code> and <code>setTimeout</code>. Stopping in-flight requests is a useful cleanup step that can improve performance by reducing unnecessary load on our API origin.</p>
<p class="calibre3">Finally, the advanced asynchronous programming patterns allow fewer requests to happen via throttling and debouncing. We can also control the concurrency of our parallel requests using batching and resolving the batches. Again, these approaches can reduce unnecessary network traffic and load on the API servers.</p>
<p class="calibre3">Now that we’ve covered asynchronous programming performance patterns, with Promise, async/await, and advanced patterns, we can look at patterns for event-driven programming in JavaScript.</p>
</div>
</body></html>