- en: Chapter 2. Creating Variables and Mixins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 创建变量和混入
- en: 'A question: how often have you created components such as buttons, where you''ve
    used very similar colors multiple times throughout your code? It''s a real pain
    to manually alter. Using a preprocessor such as SASS or Less makes it easier,
    but with the overhead of a full-sized library.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题：你有多少次在代码中创建了像按钮这样的组件，使用了多次非常相似的颜色？手动修改真的很痛苦。使用预处理程序如SASS或Less可以使它更容易，但需要承担完整库的开销。
- en: 'Can we do it differently? Absolutely; throughout the next few chapters, we''ll
    explore different elements of PostCSS, before pulling it all together to produce
    a preprocessor application later in the book. We''ll begin our journey with a
    look at using variables and mixins; we''ll explore the basics of creating them
    first, before transitioning to support using PostCSS. In this chapter, we''ll
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能换一种方法吗？绝对可以；在接下来的几章中，我们将探索PostCSS的不同元素，然后在本书的后面部分将它们全部整合，以创建一个预处理程序应用。我们的旅程将从查看使用变量和混入开始；我们首先将探讨创建它们的基础知识，然后再过渡到支持使用PostCSS。在本章中，我们将涵盖以下主题：
- en: An overview of creating variables and mixins using existing preprocessors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有预处理程序创建变量和混入的概述
- en: Transitioning to using PostCSS equivalents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向使用PostCSS等效物
- en: Adding mixin support to PostCSS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将混入支持添加到PostCSS
- en: Examining the differences between standard preprocessors and PostCSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查标准预处理程序和PostCSS之间的差异
- en: Let's get cracking!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing variables and mixins
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍变量和混入
- en: So far, we've covered the basics of installing and configuring PostCSS—although
    there are a few steps involved, it's an easy process to get started with using
    the processor. To really get to know it though, there is no substitute for using
    it in anger; it's amazing how much you can automate, with just a little care and
    planning!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了安装和配置PostCSS的基础知识——尽管涉及几个步骤，但使用处理器开始的过程很容易。然而，要真正了解它，没有比在实际中使用它更好的替代品了；只需一点小心和计划，你就可以自动化很多事情！
- en: Let's put that to the test and use it to create a couple of simple examples
    using variables, functions, and mixins. We'll start with creating the original
    version using SASS, before converting it to use PostCSS plugins. The demos do
    assume a level of prior knowledge around using SASS, so if you are at all unfamiliar,
    then you may like to refer to my book, *SASS Essentials*, available from Packt
    Publishing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用变量、函数和混入来创建几个简单的示例来测试它。我们将从使用SASS创建原始版本开始，然后再将其转换为使用PostCSS插件。这些演示假设您对使用SASS有一定的了解，如果您完全不熟悉，那么您可能想参考我的书籍《SASS
    Essentials》，由Packt Publishing出版。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of note: we will make good use of the project folders we created back
    in [Chapter 1](ch01.html "Chapter 1. Introducing PostCSS"), *Introducing PostCSS*,
    where `src` will be our in-tray, and `dest` will contain the compiled code. Make
    sure you have this open in a window somewhere on your desktop!'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：我们将充分利用我们在[第一章](ch01.html "第一章. 介绍PostCSS")中创建的项目文件夹，*介绍PostCSS*，其中`src`将是我们的工作台，而`dest`将包含编译后的代码。确保你在桌面上某个窗口中打开了它！
- en: Okay, the first step in this process is to get SASS installed, so let's take
    a look at that now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个过程的第一步是安装SASS，所以现在让我们来看看。
- en: Setting up SASS
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置SASS
- en: Setting up SASS is really easy when using Gulp; we can use the same format of
    command to install it as we do for other plugins. The source code for the plugin
    is available at [https://github.com/dlmanning/gulp-sass](https://github.com/dlmanning/gulp-sass);
    it's a lightweight frontend for `node-sass`, which in turn is a Node binding for
    the C+ library, `libsass`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gulp设置SASS非常简单；我们可以使用与其他插件相同的命令格式来安装它。该插件的源代码可在[https://github.com/dlmanning/gulp-sass](https://github.com/dlmanning/gulp-sass)找到；它是一个轻量级的`node-sass`前端，而`node-sass`是一个C+库的Node绑定，即`libsass`。
- en: 'Let''s dive in and take a look at getting it installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨并查看如何安装它：
- en: We start, as usual, with Node. Fire up a Node.js command prompt session, then
    change to the working directory.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样从Node开始。启动一个Node.js命令提示符会话，然后切换到工作目录。
- en: 'At the command prompt, enter the following, then press *Enter*:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中，输入以下内容，然后按*Enter*：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If all is well, we should see something akin to this screenshot:![Setting up
    SASS](img/BO5194_02_01.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该会看到类似于以下截图的内容：![设置SASS](img/BO5194_02_01.jpg)
- en: 'Before we continue, though, I would recommend clearing out or saving the contents
    of the `dest` folder elsewhere for safe keeping, after each exercise:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, open a copy of `gulpfile.js` in Sublime Text; we need to make a number
    of changes, beginning with adding a reference to the `gulp-sass` plugin (as highlighted):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'SASS will, by default, produce code in unminified format; the addition of `{outputStyle:
    ''compressed''}` in the task will automatically compress the output code. This
    makes this line redundant, so go ahead and remove it:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also need to remove the reference to `cssnano` on or around line 19, so
    go ahead and remove this line:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On or around line 10, change the name of the styles task to `autoprefixer`
    and the dependency name to `lint-styles`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then remove these two lines:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the rename task, modify the `rename` task to match this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On or around line 25, we need to add in the `lint-styles` task—go ahead and
    add in this block of code, which will check our styles for consistency:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re almost done. Add in the next task; this tells Gulp about how we should
    compile any SASS files presented to the task runner:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to make a couple more changes. The key task that fires off a call to
    each of the sub tasks needs to be updated, to reflect the changes to our tasks:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our last change is to alter the watch facility to check for SASS files, and
    not pure CSS; go ahead and change the configuration object as shown:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, we have set up our processor to compile SASS files to valid CSS.
    We can prove this by compiling any SASS file. If all is well, our processor will
    produce valid style sheets and accompanying source map files automatically. Let's
    put this to the test as part of our next exercise, where we create an intriguing
    hover effect for images.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hover effect example
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've seen any of my previous books, then you will see I have a thing about
    flowers, and in particular orchids; indeed, the cover on my first book was that
    of a phalaenopsis, or moth orchid! We'll use a couple of images of orchids as
    the basis for our next demo, as shown in the screenshot over the page, where it
    shows our desired effect in motion for the top image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer using Less, then please skip to the end of this demo for an example
    using Less CSS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'For this demo, we will need a copy of the `tutorial1A` folder from the code
    download that accompanies this book; make sure you dig that out before continuing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Open up a copy of `style.scss` from the `src` folder within `tutorial1A`; let's
    take a look at its contents.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the file, we have a small handful of variables. These define some
    of the colors used within the code, and set the `$fullsize` variable to 100%:![Creating
    a hover effect example](img/BO5194_02_02.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sharp-eyed among you will spot that not all colors have been given a value;
    the reason for this will become clearer later in this chapter.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next up comes an example of a simple mixin, which converts pixel values to their
    rem unit equivalents, using `16px` as the base equivalent for `1rem` unit:![Creating
    a hover effect example](img/BO5194_02_04.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个简单mixin的示例，它将像素值转换为它们的rem单位等效值，以`16px`作为`1rem`单位的基准等效值：![创建悬停效果示例](img/BO5194_02_04.jpg)
- en: To complete the exercise, we need to download a font. The demo uses the Source
    Sans Pro font available at [http://www.fontsquirrel.com/fonts/source-sans-pro](http://www.fontsquirrel.com/fonts/source-sans-pro).
    Go ahead and download it; you will need to use the **Generator** option available
    from the black menu to produce a version that can be used online (it creates the
    CSS we've used in our demo).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为了完成练习，我们需要下载一个字体。演示使用了可在[http://www.fontsquirrel.com/fonts/source-sans-pro](http://www.fontsquirrel.com/fonts/source-sans-pro)找到的Source
    Sans Pro字体。请继续下载它；您将需要使用黑色菜单中可用的**生成器**选项来生成一个可以在线使用的版本（它创建了我们在演示中使用的CSS）。 '
- en: At this point, go ahead and drop a copy of the `style.scss` file from the `tutorial1A`
    folder into the `src` folder in our project area.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，请将`tutorial1A`文件夹中的`style.scss`文件复制到我们项目区域的`src`文件夹中。
- en: We also need the `img` folder and the `index.html` file—go ahead and copy both
    across to the root of our project area.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`img`文件夹和`index.html`文件——请将它们都复制到我们项目区域的根目录。
- en: 'Fire up a Node.js command prompt window, then enter this at the prompt and
    press *Enter*:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个Node.js命令提示符窗口，然后在提示符中输入以下内容并按*Enter*：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If all is well, we should see compressed CSS files and source maps appear in
    the `dest` folder in our project area—copy the `maps` folder and `style.min.css`
    into the `css` folder of `tutorial1A`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在我们的项目区域的`dest`文件夹中看到压缩的CSS文件和源映射出现——将`maps`文件夹和`style.min.css`复制到`tutorial1A`的`css`文件夹中。
- en: Go ahead and preview the results in a browser. If all is well, we should see
    two orchid images appear on screen; if you hover over either one, you will see
    it fly to the left or right, to reveal an information box with information about
    the orchid:![Creating a hover effect example](img/BO5194_02_03.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中预览结果。如果一切顺利，我们应该在屏幕上看到两个兰花图像；如果您悬停在任何一个上，您将看到它飞向左或右，以显示有关兰花的信息框：![创建悬停效果示例](img/BO5194_02_03.jpg)
- en: Interesting effect, huh? It's a simple animation that uses `scale()` to shrink
    the image to `0.5` (or 50%) of its size and slides it to the right, before sliding
    in the `infobox` immediately behind it. Take the mouse off the image and the reverse
    happens—it's the sample principle for the second image—but in reverse; the code
    sets an `ltr` and `rtl` class to determine which direction the image should move
    in the demo.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的效果，对吧？这是一个简单的动画，使用`scale()`将图像缩小到其大小的`0.5`（或50%），然后向右滑动，在它后面的`infobox`立即滑动进入。将鼠标移出图像，就会发生相反的情况——这是第二张图像的示例原理——但方向相反；代码设置了一个`ltr`和`rtl`类来决定图像在演示中应该向哪个方向移动。
- en: Using Less CSS as an alternative
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Less CSS作为替代方案
- en: A copy of this demo using the equivalent code from the Less CSS pre-processor
    is available in the code download that accompanies this book. It's in the `Tutorial1B`
    folder if your preference is to use the Less CSS pre-processor; you will need
    to install the `gulp-less` plugin from [https://github.com/plus3network/gulp-less](https://github.com/plus3network/gulp-less),
    using NodeJS (in the same manner as other plugins that we've installed). An updated
    copy of the Gulp task file is also included in this folder, along with completed
    versions of the CSS code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包含来自Less CSS预处理器等效代码的此演示副本可在本书附带的代码下载中找到。如果您更喜欢使用Less CSS预处理器，它位于`Tutorial1B`文件夹中；您需要从[https://github.com/plus3network/gulp-less](https://github.com/plus3network/gulp-less)安装`gulp-less`插件，使用NodeJS（与其他我们已安装的插件相同的方式）。此文件夹还包括更新后的Gulp任务文件以及CSS代码的完成版本。
- en: Transitioning to using PostCSS
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向使用PostCSS
- en: Up until now, we've used SASS to build our demo; granted, it's not a particularly
    complex one, but as I always say, we must start somewhere!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用SASS来构建我们的演示；当然，它并不特别复杂，但正如我经常说的，我们必须从某个地方开始！
- en: Our demo is a perfect example of how we can introduce PostCSS to provide replacements
    for the SASS variables and mixins we've used—for this, we will avail ourselves
    of three plugins, namely `postcss-variables`, `postcss-mixins`, and `postcss-calc`.
    The first two should be self-explanatory; the third is required in the replacement
    font mixin that we've used in our code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough chit-chat, let's get stuck in and begin to alter our code; we'll
    start with adding variable support.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Adding variable support to PostCSS
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of PostCSS plugins is that most (if not all) can be installed using
    the same method as PostCSS itself, we can use the package manager of Node.js to
    handle the process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with `postcss-css-variables`, which we will use to handle variable
    support; the source for this plugin is available from [https://github.com/MadLittleMods/postcss-css-variables](https://github.com/MadLittleMods/postcss-css-variables).
    Let''s get it installed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a NodeJS command prompt, then change the working directory to our project
    area.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt, enter the following command, then press *Enter*:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If all is well, we should see the results of the installation appear, as shown
    in this screenshot:![Adding variable support to PostCSS](img/BO5194_02_08.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, Node will have also added an entry to the `package.json` file
    for the new plugin. Perfect—we can now put it to good use and switch to using
    the plugin in place of using SASS. Let's take a look at how to achieve this, as
    part of the upcoming exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Updating our hover effect demo
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we're altering code to use PostCSS for the first time, it naturally makes
    sense to start with something simple; incorporating variables and mixins into
    our code is the perfect place to begin.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'For this next exercise, we''re going to create a handful of variables to store
    some values, then add a mixin to handle styles for the fonts used in the demo.
    Let''s make a start:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by opening up a copy of `gulpfile.js` from the root of our project
    area—we first need to make some changes to accommodate using the new plugin.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `gulpfile.js`, add this line immediately below the first block of `var`
    statements—this should be on or around line 9:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now need to make some changes to our gulp task file—we''ll start with the
    simplest, which is to remove the `var` reference to SASS, as we will no longer
    need it:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have a reference to the `postcss-css-variables` plugin, we need
    to make use of it in our tasks. Go ahead and amend the highlighted lines of code
    in the `autoprefixer` task, as indicated; this also removes the dependency on
    the lint-styles task, as this is no longer needed:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that we''ve also reinstated the `cssnano` command—you will also need to
    add this line in as a variable declaration, as indicated:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A little further down, on or around line 25, change the code as highlighted,
    as we will no longer use SASS to compile our code; we can tweak the order in which
    each task is run:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next up, we can remove the SASS task in its entirety:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以完全删除SASS任务：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Toward the end of the file, go ahead and alter the default task as indicated—we
    don''t need to call the SASS task, as it has now been removed:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，按照指示更改默认任务——由于SASS任务已被移除，我们不需要调用SASS任务：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alter the `gulp.watch` command to look for plain CSS files in the `src` folder—we''re
    not using SASS, so the reference to `scss` format files is now invalid and needs
    to be changed:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`gulp.watch`命令以在`src`文件夹中查找纯CSS文件——我们不再使用SASS，因此对`scss`格式文件的引用现在无效，需要更改：
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, if all is well, we should have a working gulp task file that
    we can now use to compile our code. Let''s go ahead and start to convert the code
    in our orchid demo, to use PostCSS:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，如果一切顺利，我们应该有一个可以现在使用的正在工作的gulp任务文件。让我们继续将我们的orchid演示中的代码转换为使用PostCSS：
- en: We'll start by saving a copy of the `Tutorial2` folder from the code download
    that accompanies this book, locally, to within the project area we created under
    `c:\wamp\www`, back in [Chapter 1](ch01.html "Chapter 1. Introducing PostCSS"),
    *Introducing PostCSS*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将本书附带的代码下载中的`Tutorial2`文件夹的副本保存在我们之前在`c:\wamp\www`下创建的项目区域中，回到[第1章](ch01.html
    "第1章。介绍PostCSS")，*介绍PostCSS*。
- en: Open up a copy of `style.css` from within the `src` folder of the `Tutorial2`
    folder. At the top of the file, remove lines 1 to 14 (the variables and mixin
    code), so that the file starts with the `font-face` declaration.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Tutorial2`文件夹中的`src`文件夹内的`style.css`副本。在文件顶部，删除第1到14行（变量和mixin代码），使文件从`font-face`声明开始。
- en: 'In its place, add the following lines—these are the replacement variable assignments:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其位置，添加以下行——这些是替换变量赋值：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Further down, look for the `html`, `body {` declaration, and alter it as indicated—note
    the syntax used for the `var` statements; this is not the same as standard SASS.
    We''ve changed it to the format supported by the `postcss-css-variables` plugin:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面，寻找`html`，`body {`声明，并按照指示进行更改——注意`var`语句使用的语法；这不同于标准的SASS。我们将其更改为`postcss-css-variables`插件支持的格式：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We added the `--fullsize` variable at the top of our style sheet—let''s make
    use of it now and update the `img` rule accordingly:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在样式表的顶部添加了`--fullsize`变量——现在让我们利用它并相应地更新`img`规则：
- en: '[PRE23]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final change we will make is to the `.info` class—go ahead and alter the
    background attribute as indicated:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将进行的最后一个更改是对`.info`类的更改——按照指示更改背景属性：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our code changes are complete, so go ahead and save the file—once done, fire
    up a NodeJS command prompt, and change to the project working area.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的所有代码更改都已完成，所以请保存文件——完成后，启动NodeJS命令提示符，并切换到项目工作区。
- en: Save the file as `styles.css` into the `src` folder of our project area.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`styles.css`到我们的项目区域的`src`文件夹中。
- en: 'Switch to the NodeJS command prompt, then enter the usual command at the prompt,
    and press *Enter*:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到NodeJS命令提示符，然后在提示符中输入通常的命令，并按*Enter*：
- en: '[PRE25]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Copy the compiled code back to the `css` folder within `Tutorial2`. If all is
    well, when we preview the results in a browser, we should see our demo continue
    to work as shown at the start of the first part of this exercise.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译后的代码复制回`Tutorial2`文件夹内的`css`文件夹。如果一切顺利，当我们在浏览器中预览结果时，我们应该看到我们的演示继续按照本练习第一部分开始时所示的方式工作。
- en: 'Phew, there were a fair few steps there! There is a copy of the completed stylesheets,
    both prior to and post compilation, available in the code download that accompanies
    this book: they can be found in the `css` | `completed` folder. You will need
    to rename the two style sheet files to just `style.css` for them to work correctly.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸一下，这里有很多步骤！本书附带的代码下载中提供了完成后的样式表副本，包括编译前和编译后，它们可以在`css` | `completed`文件夹中找到。您需要将两个样式表文件重命名为`style.css`才能正确工作。
- en: If you want to see the effects of compiling variables, without committing changes
    to code, then have a look at the playground offered with this plugin, at [https://madlittlemods.github.io/postcss-css-variables/playground/](https://madlittlemods.github.io/postcss-css-variables/playground/).
    It's a great way to get accustomed to using the `postcss-css-variables` plugin,
    before diving in and editing production code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不提交代码更改的情况下查看编译变量的效果，那么请查看此插件提供的游乐场，在[https://madlittlemods.github.io/postcss-css-variables/playground/](https://madlittlemods.github.io/postcss-css-variables/playground/)。这是在深入编辑生产代码之前熟悉使用`postcss-css-variables`插件的好方法。
- en: Okay, let's change tack; we've covered a number of key concepts in our demo,
    so let's take a moment to let the proverbial dust settle, and explore what we've
    learned through the demo.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们改变一下方向；在我们的演示中，我们已经覆盖了许多关键概念，所以让我们花点时间让事情尘埃落定，并探索通过演示学到的内容。
- en: Taking it a step further
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步来说
- en: 'Over the last few pages, we''ve created a simple demo, which shows off animated
    information boxes for a couple of orchid images. There''s nothing outrageous or
    complex about what we''ve done, but nevertheless, it serves to illustrate some
    key points about using this plugin, and PostCSS in general:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，我们创建了一个简单的演示，展示了几个兰花图像的动画信息框。我们做的事情既不夸张也不复杂，但无论如何，它有助于说明使用此插件以及PostCSS的一些关键点：
- en: Although we used SASS to precompile our CSS code prior to conversion, we could
    easily have used another pre-processor, such as Less CSS or Stylus. The key here
    is to work as much as possible within the confines of a task runner such as Gulp,
    so that we don't need to introduce another technology into the mix.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们在转换之前使用SASS预编译了我们的CSS代码，但我们同样可以轻松地使用其他预处理器，如Less CSS或Stylus。关键是要尽可能在任务运行器（如Gulp）的范围内工作，这样我们就不需要将另一种技术引入其中。
- en: It is essential to note that although converting the code *looks* straightforward,
    the plugin does not compile in the same manner as pre-processors such as SASS
    would compile. It makes a direct translation from SASS to Less CSS difficult for
    anything more than simple code.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管将代码转换看起来很简单，但插件并不是像SASS这样的预处理器那样编译。对于比简单代码更复杂的情况，它直接从SASS转换到Less CSS变得困难。
- en: In this example, the key to understanding how it works is to follow the CSS
    Custom Properties Module Level 1 document from the W3C, which is available at
    [https://drafts.csswg.org/css-variables/](https://drafts.csswg.org/css-variables/).
    The trick here is to be aware of CSS specificity, or which element takes precedence
    over others; in this respect, PostCSS does not simply replace variables with values,
    but compiles code based on calculating CSS specificity. When using PostCSS, it
    is likely you will see the `:root` pseudo-element being used frequently—it's worth
    getting acquainted with how it works!
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，理解其工作原理的关键是遵循W3C的CSS自定义属性模块1级文档，该文档可在[https://drafts.csswg.org/css-variables/](https://drafts.csswg.org/css-variables/)找到。这里的技巧是要意识到CSS的特定性，或者哪个元素比其他元素有优先权；在这方面，PostCSS不仅仅是用值替换变量，而是根据计算CSS特定性来编译代码。当使用PostCSS时，你可能会经常看到`:root`伪元素被使用——了解它是如何工作的很有价值！
- en: Note
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an explanation of how CSS specificity works, please refer to [http://vanseodesign.com/css/css-specificity-inheritance-cascade/](http://vanseodesign.com/css/css-specificity-inheritance-cascade/).
    If needed, we can consider using a plugin to increase specificity—check out the
    `postcss-increase-specificity` plugin at [https://github.com/MadLittleMods/postcss-increase-specificity](https://github.com/MadLittleMods/postcss-increase-specificity).
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于CSS特定性如何工作的解释，请参阅[http://vanseodesign.com/css/css-specificity-inheritance-cascade/](http://vanseodesign.com/css/css-specificity-inheritance-cascade/)。如果需要，我们可以考虑使用插件来提高特定性——查看`postcss-increase-specificity`插件[https://github.com/MadLittleMods/postcss-increase-specificity](https://github.com/MadLittleMods/postcss-increase-specificity)。
- en: The modular nature of PostCSS means that we can be selective about the plugins
    we use—in this instance we used the `postcss-css-variables` plugin, which gives
    more flexibility than others such as `postcss-custom-properties`. As an alternative,
    we might consider separating our variables into a separate document, and import
    them in using the `postcss-constants` plugin (which is available at [https://github.com/macropodhq/postcss-constants](https://github.com/macropodhq/postcss-constants)).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostCSS的模块化特性意味着我们可以有选择性地使用插件——在这个例子中，我们使用了`postcss-css-variables`插件，它比其他如`postcss-custom-properties`等插件提供了更多的灵活性。作为替代方案，我们可能会考虑将变量分离到单独的文档中，并使用`postcss-constants`插件（可在[https://github.com/macropodhq/postcss-constants](https://github.com/macropodhq/postcss-constants)找到）导入它们。
- en: 'If we use the `postcss-css-variables` plugin, we can either store the values
    in the code itself, or hive them off into the gulp task file; an example of the
    latter would look like this:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`postcss-css-variables`插件，我们可以将值存储在代码本身中，或者将其分离到gulp任务文件中；后者的一个例子如下：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In short, we create a reference to each variable within the configuration object
    for `cssvariables`, as the alias for the `postcss-css-variables` plugin.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们在`cssvariables`配置对象中为每个变量创建一个引用，作为`postcss-css-variables`插件的别名。
- en: Creating an object map using this approach can have mixed benefits. For some,
    it reduces issues around **separation** **of concerns**, where we can keep more
    PostCSS code within the task file, and less within our style sheet. This can make
    for a task file that is harder to read; it's not a good route to take if you have
    lots of variables to define. In this instance, we would be better off exporting
    them to an import file and referencing them at compilation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法创建对象映射可以带来混合的好处。对于一些人来说，它减少了关于**关注点分离**的问题，我们可以将更多的 PostCSS 代码保留在任务文件中，而将更少的代码放在我们的样式表中。这可能会使任务文件更难阅读；如果你有很多变量需要定义，这不是一个好的选择。在这种情况下，我们最好将它们导出到导入文件中，并在编译时引用它们。
- en: If there is one important message at this point, it can be that of flexibility—the
    modular nature of PostCSS means that we can be free to pick and choose how we
    proceed; it really is a case of weighing up the pros and cons of using a plugin,
    and making a decision as to whether this best fits our needs, or if we need to
    look for an alternative solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时有一个重要的信息，那就是灵活性——PostCSS 的模块化特性意味着我们可以自由选择如何进行；这真的是权衡使用插件利弊，并决定这是否最适合我们的需求，或者我们需要寻找替代解决方案的情况。
- en: Setting the order of plugins
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置插件的顺序
- en: 'At this point, there is a key part of PostCSS we need to cover: the order we
    use when calling plugins in our task runner file. This might seem a little odd,
    but there are two good reasons for considering this when developing with PostCSS:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要介绍 PostCSS 的一个关键部分：在我们任务运行器文件中调用插件时使用的顺序。这可能会显得有些奇怪，但在使用 PostCSS 进行开发时考虑这一点有两个很好的理由：
- en: The first reason is simple—it's about making sure that we maintain a logical
    order of when tasks are completed at compilation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是简单的——它关乎确保我们在编译时保持任务完成的逻辑顺序。
- en: The second is a little more obscure, and will come with experience—some plugins
    need to be defined in the task file in a certain order, for them to work correctly.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因稍微有些晦涩，并且需要经验——一些插件需要按照特定的顺序在任务文件中定义，才能正确工作。
- en: 'Let''s explore what this means:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这意味着什么：
- en: 'If we take a look at the gulp task file that we''ve slowly been building up,
    you will notice a key difference between lines 13 and 19; and no, it''s not the
    task name, before you ask! The difference is the `[''lint-styles'']` constraint—this
    forces Gulp not to run this task until its predecessor has completed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们逐渐构建的 gulp 任务文件，你将注意到第 13 行和第 19 行之间存在一个关键的区别；而且，在你问之前，这不是任务名称！区别在于
    `['lint-styles']` 约束——这迫使 Gulp 在其前一个任务完成之前不运行此任务：
- en: '![Setting the order of plugins](img/BO5194_02_06.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![设置插件的顺序](img/BO5194_02_06.jpg)'
- en: I know this might sound like common sense, and that I am only preaching what
    you may already know, but getting the order that plugins are called in PostCSS
    is critical to the successful compilation of your file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来可能像常识，而且我只是在宣扬你可能已经知道的事情，但获取 PostCSS 中插件调用的顺序对于成功编译你的文件至关重要。
- en: As an example, when researching for this book, I frequently found that either
    my source map was only being produced for an uncompressed version of my style
    sheet, or that the minified style sheet wasn't being created at the right point.
    Simple issues, but tweaking the order can have a serious impact on what happens
    and when!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在撰写这本书的过程中，我经常发现我的源映射只针对样式表的未压缩版本生成，或者压缩后的样式表没有在正确的点创建。这些问题很简单，但调整顺序可能会对发生的事情和发生的时间产生重大影响！
- en: 'Continuing with the theme of order, it is likely you may see notes akin to
    this when browsing the source site of a PostCSS plugin:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论顺序的主题，你可能会在浏览 PostCSS 插件的源站点时看到类似这样的注释：
- en: '![Setting the order of plugins](img/BO5194_02_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![设置插件的顺序](img/BO5194_02_07.jpg)'
- en: 'This underlines why getting the order of your plugins is essential for an effective
    result: not only will tasks be completed in the right order and produce the expected
    results, but some plugins won''t even work. This should not necessarily be taken
    as being a fault; there will be a valid reason that means plugin *X* must come
    before plugin *Y*. The key thing here is that we take any constraints into consideration.
    It is worth checking, as others may add patch support to remove constraints, or
    fix it through forking their own version of the plugin.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这强调了插件顺序对于有效结果的重要性：不仅任务将按正确顺序完成并产生预期的结果，而且某些插件甚至可能无法工作。这并不一定意味着是错误；会有一个合理的理由说明插件
    *X* 必须在插件 *Y* 之前。关键是要考虑任何约束条件。值得检查，因为其他人可能会添加补丁支持以消除约束，或者通过分叉他们自己的插件版本来修复它。
- en: 'Okay, time to change focus and take a look at some different functionality:
    mixins. For the uninitiated, this is a key function frequently used in preprocessors
    such as SASS, where we can *mix-in* (yes, pun intended!) blocks of code.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候改变焦点，看看一些不同的功能：混入。对于初学者来说，这是预处理程序（如 SASS）中常用的一个关键功能，我们可以 *混入*（是的，有双关意味！）代码块。
- en: The idea here being that we can create anything, from a simple few lines to
    a complex, dynamic code excerpt that PostCSS will compile into our code and use
    to produce valid CSS. Let's dive in and take a closer look.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是我们可以创建任何东西，从简单的几行代码到复杂的、动态的代码片段，PostCSS 会将其编译到我们的代码中并用于生成有效的 CSS。让我们深入了解一下。
- en: Creating mixins with PostCSS
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostCSS 创建混入
- en: Our orchid demo so far uses a number of variables to define values in our code.
    While this works well, it is somewhat limiting; after all, creating lots of variables
    to handle different values is an expensive use of resources!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的兰花演示使用了多个变量来定义代码中的值。虽然这效果不错，但有些限制；毕竟，创建大量变量来处理不同的值是一种资源浪费的做法！
- en: A smarter approach is using mixins; this works well when we can group several
    statements together as a single definition, then clone this definition into multiple
    rule sets. Users of pre-processors will of course recognize this functionality;
    the PostCSS team have created a plugin to offer similar functionality within PostCSS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混入是一种更智能的方法；当我们能够将几个语句组合成一个单独的定义，然后将其复制到多个规则集中时，这种方法效果很好。当然，使用预处理器的人会认识到这种功能；PostCSS
    团队创建了一个插件，在 PostCSS 中提供类似的功能。
- en: 'The plugin source is available from [https://github.com/postcss/postcss-mixins](https://github.com/postcss/postcss-mixins),
    and can be installed via Node, using the same method we''ve covered throughout
    this chapter. We will also make use of the `postcss-calc` plugin (from [https://github.com/postcss/postcss-calc](https://github.com/postcss/postcss-calc))
    to create a simple mixin that handles pixel fall-back for rem values in our code.
    Let''s dive in and see how it works in action:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 插件源代码可在 [https://github.com/postcss/postcss-mixins](https://github.com/postcss/postcss-mixins)
    获取，并且可以通过 Node 使用本章中介绍的方法进行安装。我们还将使用 `postcss-calc` 插件（来自 [https://github.com/postcss/postcss-calc](https://github.com/postcss/postcss-calc)）来创建一个简单的混入，用于处理代码中
    rem 值的像素回退。让我们深入了解一下它是如何工作的：
- en: We'll start—as always—by installing the `postcss-mixins` plugin; for this, fire
    up a NodeJS command prompt, then change the working folder to our project area.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样开始安装 `postcss-mixins` 插件；为此，启动 NodeJS 命令提示符，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, enter each command separately, pressing *Enter* after each:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，逐个输入每个命令，每个命令后按 *Enter* 键：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If all is well, we should see the results of the output on-screen, as shown
    in this screenshot:![Creating mixins with PostCSS](img/BO5194_02_08.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在屏幕上看到输出结果，如图所示：![使用 PostCSS 创建混入](img/BO5194_02_08.jpg)
- en: Updating our hover effect demo
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的悬停效果演示
- en: 'At this point we will have support for mixins within PostCSS installed. Let''s
    make use of them by updating our gulp task file and style sheet. We''ll begin
    with the gulp task file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们将安装 PostCSS 中的混入支持。让我们通过更新我们的 gulp 任务文件和样式表来利用它们。我们首先从 gulp 任务文件开始：
- en: 'Let''s start by opening a copy of `gulpfile.js` from our project area, then
    adding the following lines immediately below the block of `var` declarations (on
    or around line 10):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先打开项目区域中的 `gulpfile.js` 的副本，然后在 `var` 声明块（大约在第 10 行）下方立即添加以下行：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, go ahead and alter this line, from within the `autoprefixer` task:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从 `autoprefixer` 任务中修改这一行：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save the file. We now need a copy of the demo files from the code download that
    accompanies this book—go ahead and save a copy of `Tutorial3` to within our project
    area.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。我们现在需要从本书附带的代码下载中获取演示文件的副本——请将 `Tutorial3` 的副本保存到我们的项目区域中。
- en: 'Open a copy of `style.css` from within the `src` folder, then add this block
    of code immediately after the variable declarations declared in the `--root` rule:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹内打开 `style.css` 的副本，然后在 `--root` 规则中声明的变量声明之后立即添加此代码块：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the mixin in place, we now need to adjust our code to make use of the
    mixin; this requires a few changes. The first change is in the `h3` rule declaration:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在混合设置好之后，我们现在需要调整我们的代码以使用混合；这需要一些更改。第一个更改是在 `h3` 规则声明中：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A little further down, go ahead and change the first two lines of the `.info
    h3` rule, as indicated:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面一点，按照指示更改 `.info h3` 规则的前两行：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The third and final change is in the rule for `.info p`. Change it as shown:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三和最后的更改是在 `.info p` 规则中。按照以下方式更改它：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save the file, then copy it to the `src` folder in our project area.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后将其复制到项目区域的 `src` 文件夹中。
- en: 'Fire up a NodeJS command prompt, then switch to the project area, enter the
    usual command at the prompt, and press *Enter*:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 NodeJS 命令提示符，然后切换到项目区域，在提示符中输入常规命令，并按 *Enter* 键：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may see some option messages from stylelint: these can be safely ignored
    for now, but we will explore how to optimize this later in the book.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会看到一些来自 stylelint 的选项消息：现在可以安全地忽略这些消息，但我们在本书的后面部分将探讨如何优化这些。
- en: Copy the compiled code back to the `src` folder within `Tutorial3`. If all is
    well, when we preview the results in a browser, we should see our demo continue
    to work as shown at the start of the first part of this exercise.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译后的代码复制回 `Tutorial3` 中的 `src` 文件夹。如果一切顺利，当我们在浏览器中预览结果时，我们应该看到我们的演示继续按照本练习第一部分开始时所示的方式工作。
- en: 'Although our demo won''t appear any different, there will be a noticeable difference
    in the code—a quick peek using a DOM inspector such as Firebug shows the use of
    `rem` values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的演示看起来不会有任何不同，但代码中会有一个明显的差异——使用DOM检查器（如Firebug）快速查看会显示使用了 `rem` 值：
- en: '![Updating our hover effect demo](img/BO5194_02_09.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的悬停效果演示](img/BO5194_02_09.jpg)'
- en: The use of mixins does raise some important points. Indeed, one might be forgiven
    for thinking they simply replicate functionality from SASS. The plugin we've used
    does not follow the same format, even if the principles are the same; let's pause
    for a moment and take a look at how these stack up against standard processors.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合确实会引发一些重要问题。确实，有人可能会认为它们只是简单地复制SASS的功能。我们使用的插件格式并不相同，即使原则相同；让我们暂停一下，看看这些是如何与标准处理器相比的。
- en: Comparing PostCSS to standard processors
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较PostCSS与标准处理器
- en: The use of mixins is a great way to automatically insert pre-defined blocks
    of code, either static or dynamic, into our stylesheet, at the compilation phase.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合（mixins）是一种将预定义的代码块（无论是静态的还是动态的）自动插入到我们的样式表中的好方法，在编译阶段进行。
- en: The key thing to note is that, although the end result may be similar, the similarity
    is just in name; the mixin plugin we've used was not designed to replicate existing
    functionality available within SASS. Instead, this plugin exposes the power of
    JavaScript within PostCSS, and should be used to define function mixins, as a
    replacement for if or while statements that are not available within PostCSS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的关键点是，尽管最终结果可能相似，但这种相似性仅仅是名称上的；我们使用的混合插件并非旨在复制SASS中可用的现有功能。相反，此插件在PostCSS中暴露了JavaScript的力量，应将其用作定义函数混合（function
    mixins），以替代PostCSS中不可用的if或while语句。
- en: 'This is particularly true if we need to change any property names within the
    mixin; an example of this would be when referencing multiple images that each
    need similar style classes to be applied:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其适用于我们需要在混合中更改任何属性名称的情况；一个例子是引用多个图像，每个图像都需要应用类似样式类：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we were to call this mixin with `@mixin icons signin;` from our code, we
    would see this as a result:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从代码中调用此混合 `@mixin icons signin;`，我们会看到以下结果：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This does pose an interesting question: where should the cut-off point between
    using JavaScript in our task file be, in comparison to our CSS? Taking this approach
    does mean that we have the benefit of using standard JavaScript, but at the expense
    of simplicity!'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实提出了一个有趣的问题：与CSS相比，在任务文件中使用JavaScript的截止点在哪里？采取这种方法意味着我们可以使用标准的JavaScript，但这是以牺牲简单性为代价的！
- en: This is one of the decisions you will need to make as a developer. PostCSS's
    flexibility means that not only do we need to choose the right plugin, but that
    the order they are all called in can also have an effect on the outcome of our
    code. In this instance, an alternative plugin—`postcss-simple-vars`—shares the
    same syntax as `postcss-mixins`, but does not support changing of property names.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你作为开发者需要做出的一个决定。PostCSS 的灵活性意味着我们不仅需要选择正确的插件，而且它们被调用的顺序也可能影响我们代码的结果。在这个例子中，一个替代插件——`postcss-simple-vars`——与
    `postcss-mixins` 具有相同的语法，但不支持属性名的更改。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also consider using the `postcss-nested` plugin if our mixins are stored
    within nested statements; this is something we will cover in the next chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 mixin 存储在嵌套语句中，我们还可以考虑使用 `postcss-nested` 插件；我们将在下一章中介绍这一点。
- en: 'But, to bring it back to our example: we used the classic mixin for providing
    pixel fall-back when using older versions of IE.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们回到我们的例子：我们使用了经典的 mixin 来在旧版本的 IE 中提供像素回退。
- en: We could have used an alternative plugin here, in the form of `postcss-simple-mixins`
    (available from [https://www.npmjs.com/package/postcss-simple-mixin](https://www.npmjs.com/package/postcss-simple-mixin)).
    This is designed to provide simple support for mixins, and doesn't have the baggage
    associated with `postcss-mixins`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以使用一个替代插件，形式为 `postcss-simple-mixins`（可在 [https://www.npmjs.com/package/postcss-simple-mixin](https://www.npmjs.com/package/postcss-simple-mixin)
    获取）。这个插件旨在为 mixin 提供简单的支持，并且没有与 `postcss-mixins` 相关的负担。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of note though: the `postcss-simple-mixins` plugin has been deprecated,
    although it is still available for use. It does not support nesting or the use
    of arguments.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个需要注意的点：`postcss-simple-mixins` 插件已被弃用，尽管它仍然可用于使用。它不支持嵌套或参数的使用。
- en: The key consideration, though, will depend on what you plan to achieve within
    your code; choosing the right plugin will reduce the inclusion of redundant functionality
    and help keep our custom processor as lean as possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键考虑因素将取决于你计划在代码中实现什么；选择正确的插件将减少冗余功能的包含，并帮助将我们的自定义处理器保持尽可能精简。
- en: 'There is another reason why choosing plugins is critical: instead of using
    a mixin to just support older versions of IE, we can use the `postcss-pxtorem`
    plugin to generate `rem` values during compilation. After all, although most browsers
    have supported `rem` units for some time, there is always one that is late to
    the party:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选择插件还有一个关键原因：我们不仅可以使用 mixin 来支持旧版本的 IE，还可以使用 `postcss-pxtorem` 插件在编译期间生成 `rem`
    值。毕竟，尽管大多数浏览器已经支持 `rem` 单位一段时间了，但总有一两个是后来者：
- en: '![Comparing PostCSS to standard processors](img/BO5194_02_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![比较 PostCSS 与标准处理器](img/BO5194_02_10.jpg)'
- en: Screenshot taken from the CanIUse site, at [http://www.caniuse.com](http://www.caniuse.com)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 截图来自 CanIUse 网站，[http://www.caniuse.com](http://www.caniuse.com)
- en: Switching to using this plugin has the added benefit of simplifying our code,
    as the server can handle the grunt work of replacing pixel values with the equivalent
    `rem` units. The grunt work can be shifted to a central location, so that anyone
    using it will receive consistent results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 转而使用此插件的好处是简化了我们的代码，因为服务器可以处理将像素值替换为等效的 `rem` 单位的繁琐工作。这些繁琐的工作可以转移到中央位置，这样任何使用它的人都会得到一致的结果。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to also note that the cross over between mixins and functions
    also exists within PostCSS. We will explore using functions more in [Chapter 5](ch05.html
    "Chapter 5. Managing Colors, Images, and Fonts"), *Managing Colors, Images, and
    Fonts*, when we learn how PostCSS can be used to make our lives easier when working
    with colors or media.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，在 PostCSS 中，mixins 和函数之间的交叉也存在。当我们学习如何使用 PostCSS 在处理颜色或媒体时使我们的生活更轻松时，我们将在第
    5 章 [管理颜色、图像和字体](ch05.html "第 5 章。管理颜色、图像和字体")中更多地探讨使用函数。
- en: 'Okay, onwards we go. Time to switch topics completely, and take a look at another
    key part of PostCSS: creating loops. Anyone familiar with SASS or Less will be
    aware of how mundane it can get when applying very similar styles to identical
    objects; a perfect example are the classic social media icons that frequently
    grace posts on a page. PostCSS has a plugin that allows us to mimic this functionality,
    so let''s explore how to use it in action.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们继续前进。现在是时候完全转换话题，看看 PostCSS 的另一个关键部分：创建循环。任何熟悉 SASS 或 Less 的人都会知道，当将非常相似的风格应用到相同对象上时，这可能会变得多么单调；一个完美的例子是经常出现在页面上的经典社交媒体图标。PostCSS
    有一个插件允许我们模拟这种功能，所以让我们看看如何在实际操作中使用它。
- en: Looping content with PostCSS
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostCSS循环内容
- en: 'A question: how often have you come across instances where you have a number
    of very similar images that share styles, but at the same time need to have individual
    styles applied? Sound familiar?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题：你有多少次遇到过这样的情况，即你有一系列非常相似且共享样式的图像，但同时又需要应用个别样式？听起来熟悉吗？
- en: I am of course talking about instances such as list items, grid layouts, and
    the classic social media icons we see littered all over the Internet. We can of
    course simply write rules to cover each image, but as I am sure you will agree,
    it's not the smartest approach! Instead, we can use the power of the `@each` statement
    to iterate through each item and apply each style using string interpolation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我当然是在谈论诸如列表项、网格布局以及我们在互联网上随处可见的典型社交媒体图标等实例。我们当然可以简单地编写规则来覆盖每个图像，但正如你肯定会的，这并不是最明智的方法！相反，我们可以利用`@each`语句的强大功能，遍历每个项目并使用字符串插值应用每个样式。
- en: The `@each` plugin, by Alexander Madyankin, is one of two ways to incorporate
    a facility to loop through content; the source for this plugin is available from
    [https://github.com/outpunk/postcss-each](https://github.com/outpunk/postcss-each).
    The other plugin, postcss-for (available from [https://github.com/antyakushev/postcss-for](https://github.com/antyakushev/postcss-for)),
    takes a different approach—the difference between the two is that the former works
    on objects, while the latter must use a range of numbers to apply styles.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由Alexander Madyankin编写的`@each`插件是两种实现遍历内容功能的方法之一；此插件的源代码可以从[https://github.com/outpunk/postcss-each](https://github.com/outpunk/postcss-each)获取。另一个插件postcss-for（可从[https://github.com/antyakushev/postcss-for](https://github.com/antyakushev/postcss-for)获取），采用不同的方法——两者的区别在于前者作用于对象，而后者必须使用一系列数字来应用样式。
- en: 'If we take the second plugin for a moment, we have to loop through a consecutive
    range of numbers in order to produce our result. So, something akin to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们暂时考虑第二个插件，我们必须遍历一系列连续的数字才能生成我们的结果。所以，类似于以下内容：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '…would produce this, when compiled:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: …在编译时会产生以下结果：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Seems pretty straightforward, right? Here comes the rub, though: unlike SASS,
    we can''t use variables to define that range by default; this plugin must be defined
    **before any instance of** `postcss-nested` and `postcss-simple-vars` plugins.
    In PostCSS, we iterate through **all** of the values inclusively (that is, one
    to three in our example), which is not the same as in SASS.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，对吧？但是，这里有一个问题：与SASS不同，我们默认不能使用变量来定义这个范围；此插件必须在`postcss-nested`和`postcss-simple-vars`插件的任何实例之前定义。在PostCSS中，我们遍历**所有**的值（即，在我们的例子中是一到三），这与SASS不同。
- en: It's in cases like this that we must decide between using this plugin on its
    own, or with `postcss-custom-properties` and `postcss-for-variables`. This is
    why it is key to fully understand what you need to achieve, and the capabilities
    of plugins available, so that we can choose the most effective combination to
    suit our needs. The great thing about PostCSS is its flexibility, speed, and modular
    design; this modularity and flexibility can also be seen as its Achilles heel,
    as tweaking the choice and order of plugins can have a real impact on our code!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须决定是单独使用此插件，还是与`postcss-custom-properties`和`postcss-for-variables`一起使用。这就是为什么完全理解你需要实现什么，以及可用的插件功能至关重要，这样我们才能选择最适合我们需求的最高效组合。PostCSS的伟大之处在于其灵活性、速度和模块化设计；这种模块化和灵活性也可以被视为其阿喀琉斯之踵，因为调整插件的选择和顺序可能会对我们的代码产生实际影响！
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can of course change completely, and use a separate fork of the postcss-for
    plugin, available from [https://github.com/xori/postcss-for](https://github.com/xori/postcss-for).
    This caters for dollar variables.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以完全改变，并使用来自[https://github.com/xori/postcss-for](https://github.com/xori/postcss-for)的postcss-for插件的独立分支。这适用于美元变量。
- en: Let's put some of this into practice. Before we get stuck in to nesting with
    PostCSS in the next chapter, we'll round out this one with a simple demo that
    uses a group of social media icons and PostCSS to set up styling automatically
    for us.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其付诸实践。在我们进入下一章使用PostCSS进行嵌套之前，我们将通过一个简单的示例来结束这一章，该示例使用一组社交媒体图标和PostCSS来自动设置样式。
- en: Iterating through @each statements
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历@each语句
- en: Staying with the looping theme, but on a different tack, in place of using the
    `for` statement, we can achieve similar effects with `@each`, but only if the
    target is an element on the page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环主题的基础上，但采取不同的方法，我们可以在不使用`for`语句的情况下，通过`@each`实现类似的效果，但前提是目标是页面上的一个元素。
- en: I am of course talking about elements such as buttons or menu items; these elements
    will share the same styling, but require unique IDs to allow us to interact with
    them. It goes without saying that we could simply create a shared base class and
    add multiple classes for each element…
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do better than that: most preprocessors have in-built functionality
    that allows us to iterate through elements and apply CSS styling to each element.
    Thankfully, PostCSS is no different; we can achieve the same result using the
    postcss-each plugin, available from [https://github.com/outpunk/postcss-each](https://github.com/outpunk/postcss-each).
    It''s a cinch to install, and we can use it to add elements such as social media
    icons to the foot of a page, and style them. I feel a demo coming on, so let''s
    dive in and take a look:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with installing the plugin, so go ahead and fire up a NodeJS command
    prompt, and change the working directory to our project area.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command to install the `postcss-each` plugin, then
    press *Enter*:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If all is well, we should see the customary confirmation that the plugin is
    installed:![Iterating through @each statements](img/BO5194_02_11.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the plugin now in place, let''s move on and update our gulp file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We need to make three changes to our gulp file, so go ahead and open a copy
    from the project area in your usual text editor.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, go ahead and remove lines 9 to 11; they contain the variable declarations
    for the `postcss-css-variables` and `postcss-mixins` plugins.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On or around what is now line 8, we should see the variable declaration for
    `postcss-calc`. Immediately, below, add the following line:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the main `autoprefixer` task, we need to alter the `postcss` call; remove
    this from line 13:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We should be left with this (changes have been highlighted):'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At this point, we can save the file. It is now ready for us to process the CSS
    required for our next demo. For this next exercise, we will need to avail ourselves
    of some suitable social media icons. I've used the ones by Nathan Brown, available
    at [http://wegraphics.net/downloads/free-stained-and-faded-social-media-icons/](http://wegraphics.net/downloads/free-stained-and-faded-social-media-icons/).
    We'll use the Twitter, LinkedIn, and YouTube images.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a look at the SASS version of this demo. It''s a simple example,
    but illustrates perfectly how we can use the `@each` function to iterate through
    each image and apply the appropriate style:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To compile the code, go ahead and copy the `Tutorial4` folder to our project
    area.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `gulpfile.js` with a copy from the `Tutorial1A` folder—this
    contains the appropriate commands to compile the code—we need to use the original
    version built to compile SASS code, not PostCSS, hence the change.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a copy of `style.scss` from the `src` folder of the `Tutorial4` folder,
    then drop it into the `src` folder of our project area.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fire up a NodeJS command prompt window, then change the working folder
    to our project area.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Keep the command prompt window open for now, we will use it again shortly.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the code has compiled, copy the contents of the `dest` folder back to the
    `css` folder in the `Tutorial4` folder.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is well, we should have three icons showing, when previewing the results
    in a browser. Nothing outrageous here: we have the base rule that applies to all
    of the icons, which is followed by the individual classes required to handle each
    icon itself:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, how would this look in PostCSS? Well, surprising as it may be, there isn't
    a great deal of change needed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Switching to using PostCSS
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only need to change it in two places within our CSS file. I''ve also separated
    the nested code, to make it easier to view:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The changes we need to make are highlighted in this block of code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our gulp file also needs to change. Let''s work through the steps involved
    to make the switch to PostCSS:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We first need to replace the gulp file—go ahead and delete the copy at the root
    of the project area, then replace it with a copy from the `Tutorial4` folder in
    the code download.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, extract a copy of `style`—`pre
    compile.css`, and rename it as `style.css`. Drop it in the `src` folder of our
    project area.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert back to the command prompt, then enter `gulp` at the prompt and press
    *Enter*.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the compiled style sheets appear in the `dest`
    folder, along with the source maps.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `dest` folder in project area to the `css` folder within
    our local copy of the `Tutorial4` folder.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try previewing the results in a browser; if all is working as expected, we should
    see these icons appear:![Switching to using PostCSS](img/BO5194_02_12.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Granted, it is a simple exercise, but then I've always been a fan of keeping
    things simple! Anyone can write CSS styles, but for me the "step up" is knowing
    that quantity does not always beat quality, and that there is something to be
    said for following the *KISS* principle, *Keep It Simple…* Yes, you get the idea!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'But, just to show how flexible this plugin is, try this as an exercise:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [http://dataurl.net/](http://dataurl.net/), then upload each of the
    icons in turn, and use the site to generate data-URI equivalent code for each
    image.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the CSS, remove the existing background-image links, and replace them with
    the code from the `dataurl.net` site.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go ahead and compile the code using the same principles we've used throughout
    this chapter. Looks identical, doesn't it? We've removed the need to pull in separate
    resources, as we're using a pure CSS solution...
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, there is a catch: when the file has been compiled, check the file size.
    It should tell you that it is significantly larger than the one which doesn''t
    contain data-URI equivalent code. This is to be expected: it''s the trade-off
    between sizes versus the number of resources we call. It only shows how critical
    the order of our PostCSS plugins would be, to get the desired results!'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一个需要注意的地方：当文件被编译后，检查文件大小。它应该告诉你，它比不包含data-URI等效代码的文件大得多。这是可以预料的：这是大小与我们所调用的资源数量之间的权衡。这仅仅显示了我们的PostCSS插件顺序是多么关键，以获得期望的结果！
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Anyone who has spent time using pre-processors such as SASS will no doubt be
    familiar with variables and mixins; these make up an integral part of using PostCSS.
    We've covered a lot of material relating to their use throughout this chapter,
    so let's take a breather and review what we have learned.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 任何花时间使用SASS等预处理器的人无疑都会熟悉变量和mixins；这些是使用PostCSS的一个基本组成部分。我们在本章中介绍了大量与它们使用相关的材料，所以让我们休息一下，回顾一下我们已经学到的内容。
- en: We kicked off with a brief introduction to variables and mixins in SASS, before
    setting up an example demo in SASS (and Less CSS) as a basis for conversion to
    PostCSS.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对SASS中的变量和mixins的简要介绍开始，然后在SASS（和Less CSS）中设置了一个示例演示作为转换为PostCSS的基础。
- en: Next up came the start of the transition process to PostCSS. We first looked
    at adding variable support in, before updating our hover demo to use the new plugin
    and remove a dependency on using SASS. We then covered some benefits and considerations
    of using PostCSS, before discovering how a simple tweak in the order of plugins
    can have a big impact on the end result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是开始过渡到PostCSS的过程。我们首先研究了添加变量支持，然后更新了我们的悬停演示以使用新插件并移除对使用SASS的依赖。然后，我们介绍了使用PostCSS的一些好处和考虑因素，最后发现简单地调整插件顺序可以对最终结果产生重大影响。
- en: We moved swiftly on with a look at mixins. We covered the install of the postcss-mixins
    plugin, before using it to update our demo. At this point, we paused for a moment
    to consider some of the differences between standard processors and PostCSS, and
    covered how one of the key points to bear in mind is PostCSS's flexibility and
    power.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速地继续前进，开始研究mixins。在用它来更新我们的演示之前，我们首先介绍了postcss-mixins插件的安装。在这个时候，我们暂停了一下，考虑了一些标准处理器和PostCSS之间的差异，并介绍了要记住的一个关键点是PostCSS的灵活性和强大功能。
- en: We then rounded out the chapter with a look at looping content. We first explored
    the use of the for statement, before moving on and taking a look at how we can
    easily style content using the `@each` function. We then covered its use in a
    simple demo for styling social media icons. This started in SASS, but finished
    with the converted results using PostCSS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过查看循环内容来结束这一章。我们首先探讨了for语句的使用，然后继续并查看我们如何使用`@each`函数轻松地样式化内容。然后，我们通过一个简单的演示来介绍其用于样式化社交媒体图标的使用。这始于SASS，但最终使用PostCSS转换的结果完成。
- en: Phew, let's move on! Our next stop on this whistlestop tour of mastering PostCSS
    is a look at nesting, and no, not for our feathered friends, but how we can (dramatically)
    reduce the content we write, or at least make it easier to read!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸一下，让我们继续前进！在这个快速掌握PostCSS的旅程中，我们的下一个停靠点是查看嵌套，而且，不是针对我们的羽毛朋友，而是如何（戏剧性地）减少我们编写的内容，或者至少让它更容易阅读！
