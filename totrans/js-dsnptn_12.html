<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor261" class="pcalibre1 calibre6 pcalibre"/>9</h1>
<h1 id="_idParaDest-142" class="calibre5"><a id="_idTextAnchor262" class="pcalibre1 calibre6 pcalibre"/>Maximizing Performance – Lazy Loading and Code Splitting</h1>
<p class="calibre3">In order to maximize the performance of a JavaScript application, reducing the amount of unused JavaScript being loaded and interpreted is key. The techniques that can be brought <a id="_idIndexMarker507" class="pcalibre1 calibre6 pcalibre"/>to bear on this problem are called <strong class="bold">lazy loading</strong> and <strong class="bold">code splitting</strong>. Lazy loading and code splitting allows parts of the JavaScript to <a id="_idIndexMarker508" class="pcalibre1 calibre6 pcalibre"/>be loaded on demand as required. This is in contrast to being downloaded on page load and can greatly reduce the amount of unused JavaScript being loaded and interpreted.</p>
<p class="calibre3">We’ll cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">The dynamic import syntax and how Vite can automatically code-split based on the syntax</li>
<li class="calibre11">Route-based code splitting with Next.js and how to read the Bundle Analyzer reports</li>
<li class="calibre11">How to use <strong class="source-inline1">next/dynamic</strong> and <strong class="source-inline1">react-intersection-observer</strong> to load JavaScript and React components on different user interactions</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to identify and leverage lazy loading and code splitting in a variety of scenarios and applications.</p>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor263" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-144" class="calibre5"><a id="_idTextAnchor265" class="pcalibre1 calibre6 pcalibre"/>Dynamic imports and code splitting with Vite</h1>
<p class="calibre3">Dynamic imports in <a id="_idIndexMarker509" class="pcalibre1 calibre6 pcalibre"/>JavaScript refer to the usage of the <code>import()</code> syntax to import a module. Unlike the <code>import Something from './my-module.js'</code> declarative syntax, <code>import()</code> is more akin to a function that returns a promise. For example, we could rewrite the original import as <code>const Something = </code><code>await import('./my-module.js')</code>.</p>
<p class="calibre3">The “dynamic” part of the <a id="_idIndexMarker510" class="pcalibre1 calibre6 pcalibre"/>import is that it doesn’t have to be <a id="_idIndexMarker511" class="pcalibre1 calibre6 pcalibre"/>done at module evaluation time; it’s done as part <a id="_idIndexMarker512" class="pcalibre1 calibre6 pcalibre"/>of the execution of the code. This is useful when <a id="_idIndexMarker513" class="pcalibre1 calibre6 pcalibre"/>paired with code splitting – which we’ll define now – since it means that we can avoid loading and evaluating some JavaScript code until it’s needed.</p>
<p class="calibre3">Code splitting is a <a id="_idIndexMarker514" class="pcalibre1 calibre6 pcalibre"/>technique whereby code is built into multiple files (also known as “chunks” or “bundles”) instead of a single file. Code splitting is useful to avoid loading all the code up front. Instead, when paired with dynamic imports, code is split into multiple files such that different parts of it are loaded only when necessary. This means that there’s a lower up-front cost to the JavaScript load, parse, and compile cycle.</p>
<p class="calibre3">The Vite build tool supports code splitting at dynamic import boundaries.</p>
<p class="calibre3">Given a simple document as follows, which has an <code>id="app"</code> <code>div</code> and references a <code>main.js</code> file, Vite can run a build as long as <code>main.js</code> exists:</p>
<pre class="source-code">
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script src="img/main.js" type="module"&gt;&lt;/script&gt;</pre> <p class="calibre3">We’ll have two modules now: <code>main.js</code>, which is the entry point that Vite will reference, and our code will import the <code>dynamic.js</code> module.</p>
<p class="calibre3"><code>main.js</code> will inject <code>'Hello from main.js'</code>into our <code>app</code> div. It will then proceed to dynamically load the <code>dynamic.js</code> module and set the contents of the <code>app</code> div to the output of the <code>hello</code> function as exported by <code>dynamic.js</code>:</p>
<pre class="source-code">
<strong class="source-inline2">document.querySelector('#app').textContent = 'Hello from main.js';</strong>
<strong class="source-inline2">const { hello } = await import('./dynamic.js');</strong>
<code>dynamic.js</code> implementation of the <code>hello</code> function:</p>
<pre class="source-code">
export function hello() {
  return 'Hello from dynamic.js';
}</pre> <p class="calibre3">When <a id="_idIndexMarker515" class="pcalibre1 calibre6 pcalibre"/>running the Vite dev server using <code>npx vite</code>, we can <a id="_idIndexMarker516" class="pcalibre1 calibre6 pcalibre"/>see that the dynamically imported <code>hello</code> function contents <a id="_idIndexMarker517" class="pcalibre1 calibre6 pcalibre"/>are displayed on the page. Notice <a id="_idIndexMarker518" class="pcalibre1 calibre6 pcalibre"/>that <code>dynamic.js</code> is loaded as a separate request to <code>main.js</code>; that is code splitting at play.</p>
<div><div><img alt="Figure 9.1: “Hello from dynamic.js” on the page with network requests, including a request specifically for dynamic.js" src="img/B19109_09_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1: “Hello from dynamic.js” on the page with network requests, including a request specifically for dynamic.js</p>
<p class="calibre3">This pattern can be useful to defer loading JavaScript until it’s required – for example, if we want to add client-side tracking of button clicks using <code>fetch</code> requests.</p>
<p class="calibre3">We have the following HTML, with two buttons that have a <code>data-track</code> property:</p>
<pre class="source-code">
&lt;!-- no change to app div --&gt;
&lt;div&gt;
  &lt;button data-track="button-click"&gt;With tracked click
  &lt;/button&gt;
  &lt;button data-track="alt-button-click"&gt;Other tracked click
  &lt;/button&gt;
&lt;/div&gt;
&lt;!-- to change to script --&gt;</pre> <p class="calibre3">We’ll <a id="_idIndexMarker519" class="pcalibre1 calibre6 pcalibre"/>add a <code>trackInteraction.js</code> module <a id="_idIndexMarker520" class="pcalibre1 calibre6 pcalibre"/>with a <code>trackInteraction</code> function, which <a id="_idIndexMarker521" class="pcalibre1 calibre6 pcalibre"/>will use <code>fetch</code> and the <code>POST</code> HTTP method to send <a id="_idIndexMarker522" class="pcalibre1 calibre6 pcalibre"/>interaction data to <code>jsonplaceholder</code>. If this were a live implementation, we could realistically replace <code>jsonplaceholder</code> with Google Analytics or another equivalent service that exposes a client-side JavaScript accessible endpoint:</p>
<pre class="source-code">
export function trackInteraction(page, type = 'click') {
  return fetch
    ('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({
      type,
      page,
    }),
    headers: {
      'Content-type': 'application/json; charset=UTF-8',
    },
  }).then((response) =&gt; response.json());
}</pre> <p class="calibre3">Now, the <code>trackInteraction</code> module has nothing to do with the page functionality so we want to avoid loading it until it’s needed.</p>
<p class="calibre3">In this case, we’ll attach a click event listener to each element that has a <code>data-track</code> attribute. Only when the listener is triggered does the <code>import('./trackInteraction.js')</code> statement run:</p>
<pre class="source-code">
// no change to rest of main.js
document.querySelectorAll('[data-track]').forEach((el) =&gt; {
  el.addEventListener('click', async (event) =&gt; {
    const page = window.location.pathname;
    const type = event.target.dataset?.track;
    const { trackInteraction } = await import
      ('./trackInteraction.js');
    const interactionResponse = await trackInteraction
      (page, type);
    console.assert(
      interactionResponse.type === type &amp;&amp;
        interactionResponse.page === page,
      'interaction response does not match sent data',
    );
  });
});</pre> <p class="calibre3">If we <a id="_idIndexMarker523" class="pcalibre1 calibre6 pcalibre"/>load the Vite dev server and click the <strong class="bold">With tracked click</strong> button <a id="_idIndexMarker524" class="pcalibre1 calibre6 pcalibre"/>and the <strong class="bold">Other tracked click</strong> button <a id="_idIndexMarker525" class="pcalibre1 calibre6 pcalibre"/>once and then the <strong class="bold">With tracked click</strong> button <a id="_idIndexMarker526" class="pcalibre1 calibre6 pcalibre"/>once again, we’ll get the following network requests:</p>
<div><div><img alt="Figure 9.2: Network requests after clicking the “With tracked click,” “Other tracked click,” and “With tracked click” buttons in sequence" src="img/B19109_09_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2: Network requests after clicking the “With tracked click,” “Other tracked click,” and “With tracked click” buttons in sequence</p>
<p class="calibre3">On the <a id="_idIndexMarker527" class="pcalibre1 calibre6 pcalibre"/>first click of either button, the <code>trackInteraction.js</code> file is loaded and then a <code>fetch</code> request is triggered. On subsequent clicks, <code>trackInteraction.js</code> is already loaded so the <code>fetch</code> requests to <code>jsonplaceholder</code> are the only network requests we see.</p>
<p class="calibre3">Note <a id="_idIndexMarker528" class="pcalibre1 calibre6 pcalibre"/>that each <code>POST</code> request to <code>jsonplaceholder</code> is preceded by an <code>OPTIONS</code> request due to browser <code>OPTIONS</code> response includes <code>Access-Control-Allow-…</code> headers that allow our origin and method.</p>
<p class="calibre3">We’ve now <a id="_idIndexMarker529" class="pcalibre1 calibre6 pcalibre"/>seen what dynamic imports in JavaScript look like and how Vite automatically code splits dynamic imports, which <a id="_idIndexMarker530" class="pcalibre1 calibre6 pcalibre"/>allows us to only load modules that are required “just in time,” thereby <a id="_idIndexMarker531" class="pcalibre1 calibre6 pcalibre"/>allowing us to reduce the upfront JavaScript load/parse/evaluation cost.</p>
<p class="calibre3">Next, we’ll cover route-based code splitting in Next.js and how to inspect generated chunks with the Next.js B<a id="_idTextAnchor266" class="pcalibre1 calibre6 pcalibre"/>undle Analyzer plugin.</p>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor267" class="pcalibre1 calibre6 pcalibre"/>Route-based code splitting and bundling</h1>
<p class="calibre3">Let’s <a id="_idIndexMarker532" class="pcalibre1 calibre6 pcalibre"/>begin by defining a <strong class="bold">route</strong> in a general web application <a id="_idIndexMarker533" class="pcalibre1 calibre6 pcalibre"/>context and then in a Next.js context.</p>
<p class="calibre3">In a web application, a route comes from the <strong class="bold">router</strong> concept; in simple terms, it’s an entry in the router. An entry in the router mechanism can take multiple shapes – for example, in an nginx/Apache/Caddy web server setup, we can have a path to file forwarding or a wildcard forwarding approach. In backend MVC frameworks such as Ruby on Rails, Laravel (PHP), and Django (Python), a route associates a request path to the specific code to be run. The <em class="italic">request path to code to be run</em> concept also applies to Node.js backend applications using libraries such as Express, Koa, Fastify, and Adonis.js.</p>
<p class="calibre3">Let’s now <a id="_idIndexMarker534" class="pcalibre1 calibre6 pcalibre"/>see how the <em class="italic">route</em> concept is used in the Next.js filesystem router.</p>
<p class="calibre3">A minimal <a id="_idIndexMarker535" class="pcalibre1 calibre6 pcalibre"/>Next.js project as initialized with <code>create-next-app</code> is laid out as follows. Each file in the <code>pages</code> directory corresponds <a id="_idIndexMarker536" class="pcalibre1 calibre6 pcalibre"/>to a route. For example, <code>index.js</code> is used to render the <code>/</code> path of the application. If we had an <code>about.js</code> or <code>about/index.js</code> file, that would be used to render the <code>/about</code> path of the application:</p>
<pre class="console">
.
├── components
├── next.config.js
├── package.json
├── pages
│   └── index.js
└── public</pre> <p class="calibre3">We defined code splitting in the previous section, <em class="italic">Dynamic imports and code splitting with Vite</em>. Since a core Next.js feature is the router, it can do what’s called <strong class="bold">route-based code splitting</strong>, which is automatic code splitting based on a route or page contents.</p>
<p class="calibre3">A naive route-based code-splitting approach would be to create completely separate sets of bundles for each route. In the context of a React or Next.js application, this is inefficient since we would end up with shared libraries (for example, React and Next.js) in each of the per-page bundles.</p>
<p class="calibre3">What Next.js can do in this case is identify shared code and classify it as <code>First Load JS shared </code><code>by all</code>.</p>
<p class="calibre3">This is the sample build output:</p>
<pre class="console">
+ First Load JS shared by all              79.9 kB
  ├ chunks/framework-cc1b0d6c55d15cb9.js   45.3 kB
  ├ chunks/main-7c6ad51e94ec3ff5.js        32.8 kB
  ├ chunks/pages/_app-db3a4be757903450.js  205 B
  └ chunks/webpack-8850afd7843acaaa.js     1.55 kB</pre> <p class="calibre3">We can <a id="_idIndexMarker537" class="pcalibre1 calibre6 pcalibre"/>add the Next.js Bundle Analyzer to check the contents of each chunk:</p>
<pre class="console">
npm install --save @next/bundle-analyzer</pre> <p class="calibre3">Then, we can <a id="_idIndexMarker538" class="pcalibre1 calibre6 pcalibre"/>configure <code>next.config.js</code> to use it. In our case, it looks as follows:</p>
<pre class="source-code">
const nextConfig = {
  // no changes to this config
};
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});
module.exports = withBundleAnalyzer(nextConfig);</pre> <p class="calibre3">To use the bundle analyzer, we can add an <code>analyze</code> script to our <code>package.json file</code>:</p>
<pre class="source-code">
{
  "//": "// no change to other properties",
  "scripts": {
    "//": "// no change to other scripts",
    "analyze": "cross-env ANALYZE=true next build"
  }
}</pre> <p class="calibre3">This can <a id="_idIndexMarker539" class="pcalibre1 calibre6 pcalibre"/>be run with <code>npm run analyze</code>. Its shell <a id="_idIndexMarker540" class="pcalibre1 calibre6 pcalibre"/>output is the same as <code>npm run build</code> but it opens a browser window with the bundle analysis file – for example, <code>.next/analyze/client.html</code>:</p>
<pre class="console">
npm run analyze
&gt; next-route-based-splitting@0.1.0 analyze
&gt; cross-env ANALYZE=true next build
 ✓ Linting and checking validity of types
Webpack Bundle Analyzer saved report to /next-route-based-splitting/.next/analyze/nodejs.html
No bundles were parsed. Analyzer will show only original module sizes from stats file.
Webpack Bundle Analyzer saved report to /next-route-based-splitting/.next/analyze/edge.html
Webpack Bundle Analyzer saved report to /next-route-based-splitting/.next/analyze/client.html
 ✓ Creating an optimized production build
 ✓ Compiled successfully
 ✓ Collecting page data
 ✓ Generating static pages (3/3)
 ✓ Collecting build traces
 ✓ Finalizing page optimization</pre> <p class="calibre3">We can <a id="_idIndexMarker541" class="pcalibre1 calibre6 pcalibre"/>use this to inspect the contents of the <code>shared</code> JavaScript <a id="_idIndexMarker542" class="pcalibre1 calibre6 pcalibre"/>in the <code>framework</code>, <code>main</code>, <code>pages/_app</code>, and <code>webpack</code> chunks as well as page-specific chunks:</p>
<div><div><img alt="Figure 9.3: The client.html Bundle Analyzer output in the browser" src="img/B19109_09_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3: The client.html Bundle Analyzer output in the browser</p>
<p class="calibre3">The <code>framework</code> bundle includes the following packages from <code>node_modules</code>: <code>react</code>, <code>react-dom</code>, and <code>scheduler</code>. Meanwhile, the <code>main</code> bundle includes <code>next</code> and its submodules such as <code>shared/lib</code>, which includes a large <code>router</code> chunk, or <code>next/client</code>, which is the client-side section of Next.js. Also, it is harder to see in the preceding screenshot, but <code>main</code> includes <code>@swc/helpers/esm</code>, which is probably an artifact of the Next.js build using the SWC compiler.</p>
<p class="calibre3">We’ve now <a id="_idIndexMarker543" class="pcalibre1 calibre6 pcalibre"/>seen how Next.js supports route-based <a id="_idIndexMarker544" class="pcalibre1 calibre6 pcalibre"/>code splitting and how to inspect the contents of the Next.js-generated bundles using the Next.js Bundle Analyzer report. Next, we’ll see dynamic import patterns to load additional JavaScript under different element visi<a id="_idTextAnchor268" class="pcalibre1 calibre6 pcalibre"/>bility and interaction conditions.</p>
<h1 id="_idParaDest-146" class="calibre5"><a id="_idTextAnchor269" class="pcalibre1 calibre6 pcalibre"/>Loading JavaScript on element visibility and interaction</h1>
<p class="calibre3">In this section, we’ll look at four different scenarios where dynamic or lazy loading of React <a id="_idIndexMarker545" class="pcalibre1 calibre6 pcalibre"/>components and JavaScript modules can be applied in the context of a Next.js application.</p>
<p class="calibre3">The first <a id="_idIndexMarker546" class="pcalibre1 calibre6 pcalibre"/>instance will be whether the component is in the component tree or not – in other words, whether it’s considered to be rendered or not. Next, we’ll look at dynamic imports based on user interaction. We’ll also cover how to handle an interaction that potentially requires a dynamic import of a JavaScript resource. Finally, we’ll show how to dynamically load a React component when an element is visible in the viewport.</p>
<p class="calibre3">Next.js provides a <code>dynamic</code> utility (see the documentation at <a href="https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading" class="pcalibre1 calibre6 pcalibre">https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading</a>) that allows us to lazily and dynamically load a React component.</p>
<p class="calibre3">In our case, we have a <code>components/Hello.jsx</code> component with a <code>Hello</code> component that is a named export:</p>
<pre class="source-code">
import React from 'react';
export function Hello() {
  return &lt;&gt;Hello&lt;/&gt;;
}</pre> <p class="calibre3">We can dynamically load it using <code>dynamic()</code> and <code>import()</code>. Due to <code>Hello</code> being a named export, we need to extract the <code>Hello</code> property of the <code>import()</code> promise using <code>.then()</code>. We set <code>ssr: false</code> to showcase how <code>next/dynamic</code> allows us to control <a id="_idIndexMarker547" class="pcalibre1 calibre6 pcalibre"/>whether a dynamically loaded <a id="_idIndexMarker548" class="pcalibre1 calibre6 pcalibre"/>component is included in the server-rendered output or not:</p>
<pre class="source-code">
import React from 'react';
import dynamic from 'next/dynamic';
const DynamicClientSideHello = dynamic(
  () =&gt; import('../components/Hello.jsx').then(({ Hello })
    =&gt; Hello),
  { ssr: false },
);
export default function Index() {
  return (
    &lt;&gt;
      &lt;h1&gt;Next.js route-based splitting and component lazy
        loading&lt;/h1&gt;
      &lt;DynamicClientSideHello /&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">By using <code>npm run analyze</code> as configured in the <em class="italic">Route-based code splitting and bundling</em> section (using the <code>@next/bundle-analyzer</code> module), we can inspect the contents of the <code>chunks/pages/index</code> chunk; you’ll note that <code>Hello.jsx</code> is in a different chunk.</p>
<div><div><img alt="Figure 9.4: Bundle analyzer filtered to “chunks/pages/index” and the chunk containing Hello.jsx" src="img/B19109_09_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4: Bundle analyzer filtered to “chunks/pages/index” and the chunk containing Hello.jsx</p>
<p class="calibre3">When we <a id="_idIndexMarker549" class="pcalibre1 calibre6 pcalibre"/>run the Next.js dev server using <code>next dev</code> and load <a id="_idIndexMarker550" class="pcalibre1 calibre6 pcalibre"/>up the <code>/</code> path, we see the following page and network requests. <code>_next/static/chunks/components_Hello_jsx.js</code> is loaded last and separately to <code>_next/static/chunks/pages/index.js</code>, which means that we are in fact doing a dynamic load of the <code>Hello.jsx</code> component.</p>
<div><div><img alt="Figure 9.5: Dynamic loading of the Hello.jsx page contents and Network tab" src="img/B19109_09_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5: Dynamic loading of the Hello.jsx page contents and Network tab</p>
<p class="calibre3">We’ll now <a id="_idIndexMarker551" class="pcalibre1 calibre6 pcalibre"/>showcase using <code>next/dynamic</code> inside of the <code>Index</code> component based on the component state.</p>
<p class="calibre3">Our example is a <em class="italic">Terms and Conditions</em> selector that allows the user to select between <a id="_idIndexMarker552" class="pcalibre1 calibre6 pcalibre"/>three options: <code>NoRender</code> component (which simply returns <code>null</code>), and <strong class="bold">Short</strong> and <strong class="bold">Long</strong> will dynamically load a component to display.</p>
<p class="calibre3">We’ll start by adding a <code>components/TermsAndConditionsShort.jsx</code> component, which contains an <code>h3</code> element and a single paragraph of content:</p>
<pre class="source-code">
import React from 'react';
export function TermsAndConditions() {
  return (
    &lt;&gt;
      &lt;h3&gt;Terms and Conditions Short&lt;/h3&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">We’ll <a id="_idIndexMarker553" class="pcalibre1 calibre6 pcalibre"/>also add a <code>components/TermsAndConditionsLong.jsx</code> component, which contains the same <code>h3</code> and content <a id="_idIndexMarker554" class="pcalibre1 calibre6 pcalibre"/>but has five paragraphs of content instead of one:</p>
<pre class="source-code">
import React from 'react';
export function TermsAndConditions() {
  return (
    &lt;&gt;
      &lt;h3&gt;Terms and Conditions Long&lt;/h3&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Finally, we’ll add a <code>select</code> field with relevant <code>option</code> values (<code>None</code>, <code>Short</code>, and <code>Long</code>) to <code>pages/index.js</code>. We’ll use <code>useState</code> to keep track of the currently selected option:</p>
<pre class="source-code">
import React, { useState } from 'react';
export default function Index() {
  const [selectedTermsAndConditions,
    setSelectedTermsAndConditions] =
    useState('None');
  return (
    &lt;&gt;
      {/* no changes to rest of the returned JSX */}
      &lt;div&gt;
        &lt;label htmlFor="termsAndConditionsType"&gt;
          Terms and Conditions selector:
        &lt;/label&gt;
        &lt;select
          id="termsAndConditionsType"
          onChange={(e) =&gt; setSelectedTermsAndConditions
            (e.target.value)}
        &gt;
          &lt;option value="None"&gt;None&lt;/option&gt;
          &lt;option value="Short"&gt;Short&lt;/option&gt;
          &lt;option value="Long"&gt;Long&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Finally, we’ll <a id="_idIndexMarker555" class="pcalibre1 calibre6 pcalibre"/>add a <code>NoRender</code> component and, based <a id="_idIndexMarker556" class="pcalibre1 calibre6 pcalibre"/>on <code>selectedTermsAndConditions</code>, either render <code>NoRender</code> or the dynamically loaded <code>TermsAndConditions</code> component:</p>
<pre class="source-code">
import React, { useState } from 'react';
const NoRender = () =&gt; null;
export default function Index() {
  // no change to useState
  const TermsAndConditions = ['Short', 'Long'].includes(
    selectedTermsAndConditions,
  )
    ? dynamic(() =&gt;
        import(
          `../components/TermsAndConditions$
            {selectedTermsAndConditions}.jsx`
        ).then(({ TermsAndConditions }) =&gt;
          TermsAndConditions),
      )
    : NoRender;
  return (
    &lt;&gt;
      {/* no changes to rest of the returned JSX */}
      &lt;div&gt;
        {/* no change to label or select */}
        &lt;hr /&gt;
        &lt;TermsAndConditions /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we <a id="_idIndexMarker557" class="pcalibre1 calibre6 pcalibre"/>run the next dev server and load <a id="_idIndexMarker558" class="pcalibre1 calibre6 pcalibre"/>the index page, we initially see the <code>Hello.jsx</code> one from the previous example.</p>
<div><div><img alt="Figure 9.6: Terms and conditions selector initial state with None selected; therefore, no dynamic imports apart from the existing Hello.jsx one" src="img/B19109_09_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.6: Terms and conditions selector initial state with None selected; therefore, no dynamic imports apart from the existing Hello.jsx one</p>
<p class="calibre3">On selection of <code>_next/static/chunks/components_TermsAndConditionsShort_jsx.js</code>.</p>
<div><div><img alt="Figure 9.7: Terms and conditions selector when Short is selected; TermsAndConditionsShort.jsx has been dynamically loaded and is displayed" src="img/B19109_09_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.7: Terms and conditions selector when Short is selected; TermsAndConditionsShort.jsx has been dynamically loaded and is displayed</p>
<p class="calibre3">When we <a id="_idIndexMarker559" class="pcalibre1 calibre6 pcalibre"/>select <code>/_next/static/chunks/components_TermsAndConditionsLong_jsx.js</code>.</p>
<div><div><img alt="Figure 9.8: Terms and conditions selector when Long is selected; TermsAndConditionsLong.jsx has been dynamically loaded and is displayed" src="img/B19109_09_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.8: Terms and conditions selector when Long is selected; TermsAndConditionsLong.jsx has been dynamically loaded and is displayed</p>
<p class="calibre3">We can <a id="_idIndexMarker561" class="pcalibre1 calibre6 pcalibre"/>also look at the Bundle Analyzer’s <code>client.html</code> output using <code>npm run analyze</code>; the following has been filtered <a id="_idIndexMarker562" class="pcalibre1 calibre6 pcalibre"/>to the relevant chunks to illustrate how <code>TermsAndConditionsShort</code> and <code>TermsAndConditionsLong</code> are not included in <code>chunks/pages/index.js</code>. There are three “dynamic” chunks (which correlates with our findings from the network requests we observe in the browser): one for <code>components/Hello.jsx</code>, one for <code>components/TermsAndConditionsShort.jsx</code>, and one for <code>components/TermsAndConditionsLong.jsx</code>.</p>
<div><div><img alt="Figure 9.9: Bundle Analyzer output for the page chunk as well as the dynamic chunks (which include the TermsAndConditionsShort and TermsAndConditionsLong components)" src="img/B19109_09_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.9: Bundle Analyzer output for the page chunk as well as the dynamic chunks (which include the TermsAndConditionsShort and TermsAndConditionsLong components)</p>
<p class="calibre3">We’ve now <a id="_idIndexMarker563" class="pcalibre1 calibre6 pcalibre"/>seen how <code>dynamic</code> can be used <a id="_idIndexMarker564" class="pcalibre1 calibre6 pcalibre"/>in response to a user action to dynamically load content based on user-provided data. Next, we’ll revisit dynamic imports of a JavaScript resource (as opposed to React components) while handling a user action in the context of a Next.js application.</p>
<p class="calibre3">We’ll start with a new component, <code>TermsAndConditionsLongScroll.jsx</code>, which is functionally the same as <code>TermsAndCondtionsShort.jsx</code> or <code>TermsAndCondtionsLong.jsx</code> but with 10 paragraphs:</p>
<pre class="source-code">
import React from 'react';
export function TermsAndConditions() {
  return (
    &lt;&gt;
      &lt;h3&gt;Terms and Conditions Long Scroll&lt;/h3&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
      &lt;p&gt;{/* Terms and Conditions Content */}&lt;/p&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">We’ll now <a id="_idIndexMarker565" class="pcalibre1 calibre6 pcalibre"/>add a form at the bottom of the <a id="_idIndexMarker566" class="pcalibre1 calibre6 pcalibre"/>page to accept the terms and conditions. We have a long form so it’s nice to be able to go directly to the bottom. To this end, we add a button that, on click, scrolls us to the input checkbox element using a ref.</p>
<p class="calibre3">In our <em class="italic">scroll-to-bottom</em> handler, we ensure that smooth scrolling is available (some older Safari versions don’t natively support it) by conditionally importing the <code>scroll-behavior-polyfill</code> package if <code>scrollBehavior</code> is not detected.</p>
<p class="calibre3">Finally, we scroll using the <code>scrollTargetRef.current.scrollIntoView()</code> function. <code>scrollTargetRef</code> is attached to the <a id="_idIndexMarker567" class="pcalibre1 calibre6 pcalibre"/>checkbox input using <a id="_idIndexMarker568" class="pcalibre1 calibre6 pcalibre"/>the <code>ref</code> property:</p>
<pre class="source-code">
import React, { useRef } from 'react';
export function TermsAndConditions() {
  const scrollTargetRef = useRef();
  async function handleScroll() {
    if (!('scrollBehavior' in document.
      documentElement.style)) {
      await import('scroll-behavior-polyfill');
    }
    if (scrollTargetRef.current) {
      scrollTargetRef.current.scrollIntoView({
        behavior: 'smooth',
        block: 'end',
      });
    }
  }
  return (
    &lt;&gt;
      {/* no change to heading */}
      &lt;button onClick={handleScroll}&gt;Scroll to button
        &lt;/button&gt;
      {/* no changes to paragraphs */}
      &lt;hr /&gt;
      &lt;label htmlFor="accept"&gt;
        &lt;input
          id="accept"
          name="acceptTerms"
          type="checkbox"
          ref={scrollTargetRef}
        /&gt;
        Accept Terms and Conditions
      &lt;/label&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Back in <code>pages/index.js</code>, we’ll <a id="_idIndexMarker569" class="pcalibre1 calibre6 pcalibre"/>allow <code>option</code>) and to be dynamically imported:</p>
<pre class="source-code">
// no changes to imports and definitions outside of Index
export default function Index() {
  // no changes to useState to maintain select state
  const TermsAndConditions = ['Short', 'Long',
    'LongScroll'].includes(
    selectedTermsAndConditions,
  )
    ? dynamic(() =&gt;
        import(
          `../components/TermsAndConditions$
            {selectedTermsAndConditions}.jsx`
        ).then(({ TermsAndConditions }) =&gt;
          TermsAndConditions),
      )
    : NoRender;
  return (
    &lt;&gt;
      {/* no change to content outside of select */}
      &lt;div&gt;
        {/* no change to label */}
        &lt;select
          id="termsAndConditionsType"
          onChange={(e) =&gt; setSelectedTermsAndConditions
            (e.target.value)}
        &gt;
          {/* no change to existing options */}
          &lt;option value="LongScroll"&gt;LongScroll&lt;/option&gt;
        &lt;/select&gt;
        &lt;hr /&gt;
        &lt;TermsAndConditions /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we <a id="_idIndexMarker571" class="pcalibre1 calibre6 pcalibre"/>run the next dev server, load the index page, and select <code>TermsAndConditionsLongScroll.jsx</code>.</p>
<div><div><img alt="Figure 9.10: TermsAndConditionsLongScroll.jsx selection with dynamic import" src="img/B19109_09_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.10: TermsAndConditionsLongScroll.jsx selection with dynamic import</p>
<p class="calibre3">In browsers where <code>behavior: 'smooth'</code> is supported, when the <strong class="bold">Scroll to bottom</strong> button is clicked, no additional JavaScript chunks are loaded and we’re scrolled to the checkbox input after the multiple paragraphs.</p>
<div><div><img alt="Figure 9.11: TermsAndConditionsLongScroll.jsx selection with dynamic import" src="img/B19109_09_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.11: TermsAndConditionsLongScroll.jsx selection with dynamic import</p>
<p class="calibre3">On browsers <a id="_idIndexMarker573" class="pcalibre1 calibre6 pcalibre"/>that don’t support <code>behavior: 'smooth'</code> for <a id="_idIndexMarker574" class="pcalibre1 calibre6 pcalibre"/>scrolling, <code>scroll-behavior-polyfill</code> will be loaded allowing for smooth scrolling to the checkbox.</p>
<div><div><img alt="Figure 9.12: TermsAndConditionsLongScroll.jsx selection with dynamic import of the component and of the scroll-behavior-polyfill module" src="img/B19109_09_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.12: TermsAndConditionsLongScroll.jsx selection with dynamic import of the component and of the scroll-behavior-polyfill module</p>
<p class="calibre3">Based <a id="_idIndexMarker575" class="pcalibre1 calibre6 pcalibre"/>on the Bundle Analyzer output (using <code>npm run analyze</code> and the <code>@next/bundle-analyzer</code> plugin), we can see that <a id="_idIndexMarker576" class="pcalibre1 calibre6 pcalibre"/>there is a chunk that contains <code>scroll-behavior-polyfill</code>, along with chunks for <code>pages/index.js</code> and one each for <code>TermsAndConditionsShort.jsx</code>, <code>TermsAndConditionsLong.jsx</code>, and <code>TermsAndConditionsLongScroll.jsx</code>.</p>
<div><div><img alt="Figure 9.13: Bundle Analyzer output for the pages/index.js chunk as well as relevant dynamic chunks (TermsAndConditionsShort, TermsAndConditionsLong, TermsAndConditionsLongScroll, and scroll-behavior-polyfill)" src="img/B19109_09_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.13: Bundle Analyzer output for the pages/index.js chunk as well as relevant dynamic chunks (TermsAndConditionsShort, TermsAndConditionsLong, TermsAndConditionsLongScroll, and scroll-behavior-polyfill)</p>
<p class="calibre3">We’ve now <a id="_idIndexMarker577" class="pcalibre1 calibre6 pcalibre"/>seen that Next.js code splits effectively <a id="_idIndexMarker578" class="pcalibre1 calibre6 pcalibre"/>on native <code>import()</code> as well as the provided <code>dynamic()</code> utility.</p>
<p class="calibre3">Finally, we’ll see how to use <code>dynamic()</code> and the <code>react-intersection-observer</code> package to dynamically load content when it is visible.</p>
<p class="calibre3">One other variant of a Terms and Conditions form or similar would be to include additional fields that should be captured when the customer accepts the terms.</p>
<p class="calibre3">In this example, we’ll add a <code>components/TermsForm.jsx</code> component with an input for the user’s name and a label for it:</p>
<pre class="source-code">
import React from 'react';
export default function TermsForm() {
  return (
    &lt;form&gt;
      &lt;label htmlFor="name"&gt;Type your name as signature
      &lt;/label&gt;
      &lt;input id="name" type="text" /&gt;
    &lt;/form&gt;
  );
}</pre> <p class="calibre3">Next, we’ll want to include it in <code>components/TermsAndConditionsLongScrollAcceptForm.jsx</code>. We’ll use <code>dynamic()</code> to load the <code>TermsForm</code> component.</p>
<p class="calibre3">The rest <a id="_idIndexMarker579" class="pcalibre1 calibre6 pcalibre"/>of our code is similar to the end state of the <code>TermsAndConditionsLongScroll</code> components, with a heading, 10 paragraphs, and an <code>accept</code> input.</p>
<p class="calibre3">The key <a id="_idIndexMarker580" class="pcalibre1 calibre6 pcalibre"/>exception is the import and usage of the <code>InView</code> component from <code>react-intersection-observer</code>.</p>
<p class="calibre3">The <code>InView</code> component has a children render property that receives, among other properties, the <code>ref</code> property, which we can attach to elements whose visibility we’re interested in. Another property of interest to us is the <code>inView</code> Boolean, which tells us whether the element on which we put the <code>ref</code> prop is in the viewport.</p>
<p class="calibre3">As the rendered output of the <code>InView</code> children function, we return a <code>div</code> element to which we attach the <code>ref</code> property. Inside of the <code>div</code>, we render <code>TermsForm</code> but only if <code>inView</code> is <code>true</code>:</p>
<pre class="source-code">
import React from 'react';
import dynamic from 'next/dynamic';
import { InView } from 'react-intersection-observer';
const TermsForm = dynamic(() =&gt; import('./TermsForm.jsx'));
export function TermsAndConditions() {
  return (
    &lt;&gt;
      &lt;h3&gt;Terms and Conditions Long Scroll Accept Form&lt;/h3&gt;
      {/* 10 paragraphs of content */}
      &lt;hr /&gt;
      &lt;InView&gt;
        {({ inView, ref }) =&gt; &lt;div ref={ref}&gt;{inView &amp;&amp;
          &lt;TermsForm /&gt;}&lt;/div&gt;}
      &lt;/InView&gt;
      &lt;label htmlFor="accept"&gt;
        &lt;input id="accept" name="acceptTerms"
          type="checkbox" /&gt;
        Accept Terms and Conditions
      &lt;/label&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Finally, we need <a id="_idIndexMarker581" class="pcalibre1 calibre6 pcalibre"/>to add <code>TermsAndConditionsLongScrollAcceptForm</code> as a selectable option and a dynamically <a id="_idIndexMarker582" class="pcalibre1 calibre6 pcalibre"/>loaded component:</p>
<pre class="source-code">
// no changes to imports and definitions outside of Index
export default function Index() {
  // no changes to useState to maintain select state
  const TermsAndConditions = [
    'Short',
    'Long',
    'LongScroll',
    'LongScrollAcceptForm',
  ].includes(selectedTermsAndConditions)
    ? dynamic(() =&gt;
        import(
          `../components/TermsAndConditions$
             {selectedTermsAndConditions}.jsx`
        ).then(({ TermsAndConditions }) =&gt;
          TermsAndConditions),
      )
    : NoRender;
  return (
    &lt;&gt;
      {/* no change to content outside of select */}
      &lt;div&gt;
        {/* no change to label */}
        &lt;select
          id="termsAndConditionsType"
          onChange={(e) =&gt; setSelectedTermsAndConditions
            (e.target.value)}
        &gt;
          {/* no change to existing options */}
          &lt;option value="LongScrollAcceptForm"&gt;
             LongScrollAcceptForm&lt;/option&gt;
        &lt;/select&gt;
        &lt;hr /&gt;
        &lt;TermsAndConditions /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Now, when we <a id="_idIndexMarker583" class="pcalibre1 calibre6 pcalibre"/>run the next dev server and load the <a id="_idIndexMarker584" class="pcalibre1 calibre6 pcalibre"/>index page, <code>LongScrollAcceptForm</code> is available. When we select it, the <code>TermsAndConditionsLongScrollAcceptForm.jsx</code> component is loaded.</p>
<div><div><img alt="Figure 9.14: LongScrollAcceptForm selected and TermsAndConditionsLongScrollAcceptForm.jsx dynamically loaded" src="img/B19109_09_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.14: LongScrollAcceptForm selected and TermsAndConditionsLongScrollAcceptForm.jsx dynamically loaded</p>
<p class="calibre3">When <code>TermsAndConditionsLongScrollAcceptForm</code> is scrolled to the bottom (to the <a id="_idIndexMarker585" class="pcalibre1 calibre6 pcalibre"/>point where the checkbox is visible), the <code>TermsForm.jsx</code> component <a id="_idIndexMarker586" class="pcalibre1 calibre6 pcalibre"/>is dynamically loaded and is shown on the page.</p>
<div><div><img alt="Figure 9.15: TermsAndConditionsLongScrollAcceptForm scrolled to the bottom and TermsForm.jsx dynamically loaded" src="img/B19109_09_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.15: TermsAndConditionsLongScrollAcceptForm scrolled to the bottom and TermsForm.jsx dynamically loaded</p>
<p class="calibre3">We’ve now <a id="_idIndexMarker587" class="pcalibre1 calibre6 pcalibre"/>seen how to load JavaScript and React<a id="_idTextAnchor270" class="pcalibre1 calibre6 pcalibre"/> <a id="_idIndexMarker588" class="pcalibre1 calibre6 pcalibre"/>components on component visibility and interaction with Next.js.</p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor271" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve covered various approaches for maximizing the performance of your JavaScript, React, and Next.js applications with lazy loading approaches and code splitting.</p>
<p class="calibre3">First, we showcased how to use the dynamic import syntax in a Vite-powered setup to cause code splitting and illustrated it by importing additional code only when it’s required (during an interaction handler).</p>
<p class="calibre3">Next, we saw how Next.js provides out-of-the-box route-based code splitting while also ensuring modules shared across pages don’t get loaded or output more than once. We also delved into how to validate this using the Next.js Bundle Analyzer plugin.</p>
<p class="calibre3">Finally, we covered how to implement different lazy loading scenarios in Next.js: on presence in the component tree, on change caused by user interaction, importing a JavaScript module during an event handler, and lazy loading on an element entering the viewport.</p>
<p class="calibre3">We now know how to leverage lazy loading and code splitting to maximize application load performance. In the next chapter, we’ll cover asset-loading strategies and how to execute code off the main thread.</p>
</div>
</body></html>