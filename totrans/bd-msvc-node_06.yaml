- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Designing Microservices Architecture in Node.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js中设计微服务架构
- en: Designing a microservices architecture in Node.js involves breaking down a monolithic
    application into smaller, independent services that can be developed, deployed,
    and scaled individually.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中设计微服务架构涉及将单体应用程序分解成更小、独立的微服务，这些微服务可以单独开发、部署和扩展。
- en: We’ll start this chapter by designing microservices architecture in Node.js
    for microservices development. Designing microservices architecture in Node.js
    is often a complex task that needs to be taken seriously while developing microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始本章，通过在Node.js中设计微服务架构来为微服务开发做准备。在Node.js中设计微服务架构通常是一项复杂的任务，需要在开发微服务时认真对待。
- en: By the end of this chapter, you will be able to design a robust microservices
    architecture in Node.js that is scalable, resilient, and maintainable, allowing
    you to efficiently develop and deploy complex applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够设计一个在Node.js中健壮的、可扩展的、有弹性的和可维护的微服务架构，这将使你能够高效地开发和部署复杂的应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Things to consider before creating your microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建微服务之前需要考虑的事项
- en: Communication protocol and design APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议和设计API
- en: Decentralized data management and data consistency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散式数据管理和数据一致性
- en: Authentication and authorization, error handling, and fault tolerance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权、错误处理和容错性
- en: Monitoring and tracing requests and containerization technologies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和跟踪请求以及容器化技术
- en: Things to consider before creating your microservice
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在创建微服务之前需要考虑的事项
- en: In this section, we’re going to identify the distinct business capabilities
    that can be separated into individual microservices and define the boundaries
    of each microservice. Identifying microservices refers to the process of determining
    which components or functionalities within your application should be implemented
    as separate, independent microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将识别可以分离成独立微服务的不同业务能力，并定义每个微服务的边界。识别微服务是指确定应用程序中哪些组件或功能应作为独立的、独立的微服务实现的过程。
- en: 'Here are the key steps to identify microservices:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 识别微服务的关键步骤如下：
- en: '**Decompose by business capability**: Start by understanding your application’s
    business domain. Identify distinct business capabilities or functionalities. Each
    business capability can often be a good candidate for a microservice. For example,
    user management, product catalog, order processing, and payment processing could
    be separate microservices.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按业务能力分解**：首先理解你的应用程序的业务领域。识别不同的业务能力或功能。每个业务能力通常都可以作为微服务的良好候选者。例如，用户管理、产品目录、订单处理和支付处理可以是独立的微服务。'
- en: '**Apply domain-driven design** (**DDD**): DDD is a design approach that encourages
    modeling your application’s domain in a way that aligns with your business requirements.
    Identify bounded contexts within your domain that represent distinct areas with
    their own rules and models. Each bounded context can become a microservice.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用领域驱动设计（DDD**）：DDD是一种设计方法，鼓励以与你的业务需求一致的方式对应用程序的领域进行建模。识别领域内的边界上下文，这些上下文代表具有自己规则和模型的独立区域。每个边界上下文都可以成为一个微服务。'
- en: '**Analyze dependencies**: Analyze the dependencies between different parts
    of your application. Microservices should ideally have minimal dependencies on
    each other. Identify components that can be isolated with their data and logic,
    reducing inter-service dependencies.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析依赖关系**：分析应用程序不同部分之间的依赖关系。微服务理想情况下应相互之间有最小的依赖。识别可以与其数据和逻辑隔离的组件，减少服务间的依赖。'
- en: '**Data isolation**: Consider data ownership when identifying microservices.
    A microservice should typically own and manage its data. If different parts of
    your application require different databases or data storage solutions, it may
    indicate the need for separate microservices.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据隔离**：在识别微服务时考虑数据所有权。微服务通常应拥有并管理自己的数据。如果应用程序的不同部分需要不同的数据库或数据存储解决方案，这可能表明需要独立的微服务。'
- en: '**Separation of concerns**: Apply the principle of separation of concerns.
    Each microservice should have a single, well-defined responsibility. If a component
    or functionality is handling multiple responsibilities, consider splitting it
    into multiple microservices.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关注点分离**：应用关注点分离原则。每个微服务应有一个单一、明确的责任。如果一个组件或功能处理多个责任，考虑将其拆分为多个微服务。'
- en: '**Scalability requirements**: Consider the scalability requirements of the
    different parts of your application. Some functionalities may need to scale independently,
    making them good candidates for microservices.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可扩展性需求**：考虑应用不同部分的可扩展性需求。某些功能可能需要独立扩展，这使得它们成为微服务的良好候选。'
- en: '**Technical stack**: Assess the technical stack and technologies used for different
    parts of your application. If certain components require different technologies
    or languages, they may be better suited as separate microservices.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**技术栈**：评估应用不同部分所使用的技**术栈**和**技术**。如果某些组件需要不同的技术或语言，它们可能更适合作为独立的微服务。'
- en: '**Deployment and life cycle**: Evaluate the deployment and life cycle requirements
    of various components. Some parts may need frequent updates or deployments, making
    them suitable for microservices.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署和生命周期**：评估各种组件的部署和生命周期需求。某些部分可能需要频繁更新或部署，这使得它们适合作为微服务。'
- en: '**Ownership and teams**: Consider the ownership and development teams for different
    parts of your application. Microservices often align with ownership boundaries,
    where each team is responsible for one or more microservices.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有权和团队**：考虑应用不同部分的所有权和开发团队。微服务通常与所有权边界相一致，每个团队负责一个或多个微服务。'
- en: '**Client needs**: Take into account the needs of the clients or consumers of
    your services. Different clients may require different sets of functionalities.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端需求**：考虑服务客户端或消费者的需求。不同的客户端可能需要不同的功能集。'
- en: '**Use cases and user journeys**: Analyze the use cases and user journeys within
    your application. Some use cases may align well with separate microservices.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用例和用户旅程**：分析应用内的用例和用户旅程。某些用例可能与独立的微服务很好地匹配。'
- en: '**Testing and maintenance**: Consider testing and maintenance requirements.
    Smaller microservices are often easier to test, maintain, and evolve.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试和维护**：考虑测试和维护需求。较小的微服务通常更容易测试、维护和演进。'
- en: '**Iterate and refine**: The process of identifying microservices is iterative.
    You may start with an initial breakdown and refine it over time as you gain a
    deeper understanding of your application’s requirements and usage patterns.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迭代和精炼**：识别微服务的过程是迭代的。您可能从初步分解开始，随着时间的推移，随着对应用需求和用法模式的深入了解，对其进行精炼。'
- en: It’s important to strike a balance between creating microservices that are too
    fine-grained (leading to excessive complexity) and ones that are too monolithic
    (defeating the purpose of microservices).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建过于细粒度的微服务（导致过度复杂性）和过于单体化的微服务（违背微服务目的）之间取得平衡是很重要的。
- en: Additional information
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: The *principle of separation of concerns* is a principle used in programming
    to separate an application into units, with minimal overlapping between the functions
    of the individual units. The separation of concerns is achieved using modularization,
    encapsulation, and arrangement in software layers. See more at [help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenseperation_concerns_guidl.htm#:~:text=Separation%20of%20concerns%20is%20a,and%20arrangement%20in%20software%20layers](http://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenseperation_concerns_guidl.htm#:~:text=Separation%20of%20concerns%20is%20a,and%20arrangement%20in%20software%20layers).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离原则**是编程中用来将应用分割成单元的原则，这些单元的功能之间重叠最小。通过模块化、封装和软件层的排列来实现关注点分离。更多信息请参阅[help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenseperation_concerns_guidl.htm#:~:text=Separation%20of%20concerns%20is%20a,and%20arrangement%20in%20software%20layers](http://help.sap.com/doc/abapdocu_753_index_htm/7.53/en-US/abenseperation_concerns_guidl.htm#:~:text=Separation%20of%20concerns%20is%20a,and%20arrangement%20in%20software%20layers)。'
- en: '*Figure 6**.1* illustrates the process of identifying microservices:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*展示了识别微服务的过程：'
- en: '![](img/B14980_06_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14980_06_01.jpg)'
- en: 'Figure 6.1: Identifying microservices (image by fullvector on Freepik)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：识别微服务（图片由Freepik上的fullvector提供）
- en: Collaboration among teams, domain experts, and architects is essential during
    the identification and design of microservices to ensure that the resulting architecture
    aligns with business goals and technical requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别和设计微服务的过程中，团队之间的协作、领域专家和架构师的合作至关重要，以确保最终架构与业务目标和技术要求相一致。
- en: With an understanding of these concepts, let’s now move on to the communication
    protocol and design APIs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了这些概念后，我们现在可以继续讨论通信协议和设计 API。
- en: Communication protocol and design APIs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议和设计 API
- en: '**Communication protocol and design APIs** can teach us many things about how
    to select a communication protocol that suits your requirements and design well-defined
    and versioned APIs for each microservice.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**通信协议和设计 API** 可以教会我们如何选择适合您需求的通信协议，并为每个微服务设计定义良好且版本化的 API。'
- en: The selection of communication protocols and design of APIs are crucial aspects
    of building microservices architectures, as they enable services to interact effectively
    and provide a well-defined interface for clients.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 选择通信协议和设计 API 是构建微服务架构的关键方面，因为它们使服务能够有效地交互，并为客户端提供一个定义良好的接口。
- en: Let’s look at some key considerations for communication protocols and API design
    in microservices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看微服务中通信协议和 API 设计的一些关键考虑因素。
- en: Communication protocol
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信协议
- en: 'In a microservices architecture, communication between services is a critical
    aspect that directly impacts the system’s performance, scalability, and reliability.
    Communication protocols are fundamental in enabling seamless interaction between
    microservices in a distributed architecture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务之间的通信是一个关键方面，它直接影响系统的性能、可扩展性和可靠性。通信协议是使分布式架构中的微服务之间无缝交互的基础：
- en: '**HTTP/HTTPS**: Most microservices communicate over HTTP or its secure counterpart,
    HTTPS. This choice is widely adopted due to its simplicity, ease of use, and compatibility
    with web technologies.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/HTTPS**: 大多数微服务通过 HTTP 或其安全版本 HTTPS 进行通信。这种选择因其简单性、易用性和与网络技术的兼容性而被广泛采用。'
- en: '**gRPC**: gRPC is a high-performance, language-agnostic framework for building
    **remote procedure call** (**RPC**) APIs. It uses **Protocol Buffers** (**Protobuf**)
    for efficient data serialization.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC**: gRPC 是一个高性能、语言无关的框架，用于构建 **远程过程调用** (RPC) API。它使用 **Protocol Buffers**
    (Protobuf) 进行高效的数据序列化。'
- en: '**Message queues**: For asynchronous communication and event-driven architectures,
    message queues such as RabbitMQ, Apache Kafka, or AWS SQS are used. These facilitate
    decoupled communication between services.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息队列**: 对于异步通信和事件驱动架构，使用 RabbitMQ、Apache Kafka 或 AWS SQS 等消息队列。这些队列促进了服务之间的解耦通信。'
- en: '**WebSocket**: WebSocket is used for bidirectional, real-time communication
    between microservices and clients. It’s suitable for applications that require
    instant updates, such as chat applications or real-time dashboards.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSocket**: WebSocket 用于微服务和客户端之间的双向、实时通信。它适用于需要即时更新的应用程序，如聊天应用或实时仪表板。'
- en: '**Custom protocols**: In some cases, custom communication protocols are developed,
    especially when optimizing for specific use cases or performance requirements.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义协议**: 在某些情况下，会开发自定义通信协议，尤其是在针对特定用例或性能要求进行优化时。'
- en: '`GET`, `POST`, `PUT`, and `DELETE`) and is stateless, making it suitable for
    many microservices interactions.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`GET`、`POST`、`PUT` 和 `DELETE`) 是无状态的，这使得它适合许多微服务交互。
- en: '*Figure 6**.2* illustrates the communication protocol:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.2* 展示了通信协议：'
- en: '![](img/B14980_06_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14980_06_02.jpg)'
- en: 'Figure 6.2: Communication protocol (image by studiogstock on Freepik)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：通信协议（图片由 studiogstock 在 Freepik 提供）
- en: In summary, the choice of communication protocol in a microservices architecture
    is a critical decision that depends on factors such as system requirements, performance
    considerations, and the nature of data exchanges between services. Each protocol
    has its strengths and use cases, and the selection should align with the goals
    of the microservices ecosystem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，微服务架构中通信协议的选择是一个关键决策，这取决于系统需求、性能考虑以及服务之间数据交换的性质。每种协议都有其优势和用例，选择应与微服务生态系统的目标相一致。
- en: With these concepts learned, we can continue with API design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了这些概念后，我们可以继续进行 API 设计。
- en: API design
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 设计
- en: '**API design** involves coordinating and managing the complete process of building
    robust and functional APIs for communication with microservices. In addition,
    it is a critical aspect of microservices architecture, influencing how services
    interact and enabling effective communication.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**API设计**涉及协调和管理构建用于与微服务通信的强大且功能齐全的API的完整过程。此外，它还是微服务架构的关键方面，影响着服务之间的交互并促进有效通信。'
- en: 'Here’s how the API design process works:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是API设计过程的工作方式：
- en: '`/v1/endpoint`) to ensure backward compatibility when making changes.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改时确保向后兼容性，使用`/v1/endpoint`。
- en: '**Resource naming**: Use descriptive, pluralized nouns for resource names in
    RESTful APIs. Choose meaningful names that align with your application’s domain.
    A resource can be a singleton or a collection. For example, “customers” is a collection
    resource, and “customer” is a singleton resource (in a banking domain).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源命名**: 在RESTful API中使用描述性、复数的名词作为资源名称。选择与您的应用程序域相关的有意义的名称。资源可以是单个实体或集合。例如，“customers”是一个集合资源，而“customer”是一个单个实体资源（在银行领域）。'
- en: '`GET`, `POST`, `PUT`, and `DELETE`) correctly. Use `GET` for read-only operations,
    `POST` for creating resources, `PUT` for updating, and `DELETE` for deletion.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用`GET`、`POST`、`PUT`和`DELETE`。使用`GET`进行只读操作，`POST`用于创建资源，`PUT`用于更新，`DELETE`用于删除。
- en: '`200` for success, `400` for client errors, and `500` for server errors) to
    convey the outcome of API requests clearly.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`200`表示成功，`400`表示客户端错误，`500`表示服务器错误，以清楚地传达API请求的结果。
- en: '**Request and response formats**: Standardize request and response formats,
    typically using JSON. Define clear structures for data to enhance consistency.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求和响应格式**: 标准化请求和响应格式，通常使用JSON。定义清晰的数据结构以增强一致性。'
- en: '**Pagination and filtering**: Implement pagination and filtering options in
    endpoints that return lists of resources to improve efficiency and usability.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页和过滤**: 在返回资源列表的端点中实现分页和过滤选项，以提高效率和可用性。'
- en: '**Authentication and authorization**: Clearly define how authentication and
    authorization are handled in your APIs. Use standards like OAuth 2.0 or API keys.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证和授权**: 明确定义您的API中如何处理身份验证和授权。使用如OAuth 2.0或API密钥等标准。'
- en: '**Error handling**: Design a consistent error handling mechanism to provide
    informative error messages with details on how to resolve issues.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**: 设计一个一致的错误处理机制，以提供包含如何解决问题的详细信息的错误信息。'
- en: '**Rate limiting**: Implement rate limiting to protect your APIs from abuse
    and to ensure fair usage.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**: 实施速率限制以保护API免受滥用并确保公平使用。'
- en: '**Documentation**: Create comprehensive API documentation that includes endpoint
    descriptions, request/response examples, authentication details, and error codes.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**: 创建全面的API文档，包括端点描述、请求/响应示例、身份验证细节和错误代码。'
- en: '**HATEOAS**: Consider implementing **hypermedia as the engine of application
    state** (**HATEOAS**) to provide clients with links to related resources within
    responses, promoting self-discovery of the API.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HATEOAS**: 考虑实现**超媒体作为应用程序状态引擎**（HATEOAS），在响应中为客户端提供相关资源的链接，促进API的自发现。'
- en: '**Validation**: Validate input data on the server side to ensure data integrity
    and security.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**: 在服务器端验证输入数据以确保数据完整性和安全性。'
- en: '**Testing**: Thoroughly test your APIs using tools such as Postman, Swagger,
    or automated testing frameworks. Cover both positive and negative test cases.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**: 使用Postman、Swagger或自动化测试框架等工具彻底测试您的API。涵盖正负测试用例。'
- en: '**Versioning and deprecation**: Plan for versioning and deprecation strategies
    to manage changes and inform clients about upcoming modifications.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制和弃用**: 制定版本控制和弃用策略以管理更改并通知客户端即将进行的修改。'
- en: '**Monitoring**: Implement API monitoring and analytics to track usage, detect
    performance bottlenecks, and troubleshoot issues.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**: 实施API监控和分析，以跟踪使用情况，检测性能瓶颈，并解决问题。'
- en: '**Security**: Apply security best practices, including input validation, authorization
    checks, and protection against common vulnerabilities like SQL injection and XSS
    attacks.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**: 应用安全最佳实践，包括输入验证、授权检查以及防止SQL注入和XSS攻击等常见漏洞。'
- en: '**Performance**: Optimize API performance by minimizing unnecessary data transfer
    and using caching where appropriate.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 通过最小化不必要的数据传输并在适当的位置使用缓存来优化API性能。'
- en: '**Feedback loop:** Establish a feedback loop with API consumers to gather their
    input and improve the API based on their needs.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈循环**：与API消费者建立反馈循环，收集他们的意见并根据他们的需求改进API。'
- en: '**Testing staging environment**: Provide a testing or staging environment where
    clients can experiment with your APIs before using them in production.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试环境**：提供一个测试或预生产环境，让客户端在使用生产环境之前可以实验您的API。'
- en: With these concepts in mind, the process of building better APIs is something
    that can be done easily and can last for a long time while maintaining a robust
    architecture. Effective API design is a cornerstone of microservices development,
    promoting interoperability, maintainability, and a positive developer experience.
    Regularly revisit and refine API designs to align with evolving business needs
    and industry best practices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些概念，构建更好的API的过程可以轻松完成，并且可以长期维持，同时保持稳健的架构。有效的API设计是微服务开发的基石，促进互操作性、可维护性和积极的开发者体验。定期回顾和优化API设计，以适应不断变化的企业需求和行业最佳实践。
- en: Additional information
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 附加信息
- en: HATEOAS is a constraint of the REST application architecture that distinguishes
    it from other network application architectures. With HATEOAS, a client interacts
    with a network application whose application servers provide information dynamically
    through hypermedia. More information is available at [htmx.org/essays/hateoas/](http://htmx.org/essays/hateoas/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS是REST应用架构的一个约束条件，使其与其他网络应用架构区分开来。使用HATEOAS，客户端与一个网络应用交互，该应用的服务器通过超媒体动态提供信息。更多信息请参阅[htmx.org/essays/hateoas/](http://htmx.org/essays/hateoas/)。
- en: '*Figure 6**.3* depicts the process of API design:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.3*展示了API设计的过程：'
- en: '![](img/B14980_06_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14980_06_03.jpg)'
- en: 'Figure 6.3: API design (image on Freepik)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：API设计（Freepik上的图片）
- en: In summary, effective communication protocols and well-designed APIs are essential
    for the success of microservices architectures, promoting interoperability, reliability,
    and maintainability of services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，有效的通信协议和精心设计的API对于微服务架构的成功至关重要，促进服务的互操作性、可靠性和可维护性。
- en: Now, we can continue to the next section, in which we will talk about decentralized
    data management and data consistency.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到下一节，我们将讨论去中心化数据管理和数据一致性。
- en: Decentralized data management and data consistency
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化数据管理和数据一致性
- en: In a microservices architecture, **decentralized data management and data consistency**
    are important considerations. Microservices often maintain their own databases,
    and managing data in a distributed environment can be challenging.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，**去中心化数据管理和数据一致性**是重要的考虑因素。微服务通常维护自己的数据库，在分布式环境中管理数据可能会具有挑战性。
- en: 'Here are some key principles and strategies to achieve decentralized data management
    while ensuring data consistency:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键原则和策略，以在确保数据一致性的同时实现去中心化数据管理：
- en: '**Decentralized data ownership**: Assign each microservice ownership of its
    own data. This means that each service is responsible for the storage, retrieval,
    and management of its data.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化数据所有权**：分配每个微服务对其数据的所有权。这意味着每个服务负责其数据的存储、检索和管理。'
- en: '**Use appropriate databases**: Choose the right database technology for each
    microservice based on its specific requirements. Options include relational databases
    (SQL) and NoSQL databases (e.g., MongoDB, Cassandra).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用合适的数据库**：根据每个微服务的具体需求选择合适的数据库技术。选项包括关系型数据库（SQL）和非关系型数据库（例如，MongoDB、Cassandra）。'
- en: '**Event sourcing and CQRS**: Consider event sourcing and **command query responsibility
    segregation** (**CQRS**) patterns to maintain a log of all changes to the data.
    This can help achieve data consistency by replaying events to recreate a service’s
    state.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件溯源和CQRS**：考虑事件溯源和**命令查询责任分离**（CQRS）模式来维护数据所有变更的日志。这可以通过重放事件来重新创建服务状态，从而帮助实现数据一致性。'
- en: '**Asynchronous communication**: Use asynchronous messaging patterns (message
    queues, event brokers) to propagate data changes and events between microservices.
    This enables eventual consistency.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：使用异步消息模式（消息队列、事件代理）在微服务之间传播数据变更和事件。这可以实现最终一致性。'
- en: '**Synchronous communication**: When synchronous communication is necessary,
    implement compensation or rollback mechanisms to handle failures and maintain
    consistency.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：当需要同步通信时，实施补偿或回滚机制来处理故障并保持一致性。'
- en: '**Distributed transactions (caution)**: Be cautious with distributed transactions,
    as they can lead to performance and scalability issues. Consider using **two-phase
    commit** (**2PC**) sparingly and explore alternatives such as Saga patterns.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务（谨慎使用）**：对分布式事务要谨慎，因为它们可能导致性能和可扩展性问题。应谨慎使用**两阶段提交**（**2PC**），并探索如 Saga
    模式等替代方案。'
- en: '**Saga pattern**: Implement the Saga pattern for long-running transactions
    across multiple microservices. Sagas are a sequence of local transactions, and
    compensating actions are used to maintain consistency if a step fails.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saga 模式**：在多个微服务之间实现 Saga 模式以处理长时间运行的交易。Sagas 是一系列本地事务，如果某个步骤失败，则使用补偿操作来维护一致性。'
- en: '**Idempotency**: Ensure that operations in microservices are idempotent, meaning
    they can be repeated without changing the result. This helps manage failures and
    retries without causing inconsistencies.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：确保微服务中的操作是幂等的，这意味着它们可以被重复执行而不会改变结果。这有助于管理失败和重试，而不会导致不一致。'
- en: '**Data validation and constraints**: Enforce data validation and constraints
    within microservices to prevent invalid or inconsistent data from entering the
    system.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据验证和约束**：在微服务内部执行数据验证和约束，以防止无效或不一致的数据进入系统。'
- en: '**Consistency models**: Understand and choose the appropriate consistency model
    for your application. Options include strong consistency, eventual consistency,
    and causal consistency, depending on your requirements.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性模型**：了解并选择适合您应用程序的适当一致性模型。选项包括强一致性、最终一致性和因果一致性，具体取决于您的需求。'
- en: '**Data replication**: Consider replicating data across multiple data stores
    or microservices for redundancy and availability.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复制**：考虑在多个数据存储或微服务之间复制数据以提高冗余性和可用性。'
- en: '**Global unique identifiers** (**GUIDs**): Use GUIDs or **universally unique
    identifiers** (**UUIDs**) to ensure that data records across microservices have
    unique identifiers.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局唯一标识符**（**GUIDs**）：使用 GUID 或 **通用唯一标识符**（**UUIDs**）以确保微服务中的数据记录具有唯一的标识符。'
- en: '**Monitoring and logging**: Implement robust monitoring and logging to detect
    data consistency issues early. Use tools such as distributed tracing and centralized
    logging.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和日志记录**：实现强大的监控和日志记录，以早期发现数据一致性问题时。使用分布式跟踪和集中式日志记录等工具。'
- en: '**Data backup and recovery**: Develop data backup and recovery strategies to
    mitigate data loss in the case of failures or data corruption.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据备份和恢复**：制定数据备份和恢复策略，以减轻故障或数据损坏导致的数据丢失。'
- en: '**Testing and validation**: Thoroughly test data consistency scenarios, including
    failure recovery and data reconciliation processes.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和验证**：彻底测试数据一致性场景，包括故障恢复和数据对齐过程。'
- en: '**Documentation and communication**: Document data consistency strategies and
    communicate them clearly among development teams. Ensure that all team members
    understand and follow these strategies.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档和沟通**：记录数据一致性策略，并在开发团队之间清晰沟通。确保所有团队成员都理解并遵循这些策略。'
- en: '**Data governance**: Establish data governance practices and policies to maintain
    data quality and consistency throughout the microservices ecosystem.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据治理**：建立数据治理实践和政策，以维护整个微服务生态系统中数据的质量和一致性。'
- en: Data consistency in microservices is often achieved through trade-offs between
    strong consistency and eventual consistency depending on your application’s requirements
    and performance constraints.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，数据一致性通常通过在强一致性和最终一致性之间进行权衡来实现，具体取决于您应用程序的需求和性能限制。
- en: Additional information
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: CQRS is a system architecture that extends the idea behind command-query separation
    to the level of services. More information is available at [learn.microsoft.com/en-us/azure/architecture/patterns/cqrs](http://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 是一种系统架构，它将命令查询分离的思想扩展到服务层面。更多信息请参阅 [learn.microsoft.com/en-us/azure/architecture/patterns/cqrs](http://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)。
- en: '*Figure 6**.4* illustrates decentralized data management:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.4* 展示了去中心化的数据管理：'
- en: '![](img/B14980_06_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14980_06_04.jpg)'
- en: 'Figure 6.4: Decentralized data management (image by rawpixel.com on Freepik)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：去中心化的数据管理（图片由 rawpixel.com 在 Freepik 提供）
- en: In summary, it’s essential to carefully design and implement data management
    strategies to maintain the integrity of your data while leveraging the benefits
    of a microservices architecture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，精心设计和实施数据管理策略对于维护数据的完整性并利用微服务架构的优势至关重要。
- en: In the next section, we will learn about authentication and authorization, error
    handling, and fault tolerance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于认证和授权、错误处理和容错性。
- en: Authentication and authorization and error handling and fault tolerance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权、错误处理和容错性
- en: We will learn about how to implement a robust authentication and authorization
    mechanism to secure access to your microservices and build fault-tolerant microservices
    that can handle errors and failures gracefully.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何实现一个健壮的认证和授权机制来保护对您的微服务的访问，并构建能够优雅处理错误和故障的容错性微服务。
- en: Authentication, authorization, error handling, and fault tolerance are critical
    aspects of building secure and robust microservices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 认证、授权、错误处理和容错性是构建安全且健壮微服务的关键方面。
- en: Let’s explore each of these topics in more detail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些主题。
- en: Authentication and authorization
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: '**Authentication and authorization** are fundamental security concepts in any
    software system, including microservices architectures. They are often used together
    to ensure that users and services are who or what they claim to be (authentication)
    and that they have the appropriate permissions to access specific resources or
    perform certain actions (authorization):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证和授权**是任何软件系统中的基本安全概念，包括微服务架构。它们通常一起使用，以确保用户和服务是其所声称的（认证）以及他们有权访问特定资源或执行特定操作（授权）：'
- en: '**Authentication** (**AuthN**): Authentication verifies the identity of users
    or services. Common methods include username/password, API keys, tokens, or **single
    sign-on** (**SSO**). Use authentication mechanisms such as OAuth 2.0 or **JSON**
    **W****eb Tokens** (**JWT**) for securing API endpoints. Implement strong password
    policies, **multi-factor authentication** (**MFA**), and secure storage of credentials.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**（**AuthN**）：认证验证用户或服务的身份。常见的方法包括用户名/密码、API密钥、令牌或**单点登录**（**SSO**）。使用OAuth
    2.0或**JSON Web Tokens**（**JWT**）等认证机制来保护API端点。实施强大的密码策略、**多因素认证**（**MFA**）和凭据的安全存储。'
- en: '**Authorization** (**AuthZ**): Authorization controls access to resources based
    on the authenticated user’s or service’s permissions. Implement **role-based access
    control** (**RBAC**) or **attribute-based access control** (**ABAC**) to define
    who or what can access what resources. Use middleware or API gateways to enforce
    authorization rules.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**（**AuthZ**）：授权基于已认证用户或服务的权限控制对资源的访问。实施**基于角色的访问控制**（**RBAC**）或**基于属性的访问控制**（**ABAC**）来定义谁或什么可以访问什么资源。使用中间件或API网关来强制执行授权规则。'
- en: '**OAuth 2.0 and OpenID connect** (**OIDC**): OAuth 2.0 is a widely used protocol
    for delegated authorization. OIDC extends OAuth 2.0 for user authentication. Use
    OAuth 2.0 and OIDC for secure authentication and authorization in microservices-based
    applications.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2.0和OpenID连接**（**OIDC**）：OAuth 2.0是一个广泛使用的委托授权协议。OIDC扩展了OAuth 2.0以用于用户认证。在基于微服务的应用程序中使用OAuth
    2.0和OIDC进行安全的认证和授权。'
- en: '**Single sign-on** (**SSO**): Implement SSO solutions to allow users to authenticate
    once and access multiple services without re-entering credentials.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录**（**SSO**）：实施SSO解决方案，使用户只需认证一次即可访问多个服务，无需重新输入凭据。'
- en: '**Token-based authentication**: Use tokens (e.g., JWT) for stateless authentication.
    Tokens contain user identity information and are signed or encrypted to prevent
    tampering.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于令牌的认证**：使用令牌（例如，JWT）进行无状态认证。令牌包含用户身份信息，并经过签名或加密以防止篡改。'
- en: '**Service-to-service authentication**: Use **mutual TLS** (**mTLS**) or API
    keys for authentication between microservices. Implement a service mesh for securing
    service-to-service communication.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务间认证**：在微服务之间使用**双向TLS**（**mTLS**）或API密钥进行认证。实施服务网格以保护服务间的通信。'
- en: '**Audit logging**: Log authentication and authorization events for auditing
    and compliance purposes.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计日志**：记录认证和授权事件以进行审计和合规性目的。'
- en: Authentication and authorization can help a lot in the process of building secure
    and robust microservices while maintaining a good architecture of applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权在构建安全且健壮的微服务过程中可以起到很大作用，同时保持良好的应用程序架构。
- en: In the next section, we will talk about error handling and fault tolerance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论错误处理和容错性。
- en: Error handling and fault tolerance
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理和容错性
- en: '**Error handling and fault tolerance** are critical aspects of designing robust
    and reliable microservices architectures. In a distributed system like microservices,
    failures are inevitable, and services must be able to handle errors gracefully
    and continue to operate whenever possible:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误处理和容错**是设计健壮和可靠的微服务架构的关键方面。在像微服务这样的分布式系统中，故障是不可避免的，服务必须能够优雅地处理错误，并在可能的情况下继续运行：'
- en: '**Graceful degradation**: Design microservices to degrade gracefully under
    load or when dependent services are unavailable. Provide fallback mechanisms or
    cached data.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优雅降级**: 设计微服务以在负载下或依赖服务不可用的情况下优雅降级。提供回退机制或缓存数据。'
- en: '**Circuit breaker pattern**: Implement the circuit breaker pattern to detect
    and prevent repeated requests to failing services. Open the circuit when failures
    reach a threshold.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器模式**: 实现断路器模式以检测和防止对失败服务的重复请求。当失败达到阈值时，打开电路。'
- en: '**Retry strategies**: Use retry mechanisms to handle transient failures. Implement
    exponential backoff and jitter to avoid overwhelming dependent services.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试策略**: 使用重试机制来处理短暂故障。实现指数退避和抖动以避免压倒依赖服务。'
- en: '**Timeouts**: Set timeouts for requests to prevent them from blocking indefinitely.
    Timeouts should be appropriate for the expected response times.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**: 为请求设置超时，以防止它们无限期地阻塞。超时应该适合预期的响应时间。'
- en: '**Isolation and bulkheads**: Use techniques such as microservices isolation
    and bulkheads to contain failures and prevent them from propagating to other parts
    of the system.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离和防波堤**: 使用微服务隔离和防波堤等技术来限制故障并防止其传播到系统的其他部分。'
- en: '**Error handling middleware**: Implement centralized error handling middleware
    to capture and respond to exceptions consistently across microservices.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理中间件**: 实现集中式错误处理中间件，以在微服务之间一致地捕获和响应异常。'
- en: '**Error codes and messages**: Define a standardized set of error codes and
    messages to convey meaningful information to clients. Include error details in
    API responses.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误代码和消息**: 定义一组标准化的错误代码和消息，以向客户端传达有意义的信息。在API响应中包含错误详细信息。'
- en: '**Monitoring and alerts**: Implement monitoring and alerting systems to detect
    performance issues and errors in real time. Use tools such as Prometheus and Grafana
    for monitoring microservices.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和警报**: 实现监控和警报系统以实时检测性能问题和错误。使用Prometheus和Grafana等工具监控微服务。'
- en: '**Testing for resilience**: Conduct resilience testing, including chaos engineering,
    to simulate failures and assess how well your microservices handle them.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试弹性**: 进行弹性测试，包括混沌工程，以模拟故障并评估微服务处理故障的能力。'
- en: '**Documentation**: Document error-handling strategies, fault-tolerance mechanisms,
    and retry policies for developers and operations teams.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**: 为开发者和运维团队记录错误处理策略、容错机制和重试策略。'
- en: '**Fallback services**: When a service is unavailable, provide fallback services
    or cached data to maintain basic functionality.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退服务**: 当服务不可用时，提供回退服务或缓存数据以保持基本功能。'
- en: '**Rollback and recovery plans**: Develop rollback and recovery plans in the
    case of severe failures, data corruption, or security breaches.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚和恢复计划**: 在严重故障、数据损坏或安全漏洞的情况下制定回滚和恢复计划。'
- en: In summary, authentication, authorization, error handling, and fault tolerance
    are crucial for building microservices that are secure, reliable, and capable
    of withstanding the challenges of a distributed architecture. These practices
    help ensure the availability and integrity of your services while protecting sensitive
    data from unauthorized access.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，身份验证、授权、错误处理和容错对于构建安全、可靠且能够承受分布式架构挑战的微服务至关重要。这些实践有助于确保服务的可用性和完整性，同时保护敏感数据免受未经授权的访问。
- en: In the last section, we are going to talk about monitor and trace requests and
    containerization technologies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节，我们将讨论监控和跟踪请求以及容器化技术。
- en: Monitoring and tracing requests and containerization technologies
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和跟踪请求以及容器化技术
- en: In this section, you will learn how to implement monitoring and distributed
    tracing to gain insight into the performance and behavior of your microservices
    and how to utilize containerization technologies such as Docker to package your
    microservices into portable and lightweight containers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何实现监控和分布式跟踪以深入了解微服务的性能和行为，以及如何利用容器化技术（如 Docker）将微服务打包成便携式和轻量级的容器。
- en: Let’s explore these topics in detail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨这些主题。
- en: Monitoring and tracing requests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和跟踪请求
- en: '**Monitoring and tracing requests** in a microservices architecture are essential
    for gaining insight into the performance, behavior, and dependencies of services.
    Proper monitoring and tracing enable you to identify bottlenecks, diagnose issues,
    and optimize the system’s overall performance:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中**监控和跟踪请求**对于深入了解服务的性能、行为和依赖性至关重要。适当的监控和跟踪使您能够识别瓶颈、诊断问题并优化系统的整体性能：
- en: '**Distributed tracing**: Implement distributed tracing to track requests as
    they flow through various microservices. Popular tools include Jaeger, Zipkin,
    and OpenTelemetry. Use trace identifiers (e.g., trace IDs) to correlate requests
    across different microservices and services.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪**：实现分布式跟踪以跟踪请求在各个微服务中的流动。流行的工具包括 Jaeger、Zipkin 和 OpenTelemetry。使用跟踪标识符（例如，跟踪
    ID）来关联不同微服务和服务的请求。'
- en: '**Request logging**: Log essential information about incoming requests, such
    as request method, URL, headers, and timestamps. Include correlation IDs or request
    IDs in logs to tie together log entries related to the same request.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求日志记录**：记录关于传入请求的基本信息，例如请求方法、URL、头信息和时间戳。在日志中包含关联 ID 或请求 ID，以将同一请求相关的日志条目联系起来。'
- en: '**Centralized logging**: Aggregate logs from all microservices into a centralized
    logging system (e.g., ELK Stack, Graylog, or Fluentd). Use structured logging
    formats such as JSON for easier parsing and analysis.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式日志记录**：将所有微服务的日志聚合到集中式日志系统中（例如，ELK Stack、Graylog 或 Fluentd）。使用结构化日志格式（如
    JSON）以便于解析和分析。'
- en: '**Performance metrics**: Collect performance metrics for each microservice,
    including response times, error rates, and resource utilization (CPU, memory).
    Use monitoring tools such as Prometheus and Grafana for metric collection and
    visualization.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能指标**：收集每个微服务的性能指标，包括响应时间、错误率和资源利用率（CPU、内存）。使用 Prometheus 和 Grafana 等监控工具进行指标收集和可视化。'
- en: '**Alerting and notifications**: Set up alerting rules based on performance
    thresholds and error rates. Integrate with alerting systems (e.g., PagerDuty,
    Slack) for timely notifications. Create dashboards to visualize the health of
    microservices and respond to issues proactively. Alerting and notifications in
    a microservices architecture are essential for detecting, responding to, and resolving
    issues in a timely manner. Effective alerting and notification practices are critical
    for maintaining the reliability and availability of microservices. A well-designed
    system ensures that the right people are informed promptly when issues arise,
    facilitating quick resolution and minimizing downtime.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报和通知**：根据性能阈值和错误率设置警报规则。与警报系统（例如，PagerDuty、Slack）集成以实现及时通知。创建仪表板以可视化微服务的健康状况并主动响应问题。在微服务架构中，警报和通知对于及时检测、响应和解决问题至关重要。有效的警报和通知实践对于维护微服务的可靠性和可用性至关重要。一个设计良好的系统确保在出现问题时，相关人员能够及时得到通知，从而促进快速解决并最小化停机时间。'
- en: '**Error tracking**: Implement error tracking solutions (e.g., Sentry, Rollbar)
    to capture and analyze application errors and exceptions. Monitor error rates
    and prioritize fixing critical issues.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误跟踪**：实现错误跟踪解决方案（例如，Sentry、Rollbar）以捕获和分析应用程序错误和异常。监控错误率并优先修复关键问题。'
- en: '**Infrastructure monitoring**: Monitor the health and performance of underlying
    infrastructure components, including servers, containers, and network resources.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施监控**：监控底层基础设施组件的健康状况和性能，包括服务器、容器和网络资源。'
- en: '**Security monitoring**: Implement security monitoring and intrusion detection
    to detect and respond to security threats and vulnerabilities.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全监控**：实现安全监控和入侵检测以检测和响应安全威胁和漏洞。'
- en: '**Tracing for performance optimization**: Use tracing data to identify bottlenecks
    and performance issues within microservices. Optimize critical paths based on
    this information.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化中的追踪**：使用追踪数据来识别微服务内部的瓶颈和性能问题。根据这些信息优化关键路径。'
- en: '**Observability tools**: Explore observability tools that combine metrics,
    logs, and traces for a holistic view of your microservices ecosystem.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性工具**：探索结合指标、日志和追踪的可观察性工具，以获得对您的微服务生态系统的全面了解。'
- en: As we have learned, these concepts help us monitor our applications better,
    identify bugs, and solve problems faster.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，这些概念帮助我们更好地监控应用程序，识别错误，并更快地解决问题。
- en: '*Figure 6**.5* presents an example of monitor and trace requests:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.5* 展示了监控和追踪请求的示例：'
- en: '![](img/B14980_06_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14980_06_05.jpg)'
- en: 'Figure 6.5: Monitor and trace requests (image on Freepik)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：监控和追踪请求（Freepik 上的图片）
- en: Monitoring and tracing requests in a microservices architecture are essential
    for gaining insight into the performance, health, and behavior of your services.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中监控和追踪请求对于深入了解您服务的性能、健康和行为至关重要。
- en: In the next section, we will learn more about containerization technologies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于容器化技术的内容。
- en: Containerization technologies
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化技术
- en: '**Containerization technologies** play a vital role in packaging and deploying
    microservices efficiently.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器化技术**在高效打包和部署微服务中发挥着至关重要的作用。'
- en: 'They also play a pivotal role in modern microservices architectures, providing
    efficient and consistent ways to package, deploy, and manage applications. Containerization
    technologies are foundational for building and deploying microservices:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也在现代微服务架构中发挥着关键作用，提供了高效且一致的方式来打包、部署和管理应用程序。容器化技术是构建和部署微服务的基础：
- en: '**Docker**: Use Docker to package microservices and their dependencies into
    containers. Docker containers are portable and consistent across different environments.
    It is also a powerful platform that simplifies the deployment and scaling of applications
    through containerization. Containers encapsulate an application and its dependencies,
    providing consistency across different environments.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：使用 Docker 将微服务和它们的依赖项打包到容器中。Docker 容器在不同环境中是可移植的和一致的。它也是一个强大的平台，通过容器化简化了应用程序的部署和扩展。容器封装了应用程序及其依赖项，在不同环境中提供一致性。'
- en: '**Kubernetes**: Deploy and manage containers at scale using Kubernetes. Kubernetes
    provides orchestration, scaling, and load balancing for microservices. Kubernetes,
    often abbreviated as K8s, is a powerful open-source container orchestration platform
    designed to automate the deployment, scaling, and management of containerized
    applications.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：使用 Kubernetes 在大规模上部署和管理容器。Kubernetes 为微服务提供编排、扩展和负载均衡。Kubernetes
    通常简称为 K8s，是一个强大的开源容器编排平台，旨在自动化容器化应用程序的部署、扩展和管理。'
- en: '**Container orchestration**: Consider other container orchestration platforms
    like Docker Swarm, Amazon ECS, or **Google Kubernetes Engine** (**GKE**) based
    on your infrastructure and cloud provider.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器编排**：根据您的基础设施和云提供商，考虑其他容器编排平台，如 Docker Swarm、Amazon ECS 或 **Google Kubernetes
    Engine**（**GKE**）。'
- en: '**Container registry**: Use container registries (e.g., Docker Hub, Amazon
    ECR, Google Container Registry) to store and distribute container images.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册库**：使用容器注册库（例如，Docker Hub、Amazon ECR、Google Container Registry）来存储和分发容器镜像。'
- en: '**Infrastructure as code** (**IaC**): Define infrastructure and container configurations
    using IaC tools such as Terraform or AWS CloudFormation to ensure reproducibility.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（**IaC**）：使用 Terraform 或 AWS CloudFormation 等IaC工具定义基础设施和容器配置，以确保可重复性。'
- en: '**Service mesh**: Implement a service mesh such as Istio or Linkerd to manage
    service-to-service communication, routing, and security within a containerized
    environment.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务网格**：在容器化环境中，通过实施服务网格（如 Istio 或 Linkerd）来管理服务间的通信、路由和安全。'
- en: '**Continuous integration/continuous deployment (CI/CD)**: Automate the build
    and deployment of containerized microservices using CI/CD pipelines. Tools such
    as Jenkins, Travis CI, and CircleCI are commonly used.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成/持续部署（CI/CD）**：使用 CI/CD 管道自动化容器化微服务的构建和部署。常用的工具有 Jenkins、Travis CI 和
    CircleCI。'
- en: '**Container security**: Ensure container security by regularly scanning container
    images for vulnerabilities, implementing security policies, and enforcing access
    controls.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器安全**：通过定期扫描容器镜像以查找漏洞、实施安全策略和执行访问控制来确保容器安全。'
- en: '**Secret management**: Use tools like Kubernetes Secrets or HashiCorp Vault
    for the secure management of sensitive information (e.g., API keys, credentials)
    used within containers.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥管理**：使用 Kubernetes Secrets 或 HashiCorp Vault 等工具来安全地管理容器内使用的敏感信息（例如 API
    密钥、凭证）。'
- en: '**Resource scaling**: Leverage Kubernetes’ autoscaling features to automatically
    adjust the number of container replicas based on resource utilization.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源扩展**：利用 Kubernetes 的自动扩展功能，根据资源利用率自动调整容器副本的数量。'
- en: '**Deployment pipeline**: Setting up a deployment pipeline for containerized
    applications involves automating the process of building, testing, and deploying
    container images. A well-structured deployment pipeline streamlines the process
    of taking code changes from development to production, ensuring consistency, reliability,
    and efficiency in deploying containerized applications. Regularly review and optimize
    the pipeline for continuous improvement.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署管道**：为容器化应用程序设置部署管道涉及自动化构建、测试和部署容器镜像的过程。一个结构良好的部署管道简化了将代码更改从开发到生产的流程，确保在部署容器化应用程序时的一致性、可靠性和效率。定期审查和优化管道以实现持续改进。'
- en: By having these technologies in mind, you will have extra power to develop more
    quickly and an application that can run on every platform. Docker remains a standard,
    while orchestration platforms such as Kubernetes provide powerful tools for managing
    containerized applications at scale. The choice of containerization technology
    should align with specific project requirements, preferences, and the overall
    microservices architecture.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑这些技术，你将拥有额外的力量来更快地开发，并且可以运行在任何平台上的应用程序。Docker 仍然是标准，而像 Kubernetes 这样的编排平台提供了强大的工具来管理大规模的容器化应用程序。容器化技术的选择应与特定的项目需求、偏好以及整体微服务架构相一致。
- en: '*Figure 6**.6* illustrates the process of dockerization:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.6* 展示了 Docker 化的过程：'
- en: '![](img/B14980_06_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14980_06_06.jpg)'
- en: 'Figure 6.6: Docker (Image by vectorjuice on Freepik)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：Docker（图片由 vectorjuice 在 Freepik 上提供）
- en: In summary, by effectively monitoring and tracing requests and adopting containerization
    technologies, you can enhance the observability, reliability, and scalability
    of your microservices-based applications. These practices are crucial for maintaining
    a healthy and responsive microservices ecosystem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过有效地监控和跟踪请求以及采用容器化技术，你可以提高基于微服务的应用程序的可观察性、可靠性和可伸缩性。这些实践对于维护一个健康和响应迅速的微服务生态系统至关重要。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned a lot about microservices and designing them.
    You have learned how to build microservices that can be run on every platform
    and that are fast, reliable, and secure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于微服务及其设计的大量知识。你学习了如何构建可以在每个平台上运行、快速、可靠和安全的微服务。
- en: Designing a microservices architecture in Node.js involves breaking down a monolithic
    application into smaller, independent services that work together to deliver functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中设计微服务架构涉及将单体应用程序分解成更小、独立的、协同工作以提供功能的服务。
- en: Designing microservices in Node.js requires careful consideration of both technical
    and architectural aspects to create a flexible, scalable, and maintainable system.
    Node.js is well-suited for building microservices due to its non-blocking I/O,
    lightweight nature, and vibrant ecosystem of libraries and frameworks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中设计微服务需要仔细考虑技术和架构方面的因素，以创建一个灵活、可扩展和可维护的系统。Node.js 由于其非阻塞 I/O、轻量级特性和充满活力的库和框架生态系统，非常适合构建微服务。
- en: In the next chapter, we are going to learn about integrating microservices in
    Node.js applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Node.js 应用程序中集成微服务。
- en: Quiz time
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验时间
- en: What are things to consider before creating your microservice?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建微服务之前需要考虑哪些事情？
- en: How does the API design process work?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 设计过程是如何工作的？
- en: What are authentication and authorization?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权是什么？
