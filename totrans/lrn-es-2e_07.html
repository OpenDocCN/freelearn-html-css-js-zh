<html><head></head><body>
        

                            
                    <h1 class="header-title">Proxies</h1>
                
            
            
                
<p class="mce-root">Proxies are used to define the custom behavior of the fundamental operations on objects. Proxies are already available in programming languages such as C#, C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy API, which lets us create proxies. In this chapter, we will look at proxies, their usage, and proxy traps. Due to the benefits of proxies, developers are using them increasingly and, therefore, it's important to learn about proxies in depth, with examples, which we will do in this chapter.</p>
<p>In this chapter, we'll cover:</p>
<ul>
<li>Creating proxies using the Proxy API</li>
<li>Understanding what proxies are and how to use them</li>
<li>Intercepting various operations on the objects using traps</li>
<li>The different kinds of available traps</li>
<li>Some use cases of proxies</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Proxies in a nutshell</h1>
                
            
            
                
<p>A proxy acts like a wrapper for an object and defines the custom behavior for the fundamental operations on the object. Some fundamental operations on the objects are property lookup, property assignment, constructor invocation, enumeration, and so on.</p>
<p>Think of it as a basic way of intercepting the operation you do with an object and its associated properties. For example, calling out a property value by writing <kbd>&lt;objectname&gt;.propertyName</kbd> should technically just echo out the property value, right?</p>
<p>What if you want to take a step back and inject your control right before the echoing part, but right after the calling part? Here's where proxies come in.</p>
<p>Once an object is wrapped using a proxy, all the operations that are supposed to be done on the object should now be done on the proxy object, so that the custom behavior can take place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Terminology for proxies</h1>
                
            
            
                
<p>Here are some important terms that are used while studying proxies:</p>
<ul>
<li><strong>Target:</strong> This is the object that is wrapped by a proxy.</li>
<li><strong>Traps:</strong> These are functions that intercept various operations on the <kbd>target</kbd> object, and define the custom behavior for those operations.</li>
<li><strong>Handler:</strong> This is an object that holds the traps. A handler is attached to a proxy object.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with the Proxy API</h1>
                
            
            
                
<p>The ES6 Proxy API provides the proxy constructor to create proxies. The proxy constructor takes two arguments, which are:</p>
<ul>
<li><strong>Target:</strong> This is the object that will be wrapped by the proxy</li>
<li><strong>Handler:</strong> This is an object that contains the traps for the <kbd>target</kbd> object</li>
</ul>
<p>A trap can be defined for every possible operation on the <kbd>target</kbd> object. If a trap is not defined, then the default action takes place on the target. Here is a code example that shows how to create a proxy, and does various operations on the <kbd>target</kbd> object. In this example, we have not defined any traps:</p>
<pre>const target = {  age: 12 }; <br/>const handler = {}; <br/>const proxy = new Proxy(target, handler); <br/>proxy.name = "Eden"; <br/>console.log(target.name); <br/>console.log(proxy.name); <br/>console.log(target.age); <br/>console.log(proxy.age);</pre>
<p>This outputs the following:</p>
<pre><strong>Eden</strong><br/><strong>Eden</strong><br/><strong>12</strong><br/><strong>12</strong></pre>
<p>Here, we can see that the age property of the <kbd>target</kbd> object can be accessed via the <kbd>proxy</kbd> object. When we added the name property to the <kbd>proxy</kbd> object, it was actually added to the <kbd>target</kbd> object.</p>
<p>As there was no trap attached to the property assignment, the <kbd>proxy.name</kbd> assignment resulted in the default behavior--that is, simply assigning the value to the property.</p>
<p>So, we can say that a proxy is just a wrapper for a <kbd>target</kbd> object, and traps can be defined to change the default behavior of operations.</p>
<p>Many developers don't keep a reference variable for the <kbd>target</kbd> object, so use of the proxy is not mandatory for accessing the object. Keep a reference for the handler only when you need to reuse it for multiple proxies. Here is how to rewrite the previous code:</p>
<pre>var proxy = new Proxy({ age: 12 }, {}); <br/>proxy.name = "Eden";</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Proxy traps</h1>
                
            
            
                
<p>There are different traps for the different operations that can be performed on an object. Some of the traps need to return values. There are some rules you need to follow when returning values. The returned values are intercepted by the proxy to filter and/or check if the returned values obey the rules. If a trap doesn't obey rules while returning a value, then the proxy throws the <kbd>TypeError</kbd> exception.</p>
<p>The value of <kbd>this</kbd> inside a trap is always a reference to the handler.</p>
<p>Let's take a look at the various kinds of traps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The get(target, property, receiver) method</h1>
                
            
            
                
<p>The get trap is executed when we retrieve a property value using the dot or bracket notation, or the <kbd>Reflect.get()</kbd> method. It takes three parameters--that is, the <kbd>target</kbd> object, the property name, and the proxy.</p>
<p>It must return a value that represents the property value. Here is a code example, which shows how to use the get trap:</p>
<pre>const proxy = new Proxy({ <br/>    age: 12 <br/>}, { <br/>get(target, property, receiver) { <br/>    if(property in target) { <br/>        return target[property]; <br/>    }<br/>    return "Property not found!"; <br/>} <br/>}); <br/>console.log(proxy.age); <br/>console.log(proxy.name);</pre>
<p>The output, as you might've figured out, is as follows:</p>
<pre><strong>12</strong><br/><strong>Property not found!</strong></pre>
<p>Instead of the output, you will get the following without proxies:</p>
<pre><strong>12</strong><br/><strong>undefined</strong></pre>
<p>Here, we can see that the get trap looks for the property in the <kbd>target</kbd> object and, if it finds it, then returns the <kbd>property</kbd> value. Otherwise, it returns a string indicating that it was not found.</p>
<p>The receiver parameter is the reference of the object whose property we intend to access. Consider this example to better understand the value of the receiver parameter:</p>
<pre>const proxy = new Proxy({<br/>    age: 13<br/>}, { <br/>get(target, property, receiver) { <br/>    if(property in target) { <br/>        return target[property]; <br/>    } else if(property == "name") {<br/>        console.log("Receiver here is ", receiver);<br/>        return "backup property value for name.";<br/>    } else { <br/>        return console.log("Property Not Found ", receiver); <br/>    } <br/>} <br/>}); <br/>let temp = proxy.name; <br/>let obj = { <br/>    age: 12, <br/>    __proto__: proxy <br/>};<br/>temp = obj.name;<br/>const justARandomVariablePassingBy = obj.age;<br/>console.log(justARandomVariablePassingBy);</pre>
<p>The output:</p>
<pre><strong>Receiver here is &lt;ProxyObject&gt; {age: 13}</strong><br/><strong>Receiver here is {age: 12}<br/>12</strong></pre>
<p>Note that <kbd>{age: 13}</kbd> here is <kbd>ProxyObject</kbd>, <kbd>{ age: 12 }</kbd> is the normal object.</p>
<p>Here <kbd>obj</kbd> inherits the <kbd>proxy</kbd> object. Therefore, when the name property was not found in the <kbd>obj</kbd> object, it was searched for in the <kbd>proxy</kbd> object. As the <kbd>proxy</kbd> object had a get trap, it provided a value.</p>
<p>So, the value of the receiver parameter when we access the name property via the <kbd>obj.name</kbd> expression is <kbd>obj</kbd>, and when we access the name property via <kbd>proxy.name</kbd> the expression is <kbd>proxy</kbd>.</p>
<p>The value of the receiver parameter is decided in the same way for all other traps also.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using get trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the get trap:</p>
<ul>
<li>The value returned for a property must be the same as the value of the <kbd>target</kbd> object property if the <kbd>target</kbd> object property is a non-writable, non-configurable data property.</li>
<li>The value returned for a property must be <kbd>undefined</kbd> if the <kbd>target</kbd> object property is a non-configurable accessor property that has <kbd>undefined</kbd> as its [[Get]] attribute.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The set(target, property, value, receiver) method</h1>
                
            
            
                
<p>The set trap is invoked when we set the value of a property using the assignment operator, or the <kbd>Reflect.set()</kbd> method. It takes four parameter-- that is, the <kbd>target</kbd> object, the property name, the new property value, and the receiver.</p>
<p>The set trap must return <kbd>true</kbd> if the assignment was successful. Otherwise, it will return <kbd>false</kbd>.</p>
<p>Here is a code example that demonstrates how to use the set trap:</p>
<pre>const proxy = new Proxy({}, { <br/>set(target, property, value, receiver) { <br/>    target[property] = value; <br/>    return true; <br/>} <br/>}); <br/>proxy.name = "Eden";<br/>console.log(proxy.name); //Output "Eden"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using set trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the set trap:</p>
<ul>
<li>If the <kbd>target</kbd> object property is a non-writable, non-configurable data property, then it will return as <kbd>false</kbd>--that is, you cannot change the property value</li>
<li>If the <kbd>target</kbd> object property is a non-configurable accessor property that has <kbd>undefined</kbd> as its [[Set]] attribute, then it will return as <kbd>false</kbd>--that is, you cannot change the property value</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The has(target, property) method</h1>
                
            
            
                
<p>The has trap is executed when we check if a property exists or not, using the <kbd>in</kbd> operator. It takes two parameters--that is, the <kbd>target</kbd> object and the property name. It must return a Boolean value that indicates whether the property exists or not.</p>
<p>Here is a code example that demonstrates how to use the has trap:</p>
<pre>const proxy = new Proxy({age: 12}, { <br/>has(target, property) { <br/>    return property in target;<br/>}<br/>}); <br/>console.log(Reflect.has(proxy, "name")); <br/>console.log(Reflect.has(proxy, "age"));</pre>
<p>The output is as follows:</p>
<pre class="mce-root"><strong>false</strong><br/><strong>true</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using has trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the has trap:</p>
<ul>
<li>You cannot return <kbd>false</kbd> if the property exists as a non-configurable and is its own property of the <kbd>target</kbd> object</li>
<li>You cannot return <kbd>false</kbd> if the property exists as an own property of the <kbd>target</kbd> object and the <kbd>target</kbd> object is not-extensible</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The isExtensible(target) method</h1>
                
            
            
                
<p>The <kbd>isExtensible</kbd> trap is executed when we check if the object is extensible or not, using the <kbd>Object.isExtensible()</kbd> method. It takes only one parameter--that is, the <kbd>target</kbd> object. It must return a Boolean value indicating whether the object is extensible or not.</p>
<p>Here is a code example that demonstrates how to use the <kbd>isExtensible</kbd> trap:</p>
<pre>const proxy = new Proxy({age: 12}, { <br/>isExtensible(target) { <br/>    return Object.isExtensible(target); <br/>} <br/>}); <br/>console.log(Reflect.isExtensible(proxy)); //Output "true"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rule for using isExtensible trap</h1>
                
            
            
                
<p>This rule shouldn't be violated when using the <kbd>isExtensible</kbd> trap:</p>
<ul>
<li>You cannot return <kbd>false</kbd> if the target is extensible. Similarly, you cannot return <kbd>true</kbd> if the target is non-extensible</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The getPrototypeOf(target) method</h1>
                
            
            
                
<p>The <kbd>getPrototypeOf</kbd> trap is executed when we retrieve the value of the internal [[prototype]] property, using either the <kbd>Object.getPrototypeOf()</kbd> method or the <kbd>__proto__</kbd> property. It takes only one parameter--that is, the <kbd>target</kbd> object.</p>
<p>It must return an object or null value. The null value indicates that the object doesn't inherit anything else and is the end of the inheritance chain.</p>
<p>Here is a code example that demonstrates how to use the <kbd>getPrototypeOf</kbd> trap:</p>
<pre>const proxy = new Proxy({<br/>    age: 12, <br/>    __proto__: {name: "Eden"}<br/>}, <br/>{ <br/>    getPrototypeOf(target) { <br/>        return Object.getPrototypeOf(target); <br/>    } <br/>}); <br/><br/>console.log(Reflect.getPrototypeOf(proxy).name); //Output "Eden"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using getPrototypeOf trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the <kbd>getPrototypeOf</kbd> trap:</p>
<ul>
<li>It must either return an object or return a null value</li>
<li>If the target is not-extensible, then this trap must return the actual prototype</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The setPrototypeOf(target, prototype) method</h1>
                
            
            
                
<p>The <kbd>setPrototypeOf</kbd> trap is executed when we set the value of the internal [[prototype]] property, using either the <kbd>Object.setPrototypeOf()</kbd> method or the <kbd>__proto__</kbd> property. It takes two parameters--that is, the <kbd>target</kbd> object and value of the property to be assigned.</p>
<p>This trap will return a Boolean, indicating whether it has successfully set the prototype or not.</p>
<p>Here is a code example that demonstrates how to use the <kbd>setPrototypeOf</kbd> trap:</p>
<pre>const proxy = new Proxy({}, { <br/>    setPrototypeOf(target, value) { <br/>        Reflect.setPrototypeOf(target, value); <br/>        return true; <br/>    } <br/>}); <br/><br/>Reflect.setPrototypeOf(proxy, {name: "Eden"}); console.log(Reflect.getPrototypeOf(proxy).name); //Output "Eden"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rule for using setPrototypeOf trap</h1>
                
            
            
                
<p>This rule shouldn't be violated when using the <kbd>setPrototypeOf</kbd> trap:</p>
<ul>
<li>You must return <kbd>false</kbd> if the target is not-extensible</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The preventExtensions(target) method</h1>
                
            
            
                
<p>The <kbd>preventExtensions</kbd> trap is executed when we prevent the addition of new properties using the <kbd>Object.preventExtensions()</kbd> method. It takes only one parameter--that is, the <kbd>target</kbd> object.</p>
<p>It must return a Boolean, indicating whether it has successfully prevented the extension of the object or not.</p>
<p>Here is a code example that demonstrates how to use the <kbd>preventExtensions</kbd> trap:</p>
<pre>const proxy = new Proxy({}, { <br/>preventExtensions(target) { <br/>    Object.preventExtensions(target); <br/>    return true; <br/>} <br/>}); <br/>Reflect.preventExtensions(proxy); <br/>proxy.a = 12; <br/>console.log(proxy.a); //Output "undefined"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rule for using preventExtensions trap</h1>
                
            
            
                
<p>This rule shouldn't be violated when using the <kbd>preventExtensions</kbd> trap:</p>
<ul>
<li>This trap can return <kbd>true</kbd> only if the target is non-extensible or it has made the target non-extensible</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The getOwnPropertyDescriptor(target, property) method</h1>
                
            
            
                
<p>The <kbd>getOwnPropertyDescriptor</kbd> trap is executed when we retrieve the descriptor of a property by using the <kbd>Object.getOwnPropertyDescriptor()</kbd> method. It takes two parameters--that is, the <kbd>target</kbd> object and the name of the property.</p>
<p>This trap must return a <kbd>descriptor</kbd> object or <kbd>undefined</kbd>. The <kbd>undefined</kbd> value is returned if the property doesn't exist.</p>
<p>Here is a code example that demonstrates how to use the <kbd>getOwnPropertyDescriptor</kbd> trap:</p>
<pre>const proxy = new Proxy({age: 12}, { <br/>getOwnPropertyDescriptor(target, property) { <br/>    return Object.getOwnPropertyDescriptor(target, property); <br/>} <br/>}); <br/><br/>const descriptor = Reflect.getOwnPropertyDescriptor(proxy, "age"); console.log("Enumerable: " + descriptor.enumerable); <br/>console.log("Writable: " + descriptor.writable); <br/>console.log("Configurable: " + descriptor.configurable); <br/>console.log("Value: " + descriptor.value);</pre>
<p>The output is as follows:</p>
<pre><strong>Enumerable: true</strong><br/><strong>Writable: true</strong><br/><strong>Configurable: true</strong><br/><strong>Value: 12</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using getOwnPropertyDescriptor trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the <kbd>getOwnPropertyDescriptor</kbd> trap:</p>
<ul>
<li>This trap must either return an object or return an <kbd>undefined</kbd> property</li>
<li>You cannot return the <kbd>undefined</kbd> value if the property exists as a non-configurable own property of the <kbd>target</kbd> object</li>
<li>You cannot return the <kbd>undefined</kbd> value if the property exists as an own property of the <kbd>target</kbd> object and the <kbd>target</kbd> object is not-extensible</li>
<li>You will have to return <kbd>undefined</kbd> if the property does not exist as an own property of the <kbd>target</kbd> object and the <kbd>target</kbd> object is not-extensible</li>
<li>You cannot make the configurable property of the returned descriptor object <kbd>false</kbd> if the property exists as an own property of the <kbd>target</kbd> object, or if it exists as a configurable own property of the <kbd>target</kbd> object</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The defineProperty(target, property, descriptor) method</h1>
                
            
            
                
<p>The <kbd>defineProperty</kbd> trap is executed when we define a property using the <kbd>Object.defineProperty()</kbd> method. It takes three parameters--that is, the <kbd>target</kbd> object, the property name, and the <kbd>descriptor</kbd> object.</p>
<p>This trap should return a Boolean indicating whether it has successfully defined the property or not.</p>
<p>Here is a code example that demonstrates how to use the <kbd>defineProperty</kbd> trap:</p>
<pre>const proxy = new Proxy({}, { <br/>defineProperty(target, property, descriptor) { <br/>    Object.defineProperty(target, property, descriptor); <br/>    return true; <br/>} <br/>}); <br/>Reflect.defineProperty(proxy, "name", {value: "Eden"}); <br/>console.log(proxy.name); //Output "Eden"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rule for using defineProperty</h1>
                
            
            
                
<p>This rule shouldn't be violated when using the <kbd>defineProperty</kbd> trap:</p>
<ul>
<li>It must return <kbd>false</kbd> if the <kbd>target</kbd> object is not-extensible, and the property doesn't yet exist</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The deleteProperty(target, property) method</h1>
                
            
            
                
<p>The <kbd>deleteProperty</kbd> trap is executed when we delete a property using either the delete operator or the <kbd>Reflect.deleteProperty()</kbd> method. It takes two parameters--that is, the <kbd>target</kbd> object and the property name.</p>
<p>This trap must return a Boolean, indicating whether the property was deleted successfully or not. Here is a code example that demonstrates how to use the <kbd>deleteProperty</kbd> trap:</p>
<pre>const proxy = new Proxy({age: 12}, { <br/>deleteProperty(target, property) { <br/>    return delete target[property]; <br/>} <br/>}); <br/>Reflect.deleteProperty(proxy, "age"); <br/>console.log(proxy.age); //Output "undefined"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rule for deleteProperty trap</h1>
                
            
            
                
<p>This rule shouldn't be violated when using the <kbd>deleteProperty</kbd> trap:</p>
<ul>
<li>This trap must return <kbd>false</kbd> if the property exists as a non-configurable own property of the <kbd>target</kbd> object</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The ownKeys(target) method</h1>
                
            
            
                
<p>The <kbd>ownKeys</kbd> trap is executed when we retrieve the own property keys using the <kbd>Reflect.ownKeys()</kbd>, <kbd>Object.getOwnPropertyNames()</kbd>, <kbd>Object. getOwnPropertySymbols()</kbd> and the <kbd>Object.keys()</kbd> methods. It takes only one parameter--that is, the <kbd>target</kbd> object.</p>
<p>The <kbd>Reflect.ownKeys()</kbd> method is similar to the <kbd>Object.getOwnPropertyNames()</kbd> method--that is, they both return the enumerable and non-enumerable property keys of an object.</p>
<p>They also both ignore the inherited properties. The only difference is that the <kbd>Reflect. ownKeys()</kbd> method returns both the symbol and string keys, whereas the <kbd>Object. getOwnPropertyNames()</kbd> method returns only the string keys.</p>
<p>The <kbd>Object.getOwnPropertySymbols()</kbd> method returns the enumerable and non-enumerable properties whose keys are symbols. It ignores the inherited properties.</p>
<p>The <kbd>Object.keys()</kbd> method is similar to the <kbd>Object.getOwnPropertyNames()</kbd> method, but the only difference is that the <kbd>Object.keys()</kbd> method returns the enumerable properties only.</p>
<p>The <kbd>ownKeys</kbd> trap must return an array, representing the own property keys.</p>
<p>Here is a code example which demonstrates how to use the <kbd>ownKeys</kbd> trap:</p>
<pre>const s = Symbol(); <br/>const object = {age: 12, __proto__: {name: "Eden"}, [s]: "Symbol"}; Object.defineProperty(object, "profession", <br/>{ <br/>    enumerable: false, <br/>    configurable: false, <br/>    writable: false, <br/>    value: "Developer" <br/>}) <br/><br/>const proxy = new Proxy(object, { <br/>    ownKeys(target) { <br/>        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)); <br/>} <br/>}); <br/><br/>console.log(Reflect.ownKeys(proxy)); <br/>console.log(Object.getOwnPropertyNames(proxy)); <br/>console.log(Object.keys(proxy)); <br/>console.log(Object.getOwnPropertySymbols(proxy));</pre>
<p>The output is as follows:</p>
<pre><strong>["age", "profession", Symbol()]</strong><br/><strong>["age", "profession"]</strong><br/><strong>["age"]</strong><br/><strong>[Symbol()]</strong></pre>
<p>Here, we can see that the values of the array returned by the <kbd>ownKeys</kbd> trap are filtered by the proxy, based on what the caller expected. For example, the <kbd>Object.getOwnPropertySymbols()</kbd> caller expected an array of symbols. Therefore, the proxy removed the strings from the returned array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rules for using ownKeys trap</h1>
                
            
            
                
<p>These rules shouldn't be violated when using the <kbd>ownKeys</kbd> trap:</p>
<ul>
<li>The elements of the returned array must either be a string or symbol</li>
<li>The returned array must contain the keys of all the non-configurable own properties of the <kbd>target</kbd> object</li>
<li>If the <kbd>target</kbd> object is not-extensible, then the returned array must contain all the keys of the own properties and of the <kbd>target</kbd> object, and no other values</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The apply(target, thisValue, arguments) method</h1>
                
            
            
                
<p>If the target is a function, then calling the proxy will execute the <kbd>apply</kbd> trap. The <kbd>apply</kbd> trap is also executed for the function's <kbd>apply()</kbd> and <kbd>call()</kbd> methods, and the <kbd>Reflect.apply()</kbd> method.</p>
<p>The apply trap takes three parameters. The first parameter is the <kbd>target</kbd> object and the third parameter is an array, representing the arguments of the function call.</p>
<p>The second parameter is the same as the value of <kbd>this</kbd> of the <kbd>target</kbd> function--that is, it's the same as the value of <kbd>this</kbd> of the target function if the target function would have been invoked without the proxy.</p>
<p>Here is a code example that demonstrates how to use the apply trap:</p>
<pre>const proxy = new Proxy(function(){}, { <br/>    apply(target, thisValue, arguments) { <br/>        console.log(thisValue.name); <br/>        return arguments[0] + arguments[1] + arguments[2]; <br/>    } <br/>});<br/><br/>const obj = { name: "Eden", f: proxy } <br/>const sum = obj.f(1,2,3); <br/>console.log(sum);</pre>
<p>The output is as follows:</p>
<pre><strong>Eden</strong><br/><strong>6</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The construct(target, arguments) method</h1>
                
            
            
                
<p>If the target is a function, then calling the target as a constructor using the <kbd>new</kbd> operator or the <kbd>Reflect.construct()</kbd> method will execute the construct trap.</p>
<p>The construct trap takes two parameters. The first parameter is the <kbd>target</kbd> object and the second parameter is an array, representing the arguments of the constructor call.</p>
<p>The <kbd>construct</kbd> trap must return an object, representing the newly created instance. Here is a code example that demonstrates how to use the <kbd>construct</kbd> trap:</p>
<pre>const proxy = new Proxy(function(){}, { <br/>    construct(target, arguments) { <br/>        return {name: arguments[0]}; <br/>    } <br/>}); <br/><br/>const obj = new proxy("Eden"); <br/>console.log(obj.name); //Output "Eden"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Proxy.revocable(target, handler) method</h1>
                
            
            
                
<p>A revocable proxy is a proxy that can be revoked (that is, switched off).</p>
<p>To create revocable proxies we have to use the <kbd>Proxy.revocable()</kbd> method. The <kbd>Proxy.revocable()</kbd> method is not a constructor. This method also takes the same arguments as the <kbd>Proxy</kbd> constructor, but, instead of returning a revocable proxy instance directly, it returns an object with two properties, which are the following: </p>
<ul>
<li><kbd>proxy</kbd>: This is the revocable <kbd>proxy</kbd> object</li>
<li><kbd>revoke</kbd>: When this function is called, it revokes the proxy</li>
</ul>
<p>Once a revocable <kbd>proxy</kbd> is revoked, any attempts to use it will throw a <kbd>TypeError</kbd> exception. Here is an example to demonstrate how to create a revocable <kbd>proxy</kbd> and <kbd>revoke</kbd> it:</p>
<pre>const revocableProxy = Proxy.revocable({ age: 12 }, { <br/>get(target, property, receiver) { <br/>    if(property in target) {<br/>         return target[property]; <br/>    }<br/>    return "Not Found";  <br/>} <br/>}); <br/>console.log(revocableProxy.proxy.age); <br/>revocableProxy.revoke(); <br/>console.log(revocableProxy.proxy.name);</pre>
<p>The output is as follows:</p>
<pre><strong>12</strong><br/><strong>TypeError: proxy is revoked</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case of revocable proxy</h1>
                
            
            
                
<p>You can use the revocable proxies instead of the regular proxies. You can use it when you pass a proxy to a function that runs asynchronously or in parallel, so that you can revoke it when you don't want the function to be able to use that proxy anymore.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The uses of proxies</h1>
                
            
            
                
<p>There are several uses of proxies. Here are some main use cases:</p>
<ul>
<li>Creating virtualized objects, such as remote objects, persistent objects, and more</li>
<li>The lazy creation of objects</li>
<li>Transparent logging, tracing, profiling, and more</li>
<li>Embedded domain specific languages</li>
<li>Generically interposing abstractions in order to enforce access control</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned what proxies are and how to use them. We saw the various traps available with examples. We also saw different rules that need to be followed by different traps. This chapter explained everything about the Proxy API in JavaScript in depth. Finally, we saw some use cases of proxies. In the next chapter, we will walk through object-oriented programming and the ES6 classes.</p>


            

            
        
    </body></html>