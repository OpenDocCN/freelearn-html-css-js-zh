<html><head></head><body>
		<div id="_idContainer056">
			<h1 id="_idParaDest-172" class="chapter-number"><a id="_idTextAnchor172"/>9</h1>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor173"/>Designing Functions – Recursion</h1>
			<p>In <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>, we considered yet more ways to create new functions out of combining previous existing ones. Here, we will get into a different theme: how to design and write functions in a typically functional way, by applying <span class="No-Break">recursive techniques.</span></p>
			<p>We will be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding what recursion is and how to think in order to produce <span class="No-Break">recursive solutions</span></li>
				<li>Applying recursion to some well-known problems, such as making a change or the Tower <span class="No-Break">of Hanoi</span></li>
				<li>Using recursion instead of iteration to re-implement some higher-order functions from <span class="No-Break">earlier chapters</span></li>
				<li>Writing search and backtrack algorithms <span class="No-Break">with ease</span></li>
				<li>Traversing data structures, such as trees, to work with filesystem directories or with the <span class="No-Break">browser DOM</span></li>
				<li>Understanding mutual recursion and applying it to problems such as correctly evaluating <span class="No-Break">arithmetical expressions</span></li>
				<li>Getting around some limitations caused by browser JavaScript <span class="No-Break">engine considerations</span></li>
			</ul>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor174"/>Using recursion</h1>
			<p>Recursion is a key<a id="_idIndexMarker673"/> technique in FP, to the degree that some languages do not provide for iterations or loops, and work exclusively with recursion (Haskell, which we already mentioned, is a prime example of that). A fundamental fact of computer science is that whatever you can do with recursion, you can do with iteration (loops), and vice versa. The key concept is that there are many algorithms whose definition is far easier if you work recursively. On the other hand, recursion is not always taught, and many programmers, even after knowing about it, prefer not to use it. Therefore, in this section, we shall see several examples of recursive thinking so that you can adapt it for<a id="_idIndexMarker674"/> your <span class="No-Break">functional coding.</span></p>
			<p class="callout-heading">A typical, oft-quoted, and very old computer joke!</p>
			<p class="callout">Dictionary definition: <strong class="bold">recursion</strong><em class="italic">: (n) </em><span class="No-Break"><em class="italic">see </em></span><span class="No-Break"><strong class="bold">recursion</strong></span></p>
			<p>But what is recursion? There are many ways to define what recursion is, but the simplest one I’ve seen runs along the lines of <em class="italic">a function calling itself again and again until it doesn’t</em>. A more complex case is mutual recursion, the simplest example of which is when we have two functions, <strong class="source-inline">A()</strong> and <strong class="source-inline">B()</strong>, each of which calls the other, over and over, until they <span class="No-Break">are done.</span></p>
			<p>Recursion is a natural technique for several kinds of problems, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Mathematical definitions, such as the Fibonacci sequence or the factorial of <span class="No-Break">a number</span></li>
				<li>Data-structure-related<a id="_idIndexMarker675"/> algorithms with recursively defined structures, such as lists (a list is either empty or consists of a head node followed by a list of nodes) or trees (a tree might be defined as a special node, called the root, linked to zero or <span class="No-Break">more trees)</span></li>
				<li>Syntax analysis for compilers based on grammar rules, which themselves depend on other rules, which also depend on other rules, and <span class="No-Break">so on</span></li>
			</ul>
			<p>And many more! It even appears in art and humor, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_9.1_B19301.jpg" alt="Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers, “Did you mean: recursion”"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers, “Did you mean: recursion”</p>
			<p>Apart from some easy base cases in which no further computation is required, a recursive function must call itself one or more times to perform part of the required calculations. This concept may not be very clear at this point, so in the following sections, we will<a id="_idIndexMarker676"/> see how we can think recursively and solve several common problems by applying <span class="No-Break">this technique.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor175"/>Thinking recursively</h2>
			<p>The key to solving problems<a id="_idIndexMarker677"/> recursively is assuming that you already have a function that does whatever you need and just calling it. (Doesn’t this sound weird? Actually, it is quite appropriate: if you want to solve a problem with recursion, you must first have solved it before...) On the other hand, if you attempt to work out in your head how the recursive calls work and try to follow the flow, you’ll probably just get lost. So, what you need to do is <span class="No-Break">the following:</span></p>
			<ol>
				<li>Assume you already have an appropriate function to solve <span class="No-Break">your problem.</span></li>
				<li>See how the big problem can be solved by solving one (or more) <span class="No-Break">smaller problems.</span></li>
				<li>Solve those problems by using the imagined function from <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
				<li>Decide what your base cases are. Make sure they are simple enough that they are solved directly, without requiring <span class="No-Break">more calls.</span></li>
			</ol>
			<p>With these points in<a id="_idIndexMarker678"/> mind, you can solve problems by recursion because you’ll have the basic structure for your <span class="No-Break">recursive solution.</span></p>
			<p>There are three usual methods for solving problems<a id="_idIndexMarker679"/> by <span class="No-Break">applying recursion:</span></p>
			<ul>
				<li><strong class="bold">Decrease and conquer</strong> is the <a id="_idIndexMarker680"/>simplest case, in which solving a problem directly depends on solving a single, simpler case <span class="No-Break">of itself.</span></li>
				<li><strong class="bold">Divide and conquer</strong> is a more<a id="_idIndexMarker681"/> general approach. The idea is to try to divide your problem into two or more smaller versions, solve them recursively, and use these solutions to solve the original problem. The only difference between this technique and <em class="italic">decrease and conquer</em> is that you have to solve two or more other problems instead of <span class="No-Break">only one.</span></li>
				<li><strong class="bold">Dynamic programming</strong> can be seen as a variant of <em class="italic">divide and conquer</em>: basically, you solve a complex <a id="_idIndexMarker682"/>problem by breaking it into a set of somewhat simpler versions of the same problem and solving each in order; however, a key idea in this strategy is to store previously found solutions, so that whenever you find yourself needing the solution to a simpler case again, you won’t directly apply recursion but, instead, use the stored result and avoid unnecessary <span class="No-Break">repeated calculations.</span></li>
			</ul>
			<p>In this section, we shall look at a few problems and solve them by thinking recursively. Of course, we shall see more applications of recursion in the rest of the chapter; here, we’ll focus on the key decisions and questions needed to create such <span class="No-Break">an algorithm.</span></p>
			<h3>Decrease and conquer – searching</h3>
			<p>The most usual case of recursion<a id="_idIndexMarker683"/> involves just a single, simple case. We have already seen some examples of this, such as the ubiquitous factorial calculation: to calculate the factorial of <em class="italic">n</em>, you previously needed to calculate the factorial of <em class="italic">n</em>-1. (See <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>.) Let’s turn now to a <span class="No-Break">non-mathematical example.</span></p>
			<p>You would also use this decrease-and-conquer strategy to search for an element in an array. If the array is empty, then obviously the searched-for value isn’t there; otherwise, the result is in the array if, and only if, it’s the array’s first element or if it’s in the rest of the array. The following <a id="_idIndexMarker684"/>code does <span class="No-Break">just that:</span></p>
			<pre class="source-code">
// search.ts
const search = &lt;A&gt;(arr: A[], key: A): boolean =&gt; {
  if (arr.length === 0) {
    return false;
  } else if (arr[0] === key) {
    return true;
  } else {
    return search(arr.slice(1), key);
  }
};</pre>
			<p>This implementation directly mirrors our explanation, and verifying its correctness <span class="No-Break">is easy.</span></p>
			<p>By the way, just as a precaution, let’s look at two further implementations of the same concept. You can shorten the search function a bit—is it <span class="No-Break">still clear?</span></p>
			<p>We are using a ternary operator to detect whether the array is empty, and a Boolean <strong class="source-inline">||</strong> operator to return <strong class="source-inline">true</strong> if the first element is the sought one or else return the result of the <span class="No-Break">recursive search:</span></p>
			<pre class="source-code">
// continued...
const search2 = &lt;A&gt;(arr: A[], key: A): boolean =&gt;
  arr.length === 0
    ? false
    : arr[0] === key || search2(arr.slice(1), key);</pre>
			<p>Sparseness can go even further! Using <strong class="source-inline">&amp;&amp;</strong> as a shortcut is a <span class="No-Break">common idiom:</span></p>
			<pre class="source-code">
// continued...
const search3 = &lt;A&gt;(arr: A[], key: A): boolean =&gt;
  !!arr.length &amp;&amp;
  (arr[0] === key || search3(arr.slice(1), key));</pre>
			<p>I’m not really suggesting that you code the function in this way—instead, consider it a warning against the tendency that some FP developers have to try to go for the tightest, shortest possible solution <a id="_idIndexMarker685"/>and never <span class="No-Break">mind clarity!</span></p>
			<h3>Decrease and conquer – doing powers</h3>
			<p>Another classic example has to <a id="_idIndexMarker686"/>do with efficiently calculating powers of numbers. If you want to calculate, say, 2 to the 13th power (2<span class="superscript">13</span>), then you can do this with 12 multiplications; however, you can do much better by writing 2<span class="superscript">13</span> as <span class="No-Break">the following:</span></p>
			<p>= 2 <span class="No-Break">times 2</span><span class="No-Break"><span class="superscript">12</span></span></p>
			<p>= 2 <span class="No-Break">times 4</span><span class="No-Break"><span class="superscript">6</span></span></p>
			<p>= 2 <span class="No-Break">times 16</span><span class="No-Break"><span class="superscript">3</span></span></p>
			<p>= 2 times 16 <span class="No-Break">times 16</span><span class="No-Break"><span class="superscript">2</span></span></p>
			<p>= 2 times 16 <span class="No-Break">times 256</span><span class="No-Break"><span class="superscript">1</span></span></p>
			<p>= <span class="No-Break">8192</span></p>
			<p>This reduction in the total number of multiplications may not look very impressive, but in terms of algorithmic complexity, it allows us to bring down the order of the calculations from O(<em class="italic">n</em>) to O(<em class="italic">log n</em>). In some cryptographic-related methods, which have to raise numbers to really high exponents, this makes a significant difference. We can implement this recursive algorithm in a few lines of code, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// power.ts
const powerN = (base: number, power: number): number =&gt; {
  if (power === 0) {
    return 1;
  } else if (power % 2) {
    // odd power?
    return base * powerN(base, power - 1);
  } else {
    // even power?
    return powerN(base * base, power / 2);
  }
};</pre>
			<p class="callout-heading">Extra speed</p>
			<p class="callout">When implemented for production, bit operations are used instead of modulus and divisions. Checking whether a number is odd can be written as <strong class="source-inline">power &amp; 1</strong>, and division by 2 is achieved with <strong class="source-inline">power &gt;&gt; 1</strong>. These alternative calculations are way faster than the <span class="No-Break">replaced operations.</span></p>
			<p>Calculating a power<a id="_idIndexMarker687"/> is simple when the base case is reached (raising something to the zeroth power) or based on a previously calculated power for a smaller exponent. (If you wanted to, you could add another base case for raising something to the power of one.) These observations show that we are seeing a textbook case for the decrease and conquer <span class="No-Break">recursive strategy.</span></p>
			<p>Finally, some of our higher-order functions, such as <strong class="source-inline">map()</strong>, <strong class="source-inline">reduce()</strong>, and <strong class="source-inline">filter()</strong>, also apply this technique; we’ll look into this later on in <span class="No-Break">this chapter.</span></p>
			<h3>Divide and conquer – the Tower of Hanoi</h3>
			<p>With the divide-and-conquer strategy, solving a problem requires two or more recursive solutions. For starters, let’s <a id="_idIndexMarker688"/>consider a classic puzzle invented by a French mathematician, Édouard Lucas, in the 19th century. The puzzle involves a temple in India, with 3 posts, the first of them with 64 golden disks of decreasing<a id="_idIndexMarker689"/> diameter. The priests have to move the disks from the first post to the last one following two rules: only one disk can be moved at a time, and a larger disk can never be placed on top of a smaller disk. According to the legend, when the 64 disks are moved, the world will end. This puzzle is usually marketed under the <em class="italic">Tower of Hanoi</em> name (yes, they changed countries!) with fewer than 10 disks. See <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_9.2_B19301.jpg" alt="Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution</p>
			<p class="callout-heading">A long, long time…</p>
			<p class="callout">The solution for <em class="italic">n</em> disks requires 2<span class="superscript">n</span>-1 movements. The original puzzle, requiring 2<span class="superscript">64</span>-1 movements, at one movement per second, would take more than 584 billion years to finish – a very long time, considering that the universe’s age is evaluated to only be 13.8 <span class="No-Break">billion years!</span></p>
			<p>Suppose we already <a id="_idIndexMarker690"/>have a function that solves the problem of moving any number of disks from a source post to a destination post using the remaining post as an extra aid. Think about solving the general problem if you already had a function to solve that problem: <strong class="source-inline">hanoi(disks, from, to, extra)</strong>. If you wanted to move several disks from one post to another, then <a id="_idIndexMarker691"/>you could solve it using this (still unwritten!) function by carrying out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Moving all of the disks but the last one to the <span class="No-Break">extra post.</span></li>
				<li>Moving the last disk to the <span class="No-Break">destination post.</span></li>
				<li>Moving all the disks from the extra post (where you had placed them earlier) to <span class="No-Break">the destination.</span></li>
			</ol>
			<p>But what about our base cases? We could decide that to move a single disk, you don’t need the function; you just go ahead and move the disk. When coded, it becomes <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// hanoi.ts
const hanoi = (
  disks: number,
  from: Post,
  to: Post,
  extra: Post
) =&gt; {
  if (disks === 1) {
    console.log(
      `Move disk 1 from post ${from} to post ${to}`
    );
  } else {
    hanoi(disks - 1, from, extra, to);
    console.log(
      `Move disk ${disks} from post ${from} to post ${to}`
    );
    hanoi(disks - 1, extra, to, from);
  }
};</pre>
			<p>Using the <strong class="source-inline">Post</strong> type<a id="_idIndexMarker692"/> is possibly not needed, but <a id="_idIndexMarker693"/>good practice anyway. We can quickly verify that this <span class="No-Break">code works:</span></p>
			<pre class="source-code">
<strong class="bold">hanoi (4, "A", "B", "C")</strong>;
// move all disks from A to B
Move disk 1 from post A to post C
Move disk 2 from post A to post B
Move disk 1 from post C to post B
Move disk 3 from post A to post C
Move disk 1 from post B to post A
Move disk 2 from post B to post C
Move disk 1 from post A to post C
Move disk 4 from post A to post B
Move disk 1 from post C to post B
Move disk 2 from post C to post A
Move disk 1 from post B to post A
Move disk 3 from post C to post B
Move disk 1 from post A to post C
Move disk 2 from post A to post B
Move disk 1 from post C to post B</pre>
			<p>There’s only a small detail to consider, which can simplify the function further. In this code, our base case (the one that<a id="_idIndexMarker694"/> needs no further recursion) is when <strong class="source-inline">disks</strong> equals one. You could also solve <a id="_idIndexMarker695"/>this differently by letting the disks go down to zero and simply not doing anything—after all, moving zero disks from one post to another is achieved by doing nothing at all! The revised code would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const hanoi2 = (
  disks: number,
  from: Post,
  to: Post,
  extra: Post
) =&gt; {
  if (disks &gt; 0) {
    hanoi(disks - 1, from, extra, to);
    console.log(
      `Move disk ${disks} from post ${from} to post ${to}`
    );
    hanoi(disks - 1, extra, to, from);
  }
};</pre>
			<p>Instead of checking whether there are any disks to move before doing the recursive call, we can just skip the check and have the function test, at the next level, whether there’s something to <span class="No-Break">be done.</span></p>
			<p class="callout-heading">Hanoi by hand</p>
			<p class="callout">If you are doing the puzzle by hand, there’s a simple solution for that: on odd turns, always move the smaller disk to the next post (if the total number of disks is odd) or to the previous post (if the total number of disks is even). On even turns, make the only possible move that doesn’t involve the <span class="No-Break">smaller disk.</span></p>
			<p>So, the principle for recursive algorithm design works: assume you already have your desired function and use it to <span class="No-Break">build itself!</span></p>
			<h3>Divide and conquer – sorting</h3>
			<p>We can see another example of the divide-and-conquer strategy with sorting. A way to sort arrays, called<a id="_idIndexMarker696"/> Quicksort, is based upon the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">If your array has 0 or 1 element(s), do nothing; it’s already sorted (this is the <span class="No-Break">base case).</span></li>
				<li>Pick an element of the array (called the pivot) and split the rest of the array into two subarrays: the elements smaller than your chosen element and the elements greater than or equal to your <span class="No-Break">chosen element.</span></li>
				<li>Recursively sort <span class="No-Break">each subarray.</span></li>
				<li>To produce the sorted version of the original array, concatenate both sorted results, with the pivot <span class="No-Break">in between.</span></li>
			</ol>
			<p>Let’s see a simple version of this (there are some better-optimized implementations, but we are interested in the recursive logic now). Usually, picking a random element of the array is suggested to avoid some bad performance border cases, but for our example, let’s just take the <span class="No-Break">first one:</span></p>
			<pre class="source-code">
// quicksort.ts
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
    const smaller = arr.slice(1).filter((x) =&gt; x &lt; pivot);
    const greaterEqual = arr
      .slice(1)
      .filter((x) =&gt; x &gt;= pivot);
    return [
      ...quicksort(smaller),
      pivot,
      ...quicksort(greaterEqual),
    ];
  }
};
console.log(quicksort([22, 9, 60, 12, 4, 56]));
// <strong class="bold">[4, 9, 12, 22, 56, 60]</strong></pre>
			<p>We can see how this <a id="_idIndexMarker697"/>works in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em>: the pivot for each array and subarray is underlined. Splitting is shown with dotted arrows and is joined with <span class="No-Break">full lines:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_9.3_B19301.jpg" alt="Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer strategy to reduce the original problem to smaller ones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer strategy to reduce the original problem to smaller ones</p>
			<p class="callout-heading">Easy-to-get bug!</p>
			<p class="callout">Writing Quicksort correctly is not trivial; see <em class="italic">Question 9.8</em> at the end of this chapter for an alternative version that is <em class="italic">almost </em>right, but not <span class="No-Break">totally correct!</span></p>
			<p>We have already seen the basic strategies to reduce a problem to simpler versions of itself. Let’s now look at an important optimization, a key for <span class="No-Break">many algorithms.</span></p>
			<h3>Dynamic programming – making change</h3>
			<p>The third general strategy, <em class="italic">dynamic programming</em>, assumes that you will have to solve many smaller problems, but instead of using recursion every time, it depends on you having stored the previously found <a id="_idIndexMarker698"/>solutions – <em class="italic">memoization</em>, in other words! In <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, and later, in a better <a id="_idIndexMarker699"/>fashion, in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we already saw how to optimize the calculations of the usual Fibonacci series, avoiding unnecessary repeated calls. Let’s now consider <span class="No-Break">another problem.</span></p>
			<p>Given a certain number of dollars and the list of existing bill values, calculate how many different ways we can pay that amount of dollars with different combinations of bills. It is assumed that you have access to an unlimited number of each bill. How can we go about solving this? Let’s start by considering the base cases where no further computation is needed. They are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Paying negative values is not possible, so in such cases, we should <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">0</strong></span></li>
				<li>Paying zero dollars is only possible in a single way (by giving no bills), so in this case, we should <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">1</strong></span></li>
				<li>Paying any positive amount of dollars isn’t possible if no bills are provided, so in this case, also <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">0</strong></span></li>
			</ul>
			<p>Finally, we can answer the question: in how many ways can we pay <em class="italic">N</em> dollars with a given set of bills? We can consider two cases: we do not use the larger bill at all and pay the amount using only smaller denomination bills, or we can take one bill of the larger amount and reconsider the question. (Let’s forget the avoidance of repeated calculations <span class="No-Break">for now.)</span></p>
			<p>In the first case, we should invoke our supposedly existing function with the same value of <em class="italic">N</em> but prune the largest bill denomination from the list of <span class="No-Break">available bills.</span></p>
			<p>In the second case, we should invoke our function with <em class="italic">N</em> minus the largest bill denomination, keeping the list of bills the same, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// makeChange.ts
const makeChange = (n: number, bills: number[]): number =&gt; {
  if (n &lt; 0) {
    return 0; // no way of paying negative amounts
  } else if (n == 0) {
    return 1; // one single way of paying $0: with no bills
  } else if (bills.length == 0) {
    // here, n&gt;0
    return 0; // no bills? no way of paying
  } else {
    return (
      makeChange(n, bills.slice(1)) +
      makeChange(n - bills[0], bills)
    );
  }
};
console.log(makeChange(64, [100, 50, 20, 10, 5, 2, 1]));
// 969 ways of paying $64</pre>
			<p>Now, let’s do some <a id="_idIndexMarker700"/>optimization. This algorithm often needs to recalculate the same values over and over. (To verify this, add <strong class="source-inline">console.log(n, bills.length)</strong> as the first line in <strong class="source-inline">makeChange()</strong>—but be ready for plenty of output!) However, we already have a solution for this: memoization! Since we are applying this technique to a binary function, we’ll need a version of the memoization algorithm that deals with more than one parameter. We saw that in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Producing Functions</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;string, ReturnType&lt;T&gt;&gt;;
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};
const makeChange = <strong class="bold">memoize4(</strong>(n, bills) =&gt; {
// ...same as above
}<strong class="bold">);</strong></pre>
			<p>The memoized version of <strong class="source-inline">makeChange()</strong> is far more efficient, and you can verify it with logging. While it is certainly possible to deal with the repetitions by yourself (for example, by keeping<a id="_idIndexMarker701"/> an array of already computed values), the memoization solution is, in my opinion, better because it composes two functions to produce a better solution for the <span class="No-Break">given problem.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor176"/>Higher-order functions revisited</h2>
			<p>Classic FP techniques do not use<a id="_idIndexMarker702"/> iteration at all but work exclusively with recursion as the only way to do some looping. Let’s revisit some of the functions that we have already seen in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, such as <strong class="source-inline">map()</strong>, <strong class="source-inline">reduce()</strong>, <strong class="source-inline">find()</strong>, and <strong class="source-inline">filter()</strong>, to see how we can make do with <span class="No-Break">just recursion.</span></p>
			<p>We are not planning to exchange the basic JavaScript functions for ours, though: it’s likely that performance will be worse for our recursive polyfills, and we won’t derive any advantages just from having the functions use recursion. Instead, we want to study how iterations are performed in a recursive way so that our efforts are more pedagogical than <span class="No-Break">practical, OK?</span></p>
			<h3>Mapping and filtering</h3>
			<p>Mapping and filtering are quite similar insofar as both imply going through all the elements in an array and <a id="_idIndexMarker703"/>applying a callback to each to produce output. Let’s first work out the<a id="_idIndexMarker704"/> mapping logic, which will have several points to solve, and then we should see that filtering has become almost trivially easy, requiring just <span class="No-Break">small changes.</span></p>
			<p>For mapping, given how we are developing recursive functions, we need a base case. Fortunately, that’s easy: mapping an empty array produces a new empty array. Mapping a non-empty array can be done by first applying the mapping function to the first element of the array, then recursively mapping the rest of the array, and finally, producing a single array accumulating <span class="No-Break">both results.</span></p>
			<p>Based on this idea, we can work out a simple initial version: let’s call it <strong class="source-inline">mapR()</strong>, just to remember that we are dealing with our own, recursive version of <strong class="source-inline">map()</strong>; however, be careful – our polyfill has some bugs! We’ll deal with them one at a time. Here’s our first attempt at writing our own <a id="_idIndexMarker705"/><span class="No-Break">mapping code:</span></p>
			<pre class="source-code">
// map.ts
const mapR = &lt;A, B&gt;(arr: A[], cb: (x: A) =&gt; B): B[] =&gt;
  arr.length === 0
    ? []
    : [cb(arr[0])].concat(mapR(arr.slice(1), cb));</pre>
			<p>Let’s test <span class="No-Break">it</span><span class="No-Break"><a id="_idIndexMarker706"/></span><span class="No-Break"> out:</span></p>
			<pre class="source-code">
const aaa = [1, 2, 4, 5, 7];
const timesTen = (x: number): number =&gt; x * 10;
console.log(aaa.map(timesTen));   // [10, 20, 40, 50, 70]
console.log(mapR(aaa, timesTen)); // [10, 20, 40, 50, 70]</pre>
			<p>Great! Our <strong class="source-inline">mapR()</strong> function seemingly produces the same results as <strong class="source-inline">map()</strong>. However, shouldn’t our callback function receive a couple more parameters, specifically the index at the array and the original array itself? (Check out the definition for the callback function for <strong class="source-inline">map()</strong> <span class="No-Break">at </span><a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><span class="No-Break">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map</span></a><span class="No-Break">.)</span></p>
			<p>Our implementation isn’t quite ready yet. Let’s first see how it fails by using a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const timesTenPlusI = (v: number, i: number) =&gt; 10 * v + i;
console.log(aaa.map(timesTenPlusI)); // [10, 21, 42, 53,
  74]
console.log(mapR(aaa, timesTenPlusI));</pre>
			<p>If you were working with JavaScript, the last call would produce <strong class="source-inline">[NaN, NaN, NaN, NaN, NaN]</strong> – TypeScript detects the error because the type of <strong class="source-inline">timesTenPlusI()</strong> <span class="No-Break">is wrong:</span></p>
			<pre class="console">
Argument of type '(v: number, i: number) =&gt; number' is not assignable to parameter of type '(x: number) =&gt; number'.</pre>
			<p>Generating the appropriate index position will require an extra parameter for the recursion. Still, it is basically simple: when we start out, we have <strong class="source-inline">index=0</strong>, and when we call our function<a id="_idIndexMarker707"/> recursively, it’s with the <strong class="source-inline">index+1</strong> position. Accessing the original array requires yet<a id="_idIndexMarker708"/> another parameter, which will never change, and now we have a better <span class="No-Break">mapping function:</span></p>
			<pre class="source-code">
// continued...
const mapR2 = &lt;A, B&gt;(
  arr: A[],
  cb: (x: A, i: number, arr: A[]) =&gt; B,
  i = 0,
  orig = arr
): B[] =&gt;
  arr.length == 0
    ? []
    : [cb(arr[0], i, orig)].concat(
        <strong class="bold">mapR2(arr.slice(1), cb, i + 1, orig)</strong>
      );
const senseless = (
  x: number,
  i: number,
  a: number[]
): number =&gt; x * 10 + i + a[i] / 10;
console.log(aaa.map(senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong>
console.log(mapR2(aaa, senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong></pre>
			<p>Great! When you do recursion instead of iteration, you don’t have access to an index, so if you need it (as in our case), you’ll have to generate it on your own. This is an often-used technique, so working out our <strong class="source-inline">map()</strong> substitute was a <span class="No-Break">good idea.</span></p>
			<p>However, having extra arguments in the function is not so good; a developer might accidentally provide them and the results would be unpredictable. So, using another usual technique, let’s define an inner function, <strong class="source-inline">mapLoop()</strong>, to handle looping. This is, in fact, the usual way in which looping is achieved when you only use recursion; look at the following code, in which the extra function isn’t accessible <span class="No-Break">from outside:</span></p>
			<pre class="source-code">
// continued...
const mapR3 = &lt;A, B&gt;(
  orig: A[],
  cb: (x: A, i: number, a: A[]) =&gt; B
): B[] =&gt; {
  <strong class="bold">const mapLoop</strong> = (arr: A[], i: number): B[] =&gt;
    arr.length == 0
      ? []
      : [cb(arr[0], i, orig)].concat(
          <strong class="bold">mapLoop(arr.slice(1), i + 1)</strong>
        );
  return mapLoop(orig, 0);
};
console.log(mapR3(aaa, senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong>, again</pre>
			<p>There’s only one <a id="_idIndexMarker709"/>pending issue: if the original array has some missing elements, they should <a id="_idIndexMarker710"/>be skipped during the loop. Let’s look at an example, in <span class="No-Break">plain JavaScript:</span></p>
			<pre class="source-code">
[1, 2, , , 5].map(tenTimes)
// [10, 20, undefined × 2, 50]</pre>
			<p>(Why just JavaScript? TypeScript would object because the array to be processed had <strong class="source-inline">number | undefined</strong> types, but <strong class="source-inline">timesTen()</strong> expects an array with just <strong class="source-inline">number</strong> types. By the way, I also had to disable ESLint’s <strong class="source-inline">no-sparse-array</strong> rule, which catches accidental extra commas <span class="No-Break">in arrays.)</span></p>
			<p>Fortunately, fixing this is simple—and be glad that all the experience gained here will help us write the other functions in this section! Can you understand the fix in the following code, apart from the obvious changes to allow values in arrays to be <strong class="source-inline">undefined</strong>, for which I used an auxiliary <strong class="source-inline">Opt&lt;&gt;</strong> <span class="No-Break">type definition?</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">type Opt&lt;X&gt; = X | undefined;</strong>
const mapR4 = &lt;A, B&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; B
): Opt&lt;B&gt;[] =&gt; {
  const mapLoop = (arr: Opt&lt;A&gt;[], i: number): Opt&lt;B&gt;[] =&gt;
    arr.length == 0
      ? []
<strong class="bold">      : !(0 in arr) || arr[0] === undefined</strong>
<strong class="bold">      ? ([,] as Opt&lt;B&gt;[]).concat(</strong>
<strong class="bold">          mapLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">        )</strong>
<strong class="bold">      : ([cb(arr[0] as A, i, orig)] as Opt&lt;B&gt;[]).concat(</strong>
<strong class="bold">          mapLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">        );</strong>
  return mapLoop(orig, 0);
};</pre>
			<p>Wow! This was more than we bargained for, but we saw several techniques: how to replace iteration with<a id="_idIndexMarker711"/> recursion, how to accumulate a result across iterations, and how to generate and <a id="_idIndexMarker712"/>provide the index value—good tips! Furthermore, writing filtering code will prove much easier since we’ll be able to apply very much the same logic as we did for mapping. The main difference is that we use the callback function to decide whether an element goes into the output array, so the inner loop function is a <span class="No-Break">tad longer:</span></p>
			<pre class="source-code">
// filter.ts
type Opt&lt;X&gt; = X | undefined;
const filterR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): A[] =&gt; {
  const filterLoop = (arr: Opt&lt;A&gt;[], i: number): A[] =&gt;
    arr.length == 0
      ? []
<strong class="bold">      : !(0 in arr) ||</strong>
<strong class="bold">        arr[0] === undefined ||</strong>
<strong class="bold">        !cb(arr[0] as A, i, orig)</strong>
<strong class="bold">      ? filterLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">      : ([arr[0]] as A[]).concat(</strong>
<strong class="bold">          filterLoop(arr.slice(1), i + 1) as A[]</strong>
<strong class="bold">        );</strong>
  return filterLoop(orig, 0);
};</pre>
			<p>Okay, we <a id="_idIndexMarker713"/>managed to implement two of our basic higher-order functions with similar<a id="_idIndexMarker714"/> recursive functions. What about <span class="No-Break">the others?</span></p>
			<h3>Other higher-order functions</h3>
			<p>Programming <strong class="source-inline">reduce()</strong> is, from the outset, a bit trickier, since you can decide to omit the initial value for the accumulator. Since we mentioned earlier that providing that value is generally better, let’s work here under the assumption that it will be given; dealing with the other possibility won’t be <span class="No-Break">too hard.</span></p>
			<p>The base case is simple: if the array is empty, the result is the accumulator; otherwise, we must apply the <strong class="source-inline">reduce</strong> function to the<a id="_idIndexMarker715"/> current element and the accumulator, update the latter, and then continue working with the rest of the array. This can be a bit confusing because of the ternary operators, but it should be clear enough after all we’ve seen. Look at the following code for <span class="No-Break">the details:</span></p>
			<pre class="source-code">
// reduce.ts
const reduceR = &lt;A, B&gt;(
  orig: A[],
  cb: (acc: B, x: A, i: number, a: A[]) =&gt; B,
  accum: B
) =&gt; {
  const reduceLoop = (arr: A[], accum: B, i: number): B =&gt;
    arr.length == 0
      ? accum
      : !(0 in arr) || arr[0] === undefined
      ? reduceLoop(arr.slice(1), accum, i + 1)
      : reduceLoop(
          arr.slice(1),
          cb(accum, arr[0], i, orig),
          i + 1
        );
  return reduceLoop(orig, accum, 0);
};
let bbb = [1, 2, , 5, 7, 8, 10, 21, 40];
console.log(bbb.reduce((x, y) =&gt; x + y, 0));   // 94
console.log(reduce2(bbb, (x, y) =&gt; x + y, 0)); // 94</pre>
			<p>On the other hand, <strong class="source-inline">find()</strong> is particularly apt for recursive logic since the very definition of how you (attempt to) find <a id="_idIndexMarker716"/>something is recursive <span class="No-Break">in itself:</span></p>
			<ul>
				<li>You look at the first place you think of, and if you find what you were seeking, you <span class="No-Break">are done</span></li>
				<li>Alternatively, you look at the other places to see whether what you seek <span class="No-Break">is there</span></li>
			</ul>
			<p>We are only missing the base case, but that’s simple, and we already saw this earlier in the chapter – if you have no places left to search, then you know you won’t be successful in <span class="No-Break">your search:</span></p>
			<pre class="source-code">
// find.ts
const findR = &lt;A&gt;(
  arr: A[],
  cb: (x: A) =&gt; boolean
): Opt&lt;A&gt; =&gt;
  arr.length === 0
    ? undefined
    : cb(arr[0])
    ? arr[0]
    : findR(arr.slice(1), cb);</pre>
			<p>We can quickly verify whether <span class="No-Break">this works:</span></p>
			<pre class="source-code">
let aaa = [1, 12, , , 5, 22, 9, 60];
const isTwentySomething = x =&gt; 20 &lt;= x &amp;&amp; x &lt;= 29; console.log(findR(aaa, isTwentySomething)); // 22
const isThirtySomething = x =&gt; 30 &lt;= x &amp;&amp; x &lt;= 39; console.log(findR(aaa, isThirtySomething)); // undefined</pre>
			<p>Let’s finish with our pipelining function. The definition of a pipeline lends itself to <span class="No-Break">quick implementation:</span></p>
			<ul>
				<li>If we want to pipeline a single function, then that’s the result of <span class="No-Break">the pipeline</span></li>
				<li>If we want to pipeline several functions, we must first apply the initial function and then pass that result as input to the pipeline of the <span class="No-Break">other functions</span></li>
			</ul>
			<p>We can directly turn this<a id="_idIndexMarker717"/> <span class="No-Break">into code:</span></p>
			<pre class="source-code">
function pipelineR&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Pipeline&lt;FNS&gt;;
function pipelineR&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return fns.length === 1
    ? fns[0]
    : (...args) =&gt;
        pipelineR(...fns.slice(1))(fns[0](...args));
}</pre>
			<p>We can verify its correctness with a simple example. Let’s pipeline several calls to a couple of functions, one of which just adds 1 to its argument and the other of which multiplies <span class="No-Break">by 10:</span></p>
			<pre class="source-code">
const plus1 = (x: number): number =&gt; x + 1;
const by10 = (x: number): number =&gt; x * 10;
pipelineR(
  by10,
  plus1,
  plus1,
  plus1,
  by10,
  plus1,
  by10,
  by10,
  plus1,
  plus1,
  plus1
)(2);
// 23103</pre>
			<p>If you follow the math, you’ll be able to check that the pipelining is working fine. We could have a slightly different recursive call if we take the base case to be when no functions <span class="No-Break">are provided:</span></p>
			<pre class="source-code">
// continued...
function pipelineR2&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Pipeline&lt;FNS&gt;;
function pipelineR2&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return <strong class="bold">fns.length === 0</strong>
<strong class="bold">    ? (...args) =&gt; args[0]</strong>
    : (...args) =&gt;
        pipelineR2(...fns.slice(1))(fns[0](...args));
}</pre>
			<p>In any case, these<a id="_idIndexMarker718"/> pipelines won’t work in TypeScript because our <strong class="source-inline">Pipeline&lt;&gt;</strong> type definition won’t allow for an empty set of functions – can you <span class="No-Break">fix that?</span></p>
			<p>Doing the same for composition is easy, except that you cannot use the spread operator to simplify the function definition, and you’ll have to work with array indices—work <span class="No-Break">it out!</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/>Searching and backtracking</h2>
			<p>Searching for solutions to problems, especially when there is no direct algorithm and you must resort to trial and error, is particularly appropriate for recursion. Many of these algorithms fall into a<a id="_idIndexMarker719"/> scheme such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Out of many choices available, pick one. If no options are available, <span class="No-Break">you’ve failed.</span></li>
				<li>If you could pick one, apply the same algorithm, but find a solution to <span class="No-Break">the rest.</span></li>
				<li>If you succeed, you are done. Otherwise, try <span class="No-Break">another choice.</span></li>
			</ul>
			<p>You can apply similar logic with minor variations to find a good—or possibly, optimum—solution to a given problem. Each time you find a possible solution, you match it with previous ones that you might have found and decide which to keep. This may continue until all possible solutions are evaluated or until a good enough solution has <span class="No-Break">been found.</span></p>
			<p>There are many problems to which this logic applies. They are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><em class="italic">Finding a way out of mazes</em>—pick any path, mark it as already followed, and try to find a way out of the maze that won’t reuse that path: if you succeed, you are done, and if you do not, go back to pick a <span class="No-Break">different path</span></li>
				<li><em class="italic">Filling out Sudoku puzzles</em>—if an empty cell can contain only a single number, then assign it; otherwise, run through<a id="_idIndexMarker720"/> all of the possible assignments, and for each one, recursively try to see whether the rest of the puzzle can be <span class="No-Break">filled out</span></li>
				<li><em class="italic">Playing chess</em>—where you aren’t likely to be able to follow through all possible move sequences, so you opt for the best-estimated <span class="No-Break">position instead</span></li>
			</ul>
			<p>Let’s apply these techniques to two problems: solving the eight queens puzzle and traversing a complete <span class="No-Break">file directory.</span></p>
			<h3>The eight queens puzzle</h3>
			<p>The eight queens puzzle was invented in the 19th century and involves <a id="_idIndexMarker721"/>placing eight chess queens on a standard chessboard. The restriction is that no queen should be able to attack another—implying that no pair of queens may share a row, column, or diagonal line. The puzzle may ask for any solution or the total number of distinct solutions, which we will attempt <span class="No-Break">to find.</span></p>
			<p class="callout-heading">The <em class="italic">n</em> queens variation</p>
			<p class="callout">The puzzle may also be <a id="_idIndexMarker722"/>generalized to <em class="italic">n</em> queens by working on an <em class="italic">n</em>x<em class="italic">n</em> square board. It is known that there are solutions for all values of <em class="italic">n</em>, except <em class="italic">n</em>=2 (pretty simple to see why: after placing one queen, all of the board is threatened) and <em class="italic">n</em>=3 (if you place a queen in the center, all of the board is threatened, and if you place a queen on a side, only two squares are not threatened, but they threaten each other, making it impossible to place queens <span class="No-Break">on them).</span></p>
			<p>Let’s start our solution with top-level logic. Because of the given rules, there will be a single queen in each column, so we use a <strong class="source-inline">places</strong> array to take note of each queen’s row within the given column. The <strong class="source-inline">SIZE</strong> constant could be modified to solve a more general problem. We’ll count each found distribution of queens in the <strong class="source-inline">solutions</strong> variable. Finally, the <strong class="source-inline">finder()</strong> function will perform the recursive search for solutions. The basic skeleton for the <a id="_idIndexMarker723"/>code would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// queens.ts
const SIZE = 8;
const places = Array(SIZE);
let solutions = 0;
finder();
console.log(`Solutions found: ${solutions}`);</pre>
			<p>Let’s get into the required logic. When we want to place a queen in a given row and column, we must check whether any of the previously placed queens were placed on the same row or in a diagonal leading from the row. See <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_9.4_B19301.jpg" alt="Figure 9.4 – Before placing a queen in a column, we must check the previously placed queens’ positions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Before placing a queen in a column, we must check the previously placed queens’ positions</p>
			<p>Let’s write a <strong class="source-inline">checkPlace(column, row)</strong> function to verify whether a queen can be safely placed in the given square. The most straightforward way is by using <strong class="source-inline">every()</strong>, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const checkPlace = (column: number, row: number): boolean =&gt;
  places
    .slice(0, column)
    .every(
      (v, i) =&gt;
        v !== row &amp;&amp; Math.abs(v - row) !== column - i
    );</pre>
			<p>This declarative fashion seems best: when we place a queen in a position, we want to ensure that every other previously placed queen is in a different row and diagonal. A recursive solution<a id="_idIndexMarker724"/> would have been possible too, so let’s see that. How do we know that a square <span class="No-Break">is safe?</span></p>
			<ul>
				<li>A base case is when there are no more columns to check, the square <span class="No-Break">is safe</span></li>
				<li>If the square is in the same row or diagonal as any other queen, it’s <span class="No-Break">not safe</span></li>
				<li>If we have checked a column and found no problem, we can now recursively check the <span class="No-Break">following one</span></li>
			</ul>
			<p>The required alternative code to check whether a position in a column can be occupied by a queen is, therefore, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const checkR = (column: number, row: number): boolean =&gt; {
  const checkColumn = (i: number): boolean =&gt; {
    if (i == column) {
      return true;
    } else if (
      places[i] == row ||
      Math.abs(places[i] - row) == column - i
    ) {
      return false;
    } else {
      return checkColumn(i + 1);
    }
  };
  return checkColumn(0);
};</pre>
			<p>The code works, but I wouldn’t use it since the declarative version is clearer. Anyway, having worked out this check, we can pay attention to the main <strong class="source-inline">finder()</strong> logic, which will do the recursive search. The process proceeds as we described at the beginning: try out a possible placement for a queen, and if that is acceptable, use the same search procedure to try and<a id="_idIndexMarker725"/> place the remaining queens. We start at column 0, and our base case is when we reach the last column, meaning that all queens have been successfully placed: we can print out the solution, count it, and go back to search for a <span class="No-Break">new configuration.</span></p>
			<p class="callout-heading">Getting nice output</p>
			<p class="callout">Check out how we use <strong class="source-inline">map()</strong> and a simple arrow function to print the rows of the queens, column by column, as numbers between 1 and 8, instead of 0 and 7. In chess, rows are numbered from 1 to 8 (and columns from a to h, but that doesn’t <span class="No-Break">matter here).</span></p>
			<p>Check out the following code, which applies the logic that we <span class="No-Break">described previously:</span></p>
			<pre class="source-code">
// continued...
const finder = (column = 0) =&gt; {
  if (column === SIZE) {
    // all columns tried out?
    // if so, print and count solution
    console.log(JSON.stringify(places.map((x) =&gt; x + 1)));
    solutions++;
  } else {
    const testRowsInColumn = (j: number) =&gt; {
      if (j &lt; SIZE) {
        if (checkR(column, j)) {
          places[column] = j;
          finder(column + 1);
        }
        testRowsInColumn(j + 1);
      }
    };
    testRowsInColumn(0);
  }
};</pre>
			<p>The inner <strong class="source-inline">testRowsInColumn()</strong> function also fulfills an iterative role, but recursively. The idea is to attempt placing a queen in every possible row, starting at zero: if the square is safe, <strong class="source-inline">finder()</strong> is called to start searching from the next column onward. No matter whether a solution was or wasn’t found, all rows in the column are tried out because we are interested in the total number of solutions. In other search problems, you might<a id="_idIndexMarker726"/> be content with finding any solution, and you would stop your <span class="No-Break">search there.</span></p>
			<p>We have come this far, so let’s find the answer to <span class="No-Break">our problem!</span></p>
			<pre class="console">
[1,5,8,6,3,7,2,4]
[1,6,8,3,7,4,2,5]
[1,7,4,6,8,2,5,3]
[1,7,5,8,2,4,6,3]
[2,4,6,8,3,1,7,5]
[2,5,7,1,3,8,6,4]
[2,5,7,4,1,8,6,3]
[2,6,1,7,4,8,3,5]
   ...
   ... 70 lines snipped out
   ...
[8,2,4,1,7,5,3,6]
[8,2,5,3,1,7,4,6]
[8,3,1,6,2,5,7,4]
[8,4,1,3,6,2,7,5]
Solutions found: 92</pre>
			<p>Each solution is given as the row positions for the queens, column by column, and there are 92 solutions <span class="No-Break">in all.</span></p>
			<h3>Traversing a tree structure</h3>
			<p>Data structures, which include recursion in their definition, are naturally appropriate for recursive techniques. Let’s consider, for<a id="_idIndexMarker727"/> example, how to traverse a complete filesystem directory, listing all of its contents. Where’s the recursion? The answer is straightforward if you consider that each directory can do either of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Be empty—a base case in which there’s nothing <span class="No-Break">to do</span></li>
				<li>Include one or more entries, each of which is either a file or a <span class="No-Break">directory itself</span></li>
			</ul>
			<p>Let’s work out a full recursive directory listing—meaning that when we encounter a directory, we also list its contents, and if those include more directories, we also list them, and so on. We’ll be using the same node functions as in <strong class="source-inline">getDir()</strong> (from the <em class="italic">Building pipelines by hand</em> section in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic">, Connecting Functions</em>), plus a few more to test whether a directory entry is a symbolic link (which we won’t follow to avoid possible infinite loops), a directory (which will require a recursive listing), or a <span class="No-Break">common file:</span></p>
			<pre class="source-code">
// directory.ts
import * as fs from "fs";
<strong class="bold">const recursiveDir = (path: string) =&gt;</strong> {
  console.log(path);
  fs.readdirSync(path).forEach((entry) =&gt; {
    if (entry.startsWith(".")) {
      // skip it!
    } else {
      const full = path + "/" + entry;
      const stats = fs.lstatSync(full);
      if (stats.isSymbolicLink()) {
        console.log("L ", full); // symlink, don't follow
      } else if (stats.isDirectory()) {
        console.log("D ", full);
        <strong class="bold">recursiveDir(full);</strong>
      } else {
        console.log("  ", full);
      }
    }
  });
};</pre>
			<p>The listing is long but<a id="_idIndexMarker728"/> correct. I opted to list the <strong class="source-inline">/boot</strong> directory in my own openSUSE Linux laptop, and this <span class="No-Break">was produced:</span></p>
			<pre class="console">
recursiveDir("/boot");
/boot
/boot/System.map-4.11.8-1-default
/boot/boot.readme
/boot/config-4.11.8-1-default D  /boot/efi
D    /boot/efi/EFI
D    /boot/efi/EFI/boot
/boot/efi/EFI/boot/bootx64.efi
/boot/efi/EFI/boot/fallback.efi
...
... many omitted lines
...
L    /boot/initrd
/boot/initrd-4.11.8-1-default
/boot/message
/boot/symtypes-4.11.8-1-default.gz
/boot/symvers-4.11.8-1-default.gz
/boot/sysctl.conf-4.11.8-1-default
/boot/vmlinux-4.11.8-1-default.gz  L  /boot/vmlinuz
/boot/vmlinuz-4.11.8-1-default</pre>
			<p>We can apply the same structure to a similar problem: traversing a DOM structure. We could list all of the tags, starting from a given element, using the same approach: we list a node and (by applying<a id="_idIndexMarker729"/> the same algorithm) all of its children. The base case is the same as before: when a node has no children, no more recursive calls are made. You can see this in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// dom.ts
const traverseDom = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  for (let i = 0; i &lt; node.children.length; i++) {
    traverseDom(node.children[i], depth + 1);
  }
};</pre>
			<p>We are using the <strong class="source-inline">depth</strong> variable to know how many levels below the original element we are. We could also use it to make the traversing logic stop at a certain level; in our case, we are using it only to add some bars and spaces to appropriately indent each element according to its place in the DOM hierarchy. The result of this function is shown in the following code. It would be easy to list more information and not just the element tag, but I wanted to focus on the <span class="No-Break">recursive process:</span></p>
			<pre class="console">
traverseDom(document.body);
&lt;body&gt;
| &lt;script&gt;
| &lt;div&gt;
| | &lt;div&gt;
| | | &lt;a&gt;
| | | &lt;div&gt;
| | | | &lt;ul&gt;
| | | | | &lt;li&gt;
| | | | | | &lt;a&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;div&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;br&gt;
| | | | | | | &lt;div&gt;
| | | | | | &lt;ul&gt;
| | | | | | | &lt;li&gt;
| | | | | | | | &lt;a&gt;
| | | | | | | &lt;li&gt;
...etc.!</pre>
			<p>However, there’s an ugly point there: why are we making a loop to go through all of the children? We should know<a id="_idIndexMarker730"/> better! The problem is that the structure we get from the DOM isn’t really an array. However, there’s a way out – we can use <strong class="source-inline">Array.from()</strong> to create a real array out of it and then write a more declarative solution. The following code solves the problem in a <span class="No-Break">better way:</span></p>
			<pre class="source-code">
// continued...
const traverseDom2 = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  Array.from(node.children).forEach((child) =&gt;
    traverseDom2(child, depth + 1)
  );
};</pre>
			<p>Writing <strong class="source-inline">[...node.children].forEach()</strong> would have worked as well but using <strong class="source-inline">Array.from()</strong> makes it more apparent to any reader that we are trying to make an array out of something that looks like one, but <span class="No-Break">really isn’t.</span></p>
			<p>We have now seen many ideas about the usage of recursion, and we’ve seen many applications of it; however, there are some cases in which you may run into problems, so let’s now consider<a id="_idIndexMarker731"/> some tweaks that may come in handy for <span class="No-Break">specific problems.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor178"/>Mutual recursion</h1>
			<p>Recursion need not be as “simple” and “direct” as having a function that calls itself. We can have more complex situations as a set of functions, each of which calls one or more of the others but not necessarily calling itself. (However, note that this is <span class="No-Break">also allowed.)</span></p>
			<p>Thinking in terms of mutual recursion is<a id="_idIndexMarker732"/> harder. For simple recursion, you had to imagine you already had a function to do something, and then you used it (in itself!) to do that. In mutual recursion, you have to think of a set of functions, each of which does its own part by simultaneously depending on all the set of functions: the others, and possibly itself <span class="No-Break">as well.</span></p>
			<p>Let’s examine a simple case to get our feet wet, and then go for a “<span class="No-Break">real-life” application.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor179"/>Odds and evens</h2>
			<p>How can you determine<a id="_idIndexMarker733"/> whether a (not negative) integer number is odd or even? This a trivial problem, to be sure (but see <em class="italic">Question 9.11</em>) but we can get an interesting solution if we realize <span class="No-Break">the following:</span></p>
			<ul>
				<li>Zero <span class="No-Break">is even</span></li>
				<li>If a number is even, when you subtract 1 from it, you get an <span class="No-Break">odd number</span></li>
				<li>A number is odd if it’s <span class="No-Break">not even:</span></li>
			</ul>
			<pre class="source-code">
function isEven(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return <strong class="bold">isOdd(n - 1)</strong>;
  }
}
function isOdd(n: number): boolean {
  return <strong class="bold">!isEven(n)</strong>;
}
console.log("22.. isEven?", isEven(22));
console.log("9... isOdd?", isOdd(5));
console.log("60... isOdd?", isOdd(10));</pre>
			<p>How does this work? Each function (<strong class="source-inline">isEven()</strong> and <strong class="source-inline">isOdd()</strong>) depends on the other to produce a result. How do we know that 9 is odd? The calculations are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
is 9 odd?
Is 9 not even?
Is 8 odd?
Is 8 not even?
Is 7 odd?
Is 7 not even?
   ...
   ... several lines skipped
   ...
Is 1 odd?
Is 1 not even?
Is 0 odd?
Is 0 not even?</pre>
			<p>And after the last call, the whole tower of calls gets resolved; 9 is reported to be <span class="No-Break">odd (fortunately!)</span></p>
			<p>You could say that <a id="_idIndexMarker734"/>this actually isn’t a great example of mutual recursion, because you could easily replace the code for <strong class="source-inline">isOdd()</strong> in <strong class="source-inline">isEven()</strong> to get single <span class="No-Break">recursion versions:</span></p>
			<pre class="source-code">
// continued…
function isEven2(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return <strong class="bold">!isEven2(n - 1)</strong>;
  }
}
function isOdd2(n: number): boolean {
  return !isEven2(n);
}</pre>
			<p>However, we can go about this in another way that will also include <span class="No-Break">mutual recursion:</span></p>
			<pre class="source-code">
// continued...
function isEven3(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return isOdd3(n - 1);
  }
}
<strong class="bold">function isOdd3(n: number): boolean {</strong>
<strong class="bold">  if (n === 0) {</strong>
<strong class="bold">    return false;</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    return isEven3(n - 1);</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
			<p>So, don’t get to think that mutual recursion can always be simplified away; sometimes, that’s not really possible <span class="No-Break">or practical.</span></p>
			<p>Going back to the code, it should be evident that no one would implement a parity test this way. Still, this example paves the way to implementing a more complex function: parsing and evaluating an<a id="_idIndexMarker735"/> arithmetic expression, which will involve multiple mutually recursive functions, as we’ll <span class="No-Break">see next.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/>Doing arithmetic</h2>
			<p>Let’s see a more complete problem, which<a id="_idIndexMarker736"/> also happens to (frequently!) appear online, with puzzles as in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.5</em>. We’ll implement a set of mutually recursive functions that can correctly evaluate an arithmetic expression according to standard precedence rules <span class="No-Break">for operators.</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_9.5_B19301.jpg" alt="Figure 9.5 – Common puzzles call for evaluating arithmetic expressions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Common puzzles call for evaluating arithmetic expressions</p>
			<p>To solve this, we’ll first see a tool that lets us correctly process operations: <em class="italic">railroad diagrams</em>. We want to evaluate an expression, and we can say that an expression is either one single term, or several terms added or subtracted. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.6</em> shows this graphically. Imagine the arrows are railroad tracks, and any path you follow that starts at the left and eventually ends at the right represents a <span class="No-Break">possible expression.</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_9.6_B19301.jpg" alt="Figure 9.6 – A railroad syntax diagram for arithmetic expressions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – A railroad syntax diagram for arithmetic expressions</p>
			<p>Now, what’s a term? A term is either<a id="_idIndexMarker737"/> a single factor, or the result of multiplying, dividing, or using<a id="_idIndexMarker738"/> modulus operations on several factors, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em>. Note that with these two rules, <em class="italic">2*3+5</em> is correctly evaluated as <em class="italic">(2*3)+5</em>, because <em class="italic">2*3</em> and <em class="italic">5</em> <span class="No-Break">are terms.</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_9.7_B19301.jpg" alt="Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus are performed before addition or subtraction"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus are performed before addition or subtraction</p>
			<p>We need one more diagram, for factors. A factor can be a single number or an expression between parentheses. We’ll allow an optional minus sign at the beginning, so -3 is accepted. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.8</em> shows the <span class="No-Break">needed diagram.</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_9.8_B19301.jpg" alt="Figure 9.8 – A factor starts with an optional minus sign, and can be a number or an expression within parentheses"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – A factor starts with an optional minus sign, and can be a number or an expression within parentheses</p>
			<p>We’ll implement the needed evaluation with three functions, one for each diagram. In the usual compiler or interpreter code, we have a first phase that reads the input and splits it into <em class="italic">tokens</em>, and a <a id="_idIndexMarker739"/>second phase that processes those tokens to do whatever’s needed. In our case, the tokens will be numbers (single digits, for simplicity), operators, and parentheses. The code we’ll write is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function evaluate(str: string) {
  const PLUS = "+";
  const MINUS = "-";
  const TIMES = "*";
  const DIVIDES = "/";
  const MODULUS = "%";
  const LPARENS = "(";
  const RPARENS = ")";
<strong class="bold">  let curr = 0;</strong>
<strong class="bold">  const tokens = str</strong>
<strong class="bold">    .split("")</strong>
<strong class="bold">    .map((x) =&gt; (Number.isNaN(Number(x)) ? x : Number(x)));</strong>
<strong class="bold">  return expression();</strong>
  function expression(): number { ... }
  function term(): number { ... }
  function factor(): number { ... }
}</pre>
			<p>We define some constants (<strong class="source-inline">PLUS</strong>, <strong class="source-inline">MINUS</strong>, etc.) for clarity. Given a string such as <strong class="source-inline">"7+7/7+7*7-7"</strong>, we split it into the tokens array; we take care to evaluate digits. Finally, we have a <strong class="source-inline">curr</strong> variable pointing to the token being processed right now. The evaluation of the<a id="_idIndexMarker740"/> input expression will be done by three functions that will use <span class="No-Break">mutual recursion:</span></p>
			<pre class="source-code">
  function expression(): number {
  <strong class="bold">let accum = term()</strong>;
  while (
    tokens[curr] === PLUS ||
    tokens[curr] === MINUS
  ) {
    if (tokens[curr] === PLUS) {
      curr++;
      <strong class="bold">accum += term()</strong>;
    } else if (tokens[curr] === MINUS) {
      curr++;
      <strong class="bold">accum -= term()</strong>;
    }
  }
  <strong class="bold">return accum</strong>;
}</pre>
			<p>The <strong class="source-inline">expression()</strong> function first calls <strong class="source-inline">term()</strong> to get the value of the first term and then loops if an addition or subtraction is found. In our case, this means that the function would first evaluate a 7, then add 7/7, then also add 7*7, and finally subtract the last 7. (And yes, the result is 50.) After a token is processed, <strong class="source-inline">curr</strong> is incremented to continue with the rest <a id="_idIndexMarker741"/>of <span class="No-Break">the tokens.</span></p>
			<p>The code for <strong class="source-inline">term()</strong> is similar in style; the only difference is how it works with multiplication, and <span class="No-Break">so on:</span></p>
			<pre class="source-code">
function term(): number {
  <strong class="bold">let accum = factor()</strong>;
  while (
    tokens[curr] === TIMES ||
    tokens[curr] === DIVIDES ||
    tokens[curr] === MODULUS
  ) {
    if (tokens[curr] === TIMES) {
      curr++;
      <strong class="bold">accum *= factor()</strong>;
    } else if (tokens[curr] === DIVIDES) {
      curr++;
      <strong class="bold">accum /= factor()</strong>;
    } else if (tokens[curr] === MODULUS) {
      curr++;
      <strong class="bold">accum %= factor()</strong>;
    }
  }
  <strong class="bold">return accum</strong>;
}</pre>
			<p>This function would be called to evaluate 7, then 7/7, then 7*7, and finally <span class="No-Break">another 7.</span></p>
			<p>Finally, <strong class="source-inline">factor()</strong> is a <span class="No-Break">tad different:</span></p>
			<pre class="source-code">
function factor(): number {
  let mult = 1;
  if (tokens[curr] === MINUS) {
    mult = -1;
    curr++; // skip MINUS
  }
  let result = 0;
  if (tokens[curr] === LPARENS) {
    curr++; // skip LPARENS
    result = expression();
    curr++; // skip RPARENS
  } else {
    result = tokens[curr] as number;
    curr++;
  }
  return mult * result;
}</pre>
			<p>The <strong class="source-inline">mult</strong> variable will be <strong class="source-inline">-1</strong> if an initial minus sign was present, or <strong class="source-inline">+1</strong> otherwise. We have no loops here, and just an alternative: if a left parenthesis is seen, we skip it, recursively evaluate<a id="_idIndexMarker742"/> the included expression, skip the right parenthesis, and return the value of the expression. The alternative is that we have a number, which we return. Whatever we return, we’ll multiply by the <strong class="source-inline">mult</strong> value to produce the <span class="No-Break">correct result.</span></p>
			<p>If you analyze the recursive calls, we have <strong class="source-inline">expression()</strong> calling <strong class="source-inline">term()</strong>, which calls <strong class="source-inline">factor()</strong>, which calls <strong class="source-inline">recursive()</strong> – a cycle of three! Mutual recursion is harder to understand and to get right because to plan such code, you must foresee what several functions will do. However, for the right problems (as shown here), it’s a very <span class="No-Break">powerful technique.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor181"/>Recursion techniques</h1>
			<p>While recursion is a very<a id="_idIndexMarker743"/> good technique, you may face some problems because of the way it is<a id="_idIndexMarker744"/> internally implemented. Each function call, recursive or not, requires an entry in the internal JavaScript stack. When you are working with recursion, each recursive call itself counts as another call, and you might find that there are some situations in which your code will crash and throw an error because it ran out of memory, just because of multiple calls. On the other hand, with most current JavaScript engines, you can probably have several thousand pending<a id="_idIndexMarker745"/> recursive calls without a problem – but with earlier browsers and smaller machines, the number could drop into the hundreds and feasibly go even lower. Thus, it could be argued that, at present, you are not likely to suffer from any particular <span class="No-Break">memory problems.</span></p>
			<p>In any case, let’s review the problem and go over some possible solutions in the following sections. Even if you don’t get to actually apply them, they represent valid FP ideas for which you may find a place in yet other problems. We will be looking at the <span class="No-Break">following solutions:</span></p>
			<ul>
				<li><strong class="bold">Tail call optimization</strong>, a technique<a id="_idIndexMarker746"/> that speeds up recursion <strong class="bold">continuation-passing style</strong> (<strong class="bold">CPS</strong>), an<a id="_idIndexMarker747"/> important FP technique that can help <span class="No-Break">with recursion</span></li>
				<li>A couple of interestingly named techniques, <strong class="bold">trampolines</strong> and <strong class="bold">thunks</strong>, which are also standard <span class="No-Break">FP tools</span></li>
				<li><strong class="bold">Recursion elimination</strong>, a technique beyond this book’s scope, but which may still <span class="No-Break">be applied</span></li>
			</ul>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>Tail call optimization</h2>
			<p>When is a recursive call not a<a id="_idIndexMarker748"/> recursive call? Put this way, the question<a id="_idIndexMarker749"/> may make little sense, but there’s a common optimization—for other languages, alas, but not JavaScript!—that explains the answer. If the recursive call is the very last thing a function will do, then the call could be transformed into a simple jump to the start of the function without needing to create a new stack entry. (Why? The stack entry wouldn’t be required: after the recursive call is done, the function would have nothing else to do, so there is no need to further save any of the elements that have been pushed into the stack upon entering the function.) The original stack entry would then no longer be needed and could be replaced by a new one, corresponding to the <span class="No-Break">recent call.</span></p>
			<p class="callout-heading">Implementation irony</p>
			<p class="callout">The fact that a recursive call, a quintessential FP technique, is being implemented by a base imperative <strong class="source-inline">GO</strong> <strong class="source-inline">TO</strong> statement can be considered an <span class="No-Break">ultimate irony!</span></p>
			<p>These calls are known as <strong class="bold">tail calls</strong> (for obvious reasons) and have higher efficiency, not only because of <a id="_idIndexMarker750"/>the saved stack space but also because a jump is quite a bit faster than any alternative. If the browser<a id="_idIndexMarker751"/> implements this <a id="_idIndexMarker752"/>enhancement, it uses <strong class="bold">tail call optimization</strong> (<strong class="bold">TCO</strong>); however, a glance at<a id="_idIndexMarker753"/> the compatibility tables at <a href="http://kangax.github.io/compat-table/es6/">kangax.github.io/compat-table/es6/</a> shows that at the time of writing (at the end of 2022), the only browser that provides TCO <span class="No-Break">is Safari.</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_9.9_B19301.jpg" alt="Figure 9.9 – To understand this joke, you must have previously understood it!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – To understand this joke, you must have previously understood it!</p>
			<p>A simple (though non-standard) test lets you verify whether your browser provides TCO. I found this snippet of code in several places on the web, but I’m sorry to say, I cannot attest to the original author, although I believe it is Csaba Hellinger from Hungary. Calling <strong class="source-inline">detectTCO()</strong> lets you know whether your browser does or does not <span class="No-Break">use TCO:</span></p>
			<pre class="source-code">
// tailRecursion.ts
function detectTCO() {
  const outerStackLen = new Error().stack!.length;
  return (function inner() {
    const innerStackLen = new Error().stack!.length;
    return innerStackLen &lt;= outerStackLen;
  })();
}</pre>
			<p>The <strong class="source-inline">Error().stack</strong> result is not a JavaScript standard, but modern browsers support it, albeit in somewhat different ways. (I had to add the “<strong class="source-inline">!</strong>” symbol so TypeScript would accept that <strong class="source-inline">stack</strong> would be present.) In any case, the idea is that when a function with a long name calls another function with a shorter name, the stack trace should do <span class="No-Break">the following:</span></p>
			<ul>
				<li>It should get <a id="_idIndexMarker754"/>shorter if the browser implements TCO, since the old entry for the longer-named function would be<a id="_idIndexMarker755"/> replaced with the entry for the <span class="No-Break">shorter-named one</span></li>
				<li>It should get longer without TCO, since a completely new stack entry would be created without doing away with the <span class="No-Break">original one</span></li>
			</ul>
			<p>I’m using Chrome on my Linux laptop, and I added a <strong class="source-inline">console.log()</strong> statement to show <strong class="source-inline">Error().stack</strong>. You can see that both stack entries (for <strong class="source-inline">inner()</strong> and <strong class="source-inline">detectTCO()</strong>) are <em class="italic">live</em>, so there’s <span class="No-Break">no TCO:</span></p>
			<pre class="source-code">
Error
at inner (&lt;anonymous&gt;:6:13)
at detectTCO (&lt;anonymous&gt;:9:6) at &lt;anonymous&gt;:1:1</pre>
			<p>Of course, there’s another way of learning whether your environment includes TCO: try out the following function (which does nothing!) with large enough numbers. If you manage to run it with numbers such as, say, 100,000 or 1,000,000, you can be reasonably sure that your JavaScript engine is doing TCO! A possible such function could be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
function justLoop(n: number): void {
  n &amp;&amp; justLoop(n - 1); // until n is zero
}</pre>
			<p>Let’s finish this section with a very short quiz to ensure we understand what tail calls are. Is the recursive call in the factorial function we saw in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, (but here written in TypeScript) a <span class="No-Break">tail call?</span></p>
			<pre class="source-code">
function fact(n: number): number {
  if (n === 0) {
    return 1;
  } else {
<strong class="bold">    return n * fact(n - 1);</strong>
  }
}</pre>
			<p>Think about it, because the answer is important! You might be tempted to answer in the affirmative, but the correct answer is <em class="italic">no</em>. There’s a good reason for this, and it’s a key point: after the recursive call is done and the value for <strong class="source-inline">fact(n-1)</strong> has been calculated, the function <a id="_idIndexMarker756"/>still has work to do. (So doing the recursive call wasn’t actually the last thing that the<a id="_idIndexMarker757"/> function would do.) You can see it more clearly if you write the function in this <span class="No-Break">equivalent way:</span></p>
			<pre class="source-code">
function fact2(n: number): number {
  if (n === 0) {
    return 1;
  } else {
<strong class="bold">    const aux = fact2(n - 1);</strong>
<strong class="bold">    return n * aux;</strong>
  }
}</pre>
			<p>There should be two takeaways from this section: TCO isn’t usually offered by browsers, and even if it were, you cannot take advantage of it if your calls aren’t actual tail calls. Now that we know what the problem is, let’s see some FP ways of working <span class="No-Break">around it!</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>Continuation-passing style</h2>
			<p>We already know that our logic will fail if we have recursive calls stacked too high. On the other hand, we know that tail calls should alleviate that problem, but they don’t because of browser <a id="_idIndexMarker758"/>implementations! However, there’s <a id="_idIndexMarker759"/>a way out of this. Let’s first consider how we can transform recursive calls into tail calls by using a well-known FP <a id="_idIndexMarker760"/>concept—<strong class="bold">continuations</strong>—and we’ll leave the problem of solving TCO limitations for the next section. (We mentioned continuations in <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, but we didn’t go <span class="No-Break">into detail.)</span></p>
			<p>In FP parlance, a continuation represents the state of a process and allows processing to continue. This may be too abstract, so let’s see what this means. The key idea is that when you call a function, you also provide it with a continuation (in reality, a simple function) that will be called at <span class="No-Break">return time.</span></p>
			<p>Let’s look at a trivial example. Suppose you have a function that returns the time of the day, and you want to show<a id="_idIndexMarker761"/> this on the console. The usual way to do this could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function getTime(): string {
  return new Date().toTimeString();
}
console.log(getTime()); // "21:00:24 GMT+0530 (IST)"</pre>
			<p>If you were doing <a id="_idIndexMarker762"/>CPS, you would pass a continuation to the <strong class="source-inline">getTime()</strong> function. Instead of returning a calculated value, the function would invoke the continuation, giving it the value as <span class="No-Break">a parameter:</span></p>
			<pre class="source-code">
function getTime2(<strong class="bold">cont: FN</strong>) {
  return <strong class="bold">cont(</strong>new Date().toTimeString()<strong class="bold">);</strong>
}
getTime2(console.log); // similar result as above</pre>
			<p>What’s the difference? The key is that we can apply this mechanism to make a recursive call into a tail call because all of the code that comes after will be provided in the recursive call itself. To make this clear, let’s revisit the factorial function in the version that made it explicit that we weren’t doing <span class="No-Break">tail calls:</span></p>
			<pre class="source-code">
function fact2(n: number): number {
  if (n === 0) {
    return 1;
  } else {
    const aux = fact2(n - 1);
    return n * aux;
  }
}</pre>
			<p>We will add a new parameter to the function for the continuation. What do we do with the result of the <strong class="source-inline">fact(n-1)</strong> call? We multiply it by <strong class="source-inline">n</strong>, so let’s provide a continuation that will do just that. I’ll rename the factorial function as <strong class="source-inline">factC()</strong> to make it clear that we are working with<a id="_idIndexMarker763"/> continuations, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
function factC(
  n: number,
  cont: (x: number) =&gt; number
): number {
  if (n === 0) {
    return cont(1);
  } else {
    return factC(n - 1, (x) =&gt; cont(n * x));
  }
}</pre>
			<p>How would we get the final result? Easy – we can call <strong class="source-inline">factC()</strong> with a continuation that will return<a id="_idIndexMarker764"/> whatever <span class="No-Break">it’s given:</span></p>
			<pre class="source-code">
console.log(factC(7, x =&gt; x)); // 5040, correctly
factC(7, console.log);         // same result</pre>
			<p class="callout-heading">Identity combinator</p>
			<p class="callout">In FP, a function that returns its argument <a id="_idIndexMarker765"/>as a result is usually called <strong class="source-inline">identity()</strong> for obvious reasons. In combinatory logic (which we won’t be using), we would speak of the <span class="No-Break"><strong class="bold">I combinator</strong></span><span class="No-Break">.</span></p>
			<p>Can you understand how it worked? Then let’s try out a more complex case with the Fibonacci function, which has two recursive calls in it, as shown in the following <span class="No-Break">highlighted code:</span></p>
			<pre class="source-code">
// continued...
const fibC = (n: number, cont: FN): number =&gt; {
  if (n &lt;= 1) {
    return cont(n);
  } else {
<strong class="bold">    return fibC(n - 2, (p) =&gt;</strong>
<strong class="bold">      fibC(n - 1, (q) =&gt; cont(p + q))</strong>
<strong class="bold">    )</strong>;
  }
};</pre>
			<p>This is trickier: we call <strong class="source-inline">fibC()</strong> with <strong class="source-inline">n-2</strong> and a continuation that says that whatever that call returned, call <strong class="source-inline">fibC()</strong> with <strong class="source-inline">n-1</strong>, and when <em class="italic">that</em> call returns, sum the results of both calls and pass that result to the <span class="No-Break">original continuation.</span></p>
			<p>Let’s see just one more example, involving a loop with an undefined number of recursive calls. By then, you<a id="_idIndexMarker766"/> should have some idea about how to apply CPS to your code—though I’ll readily admit it can become <span class="No-Break">really complex!</span></p>
			<p>Earlier in this chapter, we<a id="_idIndexMarker767"/> saw this function in the <em class="italic">Traversing a tree structure</em> section. The idea was to print out the DOM structure, <span class="No-Break">like this:</span></p>
			<pre class="console">
&lt;body&gt;
| &lt;script&gt;
| &lt;div&gt;
| | &lt;div&gt;
| | | &lt;a&gt;
| | | &lt;div&gt;
| | | | &lt;ul&gt;
| | | | | &lt;li&gt;
| | | | | | &lt;a&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;div&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;br&gt;
| | | | | | | &lt;div&gt;
| | | | | | &lt;ul&gt;
| | | | | | | &lt;li&gt;
| | | | | | | | &lt;a&gt;
| | | | | | | &lt;li&gt;
...etc.!</pre>
			<p>The function we ended up designing back then was <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// dom.ts
const traverseDom2 = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  Array.from(node.children).forEach((child) =&gt;
    traverseDom2(child, depth + 1)
  );
};</pre>
			<p>Let’s start by <a id="_idIndexMarker768"/>making this fully recursive, getting rid of the <strong class="source-inline">forEach()</strong> loop. We have seen this technique before, so we can move on to the following result; note how the following code <a id="_idIndexMarker769"/>forms its loops by using recursion. Also, note we added lots of <strong class="source-inline">return</strong> statements, even if they are not really needed; we’ll see the reason for <span class="No-Break">this soon:</span></p>
			<pre class="source-code">
// continued...
const traverseDom3 = (node: Element, depth = 0): void =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  const traverseChildren = (
    children: Element[],
    i = 0
  ): void =&gt; {
    if (i &lt; children.length) {
      traverseDom3(children[i], depth + 1);
      return traverseChildren(children, i + 1); // loop
    }
    return;
  };
  return traverseChildren(Array.from(node.children));
};</pre>
			<p>Now, we have to add a continuation to <strong class="source-inline">traverseDom3()</strong>. The only difference from the previous cases is that the function doesn’t return anything, so we won’t pass any arguments to the <a id="_idIndexMarker770"/>continuation. It’s also important to remember the implicit return at the end of the <strong class="source-inline">traverseChildren()</strong> loop; we must call <span class="No-Break">the continuation:</span></p>
			<pre class="source-code">
// continued...
const traverseDom3C = (
  node: Element,
  depth = 0,
  cont: FN = () =&gt; {
    /*  nothing */
  }
): void =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  const traverseChildren = (
    children: Element[],
    i = 0
  ): void =&gt; {
    if (i &lt; children.length) {
      return traverseDom3C(children[i], depth + 1, () =&gt;
        traverseChildren(children, i + 1)
      );
    }
    return cont();
  };
  return traverseChildren(Array.from(node.children));
};</pre>
			<p>We opted to give a <a id="_idIndexMarker771"/>default value to <strong class="source-inline">cont</strong>, so we can call <strong class="source-inline">traverseDom3C(document.body)</strong> as before. If we try out this logic, it works, but the problem of the potentially high number of pending calls hasn’t been solved; let’s look for a solution to this in the <span class="No-Break">following section.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor184"/>Trampolines and thunks</h2>
			<p>For the last solution to our problem, we shall have to think about the cause of the problem. Each pending recursive call creates a new entry stack. Whenever the stack gets too empty, the program crashes, and our algorithm is history. So, if we can work out a way to avoid stack growth, we should be free. The solution, in this case, is quite imposing and requires <em class="italic">thunks</em> and a <em class="italic">trampoline</em>—let’s see what <span class="No-Break">these are!</span></p>
			<p>First, a <strong class="bold">thunk</strong> is really<a id="_idIndexMarker772"/> quite simple: it’s just a nullary function (so, with no parameters) that<a id="_idIndexMarker773"/> helps delay a computation, providing a form of <strong class="bold">lazy evaluation</strong>. If you have a thunk, then you won’t get its value unless you call the thunk. For example, if you want <a id="_idIndexMarker774"/>to get the current date and time in ISO format, you could get it with <strong class="source-inline">new Date().toISOString()</strong>; however, if you provide a thunk that calculates that, you won’t get the value until you actually <span class="No-Break">invoke it:</span></p>
			<pre class="source-code">
// trampoline.ts
const getIsoDT = <strong class="bold">() =&gt; new Date().toISOString()</strong>; // a thunk
const isoDT = <strong class="bold">getIsoDT()</strong>; // getting the thunk's value</pre>
			<p>What’s the use of this? The problem with recursion is that a function calls itself, and calls itself, and calls itself, and so on until the stack blows over. Instead of directly calling itself, we will have the function return a thunk, which, when executed, will actually recursively call the function. So, instead of having the stack grow more and more, it will actually be quite flat since the function will never get to actually call itself; the stack will grow by one position when you call the function, and then get back to its size as soon as the function returns <span class="No-Break">its thunk.</span></p>
			<p>But who gets to do the<a id="_idIndexMarker775"/> recursion? That’s where the concept of a <strong class="bold">trampoline</strong> comes in. A trampoline<a id="_idIndexMarker776"/> is just a loop that calls a function, gets its return, and if it is a thunk, then it calls it so that recursion will proceed, but in a flat, linear way! The loop is exited when the thunk evaluation returns an actual value instead of a new function. Look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const trampoline = (fn: FN): any =&gt; {
  while (typeof fn === "function") {
    fn = fn();
  }
  return fn;
};</pre>
			<p>How can we apply this to an actual function? Let’s start with a simple one that sums all numbers from 1 to <em class="italic">n</em>, but in <a id="_idIndexMarker777"/>a recursive, guaranteed-to-cause-a-stack-crash fashion. Our simple <strong class="source-inline">sumAll()</strong> function could be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const sumAll = (n: number): number =&gt;
  n == 0 ? 0 : n + sumAll(n - 1);</pre>
			<p>However, if we start trying this function out, we’ll eventually stumble and crash, as you can see in the <span class="No-Break">following examples:</span></p>
			<pre class="source-code">
console.log(sumAll(10));
console.log(sumAll(100));
console.log(sumAll(1_000));
console.log(sumAll(10_000));
console.log(sumAll(100_000));
// Output:
55
5050
500500
50005000
<strong class="bold">RangeError: Maximum call stack size exceeded</strong></pre>
			<p>The stack problem will come up sooner or later depending on your machine, its memory size, and so on – but it will <a id="_idIndexMarker778"/>come, no doubt. Let’s rewrite the function in CPS so that it will become tail-recursive. We will apply the same technique that we saw earlier, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const sumAllC = (n: number, cont: FN): number =&gt;
  n === 0 ? cont(0) : sumAllC(n - 1, (v) =&gt; cont(v + n));</pre>
			<p>This, however, crashes as before; eventually, the stack grows too much. Let’s apply a simple rule to the code: whenever you are going to return from a call, instead, return a thunk that will, when executed, do the call that you actually wanted to do. The following code implements <span class="No-Break">that change:</span></p>
			<pre class="source-code">
// continued...
const sumAllT = (n: number, cont: FN): (() =&gt; number) =&gt;
  n === 0
    ? <strong class="bold">() =&gt; cont(0)</strong>
    : <strong class="bold">() =&gt; sumAllT(n - 1, (v) =&gt; () =&gt; cont(v + n));</strong></pre>
			<p>Whenever there would have been a call to a function, we now return a thunk. How do we get to run this function? This is the missing detail. You need an initial call that will invoke <strong class="source-inline">sumAllT()</strong> the first time, and (unless the function was called with a zero argument) a thunk will be<a id="_idIndexMarker779"/> immediately returned. The <strong class="source-inline">trampoline</strong> function will call the thunk, and that will cause a new call, and so on until we eventually get a thunk that just returns a value, and then the calculation will <span class="No-Break">be ended:</span></p>
			<pre class="source-code">
// continued...
const sumAll2 = n =&gt; trampoline(sumAllT(n, x =&gt; x));
console.log(sumAll2(1_000_000)); // no problem now!</pre>
			<p>In fact, you probably wouldn’t want a separate <strong class="source-inline">sumAllT()</strong> function, so you’d go for something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const sumAll3 = (n: number): number =&gt; {
  const sumAllT = (n: number, cont: FN) =&gt;
    n === 0
      ? () =&gt; cont(0)
      : () =&gt; sumAllT(n - 1, (v) =&gt; () =&gt; cont(v + n));
  return trampoline(sumAllT(n, (x) =&gt; x));
};
console.log(sumAll3(1_000_000)); // no stack crash</pre>
			<p>There’s only one problem left: what would we do if the result of our recursive function wasn’t a value but<a id="_idIndexMarker780"/> rather a function? The problem there would be on the <strong class="source-inline">trampoline()</strong> code that, as long as the result of the thunk evaluation is a function, goes back again and again to evaluate it. The simplest solution would be to return a thunk, but wrapped in an object, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
class Thunk {
  fn: FN;
  constructor(fn: FN) {
    this.fn = fn;
  }
}
const trampoline2 = (thk: Thunk) =&gt; {
  while (
    typeof thk === "object" &amp;&amp;
    thk.constructor.name === "Thunk"
  ) {
    thk = thk.fn();
  }
  return thk;
};</pre>
			<p>The difference now would be that, instead of returning a thunk, you’d return a <strong class="source-inline">Thunk</strong> object, so our new<a id="_idIndexMarker781"/> trampolining function can now distinguish an actual thunk (which is meant to be invoked and executed) from any other kind of result (which is meant to <span class="No-Break">be returned).</span></p>
			<p>So, if you happen to have a<a id="_idIndexMarker782"/> recursive algorithm, but it won’t run because of stack limits, you can fix it reasonably by going through the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Change all recursive calls to tail recursion <span class="No-Break">using continuations.</span></li>
				<li>Replace all <strong class="source-inline">return</strong> statements so that they’ll <span class="No-Break">return thunks.</span></li>
				<li>Replace the call to the original function with a <strong class="source-inline">trampoline</strong> call to start <span class="No-Break">the calculations.</span></li>
			</ol>
			<p>Of course, this doesn’t come for free. You’ll notice that, when using this mechanism, there’s extra work involving returning thunks, evaluating them, and so on, so you can expect the total time to go up. Nonetheless, this is a low price to pay if the alternative is having a non-working solution to <span class="No-Break">a problem!</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor185"/>Recursion elimination</h2>
			<p>There’s yet one other possibility that <a id="_idIndexMarker783"/>you might want to explore, but that falls beyond the realm of FP and into algorithm design. It’s a computer science fact that any algorithm implemented using recursion has an equivalent version that doesn’t use recursion at all, and instead depends on a stack. There are ways to systematically transform recursive algorithms into iterative ones, so if you run out of all options (that is, if not even continuations or thunks can help you), then you’d have a final opportunity to achieve your goals by replacing all recursion with iteration. We won’t be getting into this—as I said, this elimination has little to do with FP—but it’s important to know that the tool exists and that you might be able to <span class="No-Break">use it.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor186"/>Summary</h1>
			<p>In this chapter, we saw how we can use recursion, a basic tool in FP, as a powerful technique to create algorithms for problems that would probably require far more complex solutions otherwise. We started by considering what recursion is and how to think recursively in order to solve problems, then moved on to see some recursive solutions to several problems in different areas, and ended by analyzing potential problems with deep recursion and how to <span class="No-Break">solve them.</span></p>
			<p>In <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, we shall get back to a concept we saw earlier in the book, function purity, and see some techniques that will help us guarantee that a function won’t have any side effects by ensuring the immutability of arguments and <span class="No-Break">data structures.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor187"/>Questions</h1>
			<p>9.1 <strong class="bold">Into reverse</strong>: Can you program a <strong class="source-inline">reverse(str: string)</strong> function but implement it in a recursive fashion? The best way to do this would be using the standard string <strong class="source-inline">reverse()</strong> method, as detailed in <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse</a>, but that wouldn’t do for a question on recursion, <span class="No-Break">would it?</span></p>
			<p>9.2 <strong class="bold">Climbing steps</strong>: Suppose you want to climb up a ladder with <em class="italic">n</em> steps. Each time you raise your foot, you may climb up one or two rungs. In how many different ways can you climb up that ladder? For example, you can climb a four-rung ladder in five <span class="No-Break">different ways:</span></p>
			<ul>
				<li>Always take one step at <span class="No-Break">a time</span></li>
				<li>Always take two steps at <span class="No-Break">a time</span></li>
				<li>Take two steps first, then one, and <span class="No-Break">then one</span></li>
				<li>Take one step first, then two, and <span class="No-Break">then one</span></li>
				<li>Take one step first, then another one, and finish <span class="No-Break">with two</span></li>
			</ul>
			<p>9.3 <strong class="bold">Sorting recursively</strong>: Many sorting algorithms can be described with recursion; can you <span class="No-Break">implement them?</span></p>
			<ul>
				<li><strong class="bold">Selection sort</strong>: Find the maximum element of the array, remove it, recursively sort the rest, and then push the maximum element to the end of the <span class="No-Break">sorted rest</span></li>
				<li><strong class="bold">Insertion sort</strong>: Take the first element of the array, sort the rest, and finish by inserting the removed element into its correct place in the <span class="No-Break">sorted rest</span></li>
				<li><strong class="bold">Merge sort</strong>: Divide the array into two parts, sort each one, and finish by merging the two sorted parts into a <span class="No-Break">sorted list</span></li>
			</ul>
			<p>9.4 <strong class="bold">What could go wrong?</strong> A developer decided that he could write a shorter version of Quicksort. He reasoned that the pivot didn’t need special handling since it would be set into its correct place when sorting <strong class="source-inline">greaterEqual</strong>. Can you foresee any possible problems with this? The following code highlights the changes that the developer made with regard to the original version we <span class="No-Break">saw earlier:</span></p>
			<pre class="source-code">
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
    const smaller = <strong class="bold">arr.filter((x) =&gt; x &lt; pivot)</strong>;
    const greaterEqual = <strong class="bold">arr.filter((x) =&gt; x &gt;= pivot)</strong>;
    return [
<strong class="bold">      ...quicksort(smaller),</strong>
<strong class="bold">      ...quicksort(greaterEqual),</strong>
    ];
  }
};</pre>
			<p>9.5 <strong class="bold">More efficiency</strong>: Let’s make <strong class="source-inline">quicksort()</strong> more efficient by avoiding having to call <strong class="source-inline">filter()</strong> twice. Along the lines of what we saw in the <em class="italic">Calculating several values at once</em> section in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, write a <strong class="source-inline">partition(arr, pr)</strong> function that, given an <strong class="source-inline">arr</strong> array and an <strong class="source-inline">fn()</strong> predicate, will return two arrays: the values of <strong class="source-inline">arr</strong> for which <strong class="source-inline">fn</strong> is true in the first one, and the rest of the values of <strong class="source-inline">arr</strong> in the <span class="No-Break">second one:</span></p>
			<pre class="source-code">
const partition = &lt;A&gt;(
  arr: A[],
  fn: (x: A) =&gt; boolean
): [A[], A[]] =&gt; { … };
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
<strong class="bold">    const [smaller, greaterEqual] = partition(</strong>
<strong class="bold">      arr.slice(1),</strong>
<strong class="bold">      (x) =&gt; x &lt; pivot</strong>
<strong class="bold">    )</strong>;
    return [
      ...quicksort(smaller),
      pivot,
      ...quicksort(greaterEqual),
    ];
  }
};</pre>
			<p>9.6 <strong class="bold">Completing callbacks</strong>: In our <strong class="source-inline">findR()</strong> function, we did not provide all possible parameters to the <strong class="source-inline">cb()</strong> callback. Can you fix that? Your solution should be along the lines of what we did for <strong class="source-inline">map()</strong> and other functions. (And yes, if you can also allow for empty places in the array, it would be <span class="No-Break">even better.)</span></p>
			<p>9.7 <strong class="bold">Recursive logic</strong>: We didn’t get to code <strong class="source-inline">every()</strong> and <strong class="source-inline">some()</strong> using recursion: can you <span class="No-Break">do that?</span></p>
			<p>9.8 <strong class="bold">Symmetrical queens</strong>: In the eight queens puzzle we previously solved, only one solution shows symmetry in the placement of the queens. Can you modify your algorithm to <span class="No-Break">find it?</span></p>
			<p>9.9 <strong class="bold">Longest common subsequence</strong>: A classic dynamic programming problem is as follows: given two strings, find the length of the longest subsequence present in both of them. Be careful: we define a subsequence as a sequence of characters that appear in the same relative order but not necessarily next to each other. For example, the longest common subsequence of <strong class="source-inline">INTERNATIONAL</strong> and <strong class="source-inline">CONTRACTOR</strong> is <strong class="source-inline">N...T...R...A...T...O</strong>. Try it out with and without memoizing and see <span class="No-Break">the difference!</span></p>
			<p>9.10 <strong class="bold">At odds with JavaScript</strong>: This may not be a functional programming question, but in how many ways (not necessarily recursive!) can you implement <strong class="source-inline">isOdd()</strong>? There are quite <span class="No-Break">a few!</span></p>
			<p>9.11 <strong class="bold">Odds and evens trampolining</strong>: Implement <strong class="source-inline">isOdd()</strong> and <strong class="source-inline">isEven()</strong> using a trampoline to avoid stack <span class="No-Break">overflow problems.</span></p>
			<p>9.12 <strong class="bold">Mutual problem?</strong> One version I coded for <strong class="source-inline">isEven()</strong>/<strong class="source-inline">isOdd()</strong> was as follows, but it had a serious bug; can you <span class="No-Break">find it?</span></p>
			<pre class="source-code">
function isEven(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return isOdd(n - 1);
  }
}
function isOdd(n: number): boolean {
  if (n === 1) {
    return true;
  } else {
    return isEven(n - 1);
  }
}</pre>
			<p>9.13 <strong class="bold">Say no to whiles?</strong> Alternative (shorter) implementations of <strong class="source-inline">expression()</strong> and <strong class="source-inline">term()</strong>, which don’t use <strong class="source-inline">while</strong>, follow – are <span class="No-Break">they correct?</span></p>
			<pre class="source-code">
function expression(): number {
  for (let accum = term(); ; ) {
    if (tokens[curr] === PLUS) {
      curr++; // skip PLUS
      accum += term();
    } else if (tokens[curr] === MINUS) {
      curr++; // skip MINUS
      accum -= term();
    } else {
      return accum;
    }
  }
}
function term(): number {
  for (let accum = factor(); ; ) {
    if (tokens[curr] === TIMES) {
      curr++; // skip TIMES
      accum *= factor();
    } else if (tokens[curr] === DIVIDES) {
      curr++; // skip DIVIDES
      accum /= factor();
    } else if (tokens[curr] === MODULUS) {
      curr++; // skip MODULUS
      accum %= factor();
    } else {
      return accum;
    }
  }
}</pre>
			<p>9.14 <strong class="bold">Power, more power!</strong> Add the exponentiation operator, <strong class="source-inline">"^"</strong>, to our arithmetic expression evaluator. (Yes, the exponentiation operator in JavaScript is <strong class="source-inline">"**"</strong>, not <strong class="source-inline">"^"</strong>, but I wanted to have single-character tokens for simplicity.) Be sure to implement priorities correctly, and also to make the operator right-associative: <strong class="source-inline">2^3^4</strong> should be evaluated as <strong class="source-inline">(2^(3^4))</strong>, <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">((2^3)^4)</strong></span><span class="No-Break">.</span></p>
			<p>9.15 <strong class="bold">Error-prone evaluation</strong>: Our evaluation algorithm is prone to errors because it expects expressions to be syntactically valid. How can you <span class="No-Break">enhance it?</span></p>
		</div>
	</body></html>