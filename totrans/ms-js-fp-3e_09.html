<html><head></head><body>
		<div><h1 id="_idParaDest-172" class="chapter-number"><a id="_idTextAnchor172"/>9</h1>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor173"/>Designing Functions – Recursion</h1>
			<p>In <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>, we considered yet more ways to create new functions out of combining previous existing ones. Here, we will get into a different theme: how to design and write functions in a typically functional way, by applying recursive techniques.</p>
			<p>We will be covering the following topics:</p>
			<ul>
				<li>Understanding what recursion is and how to think in order to produce recursive solutions</li>
				<li>Applying recursion to some well-known problems, such as making a change or the Tower of Hanoi</li>
				<li>Using recursion instead of iteration to re-implement some higher-order functions from earlier chapters</li>
				<li>Writing search and backtrack algorithms with ease</li>
				<li>Traversing data structures, such as trees, to work with filesystem directories or with the browser DOM</li>
				<li>Understanding mutual recursion and applying it to problems such as correctly evaluating arithmetical expressions</li>
				<li>Getting around some limitations caused by browser JavaScript engine considerations</li>
			</ul>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor174"/>Using recursion</h1>
			<p>Recursion is a key<a id="_idIndexMarker673"/> technique in FP, to the degree that some languages do not provide for iterations or loops, and work exclusively with recursion (Haskell, which we already mentioned, is a prime example of that). A fundamental fact of computer science is that whatever you can do with recursion, you can do with iteration (loops), and vice versa. The key concept is that there are many algorithms whose definition is far easier if you work recursively. On the other hand, recursion is not always taught, and many programmers, even after knowing about it, prefer not to use it. Therefore, in this section, we shall see several examples of recursive thinking so that you can adapt it for<a id="_idIndexMarker674"/> your functional coding.</p>
			<p class="callout-heading">A typical, oft-quoted, and very old computer joke!</p>
			<p class="callout">Dictionary definition: <strong class="bold">recursion</strong><em class="italic">: (n) </em><em class="italic">see </em><strong class="bold">recursion</strong></p>
			<p>But what is recursion? There are many ways to define what recursion is, but the simplest one I’ve seen runs along the lines of <em class="italic">a function calling itself again and again until it doesn’t</em>. A more complex case is mutual recursion, the simplest example of which is when we have two functions, <code>A()</code> and <code>B()</code>, each of which calls the other, over and over, until they are done.</p>
			<p>Recursion is a natural technique for several kinds of problems, such as the following:</p>
			<ul>
				<li>Mathematical definitions, such as the Fibonacci sequence or the factorial of a number</li>
				<li>Data-structure-related<a id="_idIndexMarker675"/> algorithms with recursively defined structures, such as lists (a list is either empty or consists of a head node followed by a list of nodes) or trees (a tree might be defined as a special node, called the root, linked to zero or more trees)</li>
				<li>Syntax analysis for compilers based on grammar rules, which themselves depend on other rules, which also depend on other rules, and so on</li>
			</ul>
			<p>And many more! It even appears in art and humor, as shown in <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_9.1_B19301.jpg" alt="Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers, “Did you mean: recursion”"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers, “Did you mean: recursion”</p>
			<p>Apart from some easy base cases in which no further computation is required, a recursive function must call itself one or more times to perform part of the required calculations. This concept may not be very clear at this point, so in the following sections, we will<a id="_idIndexMarker676"/> see how we can think recursively and solve several common problems by applying this technique.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor175"/>Thinking recursively</h2>
			<p>The key to solving problems<a id="_idIndexMarker677"/> recursively is assuming that you already have a function that does whatever you need and just calling it. (Doesn’t this sound weird? Actually, it is quite appropriate: if you want to solve a problem with recursion, you must first have solved it before...) On the other hand, if you attempt to work out in your head how the recursive calls work and try to follow the flow, you’ll probably just get lost. So, what you need to do is the following:</p>
			<ol>
				<li>Assume you already have an appropriate function to solve your problem.</li>
				<li>See how the big problem can be solved by solving one (or more) smaller problems.</li>
				<li>Solve those problems by using the imagined function from <em class="italic">step 1</em>.</li>
				<li>Decide what your base cases are. Make sure they are simple enough that they are solved directly, without requiring more calls.</li>
			</ol>
			<p>With these points in<a id="_idIndexMarker678"/> mind, you can solve problems by recursion because you’ll have the basic structure for your recursive solution.</p>
			<p>There are three usual methods for solving problems<a id="_idIndexMarker679"/> by applying recursion:</p>
			<ul>
				<li><strong class="bold">Decrease and conquer</strong> is the <a id="_idIndexMarker680"/>simplest case, in which solving a problem directly depends on solving a single, simpler case of itself.</li>
				<li><strong class="bold">Divide and conquer</strong> is a more<a id="_idIndexMarker681"/> general approach. The idea is to try to divide your problem into two or more smaller versions, solve them recursively, and use these solutions to solve the original problem. The only difference between this technique and <em class="italic">decrease and conquer</em> is that you have to solve two or more other problems instead of only one.</li>
				<li><strong class="bold">Dynamic programming</strong> can be seen as a variant of <em class="italic">divide and conquer</em>: basically, you solve a complex <a id="_idIndexMarker682"/>problem by breaking it into a set of somewhat simpler versions of the same problem and solving each in order; however, a key idea in this strategy is to store previously found solutions, so that whenever you find yourself needing the solution to a simpler case again, you won’t directly apply recursion but, instead, use the stored result and avoid unnecessary repeated calculations.</li>
			</ul>
			<p>In this section, we shall look at a few problems and solve them by thinking recursively. Of course, we shall see more applications of recursion in the rest of the chapter; here, we’ll focus on the key decisions and questions needed to create such an algorithm.</p>
			<h3>Decrease and conquer – searching</h3>
			<p>The most usual case of recursion<a id="_idIndexMarker683"/> involves just a single, simple case. We have already seen some examples of this, such as the ubiquitous factorial calculation: to calculate the factorial of <em class="italic">n</em>, you previously needed to calculate the factorial of <em class="italic">n</em>-1. (See <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>.) Let’s turn now to a non-mathematical example.</p>
			<p>You would also use this decrease-and-conquer strategy to search for an element in an array. If the array is empty, then obviously the searched-for value isn’t there; otherwise, the result is in the array if, and only if, it’s the array’s first element or if it’s in the rest of the array. The following <a id="_idIndexMarker684"/>code does just that:</p>
			<pre class="source-code">
// search.ts
const search = &lt;A&gt;(arr: A[], key: A): boolean =&gt; {
  if (arr.length === 0) {
    return false;
  } else if (arr[0] === key) {
    return true;
  } else {
    return search(arr.slice(1), key);
  }
};</pre>
			<p>This implementation directly mirrors our explanation, and verifying its correctness is easy.</p>
			<p>By the way, just as a precaution, let’s look at two further implementations of the same concept. You can shorten the search function a bit—is it still clear?</p>
			<p>We are using a ternary operator to detect whether the array is empty, and a Boolean <code>||</code> operator to return <code>true</code> if the first element is the sought one or else return the result of the recursive search:</p>
			<pre class="source-code">
// continued...
const search2 = &lt;A&gt;(arr: A[], key: A): boolean =&gt;
  arr.length === 0
    ? false
    : arr[0] === key || search2(arr.slice(1), key);</pre>
			<p>Sparseness can go even further! Using <code>&amp;&amp;</code> as a shortcut is a common idiom:</p>
			<pre class="source-code">
// continued...
const search3 = &lt;A&gt;(arr: A[], key: A): boolean =&gt;
  !!arr.length &amp;&amp;
  (arr[0] === key || search3(arr.slice(1), key));</pre>
			<p>I’m not really suggesting that you code the function in this way—instead, consider it a warning against the tendency that some FP developers have to try to go for the tightest, shortest possible solution <a id="_idIndexMarker685"/>and never mind clarity!</p>
			<h3>Decrease and conquer – doing powers</h3>
			<p>Another classic example has to <a id="_idIndexMarker686"/>do with efficiently calculating powers of numbers. If you want to calculate, say, 2 to the 13th power (213), then you can do this with 12 multiplications; however, you can do much better by writing 213 as the following:</p>
			<p>= 2 times 212</p>
			<p>= 2 times 46</p>
			<p>= 2 times 163</p>
			<p>= 2 times 16 times 162</p>
			<p>= 2 times 16 times 2561</p>
			<p>= 8192</p>
			<p>This reduction in the total number of multiplications may not look very impressive, but in terms of algorithmic complexity, it allows us to bring down the order of the calculations from O(<em class="italic">n</em>) to O(<em class="italic">log n</em>). In some cryptographic-related methods, which have to raise numbers to really high exponents, this makes a significant difference. We can implement this recursive algorithm in a few lines of code, as shown in the following code:</p>
			<pre class="source-code">
// power.ts
const powerN = (base: number, power: number): number =&gt; {
  if (power === 0) {
    return 1;
  } else if (power % 2) {
    // odd power?
    return base * powerN(base, power - 1);
  } else {
    // even power?
    return powerN(base * base, power / 2);
  }
};</pre>
			<p class="callout-heading">Extra speed</p>
			<p class="callout">When implemented for production, bit operations are used instead of modulus and divisions. Checking whether a number is odd can be written as <code>power &amp; 1</code>, and division by 2 is achieved with <code>power &gt;&gt; 1</code>. These alternative calculations are way faster than the replaced operations.</p>
			<p>Calculating a power<a id="_idIndexMarker687"/> is simple when the base case is reached (raising something to the zeroth power) or based on a previously calculated power for a smaller exponent. (If you wanted to, you could add another base case for raising something to the power of one.) These observations show that we are seeing a textbook case for the decrease and conquer recursive strategy.</p>
			<p>Finally, some of our higher-order functions, such as <code>map()</code>, <code>reduce()</code>, and <code>filter()</code>, also apply this technique; we’ll look into this later on in this chapter.</p>
			<h3>Divide and conquer – the Tower of Hanoi</h3>
			<p>With the divide-and-conquer strategy, solving a problem requires two or more recursive solutions. For starters, let’s <a id="_idIndexMarker688"/>consider a classic puzzle invented by a French mathematician, Édouard Lucas, in the 19th century. The puzzle involves a temple in India, with 3 posts, the first of them with 64 golden disks of decreasing<a id="_idIndexMarker689"/> diameter. The priests have to move the disks from the first post to the last one following two rules: only one disk can be moved at a time, and a larger disk can never be placed on top of a smaller disk. According to the legend, when the 64 disks are moved, the world will end. This puzzle is usually marketed under the <em class="italic">Tower of Hanoi</em> name (yes, they changed countries!) with fewer than 10 disks. See <em class="italic">Figure 9</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/Figure_9.2_B19301.jpg" alt="Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution</p>
			<p class="callout-heading">A long, long time…</p>
			<p class="callout">The solution for <em class="italic">n</em> disks requires 2n-1 movements. The original puzzle, requiring 264-1 movements, at one movement per second, would take more than 584 billion years to finish – a very long time, considering that the universe’s age is evaluated to only be 13.8 billion years!</p>
			<p>Suppose we already <a id="_idIndexMarker690"/>have a function that solves the problem of moving any number of disks from a source post to a destination post using the remaining post as an extra aid. Think about solving the general problem if you already had a function to solve that problem: <code>hanoi(disks, from, to, extra)</code>. If you wanted to move several disks from one post to another, then <a id="_idIndexMarker691"/>you could solve it using this (still unwritten!) function by carrying out the following steps:</p>
			<ol>
				<li value="1">Moving all of the disks but the last one to the extra post.</li>
				<li>Moving the last disk to the destination post.</li>
				<li>Moving all the disks from the extra post (where you had placed them earlier) to the destination.</li>
			</ol>
			<p>But what about our base cases? We could decide that to move a single disk, you don’t need the function; you just go ahead and move the disk. When coded, it becomes the following:</p>
			<pre class="source-code">
// hanoi.ts
const hanoi = (
  disks: number,
  from: Post,
  to: Post,
  extra: Post
) =&gt; {
  if (disks === 1) {
    console.log(
      `Move disk 1 from post ${from} to post ${to}`
    );
  } else {
    hanoi(disks - 1, from, extra, to);
    console.log(
      `Move disk ${disks} from post ${from} to post ${to}`
    );
    hanoi(disks - 1, extra, to, from);
  }
};</pre>
			<p>Using the <code>Post</code> type<a id="_idIndexMarker692"/> is possibly not needed, but <a id="_idIndexMarker693"/>good practice anyway. We can quickly verify that this code works:</p>
			<pre class="source-code">
<strong class="bold">hanoi (4, "A", "B", "C")</strong>;
// move all disks from A to B
Move disk 1 from post A to post C
Move disk 2 from post A to post B
Move disk 1 from post C to post B
Move disk 3 from post A to post C
Move disk 1 from post B to post A
Move disk 2 from post B to post C
Move disk 1 from post A to post C
Move disk 4 from post A to post B
Move disk 1 from post C to post B
Move disk 2 from post C to post A
Move disk 1 from post B to post A
Move disk 3 from post C to post B
Move disk 1 from post A to post C
Move disk 2 from post A to post B
Move disk 1 from post C to post B</pre>
			<p>There’s only a small detail to consider, which can simplify the function further. In this code, our base case (the one that<a id="_idIndexMarker694"/> needs no further recursion) is when <code>disks</code> equals one. You could also solve <a id="_idIndexMarker695"/>this differently by letting the disks go down to zero and simply not doing anything—after all, moving zero disks from one post to another is achieved by doing nothing at all! The revised code would be as follows:</p>
			<pre class="source-code">
// continued...
const hanoi2 = (
  disks: number,
  from: Post,
  to: Post,
  extra: Post
) =&gt; {
  if (disks &gt; 0) {
    hanoi(disks - 1, from, extra, to);
    console.log(
      `Move disk ${disks} from post ${from} to post ${to}`
    );
    hanoi(disks - 1, extra, to, from);
  }
};</pre>
			<p>Instead of checking whether there are any disks to move before doing the recursive call, we can just skip the check and have the function test, at the next level, whether there’s something to be done.</p>
			<p class="callout-heading">Hanoi by hand</p>
			<p class="callout">If you are doing the puzzle by hand, there’s a simple solution for that: on odd turns, always move the smaller disk to the next post (if the total number of disks is odd) or to the previous post (if the total number of disks is even). On even turns, make the only possible move that doesn’t involve the smaller disk.</p>
			<p>So, the principle for recursive algorithm design works: assume you already have your desired function and use it to build itself!</p>
			<h3>Divide and conquer – sorting</h3>
			<p>We can see another example of the divide-and-conquer strategy with sorting. A way to sort arrays, called<a id="_idIndexMarker696"/> Quicksort, is based upon the following steps:</p>
			<ol>
				<li value="1">If your array has 0 or 1 element(s), do nothing; it’s already sorted (this is the base case).</li>
				<li>Pick an element of the array (called the pivot) and split the rest of the array into two subarrays: the elements smaller than your chosen element and the elements greater than or equal to your chosen element.</li>
				<li>Recursively sort each subarray.</li>
				<li>To produce the sorted version of the original array, concatenate both sorted results, with the pivot in between.</li>
			</ol>
			<p>Let’s see a simple version of this (there are some better-optimized implementations, but we are interested in the recursive logic now). Usually, picking a random element of the array is suggested to avoid some bad performance border cases, but for our example, let’s just take the first one:</p>
			<pre class="source-code">
// quicksort.ts
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
    const smaller = arr.slice(1).filter((x) =&gt; x &lt; pivot);
    const greaterEqual = arr
      .slice(1)
      .filter((x) =&gt; x &gt;= pivot);
    return [
      ...quicksort(smaller),
      pivot,
      ...quicksort(greaterEqual),
    ];
  }
};
console.log(quicksort([22, 9, 60, 12, 4, 56]));
// <strong class="bold">[4, 9, 12, 22, 56, 60]</strong></pre>
			<p>We can see how this <a id="_idIndexMarker697"/>works in <em class="italic">Figure 9</em><em class="italic">.3</em>: the pivot for each array and subarray is underlined. Splitting is shown with dotted arrows and is joined with full lines:</p>
			<div><div><img src="img/Figure_9.3_B19301.jpg" alt="Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer strategy to reduce the original problem to smaller ones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer strategy to reduce the original problem to smaller ones</p>
			<p class="callout-heading">Easy-to-get bug!</p>
			<p class="callout">Writing Quicksort correctly is not trivial; see <em class="italic">Question 9.8</em> at the end of this chapter for an alternative version that is <em class="italic">almost </em>right, but not totally correct!</p>
			<p>We have already seen the basic strategies to reduce a problem to simpler versions of itself. Let’s now look at an important optimization, a key for many algorithms.</p>
			<h3>Dynamic programming – making change</h3>
			<p>The third general strategy, <em class="italic">dynamic programming</em>, assumes that you will have to solve many smaller problems, but instead of using recursion every time, it depends on you having stored the previously found <a id="_idIndexMarker698"/>solutions – <em class="italic">memoization</em>, in other words! In <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, and later, in a better <a id="_idIndexMarker699"/>fashion, in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we already saw how to optimize the calculations of the usual Fibonacci series, avoiding unnecessary repeated calls. Let’s now consider another problem.</p>
			<p>Given a certain number of dollars and the list of existing bill values, calculate how many different ways we can pay that amount of dollars with different combinations of bills. It is assumed that you have access to an unlimited number of each bill. How can we go about solving this? Let’s start by considering the base cases where no further computation is needed. They are as follows:</p>
			<ul>
				<li>Paying negative values is not possible, so in such cases, we should return <code>0</code></li>
				<li>Paying zero dollars is only possible in a single way (by giving no bills), so in this case, we should return <code>1</code></li>
				<li>Paying any positive amount of dollars isn’t possible if no bills are provided, so in this case, also return <code>0</code></li>
			</ul>
			<p>Finally, we can answer the question: in how many ways can we pay <em class="italic">N</em> dollars with a given set of bills? We can consider two cases: we do not use the larger bill at all and pay the amount using only smaller denomination bills, or we can take one bill of the larger amount and reconsider the question. (Let’s forget the avoidance of repeated calculations for now.)</p>
			<p>In the first case, we should invoke our supposedly existing function with the same value of <em class="italic">N</em> but prune the largest bill denomination from the list of available bills.</p>
			<p>In the second case, we should invoke our function with <em class="italic">N</em> minus the largest bill denomination, keeping the list of bills the same, as shown in the following code:</p>
			<pre class="source-code">
// makeChange.ts
const makeChange = (n: number, bills: number[]): number =&gt; {
  if (n &lt; 0) {
    return 0; // no way of paying negative amounts
  } else if (n == 0) {
    return 1; // one single way of paying $0: with no bills
  } else if (bills.length == 0) {
    // here, n&gt;0
    return 0; // no bills? no way of paying
  } else {
    return (
      makeChange(n, bills.slice(1)) +
      makeChange(n - bills[0], bills)
    );
  }
};
console.log(makeChange(64, [100, 50, 20, 10, 5, 2, 1]));
// 969 ways of paying $64</pre>
			<p>Now, let’s do some <a id="_idIndexMarker700"/>optimization. This algorithm often needs to recalculate the same values over and over. (To verify this, add <code>console.log(n, bills.length)</code> as the first line in <code>makeChange()</code>—but be ready for plenty of output!) However, we already have a solution for this: memoization! Since we are applying this technique to a binary function, we’ll need a version of the memoization algorithm that deals with more than one parameter. We saw that in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, </em><em class="italic">Producing Functions</em>:</p>
			<pre class="source-code">
// continued...
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;string, ReturnType&lt;T&gt;&gt;;
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};
const makeChange = <strong class="bold">memoize4(</strong>(n, bills) =&gt; {
// ...same as above
}<strong class="bold">);</strong></pre>
			<p>The memoized version of <code>makeChange()</code> is far more efficient, and you can verify it with logging. While it is certainly possible to deal with the repetitions by yourself (for example, by keeping<a id="_idIndexMarker701"/> an array of already computed values), the memoization solution is, in my opinion, better because it composes two functions to produce a better solution for the given problem.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor176"/>Higher-order functions revisited</h2>
			<p>Classic FP techniques do not use<a id="_idIndexMarker702"/> iteration at all but work exclusively with recursion as the only way to do some looping. Let’s revisit some of the functions that we have already seen in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, such as <code>map()</code>, <code>reduce()</code>, <code>find()</code>, and <code>filter()</code>, to see how we can make do with just recursion.</p>
			<p>We are not planning to exchange the basic JavaScript functions for ours, though: it’s likely that performance will be worse for our recursive polyfills, and we won’t derive any advantages just from having the functions use recursion. Instead, we want to study how iterations are performed in a recursive way so that our efforts are more pedagogical than practical, OK?</p>
			<h3>Mapping and filtering</h3>
			<p>Mapping and filtering are quite similar insofar as both imply going through all the elements in an array and <a id="_idIndexMarker703"/>applying a callback to each to produce output. Let’s first work out the<a id="_idIndexMarker704"/> mapping logic, which will have several points to solve, and then we should see that filtering has become almost trivially easy, requiring just small changes.</p>
			<p>For mapping, given how we are developing recursive functions, we need a base case. Fortunately, that’s easy: mapping an empty array produces a new empty array. Mapping a non-empty array can be done by first applying the mapping function to the first element of the array, then recursively mapping the rest of the array, and finally, producing a single array accumulating both results.</p>
			<p>Based on this idea, we can work out a simple initial version: let’s call it <code>mapR()</code>, just to remember that we are dealing with our own, recursive version of <code>map()</code>; however, be careful – our polyfill has some bugs! We’ll deal with them one at a time. Here’s our first attempt at writing our own <a id="_idIndexMarker705"/>mapping code:</p>
			<pre class="source-code">
// map.ts
const mapR = &lt;A, B&gt;(arr: A[], cb: (x: A) =&gt; B): B[] =&gt;
  arr.length === 0
    ? []
    : [cb(arr[0])].concat(mapR(arr.slice(1), cb));</pre>
			<p>Let’s test it<a id="_idIndexMarker706"/> out:</p>
			<pre class="source-code">
const aaa = [1, 2, 4, 5, 7];
const timesTen = (x: number): number =&gt; x * 10;
console.log(aaa.map(timesTen));   // [10, 20, 40, 50, 70]
console.log(mapR(aaa, timesTen)); // [10, 20, 40, 50, 70]</pre>
			<p>Great! Our <code>mapR()</code> function seemingly produces the same results as <code>map()</code>. However, shouldn’t our callback function receive a couple more parameters, specifically the index at the array and the original array itself? (Check out the definition for the callback function for <code>map()</code> at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a>.)</p>
			<p>Our implementation isn’t quite ready yet. Let’s first see how it fails by using a simple example:</p>
			<pre class="source-code">
const timesTenPlusI = (v: number, i: number) =&gt; 10 * v + i;
console.log(aaa.map(timesTenPlusI)); // [10, 21, 42, 53,
  74]
console.log(mapR(aaa, timesTenPlusI));</pre>
			<p>If you were working with JavaScript, the last call would produce <code>[NaN, NaN, NaN, NaN, NaN]</code> – TypeScript detects the error because the type of <code>timesTenPlusI()</code> is wrong:</p>
			<pre class="console">
Argument of type '(v: number, i: number) =&gt; number' is not assignable to parameter of type '(x: number) =&gt; number'.</pre>
			<p>Generating the appropriate index position will require an extra parameter for the recursion. Still, it is basically simple: when we start out, we have <code>index=0</code>, and when we call our function<a id="_idIndexMarker707"/> recursively, it’s with the <code>index+1</code> position. Accessing the original array requires yet<a id="_idIndexMarker708"/> another parameter, which will never change, and now we have a better mapping function:</p>
			<pre class="source-code">
// continued...
const mapR2 = &lt;A, B&gt;(
  arr: A[],
  cb: (x: A, i: number, arr: A[]) =&gt; B,
  i = 0,
  orig = arr
): B[] =&gt;
  arr.length == 0
    ? []
    : [cb(arr[0], i, orig)].concat(
        <strong class="bold">mapR2(arr.slice(1), cb, i + 1, orig)</strong>
      );
const senseless = (
  x: number,
  i: number,
  a: number[]
): number =&gt; x * 10 + i + a[i] / 10;
console.log(aaa.map(senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong>
console.log(mapR2(aaa, senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong></pre>
			<p>Great! When you do recursion instead of iteration, you don’t have access to an index, so if you need it (as in our case), you’ll have to generate it on your own. This is an often-used technique, so working out our <code>map()</code> substitute was a good idea.</p>
			<p>However, having extra arguments in the function is not so good; a developer might accidentally provide them and the results would be unpredictable. So, using another usual technique, let’s define an inner function, <code>mapLoop()</code>, to handle looping. This is, in fact, the usual way in which looping is achieved when you only use recursion; look at the following code, in which the extra function isn’t accessible from outside:</p>
			<pre class="source-code">
// continued...
const mapR3 = &lt;A, B&gt;(
  orig: A[],
  cb: (x: A, i: number, a: A[]) =&gt; B
): B[] =&gt; {
  <strong class="bold">const mapLoop</strong> = (arr: A[], i: number): B[] =&gt;
    arr.length == 0
      ? []
      : [cb(arr[0], i, orig)].concat(
          <strong class="bold">mapLoop(arr.slice(1), i + 1)</strong>
        );
  return mapLoop(orig, 0);
};
console.log(mapR3(aaa, senseless));
// <strong class="bold">[10.1, 21.2, 42.4, 53.5, 74.7]</strong>, again</pre>
			<p>There’s only one <a id="_idIndexMarker709"/>pending issue: if the original array has some missing elements, they should <a id="_idIndexMarker710"/>be skipped during the loop. Let’s look at an example, in plain JavaScript:</p>
			<pre class="source-code">
[1, 2, , , 5].map(tenTimes)
// [10, 20, undefined × 2, 50]</pre>
			<p>(Why just JavaScript? TypeScript would object because the array to be processed had <code>number | undefined</code> types, but <code>timesTen()</code> expects an array with just <code>number</code> types. By the way, I also had to disable ESLint’s <code>no-sparse-array</code> rule, which catches accidental extra commas in arrays.)</p>
			<p>Fortunately, fixing this is simple—and be glad that all the experience gained here will help us write the other functions in this section! Can you understand the fix in the following code, apart from the obvious changes to allow values in arrays to be <code>undefined</code>, for which I used an auxiliary <code>Opt&lt;&gt;</code> type definition?</p>
			<pre class="source-code">
// continued...
<strong class="bold">type Opt&lt;X&gt; = X | undefined;</strong>
const mapR4 = &lt;A, B&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; B
): Opt&lt;B&gt;[] =&gt; {
  const mapLoop = (arr: Opt&lt;A&gt;[], i: number): Opt&lt;B&gt;[] =&gt;
    arr.length == 0
      ? []
<strong class="bold">      : !(0 in arr) || arr[0] === undefined</strong>
<strong class="bold">      ? ([,] as Opt&lt;B&gt;[]).concat(</strong>
<strong class="bold">          mapLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">        )</strong>
<strong class="bold">      : ([cb(arr[0] as A, i, orig)] as Opt&lt;B&gt;[]).concat(</strong>
<strong class="bold">          mapLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">        );</strong>
  return mapLoop(orig, 0);
};</pre>
			<p>Wow! This was more than we bargained for, but we saw several techniques: how to replace iteration with<a id="_idIndexMarker711"/> recursion, how to accumulate a result across iterations, and how to generate and <a id="_idIndexMarker712"/>provide the index value—good tips! Furthermore, writing filtering code will prove much easier since we’ll be able to apply very much the same logic as we did for mapping. The main difference is that we use the callback function to decide whether an element goes into the output array, so the inner loop function is a tad longer:</p>
			<pre class="source-code">
// filter.ts
type Opt&lt;X&gt; = X | undefined;
const filterR = &lt;A&gt;(
  orig: Opt&lt;A&gt;[],
  cb: (x: A, i: number, a: Opt&lt;A&gt;[]) =&gt; boolean
): A[] =&gt; {
  const filterLoop = (arr: Opt&lt;A&gt;[], i: number): A[] =&gt;
    arr.length == 0
      ? []
<strong class="bold">      : !(0 in arr) ||</strong>
<strong class="bold">        arr[0] === undefined ||</strong>
<strong class="bold">        !cb(arr[0] as A, i, orig)</strong>
<strong class="bold">      ? filterLoop(arr.slice(1), i + 1)</strong>
<strong class="bold">      : ([arr[0]] as A[]).concat(</strong>
<strong class="bold">          filterLoop(arr.slice(1), i + 1) as A[]</strong>
<strong class="bold">        );</strong>
  return filterLoop(orig, 0);
};</pre>
			<p>Okay, we <a id="_idIndexMarker713"/>managed to implement two of our basic higher-order functions with similar<a id="_idIndexMarker714"/> recursive functions. What about the others?</p>
			<h3>Other higher-order functions</h3>
			<p>Programming <code>reduce()</code> is, from the outset, a bit trickier, since you can decide to omit the initial value for the accumulator. Since we mentioned earlier that providing that value is generally better, let’s work here under the assumption that it will be given; dealing with the other possibility won’t be too hard.</p>
			<p>The base case is simple: if the array is empty, the result is the accumulator; otherwise, we must apply the <code>reduce</code> function to the<a id="_idIndexMarker715"/> current element and the accumulator, update the latter, and then continue working with the rest of the array. This can be a bit confusing because of the ternary operators, but it should be clear enough after all we’ve seen. Look at the following code for the details:</p>
			<pre class="source-code">
// reduce.ts
const reduceR = &lt;A, B&gt;(
  orig: A[],
  cb: (acc: B, x: A, i: number, a: A[]) =&gt; B,
  accum: B
) =&gt; {
  const reduceLoop = (arr: A[], accum: B, i: number): B =&gt;
    arr.length == 0
      ? accum
      : !(0 in arr) || arr[0] === undefined
      ? reduceLoop(arr.slice(1), accum, i + 1)
      : reduceLoop(
          arr.slice(1),
          cb(accum, arr[0], i, orig),
          i + 1
        );
  return reduceLoop(orig, accum, 0);
};
let bbb = [1, 2, , 5, 7, 8, 10, 21, 40];
console.log(bbb.reduce((x, y) =&gt; x + y, 0));   // 94
console.log(reduce2(bbb, (x, y) =&gt; x + y, 0)); // 94</pre>
			<p>On the other hand, <code>find()</code> is particularly apt for recursive logic since the very definition of how you (attempt to) find <a id="_idIndexMarker716"/>something is recursive in itself:</p>
			<ul>
				<li>You look at the first place you think of, and if you find what you were seeking, you are done</li>
				<li>Alternatively, you look at the other places to see whether what you seek is there</li>
			</ul>
			<p>We are only missing the base case, but that’s simple, and we already saw this earlier in the chapter – if you have no places left to search, then you know you won’t be successful in your search:</p>
			<pre class="source-code">
// find.ts
const findR = &lt;A&gt;(
  arr: A[],
  cb: (x: A) =&gt; boolean
): Opt&lt;A&gt; =&gt;
  arr.length === 0
    ? undefined
    : cb(arr[0])
    ? arr[0]
    : findR(arr.slice(1), cb);</pre>
			<p>We can quickly verify whether this works:</p>
			<pre class="source-code">
let aaa = [1, 12, , , 5, 22, 9, 60];
const isTwentySomething = x =&gt; 20 &lt;= x &amp;&amp; x &lt;= 29; console.log(findR(aaa, isTwentySomething)); // 22
const isThirtySomething = x =&gt; 30 &lt;= x &amp;&amp; x &lt;= 39; console.log(findR(aaa, isThirtySomething)); // undefined</pre>
			<p>Let’s finish with our pipelining function. The definition of a pipeline lends itself to quick implementation:</p>
			<ul>
				<li>If we want to pipeline a single function, then that’s the result of the pipeline</li>
				<li>If we want to pipeline several functions, we must first apply the initial function and then pass that result as input to the pipeline of the other functions</li>
			</ul>
			<p>We can directly turn this<a id="_idIndexMarker717"/> into code:</p>
			<pre class="source-code">
function pipelineR&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Pipeline&lt;FNS&gt;;
function pipelineR&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return fns.length === 1
    ? fns[0]
    : (...args) =&gt;
        pipelineR(...fns.slice(1))(fns[0](...args));
}</pre>
			<p>We can verify its correctness with a simple example. Let’s pipeline several calls to a couple of functions, one of which just adds 1 to its argument and the other of which multiplies by 10:</p>
			<pre class="source-code">
const plus1 = (x: number): number =&gt; x + 1;
const by10 = (x: number): number =&gt; x * 10;
pipelineR(
  by10,
  plus1,
  plus1,
  plus1,
  by10,
  plus1,
  by10,
  by10,
  plus1,
  plus1,
  plus1
)(2);
// 23103</pre>
			<p>If you follow the math, you’ll be able to check that the pipelining is working fine. We could have a slightly different recursive call if we take the base case to be when no functions are provided:</p>
			<pre class="source-code">
// continued...
function pipelineR2&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): Pipeline&lt;FNS&gt;;
function pipelineR2&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return <strong class="bold">fns.length === 0</strong>
<strong class="bold">    ? (...args) =&gt; args[0]</strong>
    : (...args) =&gt;
        pipelineR2(...fns.slice(1))(fns[0](...args));
}</pre>
			<p>In any case, these<a id="_idIndexMarker718"/> pipelines won’t work in TypeScript because our <code>Pipeline&lt;&gt;</code> type definition won’t allow for an empty set of functions – can you fix that?</p>
			<p>Doing the same for composition is easy, except that you cannot use the spread operator to simplify the function definition, and you’ll have to work with array indices—work it out!</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/>Searching and backtracking</h2>
			<p>Searching for solutions to problems, especially when there is no direct algorithm and you must resort to trial and error, is particularly appropriate for recursion. Many of these algorithms fall into a<a id="_idIndexMarker719"/> scheme such as the following:</p>
			<ul>
				<li>Out of many choices available, pick one. If no options are available, you’ve failed.</li>
				<li>If you could pick one, apply the same algorithm, but find a solution to the rest.</li>
				<li>If you succeed, you are done. Otherwise, try another choice.</li>
			</ul>
			<p>You can apply similar logic with minor variations to find a good—or possibly, optimum—solution to a given problem. Each time you find a possible solution, you match it with previous ones that you might have found and decide which to keep. This may continue until all possible solutions are evaluated or until a good enough solution has been found.</p>
			<p>There are many problems to which this logic applies. They are as follows:</p>
			<ul>
				<li><em class="italic">Finding a way out of mazes</em>—pick any path, mark it as already followed, and try to find a way out of the maze that won’t reuse that path: if you succeed, you are done, and if you do not, go back to pick a different path</li>
				<li><em class="italic">Filling out Sudoku puzzles</em>—if an empty cell can contain only a single number, then assign it; otherwise, run through<a id="_idIndexMarker720"/> all of the possible assignments, and for each one, recursively try to see whether the rest of the puzzle can be filled out</li>
				<li><em class="italic">Playing chess</em>—where you aren’t likely to be able to follow through all possible move sequences, so you opt for the best-estimated position instead</li>
			</ul>
			<p>Let’s apply these techniques to two problems: solving the eight queens puzzle and traversing a complete file directory.</p>
			<h3>The eight queens puzzle</h3>
			<p>The eight queens puzzle was invented in the 19th century and involves <a id="_idIndexMarker721"/>placing eight chess queens on a standard chessboard. The restriction is that no queen should be able to attack another—implying that no pair of queens may share a row, column, or diagonal line. The puzzle may ask for any solution or the total number of distinct solutions, which we will attempt to find.</p>
			<p class="callout-heading">The <em class="italic">n</em> queens variation</p>
			<p class="callout">The puzzle may also be <a id="_idIndexMarker722"/>generalized to <em class="italic">n</em> queens by working on an <em class="italic">n</em>x<em class="italic">n</em> square board. It is known that there are solutions for all values of <em class="italic">n</em>, except <em class="italic">n</em>=2 (pretty simple to see why: after placing one queen, all of the board is threatened) and <em class="italic">n</em>=3 (if you place a queen in the center, all of the board is threatened, and if you place a queen on a side, only two squares are not threatened, but they threaten each other, making it impossible to place queens on them).</p>
			<p>Let’s start our solution with top-level logic. Because of the given rules, there will be a single queen in each column, so we use a <code>places</code> array to take note of each queen’s row within the given column. The <code>SIZE</code> constant could be modified to solve a more general problem. We’ll count each found distribution of queens in the <code>solutions</code> variable. Finally, the <code>finder()</code> function will perform the recursive search for solutions. The basic skeleton for the <a id="_idIndexMarker723"/>code would be as follows:</p>
			<pre class="source-code">
// queens.ts
const SIZE = 8;
const places = Array(SIZE);
let solutions = 0;
finder();
console.log(`Solutions found: ${solutions}`);</pre>
			<p>Let’s get into the required logic. When we want to place a queen in a given row and column, we must check whether any of the previously placed queens were placed on the same row or in a diagonal leading from the row. See <em class="italic">Figure 9</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/Figure_9.4_B19301.jpg" alt="Figure 9.4 – Before placing a queen in a column, we must check the previously placed queens’ positions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Before placing a queen in a column, we must check the previously placed queens’ positions</p>
			<p>Let’s write a <code>checkPlace(column, row)</code> function to verify whether a queen can be safely placed in the given square. The most straightforward way is by using <code>every()</code>, as shown in the following code:</p>
			<pre class="source-code">
// continued...
const checkPlace = (column: number, row: number): boolean =&gt;
  places
    .slice(0, column)
    .every(
      (v, i) =&gt;
        v !== row &amp;&amp; Math.abs(v - row) !== column - i
    );</pre>
			<p>This declarative fashion seems best: when we place a queen in a position, we want to ensure that every other previously placed queen is in a different row and diagonal. A recursive solution<a id="_idIndexMarker724"/> would have been possible too, so let’s see that. How do we know that a square is safe?</p>
			<ul>
				<li>A base case is when there are no more columns to check, the square is safe</li>
				<li>If the square is in the same row or diagonal as any other queen, it’s not safe</li>
				<li>If we have checked a column and found no problem, we can now recursively check the following one</li>
			</ul>
			<p>The required alternative code to check whether a position in a column can be occupied by a queen is, therefore, as follows:</p>
			<pre class="source-code">
// continued...
const checkR = (column: number, row: number): boolean =&gt; {
  const checkColumn = (i: number): boolean =&gt; {
    if (i == column) {
      return true;
    } else if (
      places[i] == row ||
      Math.abs(places[i] - row) == column - i
    ) {
      return false;
    } else {
      return checkColumn(i + 1);
    }
  };
  return checkColumn(0);
};</pre>
			<p>The code works, but I wouldn’t use it since the declarative version is clearer. Anyway, having worked out this check, we can pay attention to the main <code>finder()</code> logic, which will do the recursive search. The process proceeds as we described at the beginning: try out a possible placement for a queen, and if that is acceptable, use the same search procedure to try and<a id="_idIndexMarker725"/> place the remaining queens. We start at column 0, and our base case is when we reach the last column, meaning that all queens have been successfully placed: we can print out the solution, count it, and go back to search for a new configuration.</p>
			<p class="callout-heading">Getting nice output</p>
			<p class="callout">Check out how we use <code>map()</code> and a simple arrow function to print the rows of the queens, column by column, as numbers between 1 and 8, instead of 0 and 7. In chess, rows are numbered from 1 to 8 (and columns from a to h, but that doesn’t matter here).</p>
			<p>Check out the following code, which applies the logic that we described previously:</p>
			<pre class="source-code">
// continued...
const finder = (column = 0) =&gt; {
  if (column === SIZE) {
    // all columns tried out?
    // if so, print and count solution
    console.log(JSON.stringify(places.map((x) =&gt; x + 1)));
    solutions++;
  } else {
    const testRowsInColumn = (j: number) =&gt; {
      if (j &lt; SIZE) {
        if (checkR(column, j)) {
          places[column] = j;
          finder(column + 1);
        }
        testRowsInColumn(j + 1);
      }
    };
    testRowsInColumn(0);
  }
};</pre>
			<p>The inner <code>testRowsInColumn()</code> function also fulfills an iterative role, but recursively. The idea is to attempt placing a queen in every possible row, starting at zero: if the square is safe, <code>finder()</code> is called to start searching from the next column onward. No matter whether a solution was or wasn’t found, all rows in the column are tried out because we are interested in the total number of solutions. In other search problems, you might<a id="_idIndexMarker726"/> be content with finding any solution, and you would stop your search there.</p>
			<p>We have come this far, so let’s find the answer to our problem!</p>
			<pre class="console">
[1,5,8,6,3,7,2,4]
[1,6,8,3,7,4,2,5]
[1,7,4,6,8,2,5,3]
[1,7,5,8,2,4,6,3]
[2,4,6,8,3,1,7,5]
[2,5,7,1,3,8,6,4]
[2,5,7,4,1,8,6,3]
[2,6,1,7,4,8,3,5]
   ...
   ... 70 lines snipped out
   ...
[8,2,4,1,7,5,3,6]
[8,2,5,3,1,7,4,6]
[8,3,1,6,2,5,7,4]
[8,4,1,3,6,2,7,5]
Solutions found: 92</pre>
			<p>Each solution is given as the row positions for the queens, column by column, and there are 92 solutions in all.</p>
			<h3>Traversing a tree structure</h3>
			<p>Data structures, which include recursion in their definition, are naturally appropriate for recursive techniques. Let’s consider, for<a id="_idIndexMarker727"/> example, how to traverse a complete filesystem directory, listing all of its contents. Where’s the recursion? The answer is straightforward if you consider that each directory can do either of the following:</p>
			<ul>
				<li>Be empty—a base case in which there’s nothing to do</li>
				<li>Include one or more entries, each of which is either a file or a directory itself</li>
			</ul>
			<p>Let’s work out a full recursive directory listing—meaning that when we encounter a directory, we also list its contents, and if those include more directories, we also list them, and so on. We’ll be using the same node functions as in <code>getDir()</code> (from the <em class="italic">Building pipelines by hand</em> section in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a><em class="italic">, Connecting Functions</em>), plus a few more to test whether a directory entry is a symbolic link (which we won’t follow to avoid possible infinite loops), a directory (which will require a recursive listing), or a common file:</p>
			<pre class="source-code">
// directory.ts
import * as fs from "fs";
<strong class="bold">const recursiveDir = (path: string) =&gt;</strong> {
  console.log(path);
  fs.readdirSync(path).forEach((entry) =&gt; {
    if (entry.startsWith(".")) {
      // skip it!
    } else {
      const full = path + "/" + entry;
      const stats = fs.lstatSync(full);
      if (stats.isSymbolicLink()) {
        console.log("L ", full); // symlink, don't follow
      } else if (stats.isDirectory()) {
        console.log("D ", full);
        <strong class="bold">recursiveDir(full);</strong>
      } else {
        console.log("  ", full);
      }
    }
  });
};</pre>
			<p>The listing is long but<a id="_idIndexMarker728"/> correct. I opted to list the <code>/boot</code> directory in my own openSUSE Linux laptop, and this was produced:</p>
			<pre class="console">
recursiveDir("/boot");
/boot
/boot/System.map-4.11.8-1-default
/boot/boot.readme
/boot/config-4.11.8-1-default D  /boot/efi
D    /boot/efi/EFI
D    /boot/efi/EFI/boot
/boot/efi/EFI/boot/bootx64.efi
/boot/efi/EFI/boot/fallback.efi
...
... many omitted lines
...
L    /boot/initrd
/boot/initrd-4.11.8-1-default
/boot/message
/boot/symtypes-4.11.8-1-default.gz
/boot/symvers-4.11.8-1-default.gz
/boot/sysctl.conf-4.11.8-1-default
/boot/vmlinux-4.11.8-1-default.gz  L  /boot/vmlinuz
/boot/vmlinuz-4.11.8-1-default</pre>
			<p>We can apply the same structure to a similar problem: traversing a DOM structure. We could list all of the tags, starting from a given element, using the same approach: we list a node and (by applying<a id="_idIndexMarker729"/> the same algorithm) all of its children. The base case is the same as before: when a node has no children, no more recursive calls are made. You can see this in the following code:</p>
			<pre class="source-code">
// dom.ts
const traverseDom = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  for (let i = 0; i &lt; node.children.length; i++) {
    traverseDom(node.children[i], depth + 1);
  }
};</pre>
			<p>We are using the <code>depth</code> variable to know how many levels below the original element we are. We could also use it to make the traversing logic stop at a certain level; in our case, we are using it only to add some bars and spaces to appropriately indent each element according to its place in the DOM hierarchy. The result of this function is shown in the following code. It would be easy to list more information and not just the element tag, but I wanted to focus on the recursive process:</p>
			<pre class="console">
traverseDom(document.body);
&lt;body&gt;
| &lt;script&gt;
| &lt;div&gt;
| | &lt;div&gt;
| | | &lt;a&gt;
| | | &lt;div&gt;
| | | | &lt;ul&gt;
| | | | | &lt;li&gt;
| | | | | | &lt;a&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;div&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;br&gt;
| | | | | | | &lt;div&gt;
| | | | | | &lt;ul&gt;
| | | | | | | &lt;li&gt;
| | | | | | | | &lt;a&gt;
| | | | | | | &lt;li&gt;
...etc.!</pre>
			<p>However, there’s an ugly point there: why are we making a loop to go through all of the children? We should know<a id="_idIndexMarker730"/> better! The problem is that the structure we get from the DOM isn’t really an array. However, there’s a way out – we can use <code>Array.from()</code> to create a real array out of it and then write a more declarative solution. The following code solves the problem in a better way:</p>
			<pre class="source-code">
// continued...
const traverseDom2 = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  Array.from(node.children).forEach((child) =&gt;
    traverseDom2(child, depth + 1)
  );
};</pre>
			<p>Writing <code>[...node.children].forEach()</code> would have worked as well but using <code>Array.from()</code> makes it more apparent to any reader that we are trying to make an array out of something that looks like one, but really isn’t.</p>
			<p>We have now seen many ideas about the usage of recursion, and we’ve seen many applications of it; however, there are some cases in which you may run into problems, so let’s now consider<a id="_idIndexMarker731"/> some tweaks that may come in handy for specific problems.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor178"/>Mutual recursion</h1>
			<p>Recursion need not be as “simple” and “direct” as having a function that calls itself. We can have more complex situations as a set of functions, each of which calls one or more of the others but not necessarily calling itself. (However, note that this is also allowed.)</p>
			<p>Thinking in terms of mutual recursion is<a id="_idIndexMarker732"/> harder. For simple recursion, you had to imagine you already had a function to do something, and then you used it (in itself!) to do that. In mutual recursion, you have to think of a set of functions, each of which does its own part by simultaneously depending on all the set of functions: the others, and possibly itself as well.</p>
			<p>Let’s examine a simple case to get our feet wet, and then go for a “real-life” application.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor179"/>Odds and evens</h2>
			<p>How can you determine<a id="_idIndexMarker733"/> whether a (not negative) integer number is odd or even? This a trivial problem, to be sure (but see <em class="italic">Question 9.11</em>) but we can get an interesting solution if we realize the following:</p>
			<ul>
				<li>Zero is even</li>
				<li>If a number is even, when you subtract 1 from it, you get an odd number</li>
				<li>A number is odd if it’s not even:</li>
			</ul>
			<pre class="source-code">
function isEven(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return <strong class="bold">isOdd(n - 1)</strong>;
  }
}
function isOdd(n: number): boolean {
  return <strong class="bold">!isEven(n)</strong>;
}
console.log("22.. isEven?", isEven(22));
console.log("9... isOdd?", isOdd(5));
console.log("60... isOdd?", isOdd(10));</pre>
			<p>How does this work? Each function (<code>isEven()</code> and <code>isOdd()</code>) depends on the other to produce a result. How do we know that 9 is odd? The calculations are as follows:</p>
			<pre class="source-code">
is 9 odd?
Is 9 not even?
Is 8 odd?
Is 8 not even?
Is 7 odd?
Is 7 not even?
   ...
   ... several lines skipped
   ...
Is 1 odd?
Is 1 not even?
Is 0 odd?
Is 0 not even?</pre>
			<p>And after the last call, the whole tower of calls gets resolved; 9 is reported to be odd (fortunately!)</p>
			<p>You could say that <a id="_idIndexMarker734"/>this actually isn’t a great example of mutual recursion, because you could easily replace the code for <code>isOdd()</code> in <code>isEven()</code> to get single recursion versions:</p>
			<pre class="source-code">
// continued…
function isEven2(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return <strong class="bold">!isEven2(n - 1)</strong>;
  }
}
function isOdd2(n: number): boolean {
  return !isEven2(n);
}</pre>
			<p>However, we can go about this in another way that will also include mutual recursion:</p>
			<pre class="source-code">
// continued...
function isEven3(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return isOdd3(n - 1);
  }
}
<strong class="bold">function isOdd3(n: number): boolean {</strong>
<strong class="bold">  if (n === 0) {</strong>
<strong class="bold">    return false;</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    return isEven3(n - 1);</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
			<p>So, don’t get to think that mutual recursion can always be simplified away; sometimes, that’s not really possible or practical.</p>
			<p>Going back to the code, it should be evident that no one would implement a parity test this way. Still, this example paves the way to implementing a more complex function: parsing and evaluating an<a id="_idIndexMarker735"/> arithmetic expression, which will involve multiple mutually recursive functions, as we’ll see next.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/>Doing arithmetic</h2>
			<p>Let’s see a more complete problem, which<a id="_idIndexMarker736"/> also happens to (frequently!) appear online, with puzzles as in <em class="italic">Figure 9</em><em class="italic">.5</em>. We’ll implement a set of mutually recursive functions that can correctly evaluate an arithmetic expression according to standard precedence rules for operators.</p>
			<div><div><img src="img/Figure_9.5_B19301.jpg" alt="Figure 9.5 – Common puzzles call for evaluating arithmetic expressions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Common puzzles call for evaluating arithmetic expressions</p>
			<p>To solve this, we’ll first see a tool that lets us correctly process operations: <em class="italic">railroad diagrams</em>. We want to evaluate an expression, and we can say that an expression is either one single term, or several terms added or subtracted. <em class="italic">Figure 9</em><em class="italic">.6</em> shows this graphically. Imagine the arrows are railroad tracks, and any path you follow that starts at the left and eventually ends at the right represents a possible expression.</p>
			<div><div><img src="img/Figure_9.6_B19301.jpg" alt="Figure 9.6 – A railroad syntax diagram for arithmetic expressions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – A railroad syntax diagram for arithmetic expressions</p>
			<p>Now, what’s a term? A term is either<a id="_idIndexMarker737"/> a single factor, or the result of multiplying, dividing, or using<a id="_idIndexMarker738"/> modulus operations on several factors, as shown in <em class="italic">Figure 9</em><em class="italic">.7</em>. Note that with these two rules, <em class="italic">2*3+5</em> is correctly evaluated as <em class="italic">(2*3)+5</em>, because <em class="italic">2*3</em> and <em class="italic">5</em> are terms.</p>
			<div><div><img src="img/Figure_9.7_B19301.jpg" alt="Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus are performed before addition or subtraction"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus are performed before addition or subtraction</p>
			<p>We need one more diagram, for factors. A factor can be a single number or an expression between parentheses. We’ll allow an optional minus sign at the beginning, so -3 is accepted. <em class="italic">Figure 9</em><em class="italic">.8</em> shows the needed diagram.</p>
			<div><div><img src="img/Figure_9.8_B19301.jpg" alt="Figure 9.8 – A factor starts with an optional minus sign, and can be a number or an expression within parentheses"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – A factor starts with an optional minus sign, and can be a number or an expression within parentheses</p>
			<p>We’ll implement the needed evaluation with three functions, one for each diagram. In the usual compiler or interpreter code, we have a first phase that reads the input and splits it into <em class="italic">tokens</em>, and a <a id="_idIndexMarker739"/>second phase that processes those tokens to do whatever’s needed. In our case, the tokens will be numbers (single digits, for simplicity), operators, and parentheses. The code we’ll write is as follows:</p>
			<pre class="source-code">
function evaluate(str: string) {
  const PLUS = "+";
  const MINUS = "-";
  const TIMES = "*";
  const DIVIDES = "/";
  const MODULUS = "%";
  const LPARENS = "(";
  const RPARENS = ")";
<strong class="bold">  let curr = 0;</strong>
<strong class="bold">  const tokens = str</strong>
<strong class="bold">    .split("")</strong>
<strong class="bold">    .map((x) =&gt; (Number.isNaN(Number(x)) ? x : Number(x)));</strong>
<strong class="bold">  return expression();</strong>
  function expression(): number { ... }
  function term(): number { ... }
  function factor(): number { ... }
}</pre>
			<p>We define some constants (<code>PLUS</code>, <code>MINUS</code>, etc.) for clarity. Given a string such as <code>"7+7/7+7*7-7"</code>, we split it into the tokens array; we take care to evaluate digits. Finally, we have a <code>curr</code> variable pointing to the token being processed right now. The evaluation of the<a id="_idIndexMarker740"/> input expression will be done by three functions that will use mutual recursion:</p>
			<pre class="source-code">
  function expression(): number {
  <strong class="bold">let accum = term()</strong>;
  while (
    tokens[curr] === PLUS ||
    tokens[curr] === MINUS
  ) {
    if (tokens[curr] === PLUS) {
      curr++;
      <strong class="bold">accum += term()</strong>;
    } else if (tokens[curr] === MINUS) {
      curr++;
      <strong class="bold">accum -= term()</strong>;
    }
  }
  <strong class="bold">return accum</strong>;
}</pre>
			<p>The <code>expression()</code> function first calls <code>term()</code> to get the value of the first term and then loops if an addition or subtraction is found. In our case, this means that the function would first evaluate a 7, then add 7/7, then also add 7*7, and finally subtract the last 7. (And yes, the result is 50.) After a token is processed, <code>curr</code> is incremented to continue with the rest <a id="_idIndexMarker741"/>of the tokens.</p>
			<p>The code for <code>term()</code> is similar in style; the only difference is how it works with multiplication, and so on:</p>
			<pre class="source-code">
function term(): number {
  <strong class="bold">let accum = factor()</strong>;
  while (
    tokens[curr] === TIMES ||
    tokens[curr] === DIVIDES ||
    tokens[curr] === MODULUS
  ) {
    if (tokens[curr] === TIMES) {
      curr++;
      <strong class="bold">accum *= factor()</strong>;
    } else if (tokens[curr] === DIVIDES) {
      curr++;
      <strong class="bold">accum /= factor()</strong>;
    } else if (tokens[curr] === MODULUS) {
      curr++;
      <strong class="bold">accum %= factor()</strong>;
    }
  }
  <strong class="bold">return accum</strong>;
}</pre>
			<p>This function would be called to evaluate 7, then 7/7, then 7*7, and finally another 7.</p>
			<p>Finally, <code>factor()</code> is a tad different:</p>
			<pre class="source-code">
function factor(): number {
  let mult = 1;
  if (tokens[curr] === MINUS) {
    mult = -1;
    curr++; // skip MINUS
  }
  let result = 0;
  if (tokens[curr] === LPARENS) {
    curr++; // skip LPARENS
    result = expression();
    curr++; // skip RPARENS
  } else {
    result = tokens[curr] as number;
    curr++;
  }
  return mult * result;
}</pre>
			<p>The <code>mult</code> variable will be <code>-1</code> if an initial minus sign was present, or <code>+1</code> otherwise. We have no loops here, and just an alternative: if a left parenthesis is seen, we skip it, recursively evaluate<a id="_idIndexMarker742"/> the included expression, skip the right parenthesis, and return the value of the expression. The alternative is that we have a number, which we return. Whatever we return, we’ll multiply by the <code>mult</code> value to produce the correct result.</p>
			<p>If you analyze the recursive calls, we have <code>expression()</code> calling <code>term()</code>, which calls <code>factor()</code>, which calls <code>recursive()</code> – a cycle of three! Mutual recursion is harder to understand and to get right because to plan such code, you must foresee what several functions will do. However, for the right problems (as shown here), it’s a very powerful technique.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor181"/>Recursion techniques</h1>
			<p>While recursion is a very<a id="_idIndexMarker743"/> good technique, you may face some problems because of the way it is<a id="_idIndexMarker744"/> internally implemented. Each function call, recursive or not, requires an entry in the internal JavaScript stack. When you are working with recursion, each recursive call itself counts as another call, and you might find that there are some situations in which your code will crash and throw an error because it ran out of memory, just because of multiple calls. On the other hand, with most current JavaScript engines, you can probably have several thousand pending<a id="_idIndexMarker745"/> recursive calls without a problem – but with earlier browsers and smaller machines, the number could drop into the hundreds and feasibly go even lower. Thus, it could be argued that, at present, you are not likely to suffer from any particular memory problems.</p>
			<p>In any case, let’s review the problem and go over some possible solutions in the following sections. Even if you don’t get to actually apply them, they represent valid FP ideas for which you may find a place in yet other problems. We will be looking at the following solutions:</p>
			<ul>
				<li><strong class="bold">Tail call optimization</strong>, a technique<a id="_idIndexMarker746"/> that speeds up recursion <strong class="bold">continuation-passing style</strong> (<strong class="bold">CPS</strong>), an<a id="_idIndexMarker747"/> important FP technique that can help with recursion</li>
				<li>A couple of interestingly named techniques, <strong class="bold">trampolines</strong> and <strong class="bold">thunks</strong>, which are also standard FP tools</li>
				<li><strong class="bold">Recursion elimination</strong>, a technique beyond this book’s scope, but which may still be applied</li>
			</ul>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>Tail call optimization</h2>
			<p>When is a recursive call not a<a id="_idIndexMarker748"/> recursive call? Put this way, the question<a id="_idIndexMarker749"/> may make little sense, but there’s a common optimization—for other languages, alas, but not JavaScript!—that explains the answer. If the recursive call is the very last thing a function will do, then the call could be transformed into a simple jump to the start of the function without needing to create a new stack entry. (Why? The stack entry wouldn’t be required: after the recursive call is done, the function would have nothing else to do, so there is no need to further save any of the elements that have been pushed into the stack upon entering the function.) The original stack entry would then no longer be needed and could be replaced by a new one, corresponding to the recent call.</p>
			<p class="callout-heading">Implementation irony</p>
			<p class="callout">The fact that a recursive call, a quintessential FP technique, is being implemented by a base imperative <code>GO</code> <code>TO</code> statement can be considered an ultimate irony!</p>
			<p>These calls are known as <strong class="bold">tail calls</strong> (for obvious reasons) and have higher efficiency, not only because of <a id="_idIndexMarker750"/>the saved stack space but also because a jump is quite a bit faster than any alternative. If the browser<a id="_idIndexMarker751"/> implements this <a id="_idIndexMarker752"/>enhancement, it uses <strong class="bold">tail call optimization</strong> (<strong class="bold">TCO</strong>); however, a glance at<a id="_idIndexMarker753"/> the compatibility tables at <a href="http://kangax.github.io/compat-table/es6/">kangax.github.io/compat-table/es6/</a> shows that at the time of writing (at the end of 2022), the only browser that provides TCO is Safari.</p>
			<div><div><img src="img/Figure_9.9_B19301.jpg" alt="Figure 9.9 – To understand this joke, you must have previously understood it!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – To understand this joke, you must have previously understood it!</p>
			<p>A simple (though non-standard) test lets you verify whether your browser provides TCO. I found this snippet of code in several places on the web, but I’m sorry to say, I cannot attest to the original author, although I believe it is Csaba Hellinger from Hungary. Calling <code>detectTCO()</code> lets you know whether your browser does or does not use TCO:</p>
			<pre class="source-code">
// tailRecursion.ts
function detectTCO() {
  const outerStackLen = new Error().stack!.length;
  return (function inner() {
    const innerStackLen = new Error().stack!.length;
    return innerStackLen &lt;= outerStackLen;
  })();
}</pre>
			<p>The <code>Error().stack</code> result is not a JavaScript standard, but modern browsers support it, albeit in somewhat different ways. (I had to add the “<code>!</code>” symbol so TypeScript would accept that <code>stack</code> would be present.) In any case, the idea is that when a function with a long name calls another function with a shorter name, the stack trace should do the following:</p>
			<ul>
				<li>It should get <a id="_idIndexMarker754"/>shorter if the browser implements TCO, since the old entry for the longer-named function would be<a id="_idIndexMarker755"/> replaced with the entry for the shorter-named one</li>
				<li>It should get longer without TCO, since a completely new stack entry would be created without doing away with the original one</li>
			</ul>
			<p>I’m using Chrome on my Linux laptop, and I added a <code>console.log()</code> statement to show <code>Error().stack</code>. You can see that both stack entries (for <code>inner()</code> and <code>detectTCO()</code>) are <em class="italic">live</em>, so there’s no TCO:</p>
			<pre class="source-code">
Error
at inner (&lt;anonymous&gt;:6:13)
at detectTCO (&lt;anonymous&gt;:9:6) at &lt;anonymous&gt;:1:1</pre>
			<p>Of course, there’s another way of learning whether your environment includes TCO: try out the following function (which does nothing!) with large enough numbers. If you manage to run it with numbers such as, say, 100,000 or 1,000,000, you can be reasonably sure that your JavaScript engine is doing TCO! A possible such function could be the following:</p>
			<pre class="source-code">
// continued...
function justLoop(n: number): void {
  n &amp;&amp; justLoop(n - 1); // until n is zero
}</pre>
			<p>Let’s finish this section with a very short quiz to ensure we understand what tail calls are. Is the recursive call in the factorial function we saw in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>, (but here written in TypeScript) a tail call?</p>
			<pre class="source-code">
function fact(n: number): number {
  if (n === 0) {
    return 1;
  } else {
<strong class="bold">    return n * fact(n - 1);</strong>
  }
}</pre>
			<p>Think about it, because the answer is important! You might be tempted to answer in the affirmative, but the correct answer is <em class="italic">no</em>. There’s a good reason for this, and it’s a key point: after the recursive call is done and the value for <code>fact(n-1)</code> has been calculated, the function <a id="_idIndexMarker756"/>still has work to do. (So doing the recursive call wasn’t actually the last thing that the<a id="_idIndexMarker757"/> function would do.) You can see it more clearly if you write the function in this equivalent way:</p>
			<pre class="source-code">
function fact2(n: number): number {
  if (n === 0) {
    return 1;
  } else {
<strong class="bold">    const aux = fact2(n - 1);</strong>
<strong class="bold">    return n * aux;</strong>
  }
}</pre>
			<p>There should be two takeaways from this section: TCO isn’t usually offered by browsers, and even if it were, you cannot take advantage of it if your calls aren’t actual tail calls. Now that we know what the problem is, let’s see some FP ways of working around it!</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>Continuation-passing style</h2>
			<p>We already know that our logic will fail if we have recursive calls stacked too high. On the other hand, we know that tail calls should alleviate that problem, but they don’t because of browser <a id="_idIndexMarker758"/>implementations! However, there’s <a id="_idIndexMarker759"/>a way out of this. Let’s first consider how we can transform recursive calls into tail calls by using a well-known FP <a id="_idIndexMarker760"/>concept—<strong class="bold">continuations</strong>—and we’ll leave the problem of solving TCO limitations for the next section. (We mentioned continuations in <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, but we didn’t go into detail.)</p>
			<p>In FP parlance, a continuation represents the state of a process and allows processing to continue. This may be too abstract, so let’s see what this means. The key idea is that when you call a function, you also provide it with a continuation (in reality, a simple function) that will be called at return time.</p>
			<p>Let’s look at a trivial example. Suppose you have a function that returns the time of the day, and you want to show<a id="_idIndexMarker761"/> this on the console. The usual way to do this could be as follows:</p>
			<pre class="source-code">
function getTime(): string {
  return new Date().toTimeString();
}
console.log(getTime()); // "21:00:24 GMT+0530 (IST)"</pre>
			<p>If you were doing <a id="_idIndexMarker762"/>CPS, you would pass a continuation to the <code>getTime()</code> function. Instead of returning a calculated value, the function would invoke the continuation, giving it the value as a parameter:</p>
			<pre class="source-code">
function getTime2(<strong class="bold">cont: FN</strong>) {
  return <strong class="bold">cont(</strong>new Date().toTimeString()<strong class="bold">);</strong>
}
getTime2(console.log); // similar result as above</pre>
			<p>What’s the difference? The key is that we can apply this mechanism to make a recursive call into a tail call because all of the code that comes after will be provided in the recursive call itself. To make this clear, let’s revisit the factorial function in the version that made it explicit that we weren’t doing tail calls:</p>
			<pre class="source-code">
function fact2(n: number): number {
  if (n === 0) {
    return 1;
  } else {
    const aux = fact2(n - 1);
    return n * aux;
  }
}</pre>
			<p>We will add a new parameter to the function for the continuation. What do we do with the result of the <code>fact(n-1)</code> call? We multiply it by <code>n</code>, so let’s provide a continuation that will do just that. I’ll rename the factorial function as <code>factC()</code> to make it clear that we are working with<a id="_idIndexMarker763"/> continuations, as shown in the following code:</p>
			<pre class="source-code">
// continued...
function factC(
  n: number,
  cont: (x: number) =&gt; number
): number {
  if (n === 0) {
    return cont(1);
  } else {
    return factC(n - 1, (x) =&gt; cont(n * x));
  }
}</pre>
			<p>How would we get the final result? Easy – we can call <code>factC()</code> with a continuation that will return<a id="_idIndexMarker764"/> whatever it’s given:</p>
			<pre class="source-code">
console.log(factC(7, x =&gt; x)); // 5040, correctly
factC(7, console.log);         // same result</pre>
			<p class="callout-heading">Identity combinator</p>
			<p class="callout">In FP, a function that returns its argument <a id="_idIndexMarker765"/>as a result is usually called <code>identity()</code> for obvious reasons. In combinatory logic (which we won’t be using), we would speak of the <strong class="bold">I combinator</strong>.</p>
			<p>Can you understand how it worked? Then let’s try out a more complex case with the Fibonacci function, which has two recursive calls in it, as shown in the following highlighted code:</p>
			<pre class="source-code">
// continued...
const fibC = (n: number, cont: FN): number =&gt; {
  if (n &lt;= 1) {
    return cont(n);
  } else {
<strong class="bold">    return fibC(n - 2, (p) =&gt;</strong>
<strong class="bold">      fibC(n - 1, (q) =&gt; cont(p + q))</strong>
<strong class="bold">    )</strong>;
  }
};</pre>
			<p>This is trickier: we call <code>fibC()</code> with <code>n-2</code> and a continuation that says that whatever that call returned, call <code>fibC()</code> with <code>n-1</code>, and when <em class="italic">that</em> call returns, sum the results of both calls and pass that result to the original continuation.</p>
			<p>Let’s see just one more example, involving a loop with an undefined number of recursive calls. By then, you<a id="_idIndexMarker766"/> should have some idea about how to apply CPS to your code—though I’ll readily admit it can become really complex!</p>
			<p>Earlier in this chapter, we<a id="_idIndexMarker767"/> saw this function in the <em class="italic">Traversing a tree structure</em> section. The idea was to print out the DOM structure, like this:</p>
			<pre class="console">
&lt;body&gt;
| &lt;script&gt;
| &lt;div&gt;
| | &lt;div&gt;
| | | &lt;a&gt;
| | | &lt;div&gt;
| | | | &lt;ul&gt;
| | | | | &lt;li&gt;
| | | | | | &lt;a&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;div&gt;
| | | | | | | &lt;div&gt;
| | | | | | | | &lt;br&gt;
| | | | | | | &lt;div&gt;
| | | | | | &lt;ul&gt;
| | | | | | | &lt;li&gt;
| | | | | | | | &lt;a&gt;
| | | | | | | &lt;li&gt;
...etc.!</pre>
			<p>The function we ended up designing back then was the following:</p>
			<pre class="source-code">
// dom.ts
const traverseDom2 = (node: Element, depth = 0) =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  Array.from(node.children).forEach((child) =&gt;
    traverseDom2(child, depth + 1)
  );
};</pre>
			<p>Let’s start by <a id="_idIndexMarker768"/>making this fully recursive, getting rid of the <code>forEach()</code> loop. We have seen this technique before, so we can move on to the following result; note how the following code <a id="_idIndexMarker769"/>forms its loops by using recursion. Also, note we added lots of <code>return</code> statements, even if they are not really needed; we’ll see the reason for this soon:</p>
			<pre class="source-code">
// continued...
const traverseDom3 = (node: Element, depth = 0): void =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  const traverseChildren = (
    children: Element[],
    i = 0
  ): void =&gt; {
    if (i &lt; children.length) {
      traverseDom3(children[i], depth + 1);
      return traverseChildren(children, i + 1); // loop
    }
    return;
  };
  return traverseChildren(Array.from(node.children));
};</pre>
			<p>Now, we have to add a continuation to <code>traverseDom3()</code>. The only difference from the previous cases is that the function doesn’t return anything, so we won’t pass any arguments to the <a id="_idIndexMarker770"/>continuation. It’s also important to remember the implicit return at the end of the <code>traverseChildren()</code> loop; we must call the continuation:</p>
			<pre class="source-code">
// continued...
const traverseDom3C = (
  node: Element,
  depth = 0,
  cont: FN = () =&gt; {
    /*  nothing */
  }
): void =&gt; {
  console.log(
    `${"| ".repeat(depth)}&lt;${node.nodeName.toLowerCase()}&gt;`
  );
  const traverseChildren = (
    children: Element[],
    i = 0
  ): void =&gt; {
    if (i &lt; children.length) {
      return traverseDom3C(children[i], depth + 1, () =&gt;
        traverseChildren(children, i + 1)
      );
    }
    return cont();
  };
  return traverseChildren(Array.from(node.children));
};</pre>
			<p>We opted to give a <a id="_idIndexMarker771"/>default value to <code>cont</code>, so we can call <code>traverseDom3C(document.body)</code> as before. If we try out this logic, it works, but the problem of the potentially high number of pending calls hasn’t been solved; let’s look for a solution to this in the following section.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor184"/>Trampolines and thunks</h2>
			<p>For the last solution to our problem, we shall have to think about the cause of the problem. Each pending recursive call creates a new entry stack. Whenever the stack gets too empty, the program crashes, and our algorithm is history. So, if we can work out a way to avoid stack growth, we should be free. The solution, in this case, is quite imposing and requires <em class="italic">thunks</em> and a <em class="italic">trampoline</em>—let’s see what these are!</p>
			<p>First, a <code>new Date().toISOString()</code>; however, if you provide a thunk that calculates that, you won’t get the value until you actually invoke it:</p>
			<pre class="source-code">
// trampoline.ts
const getIsoDT = <strong class="bold">() =&gt; new Date().toISOString()</strong>; // a thunk
const isoDT = <strong class="bold">getIsoDT()</strong>; // getting the thunk's value</pre>
			<p>What’s the use of this? The problem with recursion is that a function calls itself, and calls itself, and calls itself, and so on until the stack blows over. Instead of directly calling itself, we will have the function return a thunk, which, when executed, will actually recursively call the function. So, instead of having the stack grow more and more, it will actually be quite flat since the function will never get to actually call itself; the stack will grow by one position when you call the function, and then get back to its size as soon as the function returns its thunk.</p>
			<p>But who gets to do the<a id="_idIndexMarker775"/> recursion? That’s where the concept of a <strong class="bold">trampoline</strong> comes in. A trampoline<a id="_idIndexMarker776"/> is just a loop that calls a function, gets its return, and if it is a thunk, then it calls it so that recursion will proceed, but in a flat, linear way! The loop is exited when the thunk evaluation returns an actual value instead of a new function. Look at the following code:</p>
			<pre class="source-code">
// continued...
const trampoline = (fn: FN): any =&gt; {
  while (typeof fn === "function") {
    fn = fn();
  }
  return fn;
};</pre>
			<p>How can we apply this to an actual function? Let’s start with a simple one that sums all numbers from 1 to <em class="italic">n</em>, but in <a id="_idIndexMarker777"/>a recursive, guaranteed-to-cause-a-stack-crash fashion. Our simple <code>sumAll()</code> function could be the following:</p>
			<pre class="source-code">
// continued...
const sumAll = (n: number): number =&gt;
  n == 0 ? 0 : n + sumAll(n - 1);</pre>
			<p>However, if we start trying this function out, we’ll eventually stumble and crash, as you can see in the following examples:</p>
			<pre class="source-code">
console.log(sumAll(10));
console.log(sumAll(100));
console.log(sumAll(1_000));
console.log(sumAll(10_000));
console.log(sumAll(100_000));
// Output:
55
5050
500500
50005000
<strong class="bold">RangeError: Maximum call stack size exceeded</strong></pre>
			<p>The stack problem will come up sooner or later depending on your machine, its memory size, and so on – but it will <a id="_idIndexMarker778"/>come, no doubt. Let’s rewrite the function in CPS so that it will become tail-recursive. We will apply the same technique that we saw earlier, as shown in the following code:</p>
			<pre class="source-code">
// continued...
const sumAllC = (n: number, cont: FN): number =&gt;
  n === 0 ? cont(0) : sumAllC(n - 1, (v) =&gt; cont(v + n));</pre>
			<p>This, however, crashes as before; eventually, the stack grows too much. Let’s apply a simple rule to the code: whenever you are going to return from a call, instead, return a thunk that will, when executed, do the call that you actually wanted to do. The following code implements that change:</p>
			<pre class="source-code">
// continued...
const sumAllT = (n: number, cont: FN): (() =&gt; number) =&gt;
  n === 0
    ? <strong class="bold">() =&gt; cont(0)</strong>
    : <strong class="bold">() =&gt; sumAllT(n - 1, (v) =&gt; () =&gt; cont(v + n));</strong></pre>
			<p>Whenever there would have been a call to a function, we now return a thunk. How do we get to run this function? This is the missing detail. You need an initial call that will invoke <code>sumAllT()</code> the first time, and (unless the function was called with a zero argument) a thunk will be<a id="_idIndexMarker779"/> immediately returned. The <code>trampoline</code> function will call the thunk, and that will cause a new call, and so on until we eventually get a thunk that just returns a value, and then the calculation will be ended:</p>
			<pre class="source-code">
// continued...
const sumAll2 = n =&gt; trampoline(sumAllT(n, x =&gt; x));
console.log(sumAll2(1_000_000)); // no problem now!</pre>
			<p>In fact, you probably wouldn’t want a separate <code>sumAllT()</code> function, so you’d go for something like this:</p>
			<pre class="source-code">
const sumAll3 = (n: number): number =&gt; {
  const sumAllT = (n: number, cont: FN) =&gt;
    n === 0
      ? () =&gt; cont(0)
      : () =&gt; sumAllT(n - 1, (v) =&gt; () =&gt; cont(v + n));
  return trampoline(sumAllT(n, (x) =&gt; x));
};
console.log(sumAll3(1_000_000)); // no stack crash</pre>
			<p>There’s only one problem left: what would we do if the result of our recursive function wasn’t a value but<a id="_idIndexMarker780"/> rather a function? The problem there would be on the <code>trampoline()</code> code that, as long as the result of the thunk evaluation is a function, goes back again and again to evaluate it. The simplest solution would be to return a thunk, but wrapped in an object, as shown in the following code:</p>
			<pre class="source-code">
// continued...
class Thunk {
  fn: FN;
  constructor(fn: FN) {
    this.fn = fn;
  }
}
const trampoline2 = (thk: Thunk) =&gt; {
  while (
    typeof thk === "object" &amp;&amp;
    thk.constructor.name === "Thunk"
  ) {
    thk = thk.fn();
  }
  return thk;
};</pre>
			<p>The difference now would be that, instead of returning a thunk, you’d return a <code>Thunk</code> object, so our new<a id="_idIndexMarker781"/> trampolining function can now distinguish an actual thunk (which is meant to be invoked and executed) from any other kind of result (which is meant to be returned).</p>
			<p>So, if you happen to have a<a id="_idIndexMarker782"/> recursive algorithm, but it won’t run because of stack limits, you can fix it reasonably by going through the following steps:</p>
			<ol>
				<li value="1">Change all recursive calls to tail recursion using continuations.</li>
				<li>Replace all <code>return</code> statements so that they’ll return thunks.</li>
				<li>Replace the call to the original function with a <code>trampoline</code> call to start the calculations.</li>
			</ol>
			<p>Of course, this doesn’t come for free. You’ll notice that, when using this mechanism, there’s extra work involving returning thunks, evaluating them, and so on, so you can expect the total time to go up. Nonetheless, this is a low price to pay if the alternative is having a non-working solution to a problem!</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor185"/>Recursion elimination</h2>
			<p>There’s yet one other possibility that <a id="_idIndexMarker783"/>you might want to explore, but that falls beyond the realm of FP and into algorithm design. It’s a computer science fact that any algorithm implemented using recursion has an equivalent version that doesn’t use recursion at all, and instead depends on a stack. There are ways to systematically transform recursive algorithms into iterative ones, so if you run out of all options (that is, if not even continuations or thunks can help you), then you’d have a final opportunity to achieve your goals by replacing all recursion with iteration. We won’t be getting into this—as I said, this elimination has little to do with FP—but it’s important to know that the tool exists and that you might be able to use it.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor186"/>Summary</h1>
			<p>In this chapter, we saw how we can use recursion, a basic tool in FP, as a powerful technique to create algorithms for problems that would probably require far more complex solutions otherwise. We started by considering what recursion is and how to think recursively in order to solve problems, then moved on to see some recursive solutions to several problems in different areas, and ended by analyzing potential problems with deep recursion and how to solve them.</p>
			<p>In <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, we shall get back to a concept we saw earlier in the book, function purity, and see some techniques that will help us guarantee that a function won’t have any side effects by ensuring the immutability of arguments and data structures.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor187"/>Questions</h1>
			<p>9.1 <code>reverse(str: string)</code> function but implement it in a recursive fashion? The best way to do this would be using the standard string <code>reverse()</code> method, as detailed in <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse</a>, but that wouldn’t do for a question on recursion, would it?</p>
			<p>9.2 <strong class="bold">Climbing steps</strong>: Suppose you want to climb up a ladder with <em class="italic">n</em> steps. Each time you raise your foot, you may climb up one or two rungs. In how many different ways can you climb up that ladder? For example, you can climb a four-rung ladder in five different ways:</p>
			<ul>
				<li>Always take one step at a time</li>
				<li>Always take two steps at a time</li>
				<li>Take two steps first, then one, and then one</li>
				<li>Take one step first, then two, and then one</li>
				<li>Take one step first, then another one, and finish with two</li>
			</ul>
			<p>9.3 <strong class="bold">Sorting recursively</strong>: Many sorting algorithms can be described with recursion; can you implement them?</p>
			<ul>
				<li><strong class="bold">Selection sort</strong>: Find the maximum element of the array, remove it, recursively sort the rest, and then push the maximum element to the end of the sorted rest</li>
				<li><strong class="bold">Insertion sort</strong>: Take the first element of the array, sort the rest, and finish by inserting the removed element into its correct place in the sorted rest</li>
				<li><strong class="bold">Merge sort</strong>: Divide the array into two parts, sort each one, and finish by merging the two sorted parts into a sorted list</li>
			</ul>
			<p>9.4 <code>greaterEqual</code>. Can you foresee any possible problems with this? The following code highlights the changes that the developer made with regard to the original version we saw earlier:</p>
			<pre class="source-code">
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
    const smaller = <strong class="bold">arr.filter((x) =&gt; x &lt; pivot)</strong>;
    const greaterEqual = <strong class="bold">arr.filter((x) =&gt; x &gt;= pivot)</strong>;
    return [
<strong class="bold">      ...quicksort(smaller),</strong>
<strong class="bold">      ...quicksort(greaterEqual),</strong>
    ];
  }
};</pre>
			<p>9.5 <code>quicksort()</code> more efficient by avoiding having to call <code>filter()</code> twice. Along the lines of what we saw in the <em class="italic">Calculating several values at once</em> section in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, write a <code>partition(arr, pr)</code> function that, given an <code>arr</code> array and an <code>fn()</code> predicate, will return two arrays: the values of <code>arr</code> for which <code>fn</code> is true in the first one, and the rest of the values of <code>arr</code> in the second one:</p>
			<pre class="source-code">
const partition = &lt;A&gt;(
  arr: A[],
  fn: (x: A) =&gt; boolean
): [A[], A[]] =&gt; { … };
const quicksort = &lt;A&gt;(arr: A[]): A[] =&gt; {
  if (arr.length &lt; 2) {
    return arr;
  } else {
    const pivot = arr[0];
<strong class="bold">    const [smaller, greaterEqual] = partition(</strong>
<strong class="bold">      arr.slice(1),</strong>
<strong class="bold">      (x) =&gt; x &lt; pivot</strong>
<strong class="bold">    )</strong>;
    return [
      ...quicksort(smaller),
      pivot,
      ...quicksort(greaterEqual),
    ];
  }
};</pre>
			<p>9.6 <code>findR()</code> function, we did not provide all possible parameters to the <code>cb()</code> callback. Can you fix that? Your solution should be along the lines of what we did for <code>map()</code> and other functions. (And yes, if you can also allow for empty places in the array, it would be even better.)</p>
			<p>9.7 <code>every()</code> and <code>some()</code> using recursion: can you do that?</p>
			<p>9.8 <strong class="bold">Symmetrical queens</strong>: In the eight queens puzzle we previously solved, only one solution shows symmetry in the placement of the queens. Can you modify your algorithm to find it?</p>
			<p>9.9 <code>INTERNATIONAL</code> and <code>CONTRACTOR</code> is <code>N...T...R...A...T...O</code>. Try it out with and without memoizing and see the difference!</p>
			<p>9.10 <code>isOdd()</code>? There are quite a few!</p>
			<p>9.11 <code>isOdd()</code> and <code>isEven()</code> using a trampoline to avoid stack overflow problems.</p>
			<p>9.12 <code>isEven()</code>/<code>isOdd()</code> was as follows, but it had a serious bug; can you find it?</p>
			<pre class="source-code">
function isEven(n: number): boolean {
  if (n === 0) {
    return true;
  } else {
    return isOdd(n - 1);
  }
}
function isOdd(n: number): boolean {
  if (n === 1) {
    return true;
  } else {
    return isEven(n - 1);
  }
}</pre>
			<p>9.13 <code>expression()</code> and <code>term()</code>, which don’t use <code>while</code>, follow – are they correct?</p>
			<pre class="source-code">
function expression(): number {
  for (let accum = term(); ; ) {
    if (tokens[curr] === PLUS) {
      curr++; // skip PLUS
      accum += term();
    } else if (tokens[curr] === MINUS) {
      curr++; // skip MINUS
      accum -= term();
    } else {
      return accum;
    }
  }
}
function term(): number {
  for (let accum = factor(); ; ) {
    if (tokens[curr] === TIMES) {
      curr++; // skip TIMES
      accum *= factor();
    } else if (tokens[curr] === DIVIDES) {
      curr++; // skip DIVIDES
      accum /= factor();
    } else if (tokens[curr] === MODULUS) {
      curr++; // skip MODULUS
      accum %= factor();
    } else {
      return accum;
    }
  }
}</pre>
			<p>9.14 <code>"^"</code>, to our arithmetic expression evaluator. (Yes, the exponentiation operator in JavaScript is <code>"**"</code>, not <code>"^"</code>, but I wanted to have single-character tokens for simplicity.) Be sure to implement priorities correctly, and also to make the operator right-associative: <code>2^3^4</code> should be evaluated as <code>(2^(3^4))</code>, not <code>((2^3)^4)</code>.</p>
			<p>9.15 <strong class="bold">Error-prone evaluation</strong>: Our evaluation algorithm is prone to errors because it expects expressions to be syntactically valid. How can you enhance it?</p>
		</div>
	</body></html>