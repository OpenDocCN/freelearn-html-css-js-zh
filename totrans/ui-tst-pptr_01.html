<html><head></head><body>
		<div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Getting started with Puppeteer</h1>
			<p>I remember the first time I heard about browser automation. A friend told me that their QA team was testing using "automation." That sounded magical to me. People testing websites using "automation." After a few years, I learned that automation wasn't a magic potion, but instead a powerful tool not only for QA but also for developers, because we developers love to automate stuff, right?</p>
			<p>That's why in the first part of this chapter, I want to show you how browser automation works and what makes Puppeteer unique. In the latter part of this chapter, we are going to review some asynchronous techniques that are going to be useful throughout the rest of the book, and throughout your automation journey.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>What is browser automation?</li>
				<li>Introducing headless browsers</li>
				<li>Puppeteer use cases</li>
				<li>Setting up the environment</li>
				<li>Our first Puppeteer code</li>
				<li>Asynchronous programming in JavaScript</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>What is browser automation?</h1>
			<p>If<a id="_idIndexMarker000"/> you go and look for the word "automation" in Wikipedia, it will tell you that it is<em class="italic"> "a process or procedure performed with minimal human assistance."</em> If you are a developer, or just a geek, I bet you love to create scripts to automate tasks. You might also create environment variables, so you don't have to type long paths, or even create cool Git commands, so you don't need to remember all the steps required to create a new branch upstream.</p>
			<p>When I got my first Mac, I discovered an app called <a id="_idIndexMarker001"/>Automator. I fell in love with it. You can automate tasks and connect applications just using drag and drop. If you use macOS and you've never played with Automator, please give it a try! But Automator isn't the only app. There are many workflow apps in the market, such as Hazel or Alfred.</p>
			<p>Automation is <a id="_idIndexMarker002"/>even in the cloud and is available to the general public. Apps such as IFTTT and Zapier allow users to automate everyday tasks. You can create automations such as "When I post on Instagram, share the same image on Twitter," all from your phone. Regular people doing automation, that's great!</p>
			<p>We also have mail rules. Most mail clients, even web clients, let you create rules, so you can mark emails as read, label them, or even remove them based on conditions. That's also automation.</p>
			<p>Maybe you've taken it to the next level and coded an application for some of your daily tasks. You have that report that you need to send to your boss every month. That report is the result of many CSV files. You just wrote a tiny app, using your favorite language to make that report for you.</p>
			<p>In a few words, automation means using an app to do a repetitive task for us. And as we have seen, it doesn't necessarily involve coding that app. So now, we can say that <strong class="bold">browser automation is telling an app to do a repetitive task in the browser for us</strong>.</p>
			<p>Ok, that's a simple statement. But how's that possible? When you automate an app, you accomplish this using some kind of <strong class="bold">application program interface</strong> (<strong class="bold">API</strong>). For example, when you write a bat/bash file, you<a id="_idIndexMarker003"/> use the command-line arguments as an interface. If you use IFTTT, it employs Twitter's and Instagram's HTTP APIs to fetch images and create tweets. You need some kind of API, some way to interact with the app you are trying to automate. How are we supposed to interact with the browser? Good question.</p>
			<p>To make things a little bit more complicated, we also need to consider that we have two apps to automate: the browser itself and the website. We don't want just to open a browser, create a new tab, and navigate to a page. We also want to go to that page and perform some actions. We want to click on a button, or enter some text in an input element.</p>
			<p>Automating a<a id="_idIndexMarker004"/> browser sounds challenging. But, luckily for us, we have some brilliant people who did an excellent job for us and created tools such as Selenium and Puppeteer.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Selenium and Puppeteer</h2>
			<p>A quick search on Google will show that Selenium<a id="_idIndexMarker005"/> is one of the top, if not <em class="italic">the</em> top, UI testing tool on the market. I think a question many people would ask is: <strong class="bold">Why should I choose Puppeteer over Selenium? Which one is better?</strong></p>
			<p>The first thing you need to know is that Puppeteer<a id="_idIndexMarker006"/> was not created to compete with Selenium. Selenium is a cross-language, cross-browser testing tool, whereas Puppeteer was created as a multi-purpose automation tool to exploit all the power of Chromium. I think both are great automation tools, but they tackle browser automation in two different ways. They are different in two important aspects that define the target audience of a browser automation library:</p>
			<ul>
				<li>The interface between the tool and the browser</li>
				<li>The interface between the tool and the user</li>
			</ul>
			<p>Let's first unpack how Selenium works.</p>
			<h3>Selenium's approach</h3>
			<p>In order to automate most<a id="_idIndexMarker007"/> browsers in the market, Selenium wrote a spec (an API) called <strong class="bold">WebDriver</strong>, which <a id="_idIndexMarker008"/>the W3C then accepted as a standard (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver">https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver</a>), and asked the browsers to implement that interface. Selenium will use this WebDriver API to interact with the browser. If you take a look at the paper at the preceding URL, you will find two words showing up over and over: <strong class="bold">testing</strong> and <strong class="bold">simplicity</strong>. In other words, they defined an API with a clear focus on testing and simplicity and asked the browsers to implement that interface. Cross-browser testing is, in my opinion, the main feature of Selenium.</p>
			<p class="callout-heading">What is an API?</p>
			<p class="callout">An API <a id="_idIndexMarker009"/>is the set of classes, functions, properties, and events that a library allows us to use. An API is critical for a library's success because it will determine how much you can do with it and how easy (or not) the interaction will be with the library.</p>
			<p>The API that <a id="_idIndexMarker010"/>Selenium exposes to users is also considered a part of the WebDriver spec, and it follows the same philosophy: it's focused on testing and simplicity. This API provides a layer of abstraction between the user and all the different browsers and provides an interface that will easily help the developer write tests.</p>
			<h3>Puppeteer's approach</h3>
			<p>Puppeteer<a id="_idIndexMarker011"/> doesn't need to think in terms of cross-browser support. Although there are some efforts to run Puppeteer on Firefox, the focus is on grabbing all the developer tools that Chromium has and making them available to the user. With this goal in mind, Puppeteer can access way more tools than those exposed by the WebDriver API that Selenium uses.</p>
			<p>The difference in how they communicate with the browser is also reflected in the APIs. Puppeteer provides an API that will help us take advantage of all the power of Chromium. I think it's important to highlight that Puppeteer was created in JavaScript, so the API will feel more natural than Selenium's, which comes from a cross-language philosophy.</p>
			<p>Puppeteer doesn't need to ask anybody to implement the API because it takes advantage of the headless capability of Chromium. Let's now see what headless browsers are.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introducing Headless browsers</h1>
			<p>What is a headless <a id="_idIndexMarker012"/>browser? No, it's not something from a horror movie. <strong class="bold">A headless browser is a browser that you can launch and interact with using a particular protocol over a particular communication transport, with no UI involved</strong>. This means that you will have one active process (or many processes, as we know how browsers are these days), but there will be no "window" for you to interact with the browser. I think that "windowless browser" would have been a more accurate name.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Available headless browsers</h2>
			<p>Both Chromium and<a id="_idIndexMarker013"/> Firefox support headless browser mode. It's important to mention that, at the time of writing this book, Firefox's headless mode was still experimental. That might sound bad, compared with the six browsers Selenium offers (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers">https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers</a>), but, as you might have noticed, I didn't say Chrome, I said Chromium. Chromium is the engine Chrome uses under the hood. But Chrome is not the<a id="_idIndexMarker014"/> only browser using Chromium; in the past few years, many browsers have started to use the chromium engine. These are a few <a id="_idIndexMarker015"/>examples of chromium-based browsers:</p>
			<ul>
				<li>Google Chrome</li>
				<li>Microsoft Edge, a.k.a. Edgium, to avoid confusion with the previous version of Microsoft Edge based on Trident</li>
				<li>Opera</li>
				<li>Brave</li>
			</ul>
			<p>That's much better. We can automate at least five browsers. But there are two major browsers with no headless support: Microsoft Internet Explorer and Safari. The case of Safari is interesting. In the same way that Chromium is the engine behind Chrome, Webkit is the engine of Safari and, although Safari doesn't support headless mode, there are a few Webkit builds created for testing purposes with headless support. Microsoft Playwright has its own Webkit build to support cross-browser automation.</p>
			<p>Do you want to see a headless browser for the very first time?</p>
			<p>Let's try this out:</p>
			<p>If you have Chrome installed, grab the full path of the executable and pass these command arguments: <code>--headless --remote-debugging-port=9222 --crash-dumps-dir=/tmp</code>:</p>
			<pre>~ % /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --headless --remote-debugging-port=9222 --crash-dumps-dir=/tmp</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are a macOS user, the Chrome executable will be inside the "<code>Google Chrome.app</code>" pseudo-file. As you can see, it's: "<code>Google Chrome.app/Contents/MacOS/Google Chrome</code>".</p>
			<p>After executing<a id="_idIndexMarker016"/> that command, you should get something like this in the console:</p>
			<pre>DevTools listening on ws://127.0.0.1:9222/devtools/browser/e7e52f93-8f1e-491c-b718-94ae7a8e81b7</pre>
			<p>Now we have a headless chrome browser waiting for commands through a WebSocket on <code>ws://127.0.0.1:9222</code>.</p>
			<p>Firefox also provides a headless mode:</p>
			<pre>~ % /Applications/Firefox.app/Contents/MacOS/firefox --headless
*** You are running in headless mode.</pre>
			<p>It doesn't say much, but trust me, now we have a Firefox browser running in headless mode.</p>
			<p>As I mentioned before, a headless browser doesn't have a UI. The only way to interact with the browser is to use the transport the browser created, in this case, a WebSocket, and to send messages using some kind of protocol. In the case of Chromium and Firefox, it's the Chromium DevTools Protocol.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>The Chromium DevTools Protocol</h2>
			<p>If you are a web<a id="_idIndexMarker017"/> developer, I'm 100% sure you have used Chrome DevTools. If you don't know what I'm talking about, you can open DevTools by clicking on the three dots button in the top-right corner, and then go to <code>More Tools &gt; Developer Tools</code>. You will get something like this: </p>
			<div><div><img src="img/Figure_1.01_B16113.jpg" alt="Chrome DevTools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Chrome DevTools</p>
			<p>It's impressive<a id="_idIndexMarker018"/> all the things you can accomplish using this fantastic tool:</p>
			<ul>
				<li>Inspect the DOM.</li>
				<li>Evaluate CSS styles.</li>
				<li>Run JavaScript code.</li>
				<li>Debug JavaScript code.</li>
				<li>See network calls.</li>
				<li>Measure performance.</li>
			</ul>
			<p>And the good news is that it's the <strong class="bold">Chromium Developer Protocol</strong> (which we'll call <strong class="bold">CDP</strong> from now on) that drives most of the DevTools' features. And that same CDP is the protocol that headless browsers use to interact with the outside world.</p>
			<p>CDP sounds perfect. We can interact with the browser and do all the things I have mentioned. You can create a Node.JS app to launch a browser and start sending CDP messages through a WebSocket, but that would be quite complex and hard to maintain. That's where Puppeteer comes to the rescue and offers a human-friendly interface to interact with the browser.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Introducing Puppeteer</h2>
			<p>Puppeteer is <a id="_idIndexMarker019"/>nothing more, and nothing less, than a Node.js package that knows how to open a browser, send commands, and react to messages coming from that browser. At the time of writing this book, Puppeteer supports Chromium and Firefox, but Firefox support is still considered experimental. I think it's a good time for you to go to the <a id="_idIndexMarker020"/>Puppeteer repository (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo">https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo</a>) and check whether things have changed since then.</p>
			<p>There are also some community projects that implement Puppeteer in other languages. You will find <a id="_idIndexMarker021"/>Puppeteer-Sharp (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp">https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp</a>) for .NET or Pyppeteer (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer">https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer</a>) for Python.</p>
			<p>When you use Puppeteer, you are, in fact, using more than just a JavaScript library. Many people call this the "Puppeteer pyramid":</p>
			<div><div><img src="img/Figure_1.02_B16113.jpg" alt=" The Puppeteer pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> The Puppeteer pyramid</p>
			<p>The Puppeteer pyramid<a id="_idIndexMarker022"/> consists of three components:</p>
			<ul>
				<li>The headless browser is the engine that will run the pages we want to automate.</li>
				<li>The Chromium DevTools Protocol allows any external user to interact with the browser.</li>
				<li>Puppeteer provides a JavaScript API to interact with the browser using the CDP.</li>
			</ul>
			<p>What I find valuable about Puppeteer is that its model clearly represents the browser structure:</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>The Puppeteer object model</h2>
			<div><div><img src="img/Figure_1.03_B16113.jpg" alt="Puppeteer Model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Puppeteer Model</p>
			<p>Let's see <a id="_idIndexMarker023"/>what these objects represent inside the browser.</p>
			<h3>Browser</h3>
			<p>The browser<a id="_idIndexMarker024"/> is the main class. It's the object created when Puppeteer connects to a browser. The keyword here is <strong class="bold">connect</strong>. The browser that Puppeteer will use can be launched by Puppeteer itself. But it could also be a browser that is already running on your local machine, or it could even be a browser running in the cloud, like <a id="_idIndexMarker025"/>Browserless.io (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/browserless">https://www.hardkoded.com/ui-testing-with-puppeteer/browserless</a>).</p>
			<h3>Browser context</h3>
			<p>A browser can contain more than one context. A context<a id="_idIndexMarker026"/> is a browser session (not to be confused with a browser window). The best example is the Incognito Mode or private mode, depending on the browser, which creates an isolated session inside the same browser process.</p>
			<h3>Page</h3>
			<p>A page<a id="_idIndexMarker027"/> is a tab in a browser or even a pop-up page.</p>
			<h3>Frame</h3>
			<p>The frame<a id="_idIndexMarker028"/> object is more important than it looks. Every page has at least one frame, which is called the main frame. Most of the page actions we will learn across this book are, in fact, a call to the main frame; for example, <code>page.click</code> calls <code>mainframe.click</code>.</p>
			<p>The frame is a tree. One page has only one main frame, but a frame can contain many child frames.</p>
			<h3>Worker</h3>
			<p>A worker<a id="_idIndexMarker029"/> is a model that interacts with Web Workers. This is not a feature we will talk about in this book.</p>
			<h3>Execution context</h3>
			<p>The execution context<a id="_idIndexMarker030"/> is a mechanism Chromium uses to isolate the page from the browser extensions. Each frame will have its own execution context. Internally, all the frame functions that involve executing JavaScript code will use an execution context to run the code inside the browser.</p>
			<p>There are other objects involved, such as <code>ElementHandles</code> and <code>JSHandles</code>, but we are going to talk about them later in the book. </p>
			<p>Now that we know some of the differences between Selenium and Puppeteer, it's a perfect moment to review many possible use cases for Puppeteer.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Puppeteer use cases</h1>
			<p>Remember, the main<a id="_idIndexMarker031"/> difference between Puppeteer and Selenium is that Selenium is designed for end-to-end testing. In contrast, Puppeteer is designed as an API to exploit all the power of the DevTools, which means that besides end-to-end tests, there are also other use cases where you can use Puppeteer, as we will see now.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Task Automation</h2>
			<p>There are many things we do on the<a id="_idIndexMarker032"/> web that you can automate. For example, you can download a report, fill in a form, or check flight prices. You might also want to check your website's health, monitor its performance, or check whether your website is working correctly. In <a href="B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104"><em class="italic">Chapter 6</em></a><em class="italic">, Executing and Injecting JavaScript</em>, we will see how to use Checkly to monitor your website in production.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Web Scraping</h2>
			<p>Most library <a id="_idIndexMarker033"/>authors won't like to say that you can use their library to do web scraping. Web Scraping has a reputation for being illegal. But in <a href="B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a><em class="italic">, Scraping tools</em>, we will see how to do web scraping in the right way, without getting banned or sued.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Content generation</h2>
			<p>Generating content<a id="_idIndexMarker034"/> is not a use case that would come to your mind if you had to think about possible use cases. But Puppeteer is a great tool for generating two kinds of content:</p>
			<ul>
				<li><strong class="bold">Screenshots</strong>: Why would you need to take screenshots using an app? Think about thumbnails or previews. Imagine you want to create a paywall, showing part of your website content but as a blurred image. You could use Puppeteer to take a screenshot of your site, blur it, and use that image. </li>
				<li><strong class="bold">PDF files</strong>: Invoices are a great example of PDF generation. Imagine you have an e-commerce site. When the user makes a purchase, you show them a nice, well-designed invoice, but you need to send them that exact invoice by email. You could use Puppeteer to navigate to that invoice page and print it to PDF. You could also use <a id="_idIndexMarker035"/>your landing page to generate a PDF and use it as a brochure.</li>
			</ul>
			<p>In <a href="B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 7</em></a>, <em class="italic">Generating Content with Puppeteer</em>, we will talk about this use case and how to use screenshots to write UI regression tests.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>End-to-end testing</h2>
			<p>I think Puppeteer is <a id="_idIndexMarker036"/>great for testing modern web apps because it's close to the browser. The API feels great, modern, and is designed for the JavaScript developer. It lets you execute JavaScript code easily and gives you access to all the power of Chromium. But I also have to say that Selenium's tolling for end-to-end testing is impressive. Puppeteer is not even close to what Selenium offers with its Selenium Grid. It's up to you to decide which is the right tool for you.</p>
			<p>Enough with the theory. It's time to get started and set up our environment.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Setting up the environment</h1>
			<p>What's good about <a id="_idIndexMarker037"/>Node.js and Puppeteer is that they are cross-platform. My local environment is macOS Catalina 10.15.6. But you won't see much difference if you use a Windows or a Linux environment.</p>
			<p>Time is a tech book's worst enemy. At the time of writing this book, I was using Node.JS 12.18.3 and Puppeteer 7. I'm pretty sure that by the time you read this book, new versions will have come to light. But don't feel discouraged about that; we expect that to happen. That's why I encourage you to go now and take a look at the GitHub repository of this book (<a href="https://github.com/PacktPublishing/ui-testing-with-Puppeteer">https://github.com/PacktPublishing/ui-testing-with-Puppeteer</a>). If you see that something is not working or has changed, please create an issue on that repository. We will try to keep it updated.</p>
			<p>We only need two things to run our first Puppeteer code: Node.JS and Puppeteer. Let's begin with Node.JS.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Node.js</h2>
			<p>For the purposes of this book, the only thing you need to know about Node.js is that it's a runtime that allows us to run JavaScript code outside the browser.</p>
			<p>It's important to highlight that the website we want to automate doesn't necessarily need to run on <a id="_idIndexMarker038"/>Node.js. You wouldn't need to know the language used to write the website, nor the platform that the website is running, but if you get to know those details, that could give you some ideas to write better automation code. For instance, if you know that the site is an ASP.NET Webforms project, you will know that it uses some hidden inputs to perform postbacks. That becomes more evident if you know the client-side frameworks, such as Vue or React. </p>
			<p>As I mentioned before, we will install Node.JS v12.18.3 (or higher). The process is quite simple:</p>
			<ol>
				<li>Go to the <a id="_idIndexMarker039"/>official site: <a href="https://nodejs.org/">https://nodejs.org/</a>.</li>
				<li>Download the LTS version. <strong class="bold">LTS</strong> stands <a id="_idIndexMarker040"/>for <strong class="bold">Long-Term Support</strong>.</li>
				<li>Run the installer as you would typically do on your platform:</li>
			</ol>
			<div><div><img src="img/Figure_1.04_B16113.jpg" alt="Node.js setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Node.js setup</p>
			<p>If you want to<a id="_idIndexMarker041"/> see whether the installation was successful, you can open a terminal and execute <code>node --version</code>:</p>
			<pre>~ % node --version
v12.18.3</pre>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Visual Studio Code</h2>
			<p>You don't need any special code <a id="_idIndexMarker042"/>editor to write a Node.js app. But Visual Studio Code is a great editor. It's free, cross-platform, and you can use it not only to code JavaScript, but also to code in many other languages as well.</p>
			<p>You can download <a id="_idIndexMarker043"/>it at <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. It doesn't even require running <a id="_idIndexMarker044"/>a setup on macOS. It's just an app you copy to your <code>Applications</code> folder:</p>
			<div><div><img src="img/Figure_1.05_B16113.jpg" alt="Visual Studio Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Visual Studio Code</p>
			<p>Now that we have Node.js installed along with a code editor, we can create our first app. </p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Our first Puppeteer code</h1>
			<p>We first need to create a folder where our <code>hello-puppeteer </code>project will be located. I'm going to use a<a id="_idIndexMarker045"/> terminal, but you can use whatever you feel more comfortable with. Our project will be called <code>hello-puppeteer</code>:</p>
			<pre>&gt; mkdir hello-puppeteer
&gt; cd hello-puppeteer</pre>
			<p>We now need to initialize this brand-new node.js application. We create new applications in node.js <a id="_idIndexMarker046"/>using the <code>npm init</code> command. In this case, we will pass the <code>-y</code> argument, so it creates our app using default values:</p>
			<pre>&gt; npm init -y
Wrote to /Users/neo/Documents/Coding/hello-puppeteer/package.json:
{
  "name": "hello-puppeteer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}</pre>
			<p>This output doesn't say much. It shows us that it has created a <code>package.json</code> file with some default values. Now, I will create an <code>index.js</code> file using the <code>touch</code> command. Again, you can perform this action in the way you feel most comfortable:</p>
			<pre>&gt; touch index.js</pre>
			<p>Touch should have created the entry point of our app. But before coding our app, we need to install Puppeteer.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Installing Puppeteer</h2>
			<p>Most frameworks, if <a id="_idIndexMarker047"/>not all of them, have a way to publish and reuse components from different authors. The most popular package manager in Node.js is <code>npm init</code> to<a id="_idIndexMarker048"/> create our app. As Puppeteer is a package published in NPM, we can download and install it using the <code>npm install</code> command.</p>
			<p>If you don't want to jump between apps, you can open a terminal inside Visual Studio Code. If you are still in the terminal, you can open Visual Studio Code using the following command:</p>
			<pre>&gt; code .</pre>
			<p>That will open <a id="_idIndexMarker049"/>Visual Studio Code. Once there, you will be able to launch a new terminal from the <strong class="bold">Terminal</strong> menu, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_1.06_B16113.jpg" alt="Terminal inside Visual Studio Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Terminal inside Visual Studio Code</p>
			<p>After opening <a id="_idIndexMarker050"/>a terminal, we can install Puppeteer using <code>npm install</code>:</p>
			<pre>&gt; npm install puppeteer@"&gt;=7.0.0 &lt;8.0.0"
Downloading Chromium r848005 - 128 Mb [=========           ] 44% 5.3s</pre>
			<p>I would like to <a id="_idIndexMarker051"/>highlight two things here. As this book is based on <code>@"&gt;=7.0.0 &lt;8.0.0"</code>, which means that we want the latest Puppeteer version greater than or equal to <code>7.0.0</code> and less than version <code>8.0.0</code>. By forcing this version to be used, you will be able to follow the examples in this chapter using the same version I used. </p>
			<p class="callout-heading">Puppeteer versioning</p>
			<p class="callout">Puppeteer follows the <strong class="bold">Semantic Versioning Specification</strong> (<strong class="bold">SemVer</strong>) to version their releases, which means that<a id="_idIndexMarker053"/> those three numbers in <a id="_idIndexMarker054"/>the version follow a rule. A change in the major number (the first number) means that there was a breaking change in the API. When a package changes the major number, it tells you that the new version might break your code. A change in the minor number (the second number) means that they added new functionality, maintaining backward compatibility. Lastly, a change in the patch number means that they fixed a bug, maintaining backward compatibility.</p>
			<p class="callout">If you see that Puppeteer is in version 8, 9, or 10, it doesn't mean that this book is now obsolete. It means that they changed something that broke someone else's code. For instance, the change from version 6 to version 7 was just some change they made in the way they take screenshots.</p>
			<p>In real life, you can use the latest version available. And second, you might have noticed that the package downloaded a specific version of Chromium, in this case, <code>r848005</code>. That doesn't mean that your code won't work with any version of Chromium you download from the internet. But, remember, Puppeteer interacts with the browser using the Chrome DevTools Protocol, so it needs a version of Chromium that reacts in the way Puppeteer expects. In the case of Puppeteer v7.0.1, it needs Chromium 90.0.4403.0, and there is no guarantee that any other version of Chromium (newer or older) would work with your current Puppeteer version. It doesn't mean that it won't work. It means that it's not guaranteed. You need to experiment and see. You can check which chromium version you should use for every version of Puppeteer on the API page (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api">https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api</a>).</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Hello world in Puppeteer</h2>
			<p>Every language has<a id="_idIndexMarker055"/> its own hello world program. Puppeteer's hello world<a id="_idIndexMarker056"/> program would be navigating to <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">https://en.wikipedia.org/wiki/%22Hello,_World!%22_program</a> and taking a screenshot of the page. Let's see what it would look like:</p>
			<pre>const puppeteer = require('puppeteer');
(async function() {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto('https://en.wikipedia.org/wiki/%22Hello,_World!%22_program');
    await page.screenshot({ path: './screenshot.png'});
    browser.close();
})();</pre>
			<p>This is what we are <a id="_idIndexMarker057"/>doing in this small script:</p>
			<ol>
				<li value="1">We import the <a id="_idIndexMarker058"/>Puppeteer library using <code>require</code>.</li>
				<li>Launch a new browser.</li>
				<li>Open a new page (tab) inside that browser.</li>
				<li>Navigate to the Wikipedia page.</li>
				<li>Take a screenshot.</li>
				<li>Close the browser.</li>
			</ol>
			<p>I love how simple and easy it is to get started with Puppeteer. It's now time to run it. Using the same terminal you used to run <code>npm install</code>, now run <code>node index.js</code>:</p>
			<pre>&gt; node index.js</pre>
			<p>A Chromium browser opened, navigated to Wikipedia, and closed by itself. You didn't see it because it was a headless browser, but it happened. Now, if you check your working directory, you should have a new file called <code>screenshot.png</code>:</p>
			<div><div><img src="img/Figure_1.07_B16113.jpg" alt="Screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Screenshot</p>
			<p>Our code worked as<a id="_idIndexMarker059"/> expected. We got our screenshot from Wikipedia. </p>
			<p>I bet you noticed that <a id="_idIndexMarker060"/>we used four <strong class="bold">awaits</strong> in our small hello puppeteer example. Asynchronous programming plays a big role in Puppeteer. Let's now talk about asynchronous programming in JavaScript.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Asynchronous programming in JavaScript</h1>
			<p>Normally, a program runs <a id="_idIndexMarker061"/>synchronously, which means that each line of code is executed one after the other. Let's take, for instance, these two lines of code:</p>
			<pre>const x = 3 + 4;
console.log(x);</pre>
			<p>Those two lines will run in order. The result of <code>3 + 4</code> will be assigned to the <code>x</code> constant, and then the variable <code>x</code> will be printed on the screen using <code>console.log</code>. The <code>console.log</code> function can't start until <code>x</code> is assigned.</p>
			<p>But there are tasks, such as network requests, disk access, or any other I/O operation, that are time-consuming, and we don't necessarily want to wait for those tasks to finish to keep executing our code. For instance, we could start downloading a file, perform other tasks while that file is loading, and then check that file when the download is completed. Asynchronous programming will allow us to execute those long-running tasks without blocking our code.</p>
			<p>An asynchronous <a id="_idIndexMarker062"/>function returns a <strong class="bold">Promise</strong> immediately to avoid blocking your code while waiting for a task. This Promise is an object that can be in one of the <a id="_idIndexMarker063"/>following three states: </p>
			<ul>
				<li><strong class="bold">Pending</strong>: This means that the asynchronous task is still in progress.</li>
				<li><strong class="bold">Fulfilled</strong>: This means that the asynchronous task was completed successfully.</li>
				<li><strong class="bold">Rejected</strong>: This means that the asynchronous task has failed.</li>
			</ul>
			<p>Let's say that we have a function called <code>downloadAFileFromTheInternet</code>. The most common way to wait for a task to finish is to use the <code>await</code> keyword:</p>
			<pre>await downloadAFileFromTheInternet();</pre>
			<p>It's important to highlight that the <code>await</code> keyword here is not waiting for the function itself; it is waiting for the <code>Promise</code> returned by that function. That means that you can also assign that <code>Promise</code> to a variable and <code>await</code> it later in the code:</p>
			<pre>const promise = downloadAFileFromTheInternet();
// some code
await promise;</pre>
			<p>Or you can just not wait for the promise at all:</p>
			<pre>downloadAFileFromTheInternet();</pre>
			<p>If you want to learn more about asynchronous JavaScript, check out the <em class="italic">Asynchronous JavaScript Deep Dive</em> videos by Steven Hancock (<a href="https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665">https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665</a>).</p>
			<p>Puppeteer relies<a id="_idIndexMarker064"/> on asynchronous programming techniques because the communication between Puppeteer and Chrome DevTools is asynchronous. After all, the communication between Chrome DevTools and the browser is asynchronous. Think about what would happen under the hood when you click a link:</p>
			<div><div><img src="img/Figure_1.08_B16113.jpg" alt="Click timeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Click timeline</p>
			<p>When you call <code>page.click</code>, the result of that action is not immediate. As we saw, there are many things going on under the hood. When you call <code>page.click</code>, you will need to do one of the things mentioned previously: await it; keep the promise in a variable and await it later; or don't await it at all.</p>
			<p>Now that we know more about asynchronous programming, I would like to review five utilities that we will use across the book.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Promise.all</h2>
			<p><code>Promise.all</code> is a<a id="_idIndexMarker065"/> function that expects an array of promises and returns a promise that will be <strong class="bold">resolved</strong> when <strong class="bold">all</strong> the promises are <strong class="bold">fulfilled or rejected</strong>. Yes, a promise could be fulfilled, completed successfully, or rejected, which means it failed.</p>
			<p>A common scenario is clicking on a link, and waiting for the page to navigate to the next page:</p>
			<pre>await Promise.all([
  page.click('a'), 
  page.waitForNavigation()
]);</pre>
			<p>This promise will wait for the link to <code>click</code> and the <code>waitForNavigation</code> promises to be either fulfilled or rejected.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Promise.race</h2>
			<p>Like <code>Promise.all</code>, <code>Promise.race</code> expects an array of promises, but in this case, it will resolve when <strong class="bold">any</strong> of the <a id="_idIndexMarker066"/>promises are resolved.</p>
			<p>A typical usage is for timeouts. We want to take a screenshot, but only if it takes less than 2 seconds:</p>
			<pre>await Promise.race([
  page.screenshot(),
  new Promise((resolve,reject)=&gt;{ 
    setTimeout(()=&gt;{ 
      reject(new Error('Too long!!!'));},2000);
  })]);</pre>
			<p>In this case, if the <code>screenshot</code> promise takes more than 2,000 milliseconds, the promise created as the second element in the array will be <strong class="bold">rejected</strong>, rejecting the Promise.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Fulfilling our own promises</h2>
			<p>You saw in our previous example how you can create a<a id="_idIndexMarker067"/> promise, return that Promise or assign it to a variable, and then fulfill it.</p>
			<p>This is great when you want to wait for an event to happen. We can create a promise that will be resolved when the page closes:</p>
			<pre>const promise = new Promise((x) =&gt; page.on('close', x));
// …
await promise;</pre>
			<p>This kind of <code>await</code> is quite risky. If the Promise is never fulfilled, your code will hang. I recommend using these promises with <code>Promise.race</code> and timeouts.</p>
			<p>We will see lots of promises throughout this book. Maybe some recipes such as "fulfill our own promises" look odd now, but we will use them a lot.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Summary</h1>
			<p>We covered a lot in this first chapter. We learned about browser automation and the difference between Selenium and Puppeteer. Then we saw that Puppeteer isn't limited only to end-to-end testing and reviewed some use case scenarios. Then we got our hands dirty and coded our first Puppeteer script. In the last section of the chapter, we covered many asynchronous techniques that we will use in this book.</p>
			<p>In the next chapter, we are going to focus on end-to-end testing. We will review some tools available on the market and will consider how to organize our code to create reliable end-to-end tests.</p>
		</div>
	</body></html>