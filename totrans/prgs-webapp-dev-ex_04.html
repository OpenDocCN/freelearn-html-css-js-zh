<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service Workers – Notification, Synchronization, and Our Podcast App</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 1</a>, <em class="calibre13">Introduction to Progressive Web Apps</em>, you read about how the web has fallen short in the mobile era and why progressive web applications can level your website to equal or even better capabilities than native options. Service workers are the most important part of a progressive web application because they are the application's backbone.</p>
<p class="calibre2">The web manifest and the home screen icon enhance the ability to develop a relationship with the customer and control the launch experience. Service workers enable a programmatic user experience enhancement when a page is loaded and even when it isn't.</p>
<p class="calibre2">Service workers sit between the browser and the network and act as a proxy server. They provide more than just a caching layer; they are an extensible backbone:</p>
<div class="cdpaligncenter"><img src="../images/00047.gif" class="calibre61"/></div>
<p class="calibre2">For the coder, <strong class="calibre4">service workers</strong> are JavaScript files, making them familiar to most web developers. These scripts are more like Node.js modules than a web page script. They execute on a separate thread from the UI service workers, so they do not have access to the DOM.</p>
<p class="calibre2">The service worker programming model is more functional than what you might use for the user interface. The node comparison makes sense in that the service worker programming is headless and used to perform calculations, with many tasks being traditionally reserved for the web server.</p>
<p class="calibre2">Service workers also differ from UI scripts because they are completely asynchronous. This means some APIs, such as XHR and localStorage, are not supported. Instead, you should use the Fetch API and <strong class="calibre4">IndexedDB</strong> (<strong class="calibre4">IDB</strong>) to connect with APIs and persist data. When a browser supports service workers, they must also support promises, providing a natural asynchronous interface.</p>
<div class="packt_tip">
<p class="calibre62">A note about <kbd class="calibre63">XMLHttpRequest</kbd>, when initiated from the client the request passes through the service worker. You cannot initiate an XHR request from a service worker.</p>
</div>
<p class="calibre2">Service workers are designed to be an extensible platform, allowing for additional APIs to be added over time. Cache is the only extension API that the specification details. Native push notifications and background sync are examples of additional APIs that are enabled by service workers. In the future, you can expect many more APIs to be added.</p>
<p class="calibre2">Caching enables offline and instant asset loading. I think the best term to describe this feature is a proxy server in the browser. Advanced service workers act almost like a complete web server stack. A well-crafted service worker can assume rendering responsibilities currently allocated to ASP.NET, Node Express, and Ruby, and many more.</p>
<p class="calibre2">The last chapter covered adding HTTPS to your site. If you were not sold on the concept yet, you will be now. Service workers also require SSL. The main reason service workers require SSL is to enable APIs and other features requiring a higher level of trust.</p>
<p class="calibre2">The power service workers that have been enabled could be used for evil purposes. In addition to requiring SSL, they are also limited in scope to a single domain. They do not have the ability to manipulate anything outside the scope of the domain that hosts the script.</p>
<p class="calibre2">This is a good thing because a third-party script cannot register a service worker and do bad things to your site.</p>
<p class="calibre2">On the surface, this may seem simple, but there is an art to mastering service workers. The following chapters are designed to give you the foundation needed to create service workers that enhance any website.</p>
<p class="calibre2">In this chapter you will learn:</p>
<ul class="calibre10">
<li class="calibre11">The service worker threading model</li>
<li class="calibre11">Service worker browser support</li>
<li class="calibre11">How the example podcast application works</li>
<li class="calibre11">An introduction to the fetch API</li>
<li class="calibre11">How to create a basic service worker</li>
<li class="calibre11">The service worker life cycle</li>
<li class="calibre11">Service worker caching basics</li>
<li class="calibre11">How to use push notifications</li>
<li class="calibre11">An introduction to background sync programming</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The service worker thread</h1>
                
            
            <article>
                
<p class="calibre2">Service workers run within their own context or thread outside the UI. Because the service worker thread is separate from the UI, it does not have access to the DOM.</p>
<p class="calibre2">The service worker scope is event driven, meaning the platform (browser or operating system, depending on your point of view) initiates the service worker. When the service worker initiates, it does so with the intent of responding to an event, such as a web page opening, a push notification, or another event.</p>
<p class="calibre2">The process stays alive long enough to service the need. This time is determined by the browser and varies by platform. There is no fixed time defined in the service worker specification.</p>
<p class="calibre2">Running in a separate context from the normal JavaScript offers many advantages to service workers. The first is that a service worker script does not block the UI from rendering. You can use this feature to offload non-UI work to the service worker. An example we will see in a later chapter shows how to use client-side templating to render markup in the service worker and not the UI thread.</p>
<p class="calibre2">This gives you a way to separate tasks into more appropriate threads. Now, you can perform calculations such as math or rendering markup in response to an API call and return it to the UI thread to update the DOM.</p>
<p class="calibre2">The service worker can communicate with the UI thread through the messaging API. You can pass text messages back and forth between threads. You can also modify responses from the server before they reach the UI thread.</p>
<p class="calibre2">Features like push notifications are possible because service workers execute in their own context. A service worker can spin up in response to an event triggered by the operating system and not because a page is loaded.</p>
<p class="calibre2">In the past, web-based push notifications have been possible by using web workers. These are great tools, but only execute when the browser is open. Service workers differ because the operating system can spin them up due to an external stimulus. The only real requirement is that the client device should be powered on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service worker browser support</h1>
                
            
            <article>
                
<p class="calibre2">Service worker is a relatively new technology, leading to a common question: is it safe to use service workers? What we are really asking is, how many browsers support service workers?</p>
<p class="calibre2">The good news is all major browsers have shipped basic service worker support. Chrome has been the leader as they have been largely responsible for initiating the concept and managing the specification. The technology has received enthusiastic support from other browser vendors including Microsoft, FireFox, Samsung, and Opera.</p>
<p class="calibre2">As of the Spring of 2018 all modern browsers had shipped updates to general consumers with at least service worker caching support. Of course, older browsers won't support service workers. But their usage is winding down as consumers upgrade phones and laptops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Microsoft Edge service worker support</h1>
                
            
            <article>
                
<p class="calibre2">At the september 2017 Edge Web Summit, Microsoft announced they were shipping service worker support behind a flag. The goal is to flesh out any bugs in the implementation before general consumer support ships.</p>
<p class="calibre2">In the Spring of 2018 support for service workers was shipped to general consumers with when Windows RS4 was released.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Safari service worker support</h1>
                
            
            <article>
                
<p class="calibre2">If you are not familiar with how Apple announces web API support, they don't. New features quietly ship and are left for developers to discover, at least in most cases.</p>
<p class="calibre2">In a surprise release Apple updated Safari in March 2018 to support service workers:</p>
<div class="cdpaligncenter"><img src="../images/00048.jpeg" class="calibre64"/></div>
<p class="calibre2">There are some limitations to Safari service worker support. For now, they do not support native push notifications or background sync. I don't consider these missing features a reason to avoid integrating them in your applications. Remember progressive web apps are about taking advantage of features as they are available. You can still create viable work around to these features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Is the service worker ready?</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre13">Jake Archibald</em> maintains a GitHub site that tracks each mainstream browser's support of service worker-related features (<a href="https://jakearchibald.github.io/isserviceworkerready/" class="calibre9">https://jakearchibald.github.io/isserviceworkerready/</a>), called is<em class="calibre13"> service worker Ready.</em>.</p>
<p class="calibre2">The site features rows, focusing on each primary service worker feature and their requirements with each browser's icon. The grayscale browser icons indicate that support has not shipped. Icons with a yellow background have shipped partial support. A green background indicates full support of the feature:</p>
<div class="cdpaligncenter"><img src="../images/00049.jpeg" class="calibre65"/></div>
<div class="title-page-name">
<p class="calibre2">As you can see the major browser players all support service workers.</p>
<p class="calibre2">Now that all modern browsers support service workers you may think there is no reason to work about browsers without service worker support. But there are still an important percentage of browser sessions using Internet Explorer and legacy Android browsers. This means you may want to consider fallback options.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Polyfilling older browsers</h1>
                
            
            <article>
                
<p class="calibre2">Polyfills are libraries or fallbacks you can reference as needed to add support for modern features to browsers lacking support. Not all modern features can't be polyfilled, but many can. Some are not direct polyfills, but leveraging other APIs to create the desired experience.</p>
<p class="calibre2">The good news is that you can polyfill a service worker caching to a point. This can be done using <kbd class="calibre12">IndexedDB</kbd>. You will need an extra layer of JavaScript to manage the site's assets and API calls. We will touch on this technique in the advanced caching chapter.</p>
<p class="calibre2">In addition to using <kbd class="calibre12">IndexedDB</kbd> to cache assets, you can also use <kbd class="calibre12">appCache</kbd> as an offline and asset caching fallback.</p>
<p class="calibre2">Push notifications cannot be polyfilled, but you can utilize alternative notification mediums. SMS texting and web worker notifications can provide ways for the business to engage with customers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The podcast application</h1>
                
            
            <article>
                
<p class="calibre2">This chapter introduces you to different service worker concepts and features like the service worker life cycle, caching, and push notifications. To do this, we are going to build a simple podcast application. This application will demonstrate how to tackle the service worker life cycle and response caching:</p>
<p class="calibre2">The minimal podcast application requirements include:</p>
<ul class="calibre10">
<li class="calibre11">Fast loading</li>
<li class="calibre11">Search podcasts</li>
<li class="calibre11">Favorite podcasts</li>
<li class="calibre11">Play audio files</li>
<li class="calibre11">Persist episodes for offline listening</li>
</ul>
<p class="calibre2">The application requires some server-side help, which for our purposes will be a set of snapshot data I took from public sources. The data is part of the project repository (<a href="https://github.com/docluv/PWAPodcast" class="calibre9">https://github.com/docluv/PWAPodcast</a>), so you can recreate the application.</p>
<p class="calibre2">You will learn how to register a service worker, the basics of the service worker life cycle, how service worker caching works, and how to use <kbd class="calibre12">IndexedDB</kbd> to persist data. You will also see how to utilize service worker cache and <kbd class="calibre12">IndexedDB</kbd> to persist MP3 media files.</p>
<p class="calibre2">The podcast application source code is organized by folders that correlate to each chapter's progress. The root folder contains common files to define the Grunt tasks to run local web servers, just like the 2048 application.</p>
<p class="calibre2">Inside each chapter's folder there are folders for assets, such as CSS, JavaScript, and images. Each route also has a folder with a single <kbd class="calibre12">index.html</kbd> file. This allows the application to use extensionless URLs. The data files are stored under the API folder.</p>
<p class="calibre2">The application consists of the following pages:</p>
<pre class="calibre17">/ (home)<br class="title-page-name"/>/podcasts/<br class="title-page-name"/>/podcast/{slug}<br class="title-page-name"/>/episode/{slug}<br class="title-page-name"/>/search?q={term}<br class="title-page-name"/>/later/</pre>
<p class="calibre2">Each page is a static page, pre-rendered as part of the site build process. The logic behind this is beyond the scope of this book.</p>
<p class="calibre2">The application's data comes from the iTunes API. It did require some data manipulation to make it usable in the application. I have included the raw data files in the GitHub repository if you would like to use or study them.</p>
<p class="calibre2">The Apple data model needs to be transformed for the application. Instead of standing up a web server to host a formal API, the data is stored in a series of JSON files. The application will reference those files as needed.</p>
<p class="calibre2">The service worker is in the application's root folder. This file is the centerpiece of this chapter and we will spend most of our time changing it in each chapter. It will demonstrate the service worker life cycle and basic caching concepts.</p>
<p class="calibre2">You can try the finished version at <a href="https://podcast.love2dev.com" class="calibre9">https://podcast.love2dev.com</a>:</p>
<div class="cdpaligncenter"><img src="../images/00050.jpeg" class="calibre66"/></div>
<div class="cdpaligncenter2">Home page of PWA Podstr</div>
<p class="calibre2">The home page contains a list of podcasts that the user is subscribed to. This is populated by an API call to retrieve the list. It is then rendered in the browser using <kbd class="calibre12">Mustache</kbd>. All API data is a set of JSON files, so there is no messy code needed to connect and stand up a database:</p>
<div class="cdpaligncenter"><img src="../images/00051.jpeg" class="calibre67"/></div>
<p class="calibre2">The podcast page displays details about the podcast and a list of recent episodes. The podcast data is also retrieved via an API call:</p>
<div class="cdpaligncenter"><img src="../images/00052.jpeg" class="calibre68"/></div>
<p class="calibre2">The episode page lists the title and description of an episode. It includes an AUDIO element that plays the mp3 file. Again, the page is rendered after retrieving the data from the server:</p>
<div class="cdpaligncenter"><img src="../images/00053.jpeg" class="calibre69"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Fetch API</h1>
                
            
            <article>
                
<p class="calibre2">Way back in 1996, Internet Explorer introduced the <em class="calibre13">iframe</em> element as a way to load web content asynchronously in a web page. Over the next two years, the concept evolved into the first implementation of what we now know as the <kbd class="calibre12">XMLHttpReqest</kbd> object.</p>
<p class="calibre2">Back then, it was known as <kbd class="calibre12">XMLHTTP</kbd> and was first shipped in Internet Explorer 5.0. Soon after, Mozilla, Safari, and Opera all shipped implementations of what we now call <kbd class="calibre12">XMLHttpRequest</kbd>.</p>
<p class="calibre2">Up to this point, web pages were static and required an entire reload when a user navigated from one page to another inside the same site.</p>
<p class="calibre2">In 2004, Google started making wide use of what we now call <strong class="calibre4">AJAX</strong> in Gmail and Google Maps. They showed us how to leverage in-browser requests to the server and how to manipulate the DOM in response to the server's payload. This is typically done by calling an API that returns JSON data.</p>
<p class="calibre2">As with any technology, as it is used, <strong class="calibre4">implementers</strong> get frustrated dealing with issues revealed through usage. In response to new use cases and issues, the technology updates, typically by releasing a new version.</p>
<p class="calibre2">Sometimes, those updates are so major a new technology, product, or implementation replaces the first version.</p>
<p class="calibre2"><kbd class="calibre12">XMLHttpRequest</kbd> provides a mechanism to make asynchronous calls to the server, but does so based on how the web and browsers worked over a decade ago.</p>
<p class="calibre2">Today, the web has expanded in many ways. One feature we now have ubiquitous support for is JavaScript Promises. We also have deeper insight into what types of content can be made using asynchronous calls to a server that we did not think about when AJAX was first being specified.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing Fetch</h1>
                
            
            <article>
                
<p class="calibre2">After identifying common limitations of the <kbd class="calibre12">XMLHttpRequest</kbd> object, the Fetch API was standardized to provide a new, better thought out way to implement asynchronous HTTP requests.</p>
<p class="calibre2">The Fetch API is a brand new way to make AJAX calls. It was created to solve many of the problems we developers hack and work around to handle <kbd class="calibre12">XMLHttpRequest</kbd> limitations. The primary difference is that Fetch is asynchronous when using Promises.</p>
<p class="calibre2">It first started seeing browser implementations in the Spring of 2016 and now enjoys broad support by all modern browsers. If you have not started using Fetch to make asynchronous HTTP requests, you should start migrating as soon as possible.</p>
<p class="calibre2">Three key features that make Fetch stand apart from the <kbd class="calibre12">XMLHttpRequest</kbd> object is simpler syntax, native promise support, and the ability to manipulate requests and responses:</p>
<div class="cdpaligncenter"><img src="../images/00054.jpeg" class="calibre52"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Fetch API</h1>
                
            
            <article>
                
<p class="calibre2">Because AJAX has become a popular way to drive DOM manipulations, let's see how this is done using Fetch. This will be a slightly contrived example where a Podcast's logo is fetched and set to the corresponding <kbd class="calibre12">IMG</kbd> element:</p>
<pre class="calibre17">var logo = document.querySelector('.podcast-logo');<br class="title-page-name"/><br class="title-page-name"/>fetch("…/600x600bb.jpg").then(function(response) {<br class="title-page-name"/>  return response.blob();<br class="title-page-name"/>}).then(function(logoBlob) {<br class="title-page-name"/>  var objectURL = URL.createObjectURL(logoBlob);<br class="title-page-name"/>  logo.src = objectURL;<br class="title-page-name"/>});</pre>
<p class="calibre2">If you are familiar with composing an <kbd class="calibre12">XMLHttpRequest</kbd>, this example should look very clean and simple. The first thing you will notice is that the only parameter needed is a URL. This is the simplest form of fetch.</p>
<p class="calibre2">This code does the same thing, but uses the <kbd class="calibre12">XMLHttpRequest</kbd> object:</p>
<pre class="calibre17">var xhr = new XMLHttpRequest();<br class="title-page-name"/><br class="title-page-name"/>xhr.open("GET", "…/600x600bb.jpg", true);  <br class="title-page-name"/>xhr.overrideMimeType('text/plain; charset=x-user-defined');<br class="title-page-name"/>xhr.send(null);<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>xhr.onreadystatechange = function() {<br class="title-page-name"/>    if (xhr.readyState == 4){<br class="title-page-name"/>      if ((xhr.status == 200) || (xhr.status == 0)){<br class="title-page-name"/>            var logo = document.querySelector('.podcast-logo');<br class="title-page-name"/>            logo.src = "data:image/gif;base64," + <br class="title-page-name"/>            encode64(xhr.responseText);<br class="title-page-name"/>      }else{<br class="title-page-name"/>            alert("Something misconfiguration : " +<br class="title-page-name"/>            "\nError Code : " + xhr.status +<br class="title-page-name"/>            "\nError Message : " + xhr.responseText);<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>};</pre>
<p class="calibre2">This is not quite as clean and not asynchronous. This example is rather simple. In most cases, AJAX requests require more complexity.</p>
<p class="calibre2">The fetch method returns a promise, which resolves a response object. This represents that response, not the image we wanted. Access to the image is done by calling the blob mixin, which also returns a promise.</p>
<p class="calibre2">The blob is the image, which can then be used by the <kbd class="calibre12">URL.createObjectUrl</kbd> function to convert the bytes to a usable image format that can be applied to the image's src property.</p>
<p class="calibre2">While contrived, this example demonstrates multiple aspects of the Fetch API you should familiarize yourself with. The API provides a simple surface to make requests, but allows you to make very complex request handler logic.</p>
<p class="calibre2">Along with the fetch method, the API also specifies request, response, and header objects. There is also a collection of body mixins, designed to manipulate different response types.</p>
<p class="calibre2">Instead of passing just the URL to the fetch method, you can also pass a composed request object. A request object contains the values to make network requests.</p>
<p class="calibre2">The request constructor has two parameters, the URL and an optional options object. You can also supply an existing request object, which may sound odd, but as you learn how to use service workers, you will realize this will be a common starting point.</p>
<p class="calibre2">The options parameter can contain the following properties:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">method</kbd>: The HTTP request method: <kbd class="calibre12">GET</kbd>, <kbd class="calibre12">POST</kbd>, <kbd class="calibre12">PUT</kbd>, <kbd class="calibre12">DELETE</kbd>, and so on.</li>
<li class="calibre11"><kbd class="calibre12">headers</kbd>: Custom request headers, which can be either a headers object or an object literal.</li>
<li class="calibre11"><kbd class="calibre12">body</kbd>: Any body that you want to add to your request: a <kbd class="calibre12">Blob</kbd>, <kbd class="calibre12">BufferSource</kbd>, <kbd class="calibre12">FormData</kbd>, <kbd class="calibre12">URLSearchParams</kbd>, <kbd class="calibre12">USVString</kbd>, or <kbd class="calibre12">ReadableStream</kbd> object.</li>
<li class="calibre11"><kbd class="calibre12">mode</kbd>: The request mode, for example, <kbd class="calibre12">cors</kbd>, <kbd class="calibre12">no-cors</kbd>, <kbd class="calibre12">same-origin</kbd>, or <kbd class="calibre12">navigate</kbd>. The default is <kbd class="calibre12">cors</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">credentials</kbd>: The requested credentials you want to use for the request: omit, same-origin, or include.</li>
<li class="calibre11"><kbd class="calibre12">cache</kbd>: Similar to the properties used in the Cache-Control header. This tells the browser how to interact with the local cache.</li>
</ul>
<p class="calibre2">Other, less common properties are cache, redirect, referrer, and integrity.</p>
<p class="calibre2">We can use the preceding example and expand it to use a custom request object:</p>
<pre class="calibre17">var logoHeaders = new Headers();<br class="title-page-name"/>logoHeaders.append('Content-Type', 'image/jpeg');<br class="title-page-name"/><br class="title-page-name"/>var logoInit = { method: 'GET',<br class="title-page-name"/>                  headers: logoHeaders,<br class="title-page-name"/>                  mode: 'cors',<br class="title-page-name"/>                  cache: 'default'<br class="title-page-name"/>         };<br class="title-page-name"/><br class="title-page-name"/>var logoRequest = new Request("…/600x600bb.jpg", logoInit);<br class="title-page-name"/><br class="title-page-name"/>fetch(logoRequest).then(function(response) {<br class="title-page-name"/>  return response.blob();<br class="title-page-name"/>}).then(function(logoBlob) {<br class="title-page-name"/>  logo.src = URL.createObjectURL(logoBlob);<br class="title-page-name"/>});</pre>
<p class="calibre2">You should note that the fetch method will only reject when there is a network error. When an exception is thrown, the network cannot be reached, for example, when the device is offline. It will not fail for a non-2XX status code.</p>
<p class="calibre2">This means you must validate the response as being good, not found, a redirect, or a server error. You can build a robust logic tree to handle different status codes. If all you need to do is respond to a good request, you can use the <kbd class="calibre12">response.ok</kbd> property.</p>
<p class="calibre2">If the response has a 200-299 status, good, then the ok property is true. Otherwise, it is false.</p>
<p class="calibre2">You should handle exceptions differently than responses with status code. For example, if a response has a status code of 403, then you could redirect to a login form. A 404 status should redirect to a not found page.</p>
<p class="calibre2">If there is a network error, then you could trigger an appropriate visual response like an error message or triggering your application’s offline mode experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The response object</h1>
                
            
            <article>
                
<p class="calibre2">The fetch method resolves a response object. This is similar to the request object, with a few differences. It represents a server response for a request.</p>
<p class="calibre2">The response object has the following properties:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">headers</kbd>: The headers object</li>
<li class="calibre11"><kbd class="calibre12">ok</kbd>: Indicates if the status in in the 200-299 range</li>
<li class="calibre11"><kbd class="calibre12">redirected</kbd>: Indicates if the response is from a redirect</li>
<li class="calibre11"><kbd class="calibre12">status</kbd>: The HTTP status code, for example, 200 for good</li>
<li class="calibre11"><kbd class="calibre12">statusText</kbd>: The status message of the corresponding code</li>
<li class="calibre11"><kbd class="calibre12">type</kbd>: The type of response, for example, cors or basic</li>
<li class="calibre11"><kbd class="calibre12">url</kbd>: The response URL</li>
<li class="calibre11"><kbd class="calibre12">bodyUsed</kbd>: A Boolean indicating whether the body has been used</li>
</ul>
<p class="calibre2">There are several methods you should also know about:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">clone</kbd>: Makes a clone of the response object</li>
<li class="calibre11"><kbd class="calibre12">arrayBuffer</kbd>: Returns a promise that resolves to an <kbd class="calibre12">arrayBuffer</kbd></li>
<li class="calibre11"><kbd class="calibre12">blob</kbd>: Returns a promise that resolves to a blob</li>
<li class="calibre11"><kbd class="calibre12">formData</kbd>: Returns a promise that resolves to a <kbd class="calibre12">formData</kbd> object</li>
<li class="calibre11"><kbd class="calibre12">json</kbd>: Returns a promise that resolves the body text to a JSON object</li>
<li class="calibre11"><kbd class="calibre12">text</kbd>: Returns a promise that resolves the body text</li>
</ul>
<p class="calibre2">The preceding example showed how to use the blob method to create an image. A more common task web apps have is retrieving data from an API. Typically, the response is text, containing a JSON.</p>
<p class="calibre2">A common user task in a podcast application is to search for podcasts and episodes. Our podcast application has a search form built into the layout header. It has logic bound to it to call an API and return a set of results.</p>
<p class="calibre2">The Podstr application uses a single JSON file to serve as an example search result. This is done so we do not need to build a server-side search infrastructure. A production application would have a more formal setup.</p>
<p class="calibre2">The search results are formatted to contain two arrays, a list of matching podcasts, and another for matching episodes:</p>
<pre class="calibre17">[<br class="title-page-name"/>      podcasts: [<br class="title-page-name"/>            {…}<br class="title-page-name"/>],<br class="title-page-name"/>      episodes: [<br class="title-page-name"/>            {…}<br class="title-page-name"/>]<br class="title-page-name"/>}</pre>
<p class="calibre2">The search results are displayed on the search page by rendering the results against a template. Retrieving the results is done via a fetch request that uses the JSON method:</p>
<pre class="calibre17">var searchResults = document.querySelector('.search-results');<br class="title-page-name"/><br class="title-page-name"/>fetch("api/search?term={term}").then(function(response) {<br class="title-page-name"/>  return response.json();<br class="title-page-name"/>}).then(function(results) {<br class="title-page-name"/>  renderResults(results);<br class="title-page-name"/>});</pre>
<p class="calibre2">The <kbd class="calibre12">renderResults</kbd> function runs the results object through a <kbd class="calibre12">Mustache</kbd> template and assigns the rendered markup to the <kbd class="calibre12">search-results</kbd> element:</p>
<pre class="calibre17">    function renderResults(results) {<br class="title-page-name"/><br class="title-page-name"/>        var template = document.getElementById("search-results-<br class="title-page-name"/>        template"),<br class="title-page-name"/>            searchResults = document.querySelector('.search-results');<br class="title-page-name"/><br class="title-page-name"/></pre>
<pre class="calibre17">            searchResults.innerHTML =             <br class="title-page-name"/>            Mustache.render(template.innerHTML, results);<br class="title-page-name"/><br class="title-page-name"/>    }</pre>
<p class="calibre2">If you are not familiar with <kbd class="calibre12">Mustache</kbd>, it is a minimalist template engine. The render method takes an HTML template and merges a JSON object to produce markup. If you want to know more about using <kbd class="calibre12">Mustache</kbd>, visit the GitHub page (<a href="https://github.com/janl/mustache.js/" class="calibre9">https://github.com/janl/mustache.js/</a>).</p>
<p class="calibre2">The search page demonstrates how to make an API call to dynamically compose a page. This is common for web applications today. We don't go back and forth and let the server render new markup in response to an action, like submitting a form.</p>
<p class="calibre2">Instead, we migrated to a model that has evolved to what we commonly call a single page application. Pages are no longer static experiences, we can change them dynamically.</p>
<p class="calibre2">The ability to make an API call to the server without making a complete round trip. Fetch makes this possible and simpler than before. Template libraries like <kbd class="calibre12">Mustache</kbd> make it simple to render markup on the client.</p>
<p class="calibre2">If you are familiar with jQuery's ajax method, you will note some similarities to fetch. There are few key differences.</p>
<p class="calibre2">The promise returned from <kbd class="calibre12">fetch()</kbd> won't reject on HTTP error status, even if the response is an HTTP 404 or 500 error. Instead, it will resolve normally (with the <kbd class="calibre12">ok</kbd> status set to false), and it will only reject on network failure or if anything prevented the request from completing.</p>
<p class="calibre2">By default, fetch won't send or receive any cookies from the server, resulting in unauthenticated requests if the site relies on maintaining a user session (to send cookies, the credentials init option must be set).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service worker fetch</h1>
                
            
            <article>
                
<p class="calibre2">Service workers rely on promises and asynchronous APIs. This eliminates platform features such as <kbd class="calibre12">XMLHttpRequest</kbd> from being used in a service worker. Service workers are dependent on the browser supporting promises and the fetch API.</p>
<p class="calibre2">A basic understanding of using fetch is a fundamental skill required for service worker programming. Service workers allow you to intercept all network requests before they are sent to the network. This is done by adding a fetch event handler:</p>
<pre class="calibre17">self.addEventListener('fetch', function(event) {<br class="title-page-name"/>  event.respondWith(<br class="title-page-name"/>    caches.match(event.request)<br class="title-page-name"/>      .then((response) =&gt;{<br class="title-page-name"/>        // Cache hit - return response<br class="title-page-name"/>        if (response) {<br class="title-page-name"/>          return response;<br class="title-page-name"/>        }<br class="title-page-name"/>        return fetch(event.request);<br class="title-page-name"/>      }<br class="title-page-name"/>    )<br class="title-page-name"/>  );<br class="title-page-name"/>});</pre>
<p class="calibre2">The event handler receives a single <kbd class="calibre12">FetchEvent</kbd> object. There are two members of the <kbd class="calibre12">FetchEvent</kbd> object you need to know, which are <kbd class="calibre12">request</kbd> and <kbd class="calibre12">respondWith</kbd>.</p>
<p class="calibre2">The request property is the request object is being sent to the network. The <kbd class="calibre12">respondWith</kbd> method restricts the fetch event handler. It keeps the event handler <em class="calibre13"><span class="calibre5"><span class="calibre5">open</span></span></em> until the response is ready. The method also requires a response object to be returned.</p>
<p class="calibre2">The service worker fetch event allows you to intercept requests to the network. This power allows you to interrogate the request and return a cached response, compose a custom response, or return a network response. We will cover ways to use this power in the service worker caching chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Polyfilling fetch in legacy browsers</h1>
                
            
            <article>
                
<p class="calibre2">Fetch and other modern APIs enjoy broad support by major browsers. However, there is still enough users using older browsers. Many enterprises still require employees to use obsolete versions of Internet Explorer. Many consumers that are happy with older phones and do not upgrade their devices or update software often.</p>
<p class="calibre2">This means we need to make our websites adaptable to these potential scenarios. Fortunately, many APIs can be polyfilled with JavaScript libraries. Fetch and promises are modern features that can easily be polyfilled.</p>
<p class="calibre2">Just like we feature detect service worker support, we can feature detect fetch and promise support. If those features are not supported, we can then load a polyfill. It is important that these polyfills are loaded in a dependent order where promises are followed by fetch, which is then followed by any site-specific code:</p>
<pre class="calibre17">        var scripts = ["js/libs/jquery.small.js",<br class="title-page-name"/>            "js/libs/index.js",<br class="title-page-name"/>            "js/libs/collapse.js",<br class="title-page-name"/>            "js/libs/util.js",<br class="title-page-name"/>            "js/app/app.js"<br class="title-page-name"/>        ];<br class="title-page-name"/><br class="title-page-name"/>    if (typeof fetch === "undefined" || fetch.toString().indexOf("[native code]") === -1) {<br class="title-page-name"/>        scripts.unshift("js/polyfill/fetch.js");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (typeof Promise === "undefined" || Promise.toString().indexOf("[native code]") === -1) {<br class="title-page-name"/>        scripts.unshift("js/polyfill/es6-promise.min.js");<br class="title-page-name"/>    }</pre>
<p class="calibre2">This is a technique of asynchronously loading scripts I borrowed from an HTML5 Rocks article (<a href="https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread" class="calibre9">https://www.html5rocks.com/en/tutorials/speed/script-loading/#disqus_thread</a>). Most of the time, the polyfills are not needed, but for those cases where a polyfill is needed, you need to control the order the scripts are loaded in.</p>
<p class="calibre2">The technique uses an array of script URLs and loops through them, appending each to the DOM while maintaining an order of dependence.</p>
<p class="calibre2">Because the polyfills are not needed all the time, they are only added as necessary. This is determined by checking for native support. In the example code, both promise and fetch are detected. If they are not supported, then they are added to the array of script URLs and are added before the other scripts.</p>
<p class="calibre2">Promises are also checked because fetch depends on promise support. The Podstr application only needs to potentially use the fetch and promise polyfill.</p>
<p class="calibre2">But there are many API polyfills that your application might need. The HTML5 Cross Browser polyfill (<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills" class="calibre9">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills</a> ) repository is a great place to find more. You can use the same feature detection technique to add them as necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a service worker shell</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0020.html#J2B80-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 1</a>, <em class="calibre13">Introduction to Progressive Web Apps</em>, we created a basic service worker that pre-cached the 2048 game assets. In this and the following chapters, we will dive deeper into the details of a service worker.</p>
<p class="calibre2">The service worker goes through several stages in its overall life cycle. A service worker is registered. Once the script is loaded, it triggers the ‘install’ event. At this point, the service worker is not in control of the client (browser tab).</p>
<p class="calibre2">When the service worker is cleared to control client contexts, the activate event is triggered. After this, the service worker is fully active and in control of any active clients, be they tabs or background processes.</p>
<p class="calibre2">Proper service workers take advantage of the event life cycle to manage data, like cached responses, to set the service worker context.</p>
<p class="calibre2">The podcast application starts with a simple service worker script containing handlers for the install, activate, and fetch events:</p>
<pre class="calibre17">self.addEventListener('install', (event) =&gt; {<br class="title-page-name"/>      //install event handler<br class="title-page-name"/>});<br class="title-page-name"/><br class="title-page-name"/>self.addEventListener('activate', (event) =&gt; {<br class="title-page-name"/>      //activate event handler<br class="title-page-name"/>});<br class="title-page-name"/><br class="title-page-name"/>self.addEventListener('fetch', (event) =&gt; {<br class="title-page-name"/>      //fetch event handler<br class="title-page-name"/>});</pre>
<p class="calibre2">As these chapters progress, we will fill in code to use each of these handlers. These updates will demonstrate the service worker life cycle, common caching techniques, and other important service worker concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The service worker life cycle</h1>
                
            
            <article>
                
<p class="calibre2">Service workers obey a known life cycle that allows a new service worker to get itself ready without disrupting the current one. The life cycle is designed for the best user experience.</p>
<p class="calibre2">When a service worker is registered, it does not immediately seize control of the client. There are rules designed to minimize errors due to differences in code versions.</p>
<p class="calibre2">If a new service worker just took control of a client’s context when it is expecting a previous version’s logic, there could be issues. Even though the service worker operates on a separate thread, the UI code could have dependencies on the service worker logic or cached assets. If the new version breaks, the front-end your user experience could go sideways.</p>
<p class="calibre2">The life cycle is designed to ensure that an in-scope page or task is controlled by the same service worker (or no service worker) throughout its session:</p>
<p class="cdpaligncenter1"><img class="aligncenter2" src="../images/00055.jpeg"/></p>
<p class="calibre2">The life cycle consists of the registration, installation, and activation steps. The installation and activation events can have handlers bound that perform specific tasks.</p>
<p class="calibre2">The life cycle also covers service worker updates and unregistration. These last two tasks may not be used as often, but developers should still be familiar with how they work.</p>
<p class="calibre2">Each stage can be used for different process phases to manage the service worker, cached assets, and possibly state data. The following chapter goes into details about the life cycle and how each phase can be used to make your application more performant and easier to manage.</p>
<p class="calibre2">You will learn how to register, update, and remove a service worker. You will also learn the service worker’s scope and the definition of a service worker client. The chapter will also cover the install and activate events so that you can add code to manage the service worker’s cache and active state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Caching</h1>
                
            
            <article>
                
<p class="calibre2">One of the most important progressive web application features is the ability to work offline and load instantly. Service worker caching enables this super power. In the past, websites could function offline and even gain some performance benefits via <kbd class="calibre12">appCache</kbd>.</p>
<p class="calibre2">Service worker caching supersedes <kbd class="calibre12">appCache</kbd> and provides a better programmatic interface. <kbd class="calibre12">AppCache</kbd> is notorious for being difficult to manage and maintain.</p>
<p class="calibre2">When your page references an <kbd class="calibre12">appCache</kbd> manifest file and has a registered service worker, the service worker manages cache and the <kbd class="calibre12">appCache</kbd> is bypassed. This makes service worker caching a progressive enhancement from <kbd class="calibre12">appCache</kbd> and makes it safe to use both.</p>
<p class="calibre2">By enabling caching, service workers make the network a progressive enhancement. Because the service worker cache API is very low level, it requires the developer to apply custom logic to manage how network resources are cached and retrieved.</p>
<p class="calibre2">This leaves lots of room for creativity to apply different caching strategies in your application. <a href="" target="_blank" class="calibre9">Chapter 6</a>,<em class="calibre13"> Master the Cache API- Manage Web Assets in a Podcast Application,</em> dives into the core service worker caching concepts you need to master.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using push notifications</h1>
                
            
            <article>
                
<p class="calibre2">Businesses have been using push to engage customers, even if their app is not open, for about a decade now. And why not? Research shows some impressive numbers related to brand engagement and revenue directly correlated with the tiny interruptions.</p>
<p class="calibre2">For example, Google has shared the following:</p>
<ul class="calibre10">
<li class="calibre11">72% increase in time spent for users visiting via a push notification</li>
<li class="calibre11">26% increase in average spend per visit by members arriving via a push notification</li>
<li class="calibre11">+50% repeat visits within 3 months</li>
</ul>
<p class="calibre2">These values all point to the reason why brand and product managers love push notifications. Unfortunately, up to recent times, the web has been left out of this party. Many businesses have opted to go through the hassle of a native app solely to send push notifications.</p>
<p class="calibre2">The Push API gives web applications the ability to receive messages pushed to them from a server, whether or not the web app is in the foreground, or even currently loaded, on a user agent.</p>
<p class="calibre2">Implementing push in your application requires a server-based service, typically a cloud based service such as Google Cloud Messenger or AWS Pinpoint. There are numerous providers available.</p>
<p class="calibre2">Don't worry about your push provider. Web push notifications are based on an IETF standard, Generic Event Delivery Using HTTP Push (<a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12" class="calibre9">https://tools.ietf.org/html/draft-ietf-webpush-protocol-12</a>). Make sure your provider is compliant and you should have no problems.</p>
<p class="calibre2">At the time of writing this book, Chrome, FireFox, Samsung Internet, and Opera currently ship push notification support. Microsoft Edge is in the process of shipping support. Apple has not released a potential timeline for Safari support.</p>
<p class="calibre2">It is important to note that each browser or user agent acts independently from other browsers. If a customer loads your web page from more than one browser, each will register a service worker. If each one also creates a push notification subscription, the user could receive multiple notifications.</p>
<p class="calibre2">This makes managing subscription logic in your application’s service logic important. This is outside the scope of this book. As part of production logic, it is a good idea to query your server before attempting to register a user for push notifications. There are several options to handle this potential situation and you will need to determine what is best for your application.</p>
<p class="calibre2">If your brand also has a native app that offers push notifications, they will also be a separate subscription. This means you should track if the customer already receives notifications on the device as best as you can to avoid duplicating messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing push notifications</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you will learn some fundamentals of implementing push notifications:</p>
<ul class="calibre10">
<li class="calibre11">How to subscribe and unsubscribe a user for push messaging</li>
<li class="calibre11">How to handle incoming push messages</li>
<li class="calibre11">How to display a notification</li>
<li class="calibre11">How to respond to notification clicks</li>
</ul>
<p class="calibre2">The code is part of the Podstr application. I won't cover how to set up a push provider because they vary too much and are prone to changes to their administration interfaces. This creates a fluid environment that would only serve to create confusion with readers and potential providers. Plus, singling out a single provider could create an unwanted bias. Most providers have current documentation and JavaScript SDKs to help you create the server-side environment.</p>
<p class="calibre2">If you would like to stand up your own push service, Matt Gaunt, of the Google Chrome team, has published an example server you can clone (<a href="https://github.com/web-push-libs/web-push" class="calibre9">https://github.com/web-push-libs/web-push</a>). This might serve as a decent test service, but I would not consider it a production quality service.</p>
<p class="calibre2">For our purposes, the Chrome developer tools provide enough to trigger the client-side logic and experience. You can find a link to the right of a registered service workers detail to emulate a push event:</p>
<div class="cdpaligncenter"><img src="../images/00056.jpeg" class="calibre70"/></div>
<p class="calibre2">This link triggers an emulated push message with a simple payload: <span class="calibre5">Test push message from DevTools</span>. The Podstr application will use this event to trigger a message we can display to the user about new podcast episodes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up push notifications</h1>
                
            
            <article>
                
<p class="calibre2">To enable push notifications, there are several steps you need to follow. The first step is detecting if the browser supports push or not. If so, then you can proceed:</p>
<pre class="calibre17">navigator.serviceWorker.register('/sw.js').then(function (registration) {   <br class="title-page-name"/>    if ("PushManager" in window) {<br class="title-page-name"/>      //push is supported<br class="title-page-name"/>    }<br class="title-page-name"/>});</pre>
<p class="calibre2">Since push is something you would configure after you register the service worker, you can check for support once the service worker is registered. Just like checking for service worker support, you can check if the window object contains a reference to the <kbd class="calibre12">PushManager</kbd>.</p>
<p class="calibre2">The <kbd class="calibre12">PushManager</kbd> has three methods to manage a user's subscription status. The <kbd class="calibre12">getSubscription</kbd> method returns a promise that resolves a <kbd class="calibre12">PushSubscription</kbd> object. If the user is subscribed, the subscription is an object, otherwise it is null.</p>
<p class="calibre2">It is up to you how you surface the state of push notifications in your application. My personal advice is to hide any visible queues if the browser does not support push notifications because it will confuse the consumer.</p>
<p class="calibre2">Most sites will simply prompt for permission to send push notifications. The ability to send notifications is gated behind user approval. The browser displays a yes or no dialog when you try to initiate the push notification subscription process.</p>
<p class="calibre2">It is also a good practice to allow users to opt out of push notifications. This can be done in application settings or on a configuration page. The Podstr application has a settings page that includes options to manage push notifications:</p>
<div class="cdpaligncenter"><img src="../images/00057.jpeg" class="calibre71"/></div>
<p class="calibre2">The code to manage push notification subscriptions is covered later in this section. You can provide an interface for the user either as a passive option, like on the configuration page, or actively via a notification.</p>
<p class="calibre2">As Android evolves, Chrome and possible other Android browsers will automatically convert progressive web apps that are added to the <kbd class="calibre12">homescreen</kbd> to <kbd class="calibre12">WebAPKs</kbd>. These are native applications that enjoy almost equal status with store apps. One feature they should have is the ability to manage push notifications in the app through the platform settings applications, but you should never rely on this as the only way to turn notifications off.</p>
<p class="calibre2">For example, Twitter has adopted progressive web applications and can send notifications. I turned this on, but found it was pushing notifications for a single account (Scott Hanselman) to my phone. While I like Scott, I was expecting a bit more variety.</p>
<p class="calibre2">It took me a while to discover how to manage Twitter notifications. I found out how to block notifications for the site in Chrome faster:</p>
<div class="cdpaligncenter"><img src="../images/00058.jpeg" class="calibre72"/></div>
<p class="calibre2">Twitter has many notification options which require a robust backend to manage. The Podstr application uses either an on or off choice. If this were a production application, I would build out more logic over time, like Twitter has done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing the user's subscription</h1>
                
            
            <article>
                
<p class="calibre2">In the example code, if the subscription object does not exist, the <kbd class="calibre12">subscribeUser</kbd> function is invoked. The service worker registration object is passed as the only parameter:</p>
<pre class="calibre17">registration.pushManager.getSubscription()<br class="title-page-name"/>.then(function (subscription) {<br class="title-page-name"/>            if(subscription === null){<br class="title-page-name"/>                  subscribeUser(registration);<br class="title-page-name"/>            }<br class="title-page-name"/>      });</pre>
<p class="calibre2">The <kbd class="calibre12">pushManager</kbd> subscribe method has a single parameter, an object with two properties, <kbd class="calibre12">userVisibleOnly</kbd> and <kbd class="calibre12">applicationServerKey</kbd>.</p>
<p class="calibre2">The subscribe function returns a promise that resolves after the user has granted permission to send notifications and the browser sends a request to the push service.</p>
<p class="calibre2">As part of the subscribe function work flow, the User Agent is required to prompt the user for permission. If this is denied, the promise rejects with a <kbd class="calibre12">NotAllowedError</kbd>. You should always include a catch handler to the subscribe call.</p>
<p class="calibre2">According to the Push Notification specification (<a href="https://w3c.github.io/push-api/#webapp" class="calibre9">https://w3c.github.io/push-api/#webapp</a>):</p>
<div class="packt_quote2">User agents MUST NOT provide Push API access to web apps without the express permission of the user. User agents MUST acquire consent for permission through a user interface for each call to the <kbd class="calibre31">subscribe()</kbd> method, unless a previous permission grant has been persisted, or a prearranged trust relationship applies. Permissions that are preserved beyond the current browsing session MUST be revocable.</div>
<p class="calibre2">The <kbd class="calibre12">userVisibleOnly</kbd> property is a Boolean that indicates if the push notifications will always be visible to the user. Currently, you must set this property to true before browsers will let you subscribe a user:</p>
<div class="packt_quote2">"If developers request the ability to use silent push (the ability to receive pushes without triggering a user-visible UI change) we currently reject the request, but in the future we plan to introduce a permission to enable this use case"</div>
<div class="packt_quote2">– https://goo.gl/ygv404</div>
<div class="cdpaligncenter"><img src="../images/00059.jpeg" class="calibre73"/></div>
<p class="calibre2">So, for now, you will need to display a message to the end user, even if there is no user feedback needed. For example, a caching strategy to update a site’s cached assets can be triggered by a push notification. In those scenarios, you would display a notification to alert the user to the update.</p>
<p class="calibre2">The <kbd class="calibre12">applicationServerKey</kbd> property is also known as a WEBPUS-VAPID (voluntary application server identification for web push (<a href="https://tools.ietf.org/html/draft-ietf-webpush-vapid-04" class="calibre9">https://tools.ietf.org/html/draft-ietf-webpush-vapid-04</a>)). This value comes from your push service provider. It will be a rather long string of random characters and numbers.</p>
<p class="calibre2">The value should be base 64 URL safe encoded. The <kbd class="calibre12">urlB64ToUnit8Array</kbd> function converts it to a UInt8Array, which is expected by the subscribe function. The <kbd class="calibre12">urlB64ToUnit8Array</kbd> is a utility function you can find in the Podstr source code.</p>
<p class="calibre2">The User Agent should only accept notifications containing the subscribed <kbd class="calibre12">applicationServerKey</kbd>. Per the specification, this is a recommendation and browsers honor that advice:</p>
<pre class="calibre17">function subscribeUser(registration) {<br class="title-page-name"/>    const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);<br class="title-page-name"/>    registration.pushManager.subscribe({<br class="title-page-name"/>      userVisibleOnly: true,<br class="title-page-name"/>      applicationServerKey: applicationServerKey<br class="title-page-name"/>        })<br class="title-page-name"/>        .then(function (subscription) {<br class="title-page-name"/>            updateSubscriptionOnServer(subscription);<br class="title-page-name"/>            console.log('User is subscribed.');<br class="title-page-name"/>        })<br class="title-page-name"/>        .catch(function (err) {<br class="title-page-name"/>      console.log('Failed to subscribe the user: ', err);<br class="title-page-name"/>        });<br class="title-page-name"/>}</pre>
<p class="calibre2">Once a subscription has been made, it cannot be altered. You must unsubscribe from the initial subscription and create a new subscription with the new options. For example, if you should change your push service, the client will need a new <kbd class="calibre12">applicationServerKey</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00060.jpeg" class="calibre74"/></div>
<p class="calibre2">Like all things in service workers, the subscribe function returns a promise. If there is not an exception, it resolves a <kbd class="calibre12">PushSubscription</kbd> object. This object contains various values about the subscription that could be useful to build a more robust user experience or management logic.</p>
<p class="calibre2"><strong class="calibre4">Properties</strong> (all read only):</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">endpoint</kbd>: The subscription endpoint</li>
<li class="calibre11"><kbd class="calibre12">expirationTime</kbd>: Null unless the subscription has an expiration time</li>
<li class="calibre11"><kbd class="calibre12">options</kbd>: An echo of the options used to create the subscription</li>
<li class="calibre11"><kbd class="calibre12">subscriptionId</kbd>: The subscription ID</li>
</ul>
<p class="calibre2"><strong class="calibre4">Methods:</strong></p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">getKey</kbd>: An <kbd class="calibre12">ArrayBuffer</kbd> representing the client’s public key</li>
<li class="calibre11"><kbd class="calibre12">toJSON</kbd>: A JSON representation of the subscription properties</li>
<li class="calibre11"><kbd class="calibre12">unscubscribe</kbd>: Initiates a subscriber unsubscription process</li>
</ul>
<p class="calibre2">The <kbd class="calibre12">updateSubscriptionOnServer</kbd> function, called upon a successful subscription, would normally be used to update the server. However, for our purposes, it is used to echo out the subscription object properties:</p>
<pre class="calibre17">{<br class="title-page-name"/>   "endpoint": "https://fcm.googleapis.com/fcm/send/cRWeyfFxsE0:APA91bE8jAnZtPTHSG5pV9hNWtTdS_ZFZT7FTDEpDEYwf8f_FvwuiLc6YDtxNigxKzyHhj9yzbhlJ4zm3M3wt0w1JPYQ41yhF38yeXKhYVp_TFauMr_RnINOKiobCTCYIgj_X0PWlGQF",<br class="title-page-name"/>   "expirationTime": null,<br class="title-page-name"/>   "keys": {<br class="title-page-name"/>     "p256dh": "BO0FEUNPej_U984Q-dVAvtv1lyIdSvOn01AVl5ALu8F-GPA7lTtZ8QfyiQ7Z12BFjPQLvpvypMrL4I6QqHy2wNg=",<br class="title-page-name"/>     "auth": "lDiFiN9EFPcXm7LVzOYUlg=="<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling push notifications</h1>
                
            
            <article>
                
<p class="calibre2">After the consumer has confirmed a push notification subscription, you can send messages to the user agent. When a message is sent to the device, it determines what service worker to apply the message and trigger a push event.</p>
<p class="calibre2">The service worker needs a push event handler that receives an event parameter. The event object contains the message data.</p>
<p class="calibre2">The sever can send any text in the message. It is up to the service worker to parse the message and trigger the appropriate work flow.</p>
<p class="calibre2">PodStr only manages a new podcast's episode notifications. But a retailer might want to promote sales or remind a customer to complete an order. There is really no limit to what prompt you might send to your customer.</p>
<p class="calibre2">The latter message might not be a simple string -- it could be a stringified JSON object. If you need to process JSON objects, you will need to test it to see if it is a valid object before falling back to a string. The more message types you might have, the more complex event handler logic you will need.</p>
<p class="calibre2">For demonstration purposes, the Podstr push event handler will compose an <kbd class="calibre12">options</kbd> object that contains details about the new episode. This includes the episode title and podcast logo:</p>
<pre class="calibre17">{<br class="title-page-name"/>      "title": "CodeWinds - Leading edge web developer news and training | javascript / React.js / Node.js / HTML5 / web development - Jeff Barczewski",<br class="title-page-name"/>      “description”: “episode description here”,<br class="title-page-name"/>"image": "http://codewinds.com/assets/codewinds/codewinds-podcast-1400.png"<br class="title-page-name"/>}</pre>
<p class="calibre2">Push messages are handled by extensions to the core <kbd class="calibre12">serviceWorkerRegistration</kbd> object, which are obtained during the registration process or the <kbd class="calibre12">getRegistration</kbd> method. The method we are interested in is the <kbd class="calibre12">showNotification</kbd> method.</p>
<p class="calibre2">This method has two parameters, a title and an options object. The title should be a string that describes the notification. The Podstr application will use the episode’s title.</p>
<p class="calibre2">The options object allows you to configure the notification and can be a combination of several properties.</p>
<p class="calibre2"><strong class="calibre4">Notification Object:</strong></p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">actions</kbd>: An array of objects that will display action buttons for the user to choose from.</li>
<li class="calibre11"><kbd class="calibre12">badge</kbd>: The URL of an image to represent the notification when there is not enough space to display the notification itself.</li>
<li class="calibre11"><kbd class="calibre12">body</kbd>: A string to display in the message.</li>
<li class="calibre11"><kbd class="calibre12">dir</kbd>: The direction of the notification; it can be auto, ltr, or rtl.</li>
<li class="calibre11"><kbd class="calibre12">icon</kbd>: The URL of the notification icon.</li>
<li class="calibre11"><kbd class="calibre12">image</kbd>: A string containing the URL of an image to display in the notification.</li>
<li class="calibre11"><kbd class="calibre12">lang</kbd>: Must be a valid BCP 47 language tag which is used for the notification language.</li>
<li class="calibre11"><kbd class="calibre12">renotify</kbd>: If a notification uses a tag for a repeat display, this can be set to true to suppress vibrations and audible notifications.</li>
<li class="calibre11"><kbd class="calibre12">requireInteraction</kbd>: On larger screens, if this value is true, the notification stays visible until the user dismisses it. Otherwise, Chrome and I assume other browsers will minimize the notification after 20 seconds.</li>
<li class="calibre11"><kbd class="calibre12">tag</kbd>: An ID that allows you to find and replace the notification if needed. This can be done by calling the <kbd class="calibre12">getNotifications</kbd> method.</li>
<li class="calibre11"><kbd class="calibre12">vibrate</kbd>: An array of numbers specifying a vibration sequence. For example, <kbd class="calibre12">[300, 100, 400]</kbd> would vibrate 300 ms, pause 100 ms, then vibrate 400 ms.</li>
<li class="calibre11"><kbd class="calibre12">data</kbd>: This is an open field that you can optionally populate anyway you see fit. It can be any data type, like a string, number, date, or object.</li>
</ul>
<p class="calibre2">The <kbd class="calibre12">action</kbd> property gives you the ability to add one or more action buttons to the notification. You can handle this selection in the <kbd class="calibre12">notificationClick</kbd> event handler.</p>
<p class="calibre2">An action object has the following properties:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">action</kbd>: A <kbd class="calibre12">DOMString</kbd> identifying a user action to be displayed on the notification</li>
<li class="calibre11"><kbd class="calibre12">title</kbd>: A <kbd class="calibre12">DOMString</kbd> containing action text to be shown to the user</li>
<li class="calibre11"><kbd class="calibre12">icon</kbd>: [optional] A String containing the URL of an icon to display with the action:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00061.jpeg" class="calibre75"/></div>
<p class="calibre2">The Podstr service worker looks for a simple JSON object in the notification event's data field. It parses the object and builds a notification object.</p>
<p class="calibre2">Be careful trying to parse the text because it may not be a JSON object. The best way to handle this situation is to wrap the parse method and associated logic in a try catch statement. Not the best scenario, but the only way, for now, to handle valid and invalid JSON object parsing:</p>
<pre class="calibre17">    try {<br class="title-page-name"/>        var episode = JSON.parse(event.data.text());<br class="title-page-name"/><br class="title-page-name"/>        const title = episode.title;<br class="title-page-name"/>        const options = {<br class="title-page-name"/>            body: episode.description,<br class="title-page-name"/>            icon: 'img/pwa-podstr-logo-70x70.png',<br class="title-page-name"/>            badge: 'img/pwa-podstr-logo-70x70.png',<br class="title-page-name"/>            image: episode.image,<br class="title-page-name"/>            vibrate: [200, 100, 200, 100, 200, 100, 200],<br class="title-page-name"/>            actions: [{<br class="title-page-name"/>                action: "listen",<br class="title-page-name"/>                title: "Listen Now",<br class="title-page-name"/>                icon: 'img/listen-now.png'<br class="title-page-name"/>            },<br class="title-page-name"/>            {<br class="title-page-name"/>                action: "later",<br class="title-page-name"/>                title: "Listen Later",<br class="title-page-name"/>                icon: 'img/listen-later.png'<br class="title-page-name"/>            }]<br class="title-page-name"/>        };<br class="title-page-name"/><br class="title-page-name"/>        event.waitUntil(self.registration.showNotification(title, <br class="title-page-name"/>        options));<br class="title-page-name"/><br class="title-page-name"/>    }<br class="title-page-name"/>    catch (e) {<br class="title-page-name"/>        console.log('invalid json');<br class="title-page-name"/><br class="title-page-name"/>        event.waitUntil(self.registration.showNotification("spartan <br class="title-page-name"/>        obstacles", {<br class="title-page-name"/>            body: 'Generic Notification Handler',<br class="title-page-name"/>            icon: 'img/pwa-podstr-logo-70x70.png',<br class="title-page-name"/>            badge: 'img/pwa-podstr-logo-70x70.png',<br class="title-page-name"/>            vibrate: [200, 100, 200, 100, 200, 100, 200]<br class="title-page-name"/>        }));<br class="title-page-name"/>    }</pre>
<p class="calibre2">If the notification contains plain text, a generic notification is displayed.</p>
<p class="calibre2">The <kbd class="calibre12">showNotification</kbd> method causes the message on the user's device. The function returns a promise that resolves a <kbd class="calibre12">NotificationEvent</kbd>.</p>
<p class="calibre2">Wrapping the <kbd class="calibre12">showNotification</kbd> method in a <kbd class="calibre12">waitUntil</kbd> function keeps the event handler open until the promise resolves so that the service worker does not terminate.</p>
<p class="calibre2">A <kbd class="calibre12">NotificationEvent</kbd> object has two properties: notification and action. The notification is a copy of the notification object used to create the notification. If there are one or more action buttons in the notification, the action value is the action object's action property defined in the notification object.</p>
<p class="calibre2">In our example, this value would be either listen or later. You can use this value to trigger a different response flow. If the user selects listen, you can go directly to the episode page and start playing the episode. If they say later, you know to download the episode's mp3 file and persist it in the cache:</p>
<pre class="calibre17">self.addEventListener('notificationclick', function (event) {<br class="title-page-name"/>    if(event.action === "listen"){<br class="title-page-name"/>        listenToEpisode(event.notification);<br class="title-page-name"/>    }else if(event.action === "later"){<br class="title-page-name"/>        saveEpisodeForLater(event.notification);<br class="title-page-name"/>    }<br class="title-page-name"/>    event.notification.close();<br class="title-page-name"/>});</pre>
<p class="calibre2">The <kbd class="calibre12">notification.close</kbd> method programmatically closes a notification.</p>
<p class="calibre2">That is all it takes to display a push notification. Remember, all the code to process a push notification is handled in the service worker. For now, browsers require that you display a visible message when you process a notification. This does not mean the notification requires user interaction.</p>
<p class="calibre2">A push notification could trigger logic to be executed in the service worker like update the cache. If you require a response, you can configure action buttons and process the end user’s choice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unsubscribing from push notifications</h1>
                
            
            <article>
                
<p class="calibre2">The only push notification task we need to implement is a way to unsubscribe the subscription. This can be done via the <kbd class="calibre12">pushManager</kbd>.</p>
<p class="calibre2">Before I dive into the details to unsubscribe a user from push notifications, I want to look at how we can provide a UI for the user to manage their subscription status.</p>
<p class="calibre2">My preference is to include a management interface in the site's settings, configuration page, or section. For example, the Twitter PWA has a detailed notification configuration experience. It has a high-level page with links to four child pages, each offering more granular control over different notification aspects.</p>
<p class="calibre2">They are grouped as either filters or preferences. In the filters group, there is also a checkbox to enable a quality filter, which is a very high-level setting.</p>
<p class="calibre2">Push notifications are managed in their own group of pages. They have code to detect if push notifications are enabled for the site and, if so, give the user the option to enable push. Once they enable push, they can then tailor their notifications by type of activity.</p>
<p class="calibre2">The default choices can cause a crazy amount of notifications to be sent. So, if you are like me, take the time to trim the volume of notifications.</p>
<p class="calibre2">The Twitter Lite application can serve as a reference for a detailed push management interface. Fortunately, the Podstr application keeps its notifications simple. For our purposes, we will provide an interface to either turn notifications on or off:</p>
<div class="cdpaligncenter"><img src="../images/00062.jpeg" class="calibre76"/></div>
<p class="calibre2">Notifications can be toggled on or off, which triggers client-side logic to manage a subscription. The application must manage both <kbd class="calibre12">subscribeUser</kbd> and <kbd class="calibre12">unsubscribeUser</kbd> based on the user toggling a choice.</p>
<p class="calibre2">This is why there are separate subscribe and unsubscribe methods. Before I dive into the code to handle the toggling UI, let’s review the <kbd class="calibre12">unsubscribeUser</kbd> method.</p>
<p class="calibre2">Just like the <kbd class="calibre12">subscribeUser</kbd> method, the <kbd class="calibre12">unsubscribeUser</kbd> method uses the service worker's <kbd class="calibre12">pushManager.getSubscription</kbd> method to obtain reference to the current subscription, if any.</p>
<p class="calibre2">If there is a current subscription, the subscription object's unsubscribe method is called. Unsubscribe returns a promise that resolves a Boolean indicating if the subscription was unsubscribed or not:</p>
<pre class="calibre17">function unsubscribeUser(registration) {<br class="title-page-name"/>    return registration.pushManager.getSubscription()<br class="title-page-name"/>        .then(function (subscription) {<br class="title-page-name"/>            if (subscription) {<br class="title-page-name"/>                return subscription.unsubscribe()<br class="title-page-name"/>                      .then(function(success){<br class="title-page-name"/>                        console.log(“user is unsubscribed ”, success);<br class="title-page-name"/>                      });<br class="title-page-name"/>            }<br class="title-page-name"/>        })<br class="title-page-name"/>        .catch(function (error) {<br class="title-page-name"/>            console.log('Error unsubscribing', error);<br class="title-page-name"/>        });<br class="title-page-name"/>}</pre>
<p class="calibre2">If the service worker is unregistered, then any associated push notification subscriptions are deactivated.</p>
<p class="calibre2">When a notification subscription changes outside the control of the application, the <kbd class="calibre12">pushsubscriptionchange</kbd> event fires in the service worker. You can add an event handler to this event to handle the change as needed.</p>
<p class="calibre2">A subscription state can change by either the consumer or automatically by the service. The service might remove a subscription if it has become stale. In this case, you could create an automated resubscription process to renew the subscription.</p>
<p class="calibre2">If you are resubscribing a notification subscription, it must be done with the same options as the page used in the initial, frontend JavaScript. You can access the previous options by accessing the <kbd class="calibre12">oldSubscription</kbd> object in the event object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling a push subscription change</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">pushsubscriptionchange</kbd> event is particularly handy if the subscription is automatically removed due to the subscription becoming stale. This can happen because many push services limit the lifetime of a subscription for security and due to inactivity.</p>
<p class="calibre2">Just like authentication tokens, push subscriptions can be seamlessly renewed without involving the user. This is what you can do in the service worker for a push subscription.</p>
<p class="calibre2">The <kbd class="calibre12">pushsubscriptionchange</kbd> event includes an <kbd class="calibre12">oldSubscription</kbd> object that contains the details of the original subscription. They can be used to create a new subscription:</p>
<pre class="calibre17">    self.addEventListener('pushsubscriptionchange', e =&gt; { <br class="title-page-name"/>          e.waitUntil(registration.pushManager.subscribe(e.oldSubscription.options) <br class="title-page-name"/>        .then(subscription =&gt; { <br class="title-page-name"/>          // TODO: Send new subscription to application server <br class="title-page-name"/>        })); <br class="title-page-name"/>    });</pre>
<p class="calibre2">This saves you the hassle of persisting the values between sessions. Now, you can easily resubscribe the user in the service worker without disturbing the end user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Background sync</h1>
                
            
            <article>
                
<p class="calibre2">The service worker cache enables a site to render offline. But that only helps when you have the page and assets available in the cache. What can you do if you need to post data or get uncached pages while offline?</p>
<p class="calibre2">This is where background sync can help. It enables you to register a request that will be fulfilled when the device is back online.</p>
<p class="calibre2">Background sync executes asynchronous tasks in the background, when a device is online. It works by building a queue of requests to fulfill as soon as the device is capable of connecting to the internet.</p>
<p class="calibre2">The way background sync works is you place a network request with a tag, registered with the <kbd class="calibre12">SyncManager</kbd>. The platform is responsible for checking if the device is online or offline.</p>
<p class="calibre2">If it cannot make the request, the sync places the request in a queue for that tag. The background sync periodically checks the ability to make a request, but not so much that it would drain your battery or consume excessive CPU cycles.</p>
<p class="calibre2">The background sync model possibly requires a new way to organize your application's code. To properly use sync programming, you should separate all requests into isolated methods from any event triggers.</p>
<p class="calibre2">For example, instead of making a fetch call directly in a button click event handler, you would call a method that fetches the asset from the event handler. This allows you to better isolate the call within a background sync registration.</p>
<p class="calibre2">The Podstr application allows the customer to select podcast episodes to listen to offline. This requires the user to select the episode, and the application will download the audio file and store it for offline consumption.</p>
<p class="calibre2">Of course, the application must be online to download the episode. You may also want to limit downloading a large file like an audio file for when the device is on WiFi and not cellular.</p>
<p class="calibre2">First, let's see how to register a request using background sync:</p>
<pre class="calibre17">if ("sync" in reg) {<br class="title-page-name"/>      reg.sync.register('get-episode');<br class="title-page-name"/>}</pre>
<p class="calibre2">Because background sync is very new, it is not supported by many browsers yet. That should be changing in the near future. For example, Edge has support behind the service worker flag.</p>
<p class="calibre2">To be safe, you should employ feature detection before using it. This can be done by checking if the service worker registration object supports <kbd class="calibre12">"sync"</kbd>. If so, then you can register the request; otherwise, you can make the request as a normal request.</p>
<p class="calibre2">Sync requests are registered in your UI code, not the service worker. The service worker has a sync event handler, which is responsible for handling the network request.</p>
<p class="calibre2">Background sync works like a cloud-based messaging platform. Instead of placing a request directly, you post a message to a queue or buffer that can be accessed by both the placing and the responding parties.</p>
<p class="calibre2">In our example, Podstr stores requests for offline episodes in IDB. This is chosen because it is an asynchronous data store, available to both the client code and service worker. I won't go into the details of how this works in this chapter, as I am saving that for <a href="" target="_blank" class="calibre9">Chapter 6</a>, <em class="calibre13">Master the Cache API- Manage Web Assets in a Podcast Application</em>, when we dive deeper into caching.</p>
<p class="calibre2">To make background sync work, you first need to place a message in the IDB queue. When the service worker receives a sync event to process episodes to listen later (<kbd class="calibre12">get-episode</kbd>), it checks the IDB queue for episodes and fetches each file.</p>
<p class="calibre2">You register the request by calling the sync's <kbd class="calibre12">register</kbd> method. This method accepts a simple tag name. This is passed along to the service worker's sync event handler.</p>
<p class="calibre2">The service worker registers a single sync event handler. Each time a background sync event triggers, the handler receives a <kbd class="calibre12">SyncEvent</kbd> object. It contains a <kbd class="calibre12">tag</kbd> property that identifies the event by the <kbd class="calibre12">tag</kbd> value which is supplied when you registered the synchronization:</p>
<pre class="calibre17">self.addEventListener('sync', function (event) {<br class="title-page-name"/>    if (event.tag == 'get-episode') {<br class="title-page-name"/>        event.waitUntil(getEpisode());<br class="title-page-name"/>    }<br class="title-page-name"/>});</pre>
<p class="calibre2">In this example, you can see that it is checking the value of the tag before calling the <kbd class="calibre12">getEpisode</kbd> function. The <kbd class="calibre12">getEpisode</kbd> function triggers the tasks required to retrieve the episodes in the listen later queue and downloads them for offline persistence.</p>
<p class="calibre2">You should notice the method is wrapped in a <kbd class="calibre12">waitUntil</kbd>. This is to keep the event handler live while the background task is being performed. Downloading a podcast episode could take a few minutes, and you do not want the service worker process terminating.</p>
<p class="calibre2">In this example, the podcast episodes will download in response to the background sync event being fired. This means the request(s) may not immediately initiate, but they will get downloaded.</p>
<p class="calibre2">The bonus is that these downloads will happen even if a Podstr page is not loaded in the browser. Plus, the download happens in a background thread, freeing up the UI from this cumbersome task. Now, the consumer is free to navigate around the application without waiting on the audio files to download.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Service workers are exciting and offer a great new context for developers to build rich, engaging user experiences while employing background activities. This chapter introduced you to different service worker concepts and the Podstr application.</p>
<p class="calibre2">You have now seen how to leverage both push notifications and background sync to build engagements, even when the customer is not viewing your application.</p>
<p class="calibre2">In the following chapters, you will see how the service worker's life cycle and caching work. By the end of this section, you will have a modest podcast application, demonstrating how to use service worker caching, push notifications, and background synchronization to create a user experience that rivals popular native applications using web technology.</p>


            </article>

            
        </section>
    </body></html>