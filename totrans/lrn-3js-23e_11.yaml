- en: Chapter 11. Custom Shaders and Render Postprocessing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 自定义着色器和渲染后处理
- en: 'We''re getting to the end of the book, and in this chapter, we''ll look at
    the one main feature of Three.js we haven''t touched upon: render postprocessing.
    Besides that, in this chapter, we''ll also introduce you to how you can create
    custom shaders. The main points we''ll discuss in this chapter are the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这本书的阅读，在本章中，我们将探讨Three.js的一个主要特性，这是我们之前未曾涉及过的：渲染后处理。除此之外，在本章中，我们还将向您介绍如何创建自定义着色器。本章我们将讨论的主要内容包括以下几项：
- en: Setting up Three.js for postprocessing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Three.js设置后处理
- en: Discussing the basic postprocessing passes provided by Three.js, such as `THREE.BloomPass`
    and `THREE.FilmPass`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Three.js提供的基礎后处理流程，例如`THREE.BloomPass`和`THREE.FilmPass`
- en: Applying effects to part of the scene using masks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮罩对场景的一部分应用效果
- en: Using `THREE.TexturePass` to store rendering results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.TexturePass`存储渲染结果
- en: Using `THREE.ShaderPass` to add even more basic postprocessing effects, such
    as sepia filters, mirror effects, and color adjustments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.ShaderPass`添加更多基本的后处理效果，例如棕褐色滤镜、镜像效果和颜色调整
- en: Using `THREE.ShaderPass` for various blurring effects and more advanced filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.ShaderPass`实现各种模糊效果和更高级的滤镜
- en: Creating a custom postprocessing effect by writing a simple shader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写简单的着色器创建自定义后处理效果
- en: In the *Introducing requestAnimationFrame* section of [Chapter 1](ch01.html
    "Chapter 1. Creating Your First 3D Scene with Three.js"), *Creating Your First
    3D Scene with Three.js*, we set up a rendering loop that we've used throughout
    the book to render and animate our scene. For postprocessing, we need to make
    a couple of changes to this setup to allow Three.js to postprocess the final rendering.
    In the first section, we'll look at how to do this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Three.js创建您的第一个3D场景")的“介绍requestAnimationFrame”部分中，即“使用Three.js创建您的第一个3D场景”，我们设置了一个渲染循环，这是我们全书用来渲染和动画化场景的方法。对于后处理，我们需要对这个设置进行一些修改，以便允许Three.js对最终渲染进行后处理。在第一部分，我们将探讨如何实现这一点。
- en: Setting up Three.js for postprocessing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Three.js设置后处理
- en: 'To set up Three.js for postprocessing, we need to make a couple of changes
    in our current setup. We need to take the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Three.js设置后处理，我们需要在我们的当前设置中进行一些修改。我们需要采取以下步骤：
- en: Create `THREE.EffectComposer`, which we can use to add postprocessing passes.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`THREE.EffectComposer`，我们可以用它来添加后处理流程。
- en: Configure `THREE.EffectComposer` so that it renders our scene and applies any
    additional postprocessing steps.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`THREE.EffectComposer`，使其渲染我们的场景并应用任何额外的后处理步骤。
- en: In the render loop, use `THREE.EffectComposer` to render the scene, apply the
    passes, and show the output.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环中使用`THREE.EffectComposer`渲染场景，应用流程，并显示输出。
- en: 'As always, we have an example that you can use to experiment with and adopt
    for your own uses. The first example for this chapter can be accessed from `01-basic-effect-composer.html`.
    You can use the menu in the top-right corner to modify the properties of the postprocessing
    step used in this example. In this example, we render a simple globe and add an
    old-television-like effect to it. This television effect is added after the scene
    is rendered using `THREE.EffectComposer`. The following screenshot shows this
    example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们有一个示例，您可以使用它进行实验，并将其用于您自己的用途。本章的第一个示例可以从`01-basic-effect-composer.html`访问。您可以使用右上角的菜单修改此示例中使用的后处理步骤的属性。在这个示例中，我们渲染了一个简单的地球仪，并添加了一个类似老式电视的效果。这个电视效果是在使用`THREE.EffectComposer`渲染场景之后添加的。以下截图显示了此示例：
- en: '![Setting up Three.js for postprocessing](img/2215OS_11_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![设置Three.js进行后处理](img/2215OS_11_01.jpg)'
- en: Creating THREE.EffectComposer
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建THREE.EffectComposer
- en: Let's first look at the additional JavaScript files you need to include. These
    files can be found in the Three.js distribution in the `examples/js/postprocessing`
    and `examples/js/shaders` directories.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看您需要包含的附加JavaScript文件。这些文件可以在Three.js发行版中的`examples/js/postprocessing`和`examples/js/shaders`目录中找到。
- en: 'The minimal setup you need to get `THREE.EffectComposer` working is the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`THREE.EffectComposer`正常工作，您需要的最小设置如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `EffectComposer.js` file provides the `THREE.EffectComposer` object that
    allows us to add postprocessing steps. `MaskPass.js`, `ShaderPass.js`, and `CopyShader.js`
    are used internally by `THREE.EffectComposer`, and `RenderPass.js` allows us to
    add a rendering pass to `THREE.EffectComposer`. Without that pass, our scene won't
    be rendered at all.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`EffectComposer.js`文件提供了允许我们添加后处理步骤的`THREE.EffectComposer`对象。`MaskPass.js`、`ShaderPass.js`和`CopyShader.js`由`THREE.EffectComposer`内部使用，而`RenderPass.js`允许我们将渲染pass添加到`THREE.EffectComposer`中。没有这个pass，我们的场景根本不会渲染。'
- en: 'For this example, we add two additional JavaScript files to add a film-like
    effect to our scene:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们添加了两个额外的JavaScript文件，以给我们的场景添加电影般的特效：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first thing we need to do is create `THREE.EffectComposer`. You can do
    this by passing in `THREE.WebGLRenderer` to its constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建`THREE.EffectComposer`。您可以通过将其构造函数传递`THREE.WebGLRenderer`来实现这一点：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we add various *passes* to this composer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向这个合成器添加各种**passes**。
- en: Configuring THREE.EffectComposer for postprocessing
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置THREE.EffectComposer进行后处理
- en: 'Each pass is executed in the sequence it is added to `THREE.EffectComposer`.
    The first pass we add is `THREE.RenderPass`. The following pass renders our scene
    but doesn''t output it to the screen yet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个pass都是按照它添加到`THREE.EffectComposer`中的顺序执行的。我们首先添加的pass是`THREE.RenderPass`。接下来的pass渲染我们的场景，但尚未输出到屏幕：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create `THREE.RenderPass`, we pass in the scene we want to render and the
    camera that we want to use. With the `addPass` function, we add `THREE.RenderPass`
    to `THREE.EffectComposer`. The next step is to add another pass that will output
    its result to the screen. Not all the available passes allow this—more on that
    later—but `THREE.FilmPass`, which is used in this example, allows us to output
    the result of its pass to the screen. To add `THREE.FilmPass`, we first need to
    create it and add it to the composer. The resulting code looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`THREE.RenderPass`，我们传递要渲染的场景和我们想要使用的相机。使用`addPass`函数，我们将`THREE.RenderPass`添加到`THREE.EffectComposer`中。下一步是添加另一个将输出其结果的pass。并非所有可用的passes都允许这样做——稍后我们会详细介绍——但在这个示例中使用的`THREE.FilmPass`允许我们将其pass的结果输出到屏幕。要添加`THREE.FilmPass`，我们首先需要创建它并将其添加到合成器中。生成的代码如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we created `THREE.FilmPass` and set the `renderToScreen` property
    to `true`. This pass is added to `THREE.EffectComposer` after `renderPass,` so
    when this composer is used, first the scene is rendered, and through `THREE.FilmPass`,
    we can also see the output on screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了`THREE.FilmPass`并设置了`renderToScreen`属性为`true`。这个pass在`renderPass`之后添加到`THREE.EffectComposer`中，所以当使用这个合成器时，首先渲染场景，然后通过`THREE.FilmPass`，我们也可以在屏幕上看到输出。
- en: Updating the render loop
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新渲染循环
- en: 'Now we just need to make a small modification to our render loop to use the
    composer instead of `THREE.WebGLRenderer`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要对我们的渲染循环进行一些小的修改，以使用合成器而不是`THREE.WebGLRenderer`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only modification we made is we removed `webGLRenderer.render(scene, camera)`
    and replaced it with `composer.render(delta)`. This will call the render function
    on `EffectComposer`, which in turn uses the passed-in `THREE. WebGLRenderer`,
    and since we set `renderToScreen` of `FilmPass` to `true`, the result from `FilmPass`
    is shown on screen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的唯一修改是我们移除了`webGLRenderer.render(scene, camera)`并将其替换为`composer.render(delta)`。这将调用`EffectComposer`上的渲染函数，它反过来使用传入的`THREE.WebGLRenderer`，由于我们将`FilmPass`的`renderToScreen`设置为`true`，因此`FilmPass`的结果将显示在屏幕上。
- en: With this basic setup, we'll look at the available postprocessing passes in
    the next couple of sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本设置，我们将在接下来的几节中查看可用的后处理passes。
- en: Postprocessing passes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后处理passes
- en: 'Three.js comes with a number of postprocessing passes you can use directly
    with `THREE.EffectComposer`. Note that it''s best to play around with the examples
    in this chapter to see the result of these passes and understand what is happening.
    The following table gives an overview of the passes that are available:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js附带了一些可以直接与`THREE.EffectComposer`一起使用的后处理passes。请注意，最好在本章的示例中尝试，以查看这些passes的结果并理解正在发生的事情。以下表格概述了可用的passes：
- en: '| Pass name | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Pass名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.BloomPass` | This is an effect that makes light areas bleed into darker
    areas. This simulates an effect where the camera is overwhelmed by extremely bright
    light. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BloomPass` | 这是一个使光线区域渗透到较暗区域的效果。这模拟了当相机被极其明亮的光线淹没的效果。|'
- en: '| `THREE.DotScreenPass` | This applies a layer of black dots representing the
    original image across the screen. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.DotScreenPass` | 这会在屏幕上应用一层代表原始图像的黑点层。|'
- en: '| `THREE.FilmPass` | This simulates a TV screen by applying scanlines and distortions.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FilmPass` | 这通过应用扫描线和扭曲来模拟电视屏幕。|'
- en: '| `THREE.GlitchPass` | This shows an electronic glitch on the screen at a random
    time interval. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.GlitchPass` | 这在随机的时间间隔内在屏幕上显示电子故障。|'
- en: '| `THREE.MaskPass` | This allows you to apply a mask to the current image.
    Subsequent passes are only applied to the masked area. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.MaskPass` | 这允许您将蒙版应用于当前图像。后续流程仅应用于蒙版区域。|'
- en: '| `THREE.RenderPass` | This renders a scene based on the supplied scene and
    camera. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.RenderPass` | 这根据提供的场景和相机渲染场景。|'
- en: '| `THREE.SavePass` | When this pass is executed, it makes a copy of the current
    rendering step that you can use later. This pass isn''t that useful in practice,
    and we won''t use it in any of our examples. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SavePass` | 当执行此流程时，它会复制当前渲染步骤，您可以在以后使用。实际上，这个流程并不那么有用，我们不会在我们的任何示例中使用它。|'
- en: '| `THREE.ShaderPass` | This allows you to pass in custom shaders for advanced
    or custom postprocessing passes. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ShaderPass` | 这允许您为高级或定制的后处理流程传递自定义着色器。|'
- en: '| `THREE.TexturePass` | This stores the current state of the composer in a
    texture that you can use as input for other `EffectComposer` instance. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TexturePass` | 这将合成器的当前状态存储在一个纹理中，您可以使用它作为其他 `EffectComposer` 实例的输入。|'
- en: Let's start with a number of simple passes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几个简单的流程开始。
- en: Simple postprocessing passes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的后处理流程
- en: 'For simple passes, we''ll look at what we can do with `THREE.FilmPass`, `THREE.BloomPass`,
    and `THREE.DotScreenPass`. For these passes, an example is available, `02-post-processing-simple`,
    that allows you to experiment with these passes and see how they affect the original
    output differently. The following screenshot shows this example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的流程，我们将查看 `THREE.FilmPass`、`THREE.BloomPass` 和 `THREE.DotScreenPass` 我们能做什么。对于这些流程，有一个示例
    `02-post-processing-simple`，允许您实验这些流程并查看它们如何以不同的方式影响原始输出。以下截图显示了此示例：
- en: '![Simple postprocessing passes](img/2215OS_11_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![简单的后处理流程](img/2215OS_11_02.jpg)'
- en: In this example, we show four scenes at the same time, and on each scene, a
    different postprocessing pass is added. The one in the top-left corner shows `THREE.BloomPass`,
    the one in the top-right corner shows `THREE.FilmPass`, the one in the bottom-left
    corner shows `THREE.DotScreenPass`, and the one in the bottom-right corner shows
    the original render.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们同时展示了四个场景，并且在每个场景中添加了不同的后处理流程。左上角显示的是 `THREE.BloomPass`，右上角显示的是 `THREE.FilmPass`，左下角显示的是
    `THREE.DotScreenPass`，右下角显示的是原始渲染。
- en: 'In this example, we also use `THREE.ShaderPass` and `THREE.TexturePass` to
    reuse the output from the original rendering as input for the other three scenes.
    So, before we look at the individual passes, let''s look at these two passes first:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们也使用了 `THREE.ShaderPass` 和 `THREE.TexturePass` 来重用原始渲染的输出作为其他三个场景的输入。因此，在我们查看单个流程之前，让我们首先看看这两个流程：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this piece of code, we set up `THREE.EffectComposer`, which will output the
    default scene (the one in the bottom-right corner). This composer has two passes.
    `THREE.RenderPass` renders the scene, and `THREE.ShaderPass`, when configured
    with `THREE.CopyShader`, renders the output, without any further postprocessing
    to the screen if we set the `renderToScreen` property to `true`. If you look at
    the example, you can see that we show the same scene four times but with a different
    effect applied each time. We could render the scene from scratch using `THREE.RenderPass`
    four times, but that would be a bit of a waste since we can just reuse the output
    from this first composer. To do this, we create `THREE.TexturePass` and pass in
    the `composer.renderTarget2` value. We can now use the `renderScene` variable
    as input for our other composers without having to render the scene from scratch.
    Let's revisit `THREE.FilmPass` first and see how we can use `THREE.TexturePass`
    as input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们设置了 `THREE.EffectComposer`，它将输出默认场景（右下角的那个）。这个合成器有两个流程。`THREE.RenderPass`
    渲染场景，而 `THREE.ShaderPass`，当配置为 `THREE.CopyShader` 时，渲染输出，如果我们设置 `renderToScreen`
    属性为 `true`，则不会对屏幕进行任何进一步的后处理。如果您查看示例，您会看到我们展示了相同的场景四次，但每次都应用了不同的效果。我们可以使用 `THREE.RenderPass`
    四次从头开始渲染场景，但这会有些浪费，因为我们可以直接重用第一个合成器的输出。为此，我们创建 `THREE.TexturePass` 并传入 `composer.renderTarget2`
    的值。现在我们可以使用 `renderScene` 变量作为其他合成器的输入，而无需从头开始渲染场景。让我们首先回顾一下 `THREE.FilmPass`，看看我们如何使用
    `THREE.TexturePass` 作为输入。
- en: Using THREE.FilmPass to create a TV-like effect
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 THREE.FilmPass 创建类似电视的效果
- en: 'We already looked at how to create `THREE.FilmPass` in the first section of
    this chapter, so let''s see how to use this effect together with `THREE.TexturePass`
    from the previous section:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的第一节中看到了如何创建 `THREE.FilmPass`，现在让我们看看如何将这个效果与上一节中的 `THREE.TexturePass`
    一起使用：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The only step you need to take to use `THREE.TexturePass` is to add it as the
    first pass in your composer. Next, we can just add `THREE.FilmPass`, and the effect
    is applied. `THREE.FilmPass` itself takes four parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.TexturePass` 的唯一步骤是将它添加到你的 composer 中的第一个通道。接下来，我们只需添加 `THREE.FilmPass`，效果就会应用。`THREE.FilmPass`
    本身需要四个参数：
- en: '| Property | Description |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Property` | 描述 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `noiseIntensity` | This property allows you to control how grainy the scene
    looks. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `noiseIntensity` | 这个属性允许你控制场景看起来有多粗糙。|'
- en: '| `scanlinesIntensity` | `THREE.FilmPass` adds a number of scanlines to the
    scene. With this property, you can define how prominently these scanlines are
    shown. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `scanlinesIntensity` | `THREE.FilmPass` 会向场景添加一定数量的扫描线。通过这个属性，你可以定义这些扫描线显示的明显程度。|'
- en: '| `scanLinesCount` | The number of scanlines that are shown can be controlled
    with this property. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `scanLinesCount` | 可以通过这个属性控制显示的扫描线条数。|'
- en: '| `grayscale` | If this is set to `true`, the output will be converted to grayscale.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `grayscale` | 如果设置为 `true`，输出将被转换为灰度。|'
- en: 'There are actually two ways you can pass in these parameters. In this example,
    we passed them in as arguments to the constructor, but you can also set them directly,
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你有两种方式可以传递这些参数。在这个例子中，我们将它们作为构造函数的参数传递，但你也可以直接设置它们，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this approach, we use the `uniforms` property, which is used to communicate
    directly with WebGL. In the section where we talk about creating a custom shader
    later in this chapter, we'll go a bit deeper into `uniforms`; for now, all you
    need to know is that this way, you can directly update the configuration of postprocessing
    passes and shaders and directly see the results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用 `uniforms` 属性，它用于直接与 WebGL 通信。在本章后面关于创建自定义着色器的部分，我们将更深入地探讨 `uniforms`；现在，你需要知道的是，通过这种方式，你可以直接更新后处理通道和着色器的配置，并直接看到结果。
- en: Adding a bloom effect to the scene with THREE.BloomPass
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 THREE.BloomPass 为场景添加光晕效果
- en: 'The effect you see in the upper-left corner is called the bloom effect. When
    you apply the bloom effect, the bright areas of a scene will be made more prominent
    and *bleed* into the darker areas. The code to create `THREE.BloomPass` is shown
    here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上左角看到的效果被称为光晕效果。当你应用光晕效果时，场景中的明亮区域将被突出显示，并 *渗透* 到较暗区域。创建 `THREE.BloomPass`
    的代码如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you compare this with `THREE.EffectComposer`, which we used with `THREE.FilmPass`,
    you'll notice that we add an additional pass, `effectCopy`. This step, which we
    also used for the normal output, doesn't add any special effect but just copies
    the output from the last pass to the screen. We need to add this step since `THREE.BloomPass`
    can't render directly to the screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个与 `THREE.EffectComposer` 进行比较，后者我们与 `THREE.FilmPass` 一起使用，你会注意到我们添加了一个额外的通道，`effectCopy`。这个步骤，我们同样用于正常输出，它不会添加任何特殊效果，只是将最后一个通道的输出复制到屏幕上。我们需要添加这个步骤，因为
    `THREE.BloomPass` 不能直接渲染到屏幕上。
- en: 'The following table lists the properties you can set on `THREE.BloomPass`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了你可以在 `THREE.BloomPass` 上设置的属性：
- en: '| Property | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Property` | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Strength` | This is the strength of the bloom effect. The higher this is,
    the more bright the brighter areas are and the more they "bleed" to the darker
    areas. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Strength` | 这是光晕效果的强度。这个值越高，明亮区域越亮，并且它们向较暗区域的“渗透”越多。|'
- en: '| `kernelSize` | This property controls the offset of the bloom effect. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `kernelSize` | 这个属性控制光晕效果的偏移量。|'
- en: '| `sigma` | With the `sigma` property, you can control the sharpness of the
    bloom effect. The higher the value, the more blurred the bloom effect looks. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `sigma` | 通过 `sigma` 属性，你可以控制光晕效果的锐度。值越高，光晕效果看起来越模糊。|'
- en: '| `Resolution` | The `Resolution` property defines how precisely the bloom
    effect is created. If you make this too low, the result will look blocky. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Resolution` | `Resolution` 属性定义了光晕效果创建的精确度。如果你将其设置得太低，结果看起来会像方块。|'
- en: 'A better way to understand these properties is to just experiment with them
    using the previously mentioned example, `02-post-processing-simple`. The following
    screenshot shows the bloom effect with a high kernel and sigma size and low strength:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面提到的示例，`02-post-processing-simple`，来实验这些属性是更好地理解这些属性的方法。以下截图显示了具有高内核和 sigma
    大小以及低强度的光晕效果：
- en: '![Adding a bloom effect to the scene with THREE.BloomPass](img/2215OS_11_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用 THREE.BloomPass 为场景添加光晕效果](img/2215OS_11_03.jpg)'
- en: The last of the simple effects we'll have a look at is `THREE.DotScreenPass`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个简单效果是 `THREE.DotScreenPass`。
- en: Output the scene as a set of dots
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将场景输出为一系列点
- en: 'Using `THREE.DotScreenPass` is very similar to using `THREE.BloomPass`. We
    just saw `THREE.BloomPass` in action. Now let''s see the code for `THREE.DotScreenPass`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.DotScreenPass` 与使用 `THREE.BloomPass` 非常相似。我们刚刚看到了 `THREE.BloomPass`
    的实际应用。现在让我们看看 `THREE.DotScreenPass` 的代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this effect, we once again have to add `effectCopy` to output the result
    to the screen. `THREE.DotScreenPass` can also be configured with a number of properties,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此效果，我们再次需要添加 `effectCopy` 以将结果输出到屏幕。`THREE.DotScreenPass` 也可以配置多个属性，如下所示：
- en: '| Property | Description |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `center` | With the `center` property, you can fine-tune the way the dots
    are offset. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `center` | 使用 `center` 属性，您可以微调点的偏移方式。|'
- en: '| `angle` | The dots are aligned in a certain manner. With the `angle` properties,
    you can change this alignment. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `angle` | 点以某种方式对齐。使用 `angle` 属性，您可以更改这种对齐方式。|'
- en: '| `Scale` | With this, we can set the size of the dots to use. The lower the
    `scale`, the larger the dots. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Scale` | 使用此功能，我们可以设置要使用的点的大小。`scale` 越低，点就越大。|'
- en: What applies to the other shaders also applies to this shader. It's much easier
    to get the right settings with experimentation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他着色器适用的内容也适用于此着色器。通过实验，更容易获得正确的设置。
- en: '![Output the scene as a set of dots](img/2215OS_11_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![将场景输出为一系列点](img/2215OS_11_04.jpg)'
- en: Showing the output of multiple renderers on the same screen
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在同一屏幕上显示多个渲染器的输出
- en: 'This section doesn''t go into the details of how to use postprocessing effects,
    but explains how to get the output of all four `THREE.EffectComposer` instances
    on the same screen. First, let''s look at the render loop used for this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不深入介绍如何使用后处理效果，而是解释如何在同一屏幕上获取所有四个 `THREE.EffectComposer` 实例的输出。首先，让我们看看用于此示例的渲染循环：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to notice here is that we set the `webGLRenderer.autoClear`
    property to `false` and then explicitly call the `clear()` function. If we don't
    do this each time we call the `render()` function on a composer, the previously
    rendered scenes will be cleared. With this approach, we only clear everything
    at the beginning of our render loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的是，我们将 `webGLRenderer.autoClear` 属性设置为 `false`，然后显式调用 `clear()` 函数。如果我们每次在作曲家上调用
    `render()` 函数时都不这样做，之前渲染的场景将被清除。采用这种方法，我们只在渲染循环的开始处清除一切。
- en: 'To avoid all our composers rendering in the same space, we set the viewport
    of `webGLRenderer`, which is used by our composers, to a different part of the
    screen. This function takes four arguments: `x`, `y`, `width`, and `height`. As
    you can see in the code sample, we use this function to divide the screen into
    four areas and make the composers render to their individual area. Note that you
    can also use this approach with multiple scenes, cameras, and `WebGLRenderer`
    if you want.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有作曲家都在相同的空间中渲染，我们将 `webGLRenderer` 的视口设置到屏幕的不同部分，该视口被我们的作曲家使用。此函数接受四个参数：`x`、`y`、`width`
    和 `height`。如代码示例所示，我们使用此函数将屏幕分成四个区域，并让作曲家在各自区域进行渲染。请注意，如果您想使用多个场景、相机和 `WebGLRenderer`，也可以使用这种方法。
- en: 'In the table at the beginning of this section, we also mentioned `THREE.GlitchPass`.
    With this render pass, you can add a kind of electronic glitch effect to your
    scenes. This effect is just as easy to use as the other ones you''ve seen until
    now. To use it, first include the following two files in your HTML page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头的表格中，我们还提到了 `THREE.GlitchPass`。使用此渲染通道，您可以为场景添加一种电子故障效果。这种效果与您迄今为止看到的其它效果一样易于使用。要使用它，首先在您的
    HTML 页面中包含以下两个文件：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, create the `THREE.GlitchPass` object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建 `THREE.GlitchPass` 对象，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is a scene where the result is rendered normally except that at
    random intervals, a glitch occurs, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个场景，除了在随机间隔发生故障外，渲染结果正常，如下面的截图所示：
- en: '![Showing the output of multiple renderers on the same screen](img/2215OS_11_19.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![显示多个渲染器在同一屏幕上的输出](img/2215OS_11_19.jpg)'
- en: Until now, we've only chained a couple of simple passes. In the next example,
    we'll configure a more complex `THREE.EffectComposer` and use masks to apply effects
    to a part of the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只链式连接了几个简单的步骤。在下一个示例中，我们将配置一个更复杂的`THREE.EffectComposer`，并使用遮罩将效果应用于屏幕的一部分。
- en: Advanced EffectComposer flows using masks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用遮罩的高级EffectComposer流程。
- en: 'In the previous examples, we applied the postprocessing pass to the complete
    screen. Three.js, however, also has the ability to only apply passes to a specific
    area. In this section, we''re going to perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将后处理步骤应用于整个屏幕。然而，Three.js也有能力只将步骤应用于特定区域。在本节中，我们将执行以下步骤：
- en: Create a scene to serve as a background image.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为背景图像的场景。
- en: Create a scene containing a sphere that looks like Earth.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含类似地球的球体的场景。
- en: Create a scene containing a sphere that looks like Mars.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含类似火星的球体的场景。
- en: Create `EffectComposer`, which renders these three scenes into a single image.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`EffectComposer`，将这些三个场景渲染成一张单独的图片。
- en: Apply a *colorify* effect to the sphere rendered as Mars.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染为火星的球体应用一个**colorify**效果。
- en: Apply a sepia effect to the sphere rendered as Earth.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染为地球的球体应用一个棕褐色效果。
- en: 'This might sound complex, but is actually surprisingly easy to accomplish.
    First, let''s look at the result we''re aiming for in the `03-post-processing-masks.html`
    example. The following screenshot shows the result of these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上实现起来非常简单。首先，让我们看看`03-post-processing-masks.html`示例中我们想要达到的结果。以下截图显示了这些步骤的结果：
- en: '![Advanced EffectComposer flows using masks](img/2215OS_11_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用遮罩的高级EffectComposer流程](img/2215OS_11_05.jpg)'
- en: 'The first thing we need to do is set up the various scenes we''ll be rendering,
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置我们将要渲染的各种场景，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To create the Earth and Mars spheres, we just create the spheres with the correct
    material and textures and add them to their specific scenes, as shown in the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地球和火星的球体，我们只需创建具有正确材质和纹理的球体，并将它们添加到它们特定的场景中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to add some lights to the scene just as we would for a normal scene,
    but we won't show that here (see [Chapter 3](ch03.html "Chapter 3. Working with
    the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*, for more details). The only thing to remember
    is that a light cannot be added to different scenes, so you need to create separate
    lights for both scenes. That's all the setting up we need to do for these two
    scenes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要像在正常场景中一样向场景中添加一些灯光，但这里不会展示（详见[第3章](ch03.html "第3章. 使用Three.js中可用的不同光源")，*使用Three.js中可用的不同光源*，获取更多详细信息）。唯一需要记住的是，灯光不能添加到不同的场景中，因此你需要为这两个场景创建单独的灯光。这就是我们为这两个场景需要做的所有设置。
- en: 'For the background image, we create `THREE.OrthoGraphicCamera`. Remember from
    [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"),
    *Basic Components That Make Up a Three.js Scene*, that the size of objects in
    the orthographic projection doesn''t depend on the distance from the camera, so
    this also provides a good way to create fixed backgrounds. Here''s how we create
    `THREE.OrthoGraphicCamera`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景图像，我们创建`THREE.OrthoGraphicCamera`。记得从[第2章](ch02.html "第2章. 组成Three.js场景的基本组件")，*组成Three.js场景的基本组件*，正射投影中物体的尺寸不依赖于相机距离，因此这也提供了一个创建固定背景的好方法。以下是创建`THREE.OrthoGraphicCamera`的方法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We won't go into too much detail for this part, but we have to take a couple
    of steps to create a background image. First, we create a material from our background
    image, and we apply this material to a simple plane. Next, we add this plane to
    the scene and scale it to exactly fill the complete screen. So, when we render
    this scene with this camera, our background image is shown stretched to the width
    of the screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对这个部分进行过多细节的介绍，但我们必须采取几个步骤来创建一个背景图像。首先，我们从背景图像创建一个材质，并将这个材质应用到简单的平面上。接下来，我们将这个平面添加到场景中，并将其缩放到正好填满整个屏幕。因此，当我们用这个相机渲染这个场景时，我们的背景图像会拉伸到屏幕的宽度。
- en: 'We''ve now got our three scenes, and we can start to set up our passes and
    `THREE.EffectComposer`. Let''s start by looking at the complete chain of passes,
    after which we''ll look at the individual passes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了三个场景，可以开始设置我们的渲染通道和`THREE.EffectComposer`了。让我们先看看完整的渲染通道链，然后再看看单个的渲染通道：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To work with masks, we need to create `THREE.EffectComposer` in a different
    manner. In this case, we need to create a new `THREE.WebGLRenderTarget` and set
    the `stencilBuffer` property of the internally used render targets to `true`.
    A stencil buffer is a special type of buffer and is used to limit the area of
    rendering. So, by enabling the stencil buffer, we can use our masks. First, let''s
    look at the first three passes that are added. These three passes render the background,
    the Earth scene, and the Mars scene, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用遮罩，我们需要以不同的方式创建`THREE.EffectComposer`。在这种情况下，我们需要创建一个新的`THREE.WebGLRenderTarget`，并将内部使用的渲染目标的`stencilBuffer`属性设置为`true`。模板缓冲区是一种特殊的缓冲区，用于限制渲染区域。因此，通过启用模板缓冲区，我们可以使用我们的遮罩。首先，让我们看看添加的前三个通道。这三个通道渲染背景、地球场景和火星场景，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There''s nothing new here except that we set the `clear` property of two of
    these passes to `false`. If we don''t do this, we''ll only see the output from
    `renderPass2` since it will clear everything before it starts rendering. If you
    look back at the code for `THREE.EffectComposer`, the next three passes are `marsMask`,
    `effectColorify`, and `clearMask`. First, we''ll look at how these three passes
    are defined:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容，只是我们将其中两个通道的`clear`属性设置为`false`。如果我们不这样做，我们只能看到`renderPass2`的输出，因为它会在开始渲染之前清除一切。如果你回顾一下`THREE.EffectComposer`的代码，接下来的三个通道是`marsMask`、`effectColorify`和`clearMask`。首先，我们将看看这三个通道是如何定义的：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first of these three passes is `THREE.MaskPass`. When creating `THREE.MaskPass`,
    you pass in a scene and a camera just as you did for `THREE.RenderPass`. `THREE.MaskPass`
    will render this scene internally, but instead of showing this on screen, it uses
    this information to create a mask. When `THREE.MaskPass` is added to `THREE.EffectComposer`,
    all the subsequent passes will only be applied to the mask defined by `THREE.MaskPass`,
    until `THREE.ClearMaskPass` is encountered. In this example, this means that the
    `effectColorify` pass, which adds a blue glow, is only applied to the objects
    rendered in `sceneMars`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个通道中的第一个是`THREE.MaskPass`。当创建`THREE.MaskPass`时，你传入一个场景和一个相机，就像你为`THREE.RenderPass`做的那样。`THREE.MaskPass`将内部渲染这个场景，但不会在屏幕上显示，而是使用这些信息来创建一个遮罩。当`THREE.MaskPass`添加到`THREE.EffectComposer`中时，所有后续的通道将只应用于由`THREE.MaskPass`定义的遮罩，直到遇到`THREE.ClearMaskPass`。在这个例子中，这意味着添加蓝色光芒的`effectColorify`通道只应用于在`sceneMars`中渲染的对象。
- en: We use the same approach to apply a sepia filter on the Earth object. We first
    create a mask based on the Earth scene and use this mask in `THREE.EffectComposer`.
    After `THREE.MaskPass`, we add the effect we want to apply (`effectSepia` in this
    case), and once we're done with that, we add `THREE.ClearMaskPass` to remove the
    mask. The last step for this specific `THREE.EffectComposer` is one we've already
    seen. We need to copy the final result to the screen, and we once again use the
    `effectCopy` pass for that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法在地球对象上应用棕褐色滤镜。我们首先基于地球场景创建一个遮罩，并在`THREE.EffectComposer`中使用这个遮罩。在`THREE.MaskPass`之后，我们添加我们想要应用的效果（在这个例子中是`effectSepia`），完成之后，我们添加`THREE.ClearMaskPass`来移除遮罩。对于这个特定的`THREE.EffectComposer`的最后一步，我们已经见过。我们需要将最终结果复制到屏幕上，为此我们再次使用`effectCopy`通道。
- en: 'There is one additional property that''s interesting when working with `THREE.MaskPass,`
    and that''s the `inverse` property. If this property is set to `true`, the mask
    is inversed. In other words, the effect is applied to everything but the scene
    passed into `THREE.MaskPass`. This is shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`THREE.MaskPass`一起工作时，有一个有趣的额外属性，那就是`inverse`属性。如果这个属性设置为`true`，遮罩将被反转。换句话说，效果应用于除了`THREE.MaskPass`传入的场景之外的所有内容。这在上面的屏幕截图中显示：
- en: '![Advanced EffectComposer flows using masks](img/2215OS_11_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用遮罩的Advanced EffectComposer流程](img/2215OS_11_06.jpg)'
- en: Until now, we've used standard passes provided by Three.js for our effects.
    Three.js also provides `THREE.ShaderPass`, which can be used for custom effects
    and comes with a large number of shaders you can use and experiment with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用Three.js提供的标准通道来应用我们的效果。Three.js还提供了`THREE.ShaderPass`，它可以用于自定义效果，并附带大量你可以使用和实验的着色器。
- en: Using THREE.ShaderPass for custom effects
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用THREE.ShaderPass进行自定义效果
- en: 'With `THREE.ShaderPass`, we can apply a large number of additional effects
    to our scene by passing in a custom shader. This section is divided into three
    parts. First, we''ll look at the following set of simple shaders:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ShaderPass`，我们可以通过传递自定义着色器来将大量额外的效果应用到我们的场景中。本节分为三个部分。首先，我们将探讨以下一系列简单着色器：
- en: '| Name | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.MirrorShader` | This creates a mirror effect for part of the screen.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.MirrorShader` | 这为屏幕的一部分创建镜像效果。|'
- en: '| `THREE.HueSaturationShader` | This allows you to change the *hue* and *saturation*
    of the colors. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HueSaturationShader` | 这允许您更改颜色的**色调**和**饱和度**。|'
- en: '| `THREE.VignetteShader` | This applies a vignette effect. This effect shows
    dark borders around the center of the image. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.VignetteShader` | 这应用了一个晕影效果。此效果在图像中心显示暗色边缘。|'
- en: '| `THREE.ColorCorrectionShader` | With this shader, you can change the color
    distribution. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ColorCorrectionShader` | 使用此着色器，您可以更改颜色分布。|'
- en: '| `THREE.RGBShiftShader` | This shader separates the red, green, and blue components
    of a color. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.RGBShiftShader` | 此着色器将颜色的红色、绿色和蓝色分量分离。|'
- en: '| `THREE.BrightnessContrastShader` | This changes the brightness and contrast
    of an image. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BrightnessContrastShader` | 这改变图像的亮度和对比度。|'
- en: '| `THREE.ColorifyShader` | This applies a color overlay to the screen. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ColorifyShader` | 这将颜色叠加到屏幕上。|'
- en: '| `THREE.SepiaShader` | This creates a sepia-like effect on the screen. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SepiaShader` | 这在屏幕上创建类似棕褐色效果。|'
- en: '| `THREE.KaleidoShader` | This adds a kaleidoscope effect to the scene that
    provides radial reflection around the center of the scene. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.KaleidoShader` | 这为场景添加了一个万花筒效果，在场景中心提供径向反射。|'
- en: '| `THREE.LuminosityShader` | This provides a luminosity effect where the luminosity
    of the scene is shown. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LuminosityShader` | 这提供了一个亮度效果，其中显示了场景的亮度。|'
- en: '| `THREE.TechnicolorShader` | This simulates the effect of two-strip technicolor
    that can be seen in older movies. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TechnicolorShader` | 这模拟了在老电影中可以看到的双条技术彩色效果。|'
- en: 'Next, we''ll look at shaders that provide a couple of blur-related effects:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨提供一些模糊相关效果的着色器：
- en: '| Name | Description |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader` | These apply
    a blur effect to the complete scene. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HorizontalBlurShader` 和 `THREE.VerticalBlurShader` | 这些将模糊效果应用到整个场景。|'
- en: '| `THREE.HorizontalTiltShiftShader` and `THREE.VerticalTiltShiftShader` | These
    recreate the *tilt shift* effect. With the tilt shift effect, it is possible to
    create scenes that look like a miniature by making sure only part of the image
    is sharp. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HorizontalTiltShiftShader` 和 `THREE.VerticalTiltShiftShader` | 这些重新创建了**倾斜移位**效果。通过倾斜移位效果，可以确保只有图像的一部分是清晰的，从而创建出类似微缩景观的场景。|'
- en: '| `THREE.TriangleBlurShader` | This applies a blur effect using a triangle-based
    approach. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TriangleBlurShader` | 这使用基于三角形的方法应用模糊效果。|'
- en: 'And finally, we''ll look at a few shaders that provide advanced effects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨一些提供高级效果的着色器：
- en: '| Name | Description |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.BleachBypassShader` | This creates a *bleach bypass* effect. With
    this effect, a silver-like overlay will be applied to the image. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BleachBypassShader` | 这创建了一个**漂白绕过**效果。使用此效果，将在图像上应用类似银色的叠加。|'
- en: '| `THREE.EdgeShader` | This shader can be used to detect the sharp edges in
    an image and highlight them. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.EdgeShader` | 此着色器可用于检测图像中的锐利边缘并突出显示它们。|'
- en: '| `THREE.FXAAShader` | This shader applies an anti-aliasing effect during the
    postprocessing phase. Use this if applying anti-aliasing during rendering is too
    expensive. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FXAAShader` | 此着色器在后期处理阶段应用抗锯齿效果。如果应用渲染时的抗锯齿太昂贵，请使用此着色器。|'
- en: '| `THREE.FocusShader` | This is a simple shader that results in a sharply rendered
    center area and blurring along its borders. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FocusShader` | 这是一个简单的着色器，它产生一个清晰渲染的中心区域和其边缘的模糊。|'
- en: We won't go into the details of all the shaders since if you've seen how one
    works, you pretty much know how the others work. In the following sections, we'll
    highlight a couple of interesting ones. You can experiment with the others using
    the interactive examples provided for each section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如果您已经看到其中一个着色器的工作原理，您基本上就知道了其他着色器的工作原理。在接下来的几节中，我们将突出介绍几个有趣的着色器。您可以使用每个部分提供的交互式示例来实验其他着色器。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Three.js also provides two advanced postprocessing effects that allow you to
    apply a *bokeh* effect to your scene. A bokeh effect provides a blur effect to
    part of the scene while rendering your main subject very sharply. Three.js provides
    `THREE.BrokerPass`, which you can use for this, or `THREE.BokehShader2` and `THREE.DOFMipMapShader`,
    which you can use together with `THREE.ShaderPass`. An example of these shaders
    in action can be found on the Three.js website at [http://threejs.org/examples/webgl_postprocessing_dof2.html](http://threejs.org/examples/webgl_postprocessing_dof2.html)
    and [http://threejs.org/examples/webgl_postprocessing_dof.html](http://threejs.org/examples/webgl_postprocessing_dof.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了两种高级后处理效果，允许你将*散景*效果应用到场景中。散景效果在渲染主要主题时非常锐利，而对场景的一部分提供模糊效果。Three.js提供了`THREE.BrokerPass`，你可以用它来实现这个效果，或者使用`THREE.BokehShader2`和`THREE.DOFMipMapShader`，你可以将它们与`THREE.ShaderPass`一起使用。这些着色器在实际应用中的例子可以在Three.js网站上找到，地址为[http://threejs.org/examples/webgl_postprocessing_dof2.html](http://threejs.org/examples/webgl_postprocessing_dof2.html)和[http://threejs.org/examples/webgl_postprocessing_dof.html](http://threejs.org/examples/webgl_postprocessing_dof.html)。
- en: We start with a couple of the simple shaders.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从几个简单的着色器开始。
- en: Simple shaders
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单着色器
- en: 'To experiment with the basic shaders, we''ve created an example where you can
    play around with the shaders and see the effect directly in the scene. You can
    find this example in `04-shaderpass-simple.html`. The following screenshot shows
    this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验基本着色器，我们创建了一个示例，你可以在这里玩转着色器并直接在场景中看到效果。你可以在`04-shaderpass-simple.html`中找到这个示例。以下截图显示了此示例：
- en: '![Simple shaders](img/2215OS_11_07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](img/2215OS_11_07.jpg)'
- en: 'With the menu in the top-right corner, you can select the specific shader you
    want to apply, and with the various drop-down menus, you can set the properties
    of the shader you''ve selected. For instance, the following screenshot shows `RGBShiftShader`
    in action:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右上角的菜单，你可以选择要应用的具体着色器，并通过各种下拉菜单设置所选着色器的属性。例如，以下截图显示了`RGBShiftShader`的实际应用效果：
- en: '![Simple shaders](img/2215OS_11_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](img/2215OS_11_08.jpg)'
- en: 'When you change one of the properties of a shader, the result is updated directly.
    For this example, we set the changed value directly on the shader. For instance,
    when values for `RGBShiftShader` have changed, we update the shader like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你改变一个着色器的属性时，结果会直接更新。在这个例子中，我们直接在着色器上设置更改的值。例如，当`RGBShiftShader`的值发生变化时，我们像这样更新着色器：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at a couple of other shaders. The following image shows the result
    of `VignetteShader`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他几个着色器。以下图像显示了`VignetteShader`的结果：
- en: '![Simple shaders](img/2215OS_11_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](img/2215OS_11_09.jpg)'
- en: '`MirrorShader` has the following effect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`MirrorShader`具有以下效果：'
- en: '![Simple shaders](img/2215OS_11_10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](img/2215OS_11_10.jpg)'
- en: 'With postprocessing, we can also apply extreme effects. A good example of this
    is `THREE.KaleidoShader`. If you select this shader from the menu in the top-right
    corner, you''ll see the following effect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后处理，我们还可以应用极端效果。一个很好的例子是`THREE.KaleidoShader`。如果你从右上角的菜单中选择这个着色器，你会看到以下效果：
- en: '![Simple shaders](img/2215OS_11_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](img/2215OS_11_11.jpg)'
- en: That's enough for the simple shaders. As you can see, they are very versatile
    and can create very interesting-looking effects. In this example, we applied a
    single shader each time, but you can add as many `THREE.ShaderPass` steps to `THREE.EffectComposer`
    as you like.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 简单着色器就介绍到这里。正如你所见，它们非常灵活，可以创建非常有趣的效果。在这个例子中，我们每次只应用一个着色器，但你可以根据需要向`THREE.EffectComposer`添加任意多的`THREE.ShaderPass`步骤。
- en: Blurring shaders
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊着色器
- en: 'In this section, we won''t dive into the code; we''ll just show you the results
    from the various blur shaders. You can experiment with these using the `05-shaderpass-blur.html`
    example. The following scene is blurred with `HorizontalBlurShader` and `VerticalBlurShader`,
    both of which you will learn about in the following paragraphs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会深入代码；我们只会展示各种模糊着色器的结果。你可以使用`05-shaderpass-blur.html`示例来实验这些效果。以下场景使用了`HorizontalBlurShader`和`VerticalBlurShader`进行模糊处理，这两个着色器你将在接下来的段落中学习：
- en: '![Blurring shaders](img/2215OS_11_12.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](img/2215OS_11_12.jpg)'
- en: 'The preceding image shows `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader`.
    You can see the effect is a blurred scene. Besides these two blur effects, Three.js
    provides an additional shader that blurs an image, `THREE.TriangleShader`, which
    is shown here. For instance, you could use this shader to depict motion blur,
    as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了 `THREE.HorizontalBlurShader` 和 `THREE.VerticalBlurShader`。你可以看到效果是一个模糊的场景。除了这两个模糊效果之外，Three.js
    还提供了一个可以模糊图像的着色器，`THREE.TriangleShader`，如下所示。例如，你可以使用这个着色器来描绘运动模糊，如下面的截图所示：
- en: '![Blurring shaders](img/2215OS_11_13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](img/2215OS_11_13.jpg)'
- en: 'The last blur-like effect is provided by `THREE.HorizontalTiltShiftShader`
    and `THREE.VerticalTiltShiftShader`. This shader doesn''t blur the complete scene,
    but only a small area. This provides an effect called *tilt shift*. This is often
    used to create miniature-like scenes from normal photographs. The following image
    shows this effect:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个类似模糊的效果是由 `THREE.HorizontalTiltShiftShader` 和 `THREE.VerticalTiltShiftShader`
    提供的。这个着色器不会模糊整个场景，而只是一个小区域。这提供了称为 *倾斜移位* 的效果。这通常用于从普通照片中创建类似微缩模型的效果。下面的图像展示了这个效果：
- en: '![Blurring shaders](img/2215OS_11_14.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](img/2215OS_11_14.jpg)'
- en: Advanced shaders
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级着色器
- en: 'For the advanced shaders, we''ll do what we did for the previous blur-shaders.
    We''ll just show you the output of the shaders. For details on how to configure
    them, look at the `06-shaderpass-advanced.html` example. The following screenshot
    shows this example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级着色器，我们将做与之前模糊着色器相同的事情。我们只会展示着色器的输出。有关如何配置它们的详细信息，请查看 `06-shaderpass-advanced.html`
    示例。下面的截图展示了这个示例：
- en: '![Advanced shaders](img/2215OS_11_15.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![高级着色器](img/2215OS_11_15.jpg)'
- en: The preceding example shows `THREE.EdgeShader`. With this shader, you can detect
    the edges of objects in your scene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了 `THREE.EdgeShader`。使用这个着色器，你可以检测场景中物体的边缘。
- en: 'The next shader is `THREE.FocusShader`. This shader only renders the center
    of the screen in focus, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个着色器是 `THREE.FocusShader`。这个着色器只渲染屏幕的中心区域，如下面的截图所示：
- en: '![Advanced shaders](img/2215OS_11_16.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![高级着色器](img/2215OS_11_16.jpg)'
- en: Until now, we've only used shaders that are provided by Three.js. However, it's
    also very easy to create shaders yourself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了 Three.js 提供的着色器。然而，自己创建着色器也非常简单。
- en: Creating custom postprocessing shaders
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义后处理着色器
- en: In this section, you'll learn how to create a custom shader that you can use
    in postprocessing. We'll create two different shaders. The first one will convert
    the current image into a grayscale image, and the second one will convert the
    image into an 8-bit image by reducing the number of colors that are available.
    Note that creating vertex and fragment shaders is a very broad subject. In this
    section, we only touch the surface of what can be done by these shaders and how
    they work. For more in-depth information, you can find the WebGL specification
    at [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/). An additional
    good resource full of examples is Shadertoy at [https://www.shadertoy.com/](https://www.shadertoy.com/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建一个自定义着色器，你可以在后处理中使用它。我们将创建两个不同的着色器。第一个将当前图像转换为灰度图像，第二个将通过减少可用的颜色数量将图像转换为
    8 位图像。请注意，创建顶点和片段着色器是一个非常广泛的主题。在本节中，我们只触及了这些着色器可以做什么以及它们是如何工作的表面。对于更深入的信息，你可以在
    [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/) 找到 WebGL 规范。另一个充满示例的额外资源是
    Shadertoy，网址为 [https://www.shadertoy.com/](https://www.shadertoy.com/)。
- en: Custom grayscale shader
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义灰度着色器
- en: 'To create a custom shader for Three.js (and also for other WebGL libraries),
    you need to implement two components: a vertex shader and a fragment shader. The
    vertex shader can be used to change the position of individual vertices, and the
    fragment shader is used to determine the color of individual pixels. For a postprocessing
    shader, we only need to implement a fragment shader, and we can keep the default
    vertex shader provided by Three.js. An important point to make before looking
    at the code is that GPUs usually support multiple shader pipelines. This means
    that in the vertex shaders step, multiple shaders can run in parallel—something
    that goes for the fragment shaders step as well.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Three.js（以及其它WebGL库）创建自定义着色器，你需要实现两个组件：一个顶点着色器和一个片段着色器。顶点着色器可以用来改变单个顶点的位置，而片段着色器用于确定单个像素的颜色。对于后期处理着色器，我们只需要实现一个片段着色器，并且可以保留Three.js提供的默认顶点着色器。在查看代码之前，需要指出的是，GPU通常支持多个着色器管线。这意味着在顶点着色器步骤中，可以并行运行多个着色器——同样也适用于片段着色器步骤。
- en: 'Let''s start by looking at the complete source code for the shader that applies
    a grayscale effect to our image (`custom-shader.js`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看应用于我们图像的灰度效果的着色器的完整源代码（`custom-shader.js`）：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see from the code, this isn't JavaScript. When you write shaders,
    you write them in the **OpenGL Shading Language** (**GLSL**), which looks a lot
    like the C programming language. More information on GLSL can be found at [http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，这并不是JavaScript。当你编写着色器时，你使用的是**OpenGL着色语言**（**GLSL**），它看起来很像C编程语言。有关GLSL的更多信息可以在[http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/)找到。
- en: 'Let''s first look at this vertex shader:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个顶点着色器：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For postprocessing, this shader doesn't really need to do anything. The code
    you see above is the standard way Three.js implements a vertex shader. It uses
    `projectionMatrix`, which is the projection from the camera, together with `modelViewMatrix`,
    which maps an object's position into the world position, to determine where to
    render an object on screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后期处理，这个着色器实际上并不需要做任何事情。上面看到的代码是Three.js实现顶点着色器的标准方式。它使用`projectionMatrix`，这是从相机到投影，以及`modelViewMatrix`，它将对象的位映射到世界位置，以确定在屏幕上渲染对象的位置。
- en: 'For postprocessing, the only interesting thing in this piece of code is that
    the `uv` value, which indicates which texel to read from a texture, is passed
    on to the fragment shader using the "`varying` `vec2` `vUv`" variable. We will
    use the `vUV` value to get the correct pixel to work on in the fragment shader.
    Let''s look at the fragment shader and see what the code is doing. We start with
    the following variable declaration:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后期处理，这段代码中唯一有趣的是`uv`值，它指示从纹理中读取哪个texel，通过使用"`varying` `vec2` `vUv`"变量传递到片段着色器。我们将使用`vUV`值在片段着色器中获取正确的像素进行操作。让我们看看片段着色器并看看代码在做什么。我们首先声明以下变量：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we see four instances of the `uniforms` property. The instances of the
    `uniforms` property have values that are passed in from JavaScript to the shader
    and which are the same for each fragment that is processed. In this case, we pass
    in three floats, identified by type `f` (which are used to determine the ratio
    of a color to include in the final grayscale image), and a texture (`tDiffuse`)
    is passed in, identified by type `t`. This texture contains the image from the
    previous pass from `THREE.EffectComposer`. Three.js makes sure it gets passed
    correctly to this shader, and we can set the other instances of the uniforms property
    ourselves from JavaScript. Before we can use these uniforms from JavaScript, we
    have to define which `uniforms` property is available for this shader. This is
    done like this, at the top of the shader file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到四个`uniforms`属性的实例。`uniforms`属性的实例具有从JavaScript传递到着色器的值，并且对于每个处理的片段都是相同的。在这种情况下，我们传递了三个由类型`f`（用于确定要包含在最终灰度图像中的颜色的比例）标识的浮点数，以及一个纹理（`tDiffuse`），由类型`t`标识。这个纹理包含来自`THREE.EffectComposer`的前一个传递的图像。Three.js确保它正确地传递到这个着色器中，并且我们可以从JavaScript中自行设置`uniforms`属性的其它实例。在我们能够从JavaScript中使用这些`uniforms`之前，我们必须定义哪个`uniforms`属性对于这个着色器是可用的。这是在着色器文件顶部这样做的：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we can receive configuration parameters from Three.js and have
    received the image we want to modify. Let''s look at the code that will convert
    each pixel to a gray pixel:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以从 Three.js 接收配置参数，并且已经接收到了我们想要修改的图像。让我们看看将每个像素转换为灰度像素的代码：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What happens here is that we get the correct pixel from the passed-in texture.
    We do this by using the `texture2D` function, where we pass in our current image
    (`tDiffuse`) and the location of the pixel (`vUv`) we want to analyze. The result
    is a texel (a pixel from a texture) that contains a color and an opacity (`texel.w`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我们从传入的纹理中获取正确的像素。我们通过使用 `texture2D` 函数来完成，我们传入当前图像（`tDiffuse`）和我们想要分析的像素位置（`vUv`）。结果是包含颜色和透明度（`texel.w`）的
    texel（纹理中的像素）。
- en: 'Next, we use the `r`, `g`, and `b` properties of this texel to calculate a
    gray value. This gray value is set to the `gl_FragColor` variable, which is eventually
    shown on screen. And with that, we''ve got our own custom shader. Using this shader
    is just like the other shaders. First, we just need to set up `THREE.EffectComposer`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这个 texel 的 `r`、`g` 和 `b` 属性来计算一个灰度值。这个灰度值被设置为 `gl_FragColor` 变量，最终在屏幕上显示。就这样，我们得到了自己的自定义着色器。使用这个着色器就像使用其他着色器一样。首先，我们只需要设置
    `THREE.EffectComposer`：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call `composer.render(delta)` in the render loop. If we want to change the
    properties of this shader at runtime, we can just update the `uniforms` property
    we''ve defined:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染循环中调用 `composer.render(delta)`。如果我们想在运行时更改着色器的属性，我们只需更新我们定义的 `uniforms` 属性：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result can be seen in `07-shaderpass-custom.html`. The following screenshot
    shows this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在 `07-shaderpass-custom.html` 中查看。以下截图展示了这个示例：
- en: '![Custom grayscale shader](img/2215OS_11_17.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![自定义灰度着色器](img/2215OS_11_17.jpg)'
- en: Let's create another custom shader. This time, we'll reduce the 24-bit output
    to a lower bit count.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个自定义着色器。这次，我们将 24 位输出降低到更低的位计数。
- en: Creating a custom bit shader
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义位着色器
- en: Normally, colors are represented as a 24-bit value, which gives us about 16
    million different colors. In the early days of computing, this wasn't possible,
    and colors where often represented as 8- or 16-bit colors. With this shader, we'll
    automatically transform our 24-bit output to a color depth of 8 bits (or anything
    you want).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，颜色以 24 位值表示，这给我们提供了大约 1600 万种不同的颜色。在计算机的早期，这是不可能的，颜色通常以 8 位或 16 位颜色表示。使用这个着色器，我们将自动将
    24 位输出转换为 8 位颜色深度（或任何你想要的）。
- en: 'Since it hasn''t changed with regard to our previous example, we''ll skip the
    vertex shader and directly list the instances of the `uniforms` property:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与我们之前的示例没有变化，我们将跳过顶点着色器，直接列出 `uniforms` 属性的实例：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s the fragment shader itself:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是片段着色器本身：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We define two instances of the `uniforms` property that can be used to configure
    this shader. The first one is the one Three.js uses to pass in the current screen,
    and the second one is defined by us as an integer (`type:` `"i"`) and serves as
    the color depth we want to render the result in. The code itself is very straightforward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个 `uniforms` 属性的实例，可以用来配置这个着色器。第一个是 Three.js 用来传入当前屏幕的，第二个是我们定义的整数（`type:`
    `"i"`），作为我们想要渲染结果的颜色深度。代码本身非常简单：
- en: We first get `texel` from the texture and `tDiffuse` based on the passed-in
    `vUv` location of the pixel.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先根据传入的像素位置 `vUv` 从纹理中获取 `texel` 和 `tDiffuse`。
- en: We calculate the number of colors we can have based on the `bitSize` property
    by calculating 2 to the power of `bitSize` (`pow(float(bitSize),2.0))`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据 `bitSize` 属性计算可以拥有的颜色数量，通过计算 `2` 的 `bitSize` 次方（`pow(float(bitSize),2.0)`）。
- en: Next, we calculate the new value of the color of `texel` by multiplying the
    value with `n`, rounding it off, `(floor(texel.r*n))`, and dividing it again by
    `n`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将值乘以 `n`，四舍五入，`(floor(texel.r*n))`，然后再除以 `n` 来计算 `texel` 的颜色的新值。
- en: The result is set to `gl_FragColor` (red, green, and blue values and the opacity)
    and shown on screen.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果被设置为 `gl_FragColor`（红色、绿色、蓝色值和透明度）并在屏幕上显示。
- en: 'You can view the result for this custom shader in the same example as our previous
    custom shader, `07-shaderpass-custom.html`. The following screenshot shows this
    example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在与之前自定义着色器相同的示例 `07-shaderpass-custom.html` 中查看这个自定义着色器的结果。以下截图展示了这个示例：
- en: '![Creating a custom bit shader](img/2215OS_11_18.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义位着色器](img/2215OS_11_18.jpg)'
- en: That's it for this chapter on postprocessing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于后处理的介绍就到这里。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We talked about a lot of different postprocessing options in this chapter. As
    you saw, creating `THREE.EffectComposer` and chaining passes together is actually
    very easy. You just have to keep in mind a few things. Not all passes output to
    the screen. If you want to output to the screen, you can always use `THREE.ShaderPass`
    with `THREE.CopyShader`. The sequence in which you add passes to a composer is
    important. Effects are applied in that sequence. If you want to reuse the result
    from a specific `THREE.EffectComposer` instance, you can do this by using `THREE.TexturePass`.
    When you have more than one `THREE.RenderPass` in your `THREE.EffectComposer`,
    make sure to set the `clear` property to `false`. If not, you'll only see the
    output from the last `THREE.RenderPass` step. If you only want to apply an effect
    to a specific object, you can use `THREE.MaskPass`. When you're done with the
    mask, clear the mask with `THREE.ClearMaskPass`. Besides the standard passes provided
    by Three.js, there are also a large number of standard shaders available. You
    can use these together with `THREE.ShaderPass`. Creating custom shaders for postprocessing
    is very easy using the standard approach from Three.js. You only need to create
    a fragment shader.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多不同的后处理选项。正如你所见，创建`THREE.EffectComposer`并将多个步骤链接起来实际上非常简单。你只需记住几点。并非所有步骤都会输出到屏幕。如果你想输出到屏幕，你可以始终使用`THREE.ShaderPass`与`THREE.CopyShader`。将步骤添加到composer中的顺序很重要。效果是按照这个顺序应用的。如果你想重用特定`THREE.EffectComposer`实例的结果，你可以通过使用`THREE.TexturePass`来实现。当你有多个`THREE.RenderPass`在`THREE.EffectComposer`中时，请确保将`clear`属性设置为`false`。如果不这样做，你将只能看到最后一个`THREE.RenderPass`步骤的输出。如果你想只将效果应用到特定的对象上，你可以使用`THREE.MaskPass`。当你完成遮罩后，使用`THREE.ClearMaskPass`清除遮罩。除了Three.js提供的标准步骤外，还有大量标准着色器可用。你可以将这些着色器与`THREE.ShaderPass`一起使用。使用Three.js的标准方法创建自定义后处理着色器非常简单。你只需要创建一个片段着色器。
- en: Until now, we pretty much covered everything there is to know about Three.js.
    For the next chapter, the last one, we'll look at a library called **Physijs**
    that you can use to extend Three.js with physics and apply collisions, gravity,
    and constraints.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎涵盖了关于Three.js的所有知识。在下一章，也就是最后一章，我们将探讨一个名为**Physijs**的库，你可以使用它来扩展Three.js的功能，并应用碰撞、重力和约束。
