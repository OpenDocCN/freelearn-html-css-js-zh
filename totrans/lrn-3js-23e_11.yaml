- en: Chapter 11. Custom Shaders and Render Postprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re getting to the end of the book, and in this chapter, we''ll look at
    the one main feature of Three.js we haven''t touched upon: render postprocessing.
    Besides that, in this chapter, we''ll also introduce you to how you can create
    custom shaders. The main points we''ll discuss in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Three.js for postprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the basic postprocessing passes provided by Three.js, such as `THREE.BloomPass`
    and `THREE.FilmPass`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying effects to part of the scene using masks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `THREE.TexturePass` to store rendering results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `THREE.ShaderPass` to add even more basic postprocessing effects, such
    as sepia filters, mirror effects, and color adjustments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `THREE.ShaderPass` for various blurring effects and more advanced filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom postprocessing effect by writing a simple shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Introducing requestAnimationFrame* section of [Chapter 1](ch01.html
    "Chapter 1. Creating Your First 3D Scene with Three.js"), *Creating Your First
    3D Scene with Three.js*, we set up a rendering loop that we've used throughout
    the book to render and animate our scene. For postprocessing, we need to make
    a couple of changes to this setup to allow Three.js to postprocess the final rendering.
    In the first section, we'll look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Three.js for postprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up Three.js for postprocessing, we need to make a couple of changes
    in our current setup. We need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `THREE.EffectComposer`, which we can use to add postprocessing passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `THREE.EffectComposer` so that it renders our scene and applies any
    additional postprocessing steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the render loop, use `THREE.EffectComposer` to render the scene, apply the
    passes, and show the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, we have an example that you can use to experiment with and adopt
    for your own uses. The first example for this chapter can be accessed from `01-basic-effect-composer.html`.
    You can use the menu in the top-right corner to modify the properties of the postprocessing
    step used in this example. In this example, we render a simple globe and add an
    old-television-like effect to it. This television effect is added after the scene
    is rendered using `THREE.EffectComposer`. The following screenshot shows this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Three.js for postprocessing](img/2215OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating THREE.EffectComposer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first look at the additional JavaScript files you need to include. These
    files can be found in the Three.js distribution in the `examples/js/postprocessing`
    and `examples/js/shaders` directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal setup you need to get `THREE.EffectComposer` working is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `EffectComposer.js` file provides the `THREE.EffectComposer` object that
    allows us to add postprocessing steps. `MaskPass.js`, `ShaderPass.js`, and `CopyShader.js`
    are used internally by `THREE.EffectComposer`, and `RenderPass.js` allows us to
    add a rendering pass to `THREE.EffectComposer`. Without that pass, our scene won't
    be rendered at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we add two additional JavaScript files to add a film-like
    effect to our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is create `THREE.EffectComposer`. You can do
    this by passing in `THREE.WebGLRenderer` to its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add various *passes* to this composer.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring THREE.EffectComposer for postprocessing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each pass is executed in the sequence it is added to `THREE.EffectComposer`.
    The first pass we add is `THREE.RenderPass`. The following pass renders our scene
    but doesn''t output it to the screen yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To create `THREE.RenderPass`, we pass in the scene we want to render and the
    camera that we want to use. With the `addPass` function, we add `THREE.RenderPass`
    to `THREE.EffectComposer`. The next step is to add another pass that will output
    its result to the screen. Not all the available passes allow this—more on that
    later—but `THREE.FilmPass`, which is used in this example, allows us to output
    the result of its pass to the screen. To add `THREE.FilmPass`, we first need to
    create it and add it to the composer. The resulting code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created `THREE.FilmPass` and set the `renderToScreen` property
    to `true`. This pass is added to `THREE.EffectComposer` after `renderPass,` so
    when this composer is used, first the scene is rendered, and through `THREE.FilmPass`,
    we can also see the output on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the render loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we just need to make a small modification to our render loop to use the
    composer instead of `THREE.WebGLRenderer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only modification we made is we removed `webGLRenderer.render(scene, camera)`
    and replaced it with `composer.render(delta)`. This will call the render function
    on `EffectComposer`, which in turn uses the passed-in `THREE. WebGLRenderer`,
    and since we set `renderToScreen` of `FilmPass` to `true`, the result from `FilmPass`
    is shown on screen.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic setup, we'll look at the available postprocessing passes in
    the next couple of sections.
  prefs: []
  type: TYPE_NORMAL
- en: Postprocessing passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js comes with a number of postprocessing passes you can use directly
    with `THREE.EffectComposer`. Note that it''s best to play around with the examples
    in this chapter to see the result of these passes and understand what is happening.
    The following table gives an overview of the passes that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pass name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.BloomPass` | This is an effect that makes light areas bleed into darker
    areas. This simulates an effect where the camera is overwhelmed by extremely bright
    light. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.DotScreenPass` | This applies a layer of black dots representing the
    original image across the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.FilmPass` | This simulates a TV screen by applying scanlines and distortions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.GlitchPass` | This shows an electronic glitch on the screen at a random
    time interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.MaskPass` | This allows you to apply a mask to the current image.
    Subsequent passes are only applied to the masked area. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.RenderPass` | This renders a scene based on the supplied scene and
    camera. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.SavePass` | When this pass is executed, it makes a copy of the current
    rendering step that you can use later. This pass isn''t that useful in practice,
    and we won''t use it in any of our examples. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ShaderPass` | This allows you to pass in custom shaders for advanced
    or custom postprocessing passes. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.TexturePass` | This stores the current state of the composer in a
    texture that you can use as input for other `EffectComposer` instance. |'
  prefs: []
  type: TYPE_TB
- en: Let's start with a number of simple passes.
  prefs: []
  type: TYPE_NORMAL
- en: Simple postprocessing passes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For simple passes, we''ll look at what we can do with `THREE.FilmPass`, `THREE.BloomPass`,
    and `THREE.DotScreenPass`. For these passes, an example is available, `02-post-processing-simple`,
    that allows you to experiment with these passes and see how they affect the original
    output differently. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple postprocessing passes](img/2215OS_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we show four scenes at the same time, and on each scene, a
    different postprocessing pass is added. The one in the top-left corner shows `THREE.BloomPass`,
    the one in the top-right corner shows `THREE.FilmPass`, the one in the bottom-left
    corner shows `THREE.DotScreenPass`, and the one in the bottom-right corner shows
    the original render.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we also use `THREE.ShaderPass` and `THREE.TexturePass` to
    reuse the output from the original rendering as input for the other three scenes.
    So, before we look at the individual passes, let''s look at these two passes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we set up `THREE.EffectComposer`, which will output the
    default scene (the one in the bottom-right corner). This composer has two passes.
    `THREE.RenderPass` renders the scene, and `THREE.ShaderPass`, when configured
    with `THREE.CopyShader`, renders the output, without any further postprocessing
    to the screen if we set the `renderToScreen` property to `true`. If you look at
    the example, you can see that we show the same scene four times but with a different
    effect applied each time. We could render the scene from scratch using `THREE.RenderPass`
    four times, but that would be a bit of a waste since we can just reuse the output
    from this first composer. To do this, we create `THREE.TexturePass` and pass in
    the `composer.renderTarget2` value. We can now use the `renderScene` variable
    as input for our other composers without having to render the scene from scratch.
    Let's revisit `THREE.FilmPass` first and see how we can use `THREE.TexturePass`
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: Using THREE.FilmPass to create a TV-like effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already looked at how to create `THREE.FilmPass` in the first section of
    this chapter, so let''s see how to use this effect together with `THREE.TexturePass`
    from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The only step you need to take to use `THREE.TexturePass` is to add it as the
    first pass in your composer. Next, we can just add `THREE.FilmPass`, and the effect
    is applied. `THREE.FilmPass` itself takes four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `noiseIntensity` | This property allows you to control how grainy the scene
    looks. |'
  prefs: []
  type: TYPE_TB
- en: '| `scanlinesIntensity` | `THREE.FilmPass` adds a number of scanlines to the
    scene. With this property, you can define how prominently these scanlines are
    shown. |'
  prefs: []
  type: TYPE_TB
- en: '| `scanLinesCount` | The number of scanlines that are shown can be controlled
    with this property. |'
  prefs: []
  type: TYPE_TB
- en: '| `grayscale` | If this is set to `true`, the output will be converted to grayscale.
    |'
  prefs: []
  type: TYPE_TB
- en: 'There are actually two ways you can pass in these parameters. In this example,
    we passed them in as arguments to the constructor, but you can also set them directly,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this approach, we use the `uniforms` property, which is used to communicate
    directly with WebGL. In the section where we talk about creating a custom shader
    later in this chapter, we'll go a bit deeper into `uniforms`; for now, all you
    need to know is that this way, you can directly update the configuration of postprocessing
    passes and shaders and directly see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a bloom effect to the scene with THREE.BloomPass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The effect you see in the upper-left corner is called the bloom effect. When
    you apply the bloom effect, the bright areas of a scene will be made more prominent
    and *bleed* into the darker areas. The code to create `THREE.BloomPass` is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this with `THREE.EffectComposer`, which we used with `THREE.FilmPass`,
    you'll notice that we add an additional pass, `effectCopy`. This step, which we
    also used for the normal output, doesn't add any special effect but just copies
    the output from the last pass to the screen. We need to add this step since `THREE.BloomPass`
    can't render directly to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the properties you can set on `THREE.BloomPass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Strength` | This is the strength of the bloom effect. The higher this is,
    the more bright the brighter areas are and the more they "bleed" to the darker
    areas. |'
  prefs: []
  type: TYPE_TB
- en: '| `kernelSize` | This property controls the offset of the bloom effect. |'
  prefs: []
  type: TYPE_TB
- en: '| `sigma` | With the `sigma` property, you can control the sharpness of the
    bloom effect. The higher the value, the more blurred the bloom effect looks. |'
  prefs: []
  type: TYPE_TB
- en: '| `Resolution` | The `Resolution` property defines how precisely the bloom
    effect is created. If you make this too low, the result will look blocky. |'
  prefs: []
  type: TYPE_TB
- en: 'A better way to understand these properties is to just experiment with them
    using the previously mentioned example, `02-post-processing-simple`. The following
    screenshot shows the bloom effect with a high kernel and sigma size and low strength:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a bloom effect to the scene with THREE.BloomPass](img/2215OS_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last of the simple effects we'll have a look at is `THREE.DotScreenPass`.
  prefs: []
  type: TYPE_NORMAL
- en: Output the scene as a set of dots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `THREE.DotScreenPass` is very similar to using `THREE.BloomPass`. We
    just saw `THREE.BloomPass` in action. Now let''s see the code for `THREE.DotScreenPass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this effect, we once again have to add `effectCopy` to output the result
    to the screen. `THREE.DotScreenPass` can also be configured with a number of properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `center` | With the `center` property, you can fine-tune the way the dots
    are offset. |'
  prefs: []
  type: TYPE_TB
- en: '| `angle` | The dots are aligned in a certain manner. With the `angle` properties,
    you can change this alignment. |'
  prefs: []
  type: TYPE_TB
- en: '| `Scale` | With this, we can set the size of the dots to use. The lower the
    `scale`, the larger the dots. |'
  prefs: []
  type: TYPE_TB
- en: What applies to the other shaders also applies to this shader. It's much easier
    to get the right settings with experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Output the scene as a set of dots](img/2215OS_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Showing the output of multiple renderers on the same screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section doesn''t go into the details of how to use postprocessing effects,
    but explains how to get the output of all four `THREE.EffectComposer` instances
    on the same screen. First, let''s look at the render loop used for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice here is that we set the `webGLRenderer.autoClear`
    property to `false` and then explicitly call the `clear()` function. If we don't
    do this each time we call the `render()` function on a composer, the previously
    rendered scenes will be cleared. With this approach, we only clear everything
    at the beginning of our render loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid all our composers rendering in the same space, we set the viewport
    of `webGLRenderer`, which is used by our composers, to a different part of the
    screen. This function takes four arguments: `x`, `y`, `width`, and `height`. As
    you can see in the code sample, we use this function to divide the screen into
    four areas and make the composers render to their individual area. Note that you
    can also use this approach with multiple scenes, cameras, and `WebGLRenderer`
    if you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table at the beginning of this section, we also mentioned `THREE.GlitchPass`.
    With this render pass, you can add a kind of electronic glitch effect to your
    scenes. This effect is just as easy to use as the other ones you''ve seen until
    now. To use it, first include the following two files in your HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `THREE.GlitchPass` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a scene where the result is rendered normally except that at
    random intervals, a glitch occurs, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the output of multiple renderers on the same screen](img/2215OS_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Until now, we've only chained a couple of simple passes. In the next example,
    we'll configure a more complex `THREE.EffectComposer` and use masks to apply effects
    to a part of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced EffectComposer flows using masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we applied the postprocessing pass to the complete
    screen. Three.js, however, also has the ability to only apply passes to a specific
    area. In this section, we''re going to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a scene to serve as a background image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a scene containing a sphere that looks like Earth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a scene containing a sphere that looks like Mars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `EffectComposer`, which renders these three scenes into a single image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply a *colorify* effect to the sphere rendered as Mars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply a sepia effect to the sphere rendered as Earth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This might sound complex, but is actually surprisingly easy to accomplish.
    First, let''s look at the result we''re aiming for in the `03-post-processing-masks.html`
    example. The following screenshot shows the result of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced EffectComposer flows using masks](img/2215OS_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we need to do is set up the various scenes we''ll be rendering,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the Earth and Mars spheres, we just create the spheres with the correct
    material and textures and add them to their specific scenes, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We also need to add some lights to the scene just as we would for a normal scene,
    but we won't show that here (see [Chapter 3](ch03.html "Chapter 3. Working with
    the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*, for more details). The only thing to remember
    is that a light cannot be added to different scenes, so you need to create separate
    lights for both scenes. That's all the setting up we need to do for these two
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the background image, we create `THREE.OrthoGraphicCamera`. Remember from
    [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"),
    *Basic Components That Make Up a Three.js Scene*, that the size of objects in
    the orthographic projection doesn''t depend on the distance from the camera, so
    this also provides a good way to create fixed backgrounds. Here''s how we create
    `THREE.OrthoGraphicCamera`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We won't go into too much detail for this part, but we have to take a couple
    of steps to create a background image. First, we create a material from our background
    image, and we apply this material to a simple plane. Next, we add this plane to
    the scene and scale it to exactly fill the complete screen. So, when we render
    this scene with this camera, our background image is shown stretched to the width
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now got our three scenes, and we can start to set up our passes and
    `THREE.EffectComposer`. Let''s start by looking at the complete chain of passes,
    after which we''ll look at the individual passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with masks, we need to create `THREE.EffectComposer` in a different
    manner. In this case, we need to create a new `THREE.WebGLRenderTarget` and set
    the `stencilBuffer` property of the internally used render targets to `true`.
    A stencil buffer is a special type of buffer and is used to limit the area of
    rendering. So, by enabling the stencil buffer, we can use our masks. First, let''s
    look at the first three passes that are added. These three passes render the background,
    the Earth scene, and the Mars scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing new here except that we set the `clear` property of two of
    these passes to `false`. If we don''t do this, we''ll only see the output from
    `renderPass2` since it will clear everything before it starts rendering. If you
    look back at the code for `THREE.EffectComposer`, the next three passes are `marsMask`,
    `effectColorify`, and `clearMask`. First, we''ll look at how these three passes
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first of these three passes is `THREE.MaskPass`. When creating `THREE.MaskPass`,
    you pass in a scene and a camera just as you did for `THREE.RenderPass`. `THREE.MaskPass`
    will render this scene internally, but instead of showing this on screen, it uses
    this information to create a mask. When `THREE.MaskPass` is added to `THREE.EffectComposer`,
    all the subsequent passes will only be applied to the mask defined by `THREE.MaskPass`,
    until `THREE.ClearMaskPass` is encountered. In this example, this means that the
    `effectColorify` pass, which adds a blue glow, is only applied to the objects
    rendered in `sceneMars`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the same approach to apply a sepia filter on the Earth object. We first
    create a mask based on the Earth scene and use this mask in `THREE.EffectComposer`.
    After `THREE.MaskPass`, we add the effect we want to apply (`effectSepia` in this
    case), and once we're done with that, we add `THREE.ClearMaskPass` to remove the
    mask. The last step for this specific `THREE.EffectComposer` is one we've already
    seen. We need to copy the final result to the screen, and we once again use the
    `effectCopy` pass for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one additional property that''s interesting when working with `THREE.MaskPass,`
    and that''s the `inverse` property. If this property is set to `true`, the mask
    is inversed. In other words, the effect is applied to everything but the scene
    passed into `THREE.MaskPass`. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced EffectComposer flows using masks](img/2215OS_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Until now, we've used standard passes provided by Three.js for our effects.
    Three.js also provides `THREE.ShaderPass`, which can be used for custom effects
    and comes with a large number of shaders you can use and experiment with.
  prefs: []
  type: TYPE_NORMAL
- en: Using THREE.ShaderPass for custom effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.ShaderPass`, we can apply a large number of additional effects
    to our scene by passing in a custom shader. This section is divided into three
    parts. First, we''ll look at the following set of simple shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.MirrorShader` | This creates a mirror effect for part of the screen.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.HueSaturationShader` | This allows you to change the *hue* and *saturation*
    of the colors. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.VignetteShader` | This applies a vignette effect. This effect shows
    dark borders around the center of the image. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ColorCorrectionShader` | With this shader, you can change the color
    distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.RGBShiftShader` | This shader separates the red, green, and blue components
    of a color. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.BrightnessContrastShader` | This changes the brightness and contrast
    of an image. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ColorifyShader` | This applies a color overlay to the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.SepiaShader` | This creates a sepia-like effect on the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.KaleidoShader` | This adds a kaleidoscope effect to the scene that
    provides radial reflection around the center of the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LuminosityShader` | This provides a luminosity effect where the luminosity
    of the scene is shown. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.TechnicolorShader` | This simulates the effect of two-strip technicolor
    that can be seen in older movies. |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we''ll look at shaders that provide a couple of blur-related effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader` | These apply
    a blur effect to the complete scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.HorizontalTiltShiftShader` and `THREE.VerticalTiltShiftShader` | These
    recreate the *tilt shift* effect. With the tilt shift effect, it is possible to
    create scenes that look like a miniature by making sure only part of the image
    is sharp. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.TriangleBlurShader` | This applies a blur effect using a triangle-based
    approach. |'
  prefs: []
  type: TYPE_TB
- en: 'And finally, we''ll look at a few shaders that provide advanced effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.BleachBypassShader` | This creates a *bleach bypass* effect. With
    this effect, a silver-like overlay will be applied to the image. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.EdgeShader` | This shader can be used to detect the sharp edges in
    an image and highlight them. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.FXAAShader` | This shader applies an anti-aliasing effect during the
    postprocessing phase. Use this if applying anti-aliasing during rendering is too
    expensive. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.FocusShader` | This is a simple shader that results in a sharply rendered
    center area and blurring along its borders. |'
  prefs: []
  type: TYPE_TB
- en: We won't go into the details of all the shaders since if you've seen how one
    works, you pretty much know how the others work. In the following sections, we'll
    highlight a couple of interesting ones. You can experiment with the others using
    the interactive examples provided for each section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three.js also provides two advanced postprocessing effects that allow you to
    apply a *bokeh* effect to your scene. A bokeh effect provides a blur effect to
    part of the scene while rendering your main subject very sharply. Three.js provides
    `THREE.BrokerPass`, which you can use for this, or `THREE.BokehShader2` and `THREE.DOFMipMapShader`,
    which you can use together with `THREE.ShaderPass`. An example of these shaders
    in action can be found on the Three.js website at [http://threejs.org/examples/webgl_postprocessing_dof2.html](http://threejs.org/examples/webgl_postprocessing_dof2.html)
    and [http://threejs.org/examples/webgl_postprocessing_dof.html](http://threejs.org/examples/webgl_postprocessing_dof.html).
  prefs: []
  type: TYPE_NORMAL
- en: We start with a couple of the simple shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Simple shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To experiment with the basic shaders, we''ve created an example where you can
    play around with the shaders and see the effect directly in the scene. You can
    find this example in `04-shaderpass-simple.html`. The following screenshot shows
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple shaders](img/2215OS_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the menu in the top-right corner, you can select the specific shader you
    want to apply, and with the various drop-down menus, you can set the properties
    of the shader you''ve selected. For instance, the following screenshot shows `RGBShiftShader`
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple shaders](img/2215OS_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you change one of the properties of a shader, the result is updated directly.
    For this example, we set the changed value directly on the shader. For instance,
    when values for `RGBShiftShader` have changed, we update the shader like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a couple of other shaders. The following image shows the result
    of `VignetteShader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple shaders](img/2215OS_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`MirrorShader` has the following effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple shaders](img/2215OS_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With postprocessing, we can also apply extreme effects. A good example of this
    is `THREE.KaleidoShader`. If you select this shader from the menu in the top-right
    corner, you''ll see the following effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple shaders](img/2215OS_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's enough for the simple shaders. As you can see, they are very versatile
    and can create very interesting-looking effects. In this example, we applied a
    single shader each time, but you can add as many `THREE.ShaderPass` steps to `THREE.EffectComposer`
    as you like.
  prefs: []
  type: TYPE_NORMAL
- en: Blurring shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we won''t dive into the code; we''ll just show you the results
    from the various blur shaders. You can experiment with these using the `05-shaderpass-blur.html`
    example. The following scene is blurred with `HorizontalBlurShader` and `VerticalBlurShader`,
    both of which you will learn about in the following paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blurring shaders](img/2215OS_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image shows `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader`.
    You can see the effect is a blurred scene. Besides these two blur effects, Three.js
    provides an additional shader that blurs an image, `THREE.TriangleShader`, which
    is shown here. For instance, you could use this shader to depict motion blur,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blurring shaders](img/2215OS_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last blur-like effect is provided by `THREE.HorizontalTiltShiftShader`
    and `THREE.VerticalTiltShiftShader`. This shader doesn''t blur the complete scene,
    but only a small area. This provides an effect called *tilt shift*. This is often
    used to create miniature-like scenes from normal photographs. The following image
    shows this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blurring shaders](img/2215OS_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Advanced shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the advanced shaders, we''ll do what we did for the previous blur-shaders.
    We''ll just show you the output of the shaders. For details on how to configure
    them, look at the `06-shaderpass-advanced.html` example. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced shaders](img/2215OS_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example shows `THREE.EdgeShader`. With this shader, you can detect
    the edges of objects in your scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next shader is `THREE.FocusShader`. This shader only renders the center
    of the screen in focus, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced shaders](img/2215OS_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Until now, we've only used shaders that are provided by Three.js. However, it's
    also very easy to create shaders yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom postprocessing shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to create a custom shader that you can use
    in postprocessing. We'll create two different shaders. The first one will convert
    the current image into a grayscale image, and the second one will convert the
    image into an 8-bit image by reducing the number of colors that are available.
    Note that creating vertex and fragment shaders is a very broad subject. In this
    section, we only touch the surface of what can be done by these shaders and how
    they work. For more in-depth information, you can find the WebGL specification
    at [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/). An additional
    good resource full of examples is Shadertoy at [https://www.shadertoy.com/](https://www.shadertoy.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Custom grayscale shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a custom shader for Three.js (and also for other WebGL libraries),
    you need to implement two components: a vertex shader and a fragment shader. The
    vertex shader can be used to change the position of individual vertices, and the
    fragment shader is used to determine the color of individual pixels. For a postprocessing
    shader, we only need to implement a fragment shader, and we can keep the default
    vertex shader provided by Three.js. An important point to make before looking
    at the code is that GPUs usually support multiple shader pipelines. This means
    that in the vertex shaders step, multiple shaders can run in parallel—something
    that goes for the fragment shaders step as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the complete source code for the shader that applies
    a grayscale effect to our image (`custom-shader.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, this isn't JavaScript. When you write shaders,
    you write them in the **OpenGL Shading Language** (**GLSL**), which looks a lot
    like the C programming language. More information on GLSL can be found at [http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at this vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For postprocessing, this shader doesn't really need to do anything. The code
    you see above is the standard way Three.js implements a vertex shader. It uses
    `projectionMatrix`, which is the projection from the camera, together with `modelViewMatrix`,
    which maps an object's position into the world position, to determine where to
    render an object on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For postprocessing, the only interesting thing in this piece of code is that
    the `uv` value, which indicates which texel to read from a texture, is passed
    on to the fragment shader using the "`varying` `vec2` `vUv`" variable. We will
    use the `vUV` value to get the correct pixel to work on in the fragment shader.
    Let''s look at the fragment shader and see what the code is doing. We start with
    the following variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see four instances of the `uniforms` property. The instances of the
    `uniforms` property have values that are passed in from JavaScript to the shader
    and which are the same for each fragment that is processed. In this case, we pass
    in three floats, identified by type `f` (which are used to determine the ratio
    of a color to include in the final grayscale image), and a texture (`tDiffuse`)
    is passed in, identified by type `t`. This texture contains the image from the
    previous pass from `THREE.EffectComposer`. Three.js makes sure it gets passed
    correctly to this shader, and we can set the other instances of the uniforms property
    ourselves from JavaScript. Before we can use these uniforms from JavaScript, we
    have to define which `uniforms` property is available for this shader. This is
    done like this, at the top of the shader file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can receive configuration parameters from Three.js and have
    received the image we want to modify. Let''s look at the code that will convert
    each pixel to a gray pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What happens here is that we get the correct pixel from the passed-in texture.
    We do this by using the `texture2D` function, where we pass in our current image
    (`tDiffuse`) and the location of the pixel (`vUv`) we want to analyze. The result
    is a texel (a pixel from a texture) that contains a color and an opacity (`texel.w`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `r`, `g`, and `b` properties of this texel to calculate a
    gray value. This gray value is set to the `gl_FragColor` variable, which is eventually
    shown on screen. And with that, we''ve got our own custom shader. Using this shader
    is just like the other shaders. First, we just need to set up `THREE.EffectComposer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `composer.render(delta)` in the render loop. If we want to change the
    properties of this shader at runtime, we can just update the `uniforms` property
    we''ve defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen in `07-shaderpass-custom.html`. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom grayscale shader](img/2215OS_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's create another custom shader. This time, we'll reduce the 24-bit output
    to a lower bit count.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom bit shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, colors are represented as a 24-bit value, which gives us about 16
    million different colors. In the early days of computing, this wasn't possible,
    and colors where often represented as 8- or 16-bit colors. With this shader, we'll
    automatically transform our 24-bit output to a color depth of 8 bits (or anything
    you want).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it hasn''t changed with regard to our previous example, we''ll skip the
    vertex shader and directly list the instances of the `uniforms` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the fragment shader itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We define two instances of the `uniforms` property that can be used to configure
    this shader. The first one is the one Three.js uses to pass in the current screen,
    and the second one is defined by us as an integer (`type:` `"i"`) and serves as
    the color depth we want to render the result in. The code itself is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: We first get `texel` from the texture and `tDiffuse` based on the passed-in
    `vUv` location of the pixel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We calculate the number of colors we can have based on the `bitSize` property
    by calculating 2 to the power of `bitSize` (`pow(float(bitSize),2.0))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we calculate the new value of the color of `texel` by multiplying the
    value with `n`, rounding it off, `(floor(texel.r*n))`, and dividing it again by
    `n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is set to `gl_FragColor` (red, green, and blue values and the opacity)
    and shown on screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view the result for this custom shader in the same example as our previous
    custom shader, `07-shaderpass-custom.html`. The following screenshot shows this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom bit shader](img/2215OS_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it for this chapter on postprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about a lot of different postprocessing options in this chapter. As
    you saw, creating `THREE.EffectComposer` and chaining passes together is actually
    very easy. You just have to keep in mind a few things. Not all passes output to
    the screen. If you want to output to the screen, you can always use `THREE.ShaderPass`
    with `THREE.CopyShader`. The sequence in which you add passes to a composer is
    important. Effects are applied in that sequence. If you want to reuse the result
    from a specific `THREE.EffectComposer` instance, you can do this by using `THREE.TexturePass`.
    When you have more than one `THREE.RenderPass` in your `THREE.EffectComposer`,
    make sure to set the `clear` property to `false`. If not, you'll only see the
    output from the last `THREE.RenderPass` step. If you only want to apply an effect
    to a specific object, you can use `THREE.MaskPass`. When you're done with the
    mask, clear the mask with `THREE.ClearMaskPass`. Besides the standard passes provided
    by Three.js, there are also a large number of standard shaders available. You
    can use these together with `THREE.ShaderPass`. Creating custom shaders for postprocessing
    is very easy using the standard approach from Three.js. You only need to create
    a fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we pretty much covered everything there is to know about Three.js.
    For the next chapter, the last one, we'll look at a library called **Physijs**
    that you can use to extend Three.js with physics and apply collisions, gravity,
    and constraints.
  prefs: []
  type: TYPE_NORMAL
