- en: Chapter 5. Coffee with Strangers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will write an API that allows users to go for a coffee!
    This comprises of a simple yet extendable user matching system.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we'll just ask the user to enter their name and e-mail, which is
    stored on MongoDB. Whenever we can match these with the nearest other user, e-mails
    are sent to both sides and then it's coffee time. After we set up the base, it's
    time to make sure we keep a record of the matches and avoid duplicates from happening
    for a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after, let's make ourselves ready to go global and take into account their
    geo positioning.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming everything goes well (which is a mistake), we are validated. So it's
    time to refactor to a more maintainable architecture, where the pairing becomes
    a service by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's allow our users to rate how their meeting was and tell us whether
    it was a successful meeting or not in real-world applications, the usage of user
    generated feedback is invaluable!
  prefs: []
  type: TYPE_NORMAL
- en: We expect that this sort of application structure will offer the reader inspiration
    to create real world matching applications.
  prefs: []
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into actual code, we want to provide a heads up on the structure
    for the code in this chapter, which is a bit different than before, and we hope
    it adds another view to structure code for Express and Node.js in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some may call it a **Factory pattern**; it consists of wrapping each of the
    file''s code with a function that can be used to configure or test it. While this
    requires a bit more of scaffolding, it frees our code from depending on a static
    state. It will often look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A corollary of this structure is that each invocation of this file will have
    its own state, exactly like the instance of a class, except we don't depend on
    this, but the scope that never goes missing.
  prefs: []
  type: TYPE_NORMAL
- en: Going a bit further, we'll try centralizing the structure of the pieces per
    folder, each with a respective `index.js`, the main responsibilities of which
    are to initialize instances when needed, keep references to dependencies that
    will be passed down, and return only public methods.
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by defining the first routes we need and how we want them to behave
    and simple logical steps building what's strictly essential first, in a TDD style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing is that we need users to be able to register; the smallest
    test case to register our user is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assuming you have Mocha installed with `npm i -g mocha`, execute `mocha`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See 404? Good start! Now let's expand and create a file, `src/route/index.js`,
    which will declare all the routes known to the app. It uses controllers that handle
    each concern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with `user.js`, which implements a create action, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This amount of code should be enough to make the tests pass with Mocha.![Defining
    routes](img/0818_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this app, we'll have all route definitions in one place, that is, `routes/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, we know that the testing setup works. Next, let's move onto persistence
    and some business logic!
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding some diversity to the libraries, let's experiment with Mongojs ([https://github.com/mafintosh/mongojs](https://github.com/mafintosh/mongojs)),
    a simple library for MongoDB that aims to be as close as possible to the native
    client.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let's create a small config file, `./config.js`, to store
    all the common data and just return a simple object with relevant configurations
    for each environment. For now let's just make sure we have a URLin a format accepted
    by Mongojs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This file should be able to hold all global configs for the app. It ensures
    we also have different settings depending on the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This file needs to be in `app.js`, a central place to initialize and gather
    dependencies, and it will be passed to our DB, which then returns public methods.
    Let''s see that happening in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our models, let's define one file to rule them all s`rc/models/index.js`
    with its main responsibilities being to instantiate the db and expose public methods
    to other modules so that storage details stay encapsulated, keeping the code clean
    and decoupled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our first model, `user`, has the ability to create one user. Notice that we
    are not making any validations in this model to keep things simple. Don't go to
    production without having the models double-checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s update our `user.js` route to make use of our DB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this simple change, we should have a user created in our DB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's open Robomongo ([http://robomongo.org/](http://robomongo.org/)) to see
    what user data was created; it's super handy to lookup what data we have in MongoDB
    no matter what library we use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persisting data](img/0818_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open a parenthesis here and talk about the `if(err) return next(err);`.command
    This is a pattern that is used to abstract error handling in a single action that
    is supposed to be treated in Express further down the stack, via `app.use`.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things neat, we can abstract error handling to a file of its own where
    we will define specific handlers for each type of error `src/routes/errorHandler.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's define a `catchAll()` method for now. Express will know the type of use
    for this function because its functionality is 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, it''s activated in `routes/index.js`. error handling should be the
    very last middleware(s):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Naive pairing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest pairing system we can implement is to simply lookup if there is
    another user available without a pair whenever someone signs up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do so, we''ll start a new collection and model: Meeting, which
    will be the base matching structure we''ll be expanding on. The fundamental idea
    here is that each document will represent a meeting; either it''s in the request
    phase, already set or occurred, finally will also store the feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll be elaborating and defining the structure for it as it goes. For an initial
    implementation, let's run the scheduling logic right when the user decides to
    be matched. The strategy will be to look for a meeting document, where only the
    first user is set, and update it. In case there is no document like that, let's
    create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of race conditions that might kick in, which we certainly
    want to avoid. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user who's trying to find someone to schedule gets scheduled in the middle
    of the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user who's available to be scheduled is selected but then reserved by someone
    else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lucky MongoDB offers the `findAndModify()` method, which can find and update
    on a single document automatically, while also returning the updated document.
    Keep in mind that it also offers an `update()` method to update multiple methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out the docs from the following link: [http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method](http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with a new collection, `Meeting`, where we will keep track
    of a user''s interest in finding a pair as well as keeping track of meetings as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This document will contain all of the user's info up to that point in time,
    so we can use it as a history, as well as use its contents to send e-mails and
    setup reviews.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what the code looks like in `src/models/meeting.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of a successful pairing, `user2` would be set in the `Meeting` object
    to meet the following day at noon, as you can see on the attribute `at`, which
    we set via the `aux` `arrangeTime()` function and the lightweight library moment.js
    ([http://momentjs.com/](http://momentjs.com/)). It's amazing to deal with dates
    in a super readable way. It is recommended that you take a look and become more
    familiar with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, notice `new: true` as a parameter. It ensures that MongoDB returns the
    updated version of the object, so we don''t need to duplicate the logic in the
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: The new object `Meeting` needs to be created, as it carries the information
    of the users at that point in time and can be used to compose the emails/notification
    for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good opportunity to define some basic structure for our tests that
    will follow a pattern of making several calls to the endpoints and asserting the
    response. There is a thorough explanation about the decisions to implement tests
    immediately, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: (Source:git checkout e4fbf672d409482028de7c7427eab769ab0a20d2)
  prefs: []
  type: TYPE_NORMAL
- en: '![Naive pairing](img/0818_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notes about tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Mocha, a test is much like any javascript file and is executed as
    expected, allowing for any sort of regular Node.js require as you would do usually.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe()` method is the context on which our tests execute; in our case,
    it's a full run of a certain functionality. The `before()` method will run once;
    in this case, our logic is set to clean up all of our MongoDB collections.
  prefs: []
  type: TYPE_NORMAL
- en: It stands for a simple expectation to be fulfilled. It will run in the same
    order it's declared, and we will try to make the assertions small and predictable
    as far as possible. Each of these functions defines steps and in this case, because
    we are doing end-to-end tests, we make requests to the API and check the results,
    and sometimes save it to variables that are used later to assert.
  prefs: []
  type: TYPE_NORMAL
- en: There are advices that say that tests shouldn't be dependent on the previous
    state, but those don't usually test the application flow, rather, individual portions
    of logic. For this particular test scenario, in case of a failure, it's important
    to interpret the error from the first `it` that fails; fixing it will likely fix
    errors after it. You can configure Mocha to stop at the first error by using the
    `-b` flag.
  prefs: []
  type: TYPE_NORMAL
- en: While testing, the most important point to make sense is that our test cases
    should make sure all of the expected cases are checked, and bad behaviors don't
    happen. We can never expect to predict everything that may go wrong of course,
    but it's still our duty to test as many points as we are certain about common
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Considering user history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users will probably want to always be paired to meet new people, so we have
    to avoid repetitive meetings. How should we handle this?
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to allow for a method to set up new meetings. Think of it as
    a button in an app that would trigger a request to the route `POST/meeting/new`.
  prefs: []
  type: TYPE_NORMAL
- en: This endpoint will reply with the status `200` when the request is allowed and
    a pair is found, or if there is no pair but they are now attached to a `meeting`
    object and can now be matched with another user; `412` if the user is already
    scheduled in another meeting and `400` in case the expected e-mail of the user
    isn't sent; in this case, it can't be fulfilled because the user wasn't specified.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usage of status codes is somewhat subjective, (see a more comprehensive
    list on Wikipedia at [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)).
    However, having distinct responses is important so that the client can display
    meaningful messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement an Express.js middleware, that requires an e-mail for all requests
    that are made on behalf of the user. It should also load their document and attach
    it to `res.locals`, which can be used in subsequent routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `src/routes/index.js` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this middleware is to stop and return an error message for every
    request that doesn't have a user email. It's a validation that would usually require
    a username and password or a secret token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a small but important test suite for this middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to get me without email and fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a valid user; it succeeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to get me with another email; it fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access me with the email we registered and it works!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a way to load the user who's making the request, let's go back
    to the goal of matching people without repetition. As a pre-condition, their past
    meeting time has to be in the past already, otherwise it returns a `412` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to schedule a meeting for our users but any scheduled meeting will
    be set for tomorrow, how can we test it? Meet timekeeper ([https://github.com/vesln/timekeeper](https://github.com/vesln/timekeeper)),
    library with a simple interface to alter the system dates in Node.js; this is
    especially useful for tests. Look closely for the snippet of this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It's of vital importance to set an `after` hook to reset timekeeper so that
    the dates go back to normal after the scenario is finished in either success or
    failure; otherwise, there is a chance it will alter the results of other tests.
    It's also worth checking how date manipulation is made easy with `moment()` method
    and once you use `timekeeper.travel() function`, the time is warped to that date.
    For all Node.js knows, the new warped time is the actual time (although it does
    not affect any other applications). We can also switch it back and forth as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Meeting` method to perform this check on our user (defined at `models/meeting.js`)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `$or` operator is necessary because we don't know whether the user we are
    looking for is going to be `user1` or `user2`, so we take advantage of the query
    capabilities of MongoDB that can look inside objects in a document and match the
    `email` as a `String`, and the `at` field as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our newly created `src/routes/meeting.js`, is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Moving on, we'll define a very important helper function that finds previous
    meetings involving the user who's making the request and returns the emails of
    everyone they have been matched with, so we can avoid matching those two users
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Helper functions like this are super useful to keep the code understandable
    when dealing with complicated pieces of logic. As a rule of thumb, always separate
    into smaller functions when a chunk of code can be abstracted into a concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The key to `userMatchHistory` object; is through the MongoDB `$nin` operator,
    which performs a match when the element doesn't match what's in the array. The
    matching logic follows the very same logic we had in naive pairing.
  prefs: []
  type: TYPE_NORMAL
- en: In our `Meeting` model, we removed our previous `pairNaive` method with the
    `pair` method, which does similar, but first build a list of the previous matches
    to ensure we don't match those again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing for distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use a down-to-earth geolocation approach (ah! I'm so funny) to the match.
    We have to be realistic. Our service was born in Smallville but it's going global
    and we can't match people who are too far apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our meetings are arranged free of racing conditions on the `Meeting`
    collection and we would like to keep it that way, let''s adapt our existing `pair`
    method to incorporate the user''s location. We can assume that at registration,
    they will supply their location (or we could also easily update the meeting document
    once they provide the location). In our existing strategy, we have one user who
    creates a meeting document; in this case, let''s also set their location, so the
    next user looking for a match will have to be in a similar location as an additional
    constraint, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `Meeting` collection now has `location1` indexed as `2dsphere`. The geoquery
    for this field can easily be integrated with our previous query, using the operator
    `$nearSphere` to match geo positions in a sphere object. `$maxDistance` is the
    maximum radius for the match. It's expressed in meters and in this case, we intersect
    the coordinates with `Point`, which is a previously registered user. `7km` was
    chosen arbitrarily because it seems like a reasonable enough radius to meet someone.
  prefs: []
  type: TYPE_NORMAL
- en: If we changed `$maxDistance` to something considerably smaller, some of our
    tests would fail because matches wouldn't happen; see `test/meeting_near.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Clear DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user 1 in Santiago
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user 4 in Valparaiso
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether there is a match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user 2 in Santiago
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether there was a match between 1 and 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user 3 in Vancouver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether 3 has a match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user 5 in Valparaiso
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether there is a match between 4 & 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Source:git checkout 52e8f80b7fe3b9482ff27ea1bcc410270752a796)
  prefs: []
  type: TYPE_NORMAL
- en: E-mail follow up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users can now be matched. The meetings are unique and made between people that
    are nearby, which is awesome! There is no end to possible improvements on a matching
    system; so instead, lets now collect some data about how their meeting went!
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll send an email to each of the attendees, which will consist
    of a few simple options to promote engagement. Some of them are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It was awesome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was awful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meh…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My pair didn't show up!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those values are added to `src/models/meeting.js` as key-value pairs, which
    we can store for ratings and use them to communicate back to users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We could store these responses in the respective `meeting` object, associating
    it with the user who responded.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we'll rely primarily on the package `Nodemailer` ([https://github.com/andris9/Nodemailer](https://github.com/andris9/Nodemailer)).
    It is broadly used and offers support for a number of integrations, including
    transport providers and templates so we can make our e-mails dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the setup decision, as you probably realized Node.js & Express are
    free of conventions about how to set up your code because these apps may do very
    different things and there is no one-size-fits-all. Let's make mailing a concern
    of its own, as much as persistence and routes are separated concerns integrated
    into `src/app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The `src/mailer/index.js` will be our entry point and its main responsibility
    is to instantiate the `nodemailer` variable and provide public methods other files
    can refer to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to the test environment, we definitely don't want to be sending
    real e-mails, that's why we register the stub transport. For other environments,
    we decided to go with `Mailgun` but we could also go with any service that integrates
    via SMTP (remember to use Gmail since there is a risk of failing to send e-mails,
    as they have a bunch of heuristics to prevent spam).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to testing, this section is one of the harder ones to test, we
    will implement something very basic in `test/send_mail.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Add to `config.js`, and have the correspondent environment variables defined
    because it's not a good idea to keep our secrets in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When I disable the `test` environment, I can actually see the email in my inbox.
    Win! To make the service look better, let's experiment with some templates, which
    is what email-templates ([https://github.com/niftylettuce/node-email-templates](https://github.com/niftylettuce/node-email-templates))
    is all about.
  prefs: []
  type: TYPE_NORMAL
- en: It makes it easy to implement dynamic e-mails including packing the CSS inline;
    these are required to be inline by many e-mail clients.
  prefs: []
  type: TYPE_NORMAL
- en: On `src/mailer/followUp.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we send two identical emails so we get feedback from both users.
    There is a bit of complexity there that we will manage by using `async.parallel()`
    method. It allows us to start two asynchronous operations and callbacks (done)
    when both are completed. See [https://github.com/caolan/async#parallel](https://github.com/caolan/async#parallel).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual print of the email is created by two files, `src/mailer/templates/followup/followUp.html.swig`
    and `style.css`, which are combined and set via our transport solution, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can choose from many template solutions. swig ([http://paularmstrong.github.io/swig/docs/](http://paularmstrong.github.io/swig/docs/))
    comes with convenient helpers, makes it easy to work with lists, and has the familiar
    HTML visual. A bit of insight is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{string}}` is the general interpolating method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|` is for helpers (aka filters); you can use built-ins or define your own'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for k,v in obj` is a tag and works looping over key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![E-mail follow up](img/0818_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it came to the logic for the follow-up links, we made it really easy for
    the user to provide feedback; usually, the less friction, the better for outstanding
    UX. All they have to do is click on the link and their review is instantly recorded!
    In terms of Express.js, this means we have to set up a route that links all the
    piece of data together; in this case, in `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To have an endpoint that actually changes the data defined as a `GET` is an
    exception to HTTP & REST conventions, but the reason is that email clients will
    send the request as a `GET`; not a lot we can do about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method is defined at `src/routes/meeting.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method does quite a bit of checking and that's because there is a considerable
    amount of input that needs validation along with providing the appropriate response.
    First, we check whether the `feedback` provided is valid, since we are only taking
    quantitative data. `didMeetingHappened` returns `two` important pieces of info
    about the meeting; the ID may be completely wrong, or it might not have happened
    yet. Both scenarios should deliver different results. Finally, if everything looks
    good, we attempt to rate the meeting, which should work just fine and return some
    data to respond with and finish the request with an implied `200` status.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the preceding methods are available at `src/models/meeting.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The implementation method should be pretty readable. The `didMeetingHappened()`
    method looks for a maximum of one document with `_id`, where `user1` and `user2`
    are filled. When this document is found, we look at the `at` field and compare
    with the current time to check whether it already happened.
  prefs: []
  type: TYPE_NORMAL
- en: The rate is a bit longer but just as simple. We find the `meeting` object and
    figure out which user is being rated. Such feedback belonging to the opposite
    user is stored in an atomic operation, setting either field `user1reviewed` or
    `user2reviewed` with the key for the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: We have a thorough test suite implemented for this case, where we mind both
    success & failure cases. It can be used to check the emails by simply calling
    the test with `NODE_ENV=development mocha test/meeting_followup.js`, which then
    overrides the test environment with development and delivers emails to our provider,
    so we can see how it looks and fine-tune it.
  prefs: []
  type: TYPE_NORMAL
- en: Our test for this whole scenario is a bit long but we need to test several things!
  prefs: []
  type: TYPE_NORMAL
- en: Clean up DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the meeting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register user 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register user 2 at the same position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STest that non-existent meetings can't be reviewed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status 412 on meeting reviews that still didn't happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travel time two days ahead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send an email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking up a review that makes sense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User 1 should be able to review the meeting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User 2 should be able to review the meeting as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seems like we can now send emails and receive reviews, which is great, but how
    do we send the emails in a time-sensitive manner? A couple of minutes after the
    meeting has started, the emails should be sent to both parties.
  prefs: []
  type: TYPE_NORMAL
- en: (Source:git checkout 7f5303ef10bfa3d3bfb33469dea957f63e0ab1dc)
  prefs: []
  type: TYPE_NORMAL
- en: Periodical tasks with node-cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe you are familiar with cron ([http://en.wikipedia.org/wiki/Cron](http://en.wikipedia.org/wiki/Cron)).
    It's a Unix-based task scheduling system that makes running tasks easy. One problem
    with it is that it's linked to your platform, and it's not trivial to turn it
    on and off from code.
  prefs: []
  type: TYPE_NORMAL
- en: Meet node-cron ([https://github.com/ncb000gt/node-cron](https://github.com/ncb000gt/node-cron)).
    It's basically the same task scheduler but it runs directly from your Node application,
    so as long as it is up, your jobs should run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our strategy is simple: Periodically select all meetings that need mailing,
    call our mailer with each of these meetings, and then mark it as emailed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this app''s convention, let''s separate concerns into their own folders,
    starting with `src/tasks/index.js`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It needs to take `models` and `mailer` as parameters, which can be used inside
    tasks. `followupMail` is the single user defined for now because it''s all we
    need. The exported method `init` is what will kick start the cron job, the timer
    presenting respectively: `00` defined as the seconds, meaning it will run at second
    `00`, for every `*/15` minutes, any hour, any day of the month, any month, any
    day of the week. For the actual task, see `src/mailer/followUp.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It returns a function, which when executed, looks up all meeting documents that
    still need to be mailed and for each one, use `mailer.followUp` as we defined
    before and upon completion, mark each email as sent. Notice that fails here have
    nowhere to communicate and that's because it's an automated task. It's important
    for web servers to have meaningful log reporting, so in this case, the warning
    messages should be reported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this would require us to add two methods to `src/models/meeting.js`,
    which you should be able to easily make sense of by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For our final test, we'll be creating four users implying 2 meetings, travel
    2 days in the future and try sending the emails through the task, it should work
    and mark both emails as sent.
  prefs: []
  type: TYPE_NORMAL
- en: Clear DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register users 1, 2, 3, and 4 at the same location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travel time after the meeting is done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task should send an email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the emails were sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an API that can set up meetings between users taking
    into account their matching history and the pair of longitude and latitude, while
    providing them the chance to give feedback on how it went-essential information
    which can be used in many ways to further improve the algorithm!
  prefs: []
  type: TYPE_NORMAL
- en: We hope you learned about many interesting and practical concepts, such as making
    geo queries, testing time-sensitive code, sending e-mails with style, and tasks
    that run periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the technical bits, hope you had fun and perhaps were able to spark
    some insight on the framework behind match-making apps!
  prefs: []
  type: TYPE_NORMAL
- en: Next on, we'll see how `Koa.js` works by leveraging the power of generators,
    bringing the readability of synchronous code on top of the async features of Node.js.
  prefs: []
  type: TYPE_NORMAL
