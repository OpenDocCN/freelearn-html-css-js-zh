- en: Chapter 2. Understanding Ember.js Objects and Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having learned how to create a basic Ember.js application in the previous chapter,
    this chapter will introduce us to Ember.js objects, which are the foundation of
    the rest of the base classes. Therefore, most of the concepts discussed will be
    applied throughout the book. By the end of this chapter, we''ll be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create Ember.js objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define, get, and set object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register property change observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects in Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We all know how to define and create instances of function objects in JavaScript,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates instances of a defined `Point` object that has
    three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember.js uses JavaScript prototypes to simulate object-oriented features. More
    importantly, it introduces conveniences that enable easier inheritance and management
    of objects in the evented browser environment. A class, which is an object definition,
    is usually created by *extending* another user-defined or built-in class, typically
    `Ember.Object`. Classes have two methods, `create` and `extend`, which are used
    to create instances of objects and perform inheritance respectively. For example,
    the preceding code snippet would be implemented in Ember.js as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just created an Ember.js class that has three properties `x`, `y`,
    and `z`, and their corresponding log methods. To create a new instance of this
    class, we will call the `create()` method on the class, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go further and extend our `Point` class to form a new class using the
    `extend()` method. For example, we can define a `Vector` class that defines an
    `add()` method, which adds to a provided vector, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After extending the `Point` class to a `Vector` class in the example, we created
    two vectors named `vectorA` and `vectorB`, and finally composed them.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing object properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just seen how Ember.js objects are created. Did you notice how Ember.js
    object properties are accessed? Ember.js provides the `get` and `set` property
    accessor methods. Why not access these values directly? Well, these methods are
    used to recalculate values as well as notify any changes made when necessary.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties can also be read and set collectively using the `getProperties`
    and `setProperties` methods. This prevents Ember.js from unnecessarily making
    too many notifications about these changes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Defining class instance methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes can also define instance methods. These methods have a similar signature
    to object properties, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Ember.js provides the ability to reuse implementations of parent methods in
    extended classes by the use of the `_super()` method. For example, the following
    example reimplements and reuses the `logX` method in the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ember.js objects usually define a constructor method called `init()`, which
    is called on an instance creation. Any initializations should be done inside this
    method. It''s worth noting that the `_super()` method should always be called
    on any inherited methods such as `init()` to avoid losing parent implementations,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a computed property? A computed property is the one whose value is
    returned from a function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates a computed property `name` that returns the name
    of a movie instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply transformed a method into a computed property by chaining the `property()`
    function to it. The true power of computed properties comes from them being able
    to produce different values based on prespecified dependent properties. These
    dependent properties are usually passed as arguments to the `property()` function.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `name` property is always recomputed whenever
    a movie's `seriesNumber` and `year` change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computed properties can also have property dependencies of enumerable data.
    The `@each` helper can be used to set up computed properties on such kinds of
    properties. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a `country` object that has two `states`.
    We then defined a computed property, `stateNames` that returns an array of the
    state names. A change to any of the state names results in a recalculation of
    the property.
  prefs: []
  type: TYPE_NORMAL
- en: Defining property observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to computed properties, you can also set `observers` to properties.
    Observers are functions that get called when the properties they subscribe to
    change. They have the same signature as computed properties but use the `observers`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example defines a session class that sets up an observer that
    makes the user relogin as soon as the session expires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Observers have no strict naming convention, but most developers name observers
    by appending `DidChange` to the property that is being observed, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like computed properties, observers can also subscribe to an unlimited
    number of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `inMotion` property will be recalculated when either the `running`
    or `walking` property changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observers can also be set up and torn down using the `addObserver()` and `removeObserver()`
    methods respectively. These become handy when you want to manage observers yourself.
    For example, the preceding sample can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the `addObserver` method takes at least two
    arguments: the property to observe and the function to call whenever the property
    changes. In our example, we also tear down the observer listener by calling the
    `removeObserver` method. This method takes one argument, which is the property
    to unbind from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember.js also provides a way to pass the context to use in the `observer` function.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that observers only fire on property changes that occur
    after object initialization. An `on(''init'')` method can be applied to an observer
    to make it fire on changes that could occur during an object initialization. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The example defines two observers: `skippedDidChange` and `playedDidChange`,
    of which, only the latter is called after an object initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating property bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ember.js provides support for both one- and two-way bindings. A binding is
    a link between two properties of the same or different objects, such that they
    are always in sync. This means that an update to one of the properties results
    in the other property being updated to the new value. Bindings are defined in
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the two properties `property` and `otherProperty` always stay
    in sync. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `book` instance has an `author` property that
    binds to the created global author instance. Any changes made to the name of the
    author will be reflected in the bound book author property. Likewise, any changes
    made to the book''s author property will be propagated back to the global author
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of a two-way binding where an update to either property results
    in the other property being updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember.js also supports one-way bindings where updates are unidirectional. A
    property can subscribe to updates from a different property but will not update
    the latter if the former changes. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the book property changes will not affect the bound
    author's name property.
  prefs: []
  type: TYPE_NORMAL
- en: Using mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mixins are abstract definitions that define methods and properties that classes
    and objects can reuse. For example, consider these two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These two objects share a common function that can be abstracted into a mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Any number of mixins can be passed to objects or classes on creation or definition,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that mixins are always *created* and never *extended*.
    The example also showed that objects reusing mixins are always created using the
    `createWithMixins` method on instantiation and not the `create` method. However,
    classes still use the `extend` method when applying mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Reopening classes and instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to update class implementations without redefining
    them. This is usually necessary when we do not wish to extend built-in classes,
    but only want to update their implementations. Ember.js refers to this as reopening
    of classes and objects. Class methods and properties can be reimplemented using
    the `reopenClass` method, while instance methods and properties can be updated
    using the `reopen` method. It's however discouraged to change built-ins as they
    may change in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added an instance method, `purchase`, and two properties,
    `id` and `name` to the already defined `Book` class. We have also added a class
    method, `getById`, without extending the class.
  prefs: []
  type: TYPE_NORMAL
- en: Event subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of notifying changes in an application is through event subscription.
    This paradigm is used heavily in Node.js to channel messages and events across
    different components of an application. Ember.js provides the `Ember.Evented`
    mixin that can be used to serve archive this easily. For example, blocks in a
    board game can subscribe to instructions from an actuator as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The mixin provides five essential methods, two of which have been illustrated
    in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on`: This is used to subscribe to an event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off`: This is used to disable a subscription'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`one`: This is used to subscribe once to an event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trigger`: This is used to emit an event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has`: This is used to check if an event has been subscribed to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has focused on introducing Ember.js objects. We will use these
    objects extensively in the next chapter, where we will learn how state management
    is accomplished in Ember.js using routers. We will discuss how to construct routes
    and routers. That being said, you should have learned the following Ember.js object
    concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects and classes in Ember.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and setting object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining property observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating property bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reopening Ember.js classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing routes, which are one of these classes
    that are extended from `Ember.Object`.
  prefs: []
  type: TYPE_NORMAL
