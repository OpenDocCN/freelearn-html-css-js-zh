- en: Chapter 2. Understanding Ember.js Objects and Mixins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：理解 Ember.js 对象和混入
- en: 'Having learned how to create a basic Ember.js application in the previous chapter,
    this chapter will introduce us to Ember.js objects, which are the foundation of
    the rest of the base classes. Therefore, most of the concepts discussed will be
    applied throughout the book. By the end of this chapter, we''ll be able to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章学习了如何创建基本的 Ember.js 应用程序之后，本章将介绍 Ember.js 对象，这是其他基础类的基础。因此，本书中讨论的大部分概念将贯穿全书。到本章结束时，我们将能够：
- en: Create Ember.js objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Ember.js 对象
- en: Define, get, and set object properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义、获取和设置对象属性
- en: Define computed properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义计算属性
- en: Register property change observers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册属性变更观察者
- en: Use mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入
- en: Creating objects in Ember.js
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ember.js 中创建对象
- en: 'We all know how to define and create instances of function objects in JavaScript,
    as shown in the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道如何在 JavaScript 中定义和创建函数对象的实例，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding example creates instances of a defined `Point` object that has
    three methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了一个具有三个方法的定义的 `Point` 对象的实例。
- en: 'Ember.js uses JavaScript prototypes to simulate object-oriented features. More
    importantly, it introduces conveniences that enable easier inheritance and management
    of objects in the evented browser environment. A class, which is an object definition,
    is usually created by *extending* another user-defined or built-in class, typically
    `Ember.Object`. Classes have two methods, `create` and `extend`, which are used
    to create instances of objects and perform inheritance respectively. For example,
    the preceding code snippet would be implemented in Ember.js as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 使用 JavaScript 原型来模拟面向对象特性。更重要的是，它引入了便利性，使得在事件驱动的浏览器环境中更容易继承和管理对象。一个类，即对象定义，通常通过
    *扩展* 另一个用户定义的或内置的类创建，通常是 `Ember.Object`。类有两个方法，`create` 和 `extend`，分别用于创建对象实例和执行继承。例如，前面的代码片段在
    Ember.js 中的实现如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have just created an Ember.js class that has three properties `x`, `y`,
    and `z`, and their corresponding log methods. To create a new instance of this
    class, we will call the `create()` method on the class, as shown in the following
    example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个具有三个属性 `x`、`y` 和 `z` 以及它们相应的日志方法的 Ember.js 类。要创建这个类的新实例，我们将调用类上的 `create()`
    方法，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can go further and extend our `Point` class to form a new class using the
    `extend()` method. For example, we can define a `Vector` class that defines an
    `add()` method, which adds to a provided vector, as shown in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，通过使用 `extend()` 方法扩展我们的 `Point` 类来形成一个新的类。例如，我们可以定义一个 `Vector` 类，它定义了一个
    `add()` 方法，该方法向提供的向量中添加内容，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After extending the `Point` class to a `Vector` class in the example, we created
    two vectors named `vectorA` and `vectorB`, and finally composed them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中将 `Point` 类扩展为 `Vector` 类之后，我们创建了两个名为 `vectorA` 和 `vectorB` 的向量，并最终将它们组合在一起。
- en: Accessing object properties
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问对象属性
- en: 'We have just seen how Ember.js objects are created. Did you notice how Ember.js
    object properties are accessed? Ember.js provides the `get` and `set` property
    accessor methods. Why not access these values directly? Well, these methods are
    used to recalculate values as well as notify any changes made when necessary.
    For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了 Ember.js 对象是如何创建的。你注意到 Ember.js 对象属性是如何访问的吗？Ember.js 提供了 `get` 和 `set`
    属性访问器方法。为什么不直接访问这些值呢？嗯，这些方法用于重新计算值，并在必要时通知所做的任何更改。例如：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Properties can also be read and set collectively using the `getProperties`
    and `setProperties` methods. This prevents Ember.js from unnecessarily making
    too many notifications about these changes, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以通过 `getProperties` 和 `setProperties` 方法一起读取和设置。这可以防止 Ember.js 不必要地发出太多关于这些更改的通知，例如：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining class instance methods
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类实例方法
- en: 'Classes can also define instance methods. These methods have a similar signature
    to object properties, as shown in the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以定义实例方法。这些方法与对象属性的签名类似，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Ember.js provides the ability to reuse implementations of parent methods in
    extended classes by the use of the `_super()` method. For example, the following
    example reimplements and reuses the `logX` method in the `Point` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 通过使用 `_super()` 方法提供了在扩展类中重用父方法实现的能力。例如，以下示例重新实现了 `Point` 类中的 `logX`
    方法并重用它：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ember.js objects usually define a constructor method called `init()`, which
    is called on an instance creation. Any initializations should be done inside this
    method. It''s worth noting that the `_super()` method should always be called
    on any inherited methods such as `init()` to avoid losing parent implementations,
    for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 对象通常定义一个名为 `init()` 的构造方法，它在实例创建时被调用。任何初始化都应该在这个方法内完成。值得注意的是，应该始终在继承的方法（如
    `init()`）上调用 `_super()` 方法，以避免丢失父实现，例如：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining computed properties
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义计算属性
- en: 'What is a computed property? A computed property is the one whose value is
    returned from a function. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是计算属性？计算属性是指其值由函数返回的属性。例如：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example creates a computed property `name` that returns the name
    of a movie instance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了一个计算属性 `name`，它返回电影实例的名称。
- en: 'We simply transformed a method into a computed property by chaining the `property()`
    function to it. The true power of computed properties comes from them being able
    to produce different values based on prespecified dependent properties. These
    dependent properties are usually passed as arguments to the `property()` function.
    For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过将 `property()` 函数链接到它来将一个方法转换为一个计算属性。计算属性的真正力量在于它们能够根据预定义的依赖属性产生不同的值。这些依赖属性通常作为参数传递给
    `property()` 函数。例如：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the `name` property is always recomputed whenever
    a movie's `seriesNumber` and `year` change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述示例中，每当电影的 `seriesNumber` 和 `year` 发生变化时，`name` 属性都会被重新计算。
- en: 'Computed properties can also have property dependencies of enumerable data.
    The `@each` helper can be used to set up computed properties on such kinds of
    properties. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性也可以有可枚举数据的属性依赖。可以使用 `@each` 辅助函数在这样类型的属性上设置计算属性。例如：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we created a `country` object that has two `states`.
    We then defined a computed property, `stateNames` that returns an array of the
    state names. A change to any of the state names results in a recalculation of
    the property.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述示例中，我们创建了一个具有两个 `states` 的 `country` 对象。然后我们定义了一个计算属性 `stateNames`，它返回一个包含州名的数组。任何州名的更改都会导致属性重新计算。
- en: Defining property observers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性观察者
- en: 'In addition to computed properties, you can also set `observers` to properties.
    Observers are functions that get called when the properties they subscribe to
    change. They have the same signature as computed properties but use the `observers`
    function, as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算属性外，您还可以将 `observers` 设置为属性。观察者是在它们订阅的属性发生变化时被调用的函数。它们具有与计算属性相同的签名，但使用 `observers`
    函数，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following example defines a session class that sets up an observer that
    makes the user relogin as soon as the session expires:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个会话类，它设置了一个观察者，当会话过期时，用户需要重新登录：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Observers have no strict naming convention, but most developers name observers
    by appending `DidChange` to the property that is being observed, as shown:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者没有严格的命名约定，但大多数开发者通过在观察的属性后附加 `DidChange` 来命名观察者，如下所示：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just like computed properties, observers can also subscribe to an unlimited
    number of properties:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算属性一样，观察者也可以订阅无限数量的属性：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the `inMotion` property will be recalculated when either the `running`
    or `walking` property changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当 `running` 或 `walking` 属性中的任何一个发生变化时，`inMotion` 属性将被重新计算。
- en: 'Observers can also be set up and torn down using the `addObserver()` and `removeObserver()`
    methods respectively. These become handy when you want to manage observers yourself.
    For example, the preceding sample can be rewritten as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者也可以使用 `addObserver()` 和 `removeObserver()` 方法分别设置和拆除。当您想自己管理观察者时，这些方法变得非常有用。例如，前面的示例可以重写为：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding code, the `addObserver` method takes at least two
    arguments: the property to observe and the function to call whenever the property
    changes. In our example, we also tear down the observer listener by calling the
    `removeObserver` method. This method takes one argument, which is the property
    to unbind from.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`addObserver` 方法至少需要两个参数：要观察的属性以及属性变化时调用的函数。在我们的示例中，我们还通过调用 `removeObserver`
    方法来拆除观察者监听器。此方法需要一个参数，即要解绑的属性。
- en: 'Ember.js also provides a way to pass the context to use in the `observer` function.
    For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 还提供了一种方法来传递在 `observer` 函数中使用的上下文。例如：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is important to note that observers only fire on property changes that occur
    after object initialization. An `on(''init'')` method can be applied to an observer
    to make it fire on changes that could occur during an object initialization. For
    example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，观察者只会在对象初始化之后发生的属性变化上触发。可以将一个 `on('init')` 方法应用于观察者，使其在对象初始化期间可能发生的任何变化上触发。例如：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The example defines two observers: `skippedDidChange` and `playedDidChange`,
    of which, only the latter is called after an object initialization.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例定义了两个观察者：`skippedDidChange` 和 `playedDidChange`，其中，只有后者在对象初始化后会被调用。
- en: Creating property bindings
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建属性绑定
- en: 'Ember.js provides support for both one- and two-way bindings. A binding is
    a link between two properties of the same or different objects, such that they
    are always in sync. This means that an update to one of the properties results
    in the other property being updated to the new value. Bindings are defined in
    the following signature:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 提供了对单向和双向绑定的支持。绑定是同一对象或不同对象两个属性之间的链接，它们总是保持同步。这意味着对一个属性的更新会导致另一个属性更新为新值。绑定在以下签名中定义：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, the two properties `property` and `otherProperty` always stay
    in sync. Here''s an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个属性 `property` 和 `otherProperty` 总是保持同步。以下是一个例子：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding example, the `book` instance has an `author` property that
    binds to the created global author instance. Any changes made to the name of the
    author will be reflected in the bound book author property. Likewise, any changes
    made to the book''s author property will be propagated back to the global author
    as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`book` 实例有一个绑定到创建的全局作者实例的 `author` 属性。对作者名字的任何更改都会反映在绑定的书籍作者属性中。同样，对书籍作者属性的任何更改都会传播回全局作者，如下所示：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is an example of a two-way binding where an update to either property results
    in the other property being updated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双向绑定的例子，其中对任一属性的更新都会导致另一个属性更新为新值。
- en: 'Ember.js also supports one-way bindings where updates are unidirectional. A
    property can subscribe to updates from a different property but will not update
    the latter if the former changes. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 也支持单向绑定，其中更新是单向的。一个属性可以订阅来自不同属性的更新，但如果前者发生变化，它不会更新后者。例如：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, the book property changes will not affect the bound
    author's name property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，书籍属性的变化不会影响绑定的作者的名字属性。
- en: Using mixins
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混入
- en: 'Mixins are abstract definitions that define methods and properties that classes
    and objects can reuse. For example, consider these two objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是抽象定义，它定义了类和对象可以重用的方法和属性。例如，考虑这两个对象：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These two objects share a common function that can be abstracted into a mixin:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象共享一个可以抽象为混入的公共函数：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Any number of mixins can be passed to objects or classes on creation or definition,
    respectively:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在创建或定义时向对象或类传递任意数量的混入：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is important to note that mixins are always *created* and never *extended*.
    The example also showed that objects reusing mixins are always created using the
    `createWithMixins` method on instantiation and not the `create` method. However,
    classes still use the `extend` method when applying mixins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，混入总是**创建**的，而不是**扩展**的。示例还显示，重用混入的对象在实例化时总是使用 `createWithMixins` 方法创建，而不是
    `create` 方法。然而，当应用混入时，类仍然使用 `extend` 方法。
- en: Reopening classes and instances
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新打开类和实例
- en: Sometimes, it is necessary to update class implementations without redefining
    them. This is usually necessary when we do not wish to extend built-in classes,
    but only want to update their implementations. Ember.js refers to this as reopening
    of classes and objects. Class methods and properties can be reimplemented using
    the `reopenClass` method, while instance methods and properties can be updated
    using the `reopen` method. It's however discouraged to change built-ins as they
    may change in future versions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要更新类实现而不重新定义它们。通常在我们不希望扩展内置类，只想更新它们的实现时，这是必要的。Ember.js 将其称为类的重新打开和对象的重新打开。可以使用
    `reopenClass` 方法重新实现类方法和属性，而实例方法和属性可以使用 `reopen` 方法更新。然而，不建议更改内置类，因为它们可能在未来的版本中发生变化。
- en: 'For example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we added an instance method, `purchase`, and two properties,
    `id` and `name` to the already defined `Book` class. We have also added a class
    method, `getById`, without extending the class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们向已定义的`Book`类添加了一个实例方法`purchase`和两个属性`id`和`name`。我们还添加了一个类方法`getById`，而没有扩展该类。
- en: Event subscription
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件订阅
- en: 'Another way of notifying changes in an application is through event subscription.
    This paradigm is used heavily in Node.js to channel messages and events across
    different components of an application. Ember.js provides the `Ember.Evented`
    mixin that can be used to serve archive this easily. For example, blocks in a
    board game can subscribe to instructions from an actuator as in the following
    example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中通知更改的另一种方式是通过事件订阅。这种范式在Node.js中被广泛用于在不同组件之间传递消息和事件。Ember.js提供了`Ember.Evented`混入，可以用来轻松地实现这一点。例如，在棋盘游戏中，棋块可以订阅来自执行器的指令，如下例所示：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The mixin provides five essential methods, two of which have been illustrated
    in the preceding example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 混入提供了五个基本方法，其中两个在先前的示例中已经展示：
- en: '`on`: This is used to subscribe to an event'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`：用于订阅事件'
- en: '`off`: This is used to disable a subscription'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`off`：用于禁用订阅'
- en: '`one`: This is used to subscribe once to an event'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`one`：用于一次性订阅事件'
- en: '`trigger`: This is used to emit an event'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger`：用于触发事件'
- en: '`has`: This is used to check if an event has been subscribed to'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has`：用于检查是否已订阅事件'
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter has focused on introducing Ember.js objects. We will use these
    objects extensively in the next chapter, where we will learn how state management
    is accomplished in Ember.js using routers. We will discuss how to construct routes
    and routers. That being said, you should have learned the following Ember.js object
    concepts in this chapter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是介绍Ember.js对象。我们将在下一章中广泛使用这些对象，我们将学习如何在Ember.js中使用路由实现状态管理。我们将讨论如何构建路由和路由器。话虽如此，你应该在本章中学习了以下Ember.js对象概念：
- en: Creating objects and classes in Ember.js
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ember.js中创建对象和类
- en: Getting and setting object properties
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置对象属性
- en: Defining computed properties
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义计算属性
- en: Defining property observers
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义属性观察者
- en: Creating property bindings
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建属性绑定
- en: Using mixins
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入
- en: Reopening Ember.js classes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新打开Ember.js类
- en: In the next chapter, we will be discussing routes, which are one of these classes
    that are extended from `Ember.Object`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论路由，这是从`Ember.Object`扩展出来的这些类之一。
