- en: Chapter 1. What is Flux?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 什么是Flux？
- en: Flux is supposed to be this great new way of building complex user interfaces
    that scale well. At least that's the general messaging around Flux, if you're
    only skimming the Internet literature. But, how do we define *this great new way
    of building user interfaces*? What makes it superior to other more established
    frontend architectures?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Flux应该是一种构建复杂用户界面的新方法，这种方法可以很好地扩展。至少，这是关于Flux的一般信息，如果你只是浏览互联网文献。但是，我们如何定义这种“构建用户界面的新方法”呢？是什么让它优于其他更成熟的前端架构？
- en: The aim of this chapter is to cut through the sales bullet points and explicitly
    spell out what Flux is, and what it isn't, by looking at the patterns that Flux
    provides. And since Flux isn't a software package in the traditional sense, we'll
    go over the conceptual problems that we're trying to solve with Flux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是透过销售要点，明确说明Flux是什么，以及它不是什么，通过观察Flux提供的模式来实现。由于Flux在传统意义上不是一个软件包，我们将探讨我们试图用Flux解决的问题的概念性问题。
- en: Finally, we'll close the chapter by walking through the core components found
    in any Flux architecture, and we'll install the Flux `npm` package and write a
    hello world Flux application right away. Let's get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过介绍任何Flux架构中找到的核心组件来结束本章，并立即安装Flux的`npm`包，编写一个hello world的Flux应用程序。让我们开始吧。
- en: Flux is a set of patterns
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux是一套模式
- en: We should probably get the harsh reality out of the way first—Flux is not a
    software package. It's a set of architectural patterns for us to follow. While
    this might sound disappointing to some, don't despair—there's good reasons for
    not implementing yet another framework. Throughout the course of this book, we'll
    see the value of Flux existing as a set of patterns instead of a de facto implementation.
    For now, we'll go over some of the high-level architectural patterns put in place
    by Flux.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能首先应该澄清一个严峻的现实——Flux不是一个软件包。它是一套我们应遵循的架构模式。虽然这可能会让一些人感到失望，但不要绝望——不实现另一个框架有很好的理由。在本书的整个过程中，我们将看到Flux作为一套模式而不是既定实现存在的价值。现在，我们将探讨Flux实施的一些高级架构模式。
- en: Data entry points
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据输入点
- en: 'With traditional approaches to building frontend architectures, we don''t put
    much thought into how data enters the system. We might entertain the idea of data
    entry points, but not in any detail. For example, with **MVC** (**Model View Controller**)
    architectures, the controller is supposed control the flow of data. And for the
    most part, it does exactly that. On the other hand, the controller is really just
    about controlling what happens after it already has the data. How does the controller
    get data in the first place? Consider the following illustration:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用传统方法构建前端架构时，我们并没有太多考虑数据如何进入系统。我们可能会考虑数据输入点的概念，但不会详细考虑。例如，在**MVC**（**模型-视图-控制器**）架构中，控制器应该控制数据的流动。在大多数情况下，它确实做到了这一点。另一方面，控制器实际上只是控制数据到来之后发生的事情。控制器最初是如何获得数据的呢？考虑以下插图：
- en: '![Data entry points](img/B05419_01_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![数据输入点](img/B05419_01_01.jpg)'
- en: At first glance, there's nothing wrong with this picture. The data-flow, represented
    by the arrows, is easy to follow. But where does the data originate? For example,
    the view can create new data and pass it to the controller, in response to a user
    event. A controller can create new data and pass it to another controller, depending
    on the composition of our controller hierarchy. What about the controller in question—can
    it create data itself and then use it?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 初看这幅图，似乎没有什么问题。数据流，由箭头表示，很容易跟随。但是数据从哪里来呢？例如，视图可以创建新数据并将其传递给控制器，作为对用户事件的响应。控制器可以创建新数据并将其传递给另一个控制器，这取决于我们控制器层次结构的组成。那么，关于这个特定的控制器——它能否自己创建数据然后使用它呢？
- en: In a diagram such as this one, these questions don't have much virtue. But,
    if we're trying to scale an architecture to have hundreds of these components,
    the points at which data enters the system become very important. Since Flux is
    used to build architectures that scale, it considers data entry points an important
    architectural pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的图表中，这些问题并没有多少价值。但是，如果我们试图扩展一个架构以包含数百个这样的组件，数据进入系统的点就变得非常重要。由于Flux用于构建可扩展的架构，它将数据输入点视为一个重要的架构模式。
- en: Managing state
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理
- en: State is one of those realities we need to cope with in frontend development.
    Unfortunately, we can't compose our entire application of pure functions with
    no side-effects for two reasons. First, our code needs to interact with the DOM
    interface, in one way or another. This is how the user sees changes in the UI.
    Second, we don't store all our application data in the DOM (at least we shouldn't
    do this). As time passes and the user interacts with the application, this data
    will change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是我们在前端开发中需要应对的现实之一。不幸的是，我们不能因为两个原因而将整个应用程序完全由没有副作用的纯函数组成。首先，我们的代码需要以某种方式与DOM接口交互。这就是用户看到UI变化的方式。其次，我们并不将所有应用数据都存储在DOM中（至少我们不应该这样做）。随着时间的推移和用户与应用程序的交互，这些数据将发生变化。
- en: 'There''s no cut-and-dry approach to managing state in a web application, but
    there are several ways to limit the amount of state changes that can happen, and
    enforce how they happen. For example, pure functions don''t change the state of
    anything, they can only create new data. Here''s an example of what this looks
    like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中管理状态没有一刀切的方法，但有一些方法可以限制可能发生的状态改变的数量，并强制规定它们如何发生。例如，纯函数不会改变任何东西的状态，它们只能创建新的数据。以下是一个这样的例子：
- en: '![Managing state](img/B05419_01_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![管理状态](img/B05419_01_02.jpg)'
- en: As you can see, there's no side-effects with pure functions because no data
    changes state as a result of calling them. So why is this a desirable trait, if
    state changes are inevitable? The idea is to enforce *where* state changes happen.
    For example, perhaps we only allow certain types of components to change the state
    of our application data. This way, we can rule out several sources as the cause
    of a state change.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，纯函数没有副作用，因为调用它们不会导致任何数据状态改变。那么，如果状态改变是不可避免的，为什么这是一个期望的特性呢？其理念是强制规定状态改变发生的*位置*。例如，我们可能只允许某些类型的组件改变应用数据的状态。这样，我们可以排除几个可能成为状态改变原因的来源。
- en: Flux is big on controlling where state changes happen. Later on in the chapter,
    we'll see how Flux stores manage state changes. What's important about how Flux
    manages state is that it's handled at an architectural layer. Contrast this with
    an approach that lays out a set of rules that say which component types are allowed
    to mutate application data—things get confusing. With Flux, there's less room
    for guessing where state changes take place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Flux非常注重控制状态改变发生的位置。在章节的后面部分，我们将看到Flux存储如何管理状态改变。Flux管理状态的重要之处在于它是在架构层处理的。与规定哪些组件类型允许修改应用数据的一套规则的方法相比——事情会变得混乱。在Flux中，猜测状态改变发生的位置的空间更小。
- en: Keeping updates synchronous
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持更新同步
- en: Complimentary to data entry points is the notion of update synchronicity. That
    is, in addition to managing where the state changes originate from, we have to
    manage the ordering of these changes relative to other things. If the data entry
    points are the *what* of our data, then synchronously applying state changes across
    all the data in our system is the *when*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据输入点相辅相成的是更新同步性的概念。也就是说，除了管理状态改变起源的位置外，我们还需要管理这些改变相对于其他事物的顺序。如果数据输入点是我们的数据的*什么*，那么在系统中同步应用所有数据的状态改变就是*何时*。
- en: 'Let''s think about why this matters for a moment. In a system where data is
    updated asynchronously, we have to account for race conditions. Race conditions
    can be problematic because one piece of data can depend on another, and if they''re
    updated in the wrong order, we see cascading problems, from one component to another.
    Take a look at this diagram, which illustrates this problem:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下这为什么很重要。在一个数据异步更新的系统中，我们必须考虑到竞争条件。竞争条件可能是有问题的，因为一块数据可能依赖于另一块，如果它们以错误的顺序更新，我们就会看到从组件到组件的级联问题。看看这个图表，它说明了这个问题：
- en: '![Keeping updates synchronous](img/B05419_01_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![保持更新同步](img/B05419_01_03.jpg)'
- en: When something is asynchronous, we have no control over when that something
    changes state. So, all we can do is wait for the asynchronous updates to happen,
    and then go through our data and make sure all of our data dependencies are satisfied.
    Without tools that automatically handle these dependencies for us, we end up writing
    a lot of state-checking code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当某事是异步的，我们就无法控制它何时改变状态。因此，我们所能做的就是等待异步更新发生，然后遍历我们的数据，确保所有数据依赖都得到满足。如果没有自动处理这些依赖的工具，我们最终会编写大量的状态检查代码。
- en: 'Flux addresses this problem by ensuring that the updates that take place across
    our data stores are synchronous. This means that the scenario illustrated in the
    preceding diagram isn''t possible. Here''s a better visualization of how Flux
    handles the data synchronization issues that are typical of JavaScript applications
    today:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Flux通过确保跨我们的数据存储发生的更新是同步的来解决此问题。这意味着前面图中展示的场景是不可能的。以下是Flux如何处理JavaScript应用程序中典型的数据同步问题的更好可视化：
- en: '![Keeping updates synchronous](img/B05419_01_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![保持更新同步](img/B05419_01_04.jpg)'
- en: Information architecture
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息架构
- en: It's easy to forget that we work in information technology and that we should
    be building technology around information. In recent times, however, we seem to
    have moved in the other direction, where we're forced to think about implementation
    before we think about information. More often than not, the data exposed by the
    sources used by our application doesn't have what the user needs. It's up to our
    JavaScript to turn this raw data into something consumable by the user. This is
    our information architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记我们在信息技术领域工作，我们应该围绕信息构建技术。然而，近年来，我们似乎走向了另一个方向，即在考虑信息之前被迫考虑实现。很多时候，我们应用程序使用的源数据中暴露的数据并不包含用户所需的内容。这取决于我们的JavaScript将原始数据转换为用户可消费的内容。这就是我们的信息架构。
- en: Does this mean that Flux is used to design information architectures as opposed
    to a software architecture? This isn't the case at all. In fact, Flux components
    are realized as true software components that perform actual computations. The
    trick is that Flux patterns enable us to think about information architecture
    as a first-class design consideration. Rather than having to sift through all
    sorts of components and their implementation concerns, we can make sure that we're
    getting the right information to the user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着Flux是用来设计信息架构而不是软件架构的？这根本不是事实。实际上，Flux组件被实现为真正的软件组件，它们执行实际的计算。诀窍在于Flux模式使我们能够将信息架构视为一等的设计考虑因素。我们不必筛选各种组件及其实现问题，而可以确保我们向用户提供正确的信息。
- en: Once our information architecture takes shape, the larger architecture of our
    application follows, as a natural extension to the information we're trying to
    communicate to our users. Producing information from data is the difficult part.
    We have to distill many sources of data into not only information, but information
    that's also of value to the user. Getting this wrong is a huge risk for any project.
    When we get it right, we can then move on to the specific application components,
    like the state of a button widget, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的信息架构成形后，我们的应用程序的更大架构也随之而来，作为我们试图向用户传达的信息的自然扩展。从数据中产生信息是困难的部分。我们必须将许多数据源提炼成不仅包含信息，而且对用户有价值的信息。做错这一点对任何项目都是一个巨大的风险。当我们做对的时候，我们就可以继续处理特定的应用程序组件，比如按钮小部件的状态等等。
- en: Flux architectures keep data transformations confined to their stores. A store
    is an information factory—raw data goes in and new information comes out. Stores
    control how data enters the system, the synchronicity of state changes, and they
    define *how* the state changes. When we go into more depth on stores as we progress
    through the book, we'll see how they're the pillars of our information architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构将数据转换限制在其存储中。存储是一个信息工厂——原始数据进入，新的信息出来。存储控制数据如何进入系统，状态变化的同步性，以及它们定义状态变化的方式。当我们随着本书的进展更深入地探讨存储时，我们将看到它们是如何成为我们信息架构的支柱的。
- en: Flux isn't another framework
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux不是另一个框架
- en: 'Now that we''ve explored some of the high-level patterns of Flux, it''s time
    to revisit the question: what is Flux again? Well, it is just a set of architectural
    patterns we can apply to our frontend JavaScript applications. Flux scales well
    because it puts information first. Information is the most difficult aspect of
    software to scale; Flux tackles information architecture head on.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些Flux的高级模式，是时候重新审视这个问题了：Flux究竟是什么？嗯，它只是一套我们可以应用于前端JavaScript应用程序的架构模式。Flux之所以能够很好地扩展，是因为它将信息放在首位。信息是软件中最难扩展的方面；Flux直面信息架构问题。
- en: So, why aren't Flux patterns implemented as a framework? This way, Flux would
    have a canonical implementation for everyone to use; and like any other large
    scale open source project, the code would improve over time as the project matures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么Flux模式不以框架的形式实现？这样，Flux将为每个人提供一个标准实现；并且像任何其他大型开源项目一样，随着时间的推移，随着项目的成熟，代码会得到改进。
- en: The main problem is that Flux operates at an architectural level. It's used
    to address information problems that prevent a given application from scaling
    to meet user demand. If Facebook decided to release Flux as yet another JavaScript
    framework, it would likely have the same types of implementation issues that plague
    other frameworks out there. For example, if some component in a framework isn't
    implemented in a way that best suits the project we're working on, then it's not
    so easy to implement a better alternative, without hacking the framework to bits.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是Flux在架构层面运作。它用于解决防止特定应用程序扩展以满足用户需求的信息问题。如果Facebook决定将Flux作为另一个JavaScript框架发布，它可能会遇到其他框架中普遍存在的相同类型的实现问题。例如，如果框架中的某些组件没有以最适合我们正在工作的项目的方式进行实现，那么在不破坏框架的情况下实现更好的替代方案并不容易。
- en: What's nice about Flux is that Facebook decided to leave the implementation
    options on the table. They do provide a few Flux component implementations, but
    these are reference implementations. They're functional, but the idea is that
    they're a starting point for us to understand the mechanics of how things such
    as dispatchers are expected to work. We're free to implement the same Flux architectural
    pattern as we see it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Flux的优点在于，Facebook决定将实现选项留给了我们。他们确实提供了一些Flux组件实现，但这些是参考实现。它们是功能性的，但目的是它们是我们理解诸如派发器等事物预期如何工作的起点。我们可以自由地实现我们看到的相同的Flux架构模式。
- en: Flux isn't a framework. Does this mean we have to implement everything ourselves?
    No, we do not. In fact, developers are implementing Flux libraries and releasing
    them as open source projects. Some Flux libraries stick more closely to the Flux
    patterns than others. These implementations are opinionated, and there's nothing
    wrong with using them if they're a good fit for what we're building. The Flux
    patterns aim to solve generic conceptual problems with JavaScript development,
    so you'll learn what they are before diving into Flux implementation discussions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flux不是一个框架。这意味着我们必须自己实现一切吗？不，我们不必这样做。实际上，开发者正在实现Flux库，并将它们作为开源项目发布。一些Flux库更紧密地遵循Flux模式，而其他则不是。这些实现是有偏见的，如果它们适合我们正在构建的内容，使用它们是没有问题的。Flux模式旨在用JavaScript开发解决通用概念性问题，所以在深入Flux实现讨论之前，你会了解它们是什么。
- en: Flux solves conceptual problems
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux解决概念性问题
- en: If Flux is simply a collection of architectural patterns instead of a software
    framework, what sort of problems does it solve? In this section, we'll look at
    some of the conceptual problems that Flux addresses from an architectural perspective.
    These include unidirectional data-flow, traceability, consistency, component layering,
    and loosely coupled components. Each of these conceptual problems pose a degree
    of risk to our software, in particular the ability to scale it. Flux helps us
    get out in front of these issues as we're building the software.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Flux仅仅是一系列架构模式而不是一个软件框架，那么它解决了哪些问题？在本节中，我们将从架构的角度探讨Flux解决的一些概念性问题。这包括单向数据流、可追溯性、一致性、组件分层和松散耦合的组件。这些概念性问题中的每一个都对我们软件的某些方面构成了一定的风险，特别是其可扩展性。Flux帮助我们提前解决这些问题，在我们构建软件的过程中。
- en: Data flow direction
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流方向
- en: 'We''re creating an information architecture to support the feature-rich application
    that will ultimately sit on top of this architecture. Data flows into the system
    and will eventually reach an endpoint, terminating the flow. It''s what happens
    in between the entry point and the termination point that determines the data-flow
    within a Flux architecture. This is illustrated here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个信息架构来支持最终将位于这个架构之上的功能丰富的应用程序。数据流入系统，最终会达到一个端点，终止数据流。在入口点和终止点之间发生的事情决定了Flux架构中的数据流。这在此处得到了说明：
- en: '![Data flow direction](img/B05419_01_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![数据流方向](img/B05419_01_05.jpg)'
- en: Data flow is a useful abstraction, because it's easy to visualize data as it
    enters the system and moves from one point to another. Eventually, the flow stops.
    But before it does, several side-effects happen along the way. It's that middle
    block in the preceding diagram that's concerning, because we don't know exactly
    how the data-flow reached the end.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是一个有用的抽象，因为它很容易将数据视为它进入系统并在一个点到另一个点之间移动。最终，流动会停止。但在它停止之前，沿途会发生几个副作用。我们关注的是前面图中的中间块，因为我们不知道数据流是如何到达终点的。
- en: 'Let''s say that our architecture doesn''t pose any restrictions on data flow.
    Any component is allowed to pass data to any other component, regardless of where
    that component lives. Let''s try to visualize this setup:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的架构对数据流没有任何限制。任何组件都可以将数据传递给任何其他组件，无论该组件位于何处。让我们尝试可视化这个设置：
- en: '![Data flow direction](img/B05419_01_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![数据流方向](img/B05419_01_06.jpg)'
- en: As you can see, our system has clearly defined entry and exit points for our
    data. This is good because it means that we can confidently say that the data-flows
    through our system. The problem with this picture is with how the data-flows between
    the components of the system. There's no direction, or rather, it's *multidirectional*.
    This isn't a good thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的系统对我们的数据有明确的入口和出口点。这是好事，因为它意味着我们可以自信地说数据流通过我们的系统。这幅图的问题在于数据流在系统组件之间的流动方式。没有方向，或者说，它是*多向的*。这不是好事。
- en: Flux is a *unidirectional* data flow architecture. This means that the preceding
    component layout isn't possible. The question is—why does this matter? At times,
    it might seem convenient to be able to pass data around in any direction, that
    is, from any component to any other component. This in and of itself isn't the
    issue—passing data alone doesn't break our architecture. However, when data moves
    around our system in more than one direction, there's more opportunity for components
    to fall out of sync with one another. This simply means that if data doesn't always
    move in the same direction, there's always the possibility of ordering bugs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是一种*单向*数据流架构。这意味着前面的组件布局是不可能的。问题是——这有什么关系？有时，能够以任何方向传递数据可能看起来很方便，也就是说，从任何组件到任何其他组件。这本身并不是问题——仅仅传递数据本身并不会破坏我们的架构。然而，当数据以多个方向在我们的系统中移动时，组件之间失去同步的机会就更多了。这仅仅意味着如果数据不总是朝同一方向移动，就总有可能出现排序错误。
- en: 'Flux enforces the direction of data-flows, and thus eliminates the possibility
    of components updating themselves in an order that breaks the system. No matter
    what data has just entered the system, it''ll always flow through the system in
    the same order as any other data, as illustrated here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flux强制数据流的方向，从而消除了组件以破坏系统顺序的方式自行更新的可能性。无论什么数据刚刚进入系统，它总是会按照与其他任何数据相同的顺序通过系统，如下所示：
- en: '![Data flow direction](img/B05419_01_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![数据流方向](img/B05419_01_07.jpg)'
- en: Predictable root cause
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可预测的根本原因
- en: With data entering our system and flowing through our components in one direction,
    we can more easily trace any effect to it's cause. In contrast, when a component
    sends data to any other component residing in any architectural layer, it's a
    lot more difficult to figure how the data reached its destination. Why does this
    matter? Debuggers are sophisticated enough that we can easily traverse any level
    of complexity during runtime. The problem with this notion is that it presumes
    we only need to trace what's happening in our code for the purposes of debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据以一个方向进入我们的系统并通过我们的组件流动时，我们可以更容易地将任何影响追溯到其根本原因。相比之下，当一个组件向任何其他组件发送数据，而这些组件位于任何架构层时，确定数据如何到达目的地就困难得多。这有什么关系？调试器足够复杂，我们可以在运行时轻松地穿越任何复杂度。这个概念的问题在于它假设我们只需要追踪代码中的行为以进行调试。
- en: Flux architectures have inherently predictable data-flows. This is important
    for a number of design activities and not just debugging. Programmers working
    on Flux applications will begin to intuitively sense what's going to happen. Anticipation
    is key, because it let's us avoid design dead-ends before we hit them. When the
    cause and effect are easy to tease out, we can spend more time focusing on building
    application features—the things the customers care about.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 架构具有固有的可预测数据流。这对于许多设计活动来说很重要，而不仅仅是调试。在 Flux 应用程序上工作的程序员将开始直观地感觉到将要发生的事情。预期是关键，因为它让我们在遇到它们之前避免设计死胡同。当原因和结果容易分辨时，我们可以花更多的时间专注于构建应用程序功能——客户关心的事情。
- en: Consistent notifications
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的提醒
- en: The direction in which we pass data from component to component in Flux architectures
    should be consistent. In terms of consistency, we also need to think about the
    mechanism used to move data around our system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flux 架构中，我们从组件到组件传递数据的方向应该是一致的。在一致性的方面，我们还需要考虑用于在系统中移动数据的机制。
- en: For example, publish/subscribe (pub/sub) is a popular mechanism used for inter-component
    communication. What's neat about this approach is that our components can communicate
    with one another, and yet we're able to maintain a level of decoupling. In fact,
    this is fairly common in frontend development because component communication
    is largely driven by user events. These events can be thought of as fire-and-forget.
    Any other components that want to respond to these events in some way, need to
    take it upon themselves to subscribe to the particular event.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，发布/订阅（pub/sub）是用于组件间通信的一种流行机制。这种方法的优点在于，我们的组件可以相互通信，同时我们还能保持一定程度的解耦。实际上，这在前端开发中相当常见，因为组件通信主要是由用户事件驱动的。这些事件可以被视为一次性触发。任何其他想要以某种方式对这些事件做出响应的组件，都需要自行订阅特定的事件。
- en: While pub/sub does have some nice properties, it also poses architectural challenges,
    in particular scaling complexities. For example, let's say that we've just added
    several new components for a new feature. Well, in which order do these components
    receive update messages relative to pre-existing components? Do they get notified
    after all the pre-existing components? Should they come first? This presents a
    data dependency scaling issue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 pub/sub 确实有一些不错的特性，但它也带来了架构挑战，特别是扩展复杂性。例如，假设我们刚刚为新的功能添加了几个新组件。那么，这些组件相对于现有组件接收更新消息的顺序是什么？它们是在所有现有组件之后被通知的吗？它们应该排在第一位吗？这提出了数据依赖性扩展问题。
- en: The other challenge with pub-sub is that the events that get published are often
    fine-grained to the point where we'll want to subscribe and later unsubscribe
    from the notifications. This leads to consistency challenges because trying to
    code lifecycle changes when there's a large number of components in the system
    is difficult and presents opportunities for missed events.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Pub/Sub（发布/订阅）的另一个挑战是发布的事件通常非常细粒度，以至于我们可能想要订阅这些通知，然后在之后取消订阅。这导致了一致性挑战，因为当系统中存在大量组件时，尝试编码生命周期变化是困难的，并且会错过事件的机会。
- en: 'The idea with Flux is to sidestep the issue by maintaining a static inter-component
    messaging infrastructure that issues notifications to every component. In other
    words, programmers don''t get to pick and choose the events their components will
    subscribe to. Instead, they have to figure out which of the events that are dispatched
    to them are relevant, ignoring the rest. Here''s a visualization of how Flux dispatches
    events to components:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 的想法是通过维护一个静态的组件间消息基础设施来规避问题，该基础设施向每个组件发布通知。换句话说，程序员不能选择他们的组件将订阅哪些事件。相反，他们必须弄清楚哪些被发送给他们的事件是相关的，忽略其余的。以下是
    Flux 向组件分发事件的可视化：
- en: '![Consistent notifications](img/B05419_01_08.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![一致的提醒](img/B05419_01_08.jpg)'
- en: The Flux dispatcher sends the event to every component; there's no getting around
    this. Instead of trying to fiddle with the messaging infrastructure, which is
    difficult to scale, we implement logic within the component to determine whether
    or not the message is of interest. It's also within the component that we can
    declare dependencies on other components, which helps influence the ordering of
    messages. We'll cover this in much more detail in later chapters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Flux调度器将事件发送到每个组件；这是无法避免的。我们不是试图调整难以扩展的消息基础设施，而是在组件内部实现逻辑以确定消息是否感兴趣。同样，我们可以在组件内部声明对其他组件的依赖，这有助于影响消息的顺序。我们将在后面的章节中更详细地介绍这一点。
- en: Simple architectural layers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的架构层次
- en: 'Layers can be a great way to organize an architecture of components. For one
    thing, it''s an obvious way to categorize the various components that make up
    our application. For another thing, layers serve as a means to put constraints
    around communication paths. This latter point is especially relevant to Flux architectures
    since it''s important that data flow in one direction. It''s much easier to apply
    constraints to layers than it is to individual components. Here is an illustration
    of Flux layers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构可以是一种组织组件架构的绝佳方式。一方面，它是一种显而易见的方式来对构成我们应用程序的各种组件进行分类。另一方面，层次结构充当了限制通信路径的手段。这一点对于Flux架构尤其相关，因为数据流向一个方向是很重要的。相对于单个组件，对层次结构应用约束要容易得多。以下是一个Flux层次的示例：
- en: '![Simple architectural layers](img/B05419_01_09.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![简单的架构层次](img/B05419_01_09.jpg)'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This diagram isn't intended to capture the entire data flow of a Flux architecture,
    just how data-flows between the main three layers. It also doesn't give any detail
    about what's in the layers. Don't worry, the next section gives introductory explanations
    of the types of Flux components, and the communication that happens between the
    layers is the focus of this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此图并不是为了捕捉Flux架构的整个数据流，而是展示数据如何在主要三个层次之间流动。它也没有提供关于层次结构中内容的任何细节。请放心，下一节将介绍Flux组件的类型及其在层次结构之间的通信，这是本书的重点。
- en: As you can see, the data-flows from one layer to the next, in one direction.
    Flux only has a few layers, and as our applications scale in terms of component
    counts, the layer counts remains fixed. This puts a cap on the complexity involved
    with adding new features to an already large application. In addition to constraining
    the layer count and the data-flow direction, Flux architectures are strict about
    which layers are actually allowed to communicate with one another.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数据流从一个层次流向下一个层次，方向一致。Flux只有几个层次，并且随着我们的应用程序在组件数量方面进行扩展，层次数量保持不变。这为向已经很大的应用程序添加新功能涉及的复杂性设置了上限。除了限制层次数量和数据流向之外，Flux架构对哪些层次可以相互通信也非常严格。
- en: For example, the action layer could communicate with the view layer, and we
    would still be moving in one direction. We would still have the layers that Flux
    expects. However, skipping a layer like this is prohibited. By ensuring that layers
    only communicate with the layer directly beneath it, we can rule out bugs introduced
    by doing something out-of-order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，动作层可以与视图层通信，而我们仍然在向一个方向移动。我们仍然会有Flux期望的层次结构。然而，跳过这样的层次是禁止的。通过确保层次结构只与直接下方的层次结构通信，我们可以排除因顺序不当而引入的bug。
- en: Loosely coupled rendering
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松散耦合的渲染
- en: One decision made by the Flux designers that stands out is that Flux architectures
    don't care how UI elements are rendered. That is to say, the view layer is loosely
    coupled to the rest of the architecture. There are good reasons for this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Flux设计者做出的一个引人注目的决定是，Flux架构并不关心UI元素是如何渲染的。也就是说，视图层与架构的其他部分松散耦合。这有很好的理由。
- en: Flux is an information architecture first, and a software architecture second.
    We start with the former and graduate toward the latter. The challenge with view
    technology is that it can exert a negative influence on the rest of the architecture.
    For example, one view has a particular way of interacting with the DOM. Then,
    if we've already decided on this technology, we'll end up letting it influence
    the way our information architecture is structured. This isn't necessarily a bad
    thing, but it can lead to us making concessions about the information we ultimately
    display to our users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Flux首先是一个信息架构，其次才是软件架构。我们从这个开始，逐步过渡到后者。视图技术的挑战在于它可能会对整个架构产生负面影响。例如，一个视图有与DOM交互的特定方式。如果我们已经决定了这项技术，我们最终会让它影响我们的信息架构结构。这并不一定是坏事，但它可能导致我们在最终向用户展示的信息上做出妥协。
- en: What we should really be thinking about is the information itself and how this
    information changes over time. What actions are involved that bring about these
    changes? How is one piece of data dependent on another piece of data? Flux naturally
    removes itself from the browser technology constraints of the day so that we can
    focus on the information first. It's easy to plug views into our information architecture
    as it evolves into a software product.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正应该考虑的是信息本身以及这些信息随时间的变化。涉及哪些动作导致了这些变化？一条数据如何依赖于另一条数据？Flux自然地摆脱了当时浏览器技术的限制，以便我们首先关注信息。随着它演变成一个软件产品，很容易将视图插入到我们的信息架构中。
- en: Flux components
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流量组件
- en: In this section, we'll begin our journey into the concepts of Flux. These concepts
    are the essential ingredients used in formulating a Flux architecture. While there's
    no detailed specifications for how these components should be implemented, they
    nevertheless lay the foundation of our implementation. This is a high-level introduction
    to the components we'll be implementing throughout this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始探索Flux的概念。这些概念是构建Flux架构的基本成分。虽然没有详细说明这些组件应该如何实现，但它们仍然为我们实现奠定了基础。这是对我们将在这本书中实现的所有组件的高级介绍。
- en: Action
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: 'Actions are the *verbs* of the system. In fact, it''s helpful if we derive
    the name of an action directly from a sentence. These sentences are typically
    statements of functionality – something we want the application to do. Here are
    some examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是系统的*动词*。实际上，如果我们直接从句子中推导出动作的名称，这很有帮助。这些句子通常是功能声明——我们希望应用程序执行的操作。以下是一些例子：
- en: Fetch the session
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取会话
- en: Navigate to the settings page
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到设置页面
- en: Filter the user list
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤用户列表
- en: Toggle the visibility of the details section
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换详细信息的可见性
- en: These are simple capabilities of the application, and when we implement them
    as part of a Flux architecture, actions are the starting point. These human-readable
    action statements often require other new components elsewhere in the system,
    but the first step is always an action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是应用程序的简单功能，当我们将其作为Flux架构的一部分实现时，动作是起点。这些可读的动作声明通常需要在系统其他地方实现其他新组件，但第一步始终是动作。
- en: 'So, what exactly is a Flux action? At it''s simplest, an action is nothing
    more than a string—a name that helps identify the purpose of the action. More
    typically, actions consist of a *name* and a *payload*. Don''t worry about the
    payload specifics just yet—as far as actions are concerned, they''re just opaque
    pieces of data being delivered into the system. Put differently, actions are like
    mail parcels. The entry point into our Flux system doesn''t care about the internals
    of the parcel, only that they get to where they need to go. Here''s an illustration
    of actions entering a Flux system:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Flux动作究竟是什么呢？在最简单的情况下，动作不过是一个字符串——一个帮助识别动作目的的名称。更典型的是，动作由*名称*和*负载*组成。现在不必担心负载的具体细节——就动作而言，它们只是被传递到系统中的不透明数据块。换句话说，动作就像邮件包裹。我们的Flux系统的入口点不关心包裹的内部结构，只关心它们能否到达目的地。以下是一个动作进入Flux系统的示意图：
- en: '![Action](img/B05419_01_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/B05419_01_10.jpg)'
- en: This diagram might give the impression that actions are external to Flux, when
    in fact they're an integral part of the system. The reason this perspective is
    valuable is because it forces us to think about actions as the only means to deliver
    new data into the system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图可能会给人一种动作是Flux外部的感觉，但实际上它们是系统的一个组成部分。这种观点有价值的原因在于它迫使我们把动作视为将新数据输入系统的唯一手段。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Golden Flux Rule**: If it''s not an action, it can''t happen.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**黄金Flux规则**：如果不是行动，就无法发生。'
- en: Dispatcher
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器
- en: 'The dispatcher in a Flux architecture is responsible for distributing actions
    to the store components (we''ll talk about stores next). A dispatcher is actually
    kind of like a broker—if actions want to deliver new data to a store, they have
    to talk to the broker, so it can figure out the best way to deliver them. Think
    about a message broker in a system like RabbitMQ. It''s the central hub where
    everything is sent before it''s actually delivered. Here is a diagram depicting
    a Flux dispatcher receiving actions and dispatching them to stores:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux架构中，调度器负责将行动分发到存储组件（我们将在下一节讨论存储）。调度器实际上有点像经纪人——如果行动想要将新数据传递给存储，它们必须与经纪人交谈，以便找出最佳传递方式。想想像RabbitMQ这样的系统中的消息经纪人。它是所有消息在真正传递之前发送到的中心枢纽。以下是描述Flux调度器接收行动并将它们分发给存储的图示：
- en: '![Dispatcher](img/B05419_01_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![调度器](img/B05419_01_11.jpg)'
- en: The earlier section of this chapter—"simple architectural layers"—didn't have
    an explicit layer for dispatchers. That was intentional. In a Flux application,
    there's only one dispatcher. It can be thought of more as a pseudo layer than
    an explicit layer. We know the dispatcher is there, but it's not essential to
    this level of abstraction. What we're concerned about at an architectural level
    is making sure that when a given action is dispatched, we know that it's going
    to make it's way to every store in the system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的早期部分——“简单的架构层”——没有为调度器设置一个明确的层。这是故意的。在Flux应用中，只有一个调度器。它更像是伪层而不是明确层。我们知道调度器在那里，但它不是这个抽象级别的必需品。我们在架构层面关心的是确保当某个特定的行动被调度时，我们知道它将到达系统中的每个存储。
- en: Having said that, the dispatcher's role is critical to how Flux works. It's
    the place where store callback functions are registered and it's how data dependencies
    are handled. Stores tell the dispatcher about other stores that it depends on,
    and it's up to the dispatcher to make sure these dependencies are properly handled.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，调度器在Flux的工作方式中起着至关重要的作用。它是注册存储回调函数的地方，也是处理数据依赖的地方。存储告诉调度器它依赖的其他存储，而调度器负责确保这些依赖得到适当处理。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Golden Flux Rule**: The dispatcher is the ultimate arbiter of data dependencies.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**黄金Flux规则**：调度器是数据依赖的最终仲裁者。'
- en: Store
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: Stores are where state is kept in a Flux application. Typically, this means
    the application data that's sent to the frontend from the API. However, Flux stores
    take this a step further and explicitly model the state of the entire application.
    If this sounds confusing or like a generally bad idea, don't worry—we'll clear
    this up as we make our way through subsequent chapters. For now, just know that
    stores are where state that matters can be found. Other Flux components don't
    have state—they have implicit state at the code level, but we're not interested
    in this, from an architectural point of view.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux应用中，存储是保持状态的地方。通常，这意味着从API发送到前端的应用数据。然而，Flux存储更进一步，明确地模拟整个应用的状态。如果这听起来很困惑或者像是一个普遍的坏主意，不用担心——随着我们进入后续章节，我们会澄清这一点。现在，只需知道存储是重要状态可以找到的地方。其他Flux组件没有状态——它们在代码级别有隐式状态，但我们对此不感兴趣，从架构的角度来看。
- en: 'Actions are the delivery mechanism for new data entering the system. The term
    *new data* doesn''t imply that we''re simply appending it to some collection in
    a store. All data entering the system is new in the sense that it hasn''t been
    dispatched as an action yet—it could in fact result in a store changing state.
    Let''s look at a visualization of an action that results in a store changing state:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 行动是系统中新数据进入的传递机制。术语“新数据”并不意味着我们只是将其附加到存储中的某个集合。所有进入系统的数据都是新的，因为在意义上它还没有被作为行动发出——实际上它可能导致存储状态改变。让我们看看一个导致存储状态改变的行动的可视化：
- en: '![Store](img/B05419_01_12.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![存储](img/B05419_01_12.jpg)'
- en: The key aspect of how stores change state is that there's no external logic
    that determines a state change should happen. It's the store, and only the store,
    that makes this decision and then carries out the state transformation. This is
    all tightly encapsulated within the store. This means that when we need to reason
    about particular information, we need not look any further than the stores. They're
    their own boss—they're self-employed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储如何改变状态的关键方面是没有任何外部逻辑决定状态变化应该发生。只有存储，并且只有存储，才会做出这个决定并执行状态转换。这一切都紧密封装在存储中。这意味着当我们需要推理特定信息时，我们不需要再往其他地方看，只需查看存储即可。他们是自己的老板——他们是自雇的。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Golden Flux Rule**: Stores are where state lives, and only stores themselves
    can change this state.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**黄金Flux规则**：状态存储在存储中，只有存储本身可以改变这种状态。'
- en: View
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'The last Flux component we''re going to look at in this section is the view,
    and it technically isn''t even a part of Flux. At the same time, views are obviously
    a critical part of our application. Views are almost universally understood as
    the part of our architecture that''s responsible for displaying data to the user—it''s
    the last stop as data-flows through our information architecture. For example,
    in MVC architectures, views take model data and display it. In this sense, views
    in a Flux-based application aren''t all that different from MVC views. Where they
    differ markedly is with regard to handling events. Let''s take a look at the following
    diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将要查看的最后一个Flux组件是视图，从技术上讲，它甚至不是Flux的一部分。同时，视图显然是我们应用程序的一个关键部分。视图几乎被普遍理解为负责向用户显示数据的架构部分——它是数据流通过我们的信息架构的最后一站。例如，在MVC架构中，视图接收模型数据并显示它。从这个意义上说，基于Flux的应用程序中的视图与MVC视图并没有太大的不同。它们之间的显著差异在于处理事件的方式。让我们看一下以下图表：
- en: '![View](img/B05419_01_13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![视图](img/B05419_01_13.jpg)'
- en: Here we can see the contrasting responsibilities of a Flux view, compared with
    a view component found in your typical MVC architecture. The two view types have
    similar types of data flowing into them—application data used to render the component
    and events (often user input). What's different between the two types of view
    is what flows out of them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Flux视图与典型MVC架构中找到的视图组件的对比责任。这两种视图类型接收到的数据类型相似——用于渲染组件的应用数据以及事件（通常是用户输入）。这两种类型视图之间的不同之处在于它们流出的内容。
- en: The typical view doesn't really have any constraints in how its event handler
    functions communicate with other components. For example, in response to a user
    clicking a button, the view could directly invoke behavior on a controller, change
    the state of a model, or it might query the state of another view. On the other
    hand, the Flux view can only dispatch new actions. This keeps our single entry
    point into the system intact and consistent with other mechanisms that want to
    change the state of our store data. In other words, an API response updates state
    in the exact same way as a user clicking a button does.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的视图在事件处理函数如何与其他组件通信方面并没有任何限制。例如，在用户点击按钮的响应中，视图可以直接在控制器上调用行为，改变模型的状态，或者它可能查询另一个视图的状态。另一方面，Flux
    视图只能分派新的动作。这保持了我们的系统单入口的完整性和一致性，与其他想要改变我们存储数据状态的机制相一致。换句话说，API 响应更新状态的方式与用户点击按钮的方式完全相同。
- en: Given that views should be restricted in terms of how data-flows out of them
    (besides DOM updates) in a Flux architecture, you would think that views should
    be an actual Flux component. This would make sense insofar as making actions the
    only possible option for views. However, there's also no reason we can't enforce
    this now, with the benefit being that Flux remains entirely focused on creating
    information architectures.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Flux架构中，视图应该限制数据流出的方式（除了DOM更新），因此人们可能会认为视图应该是一个实际的Flux组件。这在某种程度上是有道理的，因为使动作成为视图的唯一可能选项。然而，也没有理由我们现在不能强制执行这一点，好处是Flux可以完全专注于创建信息架构。
- en: Keep in mind, however, that Flux is still in it's infancy. There's no doubt
    going to be external influences as more people start adopting Flux. Maybe Flux
    will have something to say about views in the future. Until then, views exist
    outside of Flux but are constrained by the unidirectional nature of Flux.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，Flux 仍然处于起步阶段。随着越来越多的人开始采用Flux，无疑会有外部影响。也许Flux将来会对视图有所评论。在此之前，视图存在于Flux之外，但受到Flux单向特性的限制。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Golden Flux Rule**: The only way data-flows out of a view is by dispatching
    an action.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**黄金Flux规则**：数据从视图中流出的唯一方式是通过分发一个动作。'
- en: Installing the Flux package
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Flux包
- en: We'll close the first chapter by getting our feet wet with some code, because
    everyone needs a hello world application under their belt. We'll also get some
    of our boilerplate code setup tasks out of the way too, since we'll be using a
    similar setup throughout the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过编写一些代码来结束第一章，因为每个人都需要一个基础的好莱坞应用。我们还将完成一些样板代码的设置任务，因为我们将在整个书中使用类似的设置。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll skip going over Node + NPM installation since it's sufficiently covered
    in great detail all over the Internet. We'll assume Node is installed and ready
    to go from this point forward.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过Node + NPM的安装说明，因为互联网上已经有很多详细的覆盖。我们将假设从现在开始Node已经安装并准备就绪。
- en: 'The first NPM package we''ll need installed is Webpack. This is an advanced
    module bundler that''s well suited for modern JavaScript applications, including
    Flux-based applications. We''ll want to install this package globally so that
    the `webpack` command gets installed on our system:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装的NPM包是Webpack。这是一个适用于现代JavaScript应用（包括基于Flux的应用）的高级模块打包器。我们希望全局安装此包，以便`webpack`命令可以在我们的系统上安装：
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Webpack in place, we can build each of the code examples that ship with
    this book. However, our project does require a couple of local NPM packages, and
    these can be installed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Webpack配置就绪的情况下，我们可以构建本书附带的所有代码示例。然而，我们的项目需要安装几个本地的NPM包，这些包可以按照以下步骤安装：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `--save-dev` option adds these development dependencies to our file, if
    one exists. This is just to get started—it isn''t necessary to manually install
    these packages to run the code examples in this book. The examples you''ve downloaded
    already come with a `package.json`, so to install the local dependencies, simply
    run the following from within the same directory as the `package.json` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save-dev`选项将这些开发依赖项添加到我们的文件中，如果存在的话。这只是开始——手动安装这些包来运行本书中的代码示例并不是必需的。你下载的示例已经包含了`package.json`文件，因此要安装本地依赖项，只需在`package.json`文件所在的目录中运行以下命令：'
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now the `webpack` command can be used to build the example. This is the only
    example in the first chapter, so it's easy to navigate to within a terminal window
    and run the `webpack` command, which builds the `main-bundle.js` file. Alternatively,
    if you plan on playing with the code, which is obviously encouraged, try running
    `webpack --watch`. This latter form of the command will monitor for file changes
    to the files used in the build, and run the build whenever they change.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用`webpack`命令来构建示例。这是第一章中唯一的示例，因此很容易在终端窗口中导航并运行`webpack`命令，该命令会构建`main-bundle.js`文件。如果你打算玩转代码，这显然是被鼓励的，可以尝试运行`webpack
    --watch`。这个命令的后者形式将监视用于构建的文件的变化，并在它们发生变化时运行构建。
- en: This is indeed a simple hello world to get us off to a running start, in preparation
    for the remainder of the book. We've taken care of all the boilerplate setup tasks
    by installing Webpack and its supporting modules. Let's take a look at the code
    now. We'll start by looking at the markup that's used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个简单的hello world，让我们能够顺利地开始阅读本书的其余部分。我们已经通过安装Webpack及其支持模块来处理了所有样板设置任务。现在让我们看看代码。我们将从使用的标记开始看起。
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not a lot to it is there? There isn''t even content within the `body` tag.
    The important part is the `main-bundle.js` script—this is the code that''s built
    for us by Webpack. Let''s take a look at this code now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有什么复杂的地方，对吧？甚至`body`标签内也没有内容。重要的是`main-bundle.js`脚本——这是Webpack为我们构建的代码。现在让我们看看这段代码：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, there's not much to this hello world Flux application. In fact,
    the only Flux-specific component this code creates is a dispatcher. It then dispatches
    a couple of actions and the handler function that's registered to the store processes
    the actions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个hello world Flux应用并没有什么复杂的地方。实际上，这段代码创建的唯一Flux特定组件是一个分发器。然后它分发几个动作，注册到存储中的处理函数处理这些动作。
- en: Don't worry that there's no stores or views in this example. The idea is that
    we've got the basic Flux NPM package installed and ready to go.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这个示例中没有存储或视图。我们的想法是，我们已经安装并准备好了基本的Flux NPM包。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduced you to Flux. Specifically, we looked at both what Flux
    is and what it isn't. Flux is a set of architectural patterns that, when applied
    to our JavaScript application, help with getting the data-flow aspect of our architecture
    right. Flux isn't yet another framework used for solving specific implementation
    challenges, be it browser quirks or performance gains—there's a multitude of tools
    already available for these purposes. Perhaps the most important defining aspect
    of Flux are the conceptual problems it solves—things like unidirectional data
    flow. This is a major reason that there's no de facto Flux implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Flux。具体来说，我们探讨了Flux是什么以及它不是什么。Flux是一套架构模式，当应用于我们的JavaScript应用程序时，有助于正确处理架构中的数据流方面。Flux并不是用于解决特定实现挑战的另一个框架，无论是浏览器怪癖还是性能提升——已有众多工具可用于这些目的。也许Flux最重要的定义特征是它解决的问题的概念性——比如单向数据流。这是没有默认Flux实现的主要原因之一。
- en: We wrapped the chapter up by walking through the setup of our build components
    used throughout the book. To test that the packages are all in place, we created
    a very basic hello world Flux application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过回顾本书中使用的构建组件的设置来结束本章。为了测试所有包是否就绪，我们创建了一个非常基础的hello world Flux应用程序。
- en: Now that we have a handle on what Flux is, it's time for us to look at why Flux
    is the way it is. In the following chapter, we'll take a more detailed look at
    the principles that drive the design of Flux applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Flux是什么，是时候看看为什么Flux是这样的了。在下一章中，我们将更详细地探讨驱动Flux应用程序设计的原则。
