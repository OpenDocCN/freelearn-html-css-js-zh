- en: Chapter 1. What is Flux?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux is supposed to be this great new way of building complex user interfaces
    that scale well. At least that's the general messaging around Flux, if you're
    only skimming the Internet literature. But, how do we define *this great new way
    of building user interfaces*? What makes it superior to other more established
    frontend architectures?
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this chapter is to cut through the sales bullet points and explicitly
    spell out what Flux is, and what it isn't, by looking at the patterns that Flux
    provides. And since Flux isn't a software package in the traditional sense, we'll
    go over the conceptual problems that we're trying to solve with Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll close the chapter by walking through the core components found
    in any Flux architecture, and we'll install the Flux `npm` package and write a
    hello world Flux application right away. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a set of patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should probably get the harsh reality out of the way first—Flux is not a
    software package. It's a set of architectural patterns for us to follow. While
    this might sound disappointing to some, don't despair—there's good reasons for
    not implementing yet another framework. Throughout the course of this book, we'll
    see the value of Flux existing as a set of patterns instead of a de facto implementation.
    For now, we'll go over some of the high-level architectural patterns put in place
    by Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Data entry points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With traditional approaches to building frontend architectures, we don''t put
    much thought into how data enters the system. We might entertain the idea of data
    entry points, but not in any detail. For example, with **MVC** (**Model View Controller**)
    architectures, the controller is supposed control the flow of data. And for the
    most part, it does exactly that. On the other hand, the controller is really just
    about controlling what happens after it already has the data. How does the controller
    get data in the first place? Consider the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data entry points](img/B05419_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance, there's nothing wrong with this picture. The data-flow, represented
    by the arrows, is easy to follow. But where does the data originate? For example,
    the view can create new data and pass it to the controller, in response to a user
    event. A controller can create new data and pass it to another controller, depending
    on the composition of our controller hierarchy. What about the controller in question—can
    it create data itself and then use it?
  prefs: []
  type: TYPE_NORMAL
- en: In a diagram such as this one, these questions don't have much virtue. But,
    if we're trying to scale an architecture to have hundreds of these components,
    the points at which data enters the system become very important. Since Flux is
    used to build architectures that scale, it considers data entry points an important
    architectural pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is one of those realities we need to cope with in frontend development.
    Unfortunately, we can't compose our entire application of pure functions with
    no side-effects for two reasons. First, our code needs to interact with the DOM
    interface, in one way or another. This is how the user sees changes in the UI.
    Second, we don't store all our application data in the DOM (at least we shouldn't
    do this). As time passes and the user interacts with the application, this data
    will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no cut-and-dry approach to managing state in a web application, but
    there are several ways to limit the amount of state changes that can happen, and
    enforce how they happen. For example, pure functions don''t change the state of
    anything, they can only create new data. Here''s an example of what this looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing state](img/B05419_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there's no side-effects with pure functions because no data
    changes state as a result of calling them. So why is this a desirable trait, if
    state changes are inevitable? The idea is to enforce *where* state changes happen.
    For example, perhaps we only allow certain types of components to change the state
    of our application data. This way, we can rule out several sources as the cause
    of a state change.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is big on controlling where state changes happen. Later on in the chapter,
    we'll see how Flux stores manage state changes. What's important about how Flux
    manages state is that it's handled at an architectural layer. Contrast this with
    an approach that lays out a set of rules that say which component types are allowed
    to mutate application data—things get confusing. With Flux, there's less room
    for guessing where state changes take place.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping updates synchronous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complimentary to data entry points is the notion of update synchronicity. That
    is, in addition to managing where the state changes originate from, we have to
    manage the ordering of these changes relative to other things. If the data entry
    points are the *what* of our data, then synchronously applying state changes across
    all the data in our system is the *when*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about why this matters for a moment. In a system where data is
    updated asynchronously, we have to account for race conditions. Race conditions
    can be problematic because one piece of data can depend on another, and if they''re
    updated in the wrong order, we see cascading problems, from one component to another.
    Take a look at this diagram, which illustrates this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Keeping updates synchronous](img/B05419_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When something is asynchronous, we have no control over when that something
    changes state. So, all we can do is wait for the asynchronous updates to happen,
    and then go through our data and make sure all of our data dependencies are satisfied.
    Without tools that automatically handle these dependencies for us, we end up writing
    a lot of state-checking code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux addresses this problem by ensuring that the updates that take place across
    our data stores are synchronous. This means that the scenario illustrated in the
    preceding diagram isn''t possible. Here''s a better visualization of how Flux
    handles the data synchronization issues that are typical of JavaScript applications
    today:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Keeping updates synchronous](img/B05419_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Information architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's easy to forget that we work in information technology and that we should
    be building technology around information. In recent times, however, we seem to
    have moved in the other direction, where we're forced to think about implementation
    before we think about information. More often than not, the data exposed by the
    sources used by our application doesn't have what the user needs. It's up to our
    JavaScript to turn this raw data into something consumable by the user. This is
    our information architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that Flux is used to design information architectures as opposed
    to a software architecture? This isn't the case at all. In fact, Flux components
    are realized as true software components that perform actual computations. The
    trick is that Flux patterns enable us to think about information architecture
    as a first-class design consideration. Rather than having to sift through all
    sorts of components and their implementation concerns, we can make sure that we're
    getting the right information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Once our information architecture takes shape, the larger architecture of our
    application follows, as a natural extension to the information we're trying to
    communicate to our users. Producing information from data is the difficult part.
    We have to distill many sources of data into not only information, but information
    that's also of value to the user. Getting this wrong is a huge risk for any project.
    When we get it right, we can then move on to the specific application components,
    like the state of a button widget, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Flux architectures keep data transformations confined to their stores. A store
    is an information factory—raw data goes in and new information comes out. Stores
    control how data enters the system, the synchronicity of state changes, and they
    define *how* the state changes. When we go into more depth on stores as we progress
    through the book, we'll see how they're the pillars of our information architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Flux isn't another framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve explored some of the high-level patterns of Flux, it''s time
    to revisit the question: what is Flux again? Well, it is just a set of architectural
    patterns we can apply to our frontend JavaScript applications. Flux scales well
    because it puts information first. Information is the most difficult aspect of
    software to scale; Flux tackles information architecture head on.'
  prefs: []
  type: TYPE_NORMAL
- en: So, why aren't Flux patterns implemented as a framework? This way, Flux would
    have a canonical implementation for everyone to use; and like any other large
    scale open source project, the code would improve over time as the project matures.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is that Flux operates at an architectural level. It's used
    to address information problems that prevent a given application from scaling
    to meet user demand. If Facebook decided to release Flux as yet another JavaScript
    framework, it would likely have the same types of implementation issues that plague
    other frameworks out there. For example, if some component in a framework isn't
    implemented in a way that best suits the project we're working on, then it's not
    so easy to implement a better alternative, without hacking the framework to bits.
  prefs: []
  type: TYPE_NORMAL
- en: What's nice about Flux is that Facebook decided to leave the implementation
    options on the table. They do provide a few Flux component implementations, but
    these are reference implementations. They're functional, but the idea is that
    they're a starting point for us to understand the mechanics of how things such
    as dispatchers are expected to work. We're free to implement the same Flux architectural
    pattern as we see it.
  prefs: []
  type: TYPE_NORMAL
- en: Flux isn't a framework. Does this mean we have to implement everything ourselves?
    No, we do not. In fact, developers are implementing Flux libraries and releasing
    them as open source projects. Some Flux libraries stick more closely to the Flux
    patterns than others. These implementations are opinionated, and there's nothing
    wrong with using them if they're a good fit for what we're building. The Flux
    patterns aim to solve generic conceptual problems with JavaScript development,
    so you'll learn what they are before diving into Flux implementation discussions.
  prefs: []
  type: TYPE_NORMAL
- en: Flux solves conceptual problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If Flux is simply a collection of architectural patterns instead of a software
    framework, what sort of problems does it solve? In this section, we'll look at
    some of the conceptual problems that Flux addresses from an architectural perspective.
    These include unidirectional data-flow, traceability, consistency, component layering,
    and loosely coupled components. Each of these conceptual problems pose a degree
    of risk to our software, in particular the ability to scale it. Flux helps us
    get out in front of these issues as we're building the software.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re creating an information architecture to support the feature-rich application
    that will ultimately sit on top of this architecture. Data flows into the system
    and will eventually reach an endpoint, terminating the flow. It''s what happens
    in between the entry point and the termination point that determines the data-flow
    within a Flux architecture. This is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data flow direction](img/B05419_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data flow is a useful abstraction, because it's easy to visualize data as it
    enters the system and moves from one point to another. Eventually, the flow stops.
    But before it does, several side-effects happen along the way. It's that middle
    block in the preceding diagram that's concerning, because we don't know exactly
    how the data-flow reached the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that our architecture doesn''t pose any restrictions on data flow.
    Any component is allowed to pass data to any other component, regardless of where
    that component lives. Let''s try to visualize this setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data flow direction](img/B05419_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our system has clearly defined entry and exit points for our
    data. This is good because it means that we can confidently say that the data-flows
    through our system. The problem with this picture is with how the data-flows between
    the components of the system. There's no direction, or rather, it's *multidirectional*.
    This isn't a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a *unidirectional* data flow architecture. This means that the preceding
    component layout isn't possible. The question is—why does this matter? At times,
    it might seem convenient to be able to pass data around in any direction, that
    is, from any component to any other component. This in and of itself isn't the
    issue—passing data alone doesn't break our architecture. However, when data moves
    around our system in more than one direction, there's more opportunity for components
    to fall out of sync with one another. This simply means that if data doesn't always
    move in the same direction, there's always the possibility of ordering bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux enforces the direction of data-flows, and thus eliminates the possibility
    of components updating themselves in an order that breaks the system. No matter
    what data has just entered the system, it''ll always flow through the system in
    the same order as any other data, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data flow direction](img/B05419_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Predictable root cause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With data entering our system and flowing through our components in one direction,
    we can more easily trace any effect to it's cause. In contrast, when a component
    sends data to any other component residing in any architectural layer, it's a
    lot more difficult to figure how the data reached its destination. Why does this
    matter? Debuggers are sophisticated enough that we can easily traverse any level
    of complexity during runtime. The problem with this notion is that it presumes
    we only need to trace what's happening in our code for the purposes of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Flux architectures have inherently predictable data-flows. This is important
    for a number of design activities and not just debugging. Programmers working
    on Flux applications will begin to intuitively sense what's going to happen. Anticipation
    is key, because it let's us avoid design dead-ends before we hit them. When the
    cause and effect are easy to tease out, we can spend more time focusing on building
    application features—the things the customers care about.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The direction in which we pass data from component to component in Flux architectures
    should be consistent. In terms of consistency, we also need to think about the
    mechanism used to move data around our system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, publish/subscribe (pub/sub) is a popular mechanism used for inter-component
    communication. What's neat about this approach is that our components can communicate
    with one another, and yet we're able to maintain a level of decoupling. In fact,
    this is fairly common in frontend development because component communication
    is largely driven by user events. These events can be thought of as fire-and-forget.
    Any other components that want to respond to these events in some way, need to
    take it upon themselves to subscribe to the particular event.
  prefs: []
  type: TYPE_NORMAL
- en: While pub/sub does have some nice properties, it also poses architectural challenges,
    in particular scaling complexities. For example, let's say that we've just added
    several new components for a new feature. Well, in which order do these components
    receive update messages relative to pre-existing components? Do they get notified
    after all the pre-existing components? Should they come first? This presents a
    data dependency scaling issue.
  prefs: []
  type: TYPE_NORMAL
- en: The other challenge with pub-sub is that the events that get published are often
    fine-grained to the point where we'll want to subscribe and later unsubscribe
    from the notifications. This leads to consistency challenges because trying to
    code lifecycle changes when there's a large number of components in the system
    is difficult and presents opportunities for missed events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea with Flux is to sidestep the issue by maintaining a static inter-component
    messaging infrastructure that issues notifications to every component. In other
    words, programmers don''t get to pick and choose the events their components will
    subscribe to. Instead, they have to figure out which of the events that are dispatched
    to them are relevant, ignoring the rest. Here''s a visualization of how Flux dispatches
    events to components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consistent notifications](img/B05419_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Flux dispatcher sends the event to every component; there's no getting around
    this. Instead of trying to fiddle with the messaging infrastructure, which is
    difficult to scale, we implement logic within the component to determine whether
    or not the message is of interest. It's also within the component that we can
    declare dependencies on other components, which helps influence the ordering of
    messages. We'll cover this in much more detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Simple architectural layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Layers can be a great way to organize an architecture of components. For one
    thing, it''s an obvious way to categorize the various components that make up
    our application. For another thing, layers serve as a means to put constraints
    around communication paths. This latter point is especially relevant to Flux architectures
    since it''s important that data flow in one direction. It''s much easier to apply
    constraints to layers than it is to individual components. Here is an illustration
    of Flux layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple architectural layers](img/B05419_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This diagram isn't intended to capture the entire data flow of a Flux architecture,
    just how data-flows between the main three layers. It also doesn't give any detail
    about what's in the layers. Don't worry, the next section gives introductory explanations
    of the types of Flux components, and the communication that happens between the
    layers is the focus of this book.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the data-flows from one layer to the next, in one direction.
    Flux only has a few layers, and as our applications scale in terms of component
    counts, the layer counts remains fixed. This puts a cap on the complexity involved
    with adding new features to an already large application. In addition to constraining
    the layer count and the data-flow direction, Flux architectures are strict about
    which layers are actually allowed to communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the action layer could communicate with the view layer, and we
    would still be moving in one direction. We would still have the layers that Flux
    expects. However, skipping a layer like this is prohibited. By ensuring that layers
    only communicate with the layer directly beneath it, we can rule out bugs introduced
    by doing something out-of-order.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One decision made by the Flux designers that stands out is that Flux architectures
    don't care how UI elements are rendered. That is to say, the view layer is loosely
    coupled to the rest of the architecture. There are good reasons for this.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is an information architecture first, and a software architecture second.
    We start with the former and graduate toward the latter. The challenge with view
    technology is that it can exert a negative influence on the rest of the architecture.
    For example, one view has a particular way of interacting with the DOM. Then,
    if we've already decided on this technology, we'll end up letting it influence
    the way our information architecture is structured. This isn't necessarily a bad
    thing, but it can lead to us making concessions about the information we ultimately
    display to our users.
  prefs: []
  type: TYPE_NORMAL
- en: What we should really be thinking about is the information itself and how this
    information changes over time. What actions are involved that bring about these
    changes? How is one piece of data dependent on another piece of data? Flux naturally
    removes itself from the browser technology constraints of the day so that we can
    focus on the information first. It's easy to plug views into our information architecture
    as it evolves into a software product.
  prefs: []
  type: TYPE_NORMAL
- en: Flux components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll begin our journey into the concepts of Flux. These concepts
    are the essential ingredients used in formulating a Flux architecture. While there's
    no detailed specifications for how these components should be implemented, they
    nevertheless lay the foundation of our implementation. This is a high-level introduction
    to the components we'll be implementing throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actions are the *verbs* of the system. In fact, it''s helpful if we derive
    the name of an action directly from a sentence. These sentences are typically
    statements of functionality – something we want the application to do. Here are
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate to the settings page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter the user list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggle the visibility of the details section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are simple capabilities of the application, and when we implement them
    as part of a Flux architecture, actions are the starting point. These human-readable
    action statements often require other new components elsewhere in the system,
    but the first step is always an action.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what exactly is a Flux action? At it''s simplest, an action is nothing
    more than a string—a name that helps identify the purpose of the action. More
    typically, actions consist of a *name* and a *payload*. Don''t worry about the
    payload specifics just yet—as far as actions are concerned, they''re just opaque
    pieces of data being delivered into the system. Put differently, actions are like
    mail parcels. The entry point into our Flux system doesn''t care about the internals
    of the parcel, only that they get to where they need to go. Here''s an illustration
    of actions entering a Flux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Action](img/B05419_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram might give the impression that actions are external to Flux, when
    in fact they're an integral part of the system. The reason this perspective is
    valuable is because it forces us to think about actions as the only means to deliver
    new data into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Golden Flux Rule**: If it''s not an action, it can''t happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dispatcher in a Flux architecture is responsible for distributing actions
    to the store components (we''ll talk about stores next). A dispatcher is actually
    kind of like a broker—if actions want to deliver new data to a store, they have
    to talk to the broker, so it can figure out the best way to deliver them. Think
    about a message broker in a system like RabbitMQ. It''s the central hub where
    everything is sent before it''s actually delivered. Here is a diagram depicting
    a Flux dispatcher receiving actions and dispatching them to stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dispatcher](img/B05419_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The earlier section of this chapter—"simple architectural layers"—didn't have
    an explicit layer for dispatchers. That was intentional. In a Flux application,
    there's only one dispatcher. It can be thought of more as a pseudo layer than
    an explicit layer. We know the dispatcher is there, but it's not essential to
    this level of abstraction. What we're concerned about at an architectural level
    is making sure that when a given action is dispatched, we know that it's going
    to make it's way to every store in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the dispatcher's role is critical to how Flux works. It's
    the place where store callback functions are registered and it's how data dependencies
    are handled. Stores tell the dispatcher about other stores that it depends on,
    and it's up to the dispatcher to make sure these dependencies are properly handled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Golden Flux Rule**: The dispatcher is the ultimate arbiter of data dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stores are where state is kept in a Flux application. Typically, this means
    the application data that's sent to the frontend from the API. However, Flux stores
    take this a step further and explicitly model the state of the entire application.
    If this sounds confusing or like a generally bad idea, don't worry—we'll clear
    this up as we make our way through subsequent chapters. For now, just know that
    stores are where state that matters can be found. Other Flux components don't
    have state—they have implicit state at the code level, but we're not interested
    in this, from an architectural point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions are the delivery mechanism for new data entering the system. The term
    *new data* doesn''t imply that we''re simply appending it to some collection in
    a store. All data entering the system is new in the sense that it hasn''t been
    dispatched as an action yet—it could in fact result in a store changing state.
    Let''s look at a visualization of an action that results in a store changing state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Store](img/B05419_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key aspect of how stores change state is that there's no external logic
    that determines a state change should happen. It's the store, and only the store,
    that makes this decision and then carries out the state transformation. This is
    all tightly encapsulated within the store. This means that when we need to reason
    about particular information, we need not look any further than the stores. They're
    their own boss—they're self-employed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Golden Flux Rule**: Stores are where state lives, and only stores themselves
    can change this state.'
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last Flux component we''re going to look at in this section is the view,
    and it technically isn''t even a part of Flux. At the same time, views are obviously
    a critical part of our application. Views are almost universally understood as
    the part of our architecture that''s responsible for displaying data to the user—it''s
    the last stop as data-flows through our information architecture. For example,
    in MVC architectures, views take model data and display it. In this sense, views
    in a Flux-based application aren''t all that different from MVC views. Where they
    differ markedly is with regard to handling events. Let''s take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![View](img/B05419_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see the contrasting responsibilities of a Flux view, compared with
    a view component found in your typical MVC architecture. The two view types have
    similar types of data flowing into them—application data used to render the component
    and events (often user input). What's different between the two types of view
    is what flows out of them.
  prefs: []
  type: TYPE_NORMAL
- en: The typical view doesn't really have any constraints in how its event handler
    functions communicate with other components. For example, in response to a user
    clicking a button, the view could directly invoke behavior on a controller, change
    the state of a model, or it might query the state of another view. On the other
    hand, the Flux view can only dispatch new actions. This keeps our single entry
    point into the system intact and consistent with other mechanisms that want to
    change the state of our store data. In other words, an API response updates state
    in the exact same way as a user clicking a button does.
  prefs: []
  type: TYPE_NORMAL
- en: Given that views should be restricted in terms of how data-flows out of them
    (besides DOM updates) in a Flux architecture, you would think that views should
    be an actual Flux component. This would make sense insofar as making actions the
    only possible option for views. However, there's also no reason we can't enforce
    this now, with the benefit being that Flux remains entirely focused on creating
    information architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, however, that Flux is still in it's infancy. There's no doubt
    going to be external influences as more people start adopting Flux. Maybe Flux
    will have something to say about views in the future. Until then, views exist
    outside of Flux but are constrained by the unidirectional nature of Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Golden Flux Rule**: The only way data-flows out of a view is by dispatching
    an action.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Flux package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll close the first chapter by getting our feet wet with some code, because
    everyone needs a hello world application under their belt. We'll also get some
    of our boilerplate code setup tasks out of the way too, since we'll be using a
    similar setup throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll skip going over Node + NPM installation since it's sufficiently covered
    in great detail all over the Internet. We'll assume Node is installed and ready
    to go from this point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first NPM package we''ll need installed is Webpack. This is an advanced
    module bundler that''s well suited for modern JavaScript applications, including
    Flux-based applications. We''ll want to install this package globally so that
    the `webpack` command gets installed on our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With Webpack in place, we can build each of the code examples that ship with
    this book. However, our project does require a couple of local NPM packages, and
    these can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--save-dev` option adds these development dependencies to our file, if
    one exists. This is just to get started—it isn''t necessary to manually install
    these packages to run the code examples in this book. The examples you''ve downloaded
    already come with a `package.json`, so to install the local dependencies, simply
    run the following from within the same directory as the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now the `webpack` command can be used to build the example. This is the only
    example in the first chapter, so it's easy to navigate to within a terminal window
    and run the `webpack` command, which builds the `main-bundle.js` file. Alternatively,
    if you plan on playing with the code, which is obviously encouraged, try running
    `webpack --watch`. This latter form of the command will monitor for file changes
    to the files used in the build, and run the build whenever they change.
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed a simple hello world to get us off to a running start, in preparation
    for the remainder of the book. We've taken care of all the boilerplate setup tasks
    by installing Webpack and its supporting modules. Let's take a look at the code
    now. We'll start by looking at the markup that's used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Not a lot to it is there? There isn''t even content within the `body` tag.
    The important part is the `main-bundle.js` script—this is the code that''s built
    for us by Webpack. Let''s take a look at this code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's not much to this hello world Flux application. In fact,
    the only Flux-specific component this code creates is a dispatcher. It then dispatches
    a couple of actions and the handler function that's registered to the store processes
    the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry that there's no stores or views in this example. The idea is that
    we've got the basic Flux NPM package installed and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to Flux. Specifically, we looked at both what Flux
    is and what it isn't. Flux is a set of architectural patterns that, when applied
    to our JavaScript application, help with getting the data-flow aspect of our architecture
    right. Flux isn't yet another framework used for solving specific implementation
    challenges, be it browser quirks or performance gains—there's a multitude of tools
    already available for these purposes. Perhaps the most important defining aspect
    of Flux are the conceptual problems it solves—things like unidirectional data
    flow. This is a major reason that there's no de facto Flux implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped the chapter up by walking through the setup of our build components
    used throughout the book. To test that the packages are all in place, we created
    a very basic hello world Flux application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on what Flux is, it's time for us to look at why Flux
    is the way it is. In the following chapter, we'll take a more detailed look at
    the principles that drive the design of Flux applications.
  prefs: []
  type: TYPE_NORMAL
