<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application Testing</h1>
                </header>
            
            <article>
                
<p>In <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, we learned how to write unit tests and generate a test coverage report. However, application testing is a very extensive subject, and we barely touched its surface.</p>
<p>In this chapter, we are going to learn how to write multiple kinds of automated tests for a TypeScript application. We are going to cover the following topics:</p>
<ul>
<li>Testing terminology</li>
<li>Testing planning and methodologies</li>
<li>Writing unit tests</li>
<li>Isolating components during tests</li>
<li>Writing integration tests</li>
<li>Writing end-to-end (e2e) tests</li>
</ul>
<p>We are going to get started by learning about the core terminology used in the field of software testing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing terminology</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we are going to use some concepts that may not be familiar to readers without previous experience in the field of software testing. For this reason, we are going to take a quick look at some of the most popular concepts in software testing before we get started.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Assertions</h1>
                </header>
            
            <article>
                
<p>An <strong>assertion</strong> is a condition that must be tested to confirm that a certain piece of code behaves as expected, or, in other words, to confirm conformance to a requirement.</p>
<p>Let's imagine that we are working as part of the Google Chrome development team, and we must implement the JavaScript <kbd>Math</kbd> API. If we are working on the <kbd>pow</kbd> method, the requirement could be something like, the <kbd>Math.pow</kbd> (base, exponent) function should return the base (the base number) to the exponent (the exponent used to raise the base) power-that is, base <kbd>^</kbd> exponent.</p>
<p>With this information, we could create the following implementation:</p>
<pre>class MathAPI { 
    public static pow(base: number, exponent: number) { 
        let result = base; 
        for (var i = 1; i &lt; exponent; i++) { 
            result = result * base; 
        } 
        return result; 
    } 
} </pre>
<div class="packt_infobox">Please note that we use the name <kbd>MathAPI</kbd> instead of <kbd>Math</kbd> in this example because the <kbd>Math</kbd> variable is already declared by the real JavaScript Math API.</div>
<p>To ensure that the method is correctly implemented, we must test its accordance with the requirement. If we analyze the requirements closely, we should identify at least two necessary assertions:</p>
<ul>
<li>The function should return the base to the exponent:</li>
</ul>
<pre style="padding-left: 60px">const actual1 = MathApi.pow(3, 5);<br/>const expected1 = 243;<br/>const asertion1 = actual1 === expected1;<br/><br/>if (asertion1 === false) {<br/>    throw new Error(<br/>        `Expected 'actual1' to be ${expected1} ` +<br/>        `but got ${actual1}!`<br/>    );<br/>}</pre>
<ul>
<li>The exponent is not being used as the base (or the base is not used as the exponent):</li>
</ul>
<pre style="padding-left: 60px">const actual2 = MathApi.pow(5, 3);<br/>const expected2 = 125;<br/>const asertion2 = actual2 === expected2;<br/><br/>if (asertion2 === false) {<br/>    throw new Error(<br/>        `Expected 'actual2' to be ${expected2} ` +<br/>        `but got ${actual2}!`<br/>    );<br/>}</pre>
<p>If both assertions are valid, then our code adheres to the requirements, and we know that it will work as expected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Specs</h1>
                </header>
            
            <article>
                
<p><strong>Spec </strong>is a term used by software development engineers to refer to test specifications. A test specification (not to be confused with a test plan) is a detailed list of all the scenarios that should be tested and how they should be tested, as well as other details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test coverage</h1>
                </header>
            
            <article>
                
<p>The term <strong>test coverage</strong> refers to a unit of measurement, which is used to illustrate the number of portions of code in an application that have been tested via an automated test. Test coverage can be obtained by automatically generating test coverage reports.</p>
<div class="packt_infobox">Refer to <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Automating Your Development Workflow</em>, to learn how to generate a test coverage report.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test cases</h1>
                </header>
            
            <article>
                
<p>A <strong>test case</strong> is a set of conditions used to determine whether one of the features of an application is working as it was originally intended to work. We might wonder what the difference between a test assertion and a test case is. While a test assertion is a single condition, a test case is a set of conditions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Suites</h1>
                </header>
            
            <article>
                
<p>A <strong>suite</strong> is a collection of test cases. While a test case should focus on only one test scenario, a test suite can contain test cases for many test scenarios.</p>
<div class="packt_infobox">We will learn how to define assertions, test cases, and test suites later in this chapter, in the <em>Unit tests and integration tests with Mocha</em> section).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spies</h1>
                </header>
            
            <article>
                
<p><strong>Spies</strong> are a feature provided by some testing frameworks. They allow us to wrap a method or function and record its usage. We can record things such as the method or function arguments, their return type, or the number of times that they have been invoked. When we wrap a method or function with a spy, the underlying method's functionality does not change.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dummies</h1>
                </header>
            
            <article>
                
<p>A <strong>dummy</strong> object is an object that is passed around during the execution of a test, but it is never actually used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stubs</h1>
                </header>
            
            <article>
                
<p>A <strong>stub</strong> is a feature provided by some testing frameworks. Like spies, stubs also allow us to wrap a method or function to record its usage. Unlike in the case of spies, when we wrap a function with a stub, the underlying method's functionality is replaced with new behavior.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mocks</h1>
                </header>
            
            <article>
                
<p>Mocks are often confused with stubs. Martin Fowler once wrote the following in an article titled <em>Mocks Aren't Stubs</em>:</p>
<div class="packt_quote">"In particular, I see them (mocks) often confused with stubs - a common helper to testing environments. I understand this confusion - I saw them as similar for a while too, but conversations with the mock developers have steadily allowed a little mock understanding to penetrate my tortoiseshell cranium. This difference is actually two separate differences. On the one hand, there is a difference in how test results are verified: a distinction between state verification and behavior verification. On the other hand, is a whole different philosophy to the way testing and design play together, which I term here as the classical and mockist styles of Test Driven Development."</div>
<p>Both mocks and stubs provide some input to the test case, but despite their similarities, the flow of information from each is very different:</p>
<ul>
<li>Stubs provide input for the application under test so that the test can be performed on something else. Stubs are used to replace behavior.</li>
<li>Mocks provide input to the test to decide whether the test should pass or fail. Mocks are used to declare an expectation.</li>
</ul>
<p>The difference between mocks and stubs will become clearer as we move towards the end of this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we will be using third-party tools. In this section, we are going to learn how to install these. Before we get started, however, we need to use npm to create a <kbd>package.json</kbd> file in the folder that we are going to use to implement the examples in this chapter.</p>
<p>Let's create a new folder and go inside it to generate a new <kbd>package.json</kbd> file using the <kbd>npm init</kbd> command:</p>
<pre><strong>npm init</strong>  </pre>
<div class="packt_infobox">Please refer to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Working with Dependencies</em>, for additional information about npm.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mocha</h1>
                </header>
            
            <article>
                
<p>Mocha is a popular JavaScript testing library that facilitates the creation of test suites, test cases, and test specs. Mocha can be used to test TypeScript in the frontend and backend, identify performance issues, and generate different types of test reports, among many other functions. We can install Mocha using the following command:</p>
<pre><strong>npm install --save-dev mocha @types/mocha</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chai</h1>
                </header>
            
            <article>
                
<p>Chai is a test-assertion library that supports <strong>test-driven development</strong> (<strong>TDD</strong>) and <strong>behavior-driven development</strong> (<strong>BDD</strong>) test styles. The main goal of Chai is to reduce the amount of work necessary to create a test assertion and make the test more readable. We can install Chai using the following command:</p>
<pre><strong>npm install --save-dev chai @types/chai</strong>  </pre>
<div class="packt_infobox">Please note that we are going to learn more about TDD and BDD later in this chapter in the section titled <em>Testing methodologies</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sinon.JS</h1>
                </header>
            
            <article>
                
<p>Sinon.JS is a library that provides us with a set of APIs that can help us to test a component in isolation, thanks to its usage of spies, stubs, and mocks. Testing software components can be very difficult when there is a high level of coupling between them. However, a library such as Sinon.JS can help us isolate the components to test their features. We can install Sinon.JS using the following command:</p>
<pre><strong>npm install --save-dev sinon @types/sinon</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">nyc</h1>
                </header>
            
            <article>
                
<p>As we already learned in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, we can use nyc to generate test coverage reports for our applications. We can install nyc using the following command:</p>
<pre><strong>npm install --save-dev nyc</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Webpack</h1>
                </header>
            
            <article>
                
<p>As we already learned in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, we can use nyc to generate test coverage reports for our applications. We can install Webpack and some additional plugins using the following command:</p>
<pre><strong>npm install --save-dev webpack css-loader extract-text-webpack-plugin node-sass sass-loader style-loader</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enzyme</h1>
                </header>
            
            <article>
                
<p>Enzyme is an open source testing library developed by Airbnb that can help us to test React components. We can install enzyme using the following command:</p>
<pre><strong>npm install --save-dev enzyme enzyme-adapter-react-16 @types/enzyme @types/ enzyme-adapter-react-16</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SuperTest</h1>
                </header>
            
            <article>
                
<p>SuperTest is a library that can help us to test HTTP web services developed with Node.js and Express.js. We can install SuperTest using the following command:</p>
<pre><strong>npm install supertest @types/supertest</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PM2</h1>
                </header>
            
            <article>
                
<p>PM2 is a production process manager for Node.js applications with a built-in load balancer. PM2 allows us to run a Node.js application as a background process, which is something that we are going to need to run our e2e tests. We can install PM2 using the following command:</p>
<pre><strong>npm install pm2</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Nightwatch.js and ChromeDriver</h1>
                </header>
            
            <article>
                
<p>Nightwatch.js is a library that helps us to implement <strong>end-to-end</strong> (<strong>e2e</strong>) tests. We also need a tool known as ChromeDriver. Nightwatch.js can run our test in multiple web browsers, but in our example, we are going use Google Chrome. The <kbd>chromedriver</kbd> library is an adapter that allows Nightwatch.js to communicate with Google Chrome during the test's execution. We can install Nightwatch.js and ChromeDriver using the following command:</p>
<pre><strong>npm install chromedriver nightwatch @types/nightwatch</strong></pre>
<div class="packt_infobox">Refer to the companion source code to check the exact versions used in the <kbd>package.json</kbd> file. If you use <kbd>npm install</kbd>, the latest version will be installed by default. The version used in these examples might become outdated over time, which could lead to some configuration issues. If you want to use the latest version (which is recommended), you will have to check the documentation of each of the modules to learn about potential breaking changes.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing methodologies</h1>
                </header>
            
            <article>
                
<p>Every time we develop a new application, we need to make a lot of decisions. For example, we need to choose the type of database, architecture, libraries, and frameworks that we will use. However, not all our choices are about technologies, and we can also choose a software development methodology, such as extreme programming or scrum. When it comes to testing, there are two major styles or methodologies: TDD and BDD.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test-driven development (TDD)</h1>
                </header>
            
            <article>
                
<p>Test-driven development is a testing methodology that focuses on encouraging developers to write tests before they write application code. Usually, the process of writing code in TDD consists of the following basic steps:</p>
<ol>
<li>Write a test that fails. There is no application code at this point, so the test should fail.</li>
<li>Run the test and ensure that it fails.</li>
<li>Write the code to pass the test.</li>
<li>Run the test and ensure that it works.</li>
</ol>
<ol start="5">
<li>Run all the other existing tests to ensure that no other parts of the application are broken because of the changes.</li>
<li>Repeat the process for every new feature or bug fix.</li>
</ol>
<p>This process is often represented as the "red-green-refactor" diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-305 image-border" src="Images/0c6d09aa-720f-4c36-899b-80f169a96f25.png" style="width:32.67em;height:19.00em;" width="1329" height="773"/></div>
<p>The choice between using TDD or not comes down to the mindset you wish to adopt. Many developers don't like writing tests, so the chances are that if we leave their implementation as the last task in the development process, the tests will never be implemented or the application will just be partially tested. It is also possible that the application could be implemented in a way that is harder to test. If we are planning to write a test, doing it upfront can lead to a reduction in the implementation cost.</p>
<p>TDD is recommended because it effectively helps you and your team to increase the test coverage of your applications and, therefore, significantly reduce the number of potential issues, which eventually ends up saving money.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Behavior-driven development (BDD)</h1>
                </header>
            
            <article>
                
<p>Behavior-driven development appeared after TDD, with the mission of being a refined version of TDD. BDD focuses on the way tests are described (specs) and states that the tests should focus on the application requirements and not the test requirements. Ideally, this will encourage developers to think less about the tests themselves and think more about the entire application.</p>
<div class="packt_infobox">The original article in which the BDD principles were introduced by <em>Dan North</em> is available at <a href="http://dannorth.net/introducing-bdd/"><span class="URLPACKT">http://dannorth.net/introducing-bdd/</span></a>.</div>
<p>As we have already learned, Mocha and Chai provide APIs for both the TDD and BDD approaches. Later in this chapter, we will further explore these two approaches.</p>
<p>Recommending one of these methodologies is not trivial because TDD and BDD are both good testing methodologies. However, BDD was developed after TDD with the objective of improving it, so we can argue that BDD has some additional advantages over TDD. In BDD, the description of a test focuses on what the application should do and not what the test code is testing. This can help the developers to identify tests that reflect the behavior desired by the customer. BDD tests can be used to document the requirements of a system in a way that can be understood and validated by both the developer and the customer. This is a clear advantage over TDD tests, as TDD tests cannot be understood with ease by the customer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tests plans and test types</h1>
                </header>
            
            <article>
                
<p>The term "test plan" is sometimes incorrectly used to refer to a test specification. While test specifications define the scenarios that will be tested and how they will be tested, a test plan is a collection of all the test specs for a given area.</p>
<p>It is recommended that you create an actual planning document, because a test plan can involve many processes, documents, and practices. One of the main goals of a test plan is to identify and define what kind of test is adequate for a component or set of components in an application. The following are the most commonly used test types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>These are used to test an isolated component. If the component is not isolated—that is, if the component has some dependencies—we will have to use some tools and practices, such as stubs or dependency injections, to try to isolate it as much as we can during the test. If it is not possible to manipulate the component's dependencies, we will use spies to facilitate the creation of the unit tests. Our main goal should be to achieve the total isolation of a component when it is tested. A unit test should also be fast, and we should try to avoid input/output, network usage, and any other operations that could potentially affect the speed of the test.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integration tests</h1>
                </header>
            
            <article>
                
<p>Integration tests are used to test a set of components (partial-integration test) or the entire application (full-integration test). In integration, we will normally use known test data to feed the backend with information that will be displayed on the frontend. We will then assert that the displayed information is correct.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Regression tests</h1>
                </header>
            
            <article>
                
<p>Regression tests are used to verify that an issue has been fixed. If we are using TDD or BDD, whenever we encounter an issue, we should create a unit test that reproduces the issue before we fix the issue. By doing this, we will be able to reproduce past issues and ensure that we don't have to deal with the same issue ever again.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance and load tests</h1>
                </header>
            
            <article>
                
<p>Performance and load tests verify whether the application meets our performance expectations. We can use performance tests to verify that our application will be able to handle many concurrent users or activity spikes. To learn more about this type of test, look at <a href="2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml">Chapter 13</a>, <em>Application Performance</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">End-to-end (e2e) tests</h1>
                </header>
            
            <article>
                
<p>End-to-end tests are not that different from full-integration tests. The main difference is that in an e2e testing session, we will try to emulate an environment that is almost identical to the real user environment. We will use Nightwatch.js and ChromeDriver for this purpose.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">User-acceptance tests (UAT)</h1>
                </header>
            
            <article>
                
<p>User-acceptance tests help us to ensure that the system meets all the requirements of the end users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The example application</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to develop an entire web application. The application itself is not a very realistic example, but should be realistic enough to demonstrate many kinds of testing practices and technologies. We are going to develop a calculator that can perform the <kbd>pow</kbd> operation. The calculator application is composed of the following components:</p>
<ul>
<li>A graphic user interface that is implemented using React, and fetches the result of the <kbd>pow</kbd> operation from a web service using an HTTP client</li>
<li>A web service that is implemented using Node.js and Express.js, and finds the result of the <kbd>pow</kbd> operation using a small math library</li>
</ul>
<p>The application's graphic user interface looks as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-306 image-border" src="Images/cd3ea0db-790e-4a0e-9f3c-d7ab03ecb36b.png" style="width:39.33em;height:4.58em;" width="1087" height="126"/></div>
<p>We are going to define many different automated tasks using npm scripts. Each task uses different tools, and some tasks must take place before others. We could use a more complex setup to run some tasks in parallel and reduce the execution time of the whole process, or use a more realistic application, but we want to keep things as simple as possible to focus on the test techniques and tools.</p>
<p>We are going to define the following tasks in our <kbd>package.json</kbd> file:</p>
<pre>"scripts": { 
  "all": "npm run clean &amp;&amp; npm install &amp;&amp; npm run lint &amp;&amp; npm run build &amp;&amp; npm test", 
  "clean": "rimraf ./dist ./public", 
  "start": "./node_modules/.bin/pm2 start ./dist/src/backend/main.js", 
  "kill": "./node_modules/.bin/pm2 kill", 
  "lint": "tslint --project tsconfig.json -c tslint.json ./src/**/*.ts ./test/**/*.ts", 
  "build": "npm run build-frontend &amp;&amp; npm run build-e2e", 
  "build-frontend": "webpack", 
  "build-e2e": "tsc -p tsconfig.e2e.json", 
  "test": "npm run nyc &amp;&amp; npm run e2e", 
  "nyc": "nyc --clean --all -x webpack.config.js -x test/*.e2e.ts -x public -x dist -x globals.js --require ./jsdom.js --require isomorphic-fetch --require ts-node/register --extension .ts -- mocha --timeout 5000 **/*.test.ts **/*.test.tsx", 
  "e2e": "npm run start &amp;&amp; npm run nw &amp;&amp; npm run kill", 
  "nw": "nightwatch --config nightwatch.json", 
  "coverage": "nyc report --reporter=text --reporter=lcov" 
}, </pre>
<div class="packt_infobox">If you are using Windows, the commands defined in the preceding code will fail because the relative paths use the Unix notation. You can solve this problem by installing Git and then installing Git Bash on Windows from <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>, and then setting up npm to use Git Bash using the following command:<br/>
<kbd>npm config set script-shell "C:Program FilesGitbinbash.exe"</kbd><br/>
You might also need to install Python and the C++ build tools because both are required by the <kbd>node-sass</kbd> module.<br/>
<span>Remember that the entire source code is included in the companion source code.</span></div>
<p class="mce-root CDPAlignLeft CDPAlign">The process has been designed in a way that allows us to run it entirely by using the <kbd>npm run all</kbd> command. This command will execute all the other tasks in order, as described in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:39.17em;height:23.92em;" class="alignnone size-full wp-image-307 image-border" src="Images/6e61d224-ac63-4152-9d05-5e34a65b775b.png" width="1354" height="828"/></div>
<p>The preceding diagram allows us to visualize which tasks are initialized by a parent task. For example, the clean, install, lint, build, and test tasks are all started by the <strong>all</strong> task. The diagram also helps us to visualize the order in which the tasks are executed. For example, we can see that the first task is the <strong>all</strong> task and the last task is the <strong>kill</strong> task.</p>
<p>We will now examine the purpose of each of these tasks:</p>
<ul>
<li>The <strong>all</strong> task is the root task, and it is used to start other tasks.</li>
<li>The <strong>clean</strong> task removes some of the previous outputs to ensure that results are not influenced by any cache issues.</li>
<li>The <strong>install</strong> task downloads all the required dependencies.</li>
<li>The <strong>lint</strong> task enforces some code-styling rules.</li>
<li>The <strong>build</strong> task starts the compilation tasks for both frontend and end-to-end tests. Compilation for the backend and the unit tests is not required because the tools used (nyc and ts-node) don't require it.</li>
<li>The <strong>build_e2e</strong> task compiles the e2e tests using tsc.</li>
<li>The <strong>build_frontend</strong> task compiles the frontend application using Webpack.</li>
<li>The <strong>test</strong> task runs both the unit tests with nyc and the e2e tests with Nightwatch.js.</li>
<li>The <strong>nyc</strong> task runs the unit tests and integration tests, and generates a test-coverage report.</li>
<li>The <strong>e2e</strong> task runs the e2e tests. Before we run the e2e tests, we need to serve the application using a web server, and we will also need to stop serving the application once we are done.</li>
<li>The <strong>start</strong> task uses PM2 to starts the Node.js process that serves the application.</li>
<li>The <strong>nw</strong> task stands for Nightwatch.js, and is used to execute the e2e tests.</li>
<li>The <strong>kill</strong> task uses PM2 to stop the Node.js process that serves the application.</li>
</ul>
<p>We shouldn't worry too much if we don't understand what the mission is of each of the tasks or tools mentioned in the preceding list, because we are going to spend the rest of this chapter learning about them in detail, except for the clean, install, lint and build tasks, because we have already learned about these tasks in previous chapters.</p>
<div class="packt_infobox">Refer to <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Automa</em><em>ting Your Development Workflow</em>, <span>to learn how to generate a test-coverage report.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit tests and integration tests with Mocha</h1>
                </header>
            
            <article>
                
<p>In <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, we learned the basic details of the unit tests<span> and test-coverage reports with nyc, ts-node, Mocha, and Chai. In this chapter, we are going to learn how to test asynchronous APIs using Mocha and how to combine Mocha with other powerful tools, such as Sinon.JS, SuperTest, and Enzyme:</span></p>
<ul>
<li>We are going to learn how to write tests for every layer of an application.</li>
<li>We are going to start by testing a math library used in the backend.</li>
<li>We will then test a web service, which consumes the math library, and a client, which consumes the web service.</li>
<li>We will finish the section by writing tests for the graphic user interface and creating some e2e tests.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Back to basics</h1>
                </header>
            
            <article>
                
<p>The companion source code includes a class named <kbd>MathDemo</kbd>. This class allows us to perform the <kbd>pow</kbd> calculation in a few different ways. One of them is the synchronous <kbd>pow</kbd> function:</p>
<pre>public pow(base: number, exponent: number) { <br/><br/>  let result = base; 
  for (let i = 1; i &lt; exponent; i++) { 
    result = result * base; 
  } 
  return result; 
} </pre>
<p>As we learned in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, we can test the method declared in the preceding function using the following test case:</p>
<pre>it("Should return the correct numeric value for pow", () =&gt; { 
  const math = new MathDemo(); 
  const result = math.pow(2, 3); 
  const expected = 8; 
  expect(result).to.be.a("number"); 
  expect(result).to.equal(expected); 
}); </pre>
<p>We can then use the <kbd>nyc</kbd> command with ts-node and Mocha to run our tests and generate a test-coverage report. In the companion source code, this is wrapped with npm scripts as the following command to facilitate the usage:</p>
<pre><strong>npm run nyc</strong> </pre>
<p>If everything goes according to plan, we should see a list of all the tests that have been executed. The result generated by the tests that were included in the companion source code should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:45.17em;height:33.67em;" class="alignnone size-full wp-image-308 image-border" src="Images/4bf922d0-0900-4999-a882-59206c64d969.png" width="1259" height="938"/></p>
<p>The command should also generate a test coverage report as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:54.58em;height:22.67em;" class="alignnone size-full wp-image-309 image-border" src="Images/f485c5ad-6c53-4ea6-b6d4-08de7bcf0855.png" width="1388" height="578"/></div>
<p>Once we have executed our tests with the <kbd>nyc</kbd> command, we can generate a test coverage report by running the following command:</p>
<pre><strong>nyc report --reporter=text --reporter=lcov</strong> </pre>
<p>This will generate a folder named <kbd>coverage</kbd> in the current directory. The coverage folder contains some HTML files that we can open using a web browser:</p>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:213.33em;height:51.50em;" class="alignnone size-full wp-image-310 image-border" src="Images/f6c95fc0-ba15-461c-aecf-3fc52a48829e.png" width="2560" height="618"/></div>
<p>If we click on one of the files, we will be able to see a line-by-line test coverage report for the selected file:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-433 image-border" src="Images/834099f2-1655-4fa3-8147-b366b458353d.png" style="width:36.00em;height:14.08em;" width="1182" height="463"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing asynchronous code</h1>
                </header>
            
            <article>
                
<p>The <kbd>MathDemo</kbd> class also includes an asynchronous version of the same method:</p>
<pre>public powAsync(base: number, exponent: number) { 
  return new Promise&lt;number&gt;((resolve) =&gt; { 
    setTimeout( 
      () =&gt; { 
        const result = this.pow(base, exponent); 
        resolve(result); 
      }, 
      0 
    ); 
  }); 
} </pre>
<p>If we try to test this method, and we don't wait for its result, our test will be useless. However, if we wait for the result, using the <kbd>Promise.then</kbd> method, our test will also fail, unless we pass a callback (named <kbd>done</kbd> in the example) function to the test-case handler:</p>
<pre>it("Should return the correct numeric value for pow", (done) =&gt; { 
  const math = new MathDemo(); 
  math.powAsync(2, 3).then((result: number) =&gt; { 
    const expected = 8; 
    expect(result).to.be.a("number"); 
    expect(result).to.equal(expected); 
    done(); 
  }); 
}); </pre>
<p>Alternatively, we can use async and await, as demonstrated in the following code snippet:</p>
<pre>it("Should return the correct numeric value for pow", async () =&gt; { 
    const math = new MathDemo(); 
    const result = await math.powAsync(2, 3); 
    const expected = 8; 
    expect(result).to.be.a("number"); 
    expect(result).to.equal(expected); 
}); </pre>
<p>When testing asynchronous code, Mocha will consider the test as failed (timeout) if it takes more than 2,000 milliseconds to invoke the <kbd>done</kbd> function. The time limit before a timeout can be configured, as can warnings for slow functions. By default, when a test takes more than 40 milliseconds, a warning will be displayed. The warning suggests that our test is somehow slow. If the test execution takes over 100 milliseconds, the warning will suggest that our test is quite slow. We can change this configuration using the <kbd>--timeout</kbd> command-line argument of the <kbd>mocha</kbd> command.</p>
<div class="packt_infobox">The companion source code includes examples of each kind of warning and failure.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asserting exceptions</h1>
                </header>
            
            <article>
                
<p>In the previous examples, we have learned how to assert the type and value of a variable:</p>
<pre>const expected = 8; 
expect(result).to.be.a("number"); 
expect(result).to.equal(expected); </pre>
<p>However, there is one scenario that is perhaps not as intuitive as the previous one—testing for an exception.</p>
<p>The <kbd>MathDemo</kbd> class also contains a method named <kbd>bad</kbd>, which was added with the sole purpose of illustrating how to test for an exception. The <kbd>bad</kbd> method throws an exception when it is invoked with a <kbd>null</kbd> argument:</p>
<pre>public bad(foo: any) { 
  if (foo === null) { 
    throw new Error("Error!"); 
  } else { 
    return this.pow(5, 5); 
  } 
} </pre>
<p>In the following test, we can see how we can use the <kbd>expect</kbd> API to assert that an exception is thrown:</p>
<pre>it("Should throw an exception when no parameters passed", () =&gt; { 
  const math = new MathDemo(); 
  expect(math.bad).to.throw(Error); 
}); </pre>
<div class="packt_infobox">If you wish to learn more about assertions, visit the Chai official documentation available at <a href="http://chaijs.com/api/bdd/"><span class="URLPACKT">http://chaijs.com/api/bdd/</span></a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing a web service with SuperTest</h1>
                </header>
            
            <article>
                
<p>The demo application included in the companion source code declares a web service that allows us to get the result of the <kbd>pow</kbd> calculation:</p>
<pre>import * as express from "express"; 
import * as path from "path"; 
import { MathDemo } from "./math_demo"; 
 
export function getApp() { 
 
    const app = express(); 
 
    // ...     
 
    app.get("/api/math/pow/:base/:exponent", (req, res) =&gt; { 
        const mathDemo = new MathDemo(); 
        const base = parseInt(req.params.base, 10); 
        const exponent = parseInt(req.params.exponent, 10); 
        const result = mathDemo.pow(base, exponent); 
        res.json({ result }); 
    }); 
 
    return app; 
 
} </pre>
<p>The initialization of the application is separated into two files: <kbd>main.ts</kbd> and <kbd>server.ts</kbd>. The <kbd>server.ts</kbd> file defines the <kbd>getApp</kbd> function that we have examined in the preceding code snippet. The <kbd>main.ts</kbd> file uses the <kbd>getApp</kbd> function to start the server:</p>
<pre>import { getApp } from "./server"; 
 
const app = getApp(); 
const port = 3000; 
 
app.listen(port, () =&gt; { 
    console.log(`App listening at http://localhost:${port}`); // tslint:disable-line 
}); </pre>
<p>Sometimes, it is a good idea to test a web service as a whole in what is known as integration tests. As we learned earlier in this chapter, integration tests are used to test a set of components. In this case, we are going to test the server-side route handlers and their usage of the <kbd>MathDemo</kbd> class. We can define a test for the <kbd>pow</kbd> service as follows:</p>
<pre>import { expect } from "chai"; 
import * as request from "supertest"; 
import { getApp } from "../src/backend/server"; 
 
describe("Math Service", function() { 
    it("HTTP GET /api/math/pow/:base/:exponent", async () =&gt; { 
        const app = getApp(); 
        return request(app).get("/api/math/pow/2/3") 
                    .set("Accept", "application/json") 
                    .expect("Content-Type", /json/) 
                    .expect(200) 
                    .then((response) =&gt; 
                        expect(response.body.result).eql(8) 
                    ); 
    }); 
}); </pre>
<p>As we can see in the preceding code snippet, we have used a function named <kbd>getApp</kbd> to get the instance of the Express.js app. Once we have the app instance, we can use the request method from the <kbd>supertest</kbd> module to send a request to the service. We can use SuperTest together with Chai to assert that the response of the request matches an expected result. It is important to mention that the <kbd>getApp</kbd> function creates an app, but it doesn't launch the app. Or, in other words, the <kbd>getApp</kbd> function avoids invoking the <kbd>app.listen</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with tests suites</h1>
                </header>
            
            <article>
                
<p>A test suite is a group of test cases. We have already learned that we can use the <kbd>describe</kbd> function from Mocha to define a test suite and the <kbd>it</kbd> function to define a test case. However, we have not learned that we can define event handlers that can be invoked before and after all the tests in a test suite. The following code snippet demonstrates how we can define these event handlers:</p>
<pre>describe("My test suite", () =&gt; { 
 
  before(() =&gt; { 
    // Invoked once before ALL tests 
  }); 
 
  after(() =&gt; { 
    // Invoked once after ALL tests 
  }); 
 
  beforeEach(() =&gt; { 
    // Invoked once before EACH test 
  }); 
 
  afterEach(() =&gt; { 
    // Invoked once before EACH test 
  }); 
 
  it(() =&gt; { 
    // Test case 
  }); 
  
}); </pre>
<p>This can be useful if we want to reuse some of the initialization logic across multiple test cases. For example, we can rewrite the example that we used to test a web service earlier in the preceding section, in a way that will allow us to share the Express.js application instance across multiple test cases:</p>
<pre>import { expect } from "chai"; 
import * as express from "express"; 
import * as request from "supertest"; 
import { getApp } from "../src/backend/server"; 
 
describe("Math Service", function() { 
 
    let app: express.Application | null; 
 
    before(() =&gt; { 
        app = getApp(); 
    }); 
 
    after(() =&gt; { 
        app = null; 
    }); 
 
    it("HTTP GET /api/math/pow/:base/:exponent", async () =&gt; 
        request(app).get("/api/math/pow/2/3") 
                .set("Accept", "application/json") 
                .expect("Content-Type", /json/) 
                .expect(200) 
                .then((response) =&gt; 
                    expect(response.body.result).eql(8) 
                ) 
    ); 
 
}); </pre>
<div class="packt_infobox">Usually, testing frameworks (regardless of the language we are working with) won't allow us to control the order in which the unit tests and test suites are executed. The tests can even be executed in parallel by using multiple threads. For this reason, it is important to ensure that the unit tests in our test suites are independent of each other.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Isolating components with Sinon.JS</h1>
                </header>
            
            <article>
                
<p>We have learned that unit tests are used to test individual components, and integration tests are used to test a set of components and their interactions. When we write a unit test, and a component has a dependency on another, we will need to provide stubs, mocks, or dummies instead of real dependencies to ensure that the component is being tested in isolation. However, sometimes this can be more complicated than it sounds. Luckily, Sinon.JS can help us to ensure that our components are tested in isolation.</p>
<p>The following code snippet is used to test the web client of the <kbd>pow</kbd> web service that we described earlier in this chapter. We use Sinon.JS to define a stub for a global object named <kbd>fetch</kbd>. The <kbd>fetch</kbd> global object is a function that allows us to send an AJAX request to the backend from the frontend. Replacing the <kbd>fetch</kbd> object with a stub is a good idea because it will help us to ensure that the client class is not interacting with the backend, and, thus, that it is tested in complete isolation:</p>
<pre>import { expect } from "chai";<br/>import { stub } from "sinon"; 
import { MathClient } from "../src/frontend/math_client"; 
 
describe("MathDemo", () =&gt; { 
    it("Should return result of pow calculation", async () =&gt; { 
 
        const expectedResult = "8"; 
 
        const response = { 
            json: () =&gt; Promise.resolve({ 
                result: expectedResult  
            }) 
        }; 
 
        const stubedFetch = stub(global, "fetch" as any); 
        stubedFetch.returns(Promise.resolve(response)); 
 
        const mathClient = new MathClient(); 
        const actualResult = await mathClient.pow(2, 3); 
        expect(expectedResult).to.eq(actualResult); 
        expect(stubedFetch.callCount).to.eq(1); 
 
      }); 
}); </pre>
<p>Using a global is a bad idea because it goes against the dependency inversion principle and makes our applications harder to test. Fortunately, Sinon.JS can help us to overcome this kind of difficulty.</p>
<div class="packt_infobox">Refer to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>, to learn more about dependency inversion and its underlying principles.</div>
<p>It is also worth mentioning that the stubs provide us with an API that can help us to check things, such as the number of times that the stub was used or which arguments were passed to it. This was demonstrated by the last assertion in the preceding code snippet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">jsdom</h1>
                </header>
            
            <article>
                
<p>Some testing tools, such as Enzyme (we will learn about this in the following section), expect to be used in a web browser. In our example, the application uses nyc and ts-node to execute all our unit tests, which means that we are not using a web browser. Sometimes, it is possible to overcome this problem by using jsdom, which is described by its creators as follows:</p>
<div class="packt_quote">"jsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG DOM and HTML Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications."</div>
<p>If we examine the <kbd>nyc</kbd> command in the <kbd>package.json</kbd> file included in the companion source code, we will see that one of the arguments provided to the nyc binary is <kbd>--require ./jsdom.js</kbd>. This will force Mocha to need the <kbd>jsdom.js</kbd> file before any tests are executed. The <kbd>jsdom.js</kbd> file is used to initialize jsdom, and looks as follows:</p>
<pre>const { JSDOM } = require("jsdom" ); 
const jsdom = new JSDOM(" &lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;" ); 
const { window } = jsdom; 
 
function copyProps(src, target) { 
  const props = Object.getOwnPropertyNames(src) 
    .filter(prop =&gt; typeof target[prop] === " undefined" ) 
    .reduce((result, prop) =&gt; ({ 
      ...result, 
      [prop]: Object.getOwnPropertyDescriptor(src, prop), 
    }), {}); 
  Object.defineProperties(target, props); 
} 
 
global.window = window; 
global.document = window.document; 
global.navigator = { 
  userAgent: " node.js", 
}; 
 
copyProps(window, global); </pre>
<p>The preceding file creates a few global variables that allow us to run the backend code that was originally designed to be executed in a web browser. In the Node.js execution environment, we don't have certain variables, such as the window variable. The preceding code snippet initializes all the required variables to enable the execution of frontend code in our backend execution environment (Node.js). This is useful, for example, when we want to write a test for a frontend component because we can execute our tests without the need for a web browser.</p>
<div class="packt_infobox">Refer to the Enzyme documentation at <a href="https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md">https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md</a> to learn more about the jsdom configuration.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing React web components with Enzyme</h1>
                </header>
            
            <article>
                
<p>At this point, we have tested the backend of our application using both unit tests and integration tests (with SuperTest). We have also tested our client in complete isolation, thanks to the usage of Sinon.JS. However, our application can still fail if something is wrong in the presentation layer (the graphic user interface). In this section, we are going to learn how we can use some libraries to help us to test each of the components of our graphic user interface.</p>
<div class="packt_infobox">Refer to <a href="b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml">Chapter 11</a>, <em>Frontend Development with React and TypeScript</em>, to learn more about React.</div>
<p>The companion source code includes the following React component:</p>
<pre>import * as React from "react"; 
import { MathClient } from "./math_client"; 
import { NumericInput } from "./numeric_input_component"; 
 
const ids = { 
  base: "#base", 
  exponent: "#exponent", 
  result: "#result", 
  submit: "#submit" 
}; 
 
interface CalculatorProps { 
  client: MathClient; 
} 
 
interface CalculatorState { 
  base: string; 
  exponent: string; 
  result: string; 
} 
 
export class Calculator extends React.Component&lt;CalculatorProps, CalculatorState&gt; { 
 
  public constructor(props: CalculatorProps) { 
    super(props); 
    this.state = { 
      base: "1", 
      exponent: "1", 
      result: "1" 
    }; 
  } 
 
  public render() { 
    return ( 
      &lt;div className="well"&gt; 
        &lt;div className="row"&gt; 
          &lt;div className="col"&gt; 
            &lt;NumericInput 
              id="base" 
              name="Base" 
              value={this.state.base} 
              onChangeHandler={(v) =&gt; this.setState({ base: v })} 
            /&gt; 
          &lt;/div&gt; 
          &lt;div className="col"&gt; 
            &lt;NumericInput 
              id="exponent" 
              name="Exponent" 
              value={this.state.exponent} 
              onChangeHandler={(v) =&gt; this.setState({ 
                  exponent: v 
              })} 
            /&gt; 
          &lt;/div&gt; 
          &lt;div className="col"&gt; 
            &lt;div className="form-group"&gt; 
                  &lt;label&gt;Result&lt;/label&gt; 
                  &lt;div id="result"&gt;{this.state.result}&lt;/div&gt; 
              &lt;/div&gt; 
          &lt;/div&gt; 
          &lt;div className="col"&gt; 
            &lt;button 
              id="submit_btn" 
              type="Submit" 
              className="btn btn-primary" 
              onClick={() =&gt; this._onSubmit()} 
            &gt; 
              Submit 
            &lt;/button&gt; 
          &lt;/div&gt; 
        &lt;/div&gt; 
      &lt;/div&gt; 
    ); 
  } 
 
  private _onSubmit() { 
    (async () =&gt; { 
      const result = await this.props.client.pow( 
        parseFloat(this.state.base), 
        parseFloat(this.state.exponent) 
      ); 
      this.setState({ result }); 
    })(); 
  } 
 
} </pre>
<p>As we learned earlier in this chapter, the preceding component will display a web form on the screen. The users of the application need to provide two numbers (<kbd>base</kbd> and <kbd>exponent</kbd>) as inputs. The input is then sent to a web service in the backend, and the response is displayed as a result. The following code snippet demonstrates how we can isolate the preceding component from the HTTP client using a stub. The code snippet also demonstrates how we can configure Enzyme to work with version 16 of React and then use it to simulate user events, such as clicking on an element or typing in an input:</p>
<pre>import { expect } from "chai"; 
import * as Enzyme from "enzyme"; 
import * as Adapter from "enzyme-adapter-react-16"; 
import * as React from "react"; 
import { stub } from "sinon"; 
import { Calculator } from "../src/frontend/calculator_component"; 
import { MathClient } from "../src/frontend/math_client"; 
 
Enzyme.configure({ adapter: new Adapter() }); 
 
describe("Calculator Component", () =&gt; { 
 
  it("Should invoke client #submit is clicked", (done) =&gt; { 
 
    const mathClient = new MathClient(); 
 
    const mathClientStub = stub(mathClient, "pow"); 
    mathClientStub.returns(Promise.resolve(8)); 
 
    mathClientStub.callsFake((base: number, exponent: number) =&gt; { 
      expect(base).to.equal(2); 
      expect(exponent).to.equal(3); 
      done(); 
    }); 
 
    const wrapper = Enzyme.mount(&lt;Calculator client={mathClient} /&gt;); 
 
    expect(wrapper.find("input#base")).to.have.length(1); 
    expect(wrapper.find("input#exponent")).to.have.length(1); 
    expect(wrapper.find("button#submit_btn")).to.have.length(1); 
 
    wrapper.find("input#base").simulate("change", { target: { value: "2" } }); 
    wrapper.find("input#exponent").simulate("change", { target: { value: "3" } }); 
    wrapper.find("button#submit_btn").simulate("click"); 
 
  }); 
 
}); </pre>
<p>The preceding tests insert a value for the base and exponent inputs and then click on the <span class="packt_screen">Submit</span> button. This will invoke the web client, which has been replaced by a stub.</p>
<p>Enzyme has been designed to work with React. However, each major version of React requires a specific adapter. Other frameworks might require other libraries. For example, in Angular, we can use the utilities provided by the <kbd>@angular/core/testing</kbd> module to do something like the following:</p>
<pre>import {TestBed, ComponentFixture, inject, async} from "@angular/core/testing"; 
import {LoginComponent, User} from "./login.component"; 
import {Component, DebugElement} from "@angular/core"; 
import {By} from "@angular/platform-browser"; 
 
// Refine the test module by declaring the test component 
TestBed.configureTestingModule({ 
    declarations: [LoginComponent] 
}); 
 
// Access the component 
let fixture: ComponentFixture&lt;LoginComponent&gt; = TestBed.createComponent(LoginComponent); 
let component: LoginComponent = fixture.componentInstance; 
 
// Access an element 
let submitEl: DebugElement = fixture.debugElement.query(By.css("button")); 
submitEl.triggerEventHandler("click", null); </pre>
<div class="packt_infobox">Please refer to the documentation at <a href="https://angular.io/api/core/testing">https://angular.io/api/core/testing</a> to learn more about testing in Angular.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TDD versus BDD with Mocha and Chai</h1>
                </header>
            
            <article>
                
<p>As we have already seen, TDD and BDD follow many of the same principles, but have some differences in their style. While these two styles provide the same functionality, BDD is considered to be easier to read by many developers.</p>
<p>The following table compares the naming and style of the suites, tests, and assertions used by the TDD and BBD styles:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>TDD</strong></p>
</td>
<td>
<p><strong>BDD</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>suite</kbd></p>
</td>
<td>
<p><kbd>describe</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>setup</kbd></p>
</td>
<td>
<p><kbd>before</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>teardown</kbd></p>
</td>
<td>
<p><kbd>after</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>suiteSetup</kbd></p>
</td>
<td>
<p><kbd>beforeEach</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>suiteTeardown</kbd></p>
</td>
<td>
<p><kbd>afterEach</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>test</kbd></p>
</td>
<td>
<p><kbd>it</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assert.equal(math.PI, 3.14159265359);</kbd></p>
</td>
<td>
<p><kbd>expect(math.PI).to.equals(3.14159265359);</kbd></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">End-to-end tests with Nightwatch.js</h1>
                </header>
            
            <article>
                
<p>Writing an e2e test with Nightwatch.js is very simple because its API is very readable. We should be able to read an e2e test and be able to understand it, even if it is the first time that we see one. For example, the following is an example of an e2e test that is used to test the application included in the companion source code:</p>
<pre>import { NightwatchBrowser } from "nightwatch"; 
 
const test = { 
  "Calculator pow e2e test example": (browser: NightwatchBrowser) =&gt; { <br/>    browser 
      .url("http://localhost:3000/") 
      .waitForElementVisible("body", 1000) 
      .assert.title("Calculator") 
      .assert.visible("#base") 
      .assert.visible("#exponent") 
      .clearValue("#base") 
      .setValue("#base", "2") 
      .clearValue("#exponent") 
      .setValue("#exponent", "3") 
      .click("#submit_btn") 
      .pause(500) 
      .assert.containsText("#result", "8") 
      .end(); 
  } 
}; 
 
export = test; </pre>
<p>We use the <kbd>NightwatchBrowser</kbd> instance to navigate to a URL, wait for a few elements to be visible, set the value of a few inputs, and then click on the <span class="packt_screen">Submit</span> button.</p>
<p>While the e2e tests API is very simple, the process behind it is not so simple. If we examine the <kbd>npm script</kbd> commands in the <kbd>package.json</kbd> file included in the companion source code, we will be able to observe that the command triggers four other commands:</p>
<ul>
<li>Compile the e2e tests</li>
<li>Run the application</li>
<li>Run the e2e tests</li>
<li>Kill the application</li>
</ul>
<p>The first command uses PM2 and ts-node to run the application. PM2 is a very powerful process management tool that allows us to run a Node.js app as a cluster and to monitor it. However, this is not why we are using it here. We use PM2 because it is a very easy way to run the application as a background process. We need to run the entire application before our e2e tests are executed. The problem is that when the app starts waiting for HTTP <span>requests, it blocks all the subsequent commands. PM2 solves this problem by allowing us to run the app in a background process.</span></p>
<p>Another thing worth mentioning is that our e2e tests are browser-independent. This explains why Nightwatch.js requires us to configure a driver. The driver provides native access to the web browser that will execute the e2e tests.</p>
<p>In the demo application, we are using ChromeDriver. We have created a file named <kbd>globals.js</kbd> that is used to define some global events that will be executed before and after our e2e tests. The event handlers are very similar to the ones that we learned about while defining a test suite with Mocha earlier in this chapter.</p>
<p>We use the event handlers declared in the <kbd>globals.js</kbd> file to create and destroy instances of <kbd>chromedriver</kbd>:</p>
<pre>const chromedriver = require("chromedriver"); 
 
module.exports = { 
    before: (done) =&gt; { 
        chromedriver.start(); 
        done(); 
    }, <br/>    after: (done) =&gt; { 
        chromedriver.stop(); 
        done(); 
    }, 
    reporter: function(results) { 
        if ( 
            (typeof(results.failed) === "undefined" || results.failed === 0) &amp;&amp; 
            (typeof(results.error) === "undefined" || results.error === 0) 
        ) { 
            process.exit(0); 
        } else { 
            process.exit(1); 
        } 
    } 
}; </pre>
<div class="packt_infobox">The version of the <kbd>chromedriver</kbd> npm module used in this example is 2.36.0. This version has been tested with Google Chrome 65.0. If you are using a later version of Google Chrome, please ensure that you also upgrade the <kbd>chromedriver</kbd> module.</div>
<p>We then create a file named Nightwatch.js that contains the following configuration:</p>
<pre>{ 
    "src_folders": [ 
        "dist/test" 
    ], 
    "output_folder": "reports", <br/>    "custom_commands_path": "", 
    "custom_assertions_path": "", 
    "page_objects_path": "", 
    "globals_path": "./globals.js", 
    "selenium": { 
        "start_process": false 
    }, 
    "test_settings": { 
        "default": { 
            "selenium_port": 9515, 
            "selenium_host": "localhost", 
            "default_path_prefix": "", 
            "desiredCapabilities": { 
                "browserName": "chrome", 
                "chromeOptions": { 
                    "args": [ 
                        "--no-sandbox" <br/>                    ] 
                }, 
                "acceptSslCerts": true 
            } 
        }, 
        "chrome": { 
            "desiredCapabilities": { 
                "browserName": "chrome" 
            } 
        } 
    } 
} </pre>
<p>As we can see in the preceding code snippet, we are configuring ChromeDriver to use the <kbd>globals.js</kbd> events and Google Chrome as the web browser to be used to run our tests. We have also configured Nightwatch.js to look for our test under the <kbd>dist</kbd> folder. Nightwatch.js cannot understand TypeScript natively, which explains why we need to compile the tests into the <kbd>dist</kbd> folder before we can run them.</p>
<p>We need to define a second <kbd>tsconfig.json</kbd> file named <kbd>tsconfig.e2e.json</kbd> with some additional options to ensure that we only compile the required files:</p>
<pre>{ 
  "compilerOptions": { 
    "outDir": "./dist/" 
  }, 
  "extends": "./tsconfig", 
  "include": [ 
    "test/*.e2e.ts", 
    "src/backend/*.ts" 
  ], 
  "exclude": [ 
    "node_modules" 
  ] 
} </pre>
<p>Please note that the <kbd>extends</kbd> filed in the <kbd>tsconfig.json</kbd> file allows us to inherit all the settings from a previously declared <kbd>tsconfig.json</kbd> file.</p>
<p>If everything goes well, we should be able to see results like the following on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-434 image-border" src="Images/3cabd2d8-73ef-49f6-935d-0161d5146026.png" style="width:36.50em;height:34.92em;" width="1177" height="1126"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed some core testing concepts, such as stubs, suites, and more. We also looked at the test-driven development and behavior-driven development approaches, and how to work with some of the leading JavaScript testing frameworks, such as Mocha, Chai, Sinon.JS, Enzyme, SuperTest, and Nightwatch.js.</p>
<p>In the next chapter, we will learn how to use the TypeScript language services to create our development tools.</p>


            </article>

            
        </section>
    </div>



  </body></html>