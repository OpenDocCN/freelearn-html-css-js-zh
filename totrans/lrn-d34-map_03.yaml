- en: Producing Graphics from Data - the Foundations of D3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据生成图形 - D3 的基础
- en: We have acquired our toolbox and reviewed the basics of SVG. It is now time
    to explore D3.js. D3 is the evolution of the Protovis ([http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/))
    library. If you have already delved into data visualization have been interested
    in making charts for your web application, you might have already used this library.
    Additional libraries also exist that can be differentiated by how quickly they
    rendered graphics and their compatibility with different browsers. For example,
    Internet Explorer did not support SVG but used its own implementation, VML. This
    made the `Raphaël.js` library an excellent option because it automatically mapped
    to either VML or SVG. On the other hand, jqPlot was easy to use, and its simplistic
    jQuery plugin interface allowed developers to adopt it very quickly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了我们的工具箱并复习了 SVG 的基础知识。现在是时候探索 D3.js 了。D3 是 Protovis ([http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/))
    库的进化。如果你已经深入研究数据可视化并对为你的网络应用制作图表感兴趣，你可能已经使用过这个库。还存在其他库，它们可以通过渲染图形的速度以及与不同浏览器的兼容性来区分。例如，Internet
    Explorer 不支持 SVG，但使用其自己的实现，VML。这使得 `Raphaël.js` 库成为一个极佳的选择，因为它可以自动映射到 VML 或 SVG。另一方面，jqPlot
    使用简单，其简单的 jQuery 插件界面允许开发者快速采用它。
- en: However, Protovis had something different. Given the vector nature of the library,
    it allowed you to illustrate different kinds of visualizations, as well as generate
    fluid transitions. Please feel free to look at the links provided and see for
    yourself. Examine the force-directed layout at: [http://mbostock.github.io/protovis/ex/force.html](http://mbostock.github.io/protovis/ex/force.html).
    In 2010, these were interesting and compelling visualizations, especially for
    the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Protovis 有其独特之处。鉴于该库的矢量性质，它允许你展示不同类型的可视化，以及生成流畅的过渡。请随意查看提供的链接并亲自验证。查看力导向布局：[http://mbostock.github.io/protovis/ex/force.html](http://mbostock.github.io/protovis/ex/force.html)。在2010年，这些可视化既有趣又引人入胜，尤其是对于浏览器来说。
- en: Inspired by Protovis, a team at Stanford University (consisting of Jeff Heer,
    Mike Bostock, and Vadim Ogievetsky) began to focus on D3\. D3, and its application
    to SVG, gave developers an easy way to bind their visualizations to data and add
    interactivity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 受 Protovis 的启发，斯坦福大学的一个团队（由 Jeff Heer、Mike Bostock 和 Vadim Ogievetsky 组成）开始专注于
    D3。D3 及其应用于 SVG，为开发者提供了一个简单的方法来将他们的可视化绑定到数据并添加交互性。
- en: 'There is a wealth of information available for researching D3\. A great resource
    for complete coverage can be found on the D3 website at: [https://github.com/mbostock/d3/wiki](https://github.com/mbostock/d3/wiki).
    In this chapter, we will introduce the following concepts that will be used throughout
    this book:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于研究 D3，有大量的信息可用。在 D3 网站上可以找到一份全面覆盖的宝贵资源：[https://github.com/mbostock/d3/wiki](https://github.com/mbostock/d3/wiki)。在本章中，我们将介绍以下将在整本书中使用的概念：
- en: Creating basic SVG elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的 SVG 元素
- en: The `enter()` function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enter()` 函数'
- en: The `update` function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update` 函数'
- en: The `exit()` function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit()` 函数'
- en: AJAX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX
- en: Creating basic SVG elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的 SVG 元素
- en: 'A common operation in D3 is to select a DOM element and append SVG elements.
    Subsequent calls will then set the SVG attributes, which we learned about in [Chapter
    2](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml), *Creating Images from Simple Text*.
    D3 accomplishes this operation through an easy-to-read, functional syntax called
    **method chaining**. Let''s walk through a very simple example to illustrate how
    this is accomplished (go to `http://localhost:8080/chapter-3/example-1.html` if
    you have the http-server running):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 D3 中，一个常见的操作是选择一个 DOM 元素并附加 SVG 元素。随后的调用将设置 SVG 属性，这些属性我们在第 2 章 [创建简单的文本图像](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml)中已经学习过。D3
    通过一种易于阅读的、功能性的语法——**方法链**来完成这个操作。让我们通过一个非常简单的例子来展示这是如何实现的（如果你正在运行 http-server，请访问
    `http://localhost:8080/chapter-3/example-1.html`）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we select the `body` tag and append an SVG element to it. This SVG element
    has a width and height of `200` pixels. We also store the selection in a variable:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择 `body` 标签并向其中附加一个 SVG 元素。这个 SVG 元素的宽度和高度为 `200` 像素。我们还把选择存储在一个变量中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we use the `svg` variable and append a `<rect>` item to it. This `rect`
    item will start at (`10`,`10`) and will have a width of `50` and a height of `100`.
    From your Chrome browser, open the Chrome developer tools with the Elements tab
    selected and inspect the SVG element:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `svg` 变量并添加一个 `<rect>` 项目到它。这个 `rect` 项目将从 (`10`,`10`) 开始，宽度为 `50`，高度为
    `100`。从您的 Chrome 浏览器中，打开带有 Elements 选项卡的 Chrome 开发者工具并检查 SVG 元素：
- en: '![](img/231de160-0a34-433b-adf5-c07cf1a53e08.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/231de160-0a34-433b-adf5-c07cf1a53e08.png)'
- en: 'Notice the pattern: `append(''svg'')` creates `<svg></svg>`. `attr(''width'',200)`
    and `attr(''height'',200)` sets `width="200"` and `height="200"`  respectively.
    Together, they produce the SVG syntax we learned about in the previous chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模式：`append('svg')` 创建 `<svg></svg>`。`attr('width',200)` 和 `attr('height',200)`
    分别设置 `width="200"` 和 `height="200"`。一起，它们产生了我们在上一章中学到的 SVG 语法：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The enter() function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: enter() 函数
- en: 'The `enter()` function is a part of every basic D3 visualization. It allows
    the developer to define a starting point with attached data. The `enter()` function
    can be thought of as a section of code that executes when data is applied to the
    visualization for the first time. Typically, the `enter()` function will follow
    the selection of a DOM element. Let''s walk through an example (`http://localhost:8080/chapter-3/example-2.html`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter()` 函数是每个基本 D3 可视化的一部分。它允许开发者定义一个带有附加数据的开端点。`enter()` 函数可以被认为是一段代码，当数据首次应用于可视化时执行。通常，`enter()`
    函数将跟随 DOM 元素的选择。让我们通过一个例子来了解一下 (`http://localhost:8080/chapter-3/example-2.html`）：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the SVG container as we did earlier, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SVG 容器，就像我们之前做的那样，如下所示：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `data` function is the way we bind data to our selection. In this example,
    we are binding a very simple array, `[1,2]`, to the selection `<rect>`. The `enter()`
    function will loop through the `[1,2]` array and apply the subsequent function
    calls, as shown in the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 函数是我们将数据绑定到选择的方式。在这个例子中，我们将一个非常简单的数组 `[1,2]` 绑定到选择 `<rect>`。`enter()`
    函数将遍历 `[1,2]` 数组并应用后续的函数调用，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we loop through each element in the array, we will do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历数组中的每个元素时，我们将执行以下操作：
- en: Append a new `rect` SVG element
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的 `rect` SVG 元素
- en: 'Position the `rect` element in coordinates *x = d * 20* and *y = d * 50* for
    the element, where *d* is equal to 1 for the first element and 2 for the second
    element, as shown in the following code:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `rect` 元素定位在坐标 *x = d * 20* 和 *y = d * 50*，其中 *d* 对于第一个元素等于 1，对于第二个元素等于 2，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will keep `height` and `width` the same:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持 `height` 和 `width` 不变：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Look closely; take a peek at the Chrome developer tools. We see two rectangles,
    each corresponding to one element in our array, as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察；看看 Chrome 开发者工具。我们看到两个矩形，每个矩形对应于数组中的一个元素，如下面的截图所示：
- en: '![](img/daa6cee2-47f6-4921-939b-0d4471d5cdef.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daa6cee2-47f6-4921-939b-0d4471d5cdef.png)'
- en: 'Remember, data doesn''t necessarily have to be boring numbers, such as 1 or
    2\. The data array can consist of any data objects. To illustrate this, we will
    change the previous array to an array of objects in the next example (see `http://localhost:8080/chapter-3/example-3.html`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，数据不一定非得是枯燥的数字，比如 1 或 2。数据数组可以由任何数据对象组成。为了说明这一点，我们将在下一个例子中将之前的数组更改为对象数组（见
    `http://localhost:8080/chapter-3/example-3.html`）：
- en: '![](img/f6b2fa09-9fac-418b-84f1-013715088026.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6b2fa09-9fac-418b-84f1-013715088026.png)'
- en: 'As you can see in the following code snippet, our data array has two objects,
    each one with four different key-value pairs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下面的代码片段中看到的，我们的数据数组有两个对象，每个对象有四个不同的键值对：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, as we loop through each object in the array, we will do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们遍历数组中的每个对象时，我们将执行以下操作：
- en: Still append a new `rect` SVG element.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然添加一个新的 `rect` SVG 元素。
- en: Position and size the `rect` element by the properties of the object. The first
    rectangle will be positioned at `x=10`, `y=10`, and have a width of `5` and a
    height of `40`. The second rectangle will be positioned at `40`, `10`, and will
    have a width of `100` and a height of `40`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对象的属性定位和调整 `rect` 元素的大小。第一个矩形将定位在 `x=10`，`y=10`，宽度为 `5`，高度为 `40`。第二个矩形将定位在
    `40`，`10`，宽度为 `100`，高度为 `40`。
- en: Remember that `d` represents the datum, or each object within the array, which
    is why we refer to `d.x` or `d.y` to get  `x` and `y`  properties accordingly.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`d` 代表数据，或数组中的每个对象，这就是为什么我们用 `d.x` 或 `d.y` 来获取相应的 `x` 和 `y` 属性。
- en: The update function
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新函数
- en: 'Not only do we have our rectangles, but we''ve also joined them to a dataset
    composed of two objects. Both objects share the same properties, namely `x`, `y`,
    `width`, and `height`, so it''s easy to loop through them and read/bind the values
    to our visualization. The output of this is a set of static SVG elements. This
    section will cover how to update the SVG elements and properties as the joined
    data changes. Let''s enhance the previous example to explain exactly how this
    works (`http://localhost:8080/chapter-3/example-4.html`):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们有矩形，我们还把它们连接到一个由两个对象组成的数据集中。这两个对象共享相同的属性，即`x`、`y`、`width`和`height`，因此很容易遍历它们并将值绑定到我们的可视化中。结果是静态SVG元素集。本节将介绍如何更新SVG元素和属性，当连接的数据发生变化时。让我们增强前面的例子来解释这是如何工作的（`http://localhost:8080/chapter-3/example-4.html`）：
- en: '![](img/4a0b87c0-44ac-4e67-aa23-ac4bf804d111.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a0b87c0-44ac-4e67-aa23-ac4bf804d111.png)'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function creates a new array of objects with random properties for `x`,
    `y`, `width`, and `height`. We can use this to simulate a change in data, allowing
    us to create `n` number of items, all with different properties:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建了一个新的对象数组，具有随机的`x`、`y`、`width`和`height`属性。我们可以使用它来模拟数据的变化，允许我们创建具有不同属性的`n`个项目：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we create a function that inserts rectangles into the DOM on every invocation
    of D3\. The description is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个函数，每次调用D3时都会将矩形插入DOM中。其描述如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s generate our fake data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成我们的假数据：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s select our rectangle and assign our data to it. This gives us a variable
    to which we can easily apply `enter()` and `update` later. The following sections
    are written in a verbose way to illustrate exactly what is going on with `enter()`,
    `update`, and `exit()`. While it''s possible to take shortcuts in D3, it''s best
    to stick to the following style to prevent confusion:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择我们的矩形并将其数据分配给它。这给我们一个变量，我们可以轻松地应用`enter()`和`update`。以下部分以详尽的方式编写，以精确说明`enter()`、`update`和`exit()`正在发生的事情。虽然可以在D3中走捷径，但最好坚持以下风格以避免混淆：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As in the previous section, for each element in the array we append a rectangle
    tag to the DOM. If you''re running this code in your Chrome browser, you will
    notice that the console only displays `enter placing initial rectangle` twice.
    This is because the `enter()` section is called only when there are more elements
    in the array than in the DOM:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，对于数组中的每个元素，我们将其附加到一个矩形标签到DOM中。如果你在Chrome浏览器中运行此代码，你会注意到控制台只显示`enter placing
    initial rectangle`两次。这是因为只有当数组中的元素多于DOM中的元素时，`enter()`部分才会被调用：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `update` section is applied to every element in the original selection,
    excluding entered elements. In the previous example, we set the `x`, `y`, `width`,
    and `height` attributes of the rectangle for every data object. The `update` section
    is not defined with an explicit `update` method. D3 implies an `update` call if
    no other section is provided. If you are running the code in your Chrome browser,
    you will see the console display `updating x position to:` every time the data
    changes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`部分应用于原始选择集中的每个元素，但不包括已进入的元素。在前面的例子中，我们为每个数据对象设置了矩形的`x`、`y`、`width`和`height`属性。`update`部分没有使用显式的`update`方法。D3在没有提供其他部分的情况下隐式地假设了一个`update`调用。如果你在Chrome浏览器中运行代码，你会看到每次数据变化时控制台都会显示`updating
    x position to:`：'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following command inserts our working SVG container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令插入我们的工作SVG容器：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following command draws the first version of our visualization:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令绘制了我们可视化的第一个版本：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `setInterval()` function is the JavaScript function used to execute an operation
    every *x* milliseconds. In this case, we are calling the `rectangles` function
    every `1000` milliseconds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval()`函数是JavaScript中用于每*x*毫秒执行操作的函数。在这种情况下，我们每`1000`毫秒调用一次`rectangles`函数。'
- en: The `rectangles` function generates a new dataset every time it is called. It
    has the same property structure that we had before, but the values tied to those
    properties are random numbers between *1* and *100*. On the first call, the `enter()`
    section is invoked and we create our initial two rectangles. Every `1000` milliseconds,
    we reinvoke the `rectangles` function with the same data structure but different
    random property attributes. Because the structure is the same, the `enter()` section
    is now skipped and only `update` is reapplied to the existing rectangles. This
    is why we get the same rectangles with different dimensions every time we plot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`rectangles`函数时，它都会生成一个新的数据集。它具有与我们之前相同的属性结构，但与这些属性相关联的值是介于*1*和*100*之间的随机数。在第一次调用时，将调用`enter()`部分，并创建我们的初始两个矩形。每`1000`毫秒，我们使用相同的数据结构但不同的随机属性属性重新调用`rectangles`函数。因为结构相同，所以现在跳过了`enter()`部分，只对现有的矩形应用`update`。这就是为什么每次绘图时我们都会得到具有不同尺寸的相同矩形。
- en: The `update` method is very useful. For instance, your dataset could be tied
    to the stock market and you could update your visualization every *n* milliseconds
    to reflect the changes in the stock market. You could also bind the update to
    an event triggered by a user and have the user control the visualization. The
    options are endless.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法非常有用。例如，您的数据集可以与股市相关联，并且您可以每*毫秒*更新一次可视化以反映股市的变化。您还可以将更新绑定到由用户触发的事件，并让用户控制可视化。选项是无限的。'
- en: The exit() function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`exit()`函数'
- en: We've discussed `enter()` and `update`. We've seen how one determines the starting
    point of our visualization and the other modifies its attributes based on new
    data coming in. However, the examples covered had the exact number of data elements
    with the same properties. What would happen if our new dataset had a different
    amount of items? What if it has fewer or more?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`enter()`和`update`。我们看到了一个如何确定可视化起点，另一个如何根据传入的新数据修改其属性。然而，先前的例子中数据元素的数量与属性完全相同。如果我们的新数据集包含不同数量的项目会发生什么？如果它有更多或更少呢？
- en: 'Let''s take the `update` part of the previous example and modify it a bit to
    demonstrate what we''re talking about (`http://localhost:8080/chapter-3/example-5.html`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面的`update`部分为例，稍作修改以展示我们正在讨论的内容（`http://localhost:8080/chapter-3/example-5.html`）：
- en: '![](img/5f76fdbf-f2e6-46c7-9874-fa5ffb2673a1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f76fdbf-f2e6-46c7-9874-fa5ffb2673a1.png)'
- en: 'We can explain how this works with two small changes to the `rectangles` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对`rectangles`函数进行两个小的修改来解释它是如何工作的：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we tell the `data` function to create a random number of `data` objects:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉`data`函数创建一个随机数量的`data`对象：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `exit()` function will be the same as before. Add a new `exit()` section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`函数将与之前相同。添加一个新的`exit()`部分：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `exit()` method serves the purpose of cleansing or cleaning the no-longer-used
    DOM items in our visualization. This is helpful because it allows us to join our
    data with DOM elements, keeping them in sync. An easy way to remember this is
    as follows: if there are more data elements than DOM elements, the `enter()` section
    will be invoked; if there are fewer data elements than DOM elements, the `exit()`
    section will be invoked. In the previous example, we just removed the DOM element
    if there was no matching data.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`方法的作用是清除或清理我们可视化中不再使用的DOM元素。这很有帮助，因为它允许我们将数据与DOM元素同步。记住这个方法的一个简单方法是：如果有比DOM元素更多的数据元素，将调用`enter()`部分；如果有比DOM元素更少的数据元素，将调用`exit()`部分。在先前的例子中，如果没有匹配的数据，我们就移除了DOM元素。'
- en: 'The following is a graphical representation of the sequence that occurs when
    `enter()` and `update` functions are called. Notice that there''s no DOM element
    for data element **6**, so, the `enter()` section is executed. For data elements
    **0** to **5**, the update code is always called. For data element **6**, the
    **update** section will be executed after the **enter** process has completed.
    Refer to the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在调用`enter()`和`update`函数时发生的序列的图形表示。注意，对于数据元素**6**没有DOM元素，因此执行了`enter()`部分。对于数据元素**0**到**5**，始终调用更新代码。对于数据元素**6**，在`enter`过程完成后，将执行**update**部分。请参考以下图表：
- en: '![](img/5779c5c0-edf9-4116-ae68-efda44678cc4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5779c5c0-edf9-4116-ae68-efda44678cc4.png）'
- en: 'This illustrates what happens when you have fewer data elements than DOM elements.
    The **update** section is always called where there is a match, as shown in the
    following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了当数据元素少于DOM元素时会发生什么。**更新**部分总是在有匹配项时被调用，如下面的图所示：
- en: '![](img/0c82b03b-0e3d-4ec9-b653-e49415b12ee1.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c82b03b-0e3d-4ec9-b653-e49415b12ee1.png)'
- en: AJAX
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX
- en: '**Asynchronous JavaScript and XML** (**AJAX**) doesn''t relate 100 percent
    to D3\. It actually has its foundation in JavaScript. In short, AJAX allows the
    developer to obtain data from the background of the web page. This technique is
    extremely useful in map development because geographic datasets can be very large.
    Acquiring the data from the background will help produce a refined user experience.
    In addition, in [Chapter 6](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml), *Finding
    and Working with Geographic Data*, we will cover techniques to compress the size
    of geographic data.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步JavaScript和XML**（**AJAX**）并不完全与D3相关。它实际上基于JavaScript。简而言之，AJAX允许开发者从网页的背景中获取数据。这种技术在地图开发中非常有用，因为地理数据集可以非常大。从背景获取数据将有助于产生更精细的用户体验。此外，在[第6章](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml)“查找和使用地理数据”中，我们将介绍压缩地理数据大小的技术。'
- en: 'Separating the data from the code base will also provide the following advantages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据与代码库分离也将带来以下优势：
- en: A lighter code base that is easier to manage
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更轻量级的代码库，更容易管理
- en: The ability to update the data without making code changes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在不更改代码的情况下更新数据
- en: The ability to use third-party providers for data sources
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方数据源提供者的能力
- en: 'This is accomplished by acquiring the data through an AJAX call with the aid
    of a D3 function. Let''s examine the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用D3函数通过AJAX调用获取数据来实现的。让我们来检查以下代码：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `d3.json()` method has two parameters: a path to the file and a callback
    function. The callback function indicates what to do with the data once it has
    been transferred. In the previous code, if the call fetches the data correctly,
    it assigns it to the `json` variable. The `error` variable is just a general error
    object that indicates whether there were any problems fetching the data or not:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.json()`方法有两个参数：文件路径和回调函数。回调函数指示在数据传输后要做什么。在前面的代码中，如果调用正确获取了数据，它将数据分配给`json`变量。`error`变量只是一个通用错误对象，指示在获取数据时是否出现了任何问题：'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We store our JSON data into the data variable, and continue to process it as
    we did in the previous examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将JSON数据存储到data变量中，并继续像之前示例中那样处理它：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/6fbec84a-5332-4bf2-ac79-a7a14cf5147c.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fbec84a-5332-4bf2-ac79-a7a14cf5147c.png)'
- en: D3 provides us with many kinds of data acquisition methods, and JSON is just
    one type. It also supports CSV files, plain text files, XML files, or even entire
    HTML pages. We strongly suggest that you read about AJAX in the documentation
    at: [https://github.com/d3/d3/blob/master/API.md#requests-d3-request](https://github.com/d3/d3/blob/master/API.md#requests-d3-request).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: D3为我们提供了许多种数据获取方法，JSON只是其中一种。它还支持CSV文件、纯文本文件、XML文件，甚至是整个HTML页面。我们强烈建议您在以下文档中阅读有关AJAX的内容：[https://github.com/d3/d3/blob/master/API.md#requests-d3-request](https://github.com/d3/d3/blob/master/API.md#requests-d3-request)。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the core elements of D3 (`enter()`, `update`,
    and `exit()`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了D3的核心元素（`enter()`、`update`和`exit()`）。
- en: We understood the power of joining data to our visualization. Not only can data
    come from many different sources, but it is possible to have the visualization
    automatically updated as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了将数据与可视化结合的强大功能。数据不仅可以来自许多不同的来源，而且可视化也可以自动更新。
- en: Many detailed examples can be found in the D3 Gallery at: [https://github.com/mbostock/d3/wiki/Gallery](https://github.com/mbostock/d3/wiki/Gallery).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3 Gallery中可以找到许多详细的示例：[https://github.com/mbostock/d3/wiki/Gallery](https://github.com/mbostock/d3/wiki/Gallery)。
- en: In the next chapter, we will combine all of these techniques to build our first
    map from scratch. Get ready!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结合所有这些技术从头开始构建我们的第一张地图。准备好吧！
