- en: Producing Graphics from Data - the Foundations of D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have acquired our toolbox and reviewed the basics of SVG. It is now time
    to explore D3.js. D3 is the evolution of the Protovis ([http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/))
    library. If you have already delved into data visualization have been interested
    in making charts for your web application, you might have already used this library.
    Additional libraries also exist that can be differentiated by how quickly they
    rendered graphics and their compatibility with different browsers. For example,
    Internet Explorer did not support SVG but used its own implementation, VML. This
    made the `Raphaël.js` library an excellent option because it automatically mapped
    to either VML or SVG. On the other hand, jqPlot was easy to use, and its simplistic
    jQuery plugin interface allowed developers to adopt it very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: However, Protovis had something different. Given the vector nature of the library,
    it allowed you to illustrate different kinds of visualizations, as well as generate
    fluid transitions. Please feel free to look at the links provided and see for
    yourself. Examine the force-directed layout at: [http://mbostock.github.io/protovis/ex/force.html](http://mbostock.github.io/protovis/ex/force.html).
    In 2010, these were interesting and compelling visualizations, especially for
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by Protovis, a team at Stanford University (consisting of Jeff Heer,
    Mike Bostock, and Vadim Ogievetsky) began to focus on D3\. D3, and its application
    to SVG, gave developers an easy way to bind their visualizations to data and add
    interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wealth of information available for researching D3\. A great resource
    for complete coverage can be found on the D3 website at: [https://github.com/mbostock/d3/wiki](https://github.com/mbostock/d3/wiki).
    In this chapter, we will introduce the following concepts that will be used throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic SVG elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enter()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exit()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating basic SVG elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common operation in D3 is to select a DOM element and append SVG elements.
    Subsequent calls will then set the SVG attributes, which we learned about in [Chapter
    2](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml), *Creating Images from Simple Text*.
    D3 accomplishes this operation through an easy-to-read, functional syntax called
    **method chaining**. Let''s walk through a very simple example to illustrate how
    this is accomplished (go to `http://localhost:8080/chapter-3/example-1.html` if
    you have the http-server running):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we select the `body` tag and append an SVG element to it. This SVG element
    has a width and height of `200` pixels. We also store the selection in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `svg` variable and append a `<rect>` item to it. This `rect`
    item will start at (`10`,`10`) and will have a width of `50` and a height of `100`.
    From your Chrome browser, open the Chrome developer tools with the Elements tab
    selected and inspect the SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/231de160-0a34-433b-adf5-c07cf1a53e08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the pattern: `append(''svg'')` creates `<svg></svg>`. `attr(''width'',200)`
    and `attr(''height'',200)` sets `width="200"` and `height="200"`  respectively.
    Together, they produce the SVG syntax we learned about in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The enter() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enter()` function is a part of every basic D3 visualization. It allows
    the developer to define a starting point with attached data. The `enter()` function
    can be thought of as a section of code that executes when data is applied to the
    visualization for the first time. Typically, the `enter()` function will follow
    the selection of a DOM element. Let''s walk through an example (`http://localhost:8080/chapter-3/example-2.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the SVG container as we did earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` function is the way we bind data to our selection. In this example,
    we are binding a very simple array, `[1,2]`, to the selection `<rect>`. The `enter()`
    function will loop through the `[1,2]` array and apply the subsequent function
    calls, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we loop through each element in the array, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Append a new `rect` SVG element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Position the `rect` element in coordinates *x = d * 20* and *y = d * 50* for
    the element, where *d* is equal to 1 for the first element and 2 for the second
    element, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will keep `height` and `width` the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Look closely; take a peek at the Chrome developer tools. We see two rectangles,
    each corresponding to one element in our array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daa6cee2-47f6-4921-939b-0d4471d5cdef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember, data doesn''t necessarily have to be boring numbers, such as 1 or
    2\. The data array can consist of any data objects. To illustrate this, we will
    change the previous array to an array of objects in the next example (see `http://localhost:8080/chapter-3/example-3.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6b2fa09-9fac-418b-84f1-013715088026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the following code snippet, our data array has two objects,
    each one with four different key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we loop through each object in the array, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Still append a new `rect` SVG element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position and size the `rect` element by the properties of the object. The first
    rectangle will be positioned at `x=10`, `y=10`, and have a width of `5` and a
    height of `40`. The second rectangle will be positioned at `40`, `10`, and will
    have a width of `100` and a height of `40`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that `d` represents the datum, or each object within the array, which
    is why we refer to `d.x` or `d.y` to get  `x` and `y`  properties accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The update function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not only do we have our rectangles, but we''ve also joined them to a dataset
    composed of two objects. Both objects share the same properties, namely `x`, `y`,
    `width`, and `height`, so it''s easy to loop through them and read/bind the values
    to our visualization. The output of this is a set of static SVG elements. This
    section will cover how to update the SVG elements and properties as the joined
    data changes. Let''s enhance the previous example to explain exactly how this
    works (`http://localhost:8080/chapter-3/example-4.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a0b87c0-44ac-4e67-aa23-ac4bf804d111.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates a new array of objects with random properties for `x`,
    `y`, `width`, and `height`. We can use this to simulate a change in data, allowing
    us to create `n` number of items, all with different properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a function that inserts rectangles into the DOM on every invocation
    of D3\. The description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s generate our fake data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s select our rectangle and assign our data to it. This gives us a variable
    to which we can easily apply `enter()` and `update` later. The following sections
    are written in a verbose way to illustrate exactly what is going on with `enter()`,
    `update`, and `exit()`. While it''s possible to take shortcuts in D3, it''s best
    to stick to the following style to prevent confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous section, for each element in the array we append a rectangle
    tag to the DOM. If you''re running this code in your Chrome browser, you will
    notice that the console only displays `enter placing initial rectangle` twice.
    This is because the `enter()` section is called only when there are more elements
    in the array than in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` section is applied to every element in the original selection,
    excluding entered elements. In the previous example, we set the `x`, `y`, `width`,
    and `height` attributes of the rectangle for every data object. The `update` section
    is not defined with an explicit `update` method. D3 implies an `update` call if
    no other section is provided. If you are running the code in your Chrome browser,
    you will see the console display `updating x position to:` every time the data
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command inserts our working SVG container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command draws the first version of our visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `setInterval()` function is the JavaScript function used to execute an operation
    every *x* milliseconds. In this case, we are calling the `rectangles` function
    every `1000` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `rectangles` function generates a new dataset every time it is called. It
    has the same property structure that we had before, but the values tied to those
    properties are random numbers between *1* and *100*. On the first call, the `enter()`
    section is invoked and we create our initial two rectangles. Every `1000` milliseconds,
    we reinvoke the `rectangles` function with the same data structure but different
    random property attributes. Because the structure is the same, the `enter()` section
    is now skipped and only `update` is reapplied to the existing rectangles. This
    is why we get the same rectangles with different dimensions every time we plot.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` method is very useful. For instance, your dataset could be tied
    to the stock market and you could update your visualization every *n* milliseconds
    to reflect the changes in the stock market. You could also bind the update to
    an event triggered by a user and have the user control the visualization. The
    options are endless.
  prefs: []
  type: TYPE_NORMAL
- en: The exit() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed `enter()` and `update`. We've seen how one determines the starting
    point of our visualization and the other modifies its attributes based on new
    data coming in. However, the examples covered had the exact number of data elements
    with the same properties. What would happen if our new dataset had a different
    amount of items? What if it has fewer or more?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `update` part of the previous example and modify it a bit to
    demonstrate what we''re talking about (`http://localhost:8080/chapter-3/example-5.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f76fdbf-f2e6-46c7-9874-fa5ffb2673a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can explain how this works with two small changes to the `rectangles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we tell the `data` function to create a random number of `data` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exit()` function will be the same as before. Add a new `exit()` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exit()` method serves the purpose of cleansing or cleaning the no-longer-used
    DOM items in our visualization. This is helpful because it allows us to join our
    data with DOM elements, keeping them in sync. An easy way to remember this is
    as follows: if there are more data elements than DOM elements, the `enter()` section
    will be invoked; if there are fewer data elements than DOM elements, the `exit()`
    section will be invoked. In the previous example, we just removed the DOM element
    if there was no matching data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a graphical representation of the sequence that occurs when
    `enter()` and `update` functions are called. Notice that there''s no DOM element
    for data element **6**, so, the `enter()` section is executed. For data elements
    **0** to **5**, the update code is always called. For data element **6**, the
    **update** section will be executed after the **enter** process has completed.
    Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5779c5c0-edf9-4116-ae68-efda44678cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This illustrates what happens when you have fewer data elements than DOM elements.
    The **update** section is always called where there is a match, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c82b03b-0e3d-4ec9-b653-e49415b12ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous JavaScript and XML** (**AJAX**) doesn''t relate 100 percent
    to D3\. It actually has its foundation in JavaScript. In short, AJAX allows the
    developer to obtain data from the background of the web page. This technique is
    extremely useful in map development because geographic datasets can be very large.
    Acquiring the data from the background will help produce a refined user experience.
    In addition, in [Chapter 6](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml), *Finding
    and Working with Geographic Data*, we will cover techniques to compress the size
    of geographic data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Separating the data from the code base will also provide the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: A lighter code base that is easier to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to update the data without making code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to use third-party providers for data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is accomplished by acquiring the data through an AJAX call with the aid
    of a D3 function. Let''s examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `d3.json()` method has two parameters: a path to the file and a callback
    function. The callback function indicates what to do with the data once it has
    been transferred. In the previous code, if the call fetches the data correctly,
    it assigns it to the `json` variable. The `error` variable is just a general error
    object that indicates whether there were any problems fetching the data or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We store our JSON data into the data variable, and continue to process it as
    we did in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/6fbec84a-5332-4bf2-ac79-a7a14cf5147c.png)'
  prefs: []
  type: TYPE_IMG
- en: D3 provides us with many kinds of data acquisition methods, and JSON is just
    one type. It also supports CSV files, plain text files, XML files, or even entire
    HTML pages. We strongly suggest that you read about AJAX in the documentation
    at: [https://github.com/d3/d3/blob/master/API.md#requests-d3-request](https://github.com/d3/d3/blob/master/API.md#requests-d3-request).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained the core elements of D3 (`enter()`, `update`,
    and `exit()`).
  prefs: []
  type: TYPE_NORMAL
- en: We understood the power of joining data to our visualization. Not only can data
    come from many different sources, but it is possible to have the visualization
    automatically updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Many detailed examples can be found in the D3 Gallery at: [https://github.com/mbostock/d3/wiki/Gallery](https://github.com/mbostock/d3/wiki/Gallery).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will combine all of these techniques to build our first
    map from scratch. Get ready!
  prefs: []
  type: TYPE_NORMAL
