<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Viewing Information"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Viewing Information</h1></div></div></div><p>The view layer is the last data flow stop in a Flux architecture. Views are the essence of our application because they provide information directly to the user and respond directly to user interactions. This chapter takes a detailed look at view components within the context of a Flux architecture.</p><p>We'll start with a discussion about getting views their data, and what they can do with it once they have it. Next, we'll look at some examples that emphasize the stateless nature of Flux views. Then, we'll review the responsibilities of views in Flux architectures, which are different from views in other types of frontend architectures.</p><p>We'll wrap the chapter up with a look at using ReactJS components as the view layer. Let's get started!</p><div class="section" title="Passing views data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Passing views data</h1></div></div></div><p>Views don't have their own <a id="id232" class="indexterm"/>data source that they can use to render UI elements. Instead, they rely on the state of Flux stores, and they listen for changes in state. In this section, we'll cover the change event that stores will emit to signify that views can render themselves. We'll also discuss the idea that it's ultimately up to the view to decide when and how to render the UI.</p><div class="section" title="Data via the change event"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Data via the change event</h2></div></div></div><p>The view components that <a id="id233" class="indexterm"/>we've seen so far in this book have all relied on the change event that stores emit when the state of a store has changed. This is how the view knows that it can render itself to the DOM—because there's new store state, meaning that there's probably a visual change that we want the user to see.</p><p>You may have noticed from the earlier examples that all the handler functions that listen for change events had a state parameter—this is the state of the store. The question is—why do we need to include this state data? Why can't the view just reference the store directly to reference the state data? This idea is illustrated here:</p><div class="mediaobject"><img src="graphics/B05419_07_01.jpg" alt="Data via the change event"/></div><p>The change event is still necessary, even though the view is directly referencing the store's state—how else would it know to render? The change event is emitted, and the view then knows that the <a id="id234" class="indexterm"/>state it's referencing has changed as well. There's a potential issue with this approach, and it has to do with immutability. Let's look at some code to better understand the problem. Here's a store with a <code class="literal">name</code> property as its state:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { NAME_CAPS } from '../actions/name-caps';

class First extends EventEmitter {
  constructor() {
    super();

    // The default state is a "name" property
    // with a lower-case string.
    this.state = {
      name: 'foo'
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // Mutates the "name" property, keeping
        // the "state" object intact.
        case NAME_CAPS:
          let { state } = this;
          state.name = state.name.toUpperCase();
          this.emit('change', state);
          break;
      }
    });
  }
}

export default new First();</pre></div><p>When this store responds to the <code class="literal">NAME_CAPS</code> action, its job is to transform the state of the <code class="literal">name</code> property, using a simple call to <code class="literal">toUpperCase()</code>. Then, the change event is emitted with the state as the event<a id="id235" class="indexterm"/> data. Let's look at another store that does the same thing, but using a different approach to updating the <code class="literal">state</code> object:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { NAME_CAPS } from '../actions/name-caps';

class Second extends EventEmitter {
  constructor() {
    super();

    // The defaul state is a name property
    // with a lower-case string.
    this.state = {
      name: 'foo'
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // Assigns a new "state" object, invalidating
        // any references to any previous state.
        case NAME_CAPS:
          this.state = {
            name: this.state.name.toUpperCase()
          };
          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new Second();</pre></div><p>As you can see, the two stores are basically identical, and they produce the same result when the <code class="literal">NAME_CAPS</code> action is dispatched. However, note that this transformation doesn't mutate the <code class="literal">state</code> object. It replaces it instead. This approach keeps the state object immutable, meaning that the <a id="id236" class="indexterm"/>store will never change any of its properties. The difference is felt in the view layer, and it highlights the need for the state argument in the change event handler:</p><div class="informalexample"><pre class="programlisting">import first from './stores/first';
import second from './stores/second';
import { nameCaps } from './actions/name-caps';

// Setup references to the state of the
// two stores.
var firstState = first.state;
var secondState = second.state;

first.on('change', () =&gt; {
  console.log('firstState', firstState.name);
});
// → firstState FOO

second.on('change', () =&gt; {
  console.log('secondState', secondState.name);
});
// → secondState foo

second.on('change', (state) =&gt; {
  console.log('state', state.name);
});
// → state FOO

nameCaps();</pre></div><p>This is why we can't make assumptions about the state of a store. In the preceding code, we just made a critical error in assuming that we could hold onto a <code class="literal">secondStore.state</code> reference. It turns out that this object is immutable, and so the only way for views to access the new state is through the state argument in the change handler.</p></div><div class="section" title="Views decide when to render"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec86"/>Views decide when to render</h2></div></div></div><p>The job of a Flux store is centered primarily on generating the correct information for views to consume. What <a id="id237" class="indexterm"/>isn't part of a store's job description is to know when a view actually needs to update or not. This means that it's up to the view to decide what happens when a store triggers a change event—it could be that nothing in the DOM needs to be updated. The question then becomes—why would a store emit a change event if nothing has changed?</p><p>The simple answer is that stores don't do enough bookkeeping to make a determination as to whether something has changed or not. The store knows how to perform the correct state transformations, but it doesn't necessarily keep track of previous states for diffing purposes—although it certainly could do that.</p><p>Let's look at a store that doesn't mutate its state. Instead, it creates new state when something is transformed:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { NAME_CAPS } from '../actions/name-caps';

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.state = {
      name: 'foo'
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {
        case NAME_CAPS:

          // Convert to upper-case.
          let name = this.state.name.toUpperCase();

          // Only assign the new state object if
          // the "name" isn't already in upper-case.
          this.state = this.state.name === name ?
            this.state : {
              name: this.state.name.toUpperCase()
            };

          // Tell views about the state change, even
          // if the state object is the same.
          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>This store is listening to the same <code class="literal">NAME_CAPS</code> message from the previous example. Its job is still the same—transform the <code class="literal">name</code> property to uppercase. However, this code works differently than in the last version of the store. It's immutable in that it doesn't mutate the <code class="literal">state</code> object—it replaces it. But it only does so if the value has actually changed. Otherwise, the <code class="literal">state</code> object stays the same. The idea here isn't to show that stores should detect state changes on individual properties, but rather that the change event can be emitted even when the state <a id="id238" class="indexterm"/>hasn't changed. In other words, our views shouldn't make the assumption that rendering to the DOM is necessary, just because of a change event.</p><p>Let's turn our attention to the view now. The plan is simple—don't render unless we have to:</p><div class="informalexample"><pre class="programlisting">import myStore from '../stores/my-store';

class MyView {
  constructor() {

    // The view keeps a copy of the previous
    // store state.
    this.previousState = null;

    myStore.on('change', (state) =&gt; {

      // Make sure we have a new state before
      // rendering. If "state" is equal to
      // "previousState", then we know there's
      // nothing new to render.
      if (state !== this.previousState) {
        console.log('name', state.name);
      }

      // Keep a reference of the state, so that
      // we can use it in the next "change"
      // event.
      this.previousState = state;
    });
  }
}

export default new MyView();</pre></div><p>You can see that the <code class="literal">previousState</code> property keeps a reference to the state of the store. But wait, isn't that a bad thing, according to the section before this one? Well, no, because we're not actually using the reference for anything other than strict equality checking. This is used to determine whether or not the view needs to render. Since the store state is immutable, we <a id="id239" class="indexterm"/>can assert that if the same reference is passed as an argument to the change event handler, nothing actually changed and we can safely ignore the event. Let's see what happens when we call the same action several times in succession:</p><div class="informalexample"><pre class="programlisting">import myView from './views/my-view';
import { nameCaps } from './actions/name-caps';

// Despite repeated calls to "nameCaps()",
// "myView" is only rendered once.
nameCaps();
nameCaps();
nameCaps();
// → name FOO</pre></div><p>Later in this chapter when we look at ReactJS, we'll see more advanced scenarios of views that only render what they need to. Later in the book when we look at <code class="literal">Immutable.js</code>, we'll tackle more advanced state change detection.</p></div></div></div>
<div class="section" title="Keeping views stateless"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Keeping views stateless</h1></div></div></div><p>Views can't be completely stateless because they interact with the DOM, and the DOM elements associated with a view will always have a state. However, we can take steps to treat views as stateless entities within the context of our Flux architecture. In this section, we'll address two aspects of stateless views.</p><p>First, we'll go over the idea<a id="id240" class="indexterm"/> that all state in a Flux architecture belongs in a store, including any UI state that we might be tempted to keep in our view components. Second, we'll look at DOM querying and why we want to avoid doing this from within our Flux views.</p><div class="section" title="UI state belongs in stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec87"/>UI state belongs in stores</h2></div></div></div><p>As you learned in the previous<a id="id241" class="indexterm"/> chapter, UI state is just like state that's derived from application data—it all belongs in a store. UI state includes things such as the <code class="literal">disabled</code> property of a button or the name of a class that's applied to a <code class="literal">div</code>. The reason these bits of state belong in a store is that other stores might depend on them. This in turn affects the rendering outcome of other views. This type of dependency is visualized as follows:</p><div class="mediaobject"><img src="graphics/B05419_07_02.jpg" alt="UI state belongs in stores"/></div><p>If the UI state that other stores <a id="id242" class="indexterm"/>might depend on isn't kept in a store, then they'd have to depend on the view or the DOM itself. This is inconsistent and goes against what Flux stands for—strict update ordering and keeping state confined.</p></div><div class="section" title="No querying the DOM"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec88"/>No querying the DOM</h2></div></div></div><p>When the UI state is<a id="id243" class="indexterm"/> kept in a Flux store, there's no need to query the DOM to figure out whether or not a button is disabled. Think about the jQuery approach to manipulating application state. First, we have to issue a DOM query that gets us the relevant DOM elements, and then we have to figure out whether they're in the appropriate state by reading some of their properties. Then, we can make changes elsewhere in the application. Or perhaps there's a blend of state that's kept directly in the DOM and some JavaScript objects.</p><p>It's the consistency that's the biggest difference maker in Flux architectures, because we don't have to query the DOM to get the <code class="literal">href</code> property of a link. The stores that hold onto UI state already have this information. This is always the case—it's never a matter of figuring out whether it's in the DOM or some other component.</p><p>Another advantage of having all the UI state that we need to make rendering decisions in our stores is that there's no performance bottleneck. Querying the DOM once or twice is not a big deal, and this does need to happen if we're going to display changes for the user. What we don't want is to have a long series of DOM query calls that don't even result in something being rendered. In other words, there's no need to query the DOM to extract information when it should already be in a store.</p><p>This is the same strategy used by virtual DOM tree technologies such as ReactJS, where the DOM data is all stored in JavaScript objects. Looking up some UI <a id="id244" class="indexterm"/>state from a JavaScript object is inherently faster than looking up DOM element properties, and this is how ReactJS is able to perform so well—by minimizing the number of DOM interactions for a given UI change.</p></div></div>
<div class="section" title="View responsibilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>View responsibilities</h1></div></div></div><p>At this point in the book, you <a id="id245" class="indexterm"/>probably have a pretty good handle on the role of view components in a Flux architecture. Put simply, their job is to display store information for users by inserting it into the DOM. In this section, we'll break this core view concept into three parts.</p><p>First there's the input to<a id="id246" class="indexterm"/> the views—the store data. Next, we have the structure of the view itself, and the various ways that it can be decomposed into smaller views. Finally, there's the user interactivity. Each of these three areas of view components has a relation to the flow of data through our Flux architecture. Let's look at each of them now.</p><div class="section" title="Rendering store data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Rendering store data</h2></div></div></div><p>If the store transforms data into information that the user needs, then why have views at all? Why not have the stores <a id="id247" class="indexterm"/>directly render the information to the DOM? We need views for a couple reasons. First of all, a store could actually be used in several places, rendered by several views. Second of all, Flux isn't necessarily concerned with the visual display of information. For example, if we were to design some view that's doesn't render HTML but some other display format, that would be perfectly fine.</p><p>Views don't keep any state or perform any transformations on store information. However, they do need to transform the information a little, to turn it into valid markup for display in the browser or any other display medium where our application runs. But aside from marking up the information returned from stores, views have little to do. It's the view technology, such as ReactJS, that does the majority of the legwork in terms of marking up JavaScript objects and inserting them into the DOM. Here is a diagram that shows the process:</p><div class="mediaobject"><img src="graphics/B05419_07_03.jpg" alt="Rendering store data"/></div></div><div class="section" title="Subview structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Subview structure</h2></div></div></div><p>The aim of stores in Flux architectures is to structure them so that there's only one store per top-level feature. This gets <a id="id248" class="indexterm"/>us around the issues created by having massive hierarchies of data structures. Views, on the other hand, can benefit from a little bit of hierarchical structure. Just because a top-level feature is driven by information from a single store, it doesn't mean that only a single view can drive the user experience.</p><p>Earlier in the book, we discussed the notion of hierarchical structure and how it should be avoided in Flux architectures. This is still true to an extent with views, because no matter how you slice it, deep hierarchies are difficult to comprehend. Views do need to be decomposed to an extent, because otherwise we'll end of putting all the markup complexity in one place. HTML markup is hierarchical by nature, so to some degree our views should mimic this structure, as illustrated here:</p><div class="mediaobject"><img src="graphics/B05419_07_04.jpg" alt="Subview structure"/></div><p>Just like stores can be generic, so can views. More than one feature can use generic components to present information using a common display pattern. For instance, think about some kind of expandable/collapsible panel that's used by all of our features—would it not make sense to plug this into our larger features rather than duplicate the functionality? The view technology that we're using is also a deciding factor in how we want to decompose our views into smaller reusable pieces, since this is easier to do with some frameworks than <a id="id249" class="indexterm"/>others. For example, we'll see in the next section that ReactJS makes it easy to compose coarse-grained views out of smaller more fine-grained views because they're largely self-contained.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Something to be aware of when composing view hierarchies like this—be mindful of the data-flow. For example, when a Flux store changes, it emits the change event so that the top-level view can render itself. Then it renders its immediate children, who render their immediate children, and so on. As the store state flows through these views, no data transformations should be happening along the way. Put another way, the leaf views in the tree should get the same information as the root view.</p></div></div></div><div class="section" title="User interactivity"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec91"/>User interactivity</h2></div></div></div><p>The final area of view responsibility we need to think about is user interactivity. Apart from passively watching the information on their screens change as the underlying stores of our architecture handle <a id="id250" class="indexterm"/>actions, they're going to need to do things. If nothing else, users need to be able to navigate around the application to use the various features we've implemented. To handle this sort of thing, the view components that render the UI should also intercept the DOM events as they're triggered. This generally results in a new action being dispatched, as we've already seen earlier in the book.</p><p>The key thing to remember about these event handlers is that they should have essentially one responsibility—calling the right action creator function. What these event handlers should avoid is trying to execute any logic—this belongs in a store, along with the state that the logic affects. This is so fundamental to Flux that it's quite possible I'll repeat it at least twelve more times in the book. Once we start introducing logic in places other than stores, we lose the ability to reason about the state of something—and the state largely determines what the user sees.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>It's entirely plausible to pass action creator functions directly as event handlers to DOM nodes. This could actually help us, because it provides a very low chance of logic being introduced in the wrong place.</p></div></div></div></div>
<div class="section" title="Using ReactJS with Flux"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Using ReactJS with Flux</h1></div></div></div><p>ReactJS is a library for creating view components. In fact, React doesn't even label itself as a view library—it's a set of tools for creating components that render UI elements. This simple premise is <a id="id251" class="indexterm"/>easy to understand and powerful—a perfect fit as the view technology in our Flux architecture.</p><p>In this section, we'll look at <a id="id252" class="indexterm"/>making ReactJS the technology of choice for views in our Flux applications, starting with passing state information from stores into React components. Next, we'll talk about the composition of views, and how Flux state flows from stores to parent views to child views. Lastly, we'll implement some event handling capabilities in our views using React mechanisms and a router using the <code class="literal">react-router</code> library.</p><div class="section" title="Setting the view state"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Setting the view state</h2></div></div></div><p>There are two ways<a id="id253" class="indexterm"/> to render React components based on the state of our Flux stores. These involve two different types of components—statefull and stateless—both of which we'll address here. First, let's take a look at the store containing the state that drives our views:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { ADD } from '../actions/add';

class MyStore extends EventEmitter {
  constructor() {
    super();

    // The "items" state is an empty array
    // by default...
    this.state = {
      items: []
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // Push the "payload" to the "items"
        // array when the "ADD" action is
        // dispatched.
        case ADD:
          let { state } = this;

          state.items.push(e.payload);
          this.emit('change', state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>The idea here is simple—any time an <code class="literal">ADD</code> action is dispatched, we're pushing the action payload onto the <code class="literal">items</code> array. Any React components that wish to respond to this store state change can do so by<a id="id254" class="indexterm"/> listening for the change event. First, let's look at a stateful React component that renders the items list:</p><div class="informalexample"><pre class="programlisting">import { default as React, Component } from 'react';
import myStore from '../stores/my-store';

// A stateful React component that relies on
// it's on state in order to render updates.
export default class Stateful extends Component {
  constructor() {
    super();

    // When "myStore" changes, we set the state of
    // this component by calling "setState()", causing
    // a render to happen.
    myStore.on('change', (state) =&gt; {
      this.setState(state);
    });

    // The initial state of the component is
    // taken from the initial state of the Flux store.
    this.state = myStore.state;
  }

  // Renders a list of items.
  render() {
    return (
      &lt;ul&gt;
        {this.state.items.map(item =&gt;
          &lt;li key={item}&gt;{item}&lt;/li&gt;)}
      &lt;/ul&gt;
    );
  }
}</pre></div><p>This is a typical React component, created using the ES2015 class syntax and extending the base React <code class="literal">Component</code> class. This approach is necessary for stateful components. As you can see, the constructor of this component directly interacts with a Flux store. When the store changes, it calls <code class="literal">setState()</code>, which is how the component renders to reflect new store state. The constructor also sets the initial state by setting the <code class="literal">state</code> property. Next, we have the <code class="literal">render()</code> method, which returns React elements based on this state.</p><p>Note that our React component is <a id="id255" class="indexterm"/>using JSX syntax to define elements. We're not going to cover how this works in this book, nor will we cover other aspects of React in any level of detail. This is a book on Flux architecture, and we'll cover parts of React that are relevant in a Flux context. If you want more of a technical deep dive on React itself, there's plenty of free resources, as well as plenty of other books on the subject.</p><p>Now let's look at another implementation of the exact same component, meaning the exact same output. This is the stateless approach to React components/views:</p><div class="informalexample"><pre class="programlisting">import React from 'react';

// The stateless version of the React
// component is a much stripped-down
// version of a class component. Since
// it only relies on properttes passed
// into it, it can be a basic arrow function
// that returns a React element.
export default ({ items }) =&gt; (
  &lt;ul&gt;
    {items.map(item =&gt;
      &lt;li key={item}&gt;{item}&lt;/li&gt;)}
  &lt;/ul&gt;
);</pre></div><p>Wait, what? This is the exact same component, only it doesn't depend on state. This could be a good thing if we're implementing this as a view component inside our Flux architecture. The thing that stands out most about this implementation is that there are more comments than code, which is a good thing, allowing us to focus on the resulting DOM structure. You'll notice that there's no interaction with a Flux store in this module. Remember, this is a stateless React component, a simple arrow function, which means we don't have any life cycle methods to define, including the initial state. This is okay; let's see how we use both types of components in our <code class="literal">main.js</code> module:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

import Stateful from './views/stateful';
import Stateless from './views/stateless';
import myStore from './stores/my-store';
import { add } from './actions/add';

// These are the DOM element "containers" that
// our React components are rendered into.
var statefulContainer =
  document.getElementById('stateful');
var statelessContainer =
  document.getElementById('stateless');

// Sets up the store change listener for our
// "Stateless" React component. This is simple
// "render()" call, React efficiently handles
// the DOM diffing semantics.
myStore.on('change', (state) =&gt; {
  render(
    &lt;Stateless items={myStore.state.items}/&gt;,
    statelessContainer
  );
});

// Initial rendering of our two components.
render(
  &lt;Stateful/&gt;,
  statefulContainer
);

render(
  &lt;Stateless items={myStore.state.items}/&gt;,
  statelessContainer
);

// Dispatch some actions, causing our store to change,
// and our React components to re-render.
add('first');
add('second');
add('third');</pre></div><p>The key difference here is that the<a id="id256" class="indexterm"/> <code class="literal">Stateless</code> view needs to have its interactions with the store set up manually here. The stateful component encapsulates this by setting up the change listener in the constructor.</p><p>Is one approach superior to the other? Within a Flux architecture, stateless React components tend to have an advantage over their stateful counterparts. This is due to the simple fact that they enforce the idea that state belongs in stores, nowhere else. When our React components are simple<a id="id257" class="indexterm"/> functions, we have no choice but to figure out the correct way to transform store state into something that can be consumed as simple immutable properties.</p></div><div class="section" title="Composing views"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Composing views</h2></div></div></div><p>Just as the state of our application is <a id="id258" class="indexterm"/>composed into stores, the views of that state are composed hierarchically to a degree. I say to a degree because we want to avoid decomposing the structure of our UI at a deep level, as this just makes it difficult to grasp. Where view composition really matters is when we have smaller parts that are used by many larger components. React is good at composing views without introducing too much complexity. In particular, stateless views are a good way to keep the vein of unidirectional data flow as it traverses the view levels. Let's look at an example. Here's a store with some initial state, which sorts this state upon a specific action:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { SORT_DESC } from '../actions/sort-desc';

class MyStore extends EventEmitter {
  constructor() {
    super();

    // The default store state has an array of
    // strings.
    this.state = {
      items: [
        'First',
        'Second',
        'Third'
      ]
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // The "SORT_DESC" action sorts the
        // "items" array in descending order.
        case SORT_DESC:
          let { state } = this;

          state.items.sort().reverse();
          this.emit('change', state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>In this case, we would expect the<a id="id259" class="indexterm"/> array to be <span class="emphasis"><em>Third</em></span>, <span class="emphasis"><em>Second</em></span>, <span class="emphasis"><em>First</em></span> (alphabetically) when the <code class="literal">SORT_DESC</code> action is dispatched. Now, let's look at the main view component that listens to this store:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import Item from './item';

// The application view. Renders a list of
// "Item" components.
export default ({ items }) =&gt; (
  &lt;ul&gt;
    {items.map(item =&gt;
      &lt;Item key={item}&gt;{item}&lt;/Item&gt;)}
  &lt;/ul&gt;
);</pre></div><p>Once again, we have a simple functional view that doesn't hold on to any state, because there's no need—all state is held in the Flux stores. Rather than use an <code class="literal">li</code> element here, we're using a custom <code class="literal">Item</code> React component that we've implemented for our application. This is part of the larger <code class="literal">App</code> view, and perhaps its part of other larger views. The result is code reuse and simplified aggregate views. Let's look at the <code class="literal">Item</code> component next:</p><div class="informalexample"><pre class="programlisting">import React from 'react';

// An "li" component with "strong" text.
export default (props) =&gt; (
  &lt;li&gt;
    &lt;strong&gt;{props.children}&lt;/strong&gt;
  &lt;/li&gt;
);</pre></div><p>Not the most exciting view in the world, and in practice you'll find more complex atomic views than this. But the idea is the same—the value of <code class="literal">props.children</code> ultimately comes from a Flux store, and it traverses a parent view to get here. Let's see how all the pieces fit together in <code class="literal">main.js</code>:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

import myStore from './stores/my-store';
import App from './views/app';
import { sortDesc } from './actions/sort-desc';

// The containiner element for our application.
var appContainer = document.getElementById('app');

// Renders the "App" view component when
// the store state changes.
myStore.on('change', (state) =&gt; {
  render(
    &lt;App {...state}/&gt;,
    appContainer
  );
});

// Initial rendering...
render(
  &lt;App {...myStore.state}/&gt;,
  appContainer
);

// Perform the descending sort...
sortDesc();</pre></div></div><div class="section" title="Reacting to events"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Reacting to events</h2></div></div></div><p>React components have their own <a id="id260" class="indexterm"/>event system baked into them. They're actually a wrapper around the DOM event system, making it easier for us to include event handling functions as part of the component JSX markup. This has implications for our Flux architecture too, because these events often translate directly to action creator function calls.</p><p>To get a feel for React events in a Flux context, let's build on the previous example. We'll add a button that toggles the sort order of our items. But first, we'll take a look at the store modifications required to support this new behavior:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { SORT } from '../actions/sort';

// Constants for the direction label
// of the sort button.
const ASC = 'sort ascending';
const DESC = 'sort descending';

class MyStore extends EventEmitter {
  constructor() {
    super();

    // We have some "items", and a "direction"
    // as the default state of this store.
    this.state = {
      direction: ASC,
      items: [
        'Second',
        'First',
        'Third'
      ]
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {
        case SORT:
          let { state } = this;

          // The "items" are always sorted.
          state.items.sort()

          // If the current "direction" is ascending,
          // then update it to "DESC". Otherwise, it's
          // updated to "ASC" and the order is reversed.
          if (state.direction === ASC) {
            state.direction = DESC;
          } else {
            state.direction = ASC;
            state.items.reverse();
          }

          this.emit('change', state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>There's a new piece of state in <code class="literal">MyStore</code>—<code class="literal">direction</code>. It's relevant to both the sort direction of the items and the text <a id="id261" class="indexterm"/>content of the sort button in the view. Let's take a look at the new application view now:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import Sort from './sort';
import Item from './item';

// The application view. Renders a sort
// button and a list of "Item" components.
export default ({ items, direction }) =&gt; (
  &lt;div&gt;
    &lt;Sort direction={direction}/&gt;
    &lt;ul&gt;
      {items.map(item =&gt;
        &lt;Item key={item}&gt;{item}&lt;/Item&gt;)}
    &lt;/ul&gt;
  &lt;/div&gt;
);</pre></div><p>You can see that the element returned by this stateless function is a <code class="literal">div</code>. Although not strictly necessary from a markup perspective, it is necessary from a <code class="literal">React</code> component perspective—rendering functions can only return one element. The <code class="literal">Sort</code> element we've added above the list represents the sort button. Let's take a look at this component now:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { sort } from '../actions/sort';

// Some inline styles for the React view...
var style = {
  textTransform: 'capitalize'
};

// Renders a "button" element, with the
// "direction" store state as the label
// and the "sort()" action creator function
// is called when the button is clicked.
export default ({ direction }) =&gt; (
  &lt;button
    style={style}
    onClick={sort}&gt;{direction}
  &lt;/button&gt;
);</pre></div><p>This element is a simple <code class="literal">button</code> HTML element, with a style that will capitalize the <code class="literal">direction</code> label. You can see too that the <code class="literal">onClick</code> property is used to specify the event handler. In this case, it's<a id="id262" class="indexterm"/> simple—we're calling the <code class="literal">sort()</code> action creator function directly when the button is clicked.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>In practice, other state-handling actions might be dispatched in concert with the <code class="literal">SORT</code> action. For example, a <code class="literal">PRE_SORT</code> action might be necessary to handle button state.</p></div></div></div><div class="section" title="Routing and actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Routing and actions</h2></div></div></div><p>The <code class="literal">react-router</code> library is the de facto routing solution of ReactJS projects. If we're using React component for in the<a id="id263" class="indexterm"/> view layer of our Flux architecture, then there's a good chance that we'll want to use this package for routing in our application. However, there are<a id="id264" class="indexterm"/> some subtle nuances to be aware of when using <code class="literal">react-router</code> in the context of Flux. In this final section of the chapter, we'll address some of the tradeoffs we need to make with <code class="literal">react-router</code> by implementing it in a Flux architecture.</p><p>The basic premise of <code class="literal">react-router</code> is what makes it so attractive in the first place. The router and the routes within it are themselves React components that we can render into the DOM. We can declare that a given route should render a given React component when the route is activated. The router handles all of the nitty-gritty details for us. The question is, how does this work within the context of a Flux application? As we know, stores are where state lives in our application. So this means that they might want to know about the state of the router as well.</p><p>Let's start by looking at the <code class="literal">main.js</code> module, where the router component is declared and rendered:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';
import { Router, Route, IndexRoute } from 'react-router';

import App from './views/app';
import First from './views/first';
import Second from './views/second';
import { routeUpdate } from './actions/route-update';

// The containiner element for our application.
var appContainer = document.getElementById('app');

// Called by the "Router" whenever a route changes.
// This is where we call the action creator
// "routeUpdate()", passing it the path of the
// new route.
function onUpdate() {
  routeUpdate(this.state.location.pathname);
}

// Renders the router components. Each route
// has an associated React component that's
// rendered when the route is activated.
render((
  &lt;Router onUpdate={onUpdate}&gt;
    &lt;Route path="/" component={App}&gt;
      &lt;IndexRoute component={First}/&gt;
      &lt;Route path="first" components={First}/&gt;
      &lt;Route path="second" component={Second}/&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), appContainer);</pre></div><p>You can see here that there are three <a id="id265" class="indexterm"/>main routes, the default <code class="literal">/</code> route, followed by a <code class="literal">/first</code> and a <code class="literal">/second</code> route. Each route has a corresponding component that's rendered when the route becomes<a id="id266" class="indexterm"/> active. What's interesting about these route declarations is that the <code class="literal">First</code> and <code class="literal">Second</code> components are children of <code class="literal">App</code>. This means that when their routes are activated, they're actually rendered within <code class="literal">App</code>. Let's take a look at the <code class="literal">App</code> component now:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { Link } from 'react-router';

// Renders some links to the routes in the app.
// The "props.children" are any sub-components.
export default (props) =&gt; (
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;Link to="/first"&gt;First&lt;/Link&gt;&lt;/li&gt;
      &lt;li&gt;&lt;Link to="/second"&gt;Second&lt;/Link&gt;&lt;/li&gt;
    &lt;/ul&gt;
    {props.children}
  &lt;/div&gt;
);</pre></div><p>This component renders a list of links that point to our two routes—<code class="literal">first</code> and <code class="literal">second</code>. It also renders child components through <code class="literal">props.children</code>. This is where the child component is rendered. Let's turn our attention to the <code class="literal">routeUpdate()</code> action creator function now. This is called by the <code class="literal">Router</code> component whenever the route changes:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifiers...
export const ROUTE_UPDATE = 'ROUTE_UPDATE';
export const PRE_ROUTE_UPDATE = 'PRE_ROUTE_UPDATE';

export function routeUpdate(payload) {

  // Immediately dispatch the "PRE_ROUTE_UPDATE"
  // action, giving stores a chance to adjust
  // their state while asynchronous activities happen.
  dispatcher.dispatch({
    type: PRE_ROUTE_UPDATE,
    payload: payload
  });

  // Dispatches the "ROUTE_UPDATE" action
  // after one second.
  setTimeout(() =&gt; {
    dispatcher.dispatch({
      type: ROUTE_UPDATE,
      payload: payload
    });
  }, 1000);
}</pre></div><p>There's actually two actions that are <a id="id267" class="indexterm"/>dispatched by this function. First, there's the <code class="literal">PRE_ROUTE_UPDATE</code> action, which is dispatched so that stores have an opportunity to prepare for the changed<a id="id268" class="indexterm"/> route. Then, we perform some asynchronous behavior using <code class="literal">setTimeout()</code> and then dispatch the <code class="literal">ROUTE_UPDATE</code> action. Now let's take a look at one of the stores used by our components. We'll then look at one of the views that listens to this store. The stores and views are nearly identical, so there's no need to look at more than one of each:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';

// We need a couple action constants from
// the same action module.
import {
  PRE_ROUTE_UPDATE,
  ROUTE_UPDATE
} from '../actions/route-update';

class First extends EventEmitter {
  constructor() {
    super();

    // The "content" state is initially an
    // empty string.
    this.state = {
      content: ''
    };

    this.id = dispatcher.register((e) =&gt; {
      let { state } = this;

      switch(e.type) {

        // The "PRE_ROUTE_UPDATE" action means the
        // route is about to change once the
        // asynchronous code in the action creator
        // resolves. We can update the "content"
        // state here.
        case PRE_ROUTE_UPDATE:
          if (e.payload.endsWith('first')) {
            state.content = 'Loading...';
            this.emit('change', state);
          }
          break;

        // When the "ROUTE_UPDATE" action is dispatched,
        // we can change the content to show that it has
        // loaded.
        case ROUTE_UPDATE:
          if (e.payload.endsWith('first')) {
            state.content = 'First Loaded';
            this.emit('change', state);
          }
          break;
      }
    });
  }
}

export default new First();</pre></div><p>The store updates its <code class="literal">content</code> state based on the action type and the current route. This is important because other areas of the application might want to know that this store is waiting for a route update to complete. Now let's look at the view that listens to this store:</p><div class="informalexample"><pre class="programlisting">import { default as React, Component } from 'react';
import first from '../stores/first';

export default class First extends Component {
  constructor() {
    super();

    // The initial state comes from the store.
    this.state = first.state;

    // The store "change" callback function is
    // defined here so that it can be bound to
    // "this" and set the component state.
    this.onChange = (state) =&gt; {
      this.setState(state);
    };
  }

  // Renders the HTML using "content".
  render() {
    return (
      &lt;p&gt;{this.state.content}&lt;/p&gt;
    );
  }

  // Sets up the store "change" listener.
  componentWillMount() {
    first.on('change', this.onChange);
  }

  // Removes the store "change" listener.
  componentWillUnmount() {
    first.removeListener('change', this.onChange);
  }
}</pre></div><p>This component is stateful because it <a id="id269" class="indexterm"/>has to be. Since it's the router that renders the component<a id="id270" class="indexterm"/> initially, we can't re-render it other than by setting its state. This is how we're able to re-render the component to reflect the state of the store—by setting up a handler for the change event. This component also has life cycle methods for listening to the change event of the store, as well as removing the listener. If we didn't remove it, it would try to set the state on a component that isn't mounted.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Summary</h1></div></div></div><p>This chapter went into detail on the view layer of Flux architectures. Starting with getting information into views, you learned that the change event is fundamental in reflecting the state of the store in the view, and that views often read directly from stores during their initial render. Then, we went over the idea that views are stateless. The state of a given UI element belongs in a store, because other parts of the application might depend on this state, and we don't want to have to query the DOM.</p><p>Next, we went over some of the high-level responsibilities of view components. These include rendering store information, composing larger view structures out of smaller view components, and handling user interactivity. We wrapped the chapter up with a walkthrough of using ReactJS components as the view technology in a Flux architecture. In the following chapter, we'll dig into the life cycle of Flux components and how they differ from other architectures.</p></div></body></html>