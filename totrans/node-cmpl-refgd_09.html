<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dynamic Client/Server Interaction with Socket.IO</h1>
                </header>
            
            <article>
                
<p>The original design model of the web is similar to the way that mainframes worked in the 1970s. Both old-school dumb terminals, such as the IBM 3270, and web browsers, follow a request-response paradigm. The user sends a request and the far-off computer sends a response screen. While web browsers can show more complex information than old-school dumb terminals, the interaction pattern in both cases is a back and forth of user requests, each resulting in a screen of data sent by the server screen after screen or, in the case of web browsers, page after page.</p>
<p>In case you're wondering what this history lesson is about, that request-response paradigm is evident in the Node.js HTTP Server API, as shown in the following code:</p>
<div>
<pre><span>http</span><span>.</span><span>createServer</span><span>(</span><span>function</span><span> (</span><strong>request</strong><span>, </span><strong>response</strong><span>) {<br/></span>   ... handle request<br/>}).listen();</pre></div>
<p>The paradigm couldn't be more explicit than this. The <kbd>request</kbd> and the <kbd>response</kbd> are right there.</p>
<p>The first web browsers were an advancement over text-based user interfaces, with HTML mixing images, and text with varying colors, fonts, and sizes. As CSS came along, HTML improved, iframes allowed embedded media of all kinds, and JavaScript improved, so we have a quite different paradigm. The web browser is still sending requests and receiving a page of data, but that data can be quite complex and, more importantly, JavaScript adds interactivity. </p>
<p>One new technique is keeping an open connection to the server for continual data exchange between server and client. This change in the web application model is called, by some, the real-time web. In some cases, websites keep an open connection to the web browser, with real-time updates to web pages being one goal. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Some observe that traditional web applications can untruthfully display their data; that is, if two people are looking at a page, and one person edits that page, that person's browser will update with the correct copy of the page, while the other browser is not updated. The two browsers show different versions of the page, one of which is untruthful. The second browser can even show a page that no longer exists, if the user at the first browser deletes that page. Some think it would be better if the other person's browser is refreshed to show the new content as soon as the page is edited.</p>
<p>This is one possible role of the real-time web; pages that update themselves as page content changes. All kinds of systems support real-time interactivity between folks on the same website. Whether it's seeing Facebook comments pop up as they're written, or collaboratively edited documents, there's a new interactivity paradigm on the web. </p>
<p>We're about to implement this behavior in the Notes application.</p>
<p>One of the original purposes for inventing Node.js was to support the real-time web. The <strong>Comet</strong> application architecture (Comet is related to AJAX, and both happen to be names of household cleaning products) involves holding the HTTP connection open for a long time, with data flowing back and forth between browser and server over that channel. The term Comet was introduced by Alex Russell in his blog in 2006 (<a href="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/"><span class="URLPACKT">http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/</span></a>) as a general term for the architectural pattern to implement this real-time, two-way data exchange between client and server. That blog post called for the development of a programming platform very similar to Node.js.</p>
<p>To simplify the task, we'll lean on the <kbd>Socket.IO</kbd> library (<a href="http://socket.io/"><span class="URLPACKT">http://socket.io/</span></a>). This library simplifies two-way communication between the browser and server, and can support a variety of protocols with fallback to old-school web browsers.</p>
<p>We'll be covering the following topics:</p>
<ul>
<li>Real-time communications in modern web browsers</li>
<li>The <kbd>Socket.IO</kbd> library</li>
<li>Integrating <kbd>Socket.IO</kbd> with an Express application to support real-time communication</li>
<li>User experience for real-time communication</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing Socket.IO</h1>
                </header>
            
            <article>
                
<p>The aim of <kbd>Socket.IO</kbd> is to make real-time apps possible in every browser and mobile device<em>. </em>It supports several transport protocols, choosing the best one for the specific browser.</p>
<p>If you were to implement your application with WebSockets, it would be limited to the modern browsers supporting that protocol. Because <kbd>Socket.IO</kbd> falls back on so many alternate protocols (WebSockets, Flash, XHR, and JSONP), it supports a wide range of web browsers, including some old crufty browsers. </p>
<p>As the application author, you don't have to worry about the specific protocol <kbd>Socket.IO</kbd> uses in a given browser. Instead, you can implement the business logic and the library takes care of the details for you.</p>
<p><kbd>Socket.IO</kbd> requires that a client library make its way into the browser. That library is provided, and is easy to instantiate. You'll be writing code on both the browser side and server side using similar <kbd>Socket.IO</kbd> APIs at each end.</p>
<p>The model that <kbd>Socket.IO</kbd> provides is similar to the <kbd>EventEmitter</kbd> object. The programmer uses the <kbd>.on</kbd> method to listen for events and the <kbd>.emit</kbd> method to send them. The emitted events are sent between the browser and the server with the <kbd>Socket.IO</kbd> library taking care of sending them back and forth.</p>
<div class="packt_infobox">Information about <kbd>Socket.IO</kbd> is available at <a href="https://socket.io/">https://socket.io/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Initializing Socket.IO with Express</h1>
                </header>
            
            <article>
                
<p><kbd>Socket.IO</kbd> works by wrapping itself around an HTTP Server object. Think back to <a href="2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>HTTP Servers and Clients</em>, where we wrote a module that hooked into HTTP Server methods so that we could spy on HTTP transactions. The HTTP Sniffer attaches a listener to every HTTP event to print out the events. But what if you used that idea to do real work? Socket.IO uses a similar concept, listening to HTTP requests and responding to specific ones by using the Socket.IO protocol to communicate with client code in the browser.</p>
<p>To get started, let's first make a duplicate of the code from the previous chapter. If you created a directory named <kbd>chap08</kbd> for that code, create a new directory named <kbd>chap09</kbd> and copy the source tree there.</p>
<p>We won't make changes to the user authentication microservice, but we will use it for user authentication, of course.</p>
<p>In the Notes source directory, install these new modules:</p>
<pre><strong>$ npm install socket.io@2.x passport.socketio@3.7.x --save</strong></pre>
<p>We will incorporate user authentication with the <kbd>passport</kbd> module, used in <a href=""><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Multiuser Authentication the Microservice Way</em>, into some of the real-time interactions we'll implement.</p>
<p>To initialize <kbd>Socket.IO</kbd>, we must do some major surgery on how the Notes application is started. So far, we used the <kbd>bin/www.mjs</kbd> script along with <kbd>app.mjs</kbd>, with each script hosting different steps of launching Notes. <kbd>Socket.IO</kbd> initialization requires that these steps occur in a different order to what we've been doing. Therefore, we must merge these two scripts into one. What we'll do is copy the content of the <kbd>bin/www.mjs</kbd> script into appropriate sections of <kbd>app.mjs</kbd>, and from there, we'll use <kbd>app.mjs</kbd> to launch Notes.</p>
<p>At the beginning of <kbd>app.mjs</kbd>, a<span>dd this to the</span> <kbd>import</kbd><span> statements:</span></p>
<pre>import http from 'http';<br/>import passportSocketIo from 'passport.socketio'; <br/>import session from 'express-session';<br/>import sessionFileStore from 'session-file-store';<br/>const FileStore = sessionFileStore(session); <br/><br/>export const sessionCookieName = 'notescookie.sid';<br/>const sessionSecret = 'keyboard mouse'; <br/>const sessionStore = new FileStore({ path: "sessions" }); </pre>
<p>The <kbd>passport.socketio</kbd> module integrates <kbd>Socket.IO</kbd> with PassportJS-based user authentication. We'll configure this support shortly. The configuration for session management is now shared between <kbd>Socket.IO</kbd>, Express, and Passport. These lines centralize that configuration to one place in <kbd>app.mjs</kbd>, so we can change it once to affect every place it's needed.</p>
<p>Use this to initialize the HTTP Server object:</p>
<pre>const app = express();<br/><br/>export default app;<br/><br/>const server = http.createServer(app);<br/>import socketio from 'socket.io';<br/>const io = socketio(server); <br/> <br/>io.use(passportSocketIo.authorize({ <br/>  cookieParser: cookieParser, <br/>  key: sessionCookieName, <br/>  secret: sessionSecret, <br/>  store: sessionStore <br/>})); </pre>
<p>This moves the <kbd>export default app</kbd> line from the bottom of the file to this location. Doesn't this location make more sense?</p>
<p>The <kbd>io</kbd> object is our entry point into the <kbd>Socket.IO</kbd> API. We need to pass this object to any code that needs to use that API. It won't be enough to simply require the <kbd>socket.io</kbd> module in other modules because the <kbd>io</kbd> object is what wraps the <kbd>server</kbd> object. Instead, we'll be passing the <kbd>io</kbd> object into whatever modules are to use it.</p>
<p>The <kbd>io.use</kbd> function installs in <kbd>Socket.IO</kbd> functions similar to Express middleware. In this case, we integrate Passport authentication into <kbd>Socket.IO</kbd>:</p>
<pre><span>var</span><span> </span><span>port</span><span> </span><span>=</span><span> </span><span>normalizePort</span><span>(</span><span>process</span><span>.</span><span>env</span><span>.</span><span>PORT</span><span> </span><span>||</span><span> </span><span>'3000'</span><span>);<br/></span><span>app</span><span>.</span><span>set</span><span>(</span><span>'port'</span><span>, </span><span>port</span><span>);<br/></span><span><br/>server</span><span>.</span><span>listen</span><span>(</span><span>port</span><span>);<br/></span><span>server</span><span>.</span><span>on</span><span>(</span><span>'error'</span><span>, </span><span>onError</span><span>);<br/></span><span>server</span><span>.</span><span>on</span><span>(</span><span>'listening'</span><span>, </span><span>onListening</span><span>);</span></pre>
<p class="mce-root">This code is copied from <kbd>bin/www.mjs</kbd>, and sets up the port to listen to. It relies on three functions that will also be copied into <kbd>app.mjs</kbd> from <kbd>bin/www.mjs</kbd>:</p>
<pre>app.use(session({ <br/>  store: sessionStore, <br/>  secret: sessionSecret,<br/>  resave: true, <br/>  saveUninitialized: true,<br/>  name: sessionCookieName<br/>})); <br/>initPassport(app);</pre>
<p>This changes the configuration of Express session support to match the configuration variables we set up earlier. It's the same variables used when setting up the <kbd>Socket.IO</kbd> session integration, meaning they're both on the same page.</p>
<p>Use this to initialize <kbd>Socket.IO</kbd> code in the router modules:</p>
<pre>app.use('/', index);<br/>app.use('/users', users); <br/>app.use('/notes', notes);
 <br/>indexSocketio(io); <br/>// notesSocketio(io); </pre>
<p>This is where we pass the <kbd>io</kbd> object into modules that must use it. This is so that the Notes application can send messages to the web browsers about changes in Notes. What that means will be clearer in a second. What's required is analogous to the Express router functions, and therefore the code to send/receive messages from <kbd>Socket.IO</kbd> clients will also be located in the router modules. </p>
<p>We haven't written either of these functions yet (have patience). To support this, we need to make a change in an <kbd>import</kbd> statement at the top:</p>
<pre><span>import</span><span> { </span><span>socketio</span><span> </span><span>as</span><span> </span><span>indexSocketio</span><span>, </span><span>router</span><span> </span><span>as</span><span> </span><span>index</span><span> } </span><span>from</span><span> </span><span>'./routes/index'</span><span>;</span></pre>
<p>Each router module will export a function named <kbd>socketio</kbd>, which we'll have to rename as shown here. This function is what will receive the <kbd>io</kbd> object, and handle any <kbd>Socket.IO</kbd>-based communications. We haven't written these functions yet. </p>
<p>Then, at the end of <kbd>app.mjs</kbd>, we'll copy in the remaining code from <kbd>bin/www.mjs</kbd> so the HTTP Server starts listening on our selected port:</p>
<pre>function normalizePort(val) {<br/>  var port = parseInt(val, 10);<br/>  if (isNaN(port)) { // named pipe<br/>    return val;<br/>  }<br/>  if (port &gt;= 0) { // port number<br/>    return port;<br/>  }<br/>  return false;<br/>}<br/><br/>/**<br/> * Event listener for HTTP server "error" event.<br/> */<br/><br/>function onError(error) {<br/>  if (error.syscall !== 'listen') { throw error; }<br/><br/>  var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + <br/>  port;<br/><br/>  // handle specific listen errors with friendly messages<br/>  switch (error.code) {<br/>    case 'EACCES':<br/>      console.error(bind + ' requires elevated privileges');<br/>      process.exit(1);<br/>      break;<br/>    case 'EADDRINUSE':<br/>      console.error(bind + ' is already in use');<br/>      process.exit(1);<br/>      break;<br/>    default:<br/>      throw error;<br/>  }<br/>}<br/><br/>/**<br/> * Event listener for HTTP server "listening" event.<br/> */<br/><br/>function onListening() {<br/>  var addr = server.address();<br/>  var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;<br/>  debug('Listening on ' + bind);<br/>}</pre>
<p>Then, in <kbd>package.json</kbd>, we must start <kbd>app.mjs</kbd> rather than <kbd>bin/www.mjs</kbd>:</p>
<pre>  "scripts": { 
    "start": "DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 node --experimental-modules ./app",<br/>    "start-server1": "DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3000 node --experimental-modules ./app",<br/>    "start-server2": "DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 PORT=3002 node --experimental-modules ./app",
   ... 
  },</pre>
<p>At this point, you can delete <kbd>bin/www.mjs</kbd> if you like. You can also try starting the server, but it'll fail because the <kbd>indexSocketio</kbd> function does not exist yet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-time updates on the Notes homepage</h1>
                </header>
            
            <article>
                
<p>The goal we're working towards is for the Notes home page to automatically update the list of notes, as notes are edited or deleted. What we've done so far is to restructure the application startup so that <kbd>Socket.IO</kbd> is initialized in the Notes application. There's no change of behavior yet, except that it will crash due to a missing function.</p>
<p>The approach is for the Notes model classes to send messages whenever a note is created, updated, or deleted. In the router classes, we'll listen to those messages, then send a list of note titles to all browsers attached to the Notes application. </p>
<p>Where the Notes model so far has been a passive repository of documents, it now needs to emit events to any interested parties. This is the listener pattern and, in theory, there will be code that is interested in knowing when notes are created, edited, or destroyed. At the moment, we'll use that knowledge to update the Notes home page, but there are many potential other uses of that knowledge.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Notes model as an EventEmitter class</h1>
                </header>
            
            <article>
                
<p>The <kbd>EventEmitter</kbd> is the class that implements listener support. Let's create a new module, <kbd>models/notes-events.mjs</kbd>, containing the following:</p>
<pre>import EventEmitter from 'events'; <br/>class NotesEmitter extends EventEmitter {<br/>    noteCreated(note)  { this.emit('notecreated', note); }<br/>    noteUpdate (note)  { this.emit('noteupdate', note); }<br/>    noteDestroy (data) { this.emit('notedestroy', data); }<br/>} <br/><br/>export default new NotesEmitter();</pre>
<p>This module maintains the listeners to Notes-related events for us. We've created a subclass of <kbd>EventEmitter</kbd> because it already knows how to manage the listeners. An instance of that object is exported as the default export. </p>
<p>Let's now update <kbd>models/notes.mjs</kbd> to use <kbd>notes-events</kbd> to emit events. Because we have a single module, <kbd>notes.mjs</kbd>, to dispatch calls to the individual Notes models, this module provides a key point at which we can intercept the operations and send events. Otherwise, we'd have to integrate the event-sending code into every Notes model. </p>
<pre>import _events from './notes-events'; <br/>export const events = _events;</pre>
<p>We need to <kbd>import</kbd> this module for use here, but also export it so that other modules can also emit Notes events. By doing this, another module that imports Notes can call <kbd>notes.events.function</kbd> to use the <kbd>notes-events</kbd> module.</p>
<p>This technique is called <strong>re-exporting</strong>. Sometimes, you need to export a function from module <em>A</em> that is actually defined in module <em>B</em>. Module <em>A</em> therefore imports the function from module <em>B</em>, adding it to its exports.</p>
<p>Then we do a little rewriting of these functions:</p>
<pre>export async function create(key, title, body) {<br/>    const note = await model().create(key, title, body);<br/>    _events.noteCreated(note);<br/>    return note;<br/>}<br/><br/>export async function update(key, title, body) {<br/>    const note = await model().update(key, title, body);<br/>    _events.noteUpdate(note);<br/>    return note;<br/>}<br/><br/>export async function destroy(key) {<br/>    await model().destroy(key);<br/>    _events.noteDestroy({ key });<br/>    return key;<br/>}</pre>
<p>The contract for the Notes model functions is that they return a <kbd>Promise,</kbd> and therefore our caller will be using <kbd>await</kbd> to resolve the <kbd>Promise.</kbd> There are three steps:</p>
<ol>
<li>Call the corresponding function in the current <kbd>model</kbd> class, and <kbd>await</kbd> its result</li>
<li>Send the corresponding message to our listeners</li>
<li>Return the value, and because this is an <kbd>async</kbd> function, the value will be received as a <kbd>Promise</kbd> that fulfills the contract for these functions</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-time changes in the Notes home page</h1>
                </header>
            
            <article>
                
<p>The Notes model now sends events as Notes are created, updated, or destroyed. For this to be useful, the events must be displayed to our users. Making the events visible to our users means the controller and view portions of the application must consume those events.</p>
<p>Let's start making changes to <kbd>routes/index.mjs</kbd>:</p>
<pre>router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    let notelist = await getKeyTitlesList();<br/>    res.render('index', { <br/>      title: 'Notes', notelist: notelist,<br/>      user: req.user ? req.user : undefined<br/>    });<br/>  } catch (e) { next(e); }<br/>});</pre>
<p>We need to reuse part of the original routing function, to use it in another function. Therefore, we've pulled code that used to be in this block into a new function, <kbd>getKeyTitlesList</kbd>:</p>
<pre>async function getKeyTitlesList() { <br/>  const keylist = await notes.keylist();<br/>  var keyPromises = keylist.map(key =&gt; { <br/>      return notes.read(key).then(note =&gt; { <br/>          return { key: note.key, title: note.title }; <br/>      }); <br/>  }); <br/>  return Promise.all(keyPromises); <br/>}; </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This portion of the original routing function is now its own function. It generates an array of items containing the <kbd>key</kbd> and <kbd>title</kbd> for all existing Notes, using <kbd>Promise.all</kbd> to manage the process of reading everything.</p>
<pre>export function socketio(io) { <br/>  var emitNoteTitles = async () =&gt; { <br/>      const notelist = await getKeyTitlesList()<br/>      io.of('/home').emit('notetitles', { notelist }); <br/>  }; <br/>  notes.events.on('notecreated', emitNoteTitles); <br/>  notes.events.on('noteupdate', emitNoteTitles); <br/>  notes.events.on('notedestroy', emitNoteTitles); <br/>};</pre>
<p>Here is the <kbd>socketio</kbd> function we discussed while modifying <kbd>app.mjs</kbd>. We receive the <kbd>io</kbd> object, then use it to emit a <kbd>notestitles</kbd> event to all connected browsers.</p>
<p>The <kbd>io.of('/namespace')</kbd> method restricts whatever follows to the given namespace. In this case, we're emitting a <kbd>notestitle</kbd> message to the <kbd>/home</kbd> namespace.</p>
<div class="packt_infobox"><span>The </span><kbd>io.of</kbd><span> method defines what <kbd>Socket.IO</kbd> calls a </span>namespace<span>. Namespaces limit the scope of messages sent through <kbd>Socket.IO</kbd>. The default namespace is </span><kbd>/</kbd><span>, and namespaces look like pathnames, in that they're a series of slash-separated names. An event emitted into a namespace is delivered to any socket listening to that namespace.</span></div>
<p>The code, in this case, is fairly straightforward. It listens to the events we just implemented, <kbd>notecreated</kbd>, <kbd>noteupdate</kbd>, and <kbd>notedestroy</kbd>. For each of these events, it emits an event, <kbd>notetitles</kbd>, containing the list of note keys and titles.</p>
<p>That's it!</p>
<p>As Notes are created, updated, and destroyed, we ensure that the homepage will be refreshed to match. The homepage template, <kbd>views/index.hbs</kbd>, will require code to receive that event and rewrite the page to match.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the homepage and layout templates</h1>
                </header>
            
            <article>
                
<p><kbd>Socket.IO</kbd> runs on both client and server, with the two communicating back and forth over the HTTP connection. This requires loading the client JavaScript library into the client browser. Each page of the Notes application in which we seek to implement <kbd>Socket.IO</kbd> services must load the client library and have custom client code for our application.</p>
<p>Each page in Notes will require a different <kbd>Socket.IO</kbd> client implementation, since each page has different requirements. This affects how we load JavaScript code in Notes. </p>
<p>Initially, we simply put JavaScript code at the bottom of <kbd>layout.hbs</kbd>, because every page required the same set of JavaScript modules. But now we've identified the need for a different set of JavaScript on each page. Furthermore, some of the JavaScript needs to be loaded following the JavaScript currently loaded at the bottom of <kbd>layout.hbs</kbd>. Specifically, jQuery is loaded currently in <kbd>layout.hbs</kbd>, but we want to use jQuery in the <kbd>Socket.IO</kbd> clients to perform DOM manipulations on each page. Therefore, some template refactoring is required.</p>
<p>Create a file, <kbd>partials/footerjs.hbs</kbd>, containing:</p>
<div>
<pre><span>&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;<br/></span><span>&lt;</span><span>script</span><span> </span><span>src=</span><span>"/assets/vendor/jquery/jquery.min.js"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;<br/></span><span>&lt;</span><span>script</span><span> </span><span>src=</span><span>"/assets/vendor/popper.js/umd/popper.min.js"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;<br/></span><span>&lt;</span><span>script</span><span> </span><span>src=</span><span>"/assets/vendor/bootstrap/js/bootstrap.min.js"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;<br/></span><span>&lt;</span><span>script</span><span> </span><span>src=</span><span>"/assets/vendor/feather-icons/feather.js"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;<br/></span>&lt;<span>script</span><span>&gt;<br/></span><span> </span><span>feather</span><span>.</span><span>replace</span><span>()<br/></span><span>&lt;/</span><span>script</span><span>&gt;</span></pre></div>
<p>This had been at the bottom of <kbd>views/layout.hbs</kbd>. We now need to modify that file as follows:</p>
<pre>&lt;body&gt;<br/>    {{&gt; header }}<br/>    {{{body}}}<br/>&lt;/body&gt;</pre>
<p>Then, at the bottom of every template (<kbd>error.hbs</kbd>, <kbd>index.hbs</kbd>, <kbd>login.hbs</kbd>, <kbd>notedestroy.hbs</kbd>, <kbd>noteedit.hbs</kbd>, and <kbd>noteview.hbs</kbd>), add this line:</p>
<div>
<pre><span>{{&gt;</span><span> </span><span>footerjs</span><span>}}</span></pre></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>So far, this hasn't changed what will be loaded in the pages, because <kbd>footerjs</kbd> contains exactly what was already at the bottom of <kbd>layout.hbs</kbd>. But it gives us the freedom to load <kbd>Socket.IO</kbd> client code after the scripts in <kbd>footerjs</kbd> are loaded.</p>
<p>In <kbd>views/index.hbs</kbd> add this at the bottom, after the <kbd>footerjs</kbd> partial:</p>
<pre><span>{{&gt;</span><span> </span><span>footerjs</span><span>}}<br/><br/></span><span>&lt;</span><span>script</span><span> </span><span>src=</span><span>"/socket.io/socket.io.js"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span><span> <br/></span><span>&lt;</span><span>script</span><span>&gt;</span><span> <br/></span><span>$</span><span>(</span><span>document</span><span>).</span><span>ready</span><span>(</span><span>function</span><span> () { <br/></span><span>  </span><span>var</span><span> </span><span>socket</span><span> </span><span>=</span><span> </span><span>io</span><span>(</span><span>'/home'</span><span>); <br/></span><span>  </span><span>socket</span><span>.</span><span>on</span><span>(</span><span>'notetitles'</span><span>, </span><span>function</span><span>(</span><span>data</span><span>) { <br/></span><span>    </span><span>var</span><span> </span><span>notelist</span><span> </span><span>=</span><span> </span><span>data</span><span>.</span><span>notelist</span><span>; <br/></span><span>    </span><span>$</span><span>(</span><span>'#notetitles'</span><span>).</span><span>empty</span><span>(); <br/></span><span>    </span><span>for</span><span> (</span><span>var</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>; </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>notelist</span><span>.</span><span>length</span><span>; </span><span>i</span><span>++</span><span>) { <br/></span><span>      </span><span>notedata</span><span> </span><span>=</span><span> </span><span>notelist</span><span>[</span><span>i</span><span>]; <br/></span><span>      </span><span>$</span><span>(</span><span>'#notetitles'</span><span>) <br/></span><span>      .</span><span>append</span><span>(</span><span>'&lt;a class="btn btn-lg btn-block btn-outline-dark" <br/></span><span>      href="/notes/view?key='</span><span>+</span><span> <br/></span><span>      </span><span>notedata</span><span>.</span><span>key</span><span> </span><span>+</span><span>'"&gt;'</span><span>+</span><span> </span><span>notedata</span><span>.</span><span>title</span><span> </span><span>+</span><span>'&lt;/a&gt;'</span><span>); <br/></span><span>    } <br/></span><span>  }); <br/></span><span>}); <br/></span><span>&lt;/</span><span>script</span><span>&gt;</span><span> </span></pre>
<p>The first line is where we load the <kbd>Socket.IO</kbd> client library. You'll notice that we never set up any Express route to handle the <kbd>/socket.io</kbd> URL. Instead, the <kbd>Socket.IO</kbd> library did that for us.</p>
<p>Because we've already loaded jQuery (to support Bootstrap), we can easily ensure that this code is executed once the page is fully loaded using <kbd>$(document).ready</kbd>.</p>
<p>This code first connects a <kbd>socket</kbd> object to the <kbd>/home</kbd> namespace. That namespace is being used for events related to the Notes homepage. We then listen for the <kbd>notetitles</kbd> events, for which some jQuery DOM manipulation erases the current list of Notes and renders a new list on the screen.</p>
<p>That's it. Our code in <kbd>routes/index.mjs</kbd> listened to various events from the Notes model, and, in response, sent a <kbd>notetitles</kbd> event to the browser. The browser code takes that list of note information and redraws the screen.</p>
<div class="packt_infobox">You might notice that our browser-side JavaScript is not using ES-2015/2016/2017 features. This code would, of course, be cleaner if we were to do so. How can we know whether our visitors use a browser modern enough for those language features?  We could use Babel to transpile ES-2015/2016/2017 code into ES5 code capable of running on any browser. However, it may be a useful trade-off to still write ES5 code in the browser.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running Notes with real-time homepage updates</h1>
                </header>
            
            <article>
                
<p>We now have enough implemented to run the application and see some real-time action.</p>
<p>As you did earlier, start the user information microservice in one window:</p>
<pre><strong>$ npm start</strong><br/><br/><strong>&gt; user-auth-server@0.0.1 start /Users/david/chap09/users</strong><br/><strong>&gt; DEBUG=users:* PORT=3333 SEQUELIZE_CONNECT=sequelize-sqlite.yaml node --experimental-modules user-server</strong><br/><br/><strong>(node:11866) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>  users:service User-Auth-Service listening at http://127.0.0.1:3333 +0ms</strong></pre>
<p>Then, in another window, start the Notes application:</p>
<pre><strong><span>$ npm start <br/> <br/>&gt; notes@0.0.0 start /Users/david/chap09/notes <br/>&gt; DEBUG=notes:* SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize USER_SERVICE_URL=http://localhost:3333 node --experimental-modules ./app <br/> <br/>(node:11998) ExperimentalWarning: The ESM module loader is experimental. <br/>  notes:debug-INDEX Listening on port 3000 +0ms</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, in a browser window, go to <kbd>http://localhost:3000</kbd> and log in to the Notes application. To see the real-time effects, open multiple browser windows. If you can use Notes from multiple computers, then do that as well.</p>
<p>In one browser window, start creating and deleting notes, while leaving the other browser windows viewing the home page. Create a note, and it should show up immediately on the home page in the other browser windows. Delete a note and it should disappear immediately as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-time action while viewing notes</h1>
                </header>
            
            <article>
                
<p>It's cool how we can now see real-time changes in a part of the Notes application. Let's turn to the <kbd>/notes/view</kbd> page to see what we can do. What comes to mind is this functionality:</p>
<ul>
<li>Update the note if someone else edits it</li>
<li>Redirect the viewer to the home page if someone else deletes the note</li>
<li>Allow users to leave comments on the note</li>
</ul>
<p>For the first two features, we can rely on the existing events coming from the Notes model. The third feature will require a messaging subsystem, so we'll get to that later in this chapter.</p>
<p>In <kbd>routes/notes.mjs</kbd>, add this to the end of the module:</p>
<pre>export function socketio(io) { 
    notes.events.on('noteupdate',  newnote =&gt; { 
        io.of('/view').emit('noteupdate', newnote); 
    }); 
    notes.events.on('notedestroy', data =&gt; { 
        io.of('/view').emit('notedestroy', data); 
    }); 
}; </pre>
<p>At the top of <kbd>app.mjs,</kbd> make this change:</p>
<div>
<pre>import { socketio as indexSocketio, router as index } from './routes/index';<br/>import { router as users, initPassport } from './routes/users';<br/>import { socketio as notesSocketio, router as notes } from './routes/notes'; </pre></div>
<p class="mce-root"/>
<p>Uncomment that line of code in <kbd>app.mjs</kbd> because we've now implemented the function we said we'd get to later:</p>
<pre>indexSocketio(io); <br/>notesSocketio(io); </pre>
<p>This sets up the Notes application to send<span> </span><kbd>noteupdate</kbd><span> and </span><kbd>notedestroy</kbd><span> messages when notes are updated or destroyed. The destination is </span>the <kbd>/view</kbd> namespace. We'll need to make a corresponding modification to the note view template so it does the right thing. This means any browser viewing any note in the application will connect to this namespace. Every such browser will receive events about any note being changed, even those notes that are not being viewed. This means that the client code will have to check the key, and only take action if the event refers to the note being displayed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the note view template for real-time action</h1>
                </header>
            
            <article>
                
<p>As we did earlier, in order to make these events visible to the user, we must not only add client code to the template, <kbd>views/noteview.hbs</kbd>; we need a couple of small changes to the template:</p>
<pre>&lt;div class="container-fluid"&gt;<br/>    &lt;div class="row"&gt;&lt;div class="col-xs-12"&gt;<br/>        {{#if note}}<strong>&lt;h3 id="notetitle"&gt;</strong>{{ note.title }}&lt;/h3&gt;{{/if}}<br/>        {{#if note}}<strong>&lt;div id="notebody"&gt;</strong>{{ note.body }}&lt;/div&gt;{{/if}}<br/>        &lt;p&gt;Key: {{ notekey }}&lt;/p&gt;<br/>    &lt;/div&gt;&lt;/div&gt;<br/>    {{#if user }}<br/>    {{#if notekey }}<br/>        &lt;div class="row"&gt;&lt;div class="col-xs-12"&gt;<br/>        &lt;div class="btn-group"&gt;<br/>            &lt;a class="btn btn-outline-dark" <br/>                href="/notes/destroy?key={{notekey}}" <br/>                role="button"&gt;Delete&lt;/a&gt;<br/>            &lt;a cl <span class="fontstyle0">e template, </span><span class="fontstyle2">views/noteview.hb</span> <br/> ass="btn btn-outline-dark" <br/>                href="/notes/edit?key={{notekey}}" <br/>                role="button"&gt;Edit&lt;/a&gt;<br/>        &lt;/div&gt;<br/>        &lt;/div&gt;&lt;/div&gt;<br/>    {{/if}}<br/>    {{/if}}<br/>&lt;/div&gt;<br/><br/><strong>{{&gt; footerjs}}</strong><br/><br/><strong>{{#if notekey }}</strong><br/><strong>&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt; </strong><br/><strong>&lt;script&gt; </strong><br/><strong>$(document).ready(function () { </strong><br/><strong>    io('/view').on('noteupdate', function(note) { </strong><br/><strong>        if (note.key === "{{ notekey }}") { </strong><br/><strong>            $('h3#notetitle').empty(); </strong><br/><strong>            $('h3#notetitle').text(note.title); </strong><br/><strong>            $('#notebody').empty(); </strong><br/><strong>            $('#notebody').text(note.body); </strong><br/><strong>        } </strong><br/><strong>    }); </strong><br/><strong>    io('/view').on('notedestroy', function(data) { </strong><br/><strong>        if (data.key === "{{ notekey }}") { </strong><br/><strong>            window.location.href = "/"; </strong><br/><strong>        } </strong><br/><strong>    }); </strong><br/><strong>}); </strong><br/><strong>&lt;/script&gt; </strong><br/><strong>{{/if}}</strong></pre>
<p>We connect to the <kbd>/view</kbd> namespace where the messages are sent. As <kbd>noteupdate</kbd> or <kbd>notedestroy</kbd> messages arrive, we check the key to see whether it matches the key for the note being displayed. </p>
<p>A technique is used here that's important to understand. We have mixed JavaScript executed on the server, with JavaScript executed in the browser. We must compare the <kbd>notekey</kbd> received by the client code against the <kbd>notekey</kbd> for the note being viewed by this page. The latter <kbd>notekey</kbd> value is known on the server, while the former is known in the client.</p>
<p>Remember that code within the <kbd>{{ .. }}</kbd> delimiters is interpreted by the Handlebars template engine on the server. Consider the following:</p>
<pre>if (note.key === "{{ notekey }}") { 
  .. 
} </pre>
<p>This comparison is between the <kbd>notekey</kbd> value in the browser, which arrived inside the message from the server, and the <kbd>notekey</kbd> variable on the server. That variable contains the key of the note being displayed. Therefore, in this case, we are able to ensure these code snippets are executed only for the note being shown on the screen.</p>
<p>For the <kbd>noteupdate</kbd> event, we take the new note content and display it on the screen. For this to work, we had to add <kbd>id=</kbd> attributes to the HTML so we could use jQuery selectors in manipulating the DOM.</p>
<p>For the <kbd>notedestroy</kbd> event, we simply redirect the browser window back to the home page. The note being viewed has been deleted, and there's no point the user continuing to look at a note that no longer exists.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running Notes with real-time updates while viewing a note</h1>
                </header>
            
            <article>
                
<p>At this point, you can now rerun the Notes application and try this out.</p>
<p>Launch the user authentication server and the Notes application as before. Then, in the browser, open multiple windows on the Notes application. This time, have one viewing the home page, and two viewing a note. In one of those windows, edit the note to make a change, and see the text change on both the home page and the page viewing the note.</p>
<p>Then delete the note, and watch it disappear from the home page, and the browser window that had viewed the note is now on the home page.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inter-user chat and commenting for Notes</h1>
                </header>
            
            <article>
                
<p>This is cool! We now have real-time updates in Notes as we edit delete or create notes. Let's now take it to the next level and implement something akin to inter-user chatting.</p>
<p>It's possible to pivot our Notes application concept and take it in the direction of a social network. In the majority of such networks, users post things (notes, pictures, videos, and so on), and other users comment on those things. Done well, these basic elements can develop a large community of people sharing notes with each other. While the Notes application is kind of a toy, it's not too terribly far from being a basic social network. Commenting the way we will do now is a tiny step in that direction.</p>
<p>On each note page, we'll have an area to display messages from Notes users. Each message will show the username, a timestamp, and their message. We'll also need a method for users to post a message, and we'll also allow users to delete messages.</p>
<p class="mce-root"/>
<p>Each of those operations will be performed without refreshing the screen. Instead, code running inside the web page will send commands to/from the server and take actions dynamically.</p>
<p>Let's get started.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data model for storing messages</h1>
                </header>
            
            <article>
                
<p>We need to start by implementing a data model for storing messages. The basic fields required are a unique ID, the username of the person sending the message, the namespace the message is sent to, their message, and finally a timestamp for when the message was sent. As messages are received or deleted, events must be emitted from the model so we can do the right thing on the web page.</p>
<p>This model implementation will be written for <kbd>Sequelize</kbd>. If you prefer a different storage solution, you can , by all means, re-implement the same API on other data storage systems.</p>
<p>Create a new file, <kbd>models/messages-sequelize.mjs</kbd>, containing the following:</p>
<pre>import Sequelize from 'sequelize';<br/>import jsyaml from 'js-yaml'; <br/>import fs from 'fs-extra'; <br/>import util from 'util'; <br/>import EventEmitter from 'events'; <br/> <br/>class MessagesEmitter extends EventEmitter {} <br/><br/>import DBG from 'debug';<br/>const debug = DBG('notes:model-messages'); <br/>const error = DBG('notes:error-messages'); <br/> <br/>var SQMessage; <br/>var sequlz; <br/><br/>export const emitter = new MessagesEmitter();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This sets up the modules being used and also initializes the <kbd>EventEmitter</kbd> interface. We're also exporting the <kbd>EventEmitter</kbd> as <kbd>emitter</kbd> so other modules can use it:</p>
<pre>async function connectDB() { <br/><br/>    if (typeof sequlz === 'undefined') {<br/>        const yamltext = await <br/>        fs.readFile(process.env.SEQUELIZE_CONNECT, 'utf8');<br/>        const params = jsyaml.safeLoad(yamltext, 'utf8'); <br/>        sequlz = new Sequelize(params.dbname, <br/>                 params.username, params.password, params.params); <br/>    }<br/><br/>    if (SQMessage) return SQMessage.sync(); <br/>        <br/>    SQMessage = sequlz.define('Message', { <br/>        id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: <br/>        true }, <br/>        from: Sequelize.STRING, <br/>        namespace: Sequelize.STRING, <br/>        message: Sequelize.STRING(1024), <br/>        timestamp: Sequelize.DATE <br/>    }); <br/>    return SQMessage.sync(); <br/>}</pre>
<p>This defines our message schema in the database. We'll use the same database that we used for Notes, but the messages will be stored in their own table.</p>
<p>The <kbd>id</kbd> field won't be supplied by the caller; instead, it will be autogenerated. Because it is an <kbd>autoIncrement</kbd> field, each message that's added will be assigned a new <kbd>id</kbd> number by the database:</p>
<pre>export async function postMessage(from, namespace, message) { <br/>    const SQMessage = await connectDB();<br/>    const newmsg = await SQMessage.create({ <br/>        from, namespace, message, timestamp: new Date() <br/>    }); <br/>    var toEmit = { <br/>        id: newmsg.id, from: newmsg.from, <br/>        namespace: newmsg.namespace, message: newmsg.message, <br/>        timestamp: newmsg.timestamp <br/>    }; <br/>    emitter.emit('newmessage', toEmit); <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>This is to be called when a user posts a new comment/message. We first store it in the database, and then we emit an event saying the message was created:</p>
<pre>export async function destroyMessage(id, namespace) { <br/>    const SQMessage = await connectDB();<br/>    const msg = await SQMessage.find({ where: { id } });<br/>    if (msg) {<br/>        msg.destroy();<br/>        emitter.emit('destroymessage', { id, namespace }); <br/>    }<br/>}</pre>
<p>This is to be called when a user requests that a message should be deleted. With <kbd>Sequelize</kbd>, we must first find the message and then delete it by calling its <kbd>destroy</kbd> method. Once that's done, we emit a message saying the message was destroyed:</p>
<pre>export async function recentMessages(namespace) { <br/>    const SQMessage = await connectDB();<br/>    const messages = SQMessage.findAll({ <br/>        where: { namespace }, order: [ 'timestamp' ], limit: 20 <br/>    });<br/>    return messages.map(message =&gt; { <br/>        return { <br/>            id: message.id, from: message.from, <br/>            namespace: message.namespace, message: message.message, <br/>            timestamp: message.timestamp <br/>        }; <br/>    }); <br/>}</pre>
<p>While this is meant to be called when viewing a note, it is generalized to work for any Socket.IO namespace. It finds the most recent 20 messages associated with the given namespace and returns a cleaned-up list to the caller.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding messages to the Notes router</h1>
                </header>
            
            <article>
                
<p>Now that we can store messages in the database, let's integrate this into the Notes router module.</p>
<p>In <kbd>routes/notes.mjs</kbd>, add this to the <kbd>import</kbd> statements:</p>
<pre>import * as messages from '../models/messages-sequelize'; </pre>
<p>If you wish to implement a different data storage model for messages, you'll need to change this <kbd>import</kbd> statement. You should consider using an environment variable to specify the module name, as we've done elsewhere:</p>
<pre>// Save incoming message to message pool, then broadcast it <br/>router.post('/make-comment', ensureAuthenticated, async (req, res, next) =&gt; { <br/>    try {<br/>        await messages.postMessage(req.body.from, <br/>            req.body.namespace, req.body.message);<br/>        res.status(200).json({ });<br/>    } catch(err) {<br/>        res.status(500).end(err.stack); <br/>    }<br/>}); <br/> <br/>// Delete the indicated message <br/>router.post('/del-message', ensureAuthenticated, async (req, res, next) =&gt; { <br/>    try {<br/>        await messages.destroyMessage(req.body.id, req.body.namespace);<br/>        res.status(200).json({ });<br/>    } catch(err) { <br/>        res.status(500).end(err.stack); <br/>    }<br/>}); </pre>
<p>This pair of routes, <kbd>/notes/make-comment</kbd> and <kbd>/notes/del-message</kbd>, is used to post a new comment or delete an existing one. Each calls the corresponding data model function and then sends an appropriate response back to the caller.</p>
<p>Remember that <kbd>postMessage</kbd> stores a message in the database, and then it turns around and emits that message to other browsers. Likewise, <kbd>destroyMessage</kbd> deletes the message from the database, then emits a message to other browsers saying that the message has been deleted. Finally, the results from <kbd>recentMessages</kbd> will reflect the current set of messages in the database.</p>
<p>Both of these will be called by AJAX code in the browser:</p>
<pre>module.exports.socketio = function(io) { 
    io.of('/view').on('connection', function(socket) {<br/>        // 'cb' is a function sent from the browser, to which we<br/>        // send the messages for the named note.<br/>        socket.on('getnotemessages', (namespace, cb) =&gt; {<br/>            messages.recentMessages(namespace).then(cb)<br/>            .catch(err =&gt; console.error(err.stack));<br/>        });<br/>    });<br/><br/>    messages.emitter.on('newmessage', newmsg =&gt; {<br/>        io.of('/view').emit('newmessage', newmsg); <br/>    });<br/>    messages.emitter.on('destroymessage', data =&gt; {<br/>        io.of('/view').emit('destroymessage', data); <br/>    });
 .. 
}; </pre>
<p>This is the Socket.IO glue code, which we will add to the code we looked at earlier.</p>
<p>The <kbd>getnotemessages</kbd> message from the browser requests the list of messages for the given Note. This calls the <kbd>recentMessages</kbd> function in the model. This uses a feature of Socket.IO where the client can pass a callback function, and server-side Socket.IO code can invoke that callback, giving it some data.</p>
<p>We also listen to the <kbd>newmessage</kbd> and <kbd>destroymessage</kbd> messages emitted by the messages model, sending corresponding messages to the browser. These are sent using the method described earlier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the note view template for messages</h1>
                </header>
            
            <article>
                
<p>We need to dive back into <kbd>views/noteview.hbs</kbd> with more changes so that we can view, create, and delete messages. This time, we will add a lot of code, including using a Bootstrap modal popup to get the message, several AJAX calls to communicate with the server, and, of course, more Socket.IO stuff.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a Modal window to compose messages</h1>
                </header>
            
            <article>
                
<p>The Bootstrap framework has a Modal component that serves a similar purpose to Modal dialogs in desktop applications. You pop up the Modal, it prevents interaction with other parts of the web page, you enter stuff into fields in the Modal, and then click a button to make it close.</p>
<p>This new segment of code replaces the existing segment defining the <span class="packt_screen">Edit</span> and <span class="packt_screen">Delete</span> buttons, in<span> </span><kbd>views/noteview.hbs</kbd>:</p>
<pre>{{#if user}}<br/>{{#if notekey}}<br/>    &lt;div class="row"&gt;&lt;div class="col-xs-12"&gt;<br/>    &lt;div class="btn-group"&gt;<br/>        &lt;a class="btn btn-outline-dark" href="/notes/destroy?key=<br/>        {{notekey}}" <br/>            role="button"&gt;Delete&lt;/a&gt;<br/>        &lt;a class="btn btn-outline-dark" href="/notes/edit?key=<br/>        {{notekey}}" <br/>            role="button"&gt;Edit&lt;/a&gt;<br/>        &lt;button type="button" class="btn btn-outline-dark" <br/>            data-toggle="modal" <br/>            data-target="#notes-comment-modal"&gt;Comment&lt;/button&gt; <br/>    &lt;/div&gt;<br/>    &lt;/div&gt;&lt;/div&gt;<br/><br/>    &lt;div id="noteMessages"&gt;&lt;/div&gt; <br/>{{/if}}<br/>{{/if}}</pre>
<p>This adds support for posting comments on a note. The user will see a Modal pop-up window in which they write their comment. We'll show the code for the Modal later.</p>
<p>We added a new button labeled <span class="packt_screen">Comment</span> that the user will click to start the process of posting a message. This button is connected to the Modal by way of the element ID specified in the <kbd>data-target</kbd> attribute. The ID will match the outermost <kbd>div</kbd> wrapping the Modal. This structure of <kbd>div</kbd> elements and class names are from the Bootstrap website at <a href="http://getbootstrap.com/docs/4.0/components/modal/">http://getbootstrap.com/docs/4.0/components/modal/</a>.</p>
<p>Let's add the code for the Modal at the bottom of <kbd>views/noteview.hbs</kbd>.</p>
<div>
<pre><span>{{&gt;</span><span> </span><span>footerjs</span><span>}}</span><span><br/><br/></span><span>{{</span><span>#if</span><span> </span><span>notekey</span><span>}}<br/></span><span>{{</span><span>#if</span><span> </span><span>user</span><span>}}<br/></span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"modal fade"</span><span> </span><span>id</span><span>=</span><span>"notes-comment-modal"</span><span> </span><span>tabindex=</span><span>"-1"</span><span> <br/></span><span>      </span><span>role=</span><span>"dialog"</span><span> </span><span>aria-labelledby=</span><span>"noteCommentModalLabel"</span><span> </span><span>aria-hidden=</span><span>"true"</span><span>&gt;<br/></span><span> </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"modal-dialog modal-dialog-centered"</span><span> </span><span>role=</span><span>"document"</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"modal-content"</span><span>&gt;<br/></span><span>     </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"modal-header"</span><span>&gt;<br/></span><span>         </span><span>&lt;</span><span>button</span><span> </span><span>type=</span><span>"button"</span><span> </span><span>class=</span><span>"close"</span><span> </span><span>data-dismiss=</span><span>"modal"</span><span> </span><span>aria-<br/>         label=</span><span>"Close"</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>span</span><span> </span><span>aria-hidden=</span><span>"true"</span><span>&gt;</span><span>&amp;times;</span><span>&lt;/</span><span>span</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;/</span><span>button</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>h4</span><span> </span><span>class=</span><span>"modal-title"</span><span> </span><span>id</span><span>=</span><span>"noteCommentModalLabel"</span><span>&gt;</span><span>Leave a <br/>         Comment</span><span>&lt;/</span><span>h4</span><span>&gt;</span><span> <br/></span><span>     </span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span>     </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"modal-body"</span><span>&gt;<br/></span><span>       </span><span>&lt;</span><span>form method="POST"</span><span> </span><span>id</span><span>=</span><span>"submit-comment"</span><span> </span><span>class=</span><span>"well" data-async </span><span> <br/></span><span>             </span><span>data-target=</span><span>"#rating-modal"</span><span> </span><span>action=</span><span>"/notes/make-comment"</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>input</span><span> </span><span>type=</span><span>"hidden"</span><span> </span><span>name=</span><span>"from"</span><span> </span><span>value=</span><span>"</span><span>{{</span><span> </span><span>user.id</span><span> </span><span>}}</span><span>"</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>input</span><span> </span><span>type=</span><span>"hidden"</span><span> </span><span>name=</span><span>"namespace"</span><span> </span><span>value=</span><span>"/view-<br/></span><span>         {{</span><span>notekey</span><span>}}</span><span>"</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>input</span><span> </span><span>type=</span><span>"hidden"</span><span> </span><span>name=</span><span>"key"</span><span> </span><span>value=</span><span>"</span><span>{{</span><span>notekey</span><span>}}</span><span>"</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;</span><span>fieldset</span><span>&gt;</span><span> <br/></span><span>           </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"form-group"</span><span>&gt;</span><span> <br/></span><span>             </span><span>&lt;</span><span>label</span><span> </span><span>for=</span><span>"noteCommentTextArea"</span><span>&gt;</span><span> <br/></span><span>             Your Excellent Thoughts, Please</span><span>&lt;/</span><span>label</span><span>&gt;</span><span> <br/></span><span>             </span><span>&lt;</span><span>textarea</span><span> </span><span>id</span><span>=</span><span>"noteCommentTextArea"</span><span> </span><span>name=</span><span>"message"</span><span> <br/></span><span>                       </span><span>class=</span><span>"form-control"</span><span> </span><span>rows=</span><span>"3"</span><span>&gt;&lt;/</span><span>textarea</span><span>&gt;</span><span> <br/></span><span>           </span><span>&lt;/</span><span>div</span><span>&gt;</span><span> <br/></span><span> <br/></span><span>           </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"form-group"</span><span>&gt;</span><span> <br/></span><span>             </span><span>&lt;</span><span>div</span><span> </span><span>class=</span><span>"col-sm-offset-2 col-sm-10"</span><span>&gt;</span><span> <br/></span><span>               </span><span>&lt;</span><span>button</span><span> </span><span>id</span><span>=</span><span>"submitNewComment"</span><span> </span><span>type=</span><span>"submit"</span><span> </span><span>class=</span><span>"btn <br/>               btn-default"</span><span>&gt;<br/></span><span>               Make Comment</span><span>&lt;/</span><span>button</span><span>&gt;</span><span> <br/></span><span>             </span><span>&lt;/</span><span>div</span><span>&gt;</span><span> <br/></span><span>           </span><span>&lt;/</span><span>div</span><span>&gt;</span><span> <br/></span><span>         </span><span>&lt;/</span><span>fieldset</span><span>&gt;</span><span> <br/></span><span>      </span><span>&lt;/</span><span>form</span><span>&gt;</span><span> <br/></span><span>   </span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span> </span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span> </span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span>{{</span><span>/if</span><span>}}</span><span> <br/></span><span>{{</span><span>/if</span><span>}}</span><span> </span></pre></div>
<p>The key portion of this is the HTML form contained within the <kbd>div.modal-body</kbd> element. It's a straightforward, normal Bootstrap, augmented form with a normal <span class="packt_screen">Submit</span> button at the bottom. A few hidden <kbd>input</kbd> elements are used to pass extra information inside the request.</p>
<p>With the HTML set up this way, Bootstrap will ensure that this Modal is triggered when the user clicks on the <span class="packt_screen">Comment</span> button. The user can close the Modal by clicking on the <span class="packt_screen">Close</span> button. Otherwise, it's up to us to implement code to handle the form submission using AJAX so that it doesn't cause the page to reload.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending, displaying, and deleting messages</h1>
                </header>
            
            <article>
                
<p>Note that these code snippets are wrapped with <kbd>{{#if}}</kbd> statements, so that certain user interface elements are displayed only to sufficiently privileged users. A user that isn't logged in certainly shouldn't be able to post a message.</p>
<p>Now we have a lot of Socket.IO code to add:</p>
<pre>{{#if notekey}}<br/>{{#if user}}<br/>&lt;script&gt; <br/>$(document).ready(function () { ... });<br/>{{/if}}<br/>{{/if}}</pre>
<p>There's another code section to handle the <kbd>noteupdate</kbd> and <kbd>notedestroy</kbd> messages. This new section has to do with messages that manage the comments.</p>
<p>We need to handle the form submission for posting a new comment, get the recent messages when first viewing a note, listen for events from the server about new messages or deleted messages, render the messages on the screen, and handle requests to delete a message:</p>
<pre>$(document).ready(function () { <br/>    io('/view').emit('getnotemessages', '/view-{{notekey}}', function(msgs) {<br/>        $('#noteMessages').empty();<br/>        if (msgs.length &gt; 0) {<br/>            msgs.forEach(function(newmsg) {<br/>                $('#noteMessages').append(formatMessage(newmsg));<br/>            });<br/>            $('#noteMessages').show();<br/>            connectMsgDelButton();<br/>        } else $('#noteMessages').hide();<br/>    });<br/>    var connectMsgDelButton = function() {<br/>        $('.message-del-button').on('click', function(event) {<br/>            $.post('/notes/del-message', {<br/>                id: $(this).data("id"),<br/>                namespace: $(this).data("namespace")<br/>            },<br/>            function(response) { });<br/>            event.preventDefault();<br/>        });<br/>    };<br/>    var formatMessage = function(newmsg) {<br/>        return '&lt;div id="note-message-'+ newmsg.id +'" class="card"&gt;'<br/>            +'&lt;div class="card-body"&gt;'<br/>            +'&lt;h5 class="card-title"&gt;'+ newmsg.from +'&lt;/h5&gt;'<br/>            +'&lt;div class="card-text"&gt;'+ newmsg.message<br/>            +' &lt;small style="display: block"&gt;'+ newmsg.timestamp <br/>            +'&lt;/small&gt;&lt;/div&gt;'<br/>            +' &lt;button type="button" class="btn btn-primary message-<br/>            del-button" data-id="'<br/>            + newmsg.id +'" data-namespace="'+ newmsg.namespace +'"&gt;'<br/>            +'Delete&lt;/button&gt;'<br/>            +'&lt;/div&gt;'<br/>            +'&lt;/div&gt;';<br/>    };<br/>    io('/view').on('newmessage', function(newmsg) {<br/>        if (newmsg.namespace === '/view-{{notekey}}') {<br/>            $('#noteMessages').prepend(formatMessage(newmsg));<br/>            connectMsgDelButton();<br/>        }<br/>    });<br/>    io('/view').on('destroymessage', function(data) {<br/>        if (data.namespace === '/view-{{notekey}}') {<br/>            $('#noteMessages #note-message-'+ data.id).remove();<br/>        }<br/>    });<br/><br/>    $('form#submit-comment').submit(function(event) {<br/>        // Abort any pending request<br/>        if (request) { request.abort(); }<br/>        var $form = $('form#submit-comment');<br/>        var $target = $($form.attr('data-target'));<br/>        var request = $.ajax({<br/>            type: $form.attr('method'),<br/>            url: $form.attr('action'),<br/>            data: $form.serialize()<br/>        });<br/>        request.done(function (response, textStatus, jqXHR) { });<br/>        request.fail(function (jqXHR, textStatus, errorThrown) {<br/>            alert("ERROR "+ jqXHR.responseText);<br/>        });<br/>        request.always(function () {<br/>            // Reenable the inputs<br/>            $('#notes-comment-modal').modal('hide');<br/>        });<br/>        event.preventDefault();<br/>    });<br/>}); </pre>
<p>The code within <kbd>$('form#submit-comment').submit</kbd> handles the form submission for the comment form. Because we already have jQuery available, we can use its AJAX support to POST a request to the server without causing a page reload.</p>
<p>Using <kbd>event.preventDefault</kbd>, we ensure that the default action does not occur. For the FORM submission, that means the browser page does not reload. What happens is an HTTP POST is sent to <kbd>/notes/make-comment</kbd> with a data payload consisting of the values of the form's <kbd>input</kbd> elements. Included in those values are three hidden inputs, <kbd>from</kbd>, <kbd>namespace</kbd>, and <kbd>key</kbd>, providing useful identification data.</p>
<p>If you refer to the <kbd>/notes/make-comment</kbd> route definition, this calls <kbd>messagesModel.postMessage</kbd> to store the message in the database. That function then posts an event, <kbd>newmessage</kbd>, which our server-side code forwards to any browser that's connected to the namespace. Shortly after that, a <kbd>newmessage</kbd> event will arrive in browsers.</p>
<p>The <span><kbd>newmessage</kbd> event adds a message block, using the <kbd>formatMessage</kbd> function. The HTML for the message is <kbd>prepend</kbd>ed to <kbd>#noteMessages</kbd>.</span></p>
<p>When the page is first loaded, we want to retrieve the current messages. This is kicked off with <kbd>io('/view').emit('getnotemessages', ..</kbd>. This function, as the name implies, sends a <kbd>getnotemessages</kbd> message to the server. We showed the implementation of the server-side handler for this message earlier, in <kbd>routes/notes.mjs</kbd>.</p>
<p>If you remember, we said that Socket.IO supports the provision of a callback function that is called by the server in response to an event. You simply pass a function as the last parameter to a <kbd>.emit</kbd> call. That function is made available at the other end of the communication, to be called when appropriate. To make this clear, we have a callback function on the browser being invoked by server-side code.</p>
<p>In this case, the server-side calls our callback function with a list of messages. The message list arrives in the client-side callback function, which displays them in the <kbd>#noteMessages</kbd> area. It uses jQuery DOM manipulation to erase any existing messages, then renders each message into the messages area using the <kbd>formatMessage</kbd> function.</p>
<p>The message display template, in <kbd>formatMessage</kbd>, is straightforward. It uses a Bootstrap <kbd>card</kbd> to give a nice visual effect. And, there is a button for deleting messages.</p>
<p>In <kbd>formatMessage</kbd> we created a <span class="packt_screen">Delete</span> button for each message. Those buttons need an event handler, and the event handler is set up using the <kbd>connectMsgDelButton</kbd> function. In this case, we send an HTTP POST request to <kbd>/notes/del-message</kbd>. We again use the jQuery AJAX support to post that HTTP request.</p>
<p>The <kbd>/notes/del-message</kbd> route in turn calls <kbd>messagesModel.destroyMessage</kbd> to do the deed. That function then emits an event, <kbd>destroymessage</kbd>, which gets sent back to the browser. As you see here, the <kbd>destroymessage</kbd> event handler causes the corresponding message to be removed using jQuery DOM manipulation. We were careful to add an <kbd>id=</kbd> attribute to every message to make removal easy.</p>
<p>Since the flip side of destruction is creation, we need to have the <kbd>newmessage</kbd> event handler sitting next to the <kbd>destroymessage</kbd> event handler. It also uses jQuery DOM manipulation to insert the new message into the <kbd>#noteMessages</kbd> area.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running Notes and passing messages</h1>
                </header>
            
            <article>
                
<p>That was a lot of code, but we now have the ability to compose messages, display them on the screen, and delete them, all with no page reloads.</p>
<p>You can run the application as we did earlier, first starting the user authentication server in one command-line window and the Notes application in another:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e3ac8ba6-abbb-4615-8d9a-9af3c4f8a538.png" style="width:61.42em;height:40.25em;" width="942" height="617"/></div>
<p class="mce-root"/>
<p>While entering a message, the Modal looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2a33f878-6dae-46fd-8e49-c12b911d91e5.png" style="width:55.25em;height:46.25em;" width="750" height="628"/></div>
<p>Try this with multiple browser windows viewing the same note or different notes. This way, you can verify that notes show up only on the corresponding note window.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other applications of Modal windows</h1>
                </header>
            
            <article>
                
<p>We used a Modal and some AJAX code to avoid one page reload due to a form submission. In the Notes application, as it stands, a similar technique could be used when creating a new note, editing existing notes, and deleting existing notes. In each case, we would use a Modal, some AJAX code to handle the form submission, and some jQuery code to update the page without causing a reload.</p>
<p>But wait, that's not all. Consider the sort of dynamic real-time user interface wizardry on the popular social networks. Imagine what events and/or AJAX calls are required.</p>
<p>When you click on an image in Twitter, it pops up, you guessed it, a Modal window to show a larger version of the image. The Twitter <span class="packt_screen">Compose new Tweet</span> window is also a Modal window. Facebook uses many different Modal windows, such as when sharing a post, reporting a spam post, or while doing a lot of other things Facebook's designers deem to require a pop-up window.</p>
<p>Socket.IO, as we've seen, gives us a rich foundation of events passing between server and client that can build multiuser, multichannel communication experiences for your users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>While we came a long way in this chapter, maybe Facebook doesn't have anything to fear from the baby steps we took toward converting the Notes application into a social network. This chapter gave us the opportunity to explore some really cool technology for pseudo real-time communication between browser sessions.</p>
<p>Look up the technical definition for the phrase <em>real time</em> and you'll see the real-time web is not truly real time. The actual meaning of real time involves software with strict time boundaries that must respond to events within a specified time constraint. Real-time software is typically used in embedded systems to respond to button presses, for applications as diverse as junk food dispensers and medical devices in intensive care units. Eat too much junk food and you could end up in intensive care, and be served by real-time software in both cases. Try and remember the distinction between different meanings for this phrase.</p>
<p>In this chapter, you learned about using Socket.IO for pseudo real-time web experiences, using the <kbd>EventEmitter</kbd> class to send messages between parts of an application, jQuery, AJAX, and other browser-side JavaScript technologies, while avoiding page reloads while making AJAX calls.</p>
<p>In the next chapter, we will look into Node.js application deployment on real servers. Running code on our laptop is cool, but to hit the big time, the application needs to be properly deployed.</p>


            </article>

            
        </section>
    </div>



  </body></html>