<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Moving Sprites Around the Screen &#x2013; An Endless Runner"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Moving Sprites Around the Screen – An Endless Runner</h1></div></div></div><p>A while ago, endless runners started with a game called <span class="strong"><strong>Helicopter</strong></span> where you had to drive a helicopter <a id="id87" class="indexterm"/>through an endless cave, just pressing a button to give it thrust.</p><p>Then, games became more complex until mobile gaming started to spread. Endless runners started gaining a new popularity due to their simple one tap control. The player is just required to touch anywhere when needed to control a helicopter.</p><p>In this chapter, you are going to build an endless runner that features a spaceship flying through a city while avoiding dangerous asteroids.</p><p>In the making of this game, you will learn, among other things, how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scroll big images to give an idea on an endless background</li><li class="listitem" style="list-style-type: disc">Schedule events</li><li class="listitem" style="list-style-type: disc">Control a frame rate</li><li class="listitem" style="list-style-type: disc">Check collision between sprites</li><li class="listitem" style="list-style-type: disc">Create a simple particle system</li><li class="listitem" style="list-style-type: disc">Move sprites manually or using actions</li></ul></div><p>Moreover, although this is supposed to be a cross-platform game, you will also learn about mouse-only controls. It will be easy to change them to touch or tap controls as you already met them during the making of Concentration. All in all, it's something you can find useful should you plan a desktop-only browser game.</p><div class="section" title="Loading and placing graphic resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Loading and placing graphic resources</h1></div></div></div><p>You <a id="id88" class="indexterm"/>need to build the game over the blueprint <a id="id89" class="indexterm"/>created in the first chapter, so <a id="id90" class="indexterm"/>here is the content of the <code class="literal">assets</code> folder:</p><div class="mediaobject"><img src="graphics/0075OS_03_01.jpg" alt="Loading and placing graphic resources"/></div><p>You can <a id="id91" class="indexterm"/>see the spaceship, the asteroid you have to avoid, a small circle to create particle effects, and the scrolling background.</p><p>You will spend some time trying to understand the background. As the game is 480 x 320 pixels, your background should be at least <span class="emphasis"><em>480*2=960</em></span> pixels wide, which is made by two 480 x 320 seamless images.</p><p>With the following image, you will be able to give the player the possibility to fly through an endless cityscape:</p><div class="mediaobject"><img src="graphics/0075OS_03_02.jpg" alt="Loading and placing graphic resources"/></div><p>All <a id="id92" class="indexterm"/>these images need to be preloaded <a id="id93" class="indexterm"/>by the <code class="literal">loadassets.js</code> file located in <a id="id94" class="indexterm"/>
<code class="literal">src</code>, which will become:</p><div class="informalexample"><pre class="programlisting">var gameResources = ["assets/background.png","assets/ship.png","assets/particle.png","assets/asteroid.png"<span class="strong"><strong>];</strong></span>
</pre></div><p>You also <a id="id95" class="indexterm"/>need to make some changes to <code class="literal">main.js</code> because this time you want a game in the landscape mode:</p><div class="informalexample"><pre class="programlisting">cc.game.onStart = function(){
  <span class="strong"><strong>cc.view.setDesignResolutionSize(480, 320, cc.ResolutionPolicy.SHOW_ALL);</strong></span>
  cc.LoaderScene.preload(gameResources, function () {
    cc.director.runScene(new gameScene());
  }, this);
};
cc.game.run();</pre></div><p>The highlighted line shows the new resolution settings.</p></div></div>
<div class="section" title="Adding an endless scrolling background"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Adding an endless scrolling background</h1></div></div></div><p>Now, it's time <a id="id96" class="indexterm"/>to add the cityscape <a id="id97" class="indexterm"/>background, which will scroll endlessly and seamlessly. Finally, you can start editing <code class="literal">gamescript.js</code>:</p><div class="informalexample"><pre class="programlisting">var background;
var gameLayer;
var scrollSpeed = 1;
var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});
var game = cc.Layer.extend({
  init:function () {
    this._super();
    background = new ScrollingBG();
    this.addChild(background);
    this.scheduleUpdate();
  },
  update:function(dt){
    background.scroll();
  }
});
var ScrollingBG = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/background.png");
  },
  onEnter:function() {
    this.setPosition(480,160);
  },
  scroll:function(){
    this.setPosition(this.getPosition().x-scrollSpeed,this.getPosition().y);
    if(this.getPosition().x&lt;0){
      this.setPosition(this.getPosition().x+480,this.getPosition().y);
    }
  }
});</pre></div><p>You might <a id="id98" class="indexterm"/>think that's a lot of <a id="id99" class="indexterm"/>code, but most of it is just a copy and paste of what you've already seen in the making of the Concentration game.</p><p>Let's have a look at the interesting new stuff:</p><div class="informalexample"><pre class="programlisting">var background;
var gameLayer;
var scrollSpeed = 1;</pre></div><p>These three variables will represent the background sprite, the main game layer, and the scrolling speed in pixels per frame. This means you want the background to scroll by one pixel at each frame, that is, 60 pixels per second.</p><p>Now, it <a id="id100" class="indexterm"/>should be really clear why <a id="id101" class="indexterm"/>you are working with a fixed frame rate. On fast bowsers such as Chrome with a 120 fps refresh, you will able to see the background scrolling at the same speed as on the Firefox 60 fps browser.</p><p>The <code class="literal">gameScene</code> code does not contain anything new, so let's jump to game definition, which will introduce a new feature:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    background = new ScrollingBG();
    this.addChild(background);
    this.scheduleUpdate();
  },
  update:function(dt){
    background.scroll();
  }
});</pre></div><p>After declaring a <code class="literal">ScrollingBG</code> class, you will extend the built-in <code class="literal">Sprite</code> class in the same way you did in the making of Concentration when you created the tiles; you can see a call to <code class="literal">scheduleUpdate</code> method.</p><p>Normally, a Cocos2d-JS game is static. It never updates. Like the previous Concentration game, if you leave the game alone for ages, nothing happens.</p><p>To help you add some actions, Cocos2d-JS allows you to schedule events that happen at a certain time.</p><p>The easiest way to schedule an event is the <code class="literal">scheduleUpdate</code> method. It's just like saying you want to do something each time the game is refreshed, which in our case is every 1/60 seconds.</p><p>When you call <code class="literal">scheduleUpdate</code>, a custom <code class="literal">update</code> function will be called at each frame:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
background.scroll();
}</pre></div><p>At the moment, you are just calling a custom method of your <code class="literal">ScrollingBG</code> new class.</p><p>The <a id="id102" class="indexterm"/>definition of <code class="literal">ScrollingBG</code> is also quite simple if you got the basics of class inheritance explained in the <a id="id103" class="indexterm"/>previous chapter:</p><div class="informalexample"><pre class="programlisting">var ScrollingBG = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/background.png");
  },
  onEnter:function() {
    this.setPosition(480,160);
  },
  scroll:function(){
    this.setPosition(this.getPosition().x-scrollSpeed,this.getPosition().y);
    if(this.getPosition().x&lt;0){
      this.setPosition(this.getPosition().x+480,this.getPosition().y);
    }
  }
});</pre></div><p>Here, once you load and add the background image to the screen, you move it by the <code class="literal">scrollSpeed</code> pixels to the left, giving the feeling that it is moving to the right. Once you moved the background image by more than 480 pixels, that is, half of its length or the full length of your game resolution, you move it back by exactly 480 pixels to give the player the illusion of an infinite scrolling.</p><p>I could place a picture of what you get at this point, but it's much better if you test it yourself and see a beautiful scrolling background.</p><p>Note this is just one way to move assets around the screen as Cocos2d-JS offers a set of methods to manage sprite positions. I will cover them when adding asteroids on the screen, but at the moment, let's focus on the main actor of the game: the spaceship!</p></div>
<div class="section" title="Adding the spaceship"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Adding the spaceship</h1></div></div></div><p>The <a id="id104" class="indexterm"/>spaceship you are going to add is just another sprite, but you are going to give it behavior like it was ruled by gravity.</p><p>First, let' s <a id="id105" class="indexterm"/>add a couple of variables:</p><div class="informalexample"><pre class="programlisting">var background;
var gameLayer;
var scrollSpeed = 1;
<span class="strong"><strong>var ship;</strong></span>
<span class="strong"><strong>var gameGravity = -0.05;</strong></span>
</pre></div><p>The <code class="literal">ship</code> variable will be the spaceship itself, whereas <code class="literal">gameGravity</code> is the force that will attract the spaceship toward the bottom of the screen.</p><p>Then, inside the <code class="literal">init</code> function in <code class="literal">game</code> declaration, you add the ship in the same way you added the background:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    background = new ScrollingBG();
    this.addChild(background);
    this.scheduleUpdate();
    <span class="strong"><strong>ship = new Ship();</strong></span>
    <span class="strong"><strong>this.addChild(ship);</strong></span>
  },
  update:function(dt){
    background.scroll();
    <span class="strong"><strong>ship.updateY();</strong></span>
  }
});</pre></div><p>Then, in the <code class="literal">update</code> function (remember this function is automatically called at each frame). Thanks to the <code class="literal">scheduleUpdate</code> method, an <code class="literal">updateY</code> custom method is called.</p><p>The creation of the ship itself does not differ much from just extending the <code class="literal">Sprite</code> class:</p><div class="informalexample"><pre class="programlisting">var Ship = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/ship.png");
    this.ySpeed = 0;
  },
  onEnter:function() {
    this.setPosition(60,160);
  },
  updateY:function() {
    this.setPosition(this.getPosition().x,this.getPosition().y+this.ySpeed);
    this.ySpeed += gameGravity;
  }
});</pre></div><p>The <a id="id106" class="indexterm"/>spaceship is assigned an image and a custom attribute called <code class="literal">ySpeed</code>, initially set to zero from the <code class="literal">ctor</code> constructor.  </p><p>Once it's placed on the stage, the <code class="literal">onEnter</code> function places it at <code class="literal">60</code>, <code class="literal">160</code> (remember its <span class="emphasis"><em>x</em></span> position will never change). Then, the <code class="literal">setPosition</code> function, which is called at each frame by the game's <code class="literal">update</code> function adds <code class="literal">gameGravity</code> value to the ship's vertical speed (<code class="literal">ySpeed</code>) and updates its <span class="emphasis"><em>y</em></span> position by adding speed to the current position.</p><p>This is the <a id="id107" class="indexterm"/>cheapest but quickest way to handle gravity, forces, and thrust (that will be introduced in the next step), and it works well in simple games like an endless runner.</p><p>Now, run the game and see what happens:</p><div class="mediaobject"><img src="graphics/0075OS_03_03.jpg" alt="Adding the spaceship"/></div><p>You should see our previously created nice scrolling background and our poor spaceship falling <a id="id108" class="indexterm"/>down and disappearing off the bottom of the screen.</p><p>You just <a id="id109" class="indexterm"/>learned the first rule of spaceship creation: <span class="emphasis"><em>remember the engine</em></span>.</p></div>
<div class="section" title="Controlling the spaceship"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Controlling the spaceship</h1></div></div></div><p>Players will be able to give thrust to the spaceship by holding the mouse or finger pressed on the screen.</p><p>As you <a id="id110" class="indexterm"/>should be able to detect when the player touches the screen, I am going to show you a mouse-only way to control the spaceship to make you learn something new. You are free to replace this way to control the ship with the one you prefer.</p><p>You are going to <a id="id111" class="indexterm"/>manage ship control in just a few lines, first by adding a new global variable:</p><div class="informalexample"><pre class="programlisting">var background;
var gameLayer;
var scrollSpeed = 1;
var ship;
var gameGravity = -0.05;
<span class="strong"><strong>var gameThrust = 0.1;</strong></span>
</pre></div><p>The <code class="literal">gameThrust</code> <a id="id112" class="indexterm"/>variable represents engine power, the force that will make the ship fly through the air.</p><p>You are controlling the game with the mouse, so that's how you change the <code class="literal">game</code> declaration:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    <span class="strong"><strong>cc.eventManager.addListener({</strong></span>
      <span class="strong"><strong>event: cc.EventListener.MOUSE,</strong></span>
      <span class="strong"><strong>onMouseDown: function(event){</strong></span>
        <span class="strong"><strong>ship.engineOn = true;</strong></span>
      <span class="strong"><strong>},</strong></span>
      <span class="strong"><strong>onMouseUp: function(event){</strong></span>
        <span class="strong"><strong>ship.engineOn = false;</strong></span>
      <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>},this)</strong></span>
    background = new ScrollingBG();
    this.addChild(background);
    this.scheduleUpdate();
    ship = new Ship();
    this.addChild(ship);
    
  },
  update:function(dt){
    background.scroll();
    ship.updateY();
  }
});</pre></div><p>Unlike <a id="id113" class="indexterm"/>in the previous chapter, here you added the listener on the fly without declaring it as a variable and then calling it. It's basically the same as before, it's just that now you are working with the mouse, so you must define the event type as <code class="literal">cc.EventListener.MOUSE</code>. The events are <code class="literal">onMouseDown</code> when the player presses the mouse and <code class="literal">onMouseUp</code> when the mouse is released. Now, with <code class="literal">onMouseDown</code> and <code class="literal">onMouseUp</code>, you just turn the ship's engine to on or off, which is actually a Boolean <code class="literal">ship</code> attribute called <code class="literal">engineOn</code>.</p><p>What are <a id="id114" class="indexterm"/>you going to do with such an attribute? You just update the ship's vertical speed just like you did with the gravity:</p><div class="informalexample"><pre class="programlisting">var Ship = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/ship.png");
    this.ySpeed = 0;
    <span class="strong"><strong>this.engineOn = false;</strong></span>
  },
  onEnter:function() {
    this.setPosition(60,160);
  },
  updateY:function() {
    <span class="strong"><strong>if(this.engineOn){</strong></span>
      <span class="strong"><strong>this.ySpeed += gameThrust;</strong></span>
    <span class="strong"><strong>}</strong></span>
    this.setPosition(this.getPosition().x,this.getPosition().y+this.ySpeed);
    this.ySpeed += gameGravity;
  }
})</pre></div><p>This was really easy. First, you set <code class="literal">engineOn</code> to <code class="literal">false</code> and according to its value, you decide whether you have to add <code class="literal">gameThrust</code> to <code class="literal">ySpeed</code>.</p><p>Test the game and try to control the ship by pressing and releasing the mouse button.</p><div class="mediaobject"><img src="graphics/0075OS_03_04.jpg" alt="Controlling the spaceship"/></div><p>Finally, the <a id="id115" class="indexterm"/>spaceship can fly through the city in peace and harmony. Unfortunately, game designers are a bit mad and they could decide to make some changes to spaceship plans by adding a belt of deadly asteroids big enough to <a id="id116" class="indexterm"/>smash a spaceship.</p></div>
<div class="section" title="Adding asteroids"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Adding asteroids</h1></div></div></div><p>As the <a id="id117" class="indexterm"/>spaceship flies from left to right (actually it does not, but that's how it seems), you have to add asteroids, which enter the screen from the <a id="id118" class="indexterm"/>right-hand side of the game.</p><p>Now, you can just place some asteroid sprites on the right-hand side of the screen and make them move to the left-hand side just like you did with the background cityscape, but you wouldn't learn anything new if you did that, so let's see another way to manage sprite movement.</p><p>First things first, before you can move an asteroid, you have to create it.</p><p>In this game, a new asteroid will appear every half a second, so it's time to schedule another event in the <code class="literal">game</code> class declaration:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    cc.eventManager.addListener({
      event: cc.EventListener.MOUSE,
      onMouseDown: function(event){
        ship.engineOn = true;
      },
      onMouseUp: function(event){
        ship.engineOn = false;
      }
    },this)
    background = new ScrollingBG();
    this.addChild(background);
    this.scheduleUpdate();
    <span class="strong"><strong>this.schedule(this.addAsteroid,0.5);</strong></span>
    ship = new Ship();
    this.addChild(ship);
    
  <span class="strong"><strong>},</strong></span>
  update:function(dt){
    background.scroll();
    ship.updateY();
  },
  <span class="strong"><strong>addAsteroid:function(event){</strong></span>
    <span class="strong"><strong>var asteroid = new Asteroid();</strong></span>
    <span class="strong"><strong>this.addChild(asteroid,1);</strong></span>
  <span class="strong"><strong>},</strong></span>
  <span class="strong"><strong>removeAsteroid:function(asteroid){</strong></span>
    <span class="strong"><strong>this.removeChild(asteroid);</strong></span>
  <span class="strong"><strong>}</strong></span>
});</pre></div><p>To schedule <a id="id119" class="indexterm"/>an event at a given interval, you use the <code class="literal">schedule</code> method that works like <code class="literal">scheduleUpdate</code>, but this time you can also define which function to call, <code class="literal">addAsteroid</code>, in this case, and the interval of time in seconds.</p><p>It's easy to <a id="id120" class="indexterm"/>see what <code class="literal">addAsteroid</code> does: it adds an asteroid by extending the <code class="literal">Sprite</code> class in the same way you saw before. You also added a <code class="literal">removeAsteroid</code> function because you don't want asteroids to remain in the game forever; you will see how to remove them once they are not necessary anymore.</p><p>This is the <code class="literal">Asteroid</code> class:</p><div class="informalexample"><pre class="programlisting">var Asteroid = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/asteroid.png");
  },
  onEnter:function() {
    this._super();
    this.setPosition(600,Math.random()*320);
    var moveAction= cc.MoveTo.create(2.5, new cc.Point(-100,Math.random()*320));
    this.runAction(moveAction);
    this.scheduleUpdate();
  },
  update:function(dt){
    if(this.getPosition().x&lt;-50){
      gameLayer.removeAsteroid(this)
    }
  }
});</pre></div><p>Run <a id="id121" class="indexterm"/>the game and you will see an asteroid belt flying <a id="id122" class="indexterm"/>towards the ship following a random path.</p><div class="mediaobject"><img src="graphics/0075OS_03_05.jpg" alt="Adding asteroids"/></div><p>There is a lot of stuff in a simple class declaration, so let's take a closer look at the preceding code.</p><p>The <code class="literal">ctor</code> constructor simply creates the instance and assigns it an image, as usual. So, the magic happened somewhere else.</p><p>The <code class="literal">onEnter</code> event places the asteroid on the right-hand side of the screen at a random height; the next line is responsible for the whole animation:</p><div class="informalexample"><pre class="programlisting">var moveAction = cc.MoveTo.create(2.5,new cc.Point(-100,Math.random()*320));</pre></div><p>Cocos2d-JS <a id="id123" class="indexterm"/>allows you to create actions, which in this case basically are tweens and can be seen as things to do at a given point in time.</p><p>This action should move to a given random point on the left-hand side of the screen in 2.5 seconds. That's it. It doesn't matter how Cocos2d-JS will perform this task; you just say <span class="emphasis"><em>bring this asteroid and make it fly to that point</em></span>.</p><p>The power of these actions is awesome and you will deal with it in more examples in this book.</p><p>Once the action is created, you make Cocos2d-JS execute it with:</p><div class="informalexample"><pre class="programlisting">this.runAction(moveAction);</pre></div><p>The <a id="id124" class="indexterm"/>asteroid travel is done. You should also see whether there's a <code class="literal">scheduleUpdate</code> call because you want to remove asteroids once they exit from the left-hand side of the screen; so, in the <code class="literal">update</code> function (remember, every <code class="literal">scheduleUpdate</code> method calls an <code class="literal">update</code> function at each frame). You simply check when the asteroid is outside the screen and eventually remove it with the <code class="literal">removeAsteroid</code> method you created before.</p><p>That was really easy, wasn't it?</p><p>Too bad! The asteroids and spaceship do not collide yet, but don't worry, it won't take more than a couple of lines.</p></div>
<div class="section" title="Asteroid versus spaceship collision"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Asteroid versus spaceship collision</h1></div></div></div><p>The <a id="id125" class="indexterm"/>easiest way to see whether <a id="id126" class="indexterm"/>two sprites collide, which is <a id="id127" class="indexterm"/>also the most used in simple fast paced arcade games like the one you are currently building, is by checking whether sprite bounding boxes intersect somehow.</p><p>The bounding box of an image is the smallest rectangle, which entirely contains the image itself, and <a id="id128" class="indexterm"/>the principle of this method can be explained by the following image:</p><div class="mediaobject"><img src="graphics/0075OS_03_06.jpg" alt="Asteroid versus spaceship collision"/></div><p>In this 4x <a id="id129" class="indexterm"/>zoomed image, you can see the three different ways the bounding box collision will react:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Bounding <a id="id130" class="indexterm"/>boxes do not intersect. There is no collision.</li><li class="listitem">Bounding boxes intersect. There is a collision.</li><li class="listitem">Bounding boxes intersect, although there isn't a collision.</li></ol></div><p>In sophisticated collision engines, to prevent case 3, once bounding boxes intersect, a pixel perfect collision is performed, but this is CPU-consuming and at the moment, you don't want such a high level of precision.</p><p>So, if you want <a id="id131" class="indexterm"/>to make case 3 occur as seldom as possible, you can draw your sprites with shapes as close to a rectangle as possible, or you can consider the intersection between two boxes a little smaller than the original bounding boxes.</p><p>Remember, players want to be forgiven, so if it's just a matter of a couple of pixels, it's better not to see an actual collision rather than to see a false positive collision.</p><p>Having said that, here is how Cocos2d-JS will help you to manage bounding box collisions working on asteroid's <code class="literal">update</code> function:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  <span class="strong"><strong>var shipBoundingBox = ship.getBoundingBox();</strong></span>
  <span class="strong"><strong>var asteroidBoundingBox = this.getBoundingBox();</strong></span>
  <span class="strong"><strong>if(cc.rectIntersectsRect(shipBoundingBox,asteroidBoundingBox)){</strong></span>
    <span class="strong"><strong>gameLayer.removeAsteroid(this);</strong></span>
    <span class="strong"><strong>restartGame();</strong></span>
  <span class="strong"><strong>}</strong></span>
  if(this.getPosition().x&lt;-50){
    gameLayer.removeAsteroid(this)
  }
}</pre></div><p>The <code class="literal">getBoundingBox</code> method returns a rectangle, which is the actual sprite bounding box, and the <code class="literal">rectIntersectsRect</code> method checks whether two rectangles intersect.</p><p>This is easy. Collision detection occurs in two lines. Then, the asteroid is removed and the <code class="literal">restartGame</code> function is called.<code class="literal"> </code>This function just resets spaceship's variables, as shown <a id="id132" class="indexterm"/>in the following code:</p><div class="informalexample"><pre class="programlisting">function restartGame(){
  ship.ySpeed = 0;
  ship.setPosition(ship.getPosition().x,160);
}</pre></div><p>Now, test the <a id="id133" class="indexterm"/>game and you will see the spaceship position being reset once it collides with an asteroid. This way, the game becomes a bit punishing when you die, as you will often respawn in front of an asteroid, causing an immediate death. Remember, players want to be forgiven.</p></div>
<div class="section" title="Invulnerability"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Invulnerability</h1></div></div></div><p>This <a id="id134" class="indexterm"/>feature has nothing to do with the new Cocos2d-JS stuff, it's just some polishing in game design, but remember polishing is always better than adding features.</p><p>People played Angry Birds series to death because it's polished, not because wooden blocks did break exactly like a real-world wooden block would.</p><p>So, after the player smashed the spaceship into an asteroid, let's make the spaceship invulnerable for a limited period of time; let the player see the ship cannot be destroyed by making it flash.</p><p>You are going to add an <code class="literal">invulnerability</code> attribute to the spaceship in the ship's <code class="literal">ctor </code>constructor:</p><div class="informalexample"><pre class="programlisting">ctor:function() { 
  this._super(); 
  this.initWithFile("assets/ship.png");
  this.ySpeed = 0;
this.engineOn = false;
<span class="strong"><strong>this.invulnerability = 0;</strong></span>
}</pre></div><p>When <code class="literal">invulnerability</code> is set to zero, this means the spaceship is not invulnerable and can be <a id="id135" class="indexterm"/>destroyed by asteroids. You have to add this case to Asteroid's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  var shipBoundingBox = ship.getBoundingBox();
  var asteroidBoundingBox = this.getBoundingBox();
  if(cc.rectIntersectsRect(shipBoundingBox,asteroidBoundingBox) <span class="strong"><strong>&amp;&amp;ship.invulnerability==0</strong></span>){
    gameLayer.removeAsteroid(this);
    restartGame();
  }
  if(this.getPosition().x&lt;-50){
    gameLayer.removeAsteroid(this)
  }
}</pre></div><p>As you can see, collision is processed only if invulnerability is set to zero, and when you restart the game in the <code class="literal">restartGame</code> function, you assign it a high value, let's say 100:</p><div class="informalexample"><pre class="programlisting">function restartGame(){
  ship.ySpeed = 0;
  ship.setPosition(ship.getPosition().x,160);
<span class="strong"><strong>ship.invulnerability=100;</strong></span>
}</pre></div><p>This means that now the spaceship cannot be destroyed. To give the player a visual feedback and decrease invulnerability, let's add two lines to ship's <code class="literal">updateY</code> function:</p><div class="informalexample"><pre class="programlisting">updateY:function() {
if(this.engineOn){
    this.ySpeed += gameThrust;
  }
<span class="strong"><strong>if(this.invulnerability&gt;0){</strong></span>
    <span class="strong"><strong>this.invulnerability --;</strong></span>
    <span class="strong"><strong>this.setOpacity(255-this.getOpacity());	</strong></span>
  <span class="strong"><strong>}</strong></span>
this.setPosition(this.getPosition().x,this.getPosition().y+this.ySpeed);
  this.ySpeed += gameGravity;
}</pre></div><p>If invulnerability is greater than zero, decrease it and make the spaceship flash by switching its opacity from fully opaque (255) to completely transparent (0).</p><p>The <code class="literal">setOpacity</code> and <code class="literal">getOpacity</code> methods handle sprite's opacity.</p><p>Test the <a id="id136" class="indexterm"/>game and after you run into an asteroid, you should have <span class="emphasis"><em>God mode</em></span> enabled for about a second and a half.</p></div>
<div class="section" title="Preventing the spaceship from flying off the screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Preventing the spaceship from flying off the screen</h1></div></div></div><p>The <a id="id137" class="indexterm"/>last thing you need to do is <a id="id138" class="indexterm"/>prevent the spaceship from flying off the screen. If you press the mouse for too long, or if you don't press the mouse at all, your ship will fly respectively off the top or the bottom of the screen.</p><p>You need to prevent the ship from flying off the screen by punishing it with death.</p><p>Just add these two lines to the ship's <code class="literal">updateY</code> function:</p><div class="informalexample"><pre class="programlisting">updateY:function() {
if(this.engineOn){
    this.ySpeed += gameThrust;
  }
if(this.invulnerability&gt;0){
    this.invulnerability --;
    this.setOpacity(255-this.getOpacity());	
  }
this.setPosition(this.getPosition().x,this.getPosition().y+this.ySpeed);
  this.ySpeed += gameGravity;
<span class="strong"><strong>if(this.getPosition().y&lt;0 || this.getPosition().y&gt;320){</strong></span>
    <span class="strong"><strong>restartGame();</strong></span>
  <span class="strong"><strong>}</strong></span>
}</pre></div><p>No need to <a id="id139" class="indexterm"/>comment them, it's just an <a id="id140" class="indexterm"/>
<code class="literal">if</code> statement that checks for the spaceship's vertical position.</p></div>
<div class="section" title="Adding particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Adding particles</h1></div></div></div><p>Do you <a id="id141" class="indexterm"/>remember that in your <code class="literal">assets</code> folder, there's a yellow circle called <code class="literal">particle.png</code>? You will use it to create a nice particle effect to simulate the spaceship engine.</p><p>Discussing <a id="id142" class="indexterm"/>particle systems is beyond the scope of this book, so for more detailed information as well as complete particle generation software <a id="id143" class="indexterm"/>compatible with Cocos2d-JS, take a look at <a class="ulink" href="https://71squared.com/particledesigner">https://71squared.com/particledesigner</a>.</p><p>Here, you are just going to add the simplest particle effect ever, but you will see it has a visual appeal like the following figure:</p><div class="mediaobject"><img src="graphics/0075OS_03_07.jpg" alt="Adding particles"/></div><p>First, create <a id="id144" class="indexterm"/>a new global variable:</p><div class="informalexample"><pre class="programlisting">var background;
var gameLayer;var scrollSpeed = 1;
var ship;
var gameGravity = -0.05;
var gameThrust = 0.1;
<span class="strong"><strong>var emitter;</strong></span>
</pre></div><p>The emitter will <a id="id145" class="indexterm"/>be created and configured in game's <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  this.setMouseEnabled(true);
  background = new ScrollingBG();
  this.addChild(background);
  this.scheduleUpdate();
  this.schedule(this.addAsteroid,0.5)
  ship = new Ship();
  this.addChild(ship);
  <span class="strong"><strong>emitter = cc.ParticleSun.create();</strong></span>
  <span class="strong"><strong>this.addChild(emitter,1);</strong></span>
  <span class="strong"><strong>var myTexture = cc.textureCache. addImage("assets/particle.png");</strong></span>
  <span class="strong"><strong>emitter.setTexture(myTexture);</strong></span>
  <span class="strong"><strong>emitter.setStartSize(2);</strong></span>
  <span class="strong"><strong>emitter.setEndSize(4);</strong></span>
}</pre></div><p>Here, you can see that the emitter is created with a <span class="strong"><strong>sun</strong></span> effect, an image is assigned to it, and a start and end image size are given to it.</p><p>This is enough to <a id="id146" class="indexterm"/>generate an ever working particle emitter, but you also need it to follow the spaceship only when the engines are working by updating the ship's <code class="literal">updateY</code> function:</p><div class="informalexample"><pre class="programlisting">updateY:function() {
  if(this.engineOn){
    this.ySpeed += gameThrust;
    <span class="strong"><strong>emitter.setPosition(this.getPosition().x-25,this.getPosition().y);</strong></span>
  <span class="strong"><strong>}</strong></span>
  <span class="strong"><strong>else{</strong></span>
    <span class="strong"><strong>emitter.setPosition(this.getPosition().x-250,this.getPosition().y);</strong></span>
  <span class="strong"><strong>}</strong></span>
  if(this.invulnerability&gt;0){
    this.invulnerability --;
    this.setOpacity(255-this.getOpacity());
  }
this.setPosition(this.getPosition().x,this.getPosition().y+this.ySpeed);
  this.ySpeed += gameGravity;
  if(this.getPosition().y&lt;0 || this.getPosition().y&gt;320){
    restartGame();
  }
  
}</pre></div><p>Here, you just move the emitter to spaceship's tail when the engine is on, and outside the screen when the engine is off. Cheap and dirty, but it's working.</p><p>Test the <a id="id147" class="indexterm"/>game; you should see an eye-candy effect when engines are on, just like in the image you saw before.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create tweens, collisions, and so on. You also learned how to pass through particle generation and create a complete working game.</p><p>There is something you should do to get more familiar with Cocos2d-JS, that is, use what you learned until now and improve the game. You can try to switch the control mode from mouse-driven to touch-driven, display text with the maximum distance travelled without hitting an asteroid, and increase the difficulty level every <span class="emphasis"><em>n</em></span> seconds without hitting asteroids by making asteroids faster or appear more often.</p><p>Now, you are ready to dive into the next chapter where touch controls will become more interactive thanks to swipe detection.</p></div></body></html>