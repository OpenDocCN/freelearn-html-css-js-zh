- en: Chapter 3. Developing Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opa is designed for rapid and secure web development. In this chapter, we will
    talk about the fundamental knowledge about developing a web application in Opa.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need for a web application is a web server. In this section
    we will see how to start a web server using Opa.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a web application, resources such as web pages, images, and audios need to
    be served to users; therefore, we need an HTTP server. Let's think for a moment
    about how we would do that in PHP. The typical setup would be an Apache HTTP server
    with mod_php5 installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Opa, things are a bit different. We not only implement our application,
    but also the whole HTTP server. In fact, our web application and its web server
    are basically the same. Our code will be translated into Node.js script after
    compilation, and will be run with Node.js. The benefit of integrating the server
    with a web application is increased security. Let''s just start with a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this code into a file, `301.opa` for example, then compile and run it.
    The two concluding dashes are needed to launch the web application after it has
    completed the compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Type this address in your browser and you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple example](img/3749OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The server module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have started a web server and run our first Opa web application with the
    function `Server.start`. Let''s now take a detailed look at this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function starts a web server with two parameters, the first is configuration
    information and the second is request handler. The `Server.conf` type is the configuration
    for the server. It is a record type with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, we do not want to define all the elements in this type. We can
    extend from the static value `Server.http`. `Server.http` is a predefined default
    configuration with port equal to 8080 and the server protocol is http, and the
    default configuration for https is `Server.https`. In the following two lines,
    we are reusing the `Server.http` configuration, replacing port 8080 by port 8088
    by using the instruction `with port: 8088`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also run your application with the –p option to change the port, which
    will override this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our web server will need to answer differently to different requests, depending
    on which URL was being requested. Therefore, we will need `Server.handler` to
    handle these requests. The `Server.handler` type is much more complicated than
    the `Server.conf` type. It defines how our web server will handle the incoming
    requests. It''s a variant with eight cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example at the beginning of this chapter, we used the simplest case—`{string
    text}`. It accepts all the requests and just shows some text on the page. Let''s
    see how the second case, `{string title, (-> xhtml) page}`, works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The second case also handles all the requests, but it servers a single page.
    The field page is a function with the type `void -> xhtml`, which indicates that
    the function accepts no parameter and produces a value of the type `xhtml`. We
    will talk about XHTML later; the result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The server module](img/3749OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can notice from this screenshot that, compared to the first example, what
    has changed is that the web page we sent to the browser includes HTML markup that
    the web browser renders as a heading type.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the first two cases of `Server.handler`. They are both
    simple and accept all requests. But in real web applications, requests and responses
    are much more complicated, and the web server should respond differently according
    to different requests. This section we will cover the remaining cases of `Server.handler`
    and will show how to handle different types of requests.
  prefs: []
  type: TYPE_NORMAL
- en: The resource handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A resource handler is often used to serve static resources such as images and
    sounds. The case `{stringmap(resource) resources}` performs on a non-decoded URI
    (Uniform Resource Identifier), and returns a resource that the URI matches with
    the resource''s stringmap. To make it clear, let''s suppose there are three images
    in the directory `res: opa1.png, opa2.png, and opa3.png`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create the resources stringmap manually, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The relative URI is the key and the resource of the `.png` file is the value,
    that is, `"res/opa1.png"` is the key and `opa1.png`, as a resource, is the value.
    If the user tries to access the URL `http://localhost:8080/res/opa1.png`, the
    non-decoded relative URI will be `res/opa1.png`. The server will try to find the
    corresponding resource `opa1.png` and serve it back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we add these external files? In Opa, we can use the following two
    directives. These directives will be replaced by a proper value at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@static_content("foo.png")` is replaced by a function that returns the content
    of `compile-time foo.png`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@static_resource("foo.png")` is replaced by a value of the resource type `represents
    foo.png`, with the last modification time, MIME type, among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The difference between these two directives is that `@static_content` is replaced
    by a function, while `@static_resource` is replaced by a resource. Both directives
    have a counterpart that, instead of processing and returning one file, processes
    a directory and returns it as a stringmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@static_content_directory("foo/")` is replaced by a stringmap from file name
    `f` in the directory `foo/ to @static_content("f")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@static_resource_directory("foo/")` is replaced by a stringmap from file name
    `f` in the directory foo/ to `@static_resource("f")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it is very clear that if we want to serve resources in the directory `res`,
    all we need to do is write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can get the resource at `http://localhost:8080/res/opa1.png`.
  prefs: []
  type: TYPE_NORMAL
- en: The dispatch handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The resource handler is very useful for static resources. But frequently, the
    server needs to respond to different requests. The case `{(Uri.relative -> resource)
    dispatch}` is just for that. In this case, the request URL is decoded into an
    `Uri.relative` record, which is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose the user request URL is `http://localhost:8080/admin/find?name=Li&age=28`,
    the record will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this record, we should return a corresponding resource. Most of the
    time, pattern matching is used to dispatch requests. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember what we discussed about pattern matching in the last chapter? It is
    not hard to figure out what happens here. Note that pattern matching is not the
    only way to dispatch requests. You can do almost anything you want to return a
    resource for a given URI. Besides, we can also add a filter with the case `{Server.filter
    filter, (Uri.relative->resource) dispatch}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code will only allow user to access `http://localhost:8080/opa/packt`.
  prefs: []
  type: TYPE_NORMAL
- en: The register handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The case `{Server.registrable_resource register}` is an empty request handler,
    which means it will not handle any request. But it is useful for registering external
    resources such as `js` and `css`, so that we can use them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we registered the `doctype` as `html5`, and some external JavaScript
    and CSS. The JavaScript and CSS registered here is application-wide. It means
    we can use codes from JavaScript and styles from CSS in any page that we create
    in this application.
  prefs: []
  type: TYPE_NORMAL
- en: The customize handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The case `{Parser.general_parser(resource) custom}` is the most configurable
    request handler. The custom parser takes the non-decoded URI from incoming requests
    as input and computes the corresponding resource. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example will match all requests beginning with `"/admin"` to the admin
    page created by the code `Resource.page("Admin",<h1>Admin</h1>)`, all requests
    beginning with `"/user"` to the user page, and all the other requests to a default
    page. You can refer parser in Opa to get more information about how to deal with
    more complex cases.
  prefs: []
  type: TYPE_NORMAL
- en: The handlers group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The case list `(Server.handler)` aggregates several request handlers as a group
    in response to an incoming request. All handlers are tested in the order that
    they are listed until one succeeds and returns a resource. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As a single handler may not be sufficient to deal with all the requests, handlers
    group is a common solution for most web applications developed by Opa.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed how to launch the server and dispatch users' requests. Now
    it is time for the frontend issue, namely, the web page. Web pages are what users
    see and interact with. There are numerous technologies that can be used for building
    excellent web pages, such as PHP, Perl, and Python. But the basic way is using
    HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: XHTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Opa, both HTML and CSS are first class citizens, and are understood and
    checked by the compiler without you having to wrap them as strings. Having XHTML
    as a native type implies near-perfect XSS (cross-site scripting) protection. It
    also means we can easily compose elements, that is, we can write `<div>{foo()}</div>`.
    HTML values have a predefined `xhtml` type, and there is a built-in syntax for
    constructing XHTML values. Here is an overview of the syntax for XHTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserts for both tags and attributes work in XHTML too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, we need to serve our web page as a value of the resource type. The
    function `Resource.page` , or its shortcut `Resource.html`, will help us convert
    XHTML to a resource. `Resource.page` is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the title of the web page and the second argument is
    the content written in XHTML. It will return a value of the resource type that
    we can return to the user. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code fragment serves all the requests to the web page. `Resource.page`
    is sufficient for developers in most cases. But if you need more controls, you
    can refer to `Resource.styled_page` and `Resource.full_page`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to add styles. First, just like XHTML, CSS is a predefined
    datatype in Opa and we can define CSS in Opa code directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is using the register handler that we have talked about before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The stylesheets registered by the register handler are available application-wide,
    which means that you can use them in any page. If you want to add some page specific
    stylesheets, the choice will be `Resource.styled_page`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run this code; the result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding styles](img/3749OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An event handler is a function whose call is triggered by some activity in the
    user interface. Typical event handlers react to user's clicking (the event is
    called `click`), pressing enter (event `newline`), moving the mouse (event `mousemove`),
    or loading the page (event `ready`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Opa, an event handler always has the type `Dom.event -> void`. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code gives an example of how to write event handlers in Opa.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating DOMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Document Object Model (DOM) is a platform and language neutral interface
    that allows programs and scripts to dynamically access and update the content,
    structure, and style of documents.
  prefs: []
  type: TYPE_NORMAL
- en: At times, we may want to change the content of a page dynamically. To accomplish
    this, we will often need to interact with the DOM. Opa provides the module `Dom`
    for the purpose of manipulating the contents of the page currently being displayed
    by the browser. You can use it to add and remove elements to and from the page,
    to get the contents of a form, or to apply styles or special effects.
  prefs: []
  type: TYPE_NORMAL
- en: DOM selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step that is necessary, in order to use DOMs, is to select the one
    that you want to work with. Opa provides many ways of selecting elements. You
    can find all the available selection functions in the module `Dom`. The most commonly
    used ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As `Dom.select_id` is used everywhere and very frequently, Opa provides a shortcut
    for it. You can simply write `#id`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Reading values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often we need to read values or get content from some element of a page. For
    example, getting user''s input or getting the width of an element. Opa provides
    many `get` functions to get information of a given `Dom` item. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates some commonly used functions on `Dom`, we can find
    more on online Opa API for the entry Dom. Please do not confuse `Dom.get_value`
    with `Dom.get_text`. The first one will return the content entered by the user
    (for example, from an input, a menu, and so on), while the second one will return
    the content inserted in `Dom`. We can figure that out from the second and third
    line of the example we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: Updating content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Opa offers three syntactical shortcuts that simplify some of the most common
    transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, there are many other functions you can use to add, remove, and
    update the content of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Binding an event handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite common to bind an event handler dynamically at runtime, especially
    when you are creating controls programmatically. In Opa, we can do this with `Dom.bind`
    ,which is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns a value of the type `Dom.event_handler`, which you can
    use to unbind the event handler. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Opa provides several techniques for adding animations to a web page. These
    include simple, standard animations that are frequently used such as fade-in,
    fade-out, and hide. To apply an animation to a `Dom` item, you should use the
    function `Dom.transaction` , which is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is a `Dom` item and the second parameter is the effect
    you want to apply to this `Dom` item. You can find a full list of effects supported
    by Opa in the module `Dom.Effect`. Here is an example of animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first introduced how to start a web server with the function
    `Server.start`, which is the starting point of our web application. Then we discussed
    in detail the different cases of `Server.handler`, and how to use them to dispatch
    user requests. After that, we talked about preparing web pages. Finally, we learned
    how to change the content of the page dynamically by interacting with DOM.
  prefs: []
  type: TYPE_NORMAL
