- en: Chapter 3. Developing Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：开发网络应用
- en: Opa is designed for rapid and secure web development. In this chapter, we will
    talk about the fundamental knowledge about developing a web application in Opa.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 是为快速和安全的网络开发而设计的。在本章中，我们将讨论在 Opa 中开发网络应用的基本知识。
- en: Starting a web server
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动网络服务器
- en: The first thing we need for a web application is a web server. In this section
    we will see how to start a web server using Opa.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发一个网络应用首先需要的是一个网络服务器。在本节中，我们将了解如何使用 Opa 启动一个网络服务器。
- en: A simple example
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: As a web application, resources such as web pages, images, and audios need to
    be served to users; therefore, we need an HTTP server. Let's think for a moment
    about how we would do that in PHP. The typical setup would be an Apache HTTP server
    with mod_php5 installed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络应用，需要向用户提供服务，例如网页、图片和音频；因此，我们需要一个 HTTP 服务器。让我们暂时思考一下我们如何在 PHP 中做到这一点。典型的设置是一个安装了
    mod_php5 的 Apache HTTP 服务器。
- en: 'With Opa, things are a bit different. We not only implement our application,
    but also the whole HTTP server. In fact, our web application and its web server
    are basically the same. Our code will be translated into Node.js script after
    compilation, and will be run with Node.js. The benefit of integrating the server
    with a web application is increased security. Let''s just start with a simple
    example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Opa，事情有些不同。我们不仅实现了我们的应用，还实现了整个 HTTP 服务器。实际上，我们的网络应用及其网络服务器基本上是相同的。我们的代码在编译后将被转换为
    Node.js 脚本，并使用 Node.js 运行。将服务器与网络应用集成的好处是提高了安全性。让我们从一个简单的例子开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this code into a file, `301.opa` for example, then compile and run it.
    The two concluding dashes are needed to launch the web application after it has
    completed the compilation:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存到一个文件中，例如 `301.opa`，然后编译并运行它。在编译完成后，需要两个结尾破折号来启动网络应用：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will be:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Type this address in your browser and you will see something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中输入此地址，你将看到类似以下的内容：
- en: '![A simple example](img/3749OS_03_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的例子](img/3749OS_03_01.jpg)'
- en: The server module
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器模块
- en: 'We have started a web server and run our first Opa web application with the
    function `Server.start`. Let''s now take a detailed look at this function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了一个网络服务器，并使用 `Server.start` 函数运行了我们的第一个 Opa 网络应用。现在让我们详细看看这个函数：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function starts a web server with two parameters, the first is configuration
    information and the second is request handler. The `Server.conf` type is the configuration
    for the server. It is a record type with the following fields:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用两个参数启动网络服务器，第一个是配置信息，第二个是请求处理器。`Server.conf` 类型是服务器的配置。它是一个具有以下字段的记录类型：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In most cases, we do not want to define all the elements in this type. We can
    extend from the static value `Server.http`. `Server.http` is a predefined default
    configuration with port equal to 8080 and the server protocol is http, and the
    default configuration for https is `Server.https`. In the following two lines,
    we are reusing the `Server.http` configuration, replacing port 8080 by port 8088
    by using the instruction `with port: 8088`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '在大多数情况下，我们不想定义这个类型中的所有元素。我们可以从静态值 `Server.http` 继承。`Server.http` 是一个预定义的默认配置，端口号为
    8080，服务器协议为 http，而 https 的默认配置为 `Server.https`。在接下来的两行中，我们正在重用 `Server.http` 配置，通过使用指令
    `with port: 8088` 将端口号 8080 替换为 8088。'
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also run your application with the –p option to change the port, which
    will override this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `-p` 选项运行你的应用来更改端口号，这将覆盖此设置。
- en: 'Our web server will need to answer differently to different requests, depending
    on which URL was being requested. Therefore, we will need `Server.handler` to
    handle these requests. The `Server.handler` type is much more complicated than
    the `Server.conf` type. It defines how our web server will handle the incoming
    requests. It''s a variant with eight cases:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 web 服务器需要根据请求的不同而给出不同的响应，这取决于请求的是哪个 URL。因此，我们需要 `Server.handler` 来处理这些请求。`Server.handler`
    类型比 `Server.conf` 类型复杂得多。它定义了我们的 web 服务器将如何处理传入的请求。它是一个包含八个情况的变体：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the example at the beginning of this chapter, we used the simplest case—`{string
    text}`. It accepts all the requests and just shows some text on the page. Let''s
    see how the second case, `{string title, (-> xhtml) page}`, works:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头的示例中，我们使用了最简单的情况——`{string text}`。它接受所有请求，并在页面上显示一些文本。让我们看看第二个情况，`{string
    title, (-> xhtml) page}` 是如何工作的：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second case also handles all the requests, but it servers a single page.
    The field page is a function with the type `void -> xhtml`, which indicates that
    the function accepts no parameter and produces a value of the type `xhtml`. We
    will talk about XHTML later; the result looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况也处理了所有请求，但它只服务一个页面。页面字段是一个类型为 `void -> xhtml` 的函数，这表示该函数不接受任何参数并产生一个 `xhtml`
    类型的值。我们稍后会讨论 XHTML；结果看起来像这样：
- en: '![The server module](img/3749OS_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![服务器模块](img/3749OS_03_02.jpg)'
- en: We can notice from this screenshot that, compared to the first example, what
    has changed is that the web page we sent to the browser includes HTML markup that
    the web browser renders as a heading type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕截图我们可以注意到，与第一个例子相比，变化的是我们发送给浏览器的网页包含了网页浏览器将其渲染为标题类型的 HTML 标记。
- en: Dispatching requests
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求调度
- en: We have gone through the first two cases of `Server.handler`. They are both
    simple and accept all requests. But in real web applications, requests and responses
    are much more complicated, and the web server should respond differently according
    to different requests. This section we will cover the remaining cases of `Server.handler`
    and will show how to handle different types of requests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 `Server.handler` 的前两种情况。它们都很简单并接受所有请求。但在实际的 Web 应用程序中，请求和响应要复杂得多，Web
    服务器应根据不同的请求做出不同的响应。本节我们将讨论 `Server.handler` 的剩余情况，并展示如何处理不同类型的请求。
- en: The resource handler
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源处理器
- en: 'A resource handler is often used to serve static resources such as images and
    sounds. The case `{stringmap(resource) resources}` performs on a non-decoded URI
    (Uniform Resource Identifier), and returns a resource that the URI matches with
    the resource''s stringmap. To make it clear, let''s suppose there are three images
    in the directory `res: opa1.png, opa2.png, and opa3.png`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 资源处理器通常用于服务静态资源，如图片和声音。`{stringmap(resource) resources}` 的情况在非解码的 URI（统一资源标识符）上执行，并返回与资源字符串映射匹配的资源。为了使问题更清晰，让我们假设在目录
    `res` 中有三个图片：`opa1.png`、`opa2.png` 和 `opa3.png`。
- en: 'If we create the resources stringmap manually, it should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动创建资源字符串映射，它应该看起来像这样：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The relative URI is the key and the resource of the `.png` file is the value,
    that is, `"res/opa1.png"` is the key and `opa1.png`, as a resource, is the value.
    If the user tries to access the URL `http://localhost:8080/res/opa1.png`, the
    non-decoded relative URI will be `res/opa1.png`. The server will try to find the
    corresponding resource `opa1.png` and serve it back to the user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 相对 URI 是键，`.png` 文件的资源是值，即 `"res/opa1.png"` 是键，`opa1.png` 作为资源是值。如果用户尝试访问 URL
    `http://localhost:8080/res/opa1.png`，非解码的相对 URI 将是 `res/opa1.png`。服务器将尝试找到相应的资源
    `opa1.png` 并将其服务回用户。
- en: 'So, how can we add these external files? In Opa, we can use the following two
    directives. These directives will be replaced by a proper value at compile time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何添加这些外部文件呢？在 Opa 中，我们可以使用以下两个指令。这些指令将在编译时被替换为适当的值：
- en: '`@static_content("foo.png")` is replaced by a function that returns the content
    of `compile-time foo.png`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@static_content("foo.png")` 被一个返回 `compile-time foo.png` 内容的函数所替代'
- en: '`@static_resource("foo.png")` is replaced by a value of the resource type `represents
    foo.png`, with the last modification time, MIME type, among others.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@static_resource("foo.png")` 被一个表示 `foo.png` 的资源类型值所替代，包括最后修改时间、MIME 类型等。'
- en: 'The difference between these two directives is that `@static_content` is replaced
    by a function, while `@static_resource` is replaced by a resource. Both directives
    have a counterpart that, instead of processing and returning one file, processes
    a directory and returns it as a stringmap:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令之间的区别在于，`@static_content` 被一个函数所替代，而 `@static_resource` 被一个资源所替代。这两个指令都有一个对应的指令，它不是处理并返回一个文件，而是处理一个目录并将其作为字符串映射返回：
- en: '`@static_content_directory("foo/")` is replaced by a stringmap from file name
    `f` in the directory `foo/ to @static_content("f")`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@static_content_directory("foo/")` 被目录 `foo/` 中的文件名 `f` 到 `@static_content("f")`
    的字符串映射所替代'
- en: '`@static_resource_directory("foo/")` is replaced by a stringmap from file name
    `f` in the directory foo/ to `@static_resource("f")`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@static_resource_directory("foo/")` 被目录 `foo/` 中的文件名 `f` 到 `@static_resource("f")`
    的字符串映射所替代'
- en: 'Now, it is very clear that if we want to serve resources in the directory `res`,
    all we need to do is write the code as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在目录 `res` 中提供服务，我们只需要编写如下代码：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can get the resource at `http://localhost:8080/res/opa1.png`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `http://localhost:8080/res/opa1.png` 获取资源。
- en: The dispatch handler
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度处理器
- en: 'The resource handler is very useful for static resources. But frequently, the
    server needs to respond to different requests. The case `{(Uri.relative -> resource)
    dispatch}` is just for that. In this case, the request URL is decoded into an
    `Uri.relative` record, which is defined as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 资源处理程序对于静态资源非常有用。但频繁地，服务器需要响应不同的请求。`{(Uri.relative -> resource) dispatch}` 的情况正是为此而设。在这种情况下，请求
    URL 被解码为 `Uri.relative` 记录，它被定义为：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s suppose the user request URL is `http://localhost:8080/admin/find?name=Li&age=28`,
    the record will be:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户请求 URL 是 `http://localhost:8080/admin/find?name=Li&age=28`，记录将是：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Having this record, we should return a corresponding resource. Most of the
    time, pattern matching is used to dispatch requests. Here is an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个记录，我们应该返回相应的资源。大多数情况下，模式匹配用于分发请求。以下是一个示例：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remember what we discussed about pattern matching in the last chapter? It is
    not hard to figure out what happens here. Note that pattern matching is not the
    only way to dispatch requests. You can do almost anything you want to return a
    resource for a given URI. Besides, we can also add a filter with the case `{Server.filter
    filter, (Uri.relative->resource) dispatch}`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章讨论的模式匹配吗？这里发生的事情不难理解。请注意，模式匹配不是分发请求的唯一方式。您可以为给定的 URI 返回资源执行几乎任何操作。此外，我们还可以添加一个带有情况
    `{Server.filter filter, (Uri.relative->resource) dispatch}` 的过滤器：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code will only allow user to access `http://localhost:8080/opa/packt`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将仅允许用户访问 `http://localhost:8080/opa/packt`。
- en: The register handler
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册处理程序
- en: The case `{Server.registrable_resource register}` is an empty request handler,
    which means it will not handle any request. But it is useful for registering external
    resources such as `js` and `css`, so that we can use them in our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Server.registrable_resource register}` 的情况是一个空请求处理程序，这意味着它不会处理任何请求。但它对于注册外部资源（如
    `js` 和 `css`）很有用，这样我们就可以在应用中使用它们。'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we registered the `doctype` as `html5`, and some external JavaScript
    and CSS. The JavaScript and CSS registered here is application-wide. It means
    we can use codes from JavaScript and styles from CSS in any page that we create
    in this application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将 `doctype` 注册为 `html5`，并注册了一些外部 JavaScript 和 CSS。这里注册的 JavaScript 和
    CSS 是应用范围内的。这意味着我们可以在应用中创建的任何页面上使用 JavaScript 代码和 CSS 样式。
- en: The customize handler
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制处理程序
- en: 'The case `{Parser.general_parser(resource) custom}` is the most configurable
    request handler. The custom parser takes the non-decoded URI from incoming requests
    as input and computes the corresponding resource. Consider the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Parser.general_parser(resource) custom}` 的情况是最可配置的请求处理程序。自定义解析器将来自传入请求的非解码
    URI 作为输入，并计算相应的资源。考虑以下示例：'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example will match all requests beginning with `"/admin"` to the admin
    page created by the code `Resource.page("Admin",<h1>Admin</h1>)`, all requests
    beginning with `"/user"` to the user page, and all the other requests to a default
    page. You can refer parser in Opa to get more information about how to deal with
    more complex cases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将匹配所有以 `"/admin"` 开头的请求到由代码 `Resource.page("Admin",<h1>Admin</h1>)` 创建的管理页面，所有以
    `"/user"` 开头的请求到用户页面，以及所有其他请求到默认页面。您可以参考 Opa 中的解析器以获取更多关于如何处理更复杂情况的信息。
- en: The handlers group
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理程序组
- en: 'The case list `(Server.handler)` aggregates several request handlers as a group
    in response to an incoming request. All handlers are tested in the order that
    they are listed until one succeeds and returns a resource. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Server.handler}` 的情况将多个请求处理程序作为一组聚合，以响应传入的请求。所有处理程序将按照它们列出的顺序进行测试，直到其中一个成功并返回资源。例如：'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As a single handler may not be sufficient to deal with all the requests, handlers
    group is a common solution for most web applications developed by Opa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个处理程序可能不足以处理所有请求，因此处理程序组是大多数由 Opa 开发的 Web 应用程序中常见的解决方案。
- en: Preparing pages
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备页面
- en: We have discussed how to launch the server and dispatch users' requests. Now
    it is time for the frontend issue, namely, the web page. Web pages are what users
    see and interact with. There are numerous technologies that can be used for building
    excellent web pages, such as PHP, Perl, and Python. But the basic way is using
    HTML and CSS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何启动服务器和分发用户请求。现在轮到前端问题，即网页。网页是用户看到并与之交互的内容。有许多技术可以用来构建优秀的网页，例如 PHP、Perl
    和 Python。但基本的方法是使用 HTML 和 CSS。
- en: XHTML
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XHTML
- en: 'In Opa, both HTML and CSS are first class citizens, and are understood and
    checked by the compiler without you having to wrap them as strings. Having XHTML
    as a native type implies near-perfect XSS (cross-site scripting) protection. It
    also means we can easily compose elements, that is, we can write `<div>{foo()}</div>`.
    HTML values have a predefined `xhtml` type, and there is a built-in syntax for
    constructing XHTML values. Here is an overview of the syntax for XHTML:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Opa 中，HTML 和 CSS 都是第一等公民，并且编译器会理解和检查它们，无需将它们作为字符串包装。将 XHTML 作为原生类型意味着几乎完美的
    XSS（跨站脚本）保护。这也意味着我们可以轻松地组合元素，也就是说，我们可以编写 `<div>{foo()}</div>`。HTML 值具有预定义的 `xhtml`
    类型，并且存在用于构建 XHTML 值的内建语法。以下是 XHTML 语法的概述：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inserts for both tags and attributes work in XHTML too:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XHTML 中，标签和属性的插入同样适用：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a page
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建页面
- en: 'Usually, we need to serve our web page as a value of the resource type. The
    function `Resource.page` , or its shortcut `Resource.html`, will help us convert
    XHTML to a resource. `Resource.page` is defined as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要将我们的网页作为资源类型的值提供服务。函数 `Resource.page` 或其快捷方式 `Resource.html` 将帮助我们转换
    XHTML 为资源。`Resource.page` 定义为：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first argument is the title of the web page and the second argument is
    the content written in XHTML. It will return a value of the resource type that
    we can return to the user. Here is a simple example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是网页标题，第二个参数是使用 XHTML 编写的内联内容。它将返回一个资源类型的值，我们可以将其返回给用户。以下是一个简单的示例：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code fragment serves all the requests to the web page. `Resource.page`
    is sufficient for developers in most cases. But if you need more controls, you
    can refer to `Resource.styled_page` and `Resource.full_page`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段处理网页的所有请求。`Resource.page` 对于大多数开发者来说已经足够。但如果需要更多控制，可以参考 `Resource.styled_page`
    和 `Resource.full_page`。
- en: Adding styles
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加样式
- en: 'There are many ways to add styles. First, just like XHTML, CSS is a predefined
    datatype in Opa and we can define CSS in Opa code directly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加样式有许多方法。首先，就像 XHTML 一样，CSS 是 Opa 中的预定义数据类型，我们可以在 Opa 代码中直接定义 CSS：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another way is using the register handler that we have talked about before:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用我们之前提到过的注册处理器：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The stylesheets registered by the register handler are available application-wide,
    which means that you can use them in any page. If you want to add some page specific
    stylesheets, the choice will be `Resource.styled_page`. Here is an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注册处理器注册的样式表在应用程序范围内可用，这意味着您可以在任何页面上使用它们。如果您想添加一些特定于页面的样式表，选择将是 `Resource.styled_page`。以下是一个示例：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Compile and run this code; the result looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此代码；结果如下所示：
- en: '![Adding styles](img/3749OS_03_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![添加样式](img/3749OS_03_03.jpg)'
- en: Handling events
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: An event handler is a function whose call is triggered by some activity in the
    user interface. Typical event handlers react to user's clicking (the event is
    called `click`), pressing enter (event `newline`), moving the mouse (event `mousemove`),
    or loading the page (event `ready`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器是一个函数，其调用由用户界面中的某些活动触发。典型的事件处理器对用户的点击（事件称为 `click`）、按回车（事件 `newline`）、移动鼠标（事件
    `mousemove`）或加载页面（事件 `ready`）做出反应。
- en: 'In Opa, an event handler always has the type `Dom.event -> void`. Here is an
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Opa 中，事件处理器始终具有类型 `Dom.event -> void`。以下是一个示例：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code gives an example of how to write event handlers in Opa.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例展示了如何在 Opa 中编写事件处理器。
- en: Manipulating DOMs
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 DOM
- en: The Document Object Model (DOM) is a platform and language neutral interface
    that allows programs and scripts to dynamically access and update the content,
    structure, and style of documents.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型（DOM）是一个平台和语言中立的接口，允许程序和脚本动态访问和更新文档的内容、结构和样式。
- en: At times, we may want to change the content of a page dynamically. To accomplish
    this, we will often need to interact with the DOM. Opa provides the module `Dom`
    for the purpose of manipulating the contents of the page currently being displayed
    by the browser. You can use it to add and remove elements to and from the page,
    to get the contents of a form, or to apply styles or special effects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要动态地更改页面内容。为了实现这一点，我们通常需要与 DOM 交互。Opa 提供了 `Dom` 模块，用于操作浏览器当前显示的页面内容。您可以使用它向页面添加和删除元素，获取表单内容，或应用样式或特殊效果。
- en: DOM selection
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM 选择
- en: 'The first step that is necessary, in order to use DOMs, is to select the one
    that you want to work with. Opa provides many ways of selecting elements. You
    can find all the available selection functions in the module `Dom`. The most commonly
    used ones are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用DOMs，首先必要的一步是选择你想要与之工作的那个。Opa提供了多种选择元素的方法。你可以在模块`Dom`中找到所有可用的选择函数。最常用的有：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As `Dom.select_id` is used everywhere and very frequently, Opa provides a shortcut
    for it. You can simply write `#id`. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Dom.select_id`被广泛且频繁地使用，Opa为其提供了一个快捷方式。你可以简单地写`#id`。例如：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reading values
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取值
- en: 'Often we need to read values or get content from some element of a page. For
    example, getting user''s input or getting the width of an element. Opa provides
    many `get` functions to get information of a given `Dom` item. Consider the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 经常我们需要从页面的某个元素中读取值或获取内容。例如，获取用户的输入或获取元素的宽度。Opa提供了许多`get`函数来获取给定`Dom`项的信息。考虑以下代码：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example illustrates some commonly used functions on `Dom`, we can find
    more on online Opa API for the entry Dom. Please do not confuse `Dom.get_value`
    with `Dom.get_text`. The first one will return the content entered by the user
    (for example, from an input, a menu, and so on), while the second one will return
    the content inserted in `Dom`. We can figure that out from the second and third
    line of the example we just saw.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了`Dom`上的一些常用函数，我们可以在在线Opa API的Dom条目中找到更多信息。请不要混淆`Dom.get_value`与`Dom.get_text`。前者将返回用户输入的内容（例如，来自输入、菜单等），而后者将返回插入到`Dom`中的内容。我们可以从刚才看到的示例的第二行和第三行中得出这一点。
- en: Updating content
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新内容
- en: 'Opa offers three syntactical shortcuts that simplify some of the most common
    transformations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Opa提供了三个语法快捷方式，简化了一些最常见的转换：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, there are many other functions you can use to add, remove, and
    update the content of the page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他函数可以用来添加、删除和更新页面内容：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Binding an event handler
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定事件处理器
- en: 'It is quite common to bind an event handler dynamically at runtime, especially
    when you are creating controls programmatically. In Opa, we can do this with `Dom.bind`
    ,which is defined as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时动态绑定事件处理器相当常见，尤其是在你以编程方式创建控件时。在Opa中，我们可以通过`Dom.bind`来实现，它被定义为：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The function returns a value of the type `Dom.event_handler`, which you can
    use to unbind the event handler. Here is an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个`Dom.event_handler`类型的值，你可以使用它来解绑事件处理器。以下是一个示例：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Animations
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: 'Opa provides several techniques for adding animations to a web page. These
    include simple, standard animations that are frequently used such as fade-in,
    fade-out, and hide. To apply an animation to a `Dom` item, you should use the
    function `Dom.transaction` , which is defined as:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Opa提供了几种向网页添加动画的技术。这些包括常用的简单、标准动画，如淡入、淡出和隐藏。要将动画应用到`Dom`项上，你应该使用函数`Dom.transaction`，它被定义为：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first parameter is a `Dom` item and the second parameter is the effect
    you want to apply to this `Dom` item. You can find a full list of effects supported
    by Opa in the module `Dom.Effect`. Here is an example of animation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个`Dom`项，第二个参数是你想要应用到这个`Dom`项上的效果。你可以在模块`Dom.Effect`中找到Opa支持的所有效果的完整列表。以下是一个动画的示例：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we first introduced how to start a web server with the function
    `Server.start`, which is the starting point of our web application. Then we discussed
    in detail the different cases of `Server.handler`, and how to use them to dispatch
    user requests. After that, we talked about preparing web pages. Finally, we learned
    how to change the content of the page dynamically by interacting with DOM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了如何使用`Server.start`函数启动Web服务器，这是我们的Web应用的起点。然后我们详细讨论了`Server.handler`的不同情况，以及如何使用它们来分发用户请求。之后，我们讨论了准备网页。最后，我们学习了如何通过与DOM交互来动态更改页面内容。
