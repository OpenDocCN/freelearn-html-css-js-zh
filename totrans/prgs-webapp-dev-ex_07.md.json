["```js\nself.addEventListener(\"fetch\", event => { \n   //process request and return best response \n}); \n```", "```js\nself.addEventListener(\"install\", event => { \n\n    event.waitUntil( \n\n        caches.open(cacheName(PRECACHE_NAME)).then(cache => { \n\n            return cache.addAll(PRECACHE_URLS); \n\n        }) \n\n    ); \n\n}); \n```", "```js\n\nself.addEventListener('install', function (event) { \n    event.waitUntil( \n    //pre-cache \n    //on install as a dependency \n    return caches.open(preCacheName).then(cache =>{ \n        return cache.addAll(PRECACHE_URLS); \n    }); \n}); \n```", "```js\nself.addEventListener('install', function (event) { \n    event.waitUntil( \n        //won't delay install completing and won't cause installation \n        to  \n        //fail if caching fails. \n        //the difference is as dependency returns a Promise, the  \n        //no dependency does not. \n        //on install not as dependency (lazy-load) \n        caches.open(preCacheNoDependencyName).then(cache =>{ \n            cache.addAll(PRECACHE_NO_DEPENDENCY_URLS); \n            return cache.addAll(PRECACHE_URLS); \n        })); \n}); \n```", "```js\nself.addEventListener('activate', function (event) { \n    //on activate \n    event.waitUntil( \ncaches.keys().then(function (cacheNames) { \n                    cacheNames.forEach(function (value) { \n                    if (value.indexOf(VERSION) < 0) { \n                       caches.delete(value); \n                   } \n                }); \n            return; \n        }) \n    ); \n}); \n```", "```js\nconst VERSION = \"v1\", \n```", "```js\n    function saveEpisodeData(guid) { \n        var episodeSource = \"api/episodes/\" + guid + \".json\"; \n        fetch(episodeSource) \n            .then(function (response) { \n                if (response && response.ok) { \n                    caches.open(\"LISTEN_LATER\").then( \n                        cache => { \n                            cache.put(episodeSource, response); \n                        }); \n                } \n            }); \n    }\n```", "```js\nself.addEventListener('fetch', function (event) { \n    event.respondWith( \n        caches.open(cacheName).then(cache =>{ \n            return cache.match(event.request).then(function (response)          \n             { \n                return response || fetch(event.request).then( \n                    function (response) { \n                        caches.open(cacheName).then( \n                            cache =>{ \n                                cache.put(event.request, \n                                response.clone()); \n                            }); \n                        return response; \n                    }); \n            }); \n        }) \n    ); \n}); \n```", "```js\n self.addEventListener('fetch', event => { \n     event.respondWith(  \ncaches.open(dynamicCacheName).then(cache =>{    \n         return cache.match(event.request).then(function \n         (response) { \n               var fetchPromise = fetch(event.request) \n               .then(function (networkResponse) {      \n                cache.put(event.request, \n                networkResponse.clone());      \n                return networkResponse;     \n                 });  \n                return response || fetchPromise;    \n                })   \n         })  \n   ); \n}); \n```", "```js\n//On push message \nfunction parsePushMessage(message){ \n   //parse the message \n   If(message.update){ \n   //notify user of background update process here \n    caches.open(preCacheName).then(cache =>{ \n        return cache.addAll(message.urls); \n    }); \n} \n} \n\nself.addEventListener('push', event => {  \n   parsePushMessage(event.data); \n}); \n```", "```js\nself.addEventListener('sync', function(event) { \n  if (event.id === 'update-podcast-XYZ') { \n    event.waitUntil( \n      caches.open(DYNAMIC_CACHE_NAME).then(function(cache) { \n        return cache.add(\"podcast/xyz/\"); \n      }) \n    ); \n  } \n}); \n```", "```js\nself.addEventListener('fetch', event => { \n  // If a match isn't found in the cache, the response \n  // will look like a connection error \n  event.respondWith(caches.match(event.request)); \n}); \n```", "```js\nself.addEventListener('fetch', event => { \n  event.respondWith(fetch(event.request)); \n  // or simply don't call event.respondWith, which \n  // will result in default browser behaviour \n});  \n```", "```js\nself.addEventListener('fetch', event => { \n  event.respondWith( \n    caches.match(event.request).then(function(response) { \n      return response || fetch(event.request); \n    }) \n  ); \n}); \n```", "```js\nself.addEventListener('fetch', event =>{ \n        caches.match(event.request).then( \n            function (response) { \n                return response || fetch(event.request).then( \n                    function (response) { \n                        caches.open(dynamicCacheName).then( \n                            cache =>{ \n                                cache.put(event.request, response.clone()); \n                            }); \n                        return response; \n                    } \n                ) \n            }) \n}); \n```", "```js\nself.addEventListener('fetch', event =>{ \n        promiseAny([ \n            caches.match(event.request), \n            fetch(event.request) \n        ]) \n}); \n\n// Promise.race is no good to us because it rejects if \n// a promise rejects before fulfilling. Let's make a proper \n// race function: \nfunction promiseAny(promises) {  \n    return new Promise((resolve, reject) => {\n// make sure promises are all                                                             \n        promises = promises.map(p => Promise.resolve(p));  \n// resolve this promise as soon as one resolves           \n        promises.forEach(p => p.then(resolve));   \n// reject if all promises reject           \n        promises.reduce((a, b) => a.catch(() => b))    \n            .catch(() => reject(Error(\"All failed\")));  \n    }); \n}; \n```", "```js\nself.addEventListener('fetch', event => { \n   event.respondWidth( \n        fetch(event.request).catch(function () { \n            return caches.match(event.request); \n        }) \n    }); \n}); \n\n```", "```js\nself.addEventListener('fetch', event =>{ \n   event.respondWidth( \n        caches.match(event.request).then(response => {  \n              // Fall back to network                \n            return response || fetch(event.request);   \n        }).catch(function () {    // If both fail, show a generic         \n          fallback: \n            return caches.match(\"fallback/\").then(function(response){ \n                return response; \n            });     \n                // However, in reality you'd have many different \n                // fallbacks, depending on URL & headers. \n                // Eg, a fallback images for podcast logos. \n        }) \n   ); \n  }); \n```", "```js\nself.addEventListener('fetch', event => { \n   event.respondWidth( \n        Promise.all([    \n            caches.match(\"/product-template.html\").then( \n                response => {     \n                    return response.text();    \n                }),     \n            caches.match(\"api/products/35.json\").then( \n                response => {     \n                    return response.json();    \n                })   \n        ]).then(function (responses) {    \n            var template = responses[0];    \n            var data = responses[1];    \n            return new Response(Mustache.render(template, data), {     \n                headers: {      \n                    \"Content-Type\": \"text/html\" \n                }    \n            });   \n        }) \n    }); \n}); \n\n```"]