<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Category Theory</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about functions, asynchronous programming, and the runtime and functional programming principles and techniques, including pure functions and functional composition.</p>
<p>In this chapter, we are going to focus on category theory and algebraic data types. We are going to learn about the following concepts:</p>
<ul>
<li>Category theory</li>
<li>Algebraic data types</li>
<li>Functors</li>
<li>Applicative</li>
<li>Maybe</li>
<li>Either</li>
<li>Monads</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category theory</h1>
                </header>
            
            <article>
                
<p>Functional programming has a reputation for being difficult to learn and understand due to its mathematical background. Functional programming languages and design patterns are influenced by concepts that originated in different mathematical fields. However, we can highlight <strong>category theory</strong> as one of the most significant influences. We can think about category theory as an alternative to set theory. It defines the theory behind a series of data structures or objects known as <strong>algebraic data types</strong>.</p>
<p class="mce-root"/>
<p>There are many algebraic data types, and understanding all the properties and rules that they must implement requires a significant amount of time and effort. The following diagram illustrates the relationships between some of the most common algebraic data types:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5e37f1c4-ee1e-499a-8ac3-512ff85266a6.png"/></p>
<p>The arrows in the diagram indicate that a given algebraic data type must implement the specification of some other algebraic data types. For example, the <strong>Monad</strong> type must implement the specifications of the <strong>Applicative</strong> and <strong>Chain</strong> types.</p>
<p>The open source project, fantasy-land, declares a specification for some of these algebraic data types. The open source project, ramda-fantasy, implements these specifications in a way that is compatible with Ramda, which is a popular functional programming library that we will explore later in this book.</p>
<p>The algebraic data type specifications can be implemented in many ways. For example, the <kbd>Functor</kbd> specification can be implemented by a <kbd>Maybe</kbd> or an <kbd>Either</kbd> data type. Both types implement the <kbd>Functor</kbd> specification, but can also implement other specifications, such as the <kbd>Monad</kbd> or the <kbd>Applicative</kbd> specification.</p>
<p>The following table describes which specifications (listed in the top row) are implemented by one of the algebraic data type implementations (left row) in the fantasy-ramda project:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Name</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Setoid</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><strong>Semigroup</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 15.1159%"><strong>Functor</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Applicative</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 13%"><strong>Monad</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><strong>Foldable</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 18%"><strong>ChainRec</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Either</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">      <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Future</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Identity</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">      <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>IO</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Maybe</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">      <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">        <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">            <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Reader</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 18%"><span>✘</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>Tuple</strong></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">      <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">        <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 13%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 18%"><span>✘</span></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><strong>State</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10%"><span>✘</span></td>
<td class="CDPAlignCenter CDPAlign" style="width: 10.8841%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">          <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">         <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><span>✘</span></td>
<td class="CDPAlignLeft CDPAlign" style="width: 10%">               <img src="assets/a5f6ebac-139f-48f1-b7ef-6393904955f8.png" style="width:1.42em;height:1.00em;"/></td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>Understanding the field of category theory and all these data types and specifications is outside the scope of this book. However, in this chapter, we are going to learn the basics regarding two of the most common algebraic data types: <kbd>Functors</kbd> and <kbd>Monads</kbd>.</p>
<div class="packt_infobox">
<p>Please refer to the fantasy-land project at <a href="https://github.com/fantasyland/fantasy-land">https://github.com/fantasyland/fantasy-land</a> and the fantasy-ramda project at <a href="https://github.com/ramda/ramda-fantasy">https://github.com/ramda/ramda-fantasy</a> to learn more about algebraic data types.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functors</h1>
                </header>
            
            <article>
                
<p>The <kbd>Functor</kbd> type has two main characteristics:</p>
<ul>
<li>It holds a value</li>
<li>It implements a method named <kbd>map</kbd></li>
</ul>
<p>The following code snippet declares a class named <kbd>Container</kbd>. This class can be considered a <kbd>Functor</kbd>:</p>
<pre>class Container&lt;T&gt; {<br/><br/>    private _value: T;<br/><br/>    public constructor(val: T) {<br/>        this._value = val;<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        return new Container&lt;TMap&gt;(fn(this._value));<br/>    }<br/><br/>}</pre>
<p>We can use the container as follows:</p>
<pre>const double = (x: number) =&gt; x + x;<br/>const container = new Container(3);<br/>const container2 = container.map(double);<br/>console.log(container2); // { _value: 6 }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>At this point, you may think that the <kbd>Functor</kbd> type is not very useful because we have implemented the most basic version possible. The next two sections implement two <kbd>Functors</kbd> known as <kbd>Maybe</kbd> and <kbd>Either</kbd>. These two <kbd>Functors</kbd> are much more useful and will demonstrate that <kbd>Functors</kbd> are a powerful tool. However, before we can implement the <kbd>Maybe</kbd> and <kbd>Either</kbd> types, we need to learn about the <kbd>Applicative</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applicative</h1>
                </header>
            
            <article>
                
<p>An <kbd>Applicative</kbd> is a <kbd>Functor</kbd> that implements a method named <kbd>of</kbd>. However, an <kbd>Applicative</kbd> is not just a <kbd>Functor</kbd> type; it is also an <kbd>Apply</kbd> type. For a type to be an implementation of <kbd>Apply</kbd>, it must implement a method named <kbd>ap</kbd> that takes a <kbd>Functor</kbd> that wraps a function as an argument.</p>
<p>The following code snippet implements an <kbd>Applicative</kbd> and, as a result, it has an <kbd>of</kbd>, a <kbd>map</kbd>, and an <kbd>ap</kbd> method:</p>
<pre>class Container&lt;T&gt; {<br/><br/>    public static of&lt;TVal&gt;(val: TVal) {<br/>        return new Container(val);<br/>    }<br/><br/>    private _value!: T;<br/><br/>    public constructor(val: T) {<br/>        this._value = val;<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        return new Container&lt;TMap&gt;(fn(this._value));<br/>    }<br/><br/>    public ap&lt;TMap&gt;(c: Container&lt;(val: T) =&gt; TMap&gt;) {<br/>        return c.map(fn =&gt; this.map(fn));<br/>    }<br/><br/>}</pre>
<p>We can use the <kbd>Applicative</kbd> to wrap a number and a function <span>as follows</span>:</p>
<pre>const double = (x: number) =&gt; x + x;<br/>const numberContainer = Container.of(3);<br/>const functionContainer = Container.of(double);</pre>
<p>We can use the <kbd>map</kbd> method to map the value wrapped by the <kbd>Functor</kbd> using a mapping function:</p>
<pre>numberContainer.map(double); // Returns Container&lt;number&gt; with value 6</pre>
<p>Alternatively, we can use the <kbd>ap</kbd> function to perform the same operation using a <kbd>Functor</kbd> that wraps a function instead of a function:</p>
<pre>numberContainer.ap(functionContainer); // Container&lt;number&gt; with value 6</pre>
<div class="packt_infobox"><span>Please note that the entire example is included in the companion source code.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maybe</h1>
                </header>
            
            <article>
                
<p>The following <kbd>Maybe</kbd> data type is a <kbd>Functor</kbd> and an <kbd>Applicative</kbd>, which means that it contains a value and implements the <kbd>map</kbd> method. The main difference with the preceding implementation of <kbd>Functor</kbd> is that the value contained is optional:</p>
<pre>class MayBe&lt;T&gt; {<br/><br/>    public static of&lt;TVal&gt;(val?: TVal) {<br/>        return new MayBe(val);<br/>    }<br/><br/>    private _value!: T;<br/><br/>    public constructor(val?: T) {<br/>        if (val) {<br/>            this._value = val;<br/>        }<br/>    }<br/><br/>    public isNothing() {<br/>        return (this._value === null || this._value === undefined);<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        if (this.isNothing()) {<br/>            return new MayBe&lt;TMap&gt;();<br/>        } else {<br/>            return new MayBe&lt;TMap&gt;(fn(this._value));<br/>        }<br/>    }<br/><br/>    public ap&lt;TMap&gt;(c: MayBe&lt;(val: T) =&gt; TMap&gt;) {<br/>        return c.map(fn =&gt; this.map(fn));<br/>    }<br/><br/>}</pre>
<p>As we can see in the preceding implementation of the <kbd>map</kbd> method, the mapping function is only applied if the <kbd>Maybe</kbd> data type contains a value.</p>
<p>To demonstrate how to use the <kbd>Maybe</kbd> type and why it is useful, we are going to declare a function to fetch the latest TypeScript news from <a href="http://www.reddit.com">www.reddit.com</a>, as follows:</p>
<pre>interface New {<br/>    subreddit: string;<br/>    id: string;<br/>    title: string;<br/>    score: number;<br/>    over_18: boolean;<br/>    url: string;<br/>    author: string;<br/>    ups: number;<br/>    num_comments: number;<br/>    created_utc: number;<br/>}<br/><br/>interface Response {<br/>    kind: string;<br/>    data: {<br/>        modhash: string;<br/>        whitelist_status: boolean|null;<br/>        children: Array&lt;{ kind: string, data: New }&gt;;<br/>        after: string|null;<br/>        before: string|null;<br/>    };<br/>}<br/><br/>async function fetchNews() {<br/>    return new Promise&lt;MayBe&lt;Response&gt;&gt;((resolve, reject) =&gt; {<br/>        const url = "https://www.reddit.com/r/typescript/new.json";<br/>        fetch(url)<br/>            .then((response) =&gt; {<br/>                return response.json();<br/>            }).then((json) =&gt; {<br/>                resolve(new MayBe(json));<br/>            }).catch(() =&gt; {<br/>                resolve(new MayBe());<br/>            });<br/>    });<br/>}</pre>
<p>The preceding code snippet uses the <kbd>fetch</kbd> API to send an HTTP request. This is an asynchronous operation, which explains why the snippet creates a <kbd>Promise</kbd> instance. When the operations are completed successfully, the response is returned as a <kbd>Maybe</kbd> instance that contains a value. When the operations are completed unsuccessfully, an empty <kbd>Maybe</kbd> instance is returned.</p>
<p>The following code snippet demonstrates how we can use the <kbd>fetchNews</kbd> function:</p>
<pre>(async () =&gt; {<br/><br/>    const maybeOfResponse = await fetchNews();<br/><br/>    const maybeOfNews = maybeOfResponse<br/>        .map(r =&gt; r.data)<br/>        .map(d =&gt; d.children)<br/>        .map(children =&gt; children.map(c =&gt; c.data));<br/><br/>    maybeOfNews.map((news) =&gt; {<br/>        news.forEach((n) =&gt; console.log(`${n.title} - ${n.url}`));<br/>        return news;<br/>    });<br/><br/>})();</pre>
<p>The preceding code snippet uses the <kbd>fetchNews</kbd> function to fetch a list of posts concerning TypeScript from Reddit. If the request is completed successfully, the  <kbd>fetchNews</kbd> <span>function</span> returns the HTTP response wrapped in a <kbd>MayBe</kbd> instance. We then use the <kbd>map</kbd> method to find the list of posts within the response. The nice thing about using a <kbd>MayBe</kbd> instance is that mapping logic is only executed if there is an actual response, so we don't need to worry about potential <kbd>null</kbd> or <kbd>undefined</kbd> errors.</p>
<p class="mce-root"/>
<div class="packt_infobox">
<p>Please note that the preceding example uses some browser APIs, which means that we need to add <kbd>dom</kbd> to the <kbd>lib</kbd> field in our <kbd>tsconfig.json</kbd> file. We are also using the <kbd>async</kbd> keyword, which requires the es6 in <kbd>lib</kbd>. This will prevent compilation errors such as <span class="packt_screen">Cannot find name </span><span class="packt_screen">fetch</span>.</p>
<p>Please note that the entire example is included in the companion source code.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Either</h1>
                </header>
            
            <article>
                
<p>The <kbd>Either</kbd> algebraic data type is the union of the <kbd>Just</kbd> and <kbd>Nothing</kbd> types:</p>
<pre>type Either&lt;T1, T2&gt; = Just&lt;T1&gt; | Nothing&lt;T2&gt;;</pre>
<p>The just type is a <kbd>Functor</kbd> used to represent a non-nullable value:</p>
<pre>class Nothing&lt;T&gt; {<br/><br/>    public static of&lt;TVal&gt;(val?: TVal) {<br/>        return new Nothing(val);<br/>    }<br/><br/>    private _value: T|undefined;<br/><br/>    public constructor(val?: T) {<br/>        this._value = val;<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        if (this._value !== undefined) {<br/>            return new Nothing&lt;TMap&gt;(fn(this._value));<br/>        } else {<br/>            return new Nothing&lt;TMap&gt;(this._value as any);<br/>        }<br/>    }<br/><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>Nothing</kbd> type represents the lack of a value:</p>
<pre>class Just&lt;T&gt; {<br/><br/>    public static of&lt;TVal&gt;(val: TVal) {<br/>        return new Just(val);<br/>    }<br/><br/>    private _value: T;<br/><br/>    public constructor(val: T) {<br/>        this._value = val;<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        return new Just&lt;TMap&gt;(fn(this._value));<br/>    }<br/><br/>}</pre>
<p>The following code snippet is an implementation of the <kbd>fetchNews</kbd> function that we declared in the preceding section. The main difference this time is that we will return an instance of <kbd>Just</kbd> if the HTTP request is completed successfully, and an instance of <kbd>Nothing</kbd> if the HTTP request is not completed successfully:</p>
<pre>interface New {<br/>    subreddit: string;<br/>    id: string;<br/>    title: string;<br/>    score: number;<br/>    over_18: boolean;<br/>    url: string;<br/>    author: string;<br/>    ups: number;<br/>    num_comments: number;<br/>    created_utc: number;<br/>}<br/><br/>interface Response {<br/>    kind: string;<br/>    data: {<br/>        modhash: string;<br/>        whitelist_status: boolean|null;<br/>        children: Array&lt;{ kind: string, data: New }&gt;;<br/>        after: string|null;<br/>        before: string|null;<br/>    };<br/>}<br/><br/>async function fetchNews() {<br/>    return new Promise&lt;Either&lt;Response, Error&gt;&gt;((resolve, reject) =&gt; {<br/><br/>        const url = "https://www.reddit.com/r/typescript/new.json";<br/><br/>        fetch(url)<br/>            .then((response) =&gt; {<br/>                return response.json();<br/>            }).then((json) =&gt; {<br/>                resolve(new Just(json));<br/>            }).catch((e) =&gt; {<br/>                resolve(new Nothing(e));<br/>            });<br/><br/>    });<br/>}</pre>
<p>If we try to use <kbd>map</kbd> on an <kbd>Either</kbd> instance, we will get a compilation error:</p>
<pre>(async () =&gt; {<br/><br/>    const maybeOfResponse = await fetchNews();<br/><br/>    maybeOfResponse.map(r =&gt; r.message);<br/>    // Error:<br/>    // Cannot invoke an expression whose type lacks a call signature.<br/>    // Type<br/>    // (&lt;TMap&gt;(fn: (val: Response) =&gt; TMap) =&gt; Just&lt;TMap&gt;) |<br/>    // (&lt;TMap&gt;(fn: (val: Error) =&gt; TMap) =&gt; Nothin&lt;TMap&gt;'<br/>    // has no compatible call signatures.<br/><br/>})();</pre>
<p>We can use a type guard to ensure that we are accessing a <kbd>Nothing</kbd> instance when a request fails, and a <kbd>Just</kbd> instance when a request is completed without errors:</p>
<pre>(async () =&gt; {<br/><br/>    const maybeOfResponse = await fetchNews();<br/><br/>    if (maybeOfResponse instanceof Nothing) {<br/><br/>        maybeOfResponse<br/>            .map(r =&gt; r.message)<br/>            .map(msg =&gt; {<br/>                console.log(`Error: ${msg}`);<br/>                return msg;<br/>            });<br/><br/>    } else {<br/><br/>        const maybeOfNews = maybeOfResponse.map(r =&gt; r.data)<br/>            .map(d =&gt; d.children)<br/>            .map(children =&gt; children.map(c =&gt; c.data));<br/><br/>        maybeOfNews.map((news) =&gt; {<br/>            news.forEach((n) =&gt; console.log(`${n.title} - ${n.url}`));<br/>            return news;<br/>        });<br/><br/>    }<br/><br/>})();</pre>
<p>The good thing about using <kbd>Either</kbd> is that the compiler forces us to use a type guard. This means that using <kbd>Either</kbd> can lead to increased type safety when dealing with potential failures in I/O operations such as HTTP requests.</p>
<div class="packt_infobox">
<p>Please note that the entire example is included in the companion source code.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monads</h1>
                </header>
            
            <article>
                
<p>We are going to finish our introduction to algebraic data types by learning about monads. A <kbd>Monad</kbd> is a <kbd>Functor</kbd>, but it also implements the <kbd>Applicative</kbd> and <kbd>Chain</kbd> specifications.</p>
<p>We can transform the previously declared <kbd>Maybe</kbd> data type into a <kbd>Monad</kbd> by adding two extra methods named <kbd>join</kbd> and <kbd>chain</kbd>:</p>
<pre>class MayBe&lt;T&gt; {<br/><br/>    public static of&lt;TVal&gt;(val?: TVal) {<br/>        return new MayBe(val);<br/>    }<br/><br/>    private _value!: T;<br/><br/>    public constructor(val?: T) {<br/>        if (val) {<br/>            this._value = val;<br/>        }<br/>    }<br/><br/>    public isNothing() {<br/>        return (this._value === null || this._value === undefined);<br/>    }<br/><br/>    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        if (this.isNothing()) {<br/>            return new MayBe&lt;TMap&gt;();<br/>        } else {<br/>            return new MayBe&lt;TMap&gt;(fn(this._value));<br/>        }<br/>    }<br/><br/>    public ap&lt;TMap&gt;(c: MayBe&lt;(val: T) =&gt; TMap&gt;) {<br/>        return c.map(fn =&gt; this.map(fn));<br/>    }<br/><br/>    public join() {<br/>        return this.isNothing() ? Nothing.of(this._value) : this._value;<br/>    }<br/><br/>    public chain&lt;TMap&gt;(fn: (val: T) =&gt; TMap) {<br/>        return this.map(fn).join();<br/>    }<br/><br/>}</pre>
<p>The <kbd>Maybe</kbd> data type was already a <kbd>Functor</kbd> and an <kbd>Applicative</kbd>, but now it is also a <kbd>Monad</kbd>. The following code snippet showcases how we can use it:</p>
<pre>let maybeOfNumber = MayBe.of(5);<br/>maybeOfNumber.map((a) =&gt; a * 2);<br/>// MayBe { value: 10 }<br/><br/>maybeOfNumber.join();<br/>// 5<br/><br/>maybeOfNumber.chain((a) =&gt; a * 2);<br/>// 10<br/><br/>let maybeOfMaybeOfNumber = MayBe.of(MayBe.of(5));<br/>// MayBe { value: MayBe { value: 5 } }<br/><br/>maybeOfMaybeOfNumber.map((a) =&gt; a.map(v =&gt; v * 2));<br/>// MayBe { value: MayBe { value: 10 } }<br/><br/>maybeOfMaybeOfNumber.join();<br/>// MayBe { value: 5 }<br/><br/>maybeOfMaybeOfNumber.chain((a) =&gt; a.map(v =&gt; v * 2));<br/>// MayBe { value: 10 }</pre>
<p>The preceding code snippet demonstrates how the <kbd>join</kbd> and <kbd>chain</kbd> methods work. As you can see, they are very useful when we have a <kbd>Functor</kbd> of a <kbd>Functor</kbd>, and we want to access the contained value. The <kbd>chain</kbd> method is just a one-step shortcut for the two operations, <kbd>join</kbd> and <kbd>map</kbd>.</p>
<div class="packt_infobox">
<p>Please note that the entire example is included in the companion source code.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned about a number of algebraic data types, including the <kbd>Functor</kbd>, <kbd>Nothing</kbd>, <kbd>Just</kbd>, <kbd>Maybe</kbd>, <kbd>Either</kbd>, and <kbd>Monad</kbd> data types. We have learned how these types can help us to ensure that certain errors are handled correctly by our code.</p>
<p class="mce-root"><span>In the next chapter, we are going to learn about other functional programming constructs known as Optics, as well as two new powerful techniques: lazy evaluation and immutability.</span></p>


            </article>

            
        </section>
    </body></html>