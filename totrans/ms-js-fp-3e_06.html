<html><head></head><body>
		<div><h1 id="_idParaDest-108" class="chapter-number"><a id="_idTextAnchor107"/>6</h1>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Producing Functions – Higher-Order Functions</h1>
			<p>In <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we worked with some declarative code so that we could gain understandability and more compact, shorter code. In this chapter, we will go further toward <strong class="bold">higher-order functions</strong> (<strong class="bold">HOFs</strong>) and develop our own. We <a id="_idIndexMarker398"/>can roughly classify the results that we are going to get into three groups:</p>
			<ul>
				<li><strong class="bold">Wrapped functions</strong>: These keep their original functionality while adding some kind of <a id="_idIndexMarker399"/>new feature. In this group, we can consider logging (adding log production capacity to any function), timing (producing time and performance data for a given function), and memoization of functions and promises (caching results to avoid future rework).</li>
				<li><code>once()</code> function (we covered this in <a href="B19301_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Thinking Functionally</em>), which changes the original function <a id="_idIndexMarker400"/>so that it only runs once; functions such as <code>not()</code> or <code>invert()</code>, which alter what the function returns; arity-related conversions, which produce a new function with a fixed number of parameters; and throttling and debouncing functions for performance.</li>
				<li><strong class="bold">Other productions</strong>: These provide new operations, turn functions into promises, allow enhanced search functions, decouple methods from objects, transform them into plain functions, and go the other way around, converting functions into methods. We shall leave a special case – <em class="italic">transducers</em> – for <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>.</li>
			</ul>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Wrapping functions – keeping behavior</h1>
			<p>In this section, we’ll consider some HOFs that provide a wrapper around other functions to enhance them in <a id="_idIndexMarker401"/>some way but without altering their original objective. In terms of design patterns (which we’ll be revisiting in <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Design Patterns</em>), we can also speak of <strong class="bold">decorators</strong>. This pattern is based on the concept <a id="_idIndexMarker402"/>of adding some behavior to an object (in our case, a function) without affecting other objects. The term decorator is also popular because of its usage in frameworks, such as Angular, or (in an experimental mode) for general programming in JavaScript.</p>
			<p class="callout-heading">Waiting for decorators</p>
			<p class="callout">Decorators are being considered for general adoption in JavaScript. Currently (as of December 2022), they are <a id="_idIndexMarker403"/>at Stage 3, Candidate level, so it may still be a while until they get to Stage 4 (Finished, meaning “officially adopted”). You can read more about the proposal for decorators at <a href="http://tc39.github.io/proposal-decorators/">tc39.github.io/proposal-decorators/</a> and about the JavaScript adoption process, called TC39, at <a href="http://tc39.es/process-document/">tc39.es/process-document/</a>. See the <em class="italic">Questions</em> section in <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a><em class="italic">, Implementing Design Patterns,</em> for more information.</p>
			<p>As for the term <em class="italic">wrapper</em>, it’s more important and pervasive than you might have thought; in fact, JavaScript <a id="_idIndexMarker404"/>uses it widely. Where? You already know that object properties and methods are accessed through dot notation. However, you also know that you can write code such as <code>myString.length</code> or <code>22.9.toPrecision(5)</code>, so where are those properties and methods coming from, given that neither strings nor numbers are objects? JavaScript actually creates a <em class="italic">wrapper object</em> around <a id="_idIndexMarker405"/>your primitive value. This object inherits all the methods that are appropriate to the wrapped value. As soon as the needed evaluation has been done, JavaScript throws away the just-created wrapper. We cannot do anything about these transient wrappers, but there is a concept we will come back to regarding a wrapper that allows methods to be called on things that are not of the appropriate type. This is an interesting idea; see <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, for more applications of that!</p>
			<p>In this section, we’ll look at three examples:</p>
			<ul>
				<li>Adding logging to a function</li>
				<li>Getting timing information from functions</li>
				<li>Using caching (<em class="italic">memoizing</em>) to improve the performance of functions</li>
			</ul>
			<p>Let’s get to work!</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Logging</h2>
			<p>Let’s start with a common problem. When debugging code, you usually need to add some logging information <a id="_idIndexMarker406"/>to see whether a function was called, with what arguments, what it returned, and so on. (Yes, of course, you can simply use a debugger and set breakpoints, but bear with me for this example!) Working normally, this means that you’ll have to modify the code of the function itself, both at entry and on exit, to produce some logging output. For example, your original code could be something like the following:</p>
			<pre class="source-code">
function someFunction(param1, param2, param3) {
  // do something
  // do something else
  // and a bit more,
  // and finally
  return some expression;
}</pre>
			<p>In this case, you would have to modify it to look like the following. Here, we need to add an <code>auxValue</code> variable to store the value that we want to log and return:</p>
			<pre class="source-code">
function someFunction(param1, param2, param3) {
  <strong class="bold">console.log(</strong>
<strong class="bold">    "entering someFunction: ",</strong>
<strong class="bold">    param1,</strong>
<strong class="bold">    param2,</strong>
<strong class="bold">    param3</strong>
<strong class="bold">  );</strong>
  // do something
  // do something else
  // and a bit more,
  // and finally
<strong class="bold">  const auxValue = ...some expression... ;</strong>
<strong class="bold">  console.log("exiting someFunction: ", auxValue);</strong>
<strong class="bold">  return auxValue;</strong>
}</pre>
			<p>If the function can return at several places, you’ll have to modify all the <code>return</code> statements to log the <a id="_idIndexMarker407"/>values to be returned. And if you are just calculating the return expression on the fly, you’ll need an auxiliary variable to capture that value.</p>
			<p>In the next section, we’ll learn about logging and some special cases, such as functions that throw exceptions, and we’ll work more purely.</p>
			<h3>Logging in a functional way</h3>
			<p>Logging by modifying your functions isn’t difficult, but modifying code is always dangerous and prone <a id="_idIndexMarker408"/>to accidents. So, let’s put our FP hats on and think of a new way of doing this. We have a function that performs some work, and we want to know the arguments it receives and the value it returns.</p>
			<p>Here, we can write an HOF that will have a single parameter – the original function – and return a new function that will do the following in sequence:</p>
			<ol>
				<li>Log the received arguments.</li>
				<li>Call the original function, catching its returned value.</li>
				<li>Log that value.</li>
				<li>Return it to the caller.</li>
			</ol>
			<p>A possible solution would be as follows, and let’s use plain JavaScript first to focus on the implementation:</p>
			<pre class="source-code">
// logging.ts
function addLogging(fn) {
  return (...args) =&gt; {
<strong class="bold">    console.log(`entering ${fn.name}(${args})`);</strong>
<strong class="bold">    const valueToReturn = fn(...args);</strong>
<strong class="bold">    console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);</strong>
<strong class="bold">    return valueToReturn;</strong>
  };
}</pre>
			<p>The function returned by <code>addLogging()</code> behaves as follows:</p>
			<ul>
				<li>The first <code>console.log(...)</code> line shows the original function’s name and its list of arguments.</li>
				<li>Then, the original function, <code>fn()</code>, is called, and the returned value is stored. The second <code>console.log(...)</code> line shows the function name (again) and its returned value.</li>
				<li>Finally, the value that <code>fn()</code> calculated is returned.</li>
			</ul>
			<p>A small comment: If you <a id="_idIndexMarker409"/>were doing this for a Node.js application, you would probably opt for a better way of logging than <code>console.log()</code> by using libraries such as <em class="italic">Winston</em>, <em class="italic">Morgan</em>, or <em class="italic">Bunyan</em>, depending on what you wanted to log. However, our focus is on how to wrap the original function, and the needed changes for using those libraries would be negligible.</p>
			<p>Let’s turn to a TypeScript implementation now:</p>
			<pre class="source-code">
// continued...
function addLogging<strong class="bold">&lt;T extends (...args: any[]) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">(...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;</strong> {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
    const valueToReturn = fn(...args);
    console.log(`exiting  ${fn.name} =&gt; ${valueToReturn}`);
    return valueToReturn;
  };
}</pre>
			<p>Our <code>addLogging()</code> function applies to a generic function <code>T</code> type and returns a new function of precisely the same type: its arguments (<code>Parameters&lt;T&gt;</code>) are those of <code>T</code>, and its result (<code>ReturnType&lt;T&gt;</code>) is also the same type as <code>T</code>’s. We will be using this kind of definition many times in this chapter and the rest of the book.</p>
			<p>Let’s have an example now. We can use <code>addLogging()</code> with the upcoming functions—which are written, I agree, in an overly complicated way, just to have an appropriate example! We’ll have a function that accomplishes subtraction by changing the sign of the second number and then adding it to the first. And, just to have an error case, we’ll have the function throw an error if we attempt to subtract zero. (Yes, of course, you can subtract zero <a id="_idIndexMarker410"/>from another number! But I wanted to have some kind of an error-throwing situation at any cost!) The following code does this:</p>
			<pre class="source-code">
// continued...
function subtract(a: number, b: number): number {
  if (b === 0) {
    throw new Error("We don't subtract zero!");
  } else {
    b = changeSign(b);
    return a + b;
  }
}
let changeSign = (a: number): number =&gt; -a;
// @ts-expect-error We want to reassign the function
subtract = addLogging(subtract);
subtract(8, 3);
console.log(); // to separate
changeSign = addLogging(changeSign);
subtract(7, 5);</pre>
			<p>What’s that <code>@ts-expect-error</code> comment? TypeScript rejects the assignment in the following line, saying <code>Cannot assign to 'subtract' because it is a function.ts(2630)</code>. This prohibition keeps code safe, but since we are very sure that we won’t be changing the <code>subtract()</code> type, we can include the comment, and TypeScript will let us get away with it.</p>
			<p>The result of executing this would be the following lines of logging:</p>
			<pre class="source-code">
entering subtract(8,3)
exiting  subtract =&gt; 5
entering subtract(7,5)
entering changeSign(5)
exiting  changeSign =&gt; -5
exiting  subtract =&gt; 2</pre>
			<p>All the changes we had to make in our code were the reassignments of <code>subtract()</code> and <code>changeSign()</code>, which <a id="_idIndexMarker411"/>essentially replaced them everywhere with their new log-producing wrapped versions. Any call to those two functions will produce this output.</p>
			<p>This works fine for most functions, but what would happen if the wrapped function threw an exception? Let’s take a look.</p>
			<h3>Taking exceptions into account</h3>
			<p>Let’s enhance our logging function a bit by considering an adjustment. What happens to your log if the function <a id="_idIndexMarker412"/>throws an error? Fortunately, this is easy to solve. We have to add a <code>try</code>/<code>catch</code> structure, as shown in the following code:</p>
			<pre class="source-code">
// continued...
function addLogging2&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
 <strong class="bold">   try {</strong>
      <strong class="bold">const valueToReturn = fn(...args);</strong>
      console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);
      return valueToReturn;
    } <strong class="bold">catch (thrownError)</strong> {
<strong class="bold">      console.log(</strong>
<strong class="bold">        `exiting  ${fn.name}=&gt;threw ${thrownError}`</strong>
<strong class="bold">      );</strong>
     <strong class="bold"> throw thrownError;</strong>
    }
  };
}</pre>
			<p>With this change, if the function threw an error, you’d also get an appropriate logging message, and the exception would be rethrown for processing. The following is a quick demo of this:</p>
			<pre class="source-code">
try {
<strong class="bold">  subtract2(11, 0);</strong>
} catch (e) {
  /* nothing */
}
/*
<strong class="bold">entering subtract(11,0)</strong>
<strong class="bold">exiting  subtract=&gt;threw Error: We don't subtract zero!</strong>
*/</pre>
			<p>Other changes to get <a id="_idIndexMarker413"/>an even better logging output would be up to you – adding date and time data, enhancing the way parameters are listed, and so on. However, our implementation still has an important defect; let’s make it better and purer.</p>
			<h3>Working in a purer way</h3>
			<p>When we wrote the <code>addLogging()</code> function, we ignored some precepts we saw in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, because we included an impure element (<code>console.log()</code>) in our code. With this, not only did we lose flexibility (would you be able to <a id="_idIndexMarker414"/>select an alternate way of logging?), but we also complicated our testing. We could manage to test it by spying on the <code>console.log()</code> method, but that isn’t very clean: we depend on knowing the internals of the function we want to test instead of doing a purely black-box test. Take a look at the following example for a clearer understanding of this:</p>
			<pre class="source-code">
// logging.test.ts
import { addLogging2 } from "./logging";
describe("a logging function", function () {
  afterEach(() =&gt; {
    // so count of calls to Math.random will be OK
    jest.restoreAllMocks();
  });
  it("should log twice with well behaved functions", () =&gt; {
<strong class="bold">    jest.spyOn(global.console, "log");</strong>
    let something = (a: number, b: number): string =&gt;
      `result=${a}:${b}`;
    something = addLogging2(something);
    something(22, 9);
<strong class="bold">    expect(global.console.log).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering something(22,9)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  something=&gt;result=22:9"</strong>
<strong class="bold">    );</strong>
  });
  it("should report a thrown exception", () =&gt; {
    jest.spyOn(global.console, "log");
    let subtractZero = (x: number) =&gt; subtract(x, 0);
    subtractZero = addLogging2(subtractZero);
<strong class="bold">    expect(() =&gt; subtractZero(10)).toThrow();</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering subtractZero(10)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  subtractZero=&gt;threw Error: We don't subtract zero!"</strong>
<strong class="bold">    );</strong>
  });
  });
});</pre>
			<p>Running this test <a id="_idIndexMarker415"/>shows that <code>addLogging()</code> behaves as expected, so this is a solution. Our first test just does a simple subtraction and verifies that logging was called with appropriate data. The second test checks that our (purposefully failing) <code>subtract()</code> function throws an error to also verify that the correct logs were produced.</p>
			<p>Even so, being able to test our function this way doesn’t solve the lack of flexibility we mentioned. We should pay attention to what we wrote in the <em class="italic">Injecting impure functions</em> section in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a><em class="italic">, Behaving Properly</em>; the logging function should be passed as an argument to the wrapper <a id="_idIndexMarker416"/>function so that we can change it if we need to:</p>
			<pre class="source-code">
// logging3.ts
function addLogging3&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T,
  <strong class="bold">logger = console.log.bind(console)</strong>
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    <strong class="bold">logger(`entering ${fn.name}(${args})`)</strong>;
    try {
      const valueToReturn = fn(...args);
      <strong class="bold">logger(`exiting  ${fn.name}=&gt;${valueToReturn}`)</strong>;
      return valueToReturn;
    } catch (thrownError) {
      <strong class="bold">logger(`exiting  ${fn.name}=&gt;threw ${thrownError}`)</strong>;
      throw thrownError;
    }
  };
}</pre>
			<p>If we don’t do anything, the logging wrapper will produce the same results as in the previous section. However, we could provide a different logger – for example, with Node.js, we <a id="_idIndexMarker417"/>could use the <em class="italic">winston</em> logging tool (see <a href="http://github.com/winstonjs/winston">github.com/winstonjs/winston</a> for more on it), and the results would vary accordingly:</p>
			<pre class="source-code">
// continued...
function subtract(...) { ... }
let changeSign = ... ;
// @ts-expect-error We want to reassign the function
<strong class="bold">subtract = addLogging3(subtract, myLogger);</strong>
subtract(8, 3);
console.log(); // to separate
<strong class="bold">changeSign = addLogging3(changeSign, myLogger);</strong>
subtract(7, 5);
/*
{"level":"debug","message":"entering subtract(8,3)"}
{"level":"debug","message":"exiting  subtract=&gt;5"}
{"level":"debug","message":"entering subtract(7,5)"}
{"level":"debug","message":"entering changeSign(5)"}
{"level":"debug","message":"exiting  changeSign=&gt;-5"}
{"level":"debug","message":"exiting  subtract=&gt;2"}
*/</pre>
			<p>The log format is JSON by default. It’s more usual to route it to a file for storage, so it isn’t so clear as console output, but we could (if needed) reformat it more legibly. However, this suffices for our example, and we won’t do anything else.</p>
			<p>Now that we have followed our own advice, we can take advantage of stubs. The code for testing is practically <a id="_idIndexMarker418"/>the same as before; however, we are using a <code>dummy.logger()</code> stub with no provided functionality or side effects, so it’s safer all around. In this case, the real function that was being invoked originally, <code>console.log()</code>, can’t do any harm, but that’s not always the case, so using a stub is recommended:</p>
			<pre class="source-code">
// logging3.test.ts
import { addLogging3 } from "./logging3";
describe("addLogging3()", function () {
  it("should call the provided logger", () =&gt; {
<strong class="bold">    const logger = jest.fn();</strong>
    let something = (a: number, b: number): string =&gt;
      `result=${a}:${b}`;
    something = addLogging3(something, <strong class="bold">logger</strong>);
    something(22, 9);
<strong class="bold">    expect(logger).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering something(22,9)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  something=&gt;result=22:9"</strong>
<strong class="bold">    );</strong>
  });
  it("a throwing function should be reported", () =&gt; {
    const logger = jest.fn();
    let thrower = () =&gt; {
      throw "CRASH!";
    };
    thrower = addLogging3(thrower, logger);
<strong class="bold">    try {</strong>
<strong class="bold">      thrower();</strong>
<strong class="bold">    } catch (e) {</strong>
<strong class="bold">      expect(logger).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">      expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">        1,</strong>
<strong class="bold">        "entering thrower()"</strong>
<strong class="bold">      );</strong>
<strong class="bold">      expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">        2,</strong>
<strong class="bold">        "exiting  thrower=&gt;threw CRASH!"</strong>
<strong class="bold">      );</strong>
<strong class="bold">    }</strong>
  });
});</pre>
			<p>The preceding tests work exactly <a id="_idIndexMarker419"/>like the previous ones we wrote earlier (though, for variety, in the <em class="italic">Working in a purer way</em> section, we used <code>expect(…).toThrow()</code>, and here we used a <code>try</code>/<code>catch</code> structure to test error-throwing functions). We used and inspected the dummy logger instead of dealing with the original <code>console.log()</code> calls. Writing the test in this way avoids all possible problems due to side effects, so it’s much cleaner and safer.</p>
			<p>When applying FP techniques, remember that if you are somehow complicating your job – for example, making it difficult to test any of your functions – then you must be doing something wrong. In our case, the mere fact that the output of <code>addLogging()</code> was an impure function should <a id="_idIndexMarker420"/>have raised the alarm. Of course, given the simplicity of the code, in this particular case, you might decide that it’s not worth a fix, that you can do without testing, and that you don’t need to be able to change the way logging is produced. However, long experience in software development suggests that, sooner or later, you’ll come to regret that sort of decision, so try to go with the cleaner solution instead.</p>
			<p>Now that we have dealt with logging, we’ll look at another need: timing functions for performance reasons.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Timing functions</h2>
			<p>Another possible application for wrapped functions is to record and log the timing of each function <a id="_idIndexMarker421"/>invocation in a fully transparent way. Simply put, we want to be able to tell how long a function call takes, most likely for performance studies. However, in the same way we dealt with logging, we don’t want to have to modify the original function and will use an HOF instead.</p>
			<p class="callout-heading">The three rules for optimization</p>
			<p class="callout">If you plan to optimize your code, remember the following three rules: <em class="italic">Don’t do it</em>, <em class="italic">Don’t do it yet</em>, and <em class="italic">Don’t do it without measuring</em>. It has been mentioned that a lot of bad code arises from early attempts at optimization, so don’t start by trying to write optimal code, don’t try to optimize until you recognize the need for it, and don’t do it haphazardly without trying to determine the reasons for the slowdown by measuring all the parts of your application.</p>
			<p>Along the lines of the preceding example, we can write an <code>addTiming()</code> function that, given any function, will produce a wrapped version that will write out timing data on the console but will otherwise work in exactly the same way. Data types are very much what we saw in the previous section, so let’s write TypeScript at once:</p>
			<pre class="source-code">
const myGet = (): number =&gt; performance.now();
const myPut = (
  text: string,
  name: string,
  tStart: number,
  tEnd: number
): void =&gt;
  console.log(`${name} - ${text} ${tEnd - tStart} ms`);
function addTiming&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T,
  { getTime, output } = {
    getTime: myGet,
    output: myPut,
  }
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    const tStart = getTime();</strong>
    try {
      const valueToReturn = fn(...args);
      <strong class="bold">output("normal exit", fn.name, tStart, getTime());</strong>
      return valueToReturn;
    } catch (thrownError) {
      <strong class="bold">output("exception!!", fn.name, tStart, getTime());</strong>
      throw thrownError;
    }
  };
}</pre>
			<p>Along the lines <a id="_idIndexMarker422"/>of the enhancement we applied in the previous section to the logging function, we are providing separate logger and time access functions. Writing tests for our <code>addTiming()</code> function should prove easy, given that we can inject both impure functions.</p>
			<p>We can see how this works here:</p>
			<pre class="source-code">
// continued...
function subtract(...) { ... }
let changeSign = ... ;
// @ts-expect-error We want to reassign the function
<strong class="bold">subtract = addTiming(subtract, myLogger);</strong>
subtract(8, 3);
console.log(); // to separate
<strong class="bold">changeSign = addTiming(changeSign, myLogger);</strong>
subtract(7, 5);
/*
subtract - normal exit 0.0217440128326416 ms
changeSign - normal exit 0.0014679431915283203 ms
subtract - normal exit 0.0415341854095459 ms
*/</pre>
			<p class="callout-heading">Accuracy matters</p>
			<p class="callout">Using <code>performance.now()</code> provides the highest accuracy. If you don’t need such precision as what’s <a id="_idIndexMarker423"/>provided by that function (arguably, it is overkill), you <a id="_idIndexMarker424"/>could use <code>Date.now()</code> instead. For <a id="_idIndexMarker425"/>more on these <a id="_idIndexMarker426"/>alternatives, see <a href="http://developer.mozilla.org/en-US/docs/Web/API/Performance/now">developer.mozilla.org/en-US/docs/Web/API/Performance/now</a> and <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now</a>. Consider using <code>console.time()</code> and <code>console.timeEnd()</code>; see <a href="http://developer.mozilla.org/en-US/docs/Web/API/Console/time">developer.mozilla.org/en-US/docs/Web/API/Console/time</a> for more information.</p>
			<p>The preceding code is <a id="_idIndexMarker427"/>quite similar to the previous <code>addLogging()</code> function, and that’s reasonable: in both cases, we add some code before the actual function call and then some new code after the function returns. You might even consider writing a <em class="italic">higher</em> HOF, which would receive three functions and produce a new HOF as output (such as <code>addLogging()</code> or <code>addTiming()</code>) that would call the first function at the beginning, and then the second function if the wrapped function returned a <a id="_idIndexMarker428"/>value, or the third function if an error had been thrown! How about that?</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Memoizing functions</h2>
			<p>In <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, we considered the case of the Fibonacci function and learned how we <a id="_idIndexMarker429"/>could transform it, by hand, into a much more efficient version using <em class="italic">memoization</em>: caching calculated values to avoid recalculations. A <em class="italic">memoized</em> function would avoid redoing a process if the result was found earlier. We <a id="_idIndexMarker430"/>want to be able to turn any function into a memoized one so that we can get a more optimized version. However, a real-life memoizing solution should also take into account the available RAM and have some ways of avoiding filling it up; however, this is beyond the scope of this book, and we won’t be looking into performance issues either; those optimizations are also beyond the scope of this book.</p>
			<p class="callout-heading">Of frameworks and memos</p>
			<p class="callout">Some memoizing functionality is <a id="_idIndexMarker431"/>provided by tools such as React (the <code>useMemo()</code> hook) or Vue (the <code>v-memo</code> directive), but it’s not really the same. In these cases, only the previous <a id="_idIndexMarker432"/>result is kept, and re-rendering is avoided if a value changes. With the kind of memoization we’re discussing, <em class="italic">all</em> previous values are cached for reuse; React and Vue cache just one value.</p>
			<p>For simplicity, let’s only consider functions with a single, non-structured parameter and leave functions with more complex parameters (objects and arrays) or more than one parameter for later. The kind of values we can handle with ease are JavaScript’s primitive values: data that aren’t objects and have no methods. JavaScript has six of these: <code>boolean</code>, <code>null</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, and <code>undefined</code>. Usually, we only see the first four as actual arguments. You can find out more by going to <a href="http://developer.mozilla.org/en-US/docs/Glossary/Primitive">developer.mozilla.org/en-US/docs/Glossary/Primitive</a>.</p>
			<p>We’re not aiming to produce the best-ever memoizing solution, but let’s study the subject a bit and produce several variants of a memoizing HOF. First, we’ll deal with functions with a single parameter and then consider functions with several parameters.</p>
			<h3>Simple memoization</h3>
			<p>We will work with the Fibonacci <a id="_idIndexMarker433"/>function we mentioned previously, which is a simple case: it receives a single numeric parameter. This function is as follows:</p>
			<pre class="source-code">
// fibonacci.ts
function fib(n: number): number {
  if (n == 0) {
    return 0;
  } else if (n == 1) {
    return 1;
  } else {
    return fib(n - 2) + fib(n - 1);
  }
}</pre>
			<p>The solution we previously created was general in concept but not particularly good in its implementation: we had to directly modify the function’s code to take advantage of said memoization. Let’s look into how to do this automatically, in the same fashion as other wrapped functions. The solution would be a <code>memoize()</code> function that wraps any other function to apply memoization. For clarity, let’s work with JavaScript first and just for functions with a single numeric parameter:</p>
			<pre class="source-code">
// memoize.ts
const memoize = (fn) =&gt; {
  const cache = {};
  return (x) =&gt;
    x in cache ? cache[x] : (cache[x] = fn(x));
};</pre>
			<p>How does this work? The returned function, for any given argument, checks whether the argument was already received; that is, whether it can be found as a key in the cache object. (See <em class="italic">Question 6.2</em> for an alternative implementation of the cache.) If so, there’s no need for calculation, and the cached value is returned. Otherwise, we calculate the missing value and store it in the cache. (We use a closure to hide the cache from external access.) Here, we assume that the memoized function receives only one argument (<code>x</code>) and that it is a numeric value, which can then be directly used as a key value for the cache object; we’ll consider other cases later.</p>
			<p>We now need to go to TypeScript; here’s the equivalent version of <code>memoize()</code>. The generic data typing is along the same lines as what we saw in the <em class="italic">Logging in a functional way</em> section, with the only difference being that now we work with functions that get a single numeric argument:</p>
			<pre class="source-code">
// continued...
const memoize = <strong class="bold">&lt;T extends (x: number) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">((x: number) =&gt; ReturnType&lt;T&gt;)</strong> =&gt; {
  const cache = {} as Record&lt;number, ReturnType&lt;T&gt;&gt;;
  return (x) =&gt;
    x in cache ? cache[x] : (cache[x] = fn(x));
};</pre>
			<p>Is memoization working? We’ll have to time it – and we happen to have a useful <code>addTiming()</code> function for <a id="_idIndexMarker434"/>that! First, we time the original <code>fib()</code> function. We want to time the complete calculation and not each recursive call, so we write an auxiliary <code>testFib()</code> function, which is the one we’ll time.</p>
			<p>We should repeat the timing operations and do an average, but since we just want to confirm that memoizing works, we’ll tolerate differences:</p>
			<pre class="source-code">
const testFib = (n: number) =&gt; fib(n);
addTiming(testFib)(45); // 18,957 ms
addTiming(testFib)(40); //  1,691 ms
addTiming(testFib)(35); //    152 ms</pre>
			<p>Of course, your times will depend on your specific CPU, RAM, and so on. However, the results seem logical: the exponential growth we mentioned in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, appears to be present, and times grow quickly. Now, let’s memoize <code>fib()</code>. We should get shorter times... shouldn’t we?</p>
			<pre class="source-code">
const testMemoFib = memoize((n: number) =&gt; fib(n));
addTiming(testMemoFib)(45); // 19,401 ms
addTiming(testMemoFib)(45); //  0.005 ms – good!
addTiming(testMemoFib)(40); //  2,467 ms  ???
addTiming(testMemoFib)(35); //    174 ms  ???</pre>
			<p>Something’s wrong! The times should have gone down, but they are just about the same. This is because of a common error, which I’ve even seen in some articles and web pages. We are timing <code>testMemoFib()</code>, but nobody calls that function except for timing, which only happens once! Internally, all recursive calls are to <code>fib()</code>, which isn’t memoized. If we called <code>testMemoFib(45)</code> again, <em class="italic">that</em> call would be cached, and it would return almost immediately, but that optimization doesn’t apply to the internal <code>fib()</code> calls. This is the reason why the calls for <code>testMemoFib(40)</code> and <code>testMemoFib(35)</code> weren’t optimized – when we did the calculation for <code>testMemoFib(45)</code>, that was the only value that got cached.</p>
			<p>The correct solution is as follows:</p>
			<pre class="source-code">
fib = memoize(fib);
addTiming(testFib)(45); // 0.1481 ms
addTiming(testFib)(45); // 0.0022 ms
addTiming(testFib)(40); // 0.0019 ms
addTiming(testFib)(35); // 0.0029 ms</pre>
			<p>Now, when calculating <code>fib(45)</code>, all the intermediate Fibonacci values (from <code>fib(0)</code> to <code>fib(45)</code> itself) are stored, so the <a id="_idIndexMarker435"/>forthcoming calls have practically no work to do.</p>
			<p>Now that we know how to memoize single-argument functions, let’s look at functions with more arguments.</p>
			<h3>More complex memoization</h3>
			<p>What can we <a id="_idIndexMarker436"/>do if we have to work with a function that receives two or more arguments, or can receive arrays or objects as arguments? Of course, like in the problem that we looked at in <a href="B19301_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Thinking Functionally</em>, about having a function do its job only once, we could simply ignore the question: if the function to be memoized is unary, we go through the memoization process; otherwise, we don’t do anything!</p>
			<p class="callout-heading">On the length of functions</p>
			<p class="callout">The number of parameters of a function is called the function’s <em class="italic">arity,</em> or <em class="italic">valence</em>, and JavaScript provides it as the function’s <code>length</code> attribute; see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length</a>. You may speak in three different ways: you can say a function has arity one, two, three, and so on; you can say that a function is unary, binary, ternary, and so on; or you can say it’s monadic, dyadic, triadic, and so on. Take your pick!</p>
			<p>Our first attempt could be just memoizing unary functions and leaving the rest alone, as in the following code:</p>
			<pre class="source-code">
// continued...
const memoize2 = &lt;
  T extends (x: number, ...y: any[]) =&gt; any
&gt;(
  fn: T
): ((x: number, ...y: any[]) =&gt; ReturnType&lt;T&gt;) =&gt; {
  <strong class="bold">if (fn.length === 1)</strong> {
    const cache = {} as Record&lt;number, ReturnType&lt;T&gt;&gt;;
    return (x) =&gt;
      x in cache ? cache[x] : (cache[x] = fn(x));
  <strong class="bold">} else {</strong>
<strong class="bold">    return fn;</strong>
<strong class="bold">  }</strong>
};</pre>
			<p>Working more seriously, if we want to be able to memoize any function, we must find a way to generate <a id="_idIndexMarker437"/>cache keys. To do this, we must find a way to convert any argument into a string. We cannot use a non-primitive as a cache key directly. We could attempt to convert the value into a string with something such as <code>strX = String(x)</code>, but we'd have problems. With arrays, it seems this could work. However, take a look at the following three cases that involve different arrays but with a twist:</p>
			<pre class="source-code">
var a = [1, 5, 3, 8, 7, 4, 6];
String(a); // "1,5,3,8,7,4,6"
var b = [[1, 5], [3, 8, 7, 4, 6]];
String(b); // "1,5,3,8,7,4,6"
var c = [[1, 5, 3], [8, 7, 4, 6]];
String(c); // "1,5,3,8,7,4,6"</pre>
			<p>These three cases produce the same result. If we were only considering a single array argument, we’d be able to make do, but when different arrays produce the same key, that’s a problem. Things become worse if we have to receive objects as arguments because the <code>String()</code> representation of any object is, invariably, <code>"[</code><code>object Object]"</code>:</p>
			<pre class="source-code">
var d = {a: "fk"};
String(d); // "[object Object]"
var e = [{p: 1, q: 3}, {p: 2, q: 6}];
String(e); // "[object Object],[object Object]"</pre>
			<p>The simplest solution is to use <code>JSON.stringify()</code> to convert whatever arguments we have received into a useful, distinct string:</p>
			<pre class="source-code">
var a = [1, 5, 3, 8, 7, 4, 6];
JSON.stringify(a); // "[1,5,3,8,7,4,6]"
var b = [[1, 5], [3, 8, 7, 4, 6]];
JSON.stringify(b); // "[[1,5],[3,8,7,4,6]]"
var c = [[1, 5, 3], [8, 7, 4, 6]];
JSON.stringify(c); // "[[1,5,3],[8,7,4,6]]"
var d = {a: "fk"}; JSON.stringify(d); // "{"a":"fk"}"
var e = [{p: 1, q: 3}, {p: 2, q: 6}];
JSON.stringify(e); // "[{"p":1,"q":3},{"p":2,"q":6}]"</pre>
			<p>For performance, our logic <a id="_idIndexMarker438"/>should be as follows: if the function we are memoizing receives a single argument that’s a primitive value, we can use that argument directly as a cache key. In other cases, we would use the result of <code>JSON.stringify()</code> that’s applied to the array of arguments. Our enhanced memoizing HOF could be as follows:</p>
			<pre class="source-code">
// continued...
const memoize3 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;
    number | string,
    ReturnType&lt;T&gt;
  &gt;;
  const PRIMITIVES = ["number", "string"];
  return (...args) =&gt; {
    const strX: number | string =
      args.length === 1 &amp;&amp;
<strong class="bold">      PRIMITIVES.includes(typeof args[0])</strong>
<strong class="bold">        ? args[0]</strong>
<strong class="bold">        : JSON.stringify(args);</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};</pre>
			<p>In terms of universality, this is the safest version. If you are sure about the type of parameters in the <a id="_idIndexMarker439"/>function you will process, it’s arguable that our first version was faster. On the other hand, if you want to have easier-to-understand code, even at the cost of some wasted CPU cycles, you could go with a simpler version:</p>
			<pre class="source-code">
// continued...
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;string, ReturnType&lt;T&gt;&gt;;
  return (...args) =&gt; {
    <strong class="bold">const strX = JSON.stringify(args);</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};</pre>
			<p class="callout-heading">Birth of a speeder</p>
			<p class="callout">If you want to learn about the development of a top-performance memoizing function, read Caio Gondim’s <em class="italic">How I wrote the world’s fastest JavaScript memoization library</em> article, available online at <a href="https://blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/">blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/</a>.</p>
			<p>So far, we have achieved <a id="_idIndexMarker440"/>several interesting memoizing functions, but how will we write tests for them? Let’s analyze this problem now.</p>
			<h3>Memoization testing</h3>
			<p>Testing the memoization HOF poses an interesting problem – how would you go about it? The first idea would be to <a id="_idIndexMarker441"/>look into the cache, but that’s private and not visible. Then, of course, we could change <code>memoize()</code> so that it uses a global cache or somehow allows external access to the cache, but doing that sort of internal exam is frowned upon: you should try to do your tests based on external properties only.</p>
			<p>Accepting that we shouldn’t try to examine the cache, we could go for a time control: calling a function such as <code>fib(n)</code> for a large value of <code>n</code> should take longer if the function isn’t memoized. This is certainly possible, but it’s also prone to possible failures: something external to your tests could run at just the wrong time, and it could be possible that your memoized run would take longer than the original one. Okay, it’s possible, but not probable – but your test isn’t entirely reliable.</p>
			<p>We could think about calculating some Fibonacci numbers and testing how many times the function was called – once directly and all the other times because of recursion. (See <em class="italic">Question 6.3</em> for more on this.) The preceding code is fairly straightforward: we are using the Fibonacci function we developed earlier and testing that it produces correct values. For instance, we can find out that calculating <code>fib(6)</code> requires 25 calls by revisiting the diagram we looked at in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, and seeing that there are 25 nodes (each one representing a call to <code>fib()</code>) in it:</p>
			<div><div><img src="img/Figure_4.2_B19301.jpg" alt="Figure 6.1 – 25 calls are needed for calculating ﬁb(6)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – 25 calls are needed for calculating ﬁb(6)</p>
			<p>The first idea would be counting calls, as shown here – but it won’t work!</p>
			<pre class="source-code">
// memoize.test.ts
import { fib } from "./fibonacci";
import * as moduleFib from "./fibonacci";
describe("the original fib", function () {
  it("should repeat calculations", () =&gt; {
    jest.spyOn(moduleFib, "fib");
    expect(fib(6)).toBe(8);
    <strong class="bold">expect(fib).toHaveBeenCalledTimes(25);</strong>
  });
});</pre>
			<p>We first calculate <code>fib(6)</code> – which correctly returns <code>8</code> – and then we check that there should have been 25 calls to <code>fib()</code>, but only one was found; what’s going on? The problem is in Jest: when <a id="_idIndexMarker442"/>you spy on a function, you are actually spying on a wrapper that calls the function you want to check. <em class="italic">This</em> wrapper function is called only once; our <code>fib()</code> function was called 25 times, but Jest doesn’t see that!</p>
			<p>We’ll have to do something else in a very non-functional way! Let’s test a modified <code>fib()</code> function that will update an external counter; we’ll call it <code>fibM()</code>:</p>
			<pre class="source-code">
// continued...
describe("the modified fib", function () {
  it("should repeat calculations", () =&gt; {
<strong class="bold">    let count = 0;</strong>
    const fibM = (n: number): number =&gt; {
<strong class="bold">      count++;</strong>
      if (n == 0) {
        return 0;
      } else if (n == 1) {
        return 1;
      } else {
        return fibM(n - 2) + fibM(n - 1);
      }
    };
<strong class="bold">    expect(fibM(6)).toBe(8);</strong>
<strong class="bold">    expect(count).toBe(25);</strong>
  });
});</pre>
			<p>Now that the test works out, how about testing the memoized, modified version instead? In this <a id="_idIndexMarker443"/>case, the count of calls should be lower because of cached results. In fact, it should just be <code>7</code> because we’ll need all values from <code>fib(6)</code> down to <code>fib(0)</code>:</p>
			<pre class="source-code">
// continued...
describe("the memoized, modified fib", function () {
  it("should repeat calculations", () =&gt; {
    let count = 0;
    const fibMM = memoize((n: number): number =&gt; {
      count++;
      if (n == 0) {
        return 0;
      } else if (n == 1) {
        return 1;
      } else {
        return fibMM(n - 2) + fibMM(n - 1);
      }
    });
    expect(fibMM(6)).toBe(8);
<strong class="bold">    expect(count).toBe(7);</strong>
  });</pre>
			<p>In this section, we’ve dealt with several examples that implied wrapping functions so that they keep working <a id="_idIndexMarker444"/>but with some extra features added in. Now, let’s look at a different case where we want to change how a function works.</p>
			<h3>Memoizing promises</h3>
			<p>Let’s go a bit further and consider memoizing <code>async</code> functions, which return promises. In a complex web application with many related components, it may very well be the case that redundant, repeated API calls go out for no good reason, harming performance and <a id="_idIndexMarker445"/>producing a bad user experience. Imagine, for instance, a dashboard-style web page with several tabs. Whenever a user selects a tab, several API calls go out to get the data that the page needs. However, if the user selects a different tab but later returns to the first one, the very same API calls will go out again. For many applications, data is basically constant, meaning “not changing in real time.” You don’t then need to re-send API calls; re-using previously fetched data also works.</p>
			<p>Some solutions are not practical: we could modify the server to enable caching, but what if that’s not possible? Or we could work with a cache, checking before every call whether that data was already fetched, but that would entail hand-modifying every single API call to check the cache first! We want a solution that requires no code changes, and memoizing comes to mind.</p>
			<p>Assume we call the API with an <code>async</code> function that returns a promise. Given the <code>memoize()</code> function we developed, we could memoize the <code>async</code> function, and it would be a start. The first time you call the function with some arguments, the API call will go out, and a promise will be returned (since that’s what the function returns). If you call the function again with the same arguments, the memoized promise will be immediately returned. Great! Except there’s a catch… what would happen if the API call failed? We need to add some error-catching logic:</p>
			<pre class="source-code">
// memoize.ts
const promiseMemoize = &lt;
  A,
  T extends (...x: any[]) =&gt; Promise&lt;A&gt;
&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; Promise&lt;A&gt;) =&gt; {
  const cache = {} as Record&lt;string, Promise&lt;A&gt;&gt;;
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    return strX in cache
      ? cache[strX]
      : (cache[strX] = <strong class="bold">fn(...args).catch((x) =&gt; {</strong>
<strong class="bold">          delete cache[strX];</strong>
<strong class="bold">          return x;</strong>
<strong class="bold">        }</strong>));
  };
};</pre>
			<p>All logic is as before, with <a id="_idIndexMarker446"/>a couple of additional details:</p>
			<ul>
				<li>We are now making explicit that the memoized function returns a promise (<code>Promise&lt;A&gt;</code>) of some generic type <code>A</code></li>
				<li>If the promise is rejected, we add code to delete the cached promise, so a future call will go out again</li>
			</ul>
			<p>Our new <code>promiseMemoize()</code> function can deal with errors, allowing future retries of rejected calls; good! Now let’s <a id="_idIndexMarker447"/>look at a different case, where we want to change the way a function actually works.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Altering a function’s behavior</h1>
			<p>In the previous section, we considered some ways of wrapping functions so that they maintain their <a id="_idIndexMarker448"/>original functionality, even though they’ve been enhanced in some way. Now, we’ll turn to modifying what the functions do so that the new results will differ from their original ones.</p>
			<p>We’ll be covering the following topics:</p>
			<ul>
				<li>Revisiting the problem of having a function work, but just once</li>
				<li>Negating or inverting a function’s result</li>
				<li>Changing the arity of a function</li>
				<li>Throttling and debouncing functions for performance</li>
			</ul>
			<p>Let’s get started!</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Doing things once, revisited</h2>
			<p>In <a href="B19301_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Thinking Functionally</em>, we went through an example of developing an FP-style solution for a simple problem: fixing things so that a given function works only <a id="_idIndexMarker449"/>once. We defined <code>once()</code> with an arrow <a id="_idIndexMarker450"/>function then; let’s go with a standard function for variety:</p>
			<pre class="source-code">
// once.ts
function once&lt;T extends (...args: any[]) =&gt; void&gt;(
  f: T
): (...args: Parameters&lt;T&gt;) =&gt; void {
  let done = false;
  return ((...args: Parameters&lt;T&gt;) =&gt; {
    if (!done) {
      done = true;
      f(...args);
    }
  }) as T;
}</pre>
			<p>This is a perfectly acceptable solution; it works well, and we have nothing to object to. We can, however, think of a variation. We could observe that the given function gets called once, but its return value gets lost. This is easy to fix: we need to add a <code>return</code> statement. However, that wouldn’t be enough; what would the function return if it’s called more than once? We can take a page from the memoizing solution and store the function’s return value for future calls.</p>
			<p>Let’s store the function’s value in a <code>result</code> variable so that we can return it later:</p>
			<pre class="source-code">
// continued...
function once2&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  let done = false;
<strong class="bold">  let result: ReturnType&lt;T&gt;;</strong>
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    if (!done) {
      done = true;
<strong class="bold">      result = f(...args);</strong>
    }
<strong class="bold">    return result;</strong>
  }) as T;
}</pre>
			<p>The first time the function gets called, its value is stored in <code>result</code>; further calls just return that value with no further process. You could also think of making the function work only once but for each set of arguments. You wouldn’t have to do any work for that – <code>memoize()</code> would be enough!</p>
			<p>Back in the <em class="italic">Producing an even better solution</em> section of <a href="B19301_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Thinking Functionally</em>, we considered a possible alternative to <code>once()</code>: another HOF that took two functions as parameters and allowed the <a id="_idIndexMarker451"/>first function to be called only once, calling the second function from that point on. Adding a <code>return</code> statement to the previous code and rewriting it as a standard function would result as follows:</p>
			<pre class="source-code">
// continued...
function onceAndAfter&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T,
  g: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  let done = false;
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    if (!done) {</strong>
<strong class="bold">      done = true;</strong>
<strong class="bold">      return f(...args);</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">      return g(...args);</strong>
<strong class="bold">    }</strong>
  }) as T;
}</pre>
			<p>We can rewrite this if we remember that functions are first-order objects. Instead of using a flag to remember which function to call, we can use a <code>toCall</code> variable to directly store whichever function needs to be called. Logically, that variable will be initialized to the first function but will then change to the second one. The following code implements that change:</p>
			<pre class="source-code">
// continued...
function onceAndAfter2&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T,
  g: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
<strong class="bold">  let toCall = f;</strong>
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    let result = toCall(...args);</strong>
<strong class="bold">    toCall = g;</strong>
<strong class="bold">    return result;</strong>
  }) as T;
}</pre>
			<p>The <code>toCall</code> variable is <a id="_idIndexMarker452"/>initialized with <code>f</code>, so <code>f()</code> will get called the first time, but then <code>toCall</code> gets the <code>g</code> value, implying that all future calls will execute <code>g()</code> instead. The very same example we looked at earlier in this book would still work:</p>
			<pre class="source-code">
const squeak = (x: string) =&gt; console.log(x, "squeak!!");
const creak = (x: string) =&gt; console.log(x, "creak!!");
const makeSound = onceAndAfter2(squeak, creak);
makeSound("door"); // "door squeak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"</pre>
			<p>In terms of performance, the difference may be negligible. The reason for showing this further variation is to show that you should keep in mind that, by storing functions, you can often produce results more simply. Using flags to store state is a common technique in procedural <a id="_idIndexMarker453"/>programming. However, here, we manage to skip that usage and produce the same result. Now, let’s look at some new examples of wrapping functions to change their behaviors.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Logically negating a function</h2>
			<p>Let’s consider the <code>filter()</code> method from <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>. Given a predicate, we can filter the array to only include those elements for which the predicate is true. But how would you do a reverse filter and exclude the elements for which the predicate is true?</p>
			<p>The first solution should be pretty obvious: rework the predicate to return the opposite of whatever it originally returned. In the mentioned chapter, we looked at the following example:</p>
			<pre class="source-code">
// not.ts
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);</pre>
			<p>(For the <code>serviceResult</code> object, see the <em class="italic">A filter() example</em> section in the previous chapter.)</p>
			<p>So, we could write it the other way round, in either of these equivalent fashions. Note the different ways of writing the same predicate to test for non-negative values:</p>
			<pre class="source-code">
// continued...
const notDelinquent = serviceResult.accountsData.filter(
<strong class="bold">  (v) =&gt; v.balance &gt;= 0</strong>
);
const notDelinquent2 = serviceResult.accountsData.filter(
<strong class="bold">  (v) =&gt; !(v.balance &lt; 0)</strong>
);</pre>
			<p>That’s perfectly fine, but we could also have had something like the following in our code:</p>
			<pre class="source-code">
// continued...
const isNegativeBalance = (v: AccountData) =&gt; v.balance &lt; 0;
.
. many lines later
.
const delinquent2 = serviceResult.accountsData.filter(
  isNegativeBalance
);</pre>
			<p>In this case, rewriting the original <code>isNegativeBalance()</code> function isn’t possible. (Another possibility: the function could be defined in a separate module, which you can’t or shouldn’t modify.) However, working in a functional way, we can write an HOF that will take any <a id="_idIndexMarker454"/>predicate, evaluate it, and then negate its result. A possible implementation would be pretty straightforward, thanks to modern JavaScript syntax – and for the TypeScript version, check <em class="italic">Question 6.5</em>:</p>
			<pre class="source-code">
// continued...
const <strong class="bold">not</strong> = (fn) =&gt; (...args) =&gt; !fn(...args);</pre>
			<p>Working in this way, we could have rewritten the preceding filter as follows; to test for non-negative balances, we use the original <code>isNegativeBalance()</code> function, which is negated via our <code>not()</code> HOF:</p>
			<pre class="source-code">
// continued...
const notDelinquent3 = serviceResult.accountsData.filter(
<strong class="bold">  not(isNegativeBalance)</strong>
);</pre>
			<p>There is an additional solution we might want to try out. Instead of reversing the condition (as we did), we could write a new filtering method (possibly <code>filterNot()</code>?) that would work in the opposite way to <code>filter()</code>. The following code shows how this new function would be written. Given an <code>arr</code> array of values and an <code>fn</code> predicate, we’d have the following:</p>
			<pre class="source-code">
// continued...
const <strong class="bold">filterNot</strong> =
  &lt;A, T extends (x: A) =&gt; boolean&gt;(arr: A[]) =&gt;
  (fn: T): A[] =&gt;
  <strong class="bold">  arr.filter(not((y) =&gt; fn(y)));</strong></pre>
			<p>This solution doesn’t fully match <code>filter()</code> since you cannot use it as a method, but we could either add it to <code>Array.prototype</code> or apply some methods. We’ll look at these ideas in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>. However, it’s more interesting to note that we used the negated function, so <code>not()</code> is necessary for both solutions to the reverse filtering problem. In the upcoming <em class="italic">Demethodizing – turning methods into functions</em> section, we will see that we have yet another solution since we can decouple methods such as <code>filter()</code> from the objects they apply to, thereby changing them into common functions.</p>
			<p>As for negating the function versus using a new <code>filterNot()</code> function, even though both possibilities are <a id="_idIndexMarker455"/>equally valid, I think using <code>not()</code> is clearer. If you already understand how filtering works, then you can practically read the code aloud, and it will be understandable: we want those accounts that don’t have a negative balance, right? Now, let’s consider a related problem: inverting the results of a function.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Inverting the results</h2>
			<p>In the same vein as the preceding filtering problem, let’s revisit the sorting problem from the <em class="italic">Injection – sorting it out</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions</em>. Here, we wanted to sort an array with a specific method. Therefore, we used <code>sort()</code>, providing it with a <code>comparison</code> function that basically pointed out which of the two strings should go first. To refresh your memory, given two strings, the function should do the following:</p>
			<ul>
				<li>Return a negative number if the first string should precede the second one</li>
				<li>Return <code>0</code> if the strings are the same</li>
				<li>Return a positive number if the first string should follow the second one</li>
			</ul>
			<p>Let’s go back to the code we looked at for sorting in Spanish. We had to write a specialized <code>comparison</code> function so that sorting would take into account the character-ordering rules from Spanish, such as placing the letter <em class="italic">ñ</em> between <em class="italic">n</em> and <em class="italic">o</em>, and more. The code for this was as follows:</p>
			<pre class="source-code">
const spanishComparison = (a: string, b: string) =&gt;
  a.localeCompare(b, "es");
palabras.sort(spanishComparison);
// sorts the array according to Spanish rules</pre>
			<p>We are facing a similar problem: how can we sort in descending order? Given what we saw in the previous section, some options should immediately come to mind:</p>
			<ul>
				<li>Sort into ascending order, and afterward reverse the array. While this solves the problem, we still only sort into ascending order, and we would want to avoid the extra reversing step.</li>
				<li>Write a function that will invert the result from the comparing function. This will invert the result of <a id="_idIndexMarker456"/>all the decisions as to which string should precede, and the final result will be an array sorted in exactly the opposite way.</li>
				<li>Write a <code>sortDescending()</code> function or method that does its work in the opposite fashion to <code>sort()</code>.</li>
			</ul>
			<p>Let’s opt for the second option and write an <code>invert()</code> function that will change the comparison result. The code <a id="_idIndexMarker457"/>itself is quite similar to that of <code>not()</code>. Again, check <em class="italic">Question 6.5</em> for the TypeScript equivalent:</p>
			<pre class="source-code">
// invert.ts
const invert = (fn) =&gt; (...args) =&gt; <strong class="bold">-fn(...args)</strong>;</pre>
			<p>Given this HOF, we can sort in descending order by providing a suitably inverted <code>comparison</code> function. Take a look at the last few lines, where we use <code>invert()</code> to change the result of the sorting comparison:</p>
			<pre class="source-code">
const spanishComparison = (a: string, b: string): number =&gt;
  a.localeCompare(b, "es");
const palabras = [
  "ñandú",
  "oasis",
  "mano",
  "natural",
  "mítico",
  "musical",
];
palabras.sort(spanishComparison);
// "mano", "mítico", "musical", "natural", "ñandú", "oasis"
palabras.sort(<strong class="bold">invert(spanishComparison)</strong>);
// "oasis", "ñandú", "natural", "musical", "mítico", "mano"</pre>
			<p>The output <a id="_idIndexMarker458"/>is as expected: when we <code>invert()</code> the <code>comparison</code> <a id="_idIndexMarker459"/>function, the results are in the opposite order. Writing unit tests would be quite easy, given that we already have some test cases with their expected results, wouldn’t it?</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Arity changing</h2>
			<p>Back in the <em class="italic">Parsing numbers tacitly</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we saw that using <code>parseInt()</code> with <code>reduce()</code> produces problems because of the unexpected arity of that function, which took more than one argument—remember the example from earlier?</p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(parseInt);
// <strong class="bold">[123, NaN, NaN]</strong></pre>
			<p>We have more than one way to solve this. In the mentioned chapter, we went with an arrow function. This was a simple solution, with the added advantage of being clear to understand. In <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, we will look at yet another, based on partial application. For now, let’s go with an HOF We need a function that will take another function as a parameter and turn it into a unary function. Using JavaScript’s spread operator and an arrow function, this is easy to manage:</p>
			<pre class="source-code">
const unary = fn =&gt; (...args) =&gt; fn(args[0]);</pre>
			<p>The following is the example in TypeScript:</p>
			<pre class="source-code">
// arity.ts
const unary =
  <strong class="bold">&lt;T extends (...x: any[]) =&gt; any&gt;</strong>(
    fn: T
  ): <strong class="bold">((arg: Parameters&lt;T&gt;[0]) =&gt; ReturnType&lt;T&gt;)</strong> =&gt;
(x) =&gt; fn(x);</pre>
			<p>Our <code>unary()</code> function works with a generic <code>T</code> function. It produces a new function with just a single argument (the first one, <code>Parameters&lt;T&gt;[0]</code>) that returns the same type of result (<code>ReturnType&lt;T&gt;</code>) as the original function does.</p>
			<p>Using this function, our number parsing problem goes away:</p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(<strong class="bold">unary(parseInt)</strong>);
// [123, -67, 90]</pre>
			<p>It goes without saying that it <a id="_idIndexMarker460"/>would be equally simple to define further <code>binary()</code> or <code>ternary()</code>functions, and others that would turn any function into an equivalent but restricted-arity version. Let’s not go overboard and just look at a couple of all the possible functions – see <em class="italic">Question 6.10</em> for more on this:</p>
			<pre class="source-code">
// continued...
const binary = fn =&gt; (...a) =&gt; fn(<strong class="bold">a[0], a[1]</strong>);
const ternary = fn =&gt; (...a) =&gt; fn(<strong class="bold">a[0], a[1], a[2]</strong>);</pre>
			<p>This works, but spelling out all the parameters can become tiresome. We can even go one better by using array operations and spreading and make a generic function to deal with all of these cases, as follows:</p>
			<pre class="source-code">
// continued...
const arity = (<strong class="bold">n</strong>, fn) =&gt; (...a) =&gt; fn(<strong class="bold">...a.slice(0, n)</strong>);</pre>
			<p>With this generic <code>arity()</code> function, we can give alternative definitions for <code>unary()</code>, <code>binary()</code>, and so on. We could even <a id="_idIndexMarker461"/>rewrite the earlier functions as follows:</p>
			<pre class="source-code">
const unary = fn =&gt; arity(<strong class="bold">1</strong>, fn);
const binary = fn =&gt; arity(<strong class="bold">2</strong>, fn);
const ternary = fn =&gt; arity(<strong class="bold">3</strong>, fn);</pre>
			<p>You may think that there aren’t many cases in which you would want to apply this kind of solution, but there are many more than you would expect. Going through all of JavaScript’s functions and methods, you can quickly produce a list starting with <code>apply()</code>, <code>assign()</code>, <code>bind()</code>, <code>concat()</code>, <code>copyWithin()</code>, and many more! If you wanted to use any of those in a tacit way, you would probably need to fix their arity so that they would work with a fixed, non-variable number of parameters.</p>
			<p class="callout-heading">Everything under the sun</p>
			<p class="callout">If you want a nice list of JavaScript functions and methods, check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions</a> and <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index</a>. As for tacit programming (or pointfree style), we’ll return to it in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>.</p>
			<p class="callout">There will be a problem with TypeScript, though. TypeScript deals with static typing, but the type of the result of a call to <code>arity()</code> is determined at runtime. The most we may manage is, by a <a id="_idIndexMarker462"/>series of overloads, to say that given a function with several parameters, the result of applying <code>arity()</code> to it will have zero, one, two, and so on different possibilities – but we won’t be able to do more.</p>
			<p>So far, we have learned <a id="_idIndexMarker463"/>how to wrap functions while keeping their original behavior or changing it in some fashion. Now, let’s consider some other ways of modifying functions.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Throttling and debouncing</h2>
			<p>Let’s finish this section with two techniques that limit when and how often a function “does its thing”: <strong class="bold">debouncing</strong> and <strong class="bold">throttling</strong>. Both techniques share the same concept, so we’ll tackle them together:</p>
			<ul>
				<li><em class="italic">Debouncing</em> a function <a id="_idIndexMarker464"/>means we delay for some time, doing nothing <em class="italic">until</em> we actually call the function</li>
				<li><em class="italic">Throttling</em> a function means <a id="_idIndexMarker465"/>we delay for some time, doing nothing <em class="italic">after</em> we actually call the function</li>
			</ul>
			<p>These techniques are very efficient for web pages and allow for better performance. In a sense, they are related to memoizing. With memoization, you modify a function so it will get called only once (for some given arguments) but never more. With the techniques here, we do not go that far – we will allow a function to do its thing again, but in a restricted way, with some delays added in.</p>
			<h3>Debouncing functions</h3>
			<p>The idea of debouncing comes from electronics and involves waiting to do something until a stable state has been reached. For example, if you write an autocomplete component, every <a id="_idIndexMarker466"/>time the user types a letter, you could query an API to fetch the possible options. However, you wouldn’t want to do this keypress by keypress because you’d be generating lots of calls, most of which you won’t even use since you’ll only care for the last one you made. Other usual examples involve mouse movement or page scrolling events; you don’t want to run associated handlers too often since that will negatively impact the page’s performance.</p>
			<p>If you debounced the API-calling function, you could still call it for every keypress, but no API call would be made until some time elapsed without any more calls. See <em class="italic">Figure 6</em><em class="italic">.2</em> for an example of this; events are shown as circles, and the actual call goes only given some event-less time after the last event:</p>
			<div><div><img src="img/Figure_6.2_B19301.jpg" alt="Figure 6.2 – A debounced function executes only after a pause in calls to it"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A debounced function executes only after a pause in calls to it</p>
			<p>We can implement this with a timeout as follows:</p>
			<pre class="source-code">
// debounce.ts
const debounce = &lt;T extends (...args: any[]) =&gt; void&gt;(
  fn: T,
  delay = 1000
) =&gt; {
<strong class="bold">  let timer</strong>: ReturnType&lt;typeof setTimeout&gt;;
  return (...args: Parameters&lt;T&gt;): void =&gt; {
<strong class="bold">    clearTimeout(timer);</strong>
<strong class="bold">    timer = setTimeout(() =&gt; fn(...args), timeDelay);</strong>
  };
};</pre>
			<p>A debounced function is a new one that can be called as often as desired but won’t do anything until a <code>timer</code> has run. If you call the function once and then call it again, the timer will be reset <a id="_idIndexMarker467"/>and start running again. The only way for the function to actually do its thing is if a given <code>delay</code> period passes without any new calls.</p>
			<h3>Throttling functions</h3>
			<p>For the complementary throttling transformation, imagine a web form with a <strong class="bold">FETCH</strong>, <strong class="bold">APPLY FILTERS</strong>, or <strong class="bold">RETRIEVE</strong> button. When you click on it, an API call is made to get some data. However, if the user starts clicking again and again, too many calls will be made, even <a id="_idIndexMarker468"/>if they will get the same results. We want to throttle the calls so the first call will go through, but further calls will be disabled until some time has passed. A similar use case applies to <em class="italic">infinite scrolling</em>; as the user scrolls down the page, you want to fetch more data, but you neither want to do it very often for performance reasons nor wait until the user reaches the bottom (as would be the case with debouncing) because then scrolling would be stopped.</p>
			<p>Throttling is similar to debouncing, but a throttled function runs but then waits until the next run, while a debounced <a id="_idIndexMarker469"/>function first waits and then runs. <em class="italic">Figure 6</em><em class="italic">.3</em> shows how throttling works. As in the previous section, events are shown as circles. After a call to the API, no further calls are done unless some time has passed:</p>
			<div><div><img src="img/Figure_6.3_B19301.jpg" alt="Figure 6.3 – A throttled function runs the first time it’s called but then delays until running again"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A throttled function runs the first time it’s called but then delays until running again</p>
			<pre class="source-code">
// throttle.ts
const throttle = &lt;T extends (...args: any[]) =&gt; void&gt;(
  fn: T,
  delay = 1000
) =&gt; {
<strong class="bold">  let timer</strong>: ReturnType&lt;typeof setTimeout&gt; | undefined;
  return (...args: Parameters&lt;T&gt;): void =&gt; {
   <strong class="bold"> if (!timer) {</strong>
<strong class="bold">      timer = setTimeout(() =&gt; {</strong>
<strong class="bold">        timer = undefined;</strong>
<strong class="bold">      }, delay);</strong>
<strong class="bold">      fn(...args);</strong>
    }
  };
};</pre>
			<p>A throttled function is a new one, which you can call as often as desired, but it will “do its thing” the first time and not again until a certain <code>delay</code>. When you call the function, it first checks <a id="_idIndexMarker470"/>whether the <code>timer</code> is set; if so, it won’t do anything. If the timer isn’t set, a timeout will be set to clear the <code>timer</code> after some <code>delay</code>, and the function will be called. We are using the <code>timer</code> variable both for the timeout and as a flag (“are we waiting?”).</p>
			<p>So far, we have learned how to wrap functions while keeping their original behavior or by altering them in some fashion. Now, let’s consider some other ways of modifying functions.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Changing functions in other ways</h1>
			<p>Let’s end this chapter <a id="_idIndexMarker471"/>by considering other sundry functions that provide results, such as new finders, decoupling methods from objects, and more. Our examples will include the following:</p>
			<ul>
				<li>Turning operations (such as adding with the <code>+</code> operator) into functions</li>
				<li>Turning functions into promises</li>
				<li>Accessing objects to get the value of a property</li>
				<li>Turning methods into functions</li>
				<li>A better way of finding optimum values</li>
			</ul>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Turning operations into functions</h2>
			<p>We have already <a id="_idIndexMarker472"/>seen several cases where we needed to write <a id="_idIndexMarker473"/>a function just to add or multiply a pair of numbers. For example, in the <em class="italic">Summing an array</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we had to write code equivalent to the following:</p>
			<pre class="source-code">
const mySum = myArray.reduce(
  (x: number, y: number): number =&gt; x + y,
  0
);</pre>
			<p>In the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we wrote this to calculate a factorial:</p>
			<pre class="source-code">
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce((x, y) =&gt; x * y, 1);</pre>
			<p>It would have been easier if we could just turn a binary operator into a function that calculates the same result. The preceding two examples could have been written more succinctly, as follows. Can you understand the change we made?</p>
			<pre class="source-code">
const mySum = myArray.reduce(<strong class="bold">binaryOp2("+")</strong>, 0);
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce(<strong class="bold">binaryOp2("*")</strong>, 1);</pre>
			<p>We haven’t <a id="_idIndexMarker474"/>looked at how <code>binaryOp()</code> is implemented yet, but the <a id="_idIndexMarker475"/>key notion is that instead of an infix operator (like we use when we write <code>22+9</code>), we now have a function (as if we could write our sum like <code>+(22,9)</code>, which certainly isn’t valid JavaScript). Let’s see how we can make this work.</p>
			<h3>Implementing operations</h3>
			<p>How would we <a id="_idIndexMarker476"/>write this <code>binaryOp()</code> function? There are at least two ways of doing so: a safe but long one and a riskier and shorter alternative. The first would require listing each possible operator. The following code does this by using a longish switch:</p>
			<pre class="source-code">
// binaryOp.ts
const binaryOp1 = (op: string) =&gt; {
  switch (op) {
    case "+":
      return (x: number, y: number): number =&gt; x + y;
    case "-":
      return (x: number, y: number): number =&gt; x - y;
    case "*":
      return (x: number, y: number): number =&gt; x * y;
    //
    // etc.
    //
    default:
      throw new Error(`Unknown ${op} operator`);
  }
};</pre>
			<p>This solution is perfectly fine but requires too much work. By the way, we should have separate <code>binaryMathOp()</code> and <code>binaryLogicalOp()</code> functions; the first would be <code>(op: string) =&gt; ((x: number, y: number) =&gt; number)</code> while the second would be <code>(op: string) =&gt; ((x: boolean, y: boolean) =&gt; boolean)</code> because, as in the previous section, TypeScript cannot deduce the type of the returned function.</p>
			<p>There’s a second solution, which is shorter but more dangerous. Please consider this only as an example <a id="_idIndexMarker477"/>for learning purposes; using <code>eval()</code> isn’t recommended for security reasons! Our second version would use <code>Function()</code> to create a new function that uses the desired operator, as follows:</p>
			<pre class="source-code">
// continued...
const binaryOp2 = (op) =&gt;
  new Function("x", "y", `return x ${op} y;`);</pre>
			<p>Again, TypeScript cannot determine the type of the returned function because that will be determined only at runtime. So, we need to write the following:</p>
			<pre class="source-code">
// continued...
const binaryOp2 = (op: string) =&gt;
  new Function("x", "y", `return x ${op} y;`) <strong class="bold">as (</strong>
<strong class="bold">    x: number,</strong>
<strong class="bold">    y: number</strong>
<strong class="bold">  ) =&gt; number</strong>;</pre>
			<p>We don’t have to specify the type of <code>binaryOp2()</code> because TypeScript can work it out to be <code>(o: string) =&gt; (x: number, y: number) =&gt; number</code> by itself, given the cast that we applied to the result.</p>
			<p class="callout-heading">The (easier) way out</p>
			<p class="callout">Some libraries, such as Lodash, already provide functions such as <code>_.multiply()</code> and  <code>_.sum()</code>, so that’s a more straightforward solution! You could quickly whip up your own and create your own mini-library of mathematical and logical essential functions.</p>
			<p>If you follow this <a id="_idIndexMarker478"/>train of thought, you may also define a <code>unaryOp()</code> function, even though there are fewer applications for it. (I leave this implementation to you; it’s similar to what we already wrote.) In <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, we will look at an alternative way of creating this unary function by using a partial application.</p>
			<h3>A handier implementation</h3>
			<p>Let’s get ahead of <a id="_idIndexMarker479"/>ourselves. Doing FP doesn’t always mean getting down to the simplest possible functions. For example, in an upcoming section of this book, we will need a function to check whether a number is negative, and we’ll consider (see the <em class="italic">Converting to pointfree style</em> section of <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a><em class="italic">, Connecting Functions</em>) using <code>binaryOp2()</code> to write it:</p>
			<pre class="source-code">
const isNegative = curry(binaryOp2("&gt;"))(0);</pre>
			<p>Don’t worry about the <code>curry()</code> function for now (we’ll get to it soon, in the following chapter) – the idea is that it fixes the first argument to <code>0</code> so that our function will check for a given <code>n</code> number if <code>0&gt;n</code>. The point is that the function we just wrote isn’t very clear. We could do better if we defined a binary operation function that lets us specify one of its parameters – the left or the right one – in addition to the operator to be used. Here, we can write the following couple of functions, which define the functions where the left or right operators are missing:</p>
			<pre class="source-code">
// continued...
const binaryLeftOp =
  (x: number, op: string) =&gt; (y: number) =&gt;
    binaryOp2(op)(x, y);
const binaryOpRight =
  (op: string, y: number) =&gt; (x: number) =&gt;
    binaryOp2(op)(x, y);</pre>
			<p>With these new functions, we could write either of the following two definitions, though I think the second is clearer. I’d rather test whether a number is less than <code>0</code> than whether <code>0</code> is greater than the number:</p>
			<pre class="source-code">
const isNegative1 = binaryLeftOp(<strong class="bold">0, "&gt;"</strong>);
const isNegative2 = binaryOpRight(<strong class="bold">"&lt;", 0</strong>);</pre>
			<p>What is the point of this? Don’t strive for some basic simplicity or go down to basics. We can transform an <a id="_idIndexMarker480"/>operator into a function, but if you can do better and simplify your coding by specifying one of the two parameters for the operation, just do it! The idea of FP is to help write better code, and creating artificial limitations won’t help anybody.</p>
			<p>Of course, for a simple function such as checking whether a number is negative, I would never want to complicate things with currying, binary operators, pointfree style, or anything else, and I’d write the following with no further ado:</p>
			<pre class="source-code">
const isNegative3 = (x: number): boolean =&gt; <strong class="bold">x &lt; 0</strong>;</pre>
			<p>So far, we have seen several ways of solving the same problem. Keep in mind that FP doesn’t force you to pick one way of doing things; instead, it allows you a lot of freedom in deciding which way to go!</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Turning functions into promises</h2>
			<p>In Node.js, most asynchronous functions require a callback such as <code>(err,data)=&gt;{...}</code>: if <code>err</code> is falsy, the function was successful, and <code>data</code> is its result; otherwise, the <a id="_idIndexMarker481"/>function failed, and <code>err</code> gives <a id="_idIndexMarker482"/>the cause. (See <a href="http://nodejs.org/api/errors.html#error-first-callbacks">nodejs.org/api/errors.html#error-first-callbacks</a> for more on this.)</p>
			<p>However, you might prefer to work with promises instead. So, we can think of writing an HOF that will transform a function that requires a callback into a promise that lets you use the <code>then()</code> and <code>catch()</code> methods. (In <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, we will see that promises are actually <em class="italic">monads</em>, so this transformation is interesting in yet another way.) This will be an exercise for some developers because Node.js (since version 8) already provides the <code>util.promisify()</code> function, which turns an <code>async</code> function into a promise. See <a href="http://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original">nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original</a> for more on that.</p>
			<p>So, how can we manage this? The transformation is relatively simple. Given a function, we produce a new one: this will return a promise that, upon calling the original function with some parameters, will either <code>reject()</code> or <code>resolve()</code> the promise appropriately.</p>
			<p>The <code>promisify()</code> function does <a id="_idIndexMarker483"/>precisely that. Its parameter is an <code>fn</code> function that returns <a id="_idIndexMarker484"/>either an <code>err</code> error of generic type <code>E</code>, or some <code>data</code> of <a id="_idIndexMarker485"/>generic type <code>D</code>. The arguments of <code>fn</code> may be any type, except that the last one must be a callback; this requires using <em class="italic">variadic</em> data types, available in TypeScript since version 4.0, from 2020:</p>
			<pre class="source-code">
// promisify.ts
const promisify =
  &lt;E, T extends any[], D&gt;(
    fn: (...args: [...T, (err: E, data: D) =&gt; void]) =&gt; void
  ) =&gt;
<strong class="bold">  (...args: T)</strong>: Promise&lt;D&gt; <strong class="bold">=&gt;</strong>
    <strong class="bold">new Promise((resolve, reject) =&gt;</strong>
<strong class="bold">      fn(...args, (err: E, data: D) =&gt;</strong>
<strong class="bold">        err ? reject(err) : resolve(data)</strong>
      )
    );</pre>
			<p>The given <code>fn</code> function is turned into a promise. The promise calls <code>fn</code> with a special callback: if that callback gets a non-null <code>err</code> value, the promise is rejected with that error; otherwise, the promise is resolved with <code>data</code>.</p>
			<p>When working in Node.js, the following style is fairly common:</p>
			<pre class="source-code">
const fs = require("fs");
const cb = (err, data) =&gt;
  err
    ? console.log("ERROR", err)
    : console.log("SUCCESS", data);
fs.readFile("./exists.txt", cb);       // success, data
fs.readFile("./doesnt_exist.txt", cb); // fail, exception</pre>
			<p>You can use promises instead by using our <code>promisify()</code> function – or in current versions of Node.js,
<code>util.promisify()</code> (but see the following, by the end of this section!):</p>
			<pre class="source-code">
const fspromise = <strong class="bold">promisify</strong>(fs.readFile.bind(fs));
const goodRead = (data) =&gt;
  console.log("SUCCESSFUL PROMISE", data);
const badRead = (err) =&gt;
  console.log("UNSUCCESSFUL PROMISE", err);
fspromise("./readme.txt")    // success
  .then(goodRead)
  .catch(badRead);
fspromise("./readmenot.txt") // failure
  .then(goodRead)
  .catch(badRead);</pre>
			<p>Now, you <a id="_idIndexMarker486"/>can use <code>fspromise()</code> instead of the original <a id="_idIndexMarker487"/>method. To do so, we had to bind <code>fs.readFile</code>, as we mentioned in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out </em><em class="italic">with Functions</em>.</p>
			<p>By the way, when using Node.js, be aware that many modules already provide a promise-based API in addition to the older callback-based API; for example, see <a href="http://nodejs.org/api/fs.html#promises-api">nodejs.org/api/fs.html#promises-api</a> and compare it to <a href="http://nodejs.org/api/fs.html#callback-api">nodejs.org/api/fs.html#callback-api</a>.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Getting a property from an object</h2>
			<p>There is a <a id="_idIndexMarker488"/>simple function that we could also <a id="_idIndexMarker489"/>produce. Extracting an attribute from an object is a <a id="_idIndexMarker490"/>commonly required operation. For example, in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we had to get latitudes and longitudes to calculate an average. The code for this was as follows:</p>
			<pre class="source-code">
// getField.ts
const markers = [
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  // ...
  { name: "BO", lat: -16.5, lon: -68.1 },
];
let averageLat = average(markers.map(x =&gt; x.lat));
let averageLon = average(markers.map(x =&gt; x.lon));</pre>
			<p>We saw another example when we learned how to filter an array; in our example, we wanted to get the IDs for all the accounts with a negative balance. After filtering out all other accounts, we still needed to extract the <code>id</code> field:</p>
			<pre class="source-code">
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);
const delinquentIds = delinquent.map((v) =&gt; v.id);</pre>
			<p>What do we <a id="_idIndexMarker491"/>need? We need an HOF that will receive the <a id="_idIndexMarker492"/>name of an attribute and produce a new function <a id="_idIndexMarker493"/>that can extract an attribute from an object. Using the arrow function syntax, this function is easy to write; <code>f</code> is the name of the field we want, and <code>obj</code> is the object from which to get the field:</p>
			<pre class="source-code">
// getField.ts
const getField = <strong class="bold">f =&gt; obj =&gt; obj[f]</strong>;</pre>
			<p>The full TypeScript version is a bit longer, but not much; mainly, we need to specify that <code>f</code> must be a key of the object:</p>
			<pre class="source-code">
// continued...
const getField = &lt;D&gt;(<strong class="bold">f: keyof D</strong>) =&gt; (<strong class="bold">obj: D</strong>) =&gt; <strong class="bold">obj[f]</strong>;</pre>
			<p>With this function, the coordinate extraction process could have been written as follows:</p>
			<pre class="source-code">
let averageLat = average(markers.map(getField("lat")));
let averageLon = average(markers.map(getField("lon")));</pre>
			<p>But that won’t be accepted! The issue is that TypeScript cannot detect the type of the result of the call to <code>getField()</code> because that will be decided at runtime. We must help by informing it that our two calls will return numbers. We can define the type of a generic number-returning function as <code>NumFn</code>, and then write the following:</p>
			<pre class="source-code">
type <strong class="bold">NumFn</strong> = (...args: any[]) =&gt; number;
const averageLat2 = average(
  markers.map(getField("lat") <strong class="bold">as NumFn</strong>)
);
const averageLon2 = average(
  markers.map(getField("lon") as NumFn)
);</pre>
			<p>For variety, we <a id="_idIndexMarker494"/>could have used an auxiliary variable <a id="_idIndexMarker495"/>to get the delinquent IDs and avoid using an <a id="_idIndexMarker496"/>extra type similar to <code>NumFn</code>, as follows:</p>
			<pre class="source-code">
const getId = getField("id") <strong class="bold">as (...args: any[]) =&gt; string</strong>;
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);
const delinquentIds = <strong class="bold">delinquent.map(getId)</strong>;</pre>
			<p>Make sure that you fully understand what’s going on here. The result of the <code>getField()</code> call is a function that will be used in further expressions. The <code>map()</code> method requires a mapping function and is what <code>getField()</code> produces.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Demethodizing – turning methods into functions</h2>
			<p>Methods <a id="_idIndexMarker497"/>such as <code>filter()</code> and <code>map()</code> are only available for arrays; however, you may want to apply them to, say, <code>NodeList</code> or <code>String</code>, and you’d be out of luck. Also, we are focusing on strings, so having to use these functions as methods is not exactly what we had in mind. Finally, whenever we create a new function (such as <code>none()</code>, which we saw in the <em class="italic">Checking negatives</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, Programming Declaratively</em>), it cannot be applied in the same way as its peers (<code>some()</code> and <code>every()</code>, in this case) unless you do some prototype trickery. This is rightly frowned upon and not recommended, but we’ll look into it anyhow; another case of “do as I say, not as I do!”</p>
			<p>Read the <em class="italic">Extending current data types</em> section of <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, where we will make <code>map()</code> available for most basic types.</p>
			<p>So, what can we do? We can apply the old saying <em class="italic">If the mountain won’t come to Muhammad, then Muhammad must go to the mountain</em>. Instead of worrying about not being able to create new methods, we will turn the existing methods into functions. We can do this if we convert each method into a function that will receive, as its first parameter, the object it will work on.</p>
			<p>Decoupling methods from objects can help you because once you achieve this separation, everything <a id="_idIndexMarker498"/>turns out to be a function, and your code will be simpler. (Remember what we wrote in the <em class="italic">Logically negating a function</em> section, regarding a possible <code>filterNot()</code> function in comparison to the <code>filter()</code> method?) A decoupled method works similarly to generic functions in other languages since they can be applied to diverse data types.</p>
			<p class="callout-heading">An important ABC: apply, bind, call</p>
			<p class="callout">Take a look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function</a> for explanations on <code>apply()</code>, <code>call()</code>, and <code>bind()</code>. We are going to use these for our implementation. Back in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>, we saw the equivalence between <code>apply()</code> and <code>call()</code> when we used the spread operator.</p>
			<p>There are three distinct but similar ways to implement this decoupling in JavaScript. The first argument in the list (<code>arg0</code>) will correspond to the object, and the other arguments (<code>...args</code>) to the actual ones for the called method. The three equivalent versions would be as follows, and <a id="_idIndexMarker499"/>any of them could be used as a <code>demethodize()</code> function; pick your favorite! Let’s go with a plain JavaScript version to understand how they work; see <em class="italic">Question 6.15</em> for TypeScript versions:</p>
			<pre class="source-code">
// demethodize.ts
const demethodize1 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.apply(arg0, args);
const demethodize2 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.call(arg0, ...args);
const demethodize3 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.bind(arg0, ...args)();</pre>
			<p class="callout-heading">A fourth way</p>
			<p class="callout">There’s yet another way of doing this: <code>const demethodize = Function.prototype.bind.bind(Function.prototype.call)</code>. If you want to understand how this works, read Leland Richardson’s <em class="italic">Clever Way to Demethodize Native JS Methods</em>, at <a href="http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods">www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods</a>.</p>
			<p>Let’s look at some applications of these! Let’s start with a simple one that will also serve as a warning. We <a id="_idIndexMarker500"/>can make the <code>sort()</code> method into a function – but don’t think it will be made pure!</p>
			<pre class="source-code">
const sort = demethodize1(Array.prototype.sort);
const a = ["delta", "alfa", "beta", "gamma", "epsilon"];
const b = <strong class="bold">sort(a)</strong>;
console.log(a, b);
// [ 'alfa', 'beta', 'delta', 'epsilon', 'gamma' ] twice!</pre>
			<p>Now we can use <code>sort()</code> as a function – but it still produces the same side effect; <code>a</code> and <code>b</code> are the same array since <code>sort()</code> keeps working “in place.”</p>
			<p>A more contrived case: we can use <code>map()</code> to loop over a string without converting it into an array of characters first. Say you wanted to separate a string into individual letters and make them uppercase; we could achieve this by using <code>split()</code> and <code>toUpperCase()</code>:</p>
			<pre class="source-code">
const name = "FUNCTIONAL";
const result = name.split("").map((x) =&gt; x.toUpperCase());
// ["F", "U", "N", "C", "T", "I", "O", "N", "A", "L"]</pre>
			<p>By demethodizing <code>map()</code> and <code>toUpperCase()</code>, we can simply write the following:</p>
			<pre class="source-code">
const map = <strong class="bold">demethodize1(Array.prototype.map)</strong>;
const toUpperCase = <strong class="bold">demethodize2(</strong>
<strong class="bold">  String.prototype.toUpperCase</strong>
<strong class="bold">)</strong>;
const result2 = <strong class="bold">map(name, toUpperCase)</strong>;
// ["F", "U", "N", "C", "T", "I", "O", "N", "A", "L"]</pre>
			<p>Yes, of course, for <a id="_idIndexMarker501"/>this particular case, we could have turned the string into uppercase and then split it into separate letters, as in <code>name.toUpperCase().split("")</code>, but it wouldn’t have been such a nice example, with two usages of demethodizing being used.</p>
			<p>Similarly, we could convert an array of decimal amounts into properly formatted strings with thousands separators and decimal points:</p>
			<pre class="source-code">
const toLocaleString = demethodize3(
  Number.prototype.toLocaleString
);
const numbers = [2209.6, 124.56, 1048576];
const strings = <strong class="bold">numbers.map(toLocaleString)</strong>;
console.log(strings);
/*
[ '2.209,6', '124,56', '1.048.576' ] // Uruguay Locale
*/</pre>
			<p>Alternatively, given the preceding demethodized <code>map()</code> function, we could have done the mapping with <code>map(numbers, </code><code>toLocaleString)</code> instead.</p>
			<p>The idea of demethodizing a method to turn it into a function will prove to be quite useful in diverse situations. <a id="_idIndexMarker502"/>We have already seen some examples where we could have applied it, and there will be more such cases in the rest of this book.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Methodizing – turning functions into methods</h2>
			<p>In the previous section, we saw how we could separate methods from objects to transform them <a id="_idIndexMarker503"/>into independent, standalone functions. Then, for fairness, let’s consider the complementary transformation, adding a function (as a method) to objects. We should call this operation <em class="italic">methodizing</em>, shouldn’t we?</p>
			<p>We already saw something of this when we defined and worked with polyfills in the <em class="italic">Adding missing functions</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions</em>. Modifying prototypes is usually frowned upon because of the possibility of clashes with different libraries, at the very least. However, it’s an interesting technique, so let’s study it anyway.</p>
			<h3>Reversing strings</h3>
			<p>Let’s start with a simple example. Back in the <em class="italic">Folding left and right</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively,</em> we defined a <code>reverseString()</code> function to reverse a string. Since we already have a <code>reverse()</code> method <a id="_idIndexMarker504"/>that works with arrays, we could implement a <code>reverse()</code> method for strings. For variety, let’s do a new implementation of the string-reversing logic. We’ll add a Boolean parameter; if set to <code>true</code>, the function will add dashes between letters; this is just to show that methodizing also works with functions with more parameters. What we want to achieve is the following:</p>
			<pre class="source-code">
"ABCDE".reverse();     // "EDCBA"
"ABCDE".reverse(true); // "E-D-C-B-A"</pre>
			<p>The needed function is as follows (as a curiosity, note that we are using the array <code>reverse()</code> method to implement our <code>reverse()</code> string one!):</p>
			<pre class="source-code">
// methodize.ts
function reverse(x: string, y = false): string {
  return x
    .split("")
    .reverse()
    .join(y ? "-" : "");
}</pre>
			<p>We used a standard function (instead of an arrow one) because of the implicit handling of <code>this</code>, which wouldn’t be bound otherwise. Another crucial detail: the first argument to the function must be the string with which it will operate.</p>
			<p>Now, we must tell TypeScript that we’ll be extending the <code>String.prototype</code> object with a <a id="_idIndexMarker505"/>new method (see <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html">www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html</a> for more on this):</p>
			<pre class="source-code">
// continued...
declare global {
  interface String {
    <strong class="bold">reverse(y?: boolean): string;</strong>
  }
}</pre>
			<p>Without this <a id="_idIndexMarker506"/>definition (which could also have been in a separate <code>.d.ts</code> file), when we try to assign the new method, we’ll get the error shown in <em class="italic">Figure 6</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/Figure_6.4_B19301.jpg" alt="Figure 6.4 – You cannot add new methods to an existing object without an extra definition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – You cannot add new methods to an existing object without an extra definition</p>
			<p>How do we add a new method to the <code>String.prototype</code> object? In essence, we want to achieve the following:</p>
			<pre class="source-code">
// continued...
<strong class="bold">String.prototype.reverse</strong> = function (
  this: string,
  y
): string {
  <strong class="bold">return reverse(this, y);</strong>
};</pre>
			<p>We add a function that calls our original one. Note that <code>this</code> (the current string object) is passed as the first argument. Other parameters are passed untouched. We can implement all this with a <code>methodize()</code> function; let’s see it first in JavaScript and then get into typing details. We want to do the following to achieve this:</p>
			<pre class="source-code">
// continued...
function <strong class="bold">methodize(obj, fn)</strong> {
<strong class="bold">  obj.prototype[fn.name] = function (...args) {</strong>
<strong class="bold">    return fn(this, ...args);</strong>
<strong class="bold">  };</strong>
}</pre>
			<p>This is what we <a id="_idIndexMarker507"/>did before. We are using the function’s name for the newly added method’s name. In TypeScript, this is a bit more complex, but we need the data type checks, so let’s do this:</p>
			<pre class="source-code">
function methodize&lt;
  T extends any[],
  O extends { prototype: { [key: string]: any } },
  F extends (arg0: any, ...args: T) =&gt; any
&gt;(obj: O, fn: F) {
  obj.prototype[fn.name] = function (
    <strong class="bold">this: Parameters&lt;F&gt;[0],</strong>
<strong class="bold">    ...args: T</strong>
  ): <strong class="bold">ReturnType&lt;F&gt;</strong> {
    return fn(this, ...args);
  };
}</pre>
			<p>Let’s see the data types we added:</p>
			<ul>
				<li><code>T</code> is the generic type of the parameters that we’ll pass to our new methodized function</li>
				<li><code>O</code> is the object’s type to whose prototype we’ll add the new method</li>
				<li><code>F</code> is the function we’ll be methodizing; the first argument (<code>arg0</code>) is key, and we’ll be assigned the value of <code>this</code>. The other arguments (if any) are of a <code>T</code> type</li>
			</ul>
			<p>How do we use this <code>methodize()</code> function? Simple, with just one line:</p>
			<pre class="source-code">
methodize(String, reverse);</pre>
			<p>With this, we <a id="_idIndexMarker508"/>can use our new method as planned:</p>
			<pre class="source-code">
console.log("MONTEVIDEO".reverse());
// OEDIVETNOM
console.log("MONTEVIDEO".reverse(true));
// O-E-D-I-V-E-T-N-O-M</pre>
			<h3>Averaging arrays</h3>
			<p>Let’s see one more <a id="_idIndexMarker509"/>example, to highlight a possible detail with typing. We’ll take the <code>average()</code> function that we wrote in the <em class="italic">Calculating an average</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, Programming Declaratively,</em> and add it to <code>Array.prototype</code>:</p>
			<pre class="source-code">
// continued...
function average(<strong class="bold">x: number[]</strong>): number {
  return (
    x.reduce((x: number, y: number) =&gt; x + y, 0) / x.length
  );
}</pre>
			<p>The problem is that we want our function to only apply to arrays of numbers. We want TypeScript to detect and reject a line such as the following because of the wrong data type of the array:</p>
			<pre class="source-code">
const xx = ["FK", "ST", "JA", "MV"].average();</pre>
			<p>When writing the global declaration for the added method, an error will pop up:</p>
			<pre class="source-code">
// methodize.ts
declare global {
 <strong class="bold"> // eslint-disable @typescript-eslint/no-unused-vars</strong>
<strong class="bold"> </strong> interface Array&lt;T&gt; {
<strong class="bold">    average(): number;</strong>
  }
}</pre>
			<p>The definition of <code>Array</code> must be bound to a generic <code>Array&lt;T&gt;</code>. However, our definition for <code>average()</code> doesn’t depend on <code>T</code>. This means we have an unused definition to which ESLint objects. Since there’s no way of including <code>T</code> in our function, we’ll have to tell ESLint to let the error be; no other solution!</p>
			<p>There’s nothing <a id="_idIndexMarker510"/>more to this; we can now methodize the <code>average()</code> function and use it as a method:</p>
			<pre class="source-code">
methodize(Array, average);
const myAvg = [22, 9, 60, 12, 4, 56]<strong class="bold">.average()</strong>; // 27.166667</pre>
			<p>You can now extend all base classes as desired – but remember our advice about being very, very careful!</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Finding the optimum</h2>
			<p>Let’s end this <a id="_idIndexMarker511"/>section by creating an extension of the <code>find()</code> method. Suppose <a id="_idIndexMarker512"/>we want to find the optimum value – let’s suppose it’s the maximum – of an array of numbers. We could make do with this:</p>
			<pre class="source-code">
// optimum.ts
const findOptimum = (arr: number[]): number =&gt;
  Math.max(...arr);
const myArray = [22, 9, 60, 12, 4, 56];
console.log(findOptimum(myArray)); // 60</pre>
			<p>Now, is this sufficiently general? There are at least a pair of problems with this approach. First, are you sure that the optimum of a set will always be the maximum? If you were considering several mortgages, the one with the lowest interest rate would be the best, right? To assume that you always want the maximum of a set is too constrictive.</p>
			<p class="callout-heading">A negative maximum?</p>
			<p class="callout">You could do a roundabout trick: if you change the signs of all the numbers in an array, find its maximum, and change its sign, you actually get the minimum of the array. In our case, <code>-findOptimum(myArray.map((x) =&gt; -x))</code> would correctly produce <code>4</code>, but it’s not easily understandable code.</p>
			<p>Second, this way of finding the maximum depends on each option having a numeric value. But how <a id="_idIndexMarker513"/>would you find the optimum if such a value didn’t exist? The <a id="_idIndexMarker514"/>usual way depends on comparing elements with each other and picking the one that comes out on top:</p>
			<ol>
				<li value="1">Compare the first element with the second and keep the best of those two.</li>
				<li>Then compare that value with the third element and keep the best.</li>
				<li>Keep at it until you have finished going through all the elements.</li>
			</ol>
			<p>The way to solve this problem with more generality is to assume the existence of a comparator function, which takes two elements as arguments and returns the best of those. If you could associate a numeric value with each element, the comparator function could simply compare those values. In other cases, it could do whatever logic is needed to decide what element comes out on top.</p>
			<p>Let’s try to create an appropriate HOF; our newer version will use <code>reduce()</code> as follows:</p>
			<pre class="source-code">
// continued...
const findOptimum2 =
  &lt;T&gt;(fn: (x: T, y: T) =&gt; T) =&gt;
  (arr: T[]): T =&gt;
    arr.reduce(fn);</pre>
			<p>This generic function takes a comparator that returns the best of two elements of a <code>T</code> type and then applies that function to an array of elements of a <code>T</code> type to produce the optimum.</p>
			<p>With this, we can easily replicate the maximum- and minimum-finding functions; we only have to provide the appropriate reducing functions:</p>
			<pre class="source-code">
const <strong class="bold">findMaximum</strong> = findOptimum2(
  (x: number, y: number): number =&gt; <strong class="bold">(x &gt; y ? x : y)</strong>
);
const <strong class="bold">findMinimum</strong> = findOptimum2(
  (x: number, y: number): number =&gt; <strong class="bold">(x &lt; y ? x : y)</strong>
);
console.log(findMaximum(myArray)); // 60
console.log(findMinimum(myArray)); // 4</pre>
			<p>Let’s go one better <a id="_idIndexMarker515"/>and compare non-numeric values. Let’s imagine a <a id="_idIndexMarker516"/>superhero card game: each card represents a hero and has several numeric attributes, such as <code>strength</code>, <code>powers</code>, and <code>tech</code>. The corresponding class could be the following:</p>
			<pre class="source-code">
class Card {
  name: string;
  strength: number;
  powers: number;
  tech: number;
  constructor(n: string, s: number, p: number, t: number) {
    this.name = n;
    this.strength = s;
    this.powers = p;
    this.tech = t;
  }
}</pre>
			<p>When two heroes fight each other, the winner is the one with more categories with higher values than the other. Let’s implement a comparator for this; a suitable <code>compareHeroes()</code> function could be as follows:</p>
			<pre class="source-code">
const compareHeroes = (card1: Card, card2: Card): Card =&gt; {
  const oneIfBigger = (x: number, y: number): number =&gt;
    x &gt; y ? 1 : 0;
  const wins1 =
    oneIfBigger(card1.strength, card2.strength) +
    oneIfBigger(card1.powers, card2.powers) +
    oneIfBigger(card1.tech, card2.tech);
  const wins2 =
    oneIfBigger(card2.strength, card1.strength) +
    oneIfBigger(card2.powers, card1.powers) +
    oneIfBigger(card2.tech, card1.tech);
  return wins1 &gt; wins2 ? card1 : card2;
};</pre>
			<p>Then, we can apply <a id="_idIndexMarker517"/>this to our tournament of heroes. First, let’s create <a id="_idIndexMarker518"/>our own league of heroes:</p>
			<pre class="source-code">
const codingLeagueOfAmerica = [
  new Card("Forceful", 20, 15, 2),
  new Card("Electrico", 12, 21, 8),
  new Card("Speediest", 8, 11, 4),
  new Card("TechWiz", 6, 16, 30),
];</pre>
			<p>With these definitions, we can write a <code>findBestHero()</code> function to get the top hero:</p>
			<pre class="source-code">
const findBestHero = findOptimum2(compareHeroes);
console.log(findBestHero(codingLeagueOfAmerica));
// Electrico is the top Card!</pre>
			<p class="callout-heading">Order does matter</p>
			<p class="callout">When you rank elements according to one-to-one comparisons, unexpected results may be produced. For instance, with our superheroes comparison rules, you could find three heroes where the results show that the first beats the second, the second beats the third, but the third beats the first! In mathematical terms, the comparison function is <em class="italic">not transitive</em>, and you don’t have a <em class="italic">total ordering</em> for the set.</p>
			<p>With this, we have seen several ways of modifying functions to produce newer variants with enhanced processing; think of particular cases you might be facing and consider whether an HOF might help you out.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
			<p>In this chapter, we learned how to write HOFs of our own that can either wrap another function to provide some new feature, alter a function’s objective so that it does something else, or even provide totally new features, such as decoupling methods from objects or creating better finders. The main takeaway from this chapter is that you have a way of modifying a function’s behavior without actually having to modify its own code; HOFs can manage this in an orderly way.</p>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, we’ll keep working with HOFs and learn how to produce specialized versions of existing functions with predefined arguments by using currying and partial application.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Questions</h1>
			<p>6.1 <code>addLogging()</code> using a function, and its typing was not simple. Just to deal with a different syntax, can you provide an alternate implementation of <code>addLogging()</code> but using an arrow function?</p>
			<p>6.2 <strong class="bold">Mapping for memory</strong>: We implemented our memoizing functions by using an object as a cache. However, using a map would be better; make the necessary changes.</p>
			<p>6.3 <code>fib(50)</code> without memoizing? For example, one call and no further recursion were needed to calculate <code>fib(0)</code> or <code>fib(1)</code>, and 25 calls were required for <code>fib(6)</code>. Can you find a formula to do this calculation?</p>
			<p>6.4 <code>randomizer(fn1, fn2, ...)</code>, that will receive a variable number of functions as arguments and return a new function that will, on each call, randomly call one of <code>fn1</code>, <code>fn2</code>, and so on. You could use this to balance calls to different services on a server if each function did an AJAX call. For bonus points, ensure that no function will be called twice in a row.</p>
			<p>6.5 <code>not()</code> and <code>invert()</code> functions.</p>
			<p>6.6 <code>not()</code> function that worked with Boolean functions and a <code>negate()</code> function that worked with numerical ones. Can you go one better and write a single <code>opposite()</code> function that will behave as <code>not()</code> or <code>negate()</code>, as needed?</p>
			<p>6.7 <code>invert()</code>, as suggested.</p>
			<p>6.8 <code>filterNot()</code> function with a slight change, as shown here, TypeScript will object; why?</p>
			<pre class="source-code">
const filterNot2 =
  &lt;A, T extends (x: A) =&gt; boolean&gt;(arr: A[]) =&gt;
  (fn: T): A[] =&gt;
    arr.filter(<strong class="bold">not(fn)</strong>);</pre>
			<p>6.9 <code>arity()</code> function works well, but the produced functions don’t have the correct <code>length</code> attribute. Can you write a different arity-changing function without this defect?</p>
			<p>6.10 <code>binary()</code> and <code>ternary()</code>?</p>
			<p>6.11 <code>async</code> function, every time you call it with the same arguments, you’ll get the same promise as a result. But imagine we were calling a weather API, which updates its data every 5 minutes. We don’t want to call it just once and never again (as with memoization), but we don’t want to call it every time either. Can you add throttling behavior to our <code>promiseMemoize()</code> function so, after a given delay, a new call to the API will be made?</p>
			<p>6.12 <code>binaryOp()</code> function that would work with numbers, what is the list of all the operators you should consider?</p>
			<p>6.13 <code>getField()</code> function, we should also have a <code>setField()</code> function, so can you define it? We’ll need both in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, when we work with getters, setters, and lenses. Note that <code>setField()</code> shouldn’t directly modify an object; instead, it should return a new object with a changed value – it should be a pure function!</p>
			<p>6.14 <code>getField()</code> function if we apply it to a null object? What should its behavior be? If necessary, modify the function. This question has different answers in JavaScript and TypeScript; be careful!</p>
			<p>6.15 <code>demethodize()</code> functions. A tip: once you get one of them right, the other two will be pretty similar!</p>
			<p>6.16 <code>findMaximum()</code> and <code>findMinimum()</code>, we wrote our own functions to compare two values – but JavaScript already provides appropriate functions for that! Can you figure out alternative versions of our code based on that hint?</p>
			<p>6.17 <code>const wins2 = 3 – wins1</code> in our <code>compareHeroes()</code> function? Wouldn’t that have been faster? Or even better: avoid calculating <code>wins2</code> at all, and change the final line to <code>return wins1 &gt;= </code><code>2</code>?</p>
		</div>
	</body></html>