<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-108" class="chapter-number"><a id="_idTextAnchor107"/>6</h1>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Producing Functions – Higher-Order Functions</h1>
			<p>In <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we worked with some declarative code so that we could gain understandability and more compact, shorter code. In this chapter, we will go further toward <strong class="bold">higher-order functions</strong> (<strong class="bold">HOFs</strong>) and develop our own. We <a id="_idIndexMarker398"/>can roughly classify the results that we are going to get into <span class="No-Break">three groups:</span></p>
			<ul>
				<li><strong class="bold">Wrapped functions</strong>: These keep their original functionality while adding some kind of <a id="_idIndexMarker399"/>new feature. In this group, we can consider logging (adding log production capacity to any function), timing (producing time and performance data for a given function), and memoization of functions and promises (caching results to avoid <span class="No-Break">future rework).</span></li>
				<li><strong class="bold">Altered functions</strong>: These differ in some key points from their original versions. Here, we can include the <strong class="source-inline">once()</strong> function (we covered this in <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>), which changes the original function <a id="_idIndexMarker400"/>so that it only runs once; functions such as <strong class="source-inline">not()</strong> or <strong class="source-inline">invert()</strong>, which alter what the function returns; arity-related conversions, which produce a new function with a fixed number of parameters; and throttling and debouncing functions <span class="No-Break">for performance.</span></li>
				<li><strong class="bold">Other productions</strong>: These provide new operations, turn functions into promises, allow enhanced search functions, decouple methods from objects, transform them into plain functions, and go the other way around, converting functions into methods. We shall leave a special case – <em class="italic">transducers</em> – for <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <span class="No-Break"><em class="italic">Connecting Functions</em></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Wrapping functions – keeping behavior</h1>
			<p>In this section, we’ll consider some HOFs that provide a wrapper around other functions to enhance them in <a id="_idIndexMarker401"/>some way but without altering their original objective. In terms of design patterns (which we’ll be revisiting in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing Design Patterns</em>), we can also speak of <strong class="bold">decorators</strong>. This pattern is based on the concept <a id="_idIndexMarker402"/>of adding some behavior to an object (in our case, a function) without affecting other objects. The term decorator is also popular because of its usage in frameworks, such as Angular, or (in an experimental mode) for general programming <span class="No-Break">in JavaScript.</span></p>
			<p class="callout-heading">Waiting for decorators</p>
			<p class="callout">Decorators are being considered for general adoption in JavaScript. Currently (as of December 2022), they are <a id="_idIndexMarker403"/>at Stage 3, Candidate level, so it may still be a while until they get to Stage 4 (Finished, meaning “officially adopted”). You can read more about the proposal for decorators at <a href="http://tc39.github.io/proposal-decorators/">tc39.github.io/proposal-decorators/</a> and about the JavaScript adoption process, called TC39, at <a href="http://tc39.es/process-document/">tc39.es/process-document/</a>. See the <em class="italic">Questions</em> section in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic">, Implementing Design Patterns,</em> for <span class="No-Break">more information.</span></p>
			<p>As for the term <em class="italic">wrapper</em>, it’s more important and pervasive than you might have thought; in fact, JavaScript <a id="_idIndexMarker404"/>uses it widely. Where? You already know that object properties and methods are accessed through dot notation. However, you also know that you can write code such as <strong class="source-inline">myString.length</strong> or <strong class="source-inline">22.9.toPrecision(5)</strong>, so where are those properties and methods coming from, given that neither strings nor numbers are objects? JavaScript actually creates a <em class="italic">wrapper object</em> around <a id="_idIndexMarker405"/>your primitive value. This object inherits all the methods that are appropriate to the wrapped value. As soon as the needed evaluation has been done, JavaScript throws away the just-created wrapper. We cannot do anything about these transient wrappers, but there is a concept we will come back to regarding a wrapper that allows methods to be called on things that are not of the appropriate type. This is an interesting idea; see <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, for more applications <span class="No-Break">of that!</span></p>
			<p>In this section, we’ll look at <span class="No-Break">three examples:</span></p>
			<ul>
				<li>Adding logging to <span class="No-Break">a function</span></li>
				<li>Getting timing information <span class="No-Break">from functions</span></li>
				<li>Using caching (<em class="italic">memoizing</em>) to improve the performance <span class="No-Break">of functions</span></li>
			</ul>
			<p>Let’s get <span class="No-Break">to work!</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Logging</h2>
			<p>Let’s start with a common problem. When debugging code, you usually need to add some logging information <a id="_idIndexMarker406"/>to see whether a function was called, with what arguments, what it returned, and so on. (Yes, of course, you can simply use a debugger and set breakpoints, but bear with me for this example!) Working normally, this means that you’ll have to modify the code of the function itself, both at entry and on exit, to produce some logging output. For example, your original code could be something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
function someFunction(param1, param2, param3) {
  // do something
  // do something else
  // and a bit more,
  // and finally
  return some expression;
}</pre>
			<p>In this case, you would have to modify it to look like the following. Here, we need to add an <strong class="source-inline">auxValue</strong> variable to store the value that we want to log <span class="No-Break">and return:</span></p>
			<pre class="source-code">
function someFunction(param1, param2, param3) {
  <strong class="bold">console.log(</strong>
<strong class="bold">    "entering someFunction: ",</strong>
<strong class="bold">    param1,</strong>
<strong class="bold">    param2,</strong>
<strong class="bold">    param3</strong>
<strong class="bold">  );</strong>
  // do something
  // do something else
  // and a bit more,
  // and finally
<strong class="bold">  const auxValue = ...some expression... ;</strong>
<strong class="bold">  console.log("exiting someFunction: ", auxValue);</strong>
<strong class="bold">  return auxValue;</strong>
}</pre>
			<p>If the function can return at several places, you’ll have to modify all the <strong class="source-inline">return</strong> statements to log the <a id="_idIndexMarker407"/>values to be returned. And if you are just calculating the return expression on the fly, you’ll need an auxiliary variable to capture <span class="No-Break">that value.</span></p>
			<p>In the next section, we’ll learn about logging and some special cases, such as functions that throw exceptions, and we’ll work <span class="No-Break">more purely.</span></p>
			<h3>Logging in a functional way</h3>
			<p>Logging by modifying your functions isn’t difficult, but modifying code is always dangerous and prone <a id="_idIndexMarker408"/>to accidents. So, let’s put our FP hats on and think of a new way of doing this. We have a function that performs some work, and we want to know the arguments it receives and the value <span class="No-Break">it returns.</span></p>
			<p>Here, we can write an HOF that will have a single parameter – the original function – and return a new function that will do the following <span class="No-Break">in sequence:</span></p>
			<ol>
				<li>Log the <span class="No-Break">received arguments.</span></li>
				<li>Call the original function, catching its <span class="No-Break">returned value.</span></li>
				<li>Log <span class="No-Break">that value.</span></li>
				<li>Return it to <span class="No-Break">the caller.</span></li>
			</ol>
			<p>A possible solution would be as follows, and let’s use plain JavaScript first to focus on <span class="No-Break">the implementation:</span></p>
			<pre class="source-code">
// logging.ts
function addLogging(fn) {
  return (...args) =&gt; {
<strong class="bold">    console.log(`entering ${fn.name}(${args})`);</strong>
<strong class="bold">    const valueToReturn = fn(...args);</strong>
<strong class="bold">    console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);</strong>
<strong class="bold">    return valueToReturn;</strong>
  };
}</pre>
			<p>The function returned by <strong class="source-inline">addLogging()</strong> behaves <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The first <strong class="source-inline">console.log(...)</strong> line shows the original function’s name and its list <span class="No-Break">of arguments.</span></li>
				<li>Then, the original function, <strong class="source-inline">fn()</strong>, is called, and the returned value is stored. The second <strong class="source-inline">console.log(...)</strong> line shows the function name (again) and its <span class="No-Break">returned value.</span></li>
				<li>Finally, the value that <strong class="source-inline">fn()</strong> calculated <span class="No-Break">is returned.</span></li>
			</ul>
			<p>A small comment: If you <a id="_idIndexMarker409"/>were doing this for a Node.js application, you would probably opt for a better way of logging than <strong class="source-inline">console.log()</strong> by using libraries such as <em class="italic">Winston</em>, <em class="italic">Morgan</em>, or <em class="italic">Bunyan</em>, depending on what you wanted to log. However, our focus is on how to wrap the original function, and the needed changes for using those libraries would <span class="No-Break">be negligible.</span></p>
			<p>Let’s turn to a TypeScript <span class="No-Break">implementation now:</span></p>
			<pre class="source-code">
// continued...
function addLogging<strong class="bold">&lt;T extends (...args: any[]) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">(...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;</strong> {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
    const valueToReturn = fn(...args);
    console.log(`exiting  ${fn.name} =&gt; ${valueToReturn}`);
    return valueToReturn;
  };
}</pre>
			<p>Our <strong class="source-inline">addLogging()</strong> function applies to a generic function <strong class="source-inline">T</strong> type and returns a new function of precisely the same type: its arguments (<strong class="source-inline">Parameters&lt;T&gt;</strong>) are those of <strong class="source-inline">T</strong>, and its result (<strong class="source-inline">ReturnType&lt;T&gt;</strong>) is also the same type as <strong class="source-inline">T</strong>’s. We will be using this kind of definition many times in this chapter and the rest of <span class="No-Break">the book.</span></p>
			<p>Let’s have an example now. We can use <strong class="source-inline">addLogging()</strong> with the upcoming functions—which are written, I agree, in an overly complicated way, just to have an appropriate example! We’ll have a function that accomplishes subtraction by changing the sign of the second number and then adding it to the first. And, just to have an error case, we’ll have the function throw an error if we attempt to subtract zero. (Yes, of course, you can subtract zero <a id="_idIndexMarker410"/>from another number! But I wanted to have some kind of an error-throwing situation at any cost!) The following code <span class="No-Break">does this:</span></p>
			<pre class="source-code">
// continued...
function subtract(a: number, b: number): number {
  if (b === 0) {
    throw new Error("We don't subtract zero!");
  } else {
    b = changeSign(b);
    return a + b;
  }
}
let changeSign = (a: number): number =&gt; -a;
// @ts-expect-error We want to reassign the function
subtract = addLogging(subtract);
subtract(8, 3);
console.log(); // to separate
changeSign = addLogging(changeSign);
subtract(7, 5);</pre>
			<p>What’s that <strong class="source-inline">@ts-expect-error</strong> comment? TypeScript rejects the assignment in the following line, saying <strong class="source-inline">Cannot assign to 'subtract' because it is a function.ts(2630)</strong>. This prohibition keeps code safe, but since we are very sure that we won’t be changing the <strong class="source-inline">subtract()</strong> type, we can include the comment, and TypeScript will let us get away <span class="No-Break">with it.</span></p>
			<p>The result of executing this would be the following lines <span class="No-Break">of logging:</span></p>
			<pre class="source-code">
entering subtract(8,3)
exiting  subtract =&gt; 5
entering subtract(7,5)
entering changeSign(5)
exiting  changeSign =&gt; -5
exiting  subtract =&gt; 2</pre>
			<p>All the changes we had to make in our code were the reassignments of <strong class="source-inline">subtract()</strong> and <strong class="source-inline">changeSign()</strong>, which <a id="_idIndexMarker411"/>essentially replaced them everywhere with their new log-producing wrapped versions. Any call to those two functions will produce <span class="No-Break">this output.</span></p>
			<p>This works fine for most functions, but what would happen if the wrapped function threw an exception? Let’s take <span class="No-Break">a look.</span></p>
			<h3>Taking exceptions into account</h3>
			<p>Let’s enhance our logging function a bit by considering an adjustment. What happens to your log if the function <a id="_idIndexMarker412"/>throws an error? Fortunately, this is easy to solve. We have to add a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> structure, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
function addLogging2&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    console.log(`entering ${fn.name}(${args})`);
 <strong class="bold">   try {</strong>
      <strong class="bold">const valueToReturn = fn(...args);</strong>
      console.log(`exiting  ${fn.name}=&gt;${valueToReturn}`);
      return valueToReturn;
    } <strong class="bold">catch (thrownError)</strong> {
<strong class="bold">      console.log(</strong>
<strong class="bold">        `exiting  ${fn.name}=&gt;threw ${thrownError}`</strong>
<strong class="bold">      );</strong>
     <strong class="bold"> throw thrownError;</strong>
    }
  };
}</pre>
			<p>With this change, if the function threw an error, you’d also get an appropriate logging message, and the exception would be rethrown for processing. The following is a quick demo <span class="No-Break">of this:</span></p>
			<pre class="source-code">
try {
<strong class="bold">  subtract2(11, 0);</strong>
} catch (e) {
  /* nothing */
}
/*
<strong class="bold">entering subtract(11,0)</strong>
<strong class="bold">exiting  subtract=&gt;threw Error: We don't subtract zero!</strong>
*/</pre>
			<p>Other changes to get <a id="_idIndexMarker413"/>an even better logging output would be up to you – adding date and time data, enhancing the way parameters are listed, and so on. However, our implementation still has an important defect; let’s make it better <span class="No-Break">and purer.</span></p>
			<h3>Working in a purer way</h3>
			<p>When we wrote the <strong class="source-inline">addLogging()</strong> function, we ignored some precepts we saw in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, because we included an impure element (<strong class="source-inline">console.log()</strong>) in our code. With this, not only did we lose flexibility (would you be able to <a id="_idIndexMarker414"/>select an alternate way of logging?), but we also complicated our testing. We could manage to test it by spying on the <strong class="source-inline">console.log()</strong> method, but that isn’t very clean: we depend on knowing the internals of the function we want to test instead of doing a purely black-box test. Take a look at the following example for a clearer understanding <span class="No-Break">of this:</span></p>
			<pre class="source-code">
// logging.test.ts
import { addLogging2 } from "./logging";
describe("a logging function", function () {
  afterEach(() =&gt; {
    // so count of calls to Math.random will be OK
    jest.restoreAllMocks();
  });
  it("should log twice with well behaved functions", () =&gt; {
<strong class="bold">    jest.spyOn(global.console, "log");</strong>
    let something = (a: number, b: number): string =&gt;
      `result=${a}:${b}`;
    something = addLogging2(something);
    something(22, 9);
<strong class="bold">    expect(global.console.log).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering something(22,9)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  something=&gt;result=22:9"</strong>
<strong class="bold">    );</strong>
  });
  it("should report a thrown exception", () =&gt; {
    jest.spyOn(global.console, "log");
    let subtractZero = (x: number) =&gt; subtract(x, 0);
    subtractZero = addLogging2(subtractZero);
<strong class="bold">    expect(() =&gt; subtractZero(10)).toThrow();</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering subtractZero(10)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(global.console.log).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  subtractZero=&gt;threw Error: We don't subtract zero!"</strong>
<strong class="bold">    );</strong>
  });
  });
});</pre>
			<p>Running this test <a id="_idIndexMarker415"/>shows that <strong class="source-inline">addLogging()</strong> behaves as expected, so this is a solution. Our first test just does a simple subtraction and verifies that logging was called with appropriate data. The second test checks that our (purposefully failing) <strong class="source-inline">subtract()</strong> function throws an error to also verify that the correct logs <span class="No-Break">were produced.</span></p>
			<p>Even so, being able to test our function this way doesn’t solve the lack of flexibility we mentioned. We should pay attention to what we wrote in the <em class="italic">Injecting impure functions</em> section in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Behaving Properly</em>; the logging function should be passed as an argument to the wrapper <a id="_idIndexMarker416"/>function so that we can change it if we <span class="No-Break">need to:</span></p>
			<pre class="source-code">
// logging3.ts
function addLogging3&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T,
  <strong class="bold">logger = console.log.bind(console)</strong>
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    <strong class="bold">logger(`entering ${fn.name}(${args})`)</strong>;
    try {
      const valueToReturn = fn(...args);
      <strong class="bold">logger(`exiting  ${fn.name}=&gt;${valueToReturn}`)</strong>;
      return valueToReturn;
    } catch (thrownError) {
      <strong class="bold">logger(`exiting  ${fn.name}=&gt;threw ${thrownError}`)</strong>;
      throw thrownError;
    }
  };
}</pre>
			<p>If we don’t do anything, the logging wrapper will produce the same results as in the previous section. However, we could provide a different logger – for example, with Node.js, we <a id="_idIndexMarker417"/>could use the <em class="italic">winston</em> logging tool (see <a href="http://github.com/winstonjs/winston">github.com/winstonjs/winston</a> for more on it), and the results would <span class="No-Break">vary accordingly:</span></p>
			<pre class="source-code">
// continued...
function subtract(...) { ... }
let changeSign = ... ;
// @ts-expect-error We want to reassign the function
<strong class="bold">subtract = addLogging3(subtract, myLogger);</strong>
subtract(8, 3);
console.log(); // to separate
<strong class="bold">changeSign = addLogging3(changeSign, myLogger);</strong>
subtract(7, 5);
/*
{"level":"debug","message":"entering subtract(8,3)"}
{"level":"debug","message":"exiting  subtract=&gt;5"}
{"level":"debug","message":"entering subtract(7,5)"}
{"level":"debug","message":"entering changeSign(5)"}
{"level":"debug","message":"exiting  changeSign=&gt;-5"}
{"level":"debug","message":"exiting  subtract=&gt;2"}
*/</pre>
			<p>The log format is JSON by default. It’s more usual to route it to a file for storage, so it isn’t so clear as console output, but we could (if needed) reformat it more legibly. However, this suffices for our example, and we won’t do <span class="No-Break">anything else.</span></p>
			<p>Now that we have followed our own advice, we can take advantage of stubs. The code for testing is practically <a id="_idIndexMarker418"/>the same as before; however, we are using a <strong class="source-inline">dummy.logger()</strong> stub with no provided functionality or side effects, so it’s safer all around. In this case, the real function that was being invoked originally, <strong class="source-inline">console.log()</strong>, can’t do any harm, but that’s not always the case, so using a stub <span class="No-Break">is recommended:</span></p>
			<pre class="source-code">
// logging3.test.ts
import { addLogging3 } from "./logging3";
describe("addLogging3()", function () {
  it("should call the provided logger", () =&gt; {
<strong class="bold">    const logger = jest.fn();</strong>
    let something = (a: number, b: number): string =&gt;
      `result=${a}:${b}`;
    something = addLogging3(something, <strong class="bold">logger</strong>);
    something(22, 9);
<strong class="bold">    expect(logger).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">    expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      1,</strong>
<strong class="bold">      "entering something(22,9)"</strong>
<strong class="bold">    );</strong>
<strong class="bold">    expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">      2,</strong>
<strong class="bold">      "exiting  something=&gt;result=22:9"</strong>
<strong class="bold">    );</strong>
  });
  it("a throwing function should be reported", () =&gt; {
    const logger = jest.fn();
    let thrower = () =&gt; {
      throw "CRASH!";
    };
    thrower = addLogging3(thrower, logger);
<strong class="bold">    try {</strong>
<strong class="bold">      thrower();</strong>
<strong class="bold">    } catch (e) {</strong>
<strong class="bold">      expect(logger).toHaveBeenCalledTimes(2);</strong>
<strong class="bold">      expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">        1,</strong>
<strong class="bold">        "entering thrower()"</strong>
<strong class="bold">      );</strong>
<strong class="bold">      expect(logger).toHaveBeenNthCalledWith(</strong>
<strong class="bold">        2,</strong>
<strong class="bold">        "exiting  thrower=&gt;threw CRASH!"</strong>
<strong class="bold">      );</strong>
<strong class="bold">    }</strong>
  });
});</pre>
			<p>The preceding tests work exactly <a id="_idIndexMarker419"/>like the previous ones we wrote earlier (though, for variety, in the <em class="italic">Working in a purer way</em> section, we used <strong class="source-inline">expect(…).toThrow()</strong>, and here we used a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> structure to test error-throwing functions). We used and inspected the dummy logger instead of dealing with the original <strong class="source-inline">console.log()</strong> calls. Writing the test in this way avoids all possible problems due to side effects, so it’s much cleaner <span class="No-Break">and safer.</span></p>
			<p>When applying FP techniques, remember that if you are somehow complicating your job – for example, making it difficult to test any of your functions – then you must be doing something wrong. In our case, the mere fact that the output of <strong class="source-inline">addLogging()</strong> was an impure function should <a id="_idIndexMarker420"/>have raised the alarm. Of course, given the simplicity of the code, in this particular case, you might decide that it’s not worth a fix, that you can do without testing, and that you don’t need to be able to change the way logging is produced. However, long experience in software development suggests that, sooner or later, you’ll come to regret that sort of decision, so try to go with the cleaner <span class="No-Break">solution instead.</span></p>
			<p>Now that we have dealt with logging, we’ll look at another need: timing functions for <span class="No-Break">performance reasons.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Timing functions</h2>
			<p>Another possible application for wrapped functions is to record and log the timing of each function <a id="_idIndexMarker421"/>invocation in a fully transparent way. Simply put, we want to be able to tell how long a function call takes, most likely for performance studies. However, in the same way we dealt with logging, we don’t want to have to modify the original function and will use an <span class="No-Break">HOF instead.</span></p>
			<p class="callout-heading">The three rules for optimization</p>
			<p class="callout">If you plan to optimize your code, remember the following three rules: <em class="italic">Don’t do it</em>, <em class="italic">Don’t do it yet</em>, and <em class="italic">Don’t do it without measuring</em>. It has been mentioned that a lot of bad code arises from early attempts at optimization, so don’t start by trying to write optimal code, don’t try to optimize until you recognize the need for it, and don’t do it haphazardly without trying to determine the reasons for the slowdown by measuring all the parts of <span class="No-Break">your application.</span></p>
			<p>Along the lines of the preceding example, we can write an <strong class="source-inline">addTiming()</strong> function that, given any function, will produce a wrapped version that will write out timing data on the console but will otherwise work in exactly the same way. Data types are very much what we saw in the previous section, so let’s write TypeScript <span class="No-Break">at once:</span></p>
			<pre class="source-code">
const myGet = (): number =&gt; performance.now();
const myPut = (
  text: string,
  name: string,
  tStart: number,
  tEnd: number
): void =&gt;
  console.log(`${name} - ${text} ${tEnd - tStart} ms`);
function addTiming&lt;T extends (...args: any[]) =&gt; any&gt;(
  fn: T,
  { getTime, output } = {
    getTime: myGet,
    output: myPut,
  }
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  return (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    const tStart = getTime();</strong>
    try {
      const valueToReturn = fn(...args);
      <strong class="bold">output("normal exit", fn.name, tStart, getTime());</strong>
      return valueToReturn;
    } catch (thrownError) {
      <strong class="bold">output("exception!!", fn.name, tStart, getTime());</strong>
      throw thrownError;
    }
  };
}</pre>
			<p>Along the lines <a id="_idIndexMarker422"/>of the enhancement we applied in the previous section to the logging function, we are providing separate logger and time access functions. Writing tests for our <strong class="source-inline">addTiming()</strong> function should prove easy, given that we can inject both <span class="No-Break">impure functions.</span></p>
			<p>We can see how this <span class="No-Break">works here:</span></p>
			<pre class="source-code">
// continued...
function subtract(...) { ... }
let changeSign = ... ;
// @ts-expect-error We want to reassign the function
<strong class="bold">subtract = addTiming(subtract, myLogger);</strong>
subtract(8, 3);
console.log(); // to separate
<strong class="bold">changeSign = addTiming(changeSign, myLogger);</strong>
subtract(7, 5);
/*
subtract - normal exit 0.0217440128326416 ms
changeSign - normal exit 0.0014679431915283203 ms
subtract - normal exit 0.0415341854095459 ms
*/</pre>
			<p class="callout-heading">Accuracy matters</p>
			<p class="callout">Using <strong class="source-inline">performance.now()</strong> provides the highest accuracy. If you don’t need such precision as what’s <a id="_idIndexMarker423"/>provided by that function (arguably, it is overkill), you <a id="_idIndexMarker424"/>could use <strong class="source-inline">Date.now()</strong> instead. For <a id="_idIndexMarker425"/>more on these <a id="_idIndexMarker426"/>alternatives, see <a href="http://developer.mozilla.org/en-US/docs/Web/API/Performance/now">developer.mozilla.org/en-US/docs/Web/API/Performance/now</a> and <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now</a>. Consider using <strong class="source-inline">console.time()</strong> and <strong class="source-inline">console.timeEnd()</strong>; see <a href="http://developer.mozilla.org/en-US/docs/Web/API/Console/time">developer.mozilla.org/en-US/docs/Web/API/Console/time</a> for <span class="No-Break">more information.</span></p>
			<p>The preceding code is <a id="_idIndexMarker427"/>quite similar to the previous <strong class="source-inline">addLogging()</strong> function, and that’s reasonable: in both cases, we add some code before the actual function call and then some new code after the function returns. You might even consider writing a <em class="italic">higher</em> HOF, which would receive three functions and produce a new HOF as output (such as <strong class="source-inline">addLogging()</strong> or <strong class="source-inline">addTiming()</strong>) that would call the first function at the beginning, and then the second function if the wrapped function returned a <a id="_idIndexMarker428"/>value, or the third function if an error had been thrown! How <span class="No-Break">about that?</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Memoizing functions</h2>
			<p>In <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, we considered the case of the Fibonacci function and learned how we <a id="_idIndexMarker429"/>could transform it, by hand, into a much more efficient version using <em class="italic">memoization</em>: caching calculated values to avoid recalculations. A <em class="italic">memoized</em> function would avoid redoing a process if the result was found earlier. We <a id="_idIndexMarker430"/>want to be able to turn any function into a memoized one so that we can get a more optimized version. However, a real-life memoizing solution should also take into account the available RAM and have some ways of avoiding filling it up; however, this is beyond the scope of this book, and we won’t be looking into performance issues either; those optimizations are also beyond the scope of <span class="No-Break">this book.</span></p>
			<p class="callout-heading">Of frameworks and memos</p>
			<p class="callout">Some memoizing functionality is <a id="_idIndexMarker431"/>provided by tools such as React (the <strong class="source-inline">useMemo()</strong> hook) or Vue (the <strong class="source-inline">v-memo</strong> directive), but it’s not really the same. In these cases, only the previous <a id="_idIndexMarker432"/>result is kept, and re-rendering is avoided if a value changes. With the kind of memoization we’re discussing, <em class="italic">all</em> previous values are cached for reuse; React and Vue cache just <span class="No-Break">one value.</span></p>
			<p>For simplicity, let’s only consider functions with a single, non-structured parameter and leave functions with more complex parameters (objects and arrays) or more than one parameter for later. The kind of values we can handle with ease are JavaScript’s primitive values: data that aren’t objects and have no methods. JavaScript has six of these: <strong class="source-inline">boolean</strong>, <strong class="source-inline">null</strong>, <strong class="source-inline">number</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">symbol</strong>, and <strong class="source-inline">undefined</strong>. Usually, we only see the first four as actual arguments. You can find out more by going <span class="No-Break">to </span><a href="http://developer.mozilla.org/en-US/docs/Glossary/Primitive"><span class="No-Break">developer.mozilla.org/en-US/docs/Glossary/Primitive</span></a><span class="No-Break">.</span></p>
			<p>We’re not aiming to produce the best-ever memoizing solution, but let’s study the subject a bit and produce several variants of a memoizing HOF. First, we’ll deal with functions with a single parameter and then consider functions with <span class="No-Break">several parameters.</span></p>
			<h3>Simple memoization</h3>
			<p>We will work with the Fibonacci <a id="_idIndexMarker433"/>function we mentioned previously, which is a simple case: it receives a single numeric parameter. This function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// fibonacci.ts
function fib(n: number): number {
  if (n == 0) {
    return 0;
  } else if (n == 1) {
    return 1;
  } else {
    return fib(n - 2) + fib(n - 1);
  }
}</pre>
			<p>The solution we previously created was general in concept but not particularly good in its implementation: we had to directly modify the function’s code to take advantage of said memoization. Let’s look into how to do this automatically, in the same fashion as other wrapped functions. The solution would be a <strong class="source-inline">memoize()</strong> function that wraps any other function to apply memoization. For clarity, let’s work with JavaScript first and just for functions with a single <span class="No-Break">numeric parameter:</span></p>
			<pre class="source-code">
// memoize.ts
const memoize = (fn) =&gt; {
  const cache = {};
  return (x) =&gt;
    x in cache ? cache[x] : (cache[x] = fn(x));
};</pre>
			<p>How does this work? The returned function, for any given argument, checks whether the argument was already received; that is, whether it can be found as a key in the cache object. (See <em class="italic">Question 6.2</em> for an alternative implementation of the cache.) If so, there’s no need for calculation, and the cached value is returned. Otherwise, we calculate the missing value and store it in the cache. (We use a closure to hide the cache from external access.) Here, we assume that the memoized function receives only one argument (<strong class="source-inline">x</strong>) and that it is a numeric value, which can then be directly used as a key value for the cache object; we’ll consider other <span class="No-Break">cases later.</span></p>
			<p>We now need to go to TypeScript; here’s the equivalent version of <strong class="source-inline">memoize()</strong>. The generic data typing is along the same lines as what we saw in the <em class="italic">Logging in a functional way</em> section, with the only difference being that now we work with functions that get a single <span class="No-Break">numeric argument:</span></p>
			<pre class="source-code">
// continued...
const memoize = <strong class="bold">&lt;T extends (x: number) =&gt; any&gt;</strong>(
  fn: T
): <strong class="bold">((x: number) =&gt; ReturnType&lt;T&gt;)</strong> =&gt; {
  const cache = {} as Record&lt;number, ReturnType&lt;T&gt;&gt;;
  return (x) =&gt;
    x in cache ? cache[x] : (cache[x] = fn(x));
};</pre>
			<p>Is memoization working? We’ll have to time it – and we happen to have a useful <strong class="source-inline">addTiming()</strong> function for <a id="_idIndexMarker434"/>that! First, we time the original <strong class="source-inline">fib()</strong> function. We want to time the complete calculation and not each recursive call, so we write an auxiliary <strong class="source-inline">testFib()</strong> function, which is the one <span class="No-Break">we’ll time.</span></p>
			<p>We should repeat the timing operations and do an average, but since we just want to confirm that memoizing works, we’ll <span class="No-Break">tolerate differences:</span></p>
			<pre class="source-code">
const testFib = (n: number) =&gt; fib(n);
addTiming(testFib)(45); // 18,957 ms
addTiming(testFib)(40); //  1,691 ms
addTiming(testFib)(35); //    152 ms</pre>
			<p>Of course, your times will depend on your specific CPU, RAM, and so on. However, the results seem logical: the exponential growth we mentioned in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, appears to be present, and times grow quickly. Now, let’s memoize <strong class="source-inline">fib()</strong>. We should get shorter times... <span class="No-Break">shouldn’t we?</span></p>
			<pre class="source-code">
const testMemoFib = memoize((n: number) =&gt; fib(n));
addTiming(testMemoFib)(45); // 19,401 ms
addTiming(testMemoFib)(45); //  0.005 ms – good!
addTiming(testMemoFib)(40); //  2,467 ms  ???
addTiming(testMemoFib)(35); //    174 ms  ???</pre>
			<p>Something’s wrong! The times should have gone down, but they are just about the same. This is because of a common error, which I’ve even seen in some articles and web pages. We are timing <strong class="source-inline">testMemoFib()</strong>, but nobody calls that function except for timing, which only happens once! Internally, all recursive calls are to <strong class="source-inline">fib()</strong>, which isn’t memoized. If we called <strong class="source-inline">testMemoFib(45)</strong> again, <em class="italic">that</em> call would be cached, and it would return almost immediately, but that optimization doesn’t apply to the internal <strong class="source-inline">fib()</strong> calls. This is the reason why the calls for <strong class="source-inline">testMemoFib(40)</strong> and <strong class="source-inline">testMemoFib(35)</strong> weren’t optimized – when we did the calculation for <strong class="source-inline">testMemoFib(45)</strong>, that was the only value that <span class="No-Break">got cached.</span></p>
			<p>The correct solution is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
fib = memoize(fib);
addTiming(testFib)(45); // 0.1481 ms
addTiming(testFib)(45); // 0.0022 ms
addTiming(testFib)(40); // 0.0019 ms
addTiming(testFib)(35); // 0.0029 ms</pre>
			<p>Now, when calculating <strong class="source-inline">fib(45)</strong>, all the intermediate Fibonacci values (from <strong class="source-inline">fib(0)</strong> to <strong class="source-inline">fib(45)</strong> itself) are stored, so the <a id="_idIndexMarker435"/>forthcoming calls have practically no work <span class="No-Break">to do.</span></p>
			<p>Now that we know how to memoize single-argument functions, let’s look at functions with <span class="No-Break">more arguments.</span></p>
			<h3>More complex memoization</h3>
			<p>What can we <a id="_idIndexMarker436"/>do if we have to work with a function that receives two or more arguments, or can receive arrays or objects as arguments? Of course, like in the problem that we looked at in <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, about having a function do its job only once, we could simply ignore the question: if the function to be memoized is unary, we go through the memoization process; otherwise, we don’t <span class="No-Break">do anything!</span></p>
			<p class="callout-heading">On the length of functions</p>
			<p class="callout">The number of parameters of a function is called the function’s <em class="italic">arity,</em> or <em class="italic">valence</em>, and JavaScript provides it as the function’s <strong class="source-inline">length</strong> attribute; see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length</a>. You may speak in three different ways: you can say a function has arity one, two, three, and so on; you can say that a function is unary, binary, ternary, and so on; or you can say it’s monadic, dyadic, triadic, and so on. Take <span class="No-Break">your pick!</span></p>
			<p>Our first attempt could be just memoizing unary functions and leaving the rest alone, as in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const memoize2 = &lt;
  T extends (x: number, ...y: any[]) =&gt; any
&gt;(
  fn: T
): ((x: number, ...y: any[]) =&gt; ReturnType&lt;T&gt;) =&gt; {
  <strong class="bold">if (fn.length === 1)</strong> {
    const cache = {} as Record&lt;number, ReturnType&lt;T&gt;&gt;;
    return (x) =&gt;
      x in cache ? cache[x] : (cache[x] = fn(x));
  <strong class="bold">} else {</strong>
<strong class="bold">    return fn;</strong>
<strong class="bold">  }</strong>
};</pre>
			<p>Working more seriously, if we want to be able to memoize any function, we must find a way to generate <a id="_idIndexMarker437"/>cache keys. To do this, we must find a way to convert any argument into a string. We cannot use a non-primitive as a cache key directly. We could attempt to convert the value into a string with something such as <strong class="source-inline">strX = String(x)</strong>, but we'd have problems. With arrays, it seems this could work. However, take a look at the following three cases that involve different arrays but with <span class="No-Break">a twist:</span></p>
			<pre class="source-code">
var a = [1, 5, 3, 8, 7, 4, 6];
String(a); // "1,5,3,8,7,4,6"
var b = [[1, 5], [3, 8, 7, 4, 6]];
String(b); // "1,5,3,8,7,4,6"
var c = [[1, 5, 3], [8, 7, 4, 6]];
String(c); // "1,5,3,8,7,4,6"</pre>
			<p>These three cases produce the same result. If we were only considering a single array argument, we’d be able to make do, but when different arrays produce the same key, that’s a problem. Things become worse if we have to receive objects as arguments because the <strong class="source-inline">String()</strong> representation of any object is, invariably, <strong class="source-inline">"[</strong><span class="No-Break"><strong class="source-inline">object Object]"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var d = {a: "fk"};
String(d); // "[object Object]"
var e = [{p: 1, q: 3}, {p: 2, q: 6}];
String(e); // "[object Object],[object Object]"</pre>
			<p>The simplest solution is to use <strong class="source-inline">JSON.stringify()</strong> to convert whatever arguments we have received into a useful, <span class="No-Break">distinct string:</span></p>
			<pre class="source-code">
var a = [1, 5, 3, 8, 7, 4, 6];
JSON.stringify(a); // "[1,5,3,8,7,4,6]"
var b = [[1, 5], [3, 8, 7, 4, 6]];
JSON.stringify(b); // "[[1,5],[3,8,7,4,6]]"
var c = [[1, 5, 3], [8, 7, 4, 6]];
JSON.stringify(c); // "[[1,5,3],[8,7,4,6]]"
var d = {a: "fk"}; JSON.stringify(d); // "{"a":"fk"}"
var e = [{p: 1, q: 3}, {p: 2, q: 6}];
JSON.stringify(e); // "[{"p":1,"q":3},{"p":2,"q":6}]"</pre>
			<p>For performance, our logic <a id="_idIndexMarker438"/>should be as follows: if the function we are memoizing receives a single argument that’s a primitive value, we can use that argument directly as a cache key. In other cases, we would use the result of <strong class="source-inline">JSON.stringify()</strong> that’s applied to the array of arguments. Our enhanced memoizing HOF could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const memoize3 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;
    number | string,
    ReturnType&lt;T&gt;
  &gt;;
  const PRIMITIVES = ["number", "string"];
  return (...args) =&gt; {
    const strX: number | string =
      args.length === 1 &amp;&amp;
<strong class="bold">      PRIMITIVES.includes(typeof args[0])</strong>
<strong class="bold">        ? args[0]</strong>
<strong class="bold">        : JSON.stringify(args);</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};</pre>
			<p>In terms of universality, this is the safest version. If you are sure about the type of parameters in the <a id="_idIndexMarker439"/>function you will process, it’s arguable that our first version was faster. On the other hand, if you want to have easier-to-understand code, even at the cost of some wasted CPU cycles, you could go with a <span class="No-Break">simpler version:</span></p>
			<pre class="source-code">
// continued...
const memoize4 = &lt;T extends (...x: any[]) =&gt; any&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;) =&gt; {
  const cache = {} as Record&lt;string, ReturnType&lt;T&gt;&gt;;
  return (...args) =&gt; {
    <strong class="bold">const strX = JSON.stringify(args);</strong>
    return strX in cache
      ? cache[strX]
      : (cache[strX] = fn(...args));
  };
};</pre>
			<p class="callout-heading">Birth of a speeder</p>
			<p class="callout">If you want to learn about the development of a top-performance memoizing function, read Caio Gondim’s <em class="italic">How I wrote the world’s fastest JavaScript memoization library</em> article, available online <span class="No-Break">at </span><a href="https://blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/"><span class="No-Break">blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/</span></a><span class="No-Break">.</span></p>
			<p>So far, we have achieved <a id="_idIndexMarker440"/>several interesting memoizing functions, but how will we write tests for them? Let’s analyze this <span class="No-Break">problem now.</span></p>
			<h3>Memoization testing</h3>
			<p>Testing the memoization HOF poses an interesting problem – how would you go about it? The first idea would be to <a id="_idIndexMarker441"/>look into the cache, but that’s private and not visible. Then, of course, we could change <strong class="source-inline">memoize()</strong> so that it uses a global cache or somehow allows external access to the cache, but doing that sort of internal exam is frowned upon: you should try to do your tests based on external <span class="No-Break">properties only.</span></p>
			<p>Accepting that we shouldn’t try to examine the cache, we could go for a time control: calling a function such as <strong class="source-inline">fib(n)</strong> for a large value of <strong class="source-inline">n</strong> should take longer if the function isn’t memoized. This is certainly possible, but it’s also prone to possible failures: something external to your tests could run at just the wrong time, and it could be possible that your memoized run would take longer than the original one. Okay, it’s possible, but not probable – but your test isn’t <span class="No-Break">entirely reliable.</span></p>
			<p>We could think about calculating some Fibonacci numbers and testing how many times the function was called – once directly and all the other times because of recursion. (See <em class="italic">Question 6.3</em> for more on this.) The preceding code is fairly straightforward: we are using the Fibonacci function we developed earlier and testing that it produces correct values. For instance, we can find out that calculating <strong class="source-inline">fib(6)</strong> requires 25 calls by revisiting the diagram we looked at in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, and seeing that there are 25 nodes (each one representing a call to <strong class="source-inline">fib()</strong>) <span class="No-Break">in it:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_4.2_B19301.jpg" alt="Figure 6.1 – 25 calls are needed for calculating ﬁb(6)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – 25 calls are needed for calculating ﬁb(6)</p>
			<p>The first idea would be counting calls, as shown here – but it <span class="No-Break">won’t work!</span></p>
			<pre class="source-code">
// memoize.test.ts
import { fib } from "./fibonacci";
import * as moduleFib from "./fibonacci";
describe("the original fib", function () {
  it("should repeat calculations", () =&gt; {
    jest.spyOn(moduleFib, "fib");
    expect(fib(6)).toBe(8);
    <strong class="bold">expect(fib).toHaveBeenCalledTimes(25);</strong>
  });
});</pre>
			<p>We first calculate <strong class="source-inline">fib(6)</strong> – which correctly returns <strong class="source-inline">8</strong> – and then we check that there should have been 25 calls to <strong class="source-inline">fib()</strong>, but only one was found; what’s going on? The problem is in Jest: when <a id="_idIndexMarker442"/>you spy on a function, you are actually spying on a wrapper that calls the function you want to check. <em class="italic">This</em> wrapper function is called only once; our <strong class="source-inline">fib()</strong> function was called 25 times, but Jest doesn’t <span class="No-Break">see that!</span></p>
			<p>We’ll have to do something else in a very non-functional way! Let’s test a modified <strong class="source-inline">fib()</strong> function that will update an external counter; we’ll call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">fibM()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
describe("the modified fib", function () {
  it("should repeat calculations", () =&gt; {
<strong class="bold">    let count = 0;</strong>
    const fibM = (n: number): number =&gt; {
<strong class="bold">      count++;</strong>
      if (n == 0) {
        return 0;
      } else if (n == 1) {
        return 1;
      } else {
        return fibM(n - 2) + fibM(n - 1);
      }
    };
<strong class="bold">    expect(fibM(6)).toBe(8);</strong>
<strong class="bold">    expect(count).toBe(25);</strong>
  });
});</pre>
			<p>Now that the test works out, how about testing the memoized, modified version instead? In this <a id="_idIndexMarker443"/>case, the count of calls should be lower because of cached results. In fact, it should just be <strong class="source-inline">7</strong> because we’ll need all values from <strong class="source-inline">fib(6)</strong> down <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">fib(0)</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
describe("the memoized, modified fib", function () {
  it("should repeat calculations", () =&gt; {
    let count = 0;
    const fibMM = memoize((n: number): number =&gt; {
      count++;
      if (n == 0) {
        return 0;
      } else if (n == 1) {
        return 1;
      } else {
        return fibMM(n - 2) + fibMM(n - 1);
      }
    });
    expect(fibMM(6)).toBe(8);
<strong class="bold">    expect(count).toBe(7);</strong>
  });</pre>
			<p>In this section, we’ve dealt with several examples that implied wrapping functions so that they keep working <a id="_idIndexMarker444"/>but with some extra features added in. Now, let’s look at a different case where we want to change how a <span class="No-Break">function works.</span></p>
			<h3>Memoizing promises</h3>
			<p>Let’s go a bit further and consider memoizing <strong class="source-inline">async</strong> functions, which return promises. In a complex web application with many related components, it may very well be the case that redundant, repeated API calls go out for no good reason, harming performance and <a id="_idIndexMarker445"/>producing a bad user experience. Imagine, for instance, a dashboard-style web page with several tabs. Whenever a user selects a tab, several API calls go out to get the data that the page needs. However, if the user selects a different tab but later returns to the first one, the very same API calls will go out again. For many applications, data is basically constant, meaning “not changing in real time.” You don’t then need to re-send API calls; re-using previously fetched data <span class="No-Break">also works.</span></p>
			<p>Some solutions are not practical: we could modify the server to enable caching, but what if that’s not possible? Or we could work with a cache, checking before every call whether that data was already fetched, but that would entail hand-modifying every single API call to check the cache first! We want a solution that requires no code changes, and memoizing comes <span class="No-Break">to mind.</span></p>
			<p>Assume we call the API with an <strong class="source-inline">async</strong> function that returns a promise. Given the <strong class="source-inline">memoize()</strong> function we developed, we could memoize the <strong class="source-inline">async</strong> function, and it would be a start. The first time you call the function with some arguments, the API call will go out, and a promise will be returned (since that’s what the function returns). If you call the function again with the same arguments, the memoized promise will be immediately returned. Great! Except there’s a catch… what would happen if the API call failed? We need to add some <span class="No-Break">error-catching logic:</span></p>
			<pre class="source-code">
// memoize.ts
const promiseMemoize = &lt;
  A,
  T extends (...x: any[]) =&gt; Promise&lt;A&gt;
&gt;(
  fn: T
): ((...x: Parameters&lt;T&gt;) =&gt; Promise&lt;A&gt;) =&gt; {
  const cache = {} as Record&lt;string, Promise&lt;A&gt;&gt;;
  return (...args) =&gt; {
    const strX = JSON.stringify(args);
    return strX in cache
      ? cache[strX]
      : (cache[strX] = <strong class="bold">fn(...args).catch((x) =&gt; {</strong>
<strong class="bold">          delete cache[strX];</strong>
<strong class="bold">          return x;</strong>
<strong class="bold">        }</strong>));
  };
};</pre>
			<p>All logic is as before, with <a id="_idIndexMarker446"/>a couple of <span class="No-Break">additional details:</span></p>
			<ul>
				<li>We are now making explicit that the memoized function returns a promise (<strong class="source-inline">Promise&lt;A&gt;</strong>) of some generic <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">A</strong></span></li>
				<li>If the promise is rejected, we add code to delete the cached promise, so a future call will go <span class="No-Break">out again</span></li>
			</ul>
			<p>Our new <strong class="source-inline">promiseMemoize()</strong> function can deal with errors, allowing future retries of rejected calls; good! Now let’s <a id="_idIndexMarker447"/>look at a different case, where we want to change the way a function <span class="No-Break">actually works.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Altering a function’s behavior</h1>
			<p>In the previous section, we considered some ways of wrapping functions so that they maintain their <a id="_idIndexMarker448"/>original functionality, even though they’ve been enhanced in some way. Now, we’ll turn to modifying what the functions do so that the new results will differ from their <span class="No-Break">original ones.</span></p>
			<p>We’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Revisiting the problem of having a function work, but <span class="No-Break">just once</span></li>
				<li>Negating or inverting a <span class="No-Break">function’s result</span></li>
				<li>Changing the arity of <span class="No-Break">a function</span></li>
				<li>Throttling and debouncing functions <span class="No-Break">for performance</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started!</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Doing things once, revisited</h2>
			<p>In <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, we went through an example of developing an FP-style solution for a simple problem: fixing things so that a given function works only <a id="_idIndexMarker449"/>once. We defined <strong class="source-inline">once()</strong> with an arrow <a id="_idIndexMarker450"/>function then; let’s go with a standard function <span class="No-Break">for variety:</span></p>
			<pre class="source-code">
// once.ts
function once&lt;T extends (...args: any[]) =&gt; void&gt;(
  f: T
): (...args: Parameters&lt;T&gt;) =&gt; void {
  let done = false;
  return ((...args: Parameters&lt;T&gt;) =&gt; {
    if (!done) {
      done = true;
      f(...args);
    }
  }) as T;
}</pre>
			<p>This is a perfectly acceptable solution; it works well, and we have nothing to object to. We can, however, think of a variation. We could observe that the given function gets called once, but its return value gets lost. This is easy to fix: we need to add a <strong class="source-inline">return</strong> statement. However, that wouldn’t be enough; what would the function return if it’s called more than once? We can take a page from the memoizing solution and store the function’s return value for <span class="No-Break">future calls.</span></p>
			<p>Let’s store the function’s value in a <strong class="source-inline">result</strong> variable so that we can return <span class="No-Break">it later:</span></p>
			<pre class="source-code">
// continued...
function once2&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  let done = false;
<strong class="bold">  let result: ReturnType&lt;T&gt;;</strong>
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
    if (!done) {
      done = true;
<strong class="bold">      result = f(...args);</strong>
    }
<strong class="bold">    return result;</strong>
  }) as T;
}</pre>
			<p>The first time the function gets called, its value is stored in <strong class="source-inline">result</strong>; further calls just return that value with no further process. You could also think of making the function work only once but for each set of arguments. You wouldn’t have to do any work for that – <strong class="source-inline">memoize()</strong> would <span class="No-Break">be enough!</span></p>
			<p>Back in the <em class="italic">Producing an even better solution</em> section of <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, we considered a possible alternative to <strong class="source-inline">once()</strong>: another HOF that took two functions as parameters and allowed the <a id="_idIndexMarker451"/>first function to be called only once, calling the second function from that point on. Adding a <strong class="source-inline">return</strong> statement to the previous code and rewriting it as a standard function would result <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
function onceAndAfter&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T,
  g: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
  let done = false;
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    if (!done) {</strong>
<strong class="bold">      done = true;</strong>
<strong class="bold">      return f(...args);</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">      return g(...args);</strong>
<strong class="bold">    }</strong>
  }) as T;
}</pre>
			<p>We can rewrite this if we remember that functions are first-order objects. Instead of using a flag to remember which function to call, we can use a <strong class="source-inline">toCall</strong> variable to directly store whichever function needs to be called. Logically, that variable will be initialized to the first function but will then change to the second one. The following code implements <span class="No-Break">that change:</span></p>
			<pre class="source-code">
// continued...
function onceAndAfter2&lt;T extends (...args: any[]) =&gt; any&gt;(
  f: T,
  g: T
): (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; {
<strong class="bold">  let toCall = f;</strong>
  return ((...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; {
<strong class="bold">    let result = toCall(...args);</strong>
<strong class="bold">    toCall = g;</strong>
<strong class="bold">    return result;</strong>
  }) as T;
}</pre>
			<p>The <strong class="source-inline">toCall</strong> variable is <a id="_idIndexMarker452"/>initialized with <strong class="source-inline">f</strong>, so <strong class="source-inline">f()</strong> will get called the first time, but then <strong class="source-inline">toCall</strong> gets the <strong class="source-inline">g</strong> value, implying that all future calls will execute <strong class="source-inline">g()</strong> instead. The very same example we looked at earlier in this book would <span class="No-Break">still work:</span></p>
			<pre class="source-code">
const squeak = (x: string) =&gt; console.log(x, "squeak!!");
const creak = (x: string) =&gt; console.log(x, "creak!!");
const makeSound = onceAndAfter2(squeak, creak);
makeSound("door"); // "door squeak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"</pre>
			<p>In terms of performance, the difference may be negligible. The reason for showing this further variation is to show that you should keep in mind that, by storing functions, you can often produce results more simply. Using flags to store state is a common technique in procedural <a id="_idIndexMarker453"/>programming. However, here, we manage to skip that usage and produce the same result. Now, let’s look at some new examples of wrapping functions to change <span class="No-Break">their behaviors.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Logically negating a function</h2>
			<p>Let’s consider the <strong class="source-inline">filter()</strong> method from <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>. Given a predicate, we can filter the array to only include those elements for which the predicate is true. But how would you do a reverse filter and exclude the elements for which the predicate <span class="No-Break">is true?</span></p>
			<p>The first solution should be pretty obvious: rework the predicate to return the opposite of whatever it originally returned. In the mentioned chapter, we looked at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
// not.ts
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);</pre>
			<p>(For the <strong class="source-inline">serviceResult</strong> object, see the <em class="italic">A filter() example</em> section in the <span class="No-Break">previous chapter.)</span></p>
			<p>So, we could write it the other way round, in either of these equivalent fashions. Note the different ways of writing the same predicate to test for <span class="No-Break">non-negative values:</span></p>
			<pre class="source-code">
// continued...
const notDelinquent = serviceResult.accountsData.filter(
<strong class="bold">  (v) =&gt; v.balance &gt;= 0</strong>
);
const notDelinquent2 = serviceResult.accountsData.filter(
<strong class="bold">  (v) =&gt; !(v.balance &lt; 0)</strong>
);</pre>
			<p>That’s perfectly fine, but we could also have had something like the following in <span class="No-Break">our code:</span></p>
			<pre class="source-code">
// continued...
const isNegativeBalance = (v: AccountData) =&gt; v.balance &lt; 0;
.
. many lines later
.
const delinquent2 = serviceResult.accountsData.filter(
  isNegativeBalance
);</pre>
			<p>In this case, rewriting the original <strong class="source-inline">isNegativeBalance()</strong> function isn’t possible. (Another possibility: the function could be defined in a separate module, which you can’t or shouldn’t modify.) However, working in a functional way, we can write an HOF that will take any <a id="_idIndexMarker454"/>predicate, evaluate it, and then negate its result. A possible implementation would be pretty straightforward, thanks to modern JavaScript syntax – and for the TypeScript version, check <span class="No-Break"><em class="italic">Question 6.5</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const <strong class="bold">not</strong> = (fn) =&gt; (...args) =&gt; !fn(...args);</pre>
			<p>Working in this way, we could have rewritten the preceding filter as follows; to test for non-negative balances, we use the original <strong class="source-inline">isNegativeBalance()</strong> function, which is negated via our <span class="No-Break"><strong class="source-inline">not()</strong></span><span class="No-Break"> HOF:</span></p>
			<pre class="source-code">
// continued...
const notDelinquent3 = serviceResult.accountsData.filter(
<strong class="bold">  not(isNegativeBalance)</strong>
);</pre>
			<p>There is an additional solution we might want to try out. Instead of reversing the condition (as we did), we could write a new filtering method (possibly <strong class="source-inline">filterNot()</strong>?) that would work in the opposite way to <strong class="source-inline">filter()</strong>. The following code shows how this new function would be written. Given an <strong class="source-inline">arr</strong> array of values and an <strong class="source-inline">fn</strong> predicate, we’d have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const <strong class="bold">filterNot</strong> =
  &lt;A, T extends (x: A) =&gt; boolean&gt;(arr: A[]) =&gt;
  (fn: T): A[] =&gt;
  <strong class="bold">  arr.filter(not((y) =&gt; fn(y)));</strong></pre>
			<p>This solution doesn’t fully match <strong class="source-inline">filter()</strong> since you cannot use it as a method, but we could either add it to <strong class="source-inline">Array.prototype</strong> or apply some methods. We’ll look at these ideas in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>. However, it’s more interesting to note that we used the negated function, so <strong class="source-inline">not()</strong> is necessary for both solutions to the reverse filtering problem. In the upcoming <em class="italic">Demethodizing – turning methods into functions</em> section, we will see that we have yet another solution since we can decouple methods such as <strong class="source-inline">filter()</strong> from the objects they apply to, thereby changing them into <span class="No-Break">common functions.</span></p>
			<p>As for negating the function versus using a new <strong class="source-inline">filterNot()</strong> function, even though both possibilities are <a id="_idIndexMarker455"/>equally valid, I think using <strong class="source-inline">not()</strong> is clearer. If you already understand how filtering works, then you can practically read the code aloud, and it will be understandable: we want those accounts that don’t have a negative balance, right? Now, let’s consider a related problem: inverting the results of <span class="No-Break">a function.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Inverting the results</h2>
			<p>In the same vein as the preceding filtering problem, let’s revisit the sorting problem from the <em class="italic">Injection – sorting it out</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions</em>. Here, we wanted to sort an array with a specific method. Therefore, we used <strong class="source-inline">sort()</strong>, providing it with a <strong class="source-inline">comparison</strong> function that basically pointed out which of the two strings should go first. To refresh your memory, given two strings, the function should do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Return a negative number if the first string should precede the <span class="No-Break">second one</span></li>
				<li>Return <strong class="source-inline">0</strong> if the strings are <span class="No-Break">the same</span></li>
				<li>Return a positive number if the first string should follow the <span class="No-Break">second one</span></li>
			</ul>
			<p>Let’s go back to the code we looked at for sorting in Spanish. We had to write a specialized <strong class="source-inline">comparison</strong> function so that sorting would take into account the character-ordering rules from Spanish, such as placing the letter <em class="italic">ñ</em> between <em class="italic">n</em> and <em class="italic">o</em>, and more. The code for this was <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const spanishComparison = (a: string, b: string) =&gt;
  a.localeCompare(b, "es");
palabras.sort(spanishComparison);
// sorts the array according to Spanish rules</pre>
			<p>We are facing a similar problem: how can we sort in descending order? Given what we saw in the previous section, some options should immediately come <span class="No-Break">to mind:</span></p>
			<ul>
				<li>Sort into ascending order, and afterward reverse the array. While this solves the problem, we still only sort into ascending order, and we would want to avoid the extra <span class="No-Break">reversing step.</span></li>
				<li>Write a function that will invert the result from the comparing function. This will invert the result of <a id="_idIndexMarker456"/>all the decisions as to which string should precede, and the final result will be an array sorted in exactly the <span class="No-Break">opposite way.</span></li>
				<li>Write a <strong class="source-inline">sortDescending()</strong> function or method that does its work in the opposite fashion <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">sort()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Let’s opt for the second option and write an <strong class="source-inline">invert()</strong> function that will change the comparison result. The code <a id="_idIndexMarker457"/>itself is quite similar to that of <strong class="source-inline">not()</strong>. Again, check <em class="italic">Question 6.5</em> for the <span class="No-Break">TypeScript equivalent:</span></p>
			<pre class="source-code">
// invert.ts
const invert = (fn) =&gt; (...args) =&gt; <strong class="bold">-fn(...args)</strong>;</pre>
			<p>Given this HOF, we can sort in descending order by providing a suitably inverted <strong class="source-inline">comparison</strong> function. Take a look at the last few lines, where we use <strong class="source-inline">invert()</strong> to change the result of the <span class="No-Break">sorting comparison:</span></p>
			<pre class="source-code">
const spanishComparison = (a: string, b: string): number =&gt;
  a.localeCompare(b, "es");
const palabras = [
  "ñandú",
  "oasis",
  "mano",
  "natural",
  "mítico",
  "musical",
];
palabras.sort(spanishComparison);
// "mano", "mítico", "musical", "natural", "ñandú", "oasis"
palabras.sort(<strong class="bold">invert(spanishComparison)</strong>);
// "oasis", "ñandú", "natural", "musical", "mítico", "mano"</pre>
			<p>The output <a id="_idIndexMarker458"/>is as expected: when we <strong class="source-inline">invert()</strong> the <strong class="source-inline">comparison</strong> <a id="_idIndexMarker459"/>function, the results are in the opposite order. Writing unit tests would be quite easy, given that we already have some test cases with their expected results, <span class="No-Break">wouldn’t it?</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Arity changing</h2>
			<p>Back in the <em class="italic">Parsing numbers tacitly</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we saw that using <strong class="source-inline">parseInt()</strong> with <strong class="source-inline">reduce()</strong> produces problems because of the unexpected arity of that function, which took more than one argument—remember the example <span class="No-Break">from earlier?</span></p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(parseInt);
// <strong class="bold">[123, NaN, NaN]</strong></pre>
			<p>We have more than one way to solve this. In the mentioned chapter, we went with an arrow function. This was a simple solution, with the added advantage of being clear to understand. In <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, we will look at yet another, based on partial application. For now, let’s go with an HOF We need a function that will take another function as a parameter and turn it into a unary function. Using JavaScript’s spread operator and an arrow function, this is easy <span class="No-Break">to manage:</span></p>
			<pre class="source-code">
const unary = fn =&gt; (...args) =&gt; fn(args[0]);</pre>
			<p>The following is the example <span class="No-Break">in TypeScript:</span></p>
			<pre class="source-code">
// arity.ts
const unary =
  <strong class="bold">&lt;T extends (...x: any[]) =&gt; any&gt;</strong>(
    fn: T
  ): <strong class="bold">((arg: Parameters&lt;T&gt;[0]) =&gt; ReturnType&lt;T&gt;)</strong> =&gt;
(x) =&gt; fn(x);</pre>
			<p>Our <strong class="source-inline">unary()</strong> function works with a generic <strong class="source-inline">T</strong> function. It produces a new function with just a single argument (the first one, <strong class="source-inline">Parameters&lt;T&gt;[0]</strong>) that returns the same type of result (<strong class="source-inline">ReturnType&lt;T&gt;</strong>) as the original <span class="No-Break">function does.</span></p>
			<p>Using this function, our number parsing problem <span class="No-Break">goes away:</span></p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(<strong class="bold">unary(parseInt)</strong>);
// [123, -67, 90]</pre>
			<p>It goes without saying that it <a id="_idIndexMarker460"/>would be equally simple to define further <strong class="source-inline">binary()</strong> or <strong class="source-inline">ternary()</strong>functions, and others that would turn any function into an equivalent but restricted-arity version. Let’s not go overboard and just look at a couple of all the possible functions – see <em class="italic">Question 6.10</em> for more <span class="No-Break">on this:</span></p>
			<pre class="source-code">
// continued...
const binary = fn =&gt; (...a) =&gt; fn(<strong class="bold">a[0], a[1]</strong>);
const ternary = fn =&gt; (...a) =&gt; fn(<strong class="bold">a[0], a[1], a[2]</strong>);</pre>
			<p>This works, but spelling out all the parameters can become tiresome. We can even go one better by using array operations and spreading and make a generic function to deal with all of these cases, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const arity = (<strong class="bold">n</strong>, fn) =&gt; (...a) =&gt; fn(<strong class="bold">...a.slice(0, n)</strong>);</pre>
			<p>With this generic <strong class="source-inline">arity()</strong> function, we can give alternative definitions for <strong class="source-inline">unary()</strong>, <strong class="source-inline">binary()</strong>, and so on. We could even <a id="_idIndexMarker461"/>rewrite the earlier functions <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const unary = fn =&gt; arity(<strong class="bold">1</strong>, fn);
const binary = fn =&gt; arity(<strong class="bold">2</strong>, fn);
const ternary = fn =&gt; arity(<strong class="bold">3</strong>, fn);</pre>
			<p>You may think that there aren’t many cases in which you would want to apply this kind of solution, but there are many more than you would expect. Going through all of JavaScript’s functions and methods, you can quickly produce a list starting with <strong class="source-inline">apply()</strong>, <strong class="source-inline">assign()</strong>, <strong class="source-inline">bind()</strong>, <strong class="source-inline">concat()</strong>, <strong class="source-inline">copyWithin()</strong>, and many more! If you wanted to use any of those in a tacit way, you would probably need to fix their arity so that they would work with a fixed, non-variable number <span class="No-Break">of parameters.</span></p>
			<p class="callout-heading">Everything under the sun</p>
			<p class="callout">If you want a nice list of JavaScript functions and methods, check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions</a> and <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index</a>. As for tacit programming (or pointfree style), we’ll return to it in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <span class="No-Break"><em class="italic">Connecting Functions</em></span><span class="No-Break">.</span></p>
			<p class="callout">There will be a problem with TypeScript, though. TypeScript deals with static typing, but the type of the result of a call to <strong class="source-inline">arity()</strong> is determined at runtime. The most we may manage is, by a <a id="_idIndexMarker462"/>series of overloads, to say that given a function with several parameters, the result of applying <strong class="source-inline">arity()</strong> to it will have zero, one, two, and so on different possibilities – but we won’t be able to <span class="No-Break">do more.</span></p>
			<p>So far, we have learned <a id="_idIndexMarker463"/>how to wrap functions while keeping their original behavior or changing it in some fashion. Now, let’s consider some other ways of <span class="No-Break">modifying functions.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Throttling and debouncing</h2>
			<p>Let’s finish this section with two techniques that limit when and how often a function “does its thing”: <strong class="bold">debouncing</strong> and <strong class="bold">throttling</strong>. Both techniques share the same concept, so we’ll tackle <span class="No-Break">them together:</span></p>
			<ul>
				<li><em class="italic">Debouncing</em> a function <a id="_idIndexMarker464"/>means we delay for some time, doing nothing <em class="italic">until</em> we actually call <span class="No-Break">the function</span></li>
				<li><em class="italic">Throttling</em> a function means <a id="_idIndexMarker465"/>we delay for some time, doing nothing <em class="italic">after</em> we actually call <span class="No-Break">the function</span></li>
			</ul>
			<p>These techniques are very efficient for web pages and allow for better performance. In a sense, they are related to memoizing. With memoization, you modify a function so it will get called only once (for some given arguments) but never more. With the techniques here, we do not go that far – we will allow a function to do its thing again, but in a restricted way, with some delays <span class="No-Break">added in.</span></p>
			<h3>Debouncing functions</h3>
			<p>The idea of debouncing comes from electronics and involves waiting to do something until a stable state has been reached. For example, if you write an autocomplete component, every <a id="_idIndexMarker466"/>time the user types a letter, you could query an API to fetch the possible options. However, you wouldn’t want to do this keypress by keypress because you’d be generating lots of calls, most of which you won’t even use since you’ll only care for the last one you made. Other usual examples involve mouse movement or page scrolling events; you don’t want to run associated handlers too often since that will negatively impact the <span class="No-Break">page’s performance.</span></p>
			<p>If you debounced the API-calling function, you could still call it for every keypress, but no API call would be made until some time elapsed without any more calls. See <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em> for an example of this; events are shown as circles, and the actual call goes only given some event-less time after the <span class="No-Break">last event:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_6.2_B19301.jpg" alt="Figure 6.2 – A debounced function executes only after a pause in calls to it"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A debounced function executes only after a pause in calls to it</p>
			<p>We can implement this with a timeout <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// debounce.ts
const debounce = &lt;T extends (...args: any[]) =&gt; void&gt;(
  fn: T,
  delay = 1000
) =&gt; {
<strong class="bold">  let timer</strong>: ReturnType&lt;typeof setTimeout&gt;;
  return (...args: Parameters&lt;T&gt;): void =&gt; {
<strong class="bold">    clearTimeout(timer);</strong>
<strong class="bold">    timer = setTimeout(() =&gt; fn(...args), timeDelay);</strong>
  };
};</pre>
			<p>A debounced function is a new one that can be called as often as desired but won’t do anything until a <strong class="source-inline">timer</strong> has run. If you call the function once and then call it again, the timer will be reset <a id="_idIndexMarker467"/>and start running again. The only way for the function to actually do its thing is if a given <strong class="source-inline">delay</strong> period passes without any <span class="No-Break">new calls.</span></p>
			<h3>Throttling functions</h3>
			<p>For the complementary throttling transformation, imagine a web form with a <strong class="bold">FETCH</strong>, <strong class="bold">APPLY FILTERS</strong>, or <strong class="bold">RETRIEVE</strong> button. When you click on it, an API call is made to get some data. However, if the user starts clicking again and again, too many calls will be made, even <a id="_idIndexMarker468"/>if they will get the same results. We want to throttle the calls so the first call will go through, but further calls will be disabled until some time has passed. A similar use case applies to <em class="italic">infinite scrolling</em>; as the user scrolls down the page, you want to fetch more data, but you neither want to do it very often for performance reasons nor wait until the user reaches the bottom (as would be the case with debouncing) because then scrolling would <span class="No-Break">be stopped.</span></p>
			<p>Throttling is similar to debouncing, but a throttled function runs but then waits until the next run, while a debounced <a id="_idIndexMarker469"/>function first waits and then runs. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.3</em> shows how throttling works. As in the previous section, events are shown as circles. After a call to the API, no further calls are done unless some time <span class="No-Break">has passed:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_6.3_B19301.jpg" alt="Figure 6.3 – A throttled function runs the first time it’s called but then delays until running again"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A throttled function runs the first time it’s called but then delays until running again</p>
			<pre class="source-code">
// throttle.ts
const throttle = &lt;T extends (...args: any[]) =&gt; void&gt;(
  fn: T,
  delay = 1000
) =&gt; {
<strong class="bold">  let timer</strong>: ReturnType&lt;typeof setTimeout&gt; | undefined;
  return (...args: Parameters&lt;T&gt;): void =&gt; {
   <strong class="bold"> if (!timer) {</strong>
<strong class="bold">      timer = setTimeout(() =&gt; {</strong>
<strong class="bold">        timer = undefined;</strong>
<strong class="bold">      }, delay);</strong>
<strong class="bold">      fn(...args);</strong>
    }
  };
};</pre>
			<p>A throttled function is a new one, which you can call as often as desired, but it will “do its thing” the first time and not again until a certain <strong class="source-inline">delay</strong>. When you call the function, it first checks <a id="_idIndexMarker470"/>whether the <strong class="source-inline">timer</strong> is set; if so, it won’t do anything. If the timer isn’t set, a timeout will be set to clear the <strong class="source-inline">timer</strong> after some <strong class="source-inline">delay</strong>, and the function will be called. We are using the <strong class="source-inline">timer</strong> variable both for the timeout and as a flag (“are <span class="No-Break">we waiting?”).</span></p>
			<p>So far, we have learned how to wrap functions while keeping their original behavior or by altering them in some fashion. Now, let’s consider some other ways of <span class="No-Break">modifying functions.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Changing functions in other ways</h1>
			<p>Let’s end this chapter <a id="_idIndexMarker471"/>by considering other sundry functions that provide results, such as new finders, decoupling methods from objects, and more. Our examples will include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Turning operations (such as adding with the <strong class="source-inline">+</strong> operator) <span class="No-Break">into functions</span></li>
				<li>Turning functions <span class="No-Break">into promises</span></li>
				<li>Accessing objects to get the value of <span class="No-Break">a property</span></li>
				<li>Turning methods <span class="No-Break">into functions</span></li>
				<li>A better way of finding <span class="No-Break">optimum values</span></li>
			</ul>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Turning operations into functions</h2>
			<p>We have already <a id="_idIndexMarker472"/>seen several cases where we needed to write <a id="_idIndexMarker473"/>a function just to add or multiply a pair of numbers. For example, in the <em class="italic">Summing an array</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we had to write code equivalent to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const mySum = myArray.reduce(
  (x: number, y: number): number =&gt; x + y,
  0
);</pre>
			<p>In the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we wrote this to calculate <span class="No-Break">a factorial:</span></p>
			<pre class="source-code">
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce((x, y) =&gt; x * y, 1);</pre>
			<p>It would have been easier if we could just turn a binary operator into a function that calculates the same result. The preceding two examples could have been written more succinctly, as follows. Can you understand the change <span class="No-Break">we made?</span></p>
			<pre class="source-code">
const mySum = myArray.reduce(<strong class="bold">binaryOp2("+")</strong>, 0);
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce(<strong class="bold">binaryOp2("*")</strong>, 1);</pre>
			<p>We haven’t <a id="_idIndexMarker474"/>looked at how <strong class="source-inline">binaryOp()</strong> is implemented yet, but the <a id="_idIndexMarker475"/>key notion is that instead of an infix operator (like we use when we write <strong class="source-inline">22+9</strong>), we now have a function (as if we could write our sum like <strong class="source-inline">+(22,9)</strong>, which certainly isn’t valid JavaScript). Let’s see how we can make <span class="No-Break">this work.</span></p>
			<h3>Implementing operations</h3>
			<p>How would we <a id="_idIndexMarker476"/>write this <strong class="source-inline">binaryOp()</strong> function? There are at least two ways of doing so: a safe but long one and a riskier and shorter alternative. The first would require listing each possible operator. The following code does this by using a <span class="No-Break">longish switch:</span></p>
			<pre class="source-code">
// binaryOp.ts
const binaryOp1 = (op: string) =&gt; {
  switch (op) {
    case "+":
      return (x: number, y: number): number =&gt; x + y;
    case "-":
      return (x: number, y: number): number =&gt; x - y;
    case "*":
      return (x: number, y: number): number =&gt; x * y;
    //
    // etc.
    //
    default:
      throw new Error(`Unknown ${op} operator`);
  }
};</pre>
			<p>This solution is perfectly fine but requires too much work. By the way, we should have separate <strong class="source-inline">binaryMathOp()</strong> and <strong class="source-inline">binaryLogicalOp()</strong> functions; the first would be <strong class="source-inline">(op: string) =&gt; ((x: number, y: number) =&gt; number)</strong> while the second would be <strong class="source-inline">(op: string) =&gt; ((x: boolean, y: boolean) =&gt; boolean)</strong> because, as in the previous section, TypeScript cannot deduce the type of the <span class="No-Break">returned function.</span></p>
			<p>There’s a second solution, which is shorter but more dangerous. Please consider this only as an example <a id="_idIndexMarker477"/>for learning purposes; using <strong class="source-inline">eval()</strong> isn’t recommended for security reasons! Our second version would use <strong class="source-inline">Function()</strong> to create a new function that uses the desired operator, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const binaryOp2 = (op) =&gt;
  new Function("x", "y", `return x ${op} y;`);</pre>
			<p>Again, TypeScript cannot determine the type of the returned function because that will be determined only at runtime. So, we need to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const binaryOp2 = (op: string) =&gt;
  new Function("x", "y", `return x ${op} y;`) <strong class="bold">as (</strong>
<strong class="bold">    x: number,</strong>
<strong class="bold">    y: number</strong>
<strong class="bold">  ) =&gt; number</strong>;</pre>
			<p>We don’t have to specify the type of <strong class="source-inline">binaryOp2()</strong> because TypeScript can work it out to be <strong class="source-inline">(o: string) =&gt; (x: number, y: number) =&gt; number</strong> by itself, given the cast that we applied to <span class="No-Break">the result.</span></p>
			<p class="callout-heading">The (easier) way out</p>
			<p class="callout">Some libraries, such as Lodash, already provide functions such as <strong class="source-inline">_.multiply()</strong> and  <strong class="source-inline">_.sum()</strong>, so that’s a more straightforward solution! You could quickly whip up your own and create your own mini-library of mathematical and logical <span class="No-Break">essential functions.</span></p>
			<p>If you follow this <a id="_idIndexMarker478"/>train of thought, you may also define a <strong class="source-inline">unaryOp()</strong> function, even though there are fewer applications for it. (I leave this implementation to you; it’s similar to what we already wrote.) In <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, we will look at an alternative way of creating this unary function by using a <span class="No-Break">partial application.</span></p>
			<h3>A handier implementation</h3>
			<p>Let’s get ahead of <a id="_idIndexMarker479"/>ourselves. Doing FP doesn’t always mean getting down to the simplest possible functions. For example, in an upcoming section of this book, we will need a function to check whether a number is negative, and we’ll consider (see the <em class="italic">Converting to pointfree style</em> section of <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic">, Connecting Functions</em>) using <strong class="source-inline">binaryOp2()</strong> to <span class="No-Break">write it:</span></p>
			<pre class="source-code">
const isNegative = curry(binaryOp2("&gt;"))(0);</pre>
			<p>Don’t worry about the <strong class="source-inline">curry()</strong> function for now (we’ll get to it soon, in the following chapter) – the idea is that it fixes the first argument to <strong class="source-inline">0</strong> so that our function will check for a given <strong class="source-inline">n</strong> number if <strong class="source-inline">0&gt;n</strong>. The point is that the function we just wrote isn’t very clear. We could do better if we defined a binary operation function that lets us specify one of its parameters – the left or the right one – in addition to the operator to be used. Here, we can write the following couple of functions, which define the functions where the left or right operators <span class="No-Break">are missing:</span></p>
			<pre class="source-code">
// continued...
const binaryLeftOp =
  (x: number, op: string) =&gt; (y: number) =&gt;
    binaryOp2(op)(x, y);
const binaryOpRight =
  (op: string, y: number) =&gt; (x: number) =&gt;
    binaryOp2(op)(x, y);</pre>
			<p>With these new functions, we could write either of the following two definitions, though I think the second is clearer. I’d rather test whether a number is less than <strong class="source-inline">0</strong> than whether <strong class="source-inline">0</strong> is greater than <span class="No-Break">the number:</span></p>
			<pre class="source-code">
const isNegative1 = binaryLeftOp(<strong class="bold">0, "&gt;"</strong>);
const isNegative2 = binaryOpRight(<strong class="bold">"&lt;", 0</strong>);</pre>
			<p>What is the point of this? Don’t strive for some basic simplicity or go down to basics. We can transform an <a id="_idIndexMarker480"/>operator into a function, but if you can do better and simplify your coding by specifying one of the two parameters for the operation, just do it! The idea of FP is to help write better code, and creating artificial limitations won’t <span class="No-Break">help anybody.</span></p>
			<p>Of course, for a simple function such as checking whether a number is negative, I would never want to complicate things with currying, binary operators, pointfree style, or anything else, and I’d write the following with no <span class="No-Break">further ado:</span></p>
			<pre class="source-code">
const isNegative3 = (x: number): boolean =&gt; <strong class="bold">x &lt; 0</strong>;</pre>
			<p>So far, we have seen several ways of solving the same problem. Keep in mind that FP doesn’t force you to pick one way of doing things; instead, it allows you a lot of freedom in deciding which way <span class="No-Break">to go!</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Turning functions into promises</h2>
			<p>In Node.js, most asynchronous functions require a callback such as <strong class="source-inline">(err,data)=&gt;{...}</strong>: if <strong class="source-inline">err</strong> is falsy, the function was successful, and <strong class="source-inline">data</strong> is its result; otherwise, the <a id="_idIndexMarker481"/>function failed, and <strong class="source-inline">err</strong> gives <a id="_idIndexMarker482"/>the cause. (See <a href="http://nodejs.org/api/errors.html#error-first-callbacks">nodejs.org/api/errors.html#error-first-callbacks</a> for more <span class="No-Break">on this.)</span></p>
			<p>However, you might prefer to work with promises instead. So, we can think of writing an HOF that will transform a function that requires a callback into a promise that lets you use the <strong class="source-inline">then()</strong> and <strong class="source-inline">catch()</strong> methods. (In <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, we will see that promises are actually <em class="italic">monads</em>, so this transformation is interesting in yet another way.) This will be an exercise for some developers because Node.js (since version 8) already provides the <strong class="source-inline">util.promisify()</strong> function, which turns an <strong class="source-inline">async</strong> function into a promise. See <a href="http://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original">nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original</a> for more <span class="No-Break">on that.</span></p>
			<p>So, how can we manage this? The transformation is relatively simple. Given a function, we produce a new one: this will return a promise that, upon calling the original function with some parameters, will either <strong class="source-inline">reject()</strong> or <strong class="source-inline">resolve()</strong> the <span class="No-Break">promise appropriately.</span></p>
			<p>The <strong class="source-inline">promisify()</strong> function does <a id="_idIndexMarker483"/>precisely that. Its parameter is an <strong class="source-inline">fn</strong> function that returns <a id="_idIndexMarker484"/>either an <strong class="source-inline">err</strong> error of generic type <strong class="source-inline">E</strong>, or some <strong class="source-inline">data</strong> of <a id="_idIndexMarker485"/>generic type <strong class="source-inline">D</strong>. The arguments of <strong class="source-inline">fn</strong> may be any type, except that the last one must be a callback; this requires using <em class="italic">variadic</em> data types, available in TypeScript since version 4.0, <span class="No-Break">from 2020:</span></p>
			<pre class="source-code">
// promisify.ts
const promisify =
  &lt;E, T extends any[], D&gt;(
    fn: (...args: [...T, (err: E, data: D) =&gt; void]) =&gt; void
  ) =&gt;
<strong class="bold">  (...args: T)</strong>: Promise&lt;D&gt; <strong class="bold">=&gt;</strong>
    <strong class="bold">new Promise((resolve, reject) =&gt;</strong>
<strong class="bold">      fn(...args, (err: E, data: D) =&gt;</strong>
<strong class="bold">        err ? reject(err) : resolve(data)</strong>
      )
    );</pre>
			<p>The given <strong class="source-inline">fn</strong> function is turned into a promise. The promise calls <strong class="source-inline">fn</strong> with a special callback: if that callback gets a non-null <strong class="source-inline">err</strong> value, the promise is rejected with that error; otherwise, the promise is resolved <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break">.</span></p>
			<p>When working in Node.js, the following style is <span class="No-Break">fairly common:</span></p>
			<pre class="source-code">
const fs = require("fs");
const cb = (err, data) =&gt;
  err
    ? console.log("ERROR", err)
    : console.log("SUCCESS", data);
fs.readFile("./exists.txt", cb);       // success, data
fs.readFile("./doesnt_exist.txt", cb); // fail, exception</pre>
			<p>You can use promises instead by using our <strong class="source-inline">promisify()</strong> function – or in current versions <span class="No-Break">of Node.js,</span>
<strong class="source-inline">util.promisify()</strong> (but see the following, by the end of <span class="No-Break">this section!):</span></p>
			<pre class="source-code">
const fspromise = <strong class="bold">promisify</strong>(fs.readFile.bind(fs));
const goodRead = (data) =&gt;
  console.log("SUCCESSFUL PROMISE", data);
const badRead = (err) =&gt;
  console.log("UNSUCCESSFUL PROMISE", err);
fspromise("./readme.txt")    // success
  .then(goodRead)
  .catch(badRead);
fspromise("./readmenot.txt") // failure
  .then(goodRead)
  .catch(badRead);</pre>
			<p>Now, you <a id="_idIndexMarker486"/>can use <strong class="source-inline">fspromise()</strong> instead of the original <a id="_idIndexMarker487"/>method. To do so, we had to bind <strong class="source-inline">fs.readFile</strong>, as we mentioned in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out </em><span class="No-Break"><em class="italic">with Functions</em></span><span class="No-Break">.</span></p>
			<p>By the way, when using Node.js, be aware that many modules already provide a promise-based API in addition to the older callback-based API; for example, see <a href="http://nodejs.org/api/fs.html#promises-api">nodejs.org/api/fs.html#promises-api</a> and compare it <span class="No-Break">to </span><a href="http://nodejs.org/api/fs.html#callback-api"><span class="No-Break">nodejs.org/api/fs.html#callback-api</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Getting a property from an object</h2>
			<p>There is a <a id="_idIndexMarker488"/>simple function that we could also <a id="_idIndexMarker489"/>produce. Extracting an attribute from an object is a <a id="_idIndexMarker490"/>commonly required operation. For example, in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we had to get latitudes and longitudes to calculate an average. The code for this was <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// getField.ts
const markers = [
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  // ...
  { name: "BO", lat: -16.5, lon: -68.1 },
];
let averageLat = average(markers.map(x =&gt; x.lat));
let averageLon = average(markers.map(x =&gt; x.lon));</pre>
			<p>We saw another example when we learned how to filter an array; in our example, we wanted to get the IDs for all the accounts with a negative balance. After filtering out all other accounts, we still needed to extract the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);
const delinquentIds = delinquent.map((v) =&gt; v.id);</pre>
			<p>What do we <a id="_idIndexMarker491"/>need? We need an HOF that will receive the <a id="_idIndexMarker492"/>name of an attribute and produce a new function <a id="_idIndexMarker493"/>that can extract an attribute from an object. Using the arrow function syntax, this function is easy to write; <strong class="source-inline">f</strong> is the name of the field we want, and <strong class="source-inline">obj</strong> is the object from which to get <span class="No-Break">the field:</span></p>
			<pre class="source-code">
// getField.ts
const getField = <strong class="bold">f =&gt; obj =&gt; obj[f]</strong>;</pre>
			<p>The full TypeScript version is a bit longer, but not much; mainly, we need to specify that <strong class="source-inline">f</strong> must be a key of <span class="No-Break">the object:</span></p>
			<pre class="source-code">
// continued...
const getField = &lt;D&gt;(<strong class="bold">f: keyof D</strong>) =&gt; (<strong class="bold">obj: D</strong>) =&gt; <strong class="bold">obj[f]</strong>;</pre>
			<p>With this function, the coordinate extraction process could have been written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
let averageLat = average(markers.map(getField("lat")));
let averageLon = average(markers.map(getField("lon")));</pre>
			<p>But that won’t be accepted! The issue is that TypeScript cannot detect the type of the result of the call to <strong class="source-inline">getField()</strong> because that will be decided at runtime. We must help by informing it that our two calls will return numbers. We can define the type of a generic number-returning function as <strong class="source-inline">NumFn</strong>, and then write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
type <strong class="bold">NumFn</strong> = (...args: any[]) =&gt; number;
const averageLat2 = average(
  markers.map(getField("lat") <strong class="bold">as NumFn</strong>)
);
const averageLon2 = average(
  markers.map(getField("lon") as NumFn)
);</pre>
			<p>For variety, we <a id="_idIndexMarker494"/>could have used an auxiliary variable <a id="_idIndexMarker495"/>to get the delinquent IDs and avoid using an <a id="_idIndexMarker496"/>extra type similar to <strong class="source-inline">NumFn</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const getId = getField("id") <strong class="bold">as (...args: any[]) =&gt; string</strong>;
const delinquent = serviceResult.accountsData.filter(
  (v) =&gt; v.balance &lt; 0
);
const delinquentIds = <strong class="bold">delinquent.map(getId)</strong>;</pre>
			<p>Make sure that you fully understand what’s going on here. The result of the <strong class="source-inline">getField()</strong> call is a function that will be used in further expressions. The <strong class="source-inline">map()</strong> method requires a mapping function and is what <span class="No-Break"><strong class="source-inline">getField()</strong></span><span class="No-Break"> produces.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Demethodizing – turning methods into functions</h2>
			<p>Methods <a id="_idIndexMarker497"/>such as <strong class="source-inline">filter()</strong> and <strong class="source-inline">map()</strong> are only available for arrays; however, you may want to apply them to, say, <strong class="source-inline">NodeList</strong> or <strong class="source-inline">String</strong>, and you’d be out of luck. Also, we are focusing on strings, so having to use these functions as methods is not exactly what we had in mind. Finally, whenever we create a new function (such as <strong class="source-inline">none()</strong>, which we saw in the <em class="italic">Checking negatives</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Programming Declaratively</em>), it cannot be applied in the same way as its peers (<strong class="source-inline">some()</strong> and <strong class="source-inline">every()</strong>, in this case) unless you do some prototype trickery. This is rightly frowned upon and not recommended, but we’ll look into it anyhow; another case of “do as I say, not as <span class="No-Break">I do!”</span></p>
			<p>Read the <em class="italic">Extending current data types</em> section of <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, where we will make <strong class="source-inline">map()</strong> available for most <span class="No-Break">basic types.</span></p>
			<p>So, what can we do? We can apply the old saying <em class="italic">If the mountain won’t come to Muhammad, then Muhammad must go to the mountain</em>. Instead of worrying about not being able to create new methods, we will turn the existing methods into functions. We can do this if we convert each method into a function that will receive, as its first parameter, the object it will <span class="No-Break">work on.</span></p>
			<p>Decoupling methods from objects can help you because once you achieve this separation, everything <a id="_idIndexMarker498"/>turns out to be a function, and your code will be simpler. (Remember what we wrote in the <em class="italic">Logically negating a function</em> section, regarding a possible <strong class="source-inline">filterNot()</strong> function in comparison to the <strong class="source-inline">filter()</strong> method?) A decoupled method works similarly to generic functions in other languages since they can be applied to diverse <span class="No-Break">data types.</span></p>
			<p class="callout-heading">An important ABC: apply, bind, call</p>
			<p class="callout">Take a look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function</a> for explanations on <strong class="source-inline">apply()</strong>, <strong class="source-inline">call()</strong>, and <strong class="source-inline">bind()</strong>. We are going to use these for our implementation. Back in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, we saw the equivalence between <strong class="source-inline">apply()</strong> and <strong class="source-inline">call()</strong> when we used the <span class="No-Break">spread operator.</span></p>
			<p>There are three distinct but similar ways to implement this decoupling in JavaScript. The first argument in the list (<strong class="source-inline">arg0</strong>) will correspond to the object, and the other arguments (<strong class="source-inline">...args</strong>) to the actual ones for the called method. The three equivalent versions would be as follows, and <a id="_idIndexMarker499"/>any of them could be used as a <strong class="source-inline">demethodize()</strong> function; pick your favorite! Let’s go with a plain JavaScript version to understand how they work; see <em class="italic">Question 6.15</em> for <span class="No-Break">TypeScript versions:</span></p>
			<pre class="source-code">
// demethodize.ts
const demethodize1 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.apply(arg0, args);
const demethodize2 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.call(arg0, ...args);
const demethodize3 =
  (fn) =&gt;
  (arg0, ...args) =&gt;
    fn.bind(arg0, ...args)();</pre>
			<p class="callout-heading">A fourth way</p>
			<p class="callout">There’s yet another way of doing this: <strong class="source-inline">const demethodize = Function.prototype.bind.bind(Function.prototype.call)</strong>. If you want to understand how this works, read Leland Richardson’s <em class="italic">Clever Way to Demethodize Native JS Methods</em>, <span class="No-Break">at </span><a href="http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods"><span class="No-Break">www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods</span></a><span class="No-Break">.</span></p>
			<p>Let’s look at some applications of these! Let’s start with a simple one that will also serve as a warning. We <a id="_idIndexMarker500"/>can make the <strong class="source-inline">sort()</strong> method into a function – but don’t think it will be <span class="No-Break">made pure!</span></p>
			<pre class="source-code">
const sort = demethodize1(Array.prototype.sort);
const a = ["delta", "alfa", "beta", "gamma", "epsilon"];
const b = <strong class="bold">sort(a)</strong>;
console.log(a, b);
// [ 'alfa', 'beta', 'delta', 'epsilon', 'gamma' ] twice!</pre>
			<p>Now we can use <strong class="source-inline">sort()</strong> as a function – but it still produces the same side effect; <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> are the same array since <strong class="source-inline">sort()</strong> keeps working “<span class="No-Break">in place.”</span></p>
			<p>A more contrived case: we can use <strong class="source-inline">map()</strong> to loop over a string without converting it into an array of characters first. Say you wanted to separate a string into individual letters and make them uppercase; we could achieve this by using <strong class="source-inline">split()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">toUpperCase()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const name = "FUNCTIONAL";
const result = name.split("").map((x) =&gt; x.toUpperCase());
// ["F", "U", "N", "C", "T", "I", "O", "N", "A", "L"]</pre>
			<p>By demethodizing <strong class="source-inline">map()</strong> and <strong class="source-inline">toUpperCase()</strong>, we can simply write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const map = <strong class="bold">demethodize1(Array.prototype.map)</strong>;
const toUpperCase = <strong class="bold">demethodize2(</strong>
<strong class="bold">  String.prototype.toUpperCase</strong>
<strong class="bold">)</strong>;
const result2 = <strong class="bold">map(name, toUpperCase)</strong>;
// ["F", "U", "N", "C", "T", "I", "O", "N", "A", "L"]</pre>
			<p>Yes, of course, for <a id="_idIndexMarker501"/>this particular case, we could have turned the string into uppercase and then split it into separate letters, as in <strong class="source-inline">name.toUpperCase().split("")</strong>, but it wouldn’t have been such a nice example, with two usages of demethodizing <span class="No-Break">being used.</span></p>
			<p>Similarly, we could convert an array of decimal amounts into properly formatted strings with thousands separators and <span class="No-Break">decimal points:</span></p>
			<pre class="source-code">
const toLocaleString = demethodize3(
  Number.prototype.toLocaleString
);
const numbers = [2209.6, 124.56, 1048576];
const strings = <strong class="bold">numbers.map(toLocaleString)</strong>;
console.log(strings);
/*
[ '2.209,6', '124,56', '1.048.576' ] // Uruguay Locale
*/</pre>
			<p>Alternatively, given the preceding demethodized <strong class="source-inline">map()</strong> function, we could have done the mapping with <strong class="source-inline">map(numbers, </strong><span class="No-Break"><strong class="source-inline">toLocaleString)</strong></span><span class="No-Break"> instead.</span></p>
			<p>The idea of demethodizing a method to turn it into a function will prove to be quite useful in diverse situations. <a id="_idIndexMarker502"/>We have already seen some examples where we could have applied it, and there will be more such cases in the rest of <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Methodizing – turning functions into methods</h2>
			<p>In the previous section, we saw how we could separate methods from objects to transform them <a id="_idIndexMarker503"/>into independent, standalone functions. Then, for fairness, let’s consider the complementary transformation, adding a function (as a method) to objects. We should call this operation <em class="italic">methodizing</em>, <span class="No-Break">shouldn’t we?</span></p>
			<p>We already saw something of this when we defined and worked with polyfills in the <em class="italic">Adding missing functions</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions</em>. Modifying prototypes is usually frowned upon because of the possibility of clashes with different libraries, at the very least. However, it’s an interesting technique, so let’s study <span class="No-Break">it anyway.</span></p>
			<h3>Reversing strings</h3>
			<p>Let’s start with a simple example. Back in the <em class="italic">Folding left and right</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively,</em> we defined a <strong class="source-inline">reverseString()</strong> function to reverse a string. Since we already have a <strong class="source-inline">reverse()</strong> method <a id="_idIndexMarker504"/>that works with arrays, we could implement a <strong class="source-inline">reverse()</strong> method for strings. For variety, let’s do a new implementation of the string-reversing logic. We’ll add a Boolean parameter; if set to <strong class="source-inline">true</strong>, the function will add dashes between letters; this is just to show that methodizing also works with functions with more parameters. What we want to achieve is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
"ABCDE".reverse();     // "EDCBA"
"ABCDE".reverse(true); // "E-D-C-B-A"</pre>
			<p>The needed function is as follows (as a curiosity, note that we are using the array <strong class="source-inline">reverse()</strong> method to implement our <strong class="source-inline">reverse()</strong> <span class="No-Break">string one!):</span></p>
			<pre class="source-code">
// methodize.ts
function reverse(x: string, y = false): string {
  return x
    .split("")
    .reverse()
    .join(y ? "-" : "");
}</pre>
			<p>We used a standard function (instead of an arrow one) because of the implicit handling of <strong class="source-inline">this</strong>, which wouldn’t be bound otherwise. Another crucial detail: the first argument to the function must be the string with which it <span class="No-Break">will operate.</span></p>
			<p>Now, we must tell TypeScript that we’ll be extending the <strong class="source-inline">String.prototype</strong> object with a <a id="_idIndexMarker505"/>new method (see <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html">www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html</a> for more <span class="No-Break">on this):</span></p>
			<pre class="source-code">
// continued...
declare global {
  interface String {
    <strong class="bold">reverse(y?: boolean): string;</strong>
  }
}</pre>
			<p>Without this <a id="_idIndexMarker506"/>definition (which could also have been in a separate <strong class="source-inline">.d.ts</strong> file), when we try to assign the new method, we’ll get the error shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_6.4_B19301.jpg" alt="Figure 6.4 – You cannot add new methods to an existing object without an extra definition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – You cannot add new methods to an existing object without an extra definition</p>
			<p>How do we add a new method to the <strong class="source-inline">String.prototype</strong> object? In essence, we want to achieve <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">String.prototype.reverse</strong> = function (
  this: string,
  y
): string {
  <strong class="bold">return reverse(this, y);</strong>
};</pre>
			<p>We add a function that calls our original one. Note that <strong class="source-inline">this</strong> (the current string object) is passed as the first argument. Other parameters are passed untouched. We can implement all this with a <strong class="source-inline">methodize()</strong> function; let’s see it first in JavaScript and then get into typing details. We want to do the following to <span class="No-Break">achieve this:</span></p>
			<pre class="source-code">
// continued...
function <strong class="bold">methodize(obj, fn)</strong> {
<strong class="bold">  obj.prototype[fn.name] = function (...args) {</strong>
<strong class="bold">    return fn(this, ...args);</strong>
<strong class="bold">  };</strong>
}</pre>
			<p>This is what we <a id="_idIndexMarker507"/>did before. We are using the function’s name for the newly added method’s name. In TypeScript, this is a bit more complex, but we need the data type checks, so let’s <span class="No-Break">do this:</span></p>
			<pre class="source-code">
function methodize&lt;
  T extends any[],
  O extends { prototype: { [key: string]: any } },
  F extends (arg0: any, ...args: T) =&gt; any
&gt;(obj: O, fn: F) {
  obj.prototype[fn.name] = function (
    <strong class="bold">this: Parameters&lt;F&gt;[0],</strong>
<strong class="bold">    ...args: T</strong>
  ): <strong class="bold">ReturnType&lt;F&gt;</strong> {
    return fn(this, ...args);
  };
}</pre>
			<p>Let’s see the data types <span class="No-Break">we added:</span></p>
			<ul>
				<li><strong class="source-inline">T</strong> is the generic type of the parameters that we’ll pass to our new <span class="No-Break">methodized function</span></li>
				<li><strong class="source-inline">O</strong> is the object’s type to whose prototype we’ll add the <span class="No-Break">new method</span></li>
				<li><strong class="source-inline">F</strong> is the function we’ll be methodizing; the first argument (<strong class="source-inline">arg0</strong>) is key, and we’ll be assigned the value of <strong class="source-inline">this</strong>. The other arguments (if any) are of a <span class="No-Break"><strong class="source-inline">T</strong></span><span class="No-Break"> type</span></li>
			</ul>
			<p>How do we use this <strong class="source-inline">methodize()</strong> function? Simple, with just <span class="No-Break">one line:</span></p>
			<pre class="source-code">
methodize(String, reverse);</pre>
			<p>With this, we <a id="_idIndexMarker508"/>can use our new method <span class="No-Break">as planned:</span></p>
			<pre class="source-code">
console.log("MONTEVIDEO".reverse());
// OEDIVETNOM
console.log("MONTEVIDEO".reverse(true));
// O-E-D-I-V-E-T-N-O-M</pre>
			<h3>Averaging arrays</h3>
			<p>Let’s see one more <a id="_idIndexMarker509"/>example, to highlight a possible detail with typing. We’ll take the <strong class="source-inline">average()</strong> function that we wrote in the <em class="italic">Calculating an average</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Programming Declaratively,</em> and add it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Array.prototype</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
function average(<strong class="bold">x: number[]</strong>): number {
  return (
    x.reduce((x: number, y: number) =&gt; x + y, 0) / x.length
  );
}</pre>
			<p>The problem is that we want our function to only apply to arrays of numbers. We want TypeScript to detect and reject a line such as the following because of the wrong data type of <span class="No-Break">the array:</span></p>
			<pre class="source-code">
const xx = ["FK", "ST", "JA", "MV"].average();</pre>
			<p>When writing the global declaration for the added method, an error will <span class="No-Break">pop up:</span></p>
			<pre class="source-code">
// methodize.ts
declare global {
 <strong class="bold"> // eslint-disable @typescript-eslint/no-unused-vars</strong>
<strong class="bold"> </strong> interface Array&lt;T&gt; {
<strong class="bold">    average(): number;</strong>
  }
}</pre>
			<p>The definition of <strong class="source-inline">Array</strong> must be bound to a generic <strong class="source-inline">Array&lt;T&gt;</strong>. However, our definition for <strong class="source-inline">average()</strong> doesn’t depend on <strong class="source-inline">T</strong>. This means we have an unused definition to which ESLint objects. Since there’s no way of including <strong class="source-inline">T</strong> in our function, we’ll have to tell ESLint to let the error be; no <span class="No-Break">other solution!</span></p>
			<p>There’s nothing <a id="_idIndexMarker510"/>more to this; we can now methodize the <strong class="source-inline">average()</strong> function and use it as <span class="No-Break">a method:</span></p>
			<pre class="source-code">
methodize(Array, average);
const myAvg = [22, 9, 60, 12, 4, 56]<strong class="bold">.average()</strong>; // 27.166667</pre>
			<p>You can now extend all base classes as desired – but remember our advice about being very, <span class="No-Break">very careful!</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Finding the optimum</h2>
			<p>Let’s end this <a id="_idIndexMarker511"/>section by creating an extension of the <strong class="source-inline">find()</strong> method. Suppose <a id="_idIndexMarker512"/>we want to find the optimum value – let’s suppose it’s the maximum – of an array of numbers. We could make do <span class="No-Break">with this:</span></p>
			<pre class="source-code">
// optimum.ts
const findOptimum = (arr: number[]): number =&gt;
  Math.max(...arr);
const myArray = [22, 9, 60, 12, 4, 56];
console.log(findOptimum(myArray)); // 60</pre>
			<p>Now, is this sufficiently general? There are at least a pair of problems with this approach. First, are you sure that the optimum of a set will always be the maximum? If you were considering several mortgages, the one with the lowest interest rate would be the best, right? To assume that you always want the maximum of a set is <span class="No-Break">too constrictive.</span></p>
			<p class="callout-heading">A negative maximum?</p>
			<p class="callout">You could do a roundabout trick: if you change the signs of all the numbers in an array, find its maximum, and change its sign, you actually get the minimum of the array. In our case, <strong class="source-inline">-findOptimum(myArray.map((x) =&gt; -x))</strong> would correctly produce <strong class="source-inline">4</strong>, but it’s not easily <span class="No-Break">understandable code.</span></p>
			<p>Second, this way of finding the maximum depends on each option having a numeric value. But how <a id="_idIndexMarker513"/>would you find the optimum if such a value didn’t exist? The <a id="_idIndexMarker514"/>usual way depends on comparing elements with each other and picking the one that comes out <span class="No-Break">on top:</span></p>
			<ol>
				<li value="1">Compare the first element with the second and keep the best of <span class="No-Break">those two.</span></li>
				<li>Then compare that value with the third element and keep <span class="No-Break">the best.</span></li>
				<li>Keep at it until you have finished going through all <span class="No-Break">the elements.</span></li>
			</ol>
			<p>The way to solve this problem with more generality is to assume the existence of a comparator function, which takes two elements as arguments and returns the best of those. If you could associate a numeric value with each element, the comparator function could simply compare those values. In other cases, it could do whatever logic is needed to decide what element comes out <span class="No-Break">on top.</span></p>
			<p>Let’s try to create an appropriate HOF; our newer version will use <strong class="source-inline">reduce()</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const findOptimum2 =
  &lt;T&gt;(fn: (x: T, y: T) =&gt; T) =&gt;
  (arr: T[]): T =&gt;
    arr.reduce(fn);</pre>
			<p>This generic function takes a comparator that returns the best of two elements of a <strong class="source-inline">T</strong> type and then applies that function to an array of elements of a <strong class="source-inline">T</strong> type to produce <span class="No-Break">the optimum.</span></p>
			<p>With this, we can easily replicate the maximum- and minimum-finding functions; we only have to provide the appropriate <span class="No-Break">reducing functions:</span></p>
			<pre class="source-code">
const <strong class="bold">findMaximum</strong> = findOptimum2(
  (x: number, y: number): number =&gt; <strong class="bold">(x &gt; y ? x : y)</strong>
);
const <strong class="bold">findMinimum</strong> = findOptimum2(
  (x: number, y: number): number =&gt; <strong class="bold">(x &lt; y ? x : y)</strong>
);
console.log(findMaximum(myArray)); // 60
console.log(findMinimum(myArray)); // 4</pre>
			<p>Let’s go one better <a id="_idIndexMarker515"/>and compare non-numeric values. Let’s imagine a <a id="_idIndexMarker516"/>superhero card game: each card represents a hero and has several numeric attributes, such as <strong class="source-inline">strength</strong>, <strong class="source-inline">powers</strong>, and <strong class="source-inline">tech</strong>. The corresponding class could be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
class Card {
  name: string;
  strength: number;
  powers: number;
  tech: number;
  constructor(n: string, s: number, p: number, t: number) {
    this.name = n;
    this.strength = s;
    this.powers = p;
    this.tech = t;
  }
}</pre>
			<p>When two heroes fight each other, the winner is the one with more categories with higher values than the other. Let’s implement a comparator for this; a suitable <strong class="source-inline">compareHeroes()</strong> function could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const compareHeroes = (card1: Card, card2: Card): Card =&gt; {
  const oneIfBigger = (x: number, y: number): number =&gt;
    x &gt; y ? 1 : 0;
  const wins1 =
    oneIfBigger(card1.strength, card2.strength) +
    oneIfBigger(card1.powers, card2.powers) +
    oneIfBigger(card1.tech, card2.tech);
  const wins2 =
    oneIfBigger(card2.strength, card1.strength) +
    oneIfBigger(card2.powers, card1.powers) +
    oneIfBigger(card2.tech, card1.tech);
  return wins1 &gt; wins2 ? card1 : card2;
};</pre>
			<p>Then, we can apply <a id="_idIndexMarker517"/>this to our tournament of heroes. First, let’s create <a id="_idIndexMarker518"/>our own league <span class="No-Break">of heroes:</span></p>
			<pre class="source-code">
const codingLeagueOfAmerica = [
  new Card("Forceful", 20, 15, 2),
  new Card("Electrico", 12, 21, 8),
  new Card("Speediest", 8, 11, 4),
  new Card("TechWiz", 6, 16, 30),
];</pre>
			<p>With these definitions, we can write a <strong class="source-inline">findBestHero()</strong> function to get the <span class="No-Break">top hero:</span></p>
			<pre class="source-code">
const findBestHero = findOptimum2(compareHeroes);
console.log(findBestHero(codingLeagueOfAmerica));
// Electrico is the top Card!</pre>
			<p class="callout-heading">Order does matter</p>
			<p class="callout">When you rank elements according to one-to-one comparisons, unexpected results may be produced. For instance, with our superheroes comparison rules, you could find three heroes where the results show that the first beats the second, the second beats the third, but the third beats the first! In mathematical terms, the comparison function is <em class="italic">not transitive</em>, and you don’t have a <em class="italic">total ordering</em> for <span class="No-Break">the set.</span></p>
			<p>With this, we have seen several ways of modifying functions to produce newer variants with enhanced processing; think of particular cases you might be facing and consider whether an HOF might help <span class="No-Break">you out.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
			<p>In this chapter, we learned how to write HOFs of our own that can either wrap another function to provide some new feature, alter a function’s objective so that it does something else, or even provide totally new features, such as decoupling methods from objects or creating better finders. The main takeaway from this chapter is that you have a way of modifying a function’s behavior without actually having to modify its own code; HOFs can manage this in an <span class="No-Break">orderly way.</span></p>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, we’ll keep working with HOFs and learn how to produce specialized versions of existing functions with predefined arguments by using currying and <span class="No-Break">partial application.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Questions</h1>
			<p>6.1 <strong class="bold">Go with arrows</strong>: We implemented <strong class="source-inline">addLogging()</strong> using a function, and its typing was not simple. Just to deal with a different syntax, can you provide an alternate implementation of <strong class="source-inline">addLogging()</strong> but using an <span class="No-Break">arrow function?</span></p>
			<p>6.2 <strong class="bold">Mapping for memory</strong>: We implemented our memoizing functions by using an object as a cache. However, using a map would be better; make the <span class="No-Break">necessary changes.</span></p>
			<p>6.3 <strong class="bold">How many?</strong> How many calls would be needed to calculate <strong class="source-inline">fib(50)</strong> without memoizing? For example, one call and no further recursion were needed to calculate <strong class="source-inline">fib(0)</strong> or <strong class="source-inline">fib(1)</strong>, and 25 calls were required for <strong class="source-inline">fib(6)</strong>. Can you find a formula to do <span class="No-Break">this calculation?</span></p>
			<p>6.4 <strong class="bold">A randomizing balancer</strong>: Write an HOF, that is, <strong class="source-inline">randomizer(fn1, fn2, ...)</strong>, that will receive a variable number of functions as arguments and return a new function that will, on each call, randomly call one of <strong class="source-inline">fn1</strong>, <strong class="source-inline">fn2</strong>, and so on. You could use this to balance calls to different services on a server if each function did an AJAX call. For bonus points, ensure that no function will be called twice in <span class="No-Break">a row.</span></p>
			<p>6.5 <strong class="bold">Not in TypeScript</strong>: Write the fully typed TypeScript version of our <strong class="source-inline">not()</strong> and <span class="No-Break"><strong class="source-inline">invert()</strong></span><span class="No-Break"> functions.</span></p>
			<p>6.6 <strong class="bold">Just say no!</strong> In this chapter, we wrote a <strong class="source-inline">not()</strong> function that worked with Boolean functions and a <strong class="source-inline">negate()</strong> function that worked with numerical ones. Can you go one better and write a single <strong class="source-inline">opposite()</strong> function that will behave as <strong class="source-inline">not()</strong> or <strong class="source-inline">negate()</strong>, <span class="No-Break">as needed?</span></p>
			<p>6.7 <strong class="bold">Invert tests</strong>: Write some tests for <strong class="source-inline">invert()</strong>, <span class="No-Break">as suggested.</span></p>
			<p>6.8 <strong class="bold">Why not shorter?</strong> If we write the <strong class="source-inline">filterNot()</strong> function with a slight change, as shown here, TypeScript will <span class="No-Break">object; why?</span></p>
			<pre class="source-code">
const filterNot2 =
  &lt;A, T extends (x: A) =&gt; boolean&gt;(arr: A[]) =&gt;
  (fn: T): A[] =&gt;
    arr.filter(<strong class="bold">not(fn)</strong>);</pre>
			<p>6.9 <strong class="bold">Wrong function length</strong>: Our <strong class="source-inline">arity()</strong> function works well, but the produced functions don’t have the correct <strong class="source-inline">length</strong> attribute. Can you write a different arity-changing function without <span class="No-Break">this defect?</span></p>
			<p>6.10 <strong class="bold">Many arities!</strong> Can you write TypeScript versions of <strong class="source-inline">binary()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ternary()</strong></span><span class="No-Break">?</span></p>
			<p>6.11 <strong class="bold">Throttling promises</strong>: If you memoize an <strong class="source-inline">async</strong> function, every time you call it with the same arguments, you’ll get the same promise as a result. But imagine we were calling a weather API, which updates its data every 5 minutes. We don’t want to call it just once and never again (as with memoization), but we don’t want to call it every time either. Can you add throttling behavior to our <strong class="source-inline">promiseMemoize()</strong> function so, after a given delay, a new call to the API will <span class="No-Break">be made?</span></p>
			<p>6.12 <strong class="bold">All operators called</strong>: When writing a full <strong class="source-inline">binaryOp()</strong> function that would work with numbers, what is the list of all the operators you <span class="No-Break">should consider?</span></p>
			<p>6.13 <strong class="bold">Missing companion</strong>: If we have a <strong class="source-inline">getField()</strong> function, we should also have a <strong class="source-inline">setField()</strong> function, so can you define it? We’ll need both in <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, when we work with getters, setters, and lenses. Note that <strong class="source-inline">setField()</strong> shouldn’t directly modify an object; instead, it should return a new object with a changed value – it should be a <span class="No-Break">pure function!</span></p>
			<p>6.14 <strong class="bold">A border case</strong>: What happens with our <strong class="source-inline">getField()</strong> function if we apply it to a null object? What should its behavior be? If necessary, modify the function. This question has different answers in JavaScript and TypeScript; <span class="No-Break">be careful!</span></p>
			<p>6.15 <strong class="bold">Typed demethodizing</strong>: Provide TypeScript fully typed versions of our trio of <strong class="source-inline">demethodize()</strong> functions. A tip: once you get one of them right, the other two will be <span class="No-Break">pretty similar!</span></p>
			<p>6.16 <strong class="bold">Not reinventing the wheel</strong>: When we wrote <strong class="source-inline">findMaximum()</strong> and <strong class="source-inline">findMinimum()</strong>, we wrote our own functions to compare two values – but JavaScript already provides appropriate functions for that! Can you figure out alternative versions of our code based on <span class="No-Break">that hint?</span></p>
			<p>6.17 <strong class="bold">Comparing heroes</strong>: Why didn’t we just write <strong class="source-inline">const wins2 = 3 – wins1</strong> in our <strong class="source-inline">compareHeroes()</strong> function? Wouldn’t that have been faster? Or even better: avoid calculating <strong class="source-inline">wins2</strong> at all, and change the final line to <strong class="source-inline">return wins1 &gt;= </strong><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">?</span></p>
		</div>
	</body></html>