<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Single Page App using Web Components</h1>
                </header>
            
            <article>
                
<p><span> So far, we have been using Web Components as an individual entity. But Web Components can be used to make something even more complicated. In this chapter, we will be making a single page web app, solely with the help of Web Components.</span></p>
<p><span>In this chapter, we'll cover the following topics:</span></p>
<ul>
<li class="h1">Understanding project requirements</li>
<li class="h1">Figuring out reusable Web Components</li>
<li class="h1">Configuring starter project and APIs</li>
<li class="h1">App components</li>
<li class="h1">Other components</li>
<li class="h1">Implementing routing</li>
<li class="h1">Enabling analytics</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding project requirements</h1>
                </header>
            
            <article>
                
<p>When it comes to a single-page web app, it can be anything from one page to a thousand pages that you can show on the web app. But for the simplicity of this web app, we will keep it to a maximum of three pages. And the project that we will be trying to create is a GIF collection web app.</p>
<p>We all have been on the internet, and seen how memes and GIFs circulate. In this web app, we will be building something like a GIF repository. The purpose of this web app is to let the user see a list of trending GIFs, search for a specific topic, or maybe see a random GIF.</p>
<p>What we are also going to do is use the GIPHY API to get the GIFs. This way, we won't have to worry about manually scanning the web for GIFs.</p>
<p>Now that we have a basic understanding of our web app and the purpose behind it, let's take a look at how we can convert this requirement into a set of reusable Web Components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Figuring out reusable Web Components</h1>
                </header>
            
            <article>
                
<p>The main page of the web app we're aiming to create might look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/87b5895f-061c-49f0-b00d-0f97962a9ea7.png" style="width:38.83em;height:24.42em;"/></p>
<p>This page shows that there is a header on top, an input field and a button that can be used to search a string, and a set of results. When we break this page into a set of components, the component list looks something like this:</p>
<ul>
<li><strong>Header component</strong>: A header that can be used on all pages. It needs to be sticky on the top, and clicking on the links should change the URL.</li>
<li><strong>GIF cover component</strong>: A component that takes a URL as an attribute and shows it. It can also have a height limit. </li>
<li><strong>Search bar component</strong>: A component that is responsible for getting input from a user and searching for a string with the help of APIs. And when the search is complete, it returns the results with the help of a custom event.</li>
<li><strong>Search container</strong>: A component that will have a <span class="packt_screen">Search</span> bar component inside it, and will show GIF cover components based on the result obtained by the <span class="packt_screen">Search</span> bar.</li>
</ul>
<p>Let's take a look at the trending page. What this page is supposed to do, just like the search page, is show a collection of GIFs, but instead of making the user search for a specific string, it needs to show the trending GIFs. You should be able to find something similar on the Giphy site: <a href="https://giphy.com/trending-gifs">https://giphy.com/trending-gifs</a>.</p>
<p>This is what it will look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88992eb6-5012-49cc-9d71-433662a668eb.png" style="width:32.58em;height:26.83em;"/></p>
<p>As you can see, it doesn't look that much different from the search page. Let's break down the page into Web Components:</p>
<ul>
<li><strong>Header component</strong>: Same as previously</li>
<li><strong>GIF cover</strong>: The same component that we used on the last page to show GIFs</li>
<li><strong>Show Trending component</strong>: The container component that will make the call to the API to get trending GIFs and create a collection of GIF Cover components</li>
</ul>
<p>In all, we will be using just three components for this page. </p>
<p>Let's take a look at the last page. This page is responsible for showing a randomly generated GIF, and this is what it will look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e9e198e-da21-4a71-92b6-cd30a84f8dd7.png" style="width:29.33em;height:14.58em;"/></p>
<p>As you can see, there is a header at the top, a random GIF, and a button to get another random GIF. Let's break it down into Web Components:</p>
<ul>
<li><strong>Header component</strong>: <span>Same as previously.<br/></span></li>
<li><strong>GIF cover</strong>: Same as the last one, but we won't be seeing a lot of them. </li>
<li><strong>Show Random component</strong>: A component that is responsible for making the API call to get a random GIF. It also needs to have a button that needs to trigger the API again when it is clicked. </li>
</ul>
<p>Now that we know what Web Components are required for this project, let's start working on it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Starter Project and APIs</h1>
                </header>
            
            <article>
                
<p>A starter project is the most minimalistic project that is configured for a single page web app. You can download it from the <kbd>Starter Project</kbd> directory and put it anywhere on your computer via the following link: <a href="https://github.com/PacktPublishing/Getting-Started-with-Web-Components/tree/master/Chapter06">https://github.com/PacktPublishing/Getting-Started-with-Web-Components/tree/master/Chapter06</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-requisites</h1>
                </header>
            
            <article>
                
<p>Before you start using this project, make sure that you have Node.js installed on your computer. You can install it from the <span>Node.js</span> website (<a href="https://nodejs.org/en/" target="_blank">https://nodejs.org/en/</a>) or, if you want, you can use Homebrew (<a href="https://brew.sh/" target="_blank">https://brew.sh/</a>) to install it.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the project</h1>
                </header>
            
            <article>
                
<p>Once you are done installing Node.js, you will need to install certain packages that would make the project work without doing a lot of manual configurations at our end. All the packages are already specified in the <kbd>package.json</kbd> file. If you want, feel free to look at the contents of this file. The most important package is <kbd>webpack</kbd>, which is going to be used for bundling our code so that it can be served on a server. Another important package is <kbd>node-sass</kbd>. It will help us write our code in SCSS.</p>
<div class="packt_infobox">I am assuming that you know a little bit of SCSS. It is mostly CSS, but if you get confused, feel free to take a look at the SCSS documentation (<a href="https://sass-lang.com/documentation/syntax" target="_blank">https://sass-lang.com/documentation/synta</a><a href="https://sass-lang.com/documentation/syntax" target="_blank">x</a>).</div>
<p>You can install the packages involved by typing the following steps in the Terminal:</p>
<pre><strong>cd Chapter\ 06/Starter\ Project/</strong><br/><strong>npm install</strong></pre>
<p>This will install all the packages that will be required for this project. It might take a few minutes though, based on the speed of your internet connection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Starter Project</h1>
                </header>
            
            <article>
                
<p>Now that we have installed all our dependencies, it is time to run the Starter Project and see what it looks like.</p>
<p>To start the project, run the following command in the Terminal:</p>
<pre><strong>npm start</strong></pre>
<p>This will show you the following output:</p>
<pre><strong>&gt; </strong><strong>node webpack.dev.server</strong><br/><br/><strong>Hash: ecc08467bc66f8944b6b</strong><br/><strong>Version: webpack 3.12.0</strong><br/><strong>Time: 1284ms</strong><br/><strong>    Asset Size Chunks Chunk Names</strong><br/><strong>bundle.js 19.3 kB 0 [emitted] main</strong><br/><strong>   [0] ./src/index.js 131 bytes {0} [built]</strong><br/><strong>   [1] ./src/styles.scss 1.13 kB {0} [built]</strong><br/><strong>   [2] ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/styles.scss 225 bytes {0} [built]</strong><br/><strong>   [3] ./node_modules/css-loader/lib/css-base.js 2.26 kB {0} [built]</strong><br/><strong>   [4] ./node_modules/style-loader/lib/addStyles.js 8.7 kB {0} [built]</strong><br/><strong>   [5] ./node_modules/style-loader/lib/urls.js 3.01 kB {0} [built]</strong><br/><strong>   [6] ./src/components/my-app/index.js 541 bytes {0} [built]</strong><br/><strong>webpack: Compiled successfully.</strong></pre>
<p>This means that webpack is done creating a <kbd>bundle.js</kbd> file from the six listed files. And, you can simply go to a browser and open the following URL: <kbd>http://localhost:3000</kbd>.</p>
<p>This will show our starter project with the text <span class="packt_screen">My App</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-requisite for API calls</h1>
                </header>
            
            <article>
                
<p>You, as a user, will need to register for an API key and this can be done by following the steps as shown here:</p>
<ol>
<li>Go to the following URL and register for a free account: <a href="https://developers.giphy.com" target="_blank">https://developers.giphy.com</a></li>
<li>Once you are done creating an account, create an app by clicking on the <span class="packt_screen">Create New App</span> button at the top, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae35e90b-8157-4e3a-96c5-ffb0a8f75e8c.png" style="width:30.33em;height:21.50em;"/></p>
<ol start="3">
<li>Once you are done creating the app, you will be dropped onto a dashboard page where you can see your registered apps along with the API key required, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6270799a-1f18-4356-9ad5-9788b821f758.png" style="width:35.92em;height:23.08em;"/></p>
<div class="packt_infobox">If you have a moment, feel free to take a look at the API docs: <a href="https://developers.giphy.com/docs/" target="_blank">https://developers.giphy.com/docs/</a>.</div>
<p>But you don't have to worry about the APIs too much; we will be talking about this when we talk about components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">App components</h1>
                </header>
            
            <article>
                
<p>Before we take a look at the <kbd>&lt;my-app&gt;</kbd> component, let's take a look at what happens when you go to <kbd>localhost:3000</kbd>. The <kbd>index.html</kbd> file runs. The contents of <kbd>index.html</kbd> look something like this:</p>
<pre>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;My App&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;my-app&gt;&lt;/my-app&gt;<br/>    &lt;script src="bundle.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>As you can see, it is trying to render the <kbd>&lt;my-app&gt;</kbd> component. But it tries to get the definition of <kbd>MyApp</kbd> from the <kbd>bundle.js</kbd> file. This <kbd>bundle.js</kbd> file, as discussed earlier, is a collection of all the components that are required on the page and will be required by the <kbd>&lt;my-app&gt;</kbd> component. This <kbd>bundle.js</kbd> file is created with the help of webpack. And the configuration of the <kbd>bundle.js</kbd> file can be found in the <kbd>webpack.config.js</kbd> file, which looks something like this:</p>
<pre>entry: './src/index.js',</pre>
<p>The entry file that is chosen is the <kbd>/src/index.js</kbd> file. But then again, where does the <kbd>bundle.js</kbd> part come from? If you look at the bottom in the <kbd>webpack.config.js</kbd> file, you will see something like this:</p>
<pre>output: {<br/>  filename: 'bundle.js',<br/>  path: path.resolve(__dirname, 'dist')<br/>},</pre>
<p>Here, we are making sure that everything that is inside the entry file, <kbd>/src/index.js</kbd>, gets written to the <kbd>bundle.js</kbd> file. You can definitely modify this file if you have experience with webpack. But for the sake of simplicity, we are going to leave it as is.</p>
<p>Let's take a look at the <kbd>/src/index.js</kbd> file:</p>
<pre>import './styles.scss';<br/><br/>import MyApp from './components/my-app';<br/>customElements.define('my-app', MyApp);</pre>
<p>What we are seeing here is that, it is importing a <kbd>styles.scss</kbd> file, which can be used to store our global styles, and then it is importing our <kbd>MyApp</kbd> class from the <kbd>/components/my-app</kbd> folder. And then, it defines the custom element. This is something that we have already looked into in <a href="a40f739f-c213-4862-a256-a7e76eff4370.xhtml" target="_blank">Chapter 1</a>, <em>Web Components Essentials and Specifications</em>.</p>
<p>If we look into the <kbd>MyApp</kbd> class, we will find that there is nothing different than what we have already learned in the previous chapters. </p>
<p><span>The </span><kbd>constructor()</kbd><span> method is no different:</span></p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/>  this.render();<br/>}</pre>
<p><span>The </span><kbd>render()</kbd><span> method is pretty simple as well:</span></p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}</pre>
<p><span>The </span><kbd>getStyle()</kbd><span> and </span><kbd>getTemplate()</kbd><span> methods are the </span>same<span> as well; no different from what we have learned previously:</span></p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;div&gt;<br/>      My App<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}<br/><br/>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p class="mce-root">With the help of the code here, we can understand how the app component works and how it is the most important Web Component in order to make our single page web app work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional components</h1>
                </header>
            
            <article>
                
<p>Now that we know what the <kbd>&lt;my-app&gt;</kbd> component looks like and what it needs to work, let's start writing the components that we discussed in the beginning of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;gif-cover&gt; Web Component</h1>
                </header>
            
            <article>
                
<p class="mce-root">As discussed earlier, the purpose of this web component is to show a GIF. And, from the screenshots, we can see that it is one of the most reusable components of the project. So, let's start writing its code:</p>
<pre>export default class GifCover extends HTMLElement {<br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    // lets get the url from attribute<br/>    this.url = this.getAttribute('url');<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>    this.render();<br/>  }<br/><br/>  ...<br/>}</pre>
<p>In the <kbd>constructor()</kbd>, we are using <kbd>this.url</kbd> to grab the URL from the attribute. We will be using this URL as a source for the image, as shown in the following code:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div&gt;<br/>      &lt;img class="gif-cover__image"<br/>        src="${this.url}" /&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>We will also need styles for this component; we can achieve this by adding the following:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .gif-cover__image {<br/>        height: 150px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>As you can see, the only limitation that we are putting on this component is the image height. You can definitely remove it if you don't like it.</p>
<p>Once our <kbd>&lt;gif-cover&gt;</kbd> web component is done, we can move on to another web component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;search-bar&gt; Web Component</h1>
                </header>
            
            <article>
                
<p>If we take a look at the <span class="packt_screen">Search</span> page, we will see that there is a search bar. The input field and the <span class="packt_screen">Search</span> button are a part of this <kbd>&lt;search-bar&gt;</kbd> component and are responsible for making API calls.</p>
<p>The API call that we will be using here is the GIPHY Search Endpoint API, <kbd>https://api.giphy.com/v1/gifs/search</kbd>.<a href="https://api.giphy.com/v1/gifs/search" target="_blank"/></p>
<div class="packt_infobox"><span>The preceding link is an API link. You cannot access it directly, but you can use it to grab data if you have a key.</span></div>
<p>You will need to provide it with your key, which can be obtained from your dashboard. And, you may want to take a look at the docs here: <a href="https://developers.giphy.com/docs/#operation--gifs-search-get" target="_blank">https://developers.giphy.com/docs/#operation--gifs-search-get</a>.</p>
<p>When you make a call to this API, it is going to return an array of objects, each representing a GIF and its metadata.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now that we know what API to use, let's take a look at the code:</p>
<pre>export default class SearchBar extends HTMLElement {<br/><br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    this.key = 'YOUR-KEY';<br/>    this.searchUrl = 'https://api.giphy.com/v1/gifs/search';<br/>    this.showlimit = 20;<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>    this.render();<br/>  }<br/><br/>  ...<br/>  ...<br/><br/>}</pre>
<p>The <kbd>constructor()</kbd> method contains your key (which you will get from the GIPHY dashboard), the search URL, which is the API URL, and the limit or the amount to show in one call. Let's take a look at the <kbd>render()</kbd> method:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="search-bar__container"&gt;<br/>      &lt;input type="text"<br/>        class="search-bar__search-field"<br/>        placeholder="Enter Search Text Here"&gt;<br/>      &lt;button class="search-bar__button"&gt;Search&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p>It is nothing unusual. We just have a text field and a button. And the styles look something like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .search-bar__container {<br/>        display: flex;<br/>      }<br/>      .search-bar__search-field {<br/>        flex: 1;<br/>        margin: 10px;<br/>        height: 50px;<br/>        font-size: 18px;<br/>        padding: 10px;<br/>        border-radius: 5px;<br/>        border: none;<br/>        color: #8e8e8e;<br/>      }<br/>      .search-bar__button {<br/>        margin: 10px;<br/>        width: 200px;<br/>        border: none;<br/>        font-size: 18px;<br/>        color: #5f5f5f;<br/>        cursor: pointer;<br/>      }<br/>      .search-bar__button:hover {<br/>        background: #68f583;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>Along with basic rendering, we will also need to add a click event for the button, so that it can make a call to the API:</p>
<pre>connectedCallback() {<br/>  this.shadowObj.querySelector('button')<br/>    .addEventListener('click', (e) =&gt; {<br/>      this.handleSearch();<br/>    });<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This way, when a user clicks on the button, it is going to trigger the <kbd>handleSearch()</kbd> method, which looks something like this:</p>
<pre>handleSearch() {<br/>  let value = this.shadowObj.querySelector('input').value;<br/><br/>  fetch(`${this.searchUrl}?api_key=${this.key}&amp;q=${value}&amp;limit=${this.showlimit}`)<br/>  .then(response =&gt; response.json())<br/>  .then((jsonResponse) =&gt; {<br/>    this.dispatchDataInEvent(jsonResponse.data);<br/>  });<br/><br/>}</pre>
<p>Here, in the <kbd>handleSearch()</kbd> function, we are first getting the value of the input field. This is the value that the user entered. Then, we are making a call to the API by concatenating the API URL. The URL looks like the following:</p>
<pre>`${this.searchUrl}?api_key=${this.key}&amp;q=${value}&amp;limit=${this.showlimit}`</pre>
<p>This will get the URL from the <kbd>searchUrl</kbd> variable, and the key from the <kbd>key</kbd> variable. The <kbd>value</kbd> is obtained from the input field. And the limit is obtained from the <kbd>showlimit</kbd> variable.</p>
<p>Once the call is made, and the promise resolves, it will call the <kbd>dispatchDataInEvent()</kbd> method:</p>
<pre>dispatchDataInEvent(data) {<br/>  this.dispatchEvent(new CustomEvent('search-complete', {<br/>    detail: {<br/>      data: data,<br/>    },<br/>    bubbles: true,<br/>  }));<br/>}</pre>
<p>This <kbd>dispatchDataInEvent()</kbd> method will be responsible for notifying the parent Web Component of the new data that is obtained after the call.</p>
<p>Now that we have created Web Components that can be reused in the <kbd>&lt;search-container&gt;</kbd> component, let's take a look at <kbd>&lt;search-container&gt;</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;search-container&gt; Web Component</h1>
                </header>
            
            <article>
                
<p>Since the <kbd>&lt;search-container&gt;</kbd> component is going to use the <kbd>&lt;gif-cover&gt;</kbd> and <kbd>&lt;search-bar&gt;</kbd> components, the outline of our component will look something like this:</p>
<pre>import SearchBar from '../search-bar';<br/>import GifCover from '../gif-cover';<br/><br/>export default class SearchContainer extends HTMLElement {<br/>    ...<br/>    ...<br/>    ...<br/>}</pre>
<p>We are simply importing the classes of the Web Components that are going to be used in this component. This is pretty much the exact same thing that we have used in our <kbd>index.html</kbd> files.</p>
<p>Let's take a look at the <kbd>constructor()</kbd> method:</p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>  this.registerOtherComponents();<br/>  this.render();<br/>}</pre>
<p>Here, we have a <kbd>registerOtherComponents()</kbd> method that we are calling before the <kbd>render()</kbd> method. This is also the first time we are registering a custom element inside another custom element:</p>
<pre>registerOtherComponents() {<br/>  if (typeof customElements.get('search-bar') === 'undefined') {<br/>    customElements.define('search-bar', SearchBar);<br/>  }<br/><br/>  if (typeof customElements.get('gif-cover') === 'undefined') {<br/>    customElements.define('gif-cover', GifCover);<br/>  }<br/>}</pre>
<p>Here, we are first checking if the component has already been registered or not. If it has not been registered yet, then it registers it. Usually, a browser spits out an error message if it tries to register a custom element twice. This check is to fix that problem. </p>
<p>Once we are done registering the Web Components, it's time to render:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="search-container__container"&gt;<br/>      &lt;search-bar&gt;&lt;/search-bar&gt;<br/>      &lt;div class="search-container__images"&gt;<br/>        &lt;p&gt;Try Searching for a tag in the search bar&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>Here, we are rendering the <kbd>&lt;search-bar&gt;</kbd> component, but we do not see the <kbd>&lt;gif-cover&gt;</kbd> component. This is because the <kbd>&lt;gif-cover&gt;</kbd> components are to be shown only when data is retrieved from the <kbd>&lt;search-bar&gt;</kbd> component, and that is done when the <kbd>&lt;search-bar&gt;</kbd> component dispatches a <kbd>search-complete</kbd> event. Let's take a look at the <kbd>connectedCallback()</kbd> callback to add this event handler:</p>
<pre>connectedCallback() {<br/>  this.shadowObj.querySelector('search-bar')<br/>    .addEventListener('search-complete', (e) =&gt; {<br/>      this.handleSearchData(e.detail.data);<br/>    });<br/>}</pre>
<p>Here, we are looking for the <kbd>&lt;search-bar&gt;</kbd> element and adding an event listener. When that event occurs, it is going to trigger the <kbd>handleSearchData()</kbd> method and pass the associated data into it:</p>
<pre>handleSearchData(data) {<br/>  data = data.map((val, index) =&gt; {<br/>    return `<br/>      &lt;gif-cover url=${val.images.downsized_medium.url}&gt;&lt;/gif-cover&gt;<br/>    `;<br/>  }).join('');<br/>  this.shadowObj.querySelector('.search-container__images')<br/>    .innerHTML = data;<br/>}</pre>
<p>Just like the student list example in the previous chapters, here we are creating an HTML collection of <kbd>&lt;gif-cover&gt;</kbd> Web Components with the URL obtained from the <kbd>data</kbd> array, and then appending this HTML to the <kbd>search-container__images</kbd> <kbd>div</kbd>. This will also make sure to replace the <kbd>&lt;gif-cover&gt;</kbd> with new data when the user searches for something else. </p>
<p>Also, the <kbd>getStyles()</kbd> method is important. This is what it looks like:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .search-container__container {<br/>        display: block;<br/>        padding: 10px;<br/>      }<br/>      .search-container__images {<br/>        display: flex;<br/>        padding: 10px;<br/>        flex-wrap: wrap;<br/>        box-sizing: border-box;<br/>        justify-content: space-evenly;<br/>      }<br/>      gif-cover {<br/>        flex-basis: 10%;<br/>        padding: 5px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>Now that we have our <kbd>&lt;search-container&gt;</kbd> Web Component all set, let's add it to the <kbd>&lt;my-app&gt;</kbd> component, as shown here:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;search-container&gt;&lt;/search-container&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>Also, don't forget to register the component, as shown in the following:</p>
<pre>if (typeof customElements.get('search-container') === 'undefined') {<br/>  customElements.define('search-container', SearchContainer);<br/>}</pre>
<p>This way, we can make sure that <kbd>SearchContainer</kbd> is initialized only once.</p>
<p>Feel free to run the code and see if you are able to see a search bar; clicking on the search button will return some results.</p>
<p>Let's take a look at the <kbd>&lt;show-trending&gt;</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;show-trending&gt; Web Component</h1>
                </header>
            
            <article>
                
<p>The purpose of the <kbd>&lt;show-trending&gt;</kbd> Web Component is to first make a call to the API and then show the most trending GIFs. For this component, the API that we will be using is, <kbd>https://api.giphy.com/v1/gifs/trending</kbd>.</p>
<p>Like the previous API, this also returns an array of objects that contains the URL and other metadata. To take a look at the documentation for this API, visit this link: <a href="https://developers.giphy.com/docs/#operation--gifs-trending-get" target="_blank">https://developers.giphy.com/docs/#operation--gifs-trending-get</a>.</p>
<p>Now that we know how the API works, lets take a look at the code for the <kbd>&lt;show-trending&gt;</kbd> Web Component:</p>
<pre>export default class ShowTrending extends HTMLElement {<br/><br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    this.key = 'YOUR_KEY';<br/>    this.url = 'https://api.giphy.com/v1/gifs/trending';<br/>    this.showlimit = 20;<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>    this.registerOtherComponents();<br/>    this.render();<br/><br/>  }<br/><br/>  ...<br/>  ...<br/> <br/>}</pre>
<p>Here, just like the <kbd>&lt;search-bar&gt;</kbd> components, we have a <kbd>key</kbd> variable for <kbd>YOUR_KEY</kbd>, the URL to store the API call, and the <kbd>showlimit</kbd> variable to set the max amount of data that can come from the API call.</p>
<p>We have already seen how our <kbd>registerOtherComponents()</kbd> method should work, as follows:</p>
<pre>registerOtherComponents() {<br/>  if (typeof customElements.get('gif-cover') === 'undefined') {<br/>    customElements.define('gif-cover', GifCover);<br/>  }<br/>}</pre>
<p>Also, don't forget to import the <kbd>GifCover</kbd> component:</p>
<pre>import GifCover from '../gif-cover';</pre>
<p>Let's take a look at the <kbd>render()</kbd> method:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="show-trending__container"&gt;<br/>      &lt;h2 class="show-trending__heading"&gt;Trending Gifs&lt;/h2&gt;<br/>      &lt;div class="show-trending__images"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p>Here, we just have a <kbd>show-trending__images</kbd> div that will have <kbd>&lt;gif-cover&gt;</kbd> Web Components once the API call is made.</p>
<p>The <kbd>getStyles()</kbd> method looks something like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .show-trending__heading {<br/>        text-align: center;<br/>      }<br/>      .show-trending__images {<br/>        display: flex;<br/>        padding: 10px;<br/>        flex-wrap: wrap;<br/>        box-sizing: border-box;<br/>        justify-content: space-evenly;<br/>      }<br/><br/>      gif-cover {<br/>        flex-basis: 10%;<br/>        padding: 5px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>Now that we have the component set up, it is time to make sure that the component makes the API call:</p>
<pre>connectedCallback() {<br/>  this.makeApiCall();<br/>}<br/><br/>makeApiCall() {<br/>  fetch(`${this.url}?api_key=${this.key}&amp;limit=${this.showlimit}`)<br/>  .then(response =&gt; response.json())<br/>  .then((jsonResponse) =&gt; {<br/>    this.handleTrendingData(jsonResponse.data);<br/>  });<br/><br/>}</pre>
<p class="mce-root"/>
<p>What we are doing is simply making the call when the component is connected and DOM is added to the page. Once we have the data from the <kbd>fetch</kbd> call, we pass this data to the <kbd>handleTrendingData()</kbd> method:</p>
<pre>handleTrendingData(data) {<br/><br/>  data = data.map((val, index) =&gt; {<br/>    return `<br/>      &lt;gif-cover url=${val.images.downsized_medium.url}&gt;&lt;/gif-cover&gt;<br/>    `;<br/>  }).join('');<br/><br/>  this.shadowObj.querySelector('.show-trending__images')<br/>    .innerHTML = data;<br/>}</pre>
<p>As you can see, this <kbd>handleTrendingData()</kbd> method is responsible for creating <kbd>&lt;gif-cover&gt;</kbd> Web Components, giving them GIF URLs, and adding them to the <kbd>show-trending__images</kbd> div.</p>
<p>Just like the <kbd>&lt;search-container&gt;</kbd> component, you can test the <kbd>&lt;show-trending&gt;</kbd> component inside the <kbd>&lt;my-app&gt;</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;show-random&gt; Web Component</h1>
                </header>
            
            <article>
                
<p>Just like the <kbd>&lt;show-trending&gt;</kbd> Web Component, this is a container Web Component. That means it will be using other components in a nested way. The component that it will be using is <kbd>&lt;gif-cover&gt;</kbd>. Let's see what the outline looks like:</p>
<pre>import GifCover from '../gif-cover';<br/><br/>export default class ShowRandom extends HTMLElement {<br/>    ...<br/>    ...<br/>    ...<br/>}</pre>
<p class="mce-root">And, the <kbd>constructor()</kbd> method looks something like this:</p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // the key required for api<br/>  this.key = 'YOUR_KEY';<br/><br/>  // the url used to get the random gif<br/>  this.url = 'https://api.giphy.com/v1/gifs/random';<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>  this.registerOtherComponents();<br/>  this.render();<br/>}</pre>
<p><span>Here, the API that we are using is,</span><span> </span><kbd>https://api.giphy.com/v1/gifs/random</kbd><span>.</span></p>
<p>Unlike the previous APIs, this one spits out only one object at a time. This object will have the URL and other metadata associated with a GIF. If you need more information on it, feel free to refer to the documentation: <a href="https://developers.giphy.com/docs/#operation--gifs-random-get" target="_blank">https://developers.giphy.com/docs/#operation--gifs-random-get</a></p>
<p>The <kbd>registerOtherComponents()</kbd> method looks exactly the same as the previous one:</p>
<pre>registerOtherComponents() {<br/>  // lets register other components used <br/>  if (typeof customElements.get('gif-cover') === 'undefined') {<br/>    customElements.define('gif-cover', GifCover);<br/>  }<br/>}</pre>
<p>Also, the <kbd>render()</kbd> method looks something like this:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;div class="show-random__container"&gt;<br/>      &lt;div class="show-random__images"&gt;&lt;/div&gt;<br/>      &lt;button class="show-random__button"&gt;Get Another Random <br/>      Image&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p>Here, we see that we have a div, <kbd>show-random__images</kbd>, to show the random image. And, there is a button right below it. The <kbd>getStyle()</kbd> method looks like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>      }<br/>      .show-random__container {<br/>        text-align: center;<br/>      }<br/>      .show-random__images {<br/>        display: flex;<br/>        padding: 10px;<br/>        flex-wrap: wrap;<br/>        box-sizing: border-box;<br/>        justify-content: space-evenly;<br/>      }<br/><br/>      .show-random__button {<br/>        margin: 10px;<br/>        border: none;<br/>        font-size: 18px;<br/>        color: #5f5f5f;<br/>        cursor: pointer;<br/>        padding: 10px;<br/>      }<br/><br/>      gif-cover {<br/>        flex-basis: 10%;<br/>        padding: 5px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now that the component is set up, let's make the API call:</p>
<pre>connectedCallback() {<br/>  this.handleRandom();<br/>}<br/><br/>handleRandom() {<br/>  fetch(`${this.url}?api_key=${this.key}`)<br/>  .then(response =&gt; response.json())<br/>  .then((jsonResponse) =&gt; {<br/>    this.handleTrendingData(jsonResponse.data);<br/>  });<br/><br/>}</pre>
<p>This <kbd>handleRandom()</kbd> function is responsible for making the API call, and when the data is retrieved, it passes it to the <kbd>handleTrendingData()</kbd> method:</p>
<pre>handleTrendingData(data) {<br/><br/>  this.shadowObj.querySelector('.show-random__images')<br/>    .innerHTML = `<br/>      &lt;gif-cover url=${data.image_url}&gt;&lt;/gif-cover&gt;<br/>    `;<br/>}</pre>
<p>We also need to make sure that the image refreshes when the button is clicked. So, we can add this event listener inside the <kbd>connectedCallback()</kbd> method to make it work:</p>
<pre>connectedCallback() {<br/>  this.handleRandom();<br/><br/>  this.shadowObj.querySelector('button')<br/>    .addEventListener('click', (e) =&gt; {<br/>      this.handleRandom();<br/>    });<br/>}</pre>
<p>This way, whenever the button is clicked, it will trigger the <kbd>handleRandom()</kbd> method again.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The &lt;my-app&gt; component</h1>
                </header>
            
            <article>
                
<p>Just like the <kbd>&lt;show-trending&gt;</kbd> and <kbd>&lt;search-container&gt;</kbd> components, you can test the <kbd>&lt;show-random&gt;</kbd> Web Component by adding the <kbd>&lt;show-random&gt;</kbd> component inside the <kbd>&lt;my-app&gt;</kbd> component. But if you want to integrate it all, I have a better option.</p>
<p>Let's take a look at the <kbd>&lt;my-app&gt;</kbd> component. If we want all these three components, we will need to include it first:</p>
<pre>import SearchContainer from '../search-container';<br/>import ShowTrending from '../show-trending';<br/>import ShowRandom from '../show-random';<br/><br/>export default class MyApp extends HTMLElement {<br/>    ...<br/>    ...<br/>    ...   <br/>}</pre>
<p>Now that we have these components imported, lets register these custom elements:</p>
<pre>registerOtherComponents() {<br/>  if (typeof customElements.get('search-container') === 'undefined') {<br/>    customElements.define('search-container', SearchContainer);<br/>  }<br/><br/>  if (typeof customElements.get('show-trending') === 'undefined') {<br/>    customElements.define('show-trending', ShowTrending);<br/>  }<br/><br/>  if (typeof customElements.get('show-random') === 'undefined') {<br/>    customElements.define('show-random', ShowRandom);<br/>  }<br/>}</pre>
<p>We can also add a <kbd>showSection</kbd> variable to keep track of what component to show at what time:</p>
<pre>constructor() {<br/>  ...<br/><br/>  // to show what section<br/>  this.shownSection = 1;<br/><br/>  ...<br/>}</pre>
<p class="mce-root"/>
<p>We are initially setting it to a value of <kbd>1</kbd>, so that it can show <kbd>&lt;search-container&gt;</kbd> by default.</p>
<p>And, to make it work, we will modify the <kbd>getTemplate()</kbd> method a little bit to look something like this:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;div class="app-section"&gt;<br/>      ${this.getSection(this.shownSection)}<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}<br/><br/>getSection(section) {<br/>  switch(section) {<br/>    case 1:<br/>      return `<br/>        &lt;search-container&gt;&lt;/search-container&gt;<br/>      `;<br/>    case 2:<br/>      return `<br/>        &lt;show-trending&gt;&lt;/show-trending&gt;<br/>      `;<br/>    case 3:<br/>      return `<br/>        &lt;show-random&gt;&lt;/show-random&gt;<br/>      `;<br/>  }<br/>}</pre>
<p>This way, you can test the pages manually by changing the value of <kbd>showSection</kbd>. </p>
<p>Now that we have created a way where we can show different page level components by changing the value of the variable <kbd>showSections</kbd>, we can now concentrate on the routing aspect of these page level components. Rather than manually changing the page numbers, it is time to automate this page change concept with the implementation of routing.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing routing</h1>
                </header>
            
            <article>
                
<p>Until now, we have been manually changing the code to see different pages of our single-page web app. Also, we have not talked about the header component yet. In this section, we will take a look at the header component, update the URLs based on the link, and make sure our page view changes based on the link clicked. </p>
<p>So, let's take a look at the <kbd>&lt;custom-header&gt;</kbd> component:</p>
<pre>constructor() {<br/><br/>  // We are not even going to touch this.<br/>  super();<br/><br/>  // lets create our shadow root<br/>  this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>  this.render();<br/>}</pre>
<p>The <kbd>constructor()</kbd> method is straightforward. Let's take a look at the <kbd>render()</kbd> method:</p>
<pre>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/>}<br/><br/>getTemplate() {<br/>  return `<br/>    &lt;ul class="custom-header__ul"&gt;<br/>      &lt;li class="custom-header__li"&gt;<br/>        &lt;a href="#search"&gt;Search&lt;/a&gt;<br/>      &lt;/li&gt;<br/>      &lt;li class="custom-header__li"&gt;<br/>        &lt;a href="#trending"&gt;Trending&lt;/a&gt;<br/>      &lt;/li&gt;<br/>      &lt;li class="custom-header__li"&gt;<br/>        &lt;a href="#random"&gt;Random&lt;/a&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, we have three links: <strong><span class="packt_screen">Search</span></strong>, <span class="packt_screen"><strong>Trending</strong></span>, and <strong><span class="packt_screen">Random</span></strong>. Clicking on these links also changes the URL hash:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>        top: 0;<br/>        background: #46cff3;<br/>        position: sticky;<br/>        height: 75px;<br/>      }<br/>      .custom-header__ul {<br/>        display: flex;<br/>        margin: 0;<br/>        justify-content: flex-end;<br/>        height: 100%;<br/><br/>      }<br/>      .custom-header__li {<br/>        align-self: center;<br/>        list-style-type: none;<br/>        margin-right: 25px;<br/>      }<br/><br/>      .custom-header__li a {<br/>        text-decoration: none;<br/>        color: white;<br/>        font-size: 25px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The styles are pretty simple as well. </p>
<p>Let's take a look at the event handlers for the click. For routing, we will need to notify the <kbd>&lt;my-app&gt;</kbd> Web Component (where this <kbd>&lt;custom-header&gt;</kbd> component is going to be used) about the click event or what link the user clicked on:</p>
<pre>connectedCallback() {<br/>  this.shadowObj.querySelectorAll('.custom-header__li a')<br/>    .forEach((aTag, index) =&gt; {<br/>      aTag.addEventListener('click', (e) =&gt; {<br/>        this.handleClick(index);<br/>      });<br/>    });<br/>}</pre>
<p>Here, we are simply binding a click event to all the links and making sure that the <kbd>handleClick()</kbd> method is triggered, along with the <kbd>index</kbd> of the link:</p>
<pre>handleClick(index) {<br/>  this.dispatchEvent(new CustomEvent('custom-header-clicked', {<br/>    detail: {<br/>      data: index + 1,<br/>    },<br/>    bubbles: true,<br/>  }));<br/>}</pre>
<p>This <kbd>handleClick()</kbd> method simply passes this index value to the parent component trying to listen to the <kbd>custom-header-clicked</kbd> event.</p>
<p>Inside the <kbd>&lt;my-app&gt;</kbd> component, the definition will update as well. For example, we will need to import the <kbd>CustomHeader</kbd> class:</p>
<pre>import CustomHeader from '../custom-header';</pre>
<p>We will also need to update the <kbd>registerOtherComponents()</kbd> method by adding the following line:</p>
<pre>if (typeof customElements.get('custom-header') === 'undefined') {<br/>  customElements.define('custom-header', CustomHeader);<br/>}</pre>
<p>This will also update the <kbd>getTemplate()</kbd> method, and make it look like this:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;custom-header&gt;&lt;/custom-header&gt;<br/>    &lt;div class="app-section"&gt;<br/>      ${this.getSection(this.shownSection)}<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p>Here, we are simply adding the <kbd>&lt;custom-header&gt;</kbd> element. We will also need to capture the event emitter by this element:</p>
<pre>connectedCallback() {<br/>  this.shadowObj.querySelector('custom-header')<br/>    .addEventListener('custom-header-clicked', (e) =&gt; {<br/>      let newShownSection = e.detail.data;<br/>      if(newShownSection !== this.shownSection) {<br/>        this.shownSection = newShownSection;<br/>        this.reRenderAppSection();<br/>      }<br/>    })<br/>}</pre>
<p>We are adding an event listener to the <kbd>custom-header</kbd> element and making sure that the last value of <kbd>showSection</kbd> is not equal to the newer one. If it is not, then update the value and call the <kbd>reRenderAppSection()</kbd> method:</p>
<pre>reRenderAppSection() {<br/>  this.shadowObj.querySelector('.app-section').innerHTML = <br/>    this.getSection(this.shownSection);<br/>}</pre>
<p>This <kbd>reRenderAppSection()</kbd> method simply update the view based on the <kbd>showSection</kbd> variable.</p>
<p>Now, you can go ahead and test it on the browser by clicking on the header links, and watch the pages change. You can also see the URL changing in the address bar. Even though this all sounds complete, I would like to add one more feature to the routing. </p>
<p>Note the URL that you see in the address bar. If you send the URL with trending in the hash to someone, would it open the trending page? The answer is no. The same applies for the URL with random in the hash. It won't work. We need to have an extra piece of code:</p>
<pre>handleURL() {<br/>  switch(window.location.hash) {<br/>    case '#search':<br/>      this.shownSection = 1;<br/>      break;<br/>    case '#trending':<br/>      this.shownSection = 2;<br/>      break;<br/>    case '#random':<br/>      this.shownSection = 3;<br/>      break;<br/>    default:<br/>      this.shownSection = 1;<br/>      break;<br/>  }<br/><br/>  this.render();<br/>}</pre>
<p>You can call this <kbd>handleURL()</kbd> method in the <kbd>constructor()</kbd> method, and see it working. It updates the value of the <kbd>showSection</kbd> variable and, this way, the <kbd>getSection()</kbd> method in <kbd>getTemplate()</kbd> knows what page to render.</p>
<p>Now that the app is built, let's try adding some extra features that will make our single page web app more useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling analytics</h1>
                </header>
            
            <article>
                
<p>Analytics play an important role in understanding what users are visiting your site and how long they have been on a particular page. In this section, we will be using Google Analytics to track user interactions on the site. This is one of those really easy things that you can do even outside of Web Components.</p>
<p>In order to start using Analytics, we need to do the following:</p>
<ol>
<li>Go to <a href="https://analytics.google.com/" target="_blank">https://analytics.google.com/</a>, then click on the <span class="packt_screen">admin</span> button and create a new property. You will be dropped on to New Property page.</li>
</ol>
<ol start="2">
<li>You can then start filling out the forms on the page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5fbae596-c80d-480a-b1bd-ecc485562a0f.png" style="width:24.17em;height:32.00em;"/></p>
<ol start="3">
<li>Once you have filled in the details, and clicked on the <span class="packt_screen">Get Tracking ID</span> button, you will be dropped onto the next page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88d298bb-a77a-43a8-82ca-55c472c1cf30.png" style="width:48.92em;height:30.67em;"/></p>
<ol start="4">
<li>You can use the code from the text area and put it in your <kbd>index.html</kbd> file.</li>
<li>That's it. Now, you can simply go to the following URL and see how users are visiting your site: <a href="https://analytics.google.com" target="_blank">https://analytics.google.com</a>.</li>
</ol>
<ol start="6">
<li>You will be dropped onto a page where you can see how users have visited your page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/206f683e-ce9b-4772-8c3a-e9d2269f811d.png" style="width:58.25em;height:31.75em;"/></p>
<p>And, you can then use this data to understand what users do on your page, and how much time they stay on the site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">In this chapter, we created a single page web app using just Web Components. We learned how to break down a page into atomic and container Web Components. We learned how to include atomic components in a strategic way, so that they can be reused in an efficient way. We even looked into routing and how it can be used to keep track of what page the user is on. Lastly, we discussed how to integrate analytics into our single page web app, and how it can be used to understand different types of users. You should now be able to create any single page web application based on the concepts above without any problems.</p>
<p class="p1">In the next chapter, we will look into Polymer and Stencil JS, which are libraries that use Web Components, and how the code differs from what we have learned so far.</p>


            </article>

            
        </section>
    </body></html>