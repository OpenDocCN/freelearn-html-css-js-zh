- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Node.js Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to deploy our application to the public internet.
    We will learn how important it is to have a clear definition of the requirements
    and how to choose the best solution for our needs. We will push the application
    code to the GitHub repository in order to use GitHub Actions for continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, We will deploy the application in DigitalOcean and we will use PM2
    to keep the application running. We will configure and use MongoDB Atlas to host
    the database in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define the requirements and how to choose the best solution for our needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to push the application code to the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use MongoDB Atlas to host the database as an external resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use DigitalOcean Droplet to host the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use PM2 to keep the application running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to create accounts with the following providers in order to follow
    the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DigitalOcean: [https://www.digitalocean.com/](https://www.digitalocean.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB Atlas: [https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/](https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/signup](https://github.com/signup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/cWkqR2xJJ0k](https://youtu.be/cWkqR2xJJ0k)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use DigitalOcean to host the application, but you can use any other
    provider or even your own laptop (as an alternative). If you don’t have a DigitalOcean
    account, you can create one here: [https://www.digitalocean.com/](https://www.digitalocean.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the application working on our computer, but we need to deploy it to
    the public internet. So, we need to define the requirements in order to choose
    the best solution for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to consider the following technical questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the target environment* (*bare metal, VMs, containers, cloud solutions...*)*?*
    As our application uses Node.js and standard NPM libraries, we can deploy it easily
    directly in bare metal machines or VMs. Other solutions are also possible but
    require some work to be done in terms of configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the target platform* (*AWS, Azure, GCP, DigitalOcean, Heroku...*)*?*
    In our case, we don’t expect much traffic or many users at all. Also, we are not
    working in a team and don’t have any specific requirements, such as a Service-Level
    Agreement (SLA). We can safely choose to use the most simple provider in terms
    of the onboarding process that also has competitive pricing. In our case, we will
    use DigitalOcean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the target operating system* (*Linux, Windows, macOS...*)*?* Node.js
    is capable of running on common and exotic operating systems. Our application
    does not have any special dependencies on an operating system so we can easily
    choose Linux as it is the most popular OS for servers and also has the most extensive
    offering of the providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the target architecture* (*x86, ARM...*)*?* In this case, our application
    is pure JavaScript. Node.js supports both architectures (x86 and ARM), so we can
    easily choose x86 because it is a more common architecture for servers, often
    with lower prices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the target Node.js version* (*18, 20, 21...*)*?* We have a clear dependency
    on Node.js 20.11.0, as we used this version while developing the application,
    but we can be sure that the application should work on any Node.js 20 LTS version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the target database* (*MongoDB, MySQL, PostgreSQL, Redis...*)*?* We
    depend on MongoDB, so we need to consider that as a dependency for our infrastructure
    decisions. Aside from this, there are no more external dependencies or services
    that we depend on. Managing a database is not simple, so in this case, we can
    safely choose any managed service. MongoDB provides MongoDB Atlas ([https://www.mongodb.com/atlas/database](https://www.mongodb.com/atlas/database))
    as their cloud solution for MongoDB in the cloud. Also, the free tier should cover
    our needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, as a summary, we will deploy the application that we have been building
    in the previous chapters. We will deploy a Node.js application with Express. The
    only external dependency is MongoDB. We will use a Linux machine with x86 architecture
    and the Node.js 20.x version. Also, we will use MongoDB Atlas to host the database
    so we don’t need to worry a lot about the operational aspects of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to consider the following things that are relevant to the team
    and the project, especially if we are working in a professional environment, if
    we plan to deploy an application for a long time, or expect to scale soon:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the budget?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many deployments are we expecting?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the team size?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the team’s experience and knowledge?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not the same to deploy a Node.js application for a pet project as for
    a big company with aggressive **Service-Level Agreements** (**SLAs**) and an infrastructure
    team with a lot of experience.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, I will assume that this is the first time that you are deploying
    a Node.js application. Also, I will assume a limited budget, experience, and time
    to invest in maintaining the infrastructure, so we will try the cheapest option
    possible. Certainly, we won’t have a lot of deployments and we won’t have a lot
    of traffic. So, we don’t need to worry about scalability, performance, or high
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we have two main options that we will explore in this chapter and
    the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application on a bare metal machine or VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application in a cloud solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy the application on a bare-metal machine, which can be an old
    laptop, a **single-board computer** (**SBC**) such as a Raspberry Pi, or a virtual
    machine on your own computer. In this scenario, you can choose to enable remote
    access to the machine or not. But in any case, this is a good option to learn
    and test the application.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to face the public internet and deploy the application in
    a cloud solution. There are many providers with a big product offering out there.
    So, in order to keep this simple, I will focus on a single provider for the compute
    resources (DigitalOcean) and a single provider for the database (MongoDB Atlas).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create the GitHub repository, and we will push
    the code to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using a GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use GitHub to host the code and deploy the application. We will use
    GitHub Actions to run the tests and to check the code quality. We will then use
    GitHub to pull the code from the repository and deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a new repository using this guide: [https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I created a repository called `nodejs-for-beginners`, as you can
    see in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1–  Web Browser Screenshot of the repository created](img/B21678_16_ForCEing_FS_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1– Web Browser Screenshot of the repository created
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a repository ready, it is time to start using it by adding
    our code to it.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the code to the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the project from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step4` folder, and then you will need to push the code to the
    repository. You need to be sure that the `package.json` file is present in the
    root folder of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two guides that can help you to push the code to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to clone a repository: [https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to push code: [https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository](https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In order to simplify the process, we are going to use only the `main` branch.
    But in the real world, most teams use multiple branches to manage their code so
    they can use great features such as pull requests, code reviews, and so on. That
    is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, the repository should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Web browser screenshot of the repository with the files and
    folders added](img/B21678_16_ForCEing_FS_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Web browser screenshot of the repository with the files and folders
    added
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues running the project in this chapter while following
    the steps, or you tried an alternative approach, you can use the `step5` folder
    from the source code that you downloaded at the beginning of the chapter to compare
    and fix possible bugs more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement continuous integration with GitHub Actions.
    This is a great way to ensure that the application is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can understand continuous integration as a way to do automatic checks on
    the code. This will help us to reduce human errors and will help us to mechanize
    the process of checking the project’s quality.
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional step that is not required in order to deploy the application,
    but if you want to get a better understanding of professional development environments,
    you can follow along.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first step is to define what we expect from the automation and then
    we can implement it. In our case, we want to install the dependencies, run the
    linter, and run the tests. And we want to do this every time that we push code
    to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this, we will create the `.github/workflows/ci.yml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This YAML file defines a workflow called **Continous Integration** that will
    be triggered every time we push code to the repository. This workflow will run
    in a virtual machine with Ubuntu and it will run the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the code from the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the dependencies by running the `npm` `install` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the linter by running the `npm run` `lint` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a random JWT secret. We generate a random string with 30 characters
    that will be used as a JWT secret later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the environment by running the `npm run` `infra:start` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests with the `MONGODB_URI`, `PORT`, `SALT_ROUNDS`, and `JWT_SECRET`
    environment variables, and we will use the JWT secret generated in the previous
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we push the code to the repository, we can check the status of the workflow
    in the **Actions** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Web browser screenshot showing the GitHub actions](img/B21678_16_ForCEing_FS_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Web browser screenshot showing the GitHub actions
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the workflow, we can see the details of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Web browser screenshot showing the GitHub Action execution
    details](img/B21678_16_ForCEing_FS_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Web browser screenshot showing the GitHub Action execution details
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, all the checks are passing, so we can be confident that the application
    is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on the **Run tests** step to see the details of the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Web browser screenshot showing the tests execution step in
    detail](img/B21678_16_ForCEing_FS_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Web browser screenshot showing the tests execution step in detail
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the tests are passing, the same way as on our local machine.
    Ultimately, the continuous integration machine is just a remote machine that will
    follow the steps that we define, and it is not very different from our own environment
    in that respect.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have the continuous integration in place, we can start thinking
    about preparing the MongoDB instance using Atlas in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB Atlas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use MongoDB Atlas to host the database. We will create a free tier cluster
    and we will use the connection string to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guides that will help you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to create a free tier cluster: [https://docs.atlas.mongodb.com/tutorial/create-new-cluster/](https://docs.atlas.mongodb.com/tutorial/create-new-cluster/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to connect to the database: [https://www.mongodb.com/docs/atlas/driver-connection/](https://www.mongodb.com/docs/atlas/driver-connection/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In my case, I created a free tier cluster called `nodejs-for-beginners`, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Web browser screenshot showing the cluster creation details](img/B21678_16_ForCEing_FS_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Web browser screenshot showing the cluster creation details
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the process, you will have a connection string like this (but
    with your own credentials):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use that connection string to connect to the database from the application.
    You only need to replace the value of the `MONGODB_URI` environment variable with
    the new connection string in the `.``env` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to notice that the username and password need to be URI encoded,
    so the special characters are converted. This can easily be done with the `encodeURIComponent`
    function ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)).
    Here is a conversion example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run the test or run the application locally, you will see that the application
    is using the new database and the data is persisted in the cloud, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the data in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Web browser screenshot showing the project details](img/Image96437.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Web browser screenshot showing the project details
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Once you are ready with the database, you can restore the `.env` file to the
    original state to avoid polluting the database with test data in future executions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have the external database ready, we can start thinking about deploying
    the application. In the next section, we will prepare the application using PM2.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Node.js applications with PM2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very *exciting* moment! We are about to make our application available
    on the public internet. In this case, we will use a DigitalOcean Droplet to host
    the application. A Droplet is a virtual machine with Ubuntu 23.10 and 0.5 GB of
    RAM that will host the application. We will use PM2 to keep the application running
    and to restart it if it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to use DigitalOcean, as an alternative, you can use an old
    computer that has at least 4 GB RAM, Ubuntu (or another Linux distro), and have
    SSH communication enabled (no need to install Node.js or deploy a website at this
    point). An old laptop is a great option or even a Raspberry PI (3, 4, or 5) ([https://www.raspberrypi.com/](https://www.raspberrypi.com/))
    with Raspbian ([https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/))
    will do the job. Here, you can find two tutorials that will help you with the
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.xda-developers.com/turn-old-laptop-into-home-server](https://www.xda-developers.com/turn-old-laptop-into-home-server)/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=iSAF8D8rp0o](https://www.youtube.com/watch?v=iSAF8D8rp0o)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the setup was done properly, you can skip the next section and jump directly
    to the *Preparing the* *machine* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DigitalOcean Droplet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use DigitalOcean to host the application. We will use the most basic,
    cheap Droplet possible, currently with 512 MB RAM and 1 virtual CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the SSH key to access the machine, so please follow this guide
    if you don’t know how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/](https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I created a Droplet called `nodejs-for-beginners`, as you can see
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Web browser screenshot showing the droplet details](img/B21678_16_ForCEing_FS_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Web browser screenshot showing the droplet details
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the droplet is available at the IP address `144.126.217.34`
    and we will use that IP address to access the machine using SSH or HTTP when the
    application is running.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to access the machine with SSH. The most common is to use
    the terminal directly. But in this case, we will use VSCode to connect to the
    machine. You can follow the guide at [https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)
    to learn how to do it as it is more convenient than directly connect from your
    terminal to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we need to use the same credentials. The username is `root` and
    the password is replaced by your SSH key that was added to your Droplet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to connect to the machine, it is time to start setting
    up the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you are connected to the machine, you can run the following commands in
    the terminal in order to create the working directory and access the new directory
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will install Node.js 20.11.0 using `nvm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to install PM2 globally on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the version of PM2 with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the machine ready to work with our code. Our next step will be
    to bring the application code to our machine.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using a private repository, you will need to add the SSH key to the
    machine. You can follow the guide at [https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh),
    but you can prevent this step if you make the repository public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will clone the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that the code is present in the folder by checking the directory
    in VSCode or by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list all files, including hidden ones, in the current directory,
    and show detailed information about these files. The output should be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that the code has been downloaded, so our next step will be to
    install the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After cloning the repository, we will install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This might take a while as the machine is not very powerful, but it should finish
    without errors. If you have errors or the process is much longer than expected,
    you can try to increase the size of the Droplet, but this will increase the price
    per hour.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a `.env` file as we did in the previous chapters, but we will
    use the connection string of the MongoDB Atlas cluster that we created in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is ready, the application is ready to run, but we will use PM2 to
    keep the application running and restart it if it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the application with PM2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We decided to use PM2 as the process manager for our application, so you won’t
    start the application directly using `node` command like `node index.js`. We will
    let PM2 handle the application lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start the application with PM2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the status of the application with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the logs of the application with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can stop the application with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start the application again with PM2 and check whether the application
    is available through the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can access the application using the IP address of the Droplet. In
    my case, the IP address is `144.126.217.34` and the application is running in
    port `3000`, so I can access the application using the following URL: `http://144.126.217.34:3000`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a different host, such as a machine in your local network,
    this might be different, as it will depend on your local network configuration
    and/or firewalls. But if your network is correctly set up, then you should be
    able to access the website by using the IP address of the machine in your local
    network, for example, `192.168.1.44`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the application running as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Web browser screenshot showing the project running using the
    droplet IP](img/B21678_16_ForCEing_FS_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Web browser screenshot showing the project running using the droplet
    IP
  prefs: []
  type: TYPE_NORMAL
- en: Yes! The application is running as expected. We’ll explore another way to run
    our application in the next chapter, but this time we will use Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy our application to the public internet.
    We learned how important it is to have a clear definition of the requirements
    and how to choose the best solution for our needs. We created accounts with the
    providers that we used in this chapter and we pushed the application code to the
    GitHub repository to have proper source control in place.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used MongoDB Atlas to host the database as an external resource
    and we used a DigitalOcean Droplet to host the application. We learned how to
    use PM2 to keep the application running.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How To Set Up a Node.js Application for Production on Ubuntu 22.04: [https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Express Production best practices: [https://expressjs.com/en/advanced/best-practice-performance.html](https://expressjs.com/en/advanced/best-practice-performance.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
