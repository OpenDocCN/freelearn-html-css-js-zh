- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Expanding the Foundations – Building a User Registration Page, Front to Back!
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展基础——从前端到后端构建用户注册页面！
- en: At this point, you’ve started building the technical foundations and have some
    context around web development. You’ve also seen some of the frontend (the client)
    and some of the backend (the server), but so far, you haven’t seen them put together.
    Let’s address that now!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经开始构建技术基础，并对网页开发有一些背景知识。你也看到了一些前端（客户端）和后端（服务器），但到目前为止，你还没有看到它们是如何结合在一起的。现在让我们解决这个问题！
- en: In the process, you’ll first learn a little bit about networking, since the
    internet and websites are all built on top of networking. You’ll then get some
    exposure to more HTML, CSS, JS, and Node, and you’ll do this by building another
    simple web page and seeing how it communicates with the server side now.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你首先会了解一些关于网络的知识，因为互联网和网站都是建立在网络之上的。然后，你将接触到更多的HTML、CSS、JS和Node，你将通过构建另一个简单的网页并查看它如何与服务器端通信来实现这一点。
- en: The goal here is to see how the client and server connect, how information is
    transmitted to the server, and how the server handles it and returns a response.
    This is part and parcel of what we do every day in web development, so clearly,
    it’s of paramount importance. Not only will you get some exposure to this but
    you’ll also do so in two different ways, ensuring that you can see that there
    is more than one way to skin a cat in web development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是了解客户端和服务器是如何连接的，信息是如何传输到服务器的，以及服务器是如何处理它并返回响应的。这是我们每天在网页开发中都会做的事情的一部分，因此显然，它非常重要。你不仅会接触到这一点，而且还会以两种不同的方式接触到，确保你能看到在网页开发中不止有一种方法可以“剥猫皮”。
- en: You’ll also learn a little bit about the tools available to you that come with
    your web browser and how valuable they are, as they are tools you’ll interact
    with constantly as you work to debug and get things working exactly right.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解一些与你的网络浏览器一起提供的工具，以及它们的价值，因为当你努力调试并确保一切按预期工作的时候，你将不断地与这些工具互动。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Connecting over a network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络连接
- en: Building an interactive web app – the frontend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建交互式网页应用程序——前端
- en: Building an interactive web app – the backend
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建交互式网页应用程序——后端
- en: Exploring a different approach – single-page apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同的方法——单页应用程序
- en: Loving your new best friend – DevTools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爱上你的新最佳朋友——开发者工具
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the purposes of this chapter, the only thing you’ll require is having Node
    installed and working, which you should have done in the previous chapter. You’ll
    also want to be sure you’ve downloaded all of the source code for this book from
    GitHub ([https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan)),
    which you can find in the *Technical requirements* section of [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061).
    As you’ve probably noticed by now, each chapter has its own directory in the downloaded
    code, so you’re interested in the `ch-03/1-form` and `ch-03/2-spa` directories
    for this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，你只需要确保已经安装并运行了Node，这你应该在上章已经完成。你还需要确保你已经从GitHub（[https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan)）下载了本书的所有源代码，你可以在[*第2章*](B18315_02.xhtml#_idTextAnchor061)的[*技术要求*](B18315_02.xhtml#_idTextAnchor061)部分找到。你可能已经注意到了，下载的代码中每个章节都有自己的目录，所以对于本章，你感兴趣的是`ch-03/1-form`和`ch-03/2-spa`目录。
- en: That’s really all you need for this chapter, so now, let’s build ourselves a
    user registration page!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章你需要了解的全部内容，所以现在，让我们自己构建一个用户注册页面吧！
- en: Connecting over a network
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络连接
- en: Before we actually get to developing code, let’s first talk about something
    more fundamental, networking, and how the web communicates over a network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正开始编写代码之前，让我们先谈谈一些更基础的东西，即网络，以及网络是如何进行通信的。
- en: I mentioned **IP** (**Internet Protocol**) in the last chapter, but I didn’t
    go into too much detail. I really won’t go into it too much here either because
    when we talk about network protocols, which include IP, it quickly becomes an
    expansive topic. However, as a web developer, you should know at least the basics.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上章提到了**IP**（**互联网协议**），但并没有深入细节。在这里我也不会过多地深入，因为当我们谈论包括IP在内的网络协议时，它很快就会变成一个广泛的话题。然而，作为一名网页开发者，你应该至少了解基础知识。
- en: Understanding IP
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解IP
- en: IP, as the second word in the acronym states, is a protocol. A protocol is simply
    an agreed-upon standard for how two things communicate. In this case, IP describes
    how small bits of data called **datagrams** are transmitted between two machines
    over a network. As you saw in [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061),
    it’s also what is responsible for giving each machine an IP address that uniquely
    identifies them on the network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: IP，正如其缩写中的第二个单词所表明的，是一个协议。协议简单来说就是两个事物之间通信的约定标准。在这种情况下，IP描述了被称为**数据报**的小数据块如何在两台机器之间通过网络进行传输。正如你在[*第二章*](B18315_02.xhtml#_idTextAnchor061)中看到的，它还负责为每台机器分配一个IP地址，该地址在网络中唯一地标识了它们。
- en: However, it may surprise you to learn that IP doesn’t guarantee the delivery,
    order, or integrity of the datagrams it transmits. In other words, if you want
    to send a picture from one machine to another, that picture will be broken up
    into many datagrams, and they will be transmitted over the network using IP, but
    they may or may not reach the destination, may or may not be in the proper order
    for the other machine to reconstruct the image (in fact, the receiving machine
    wouldn’t even have a way to know what order they should go in), and may or may
    not be corrupted in some way. IP is considered a “best-effort” protocol, meaning
    it’ll *try* to get data from machine A to machine B, but it’s not guaranteed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能惊讶地发现，IP并不保证它传输的数据报的交付、顺序或完整性。换句话说，如果你想从一台机器发送一张图片到另一台机器，那张图片将被分成许多数据报，并且它们将使用IP在网络中传输，但它们可能或可能不会到达目的地，可能或可能不会以正确的顺序到达，以便其他机器可以重建图像（实际上，接收机器甚至没有一种方法知道它们应该以什么顺序到达），并且可能或可能以某种方式损坏。IP被认为是一个“尽力而为”的协议，这意味着它将*尝试*将数据从机器A传输到机器B，但它并不保证。
- en: If that sounds like a recipe for disaster, you’re right! But the benefit of
    it is that it is very simple and fast, and when you have something simple and
    fast in technology, it’s almost always easy to extend it or build something on
    top of it (we’re big on layers in software engineering). And that’s exactly where
    TCP comes in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来像是一场灾难的配方，你是对的！但它的好处是它非常简单且快速，而在技术中，当你拥有简单快速的东西时，几乎总是很容易扩展它或在其之上构建一些东西（我们在软件工程中非常重视层次）。这正是TCP的用武之地。
- en: Understanding TCP
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TCP
- en: '**TCP**, which stands for **Transmission Control Protocol**, works in conjunction
    with – or *on top of* – IP by ensuring that when information is sent, it is sent
    reliably. It begins by breaking the data to be sent down into **packets** (which
    IP will then further break down into datagrams), and it ensures that the packets
    all arrive at the destination, that they are error-free, and that they tell the
    receiver what order everything all goes in. It does this by establishing a connection
    between machines and then sending the packets, which the receiver will then examine.
    The packets contain data that the receiver can use to validate that the data is
    correct. They also include sequence numbers, which tell the receiver what order
    they go in. If a packet is corrupt, or if the receiver finds some missing, it
    can request the sender to resend the data, which is another key thing that TCP
    provides.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP**，即**传输控制协议**，通过与IP协同工作或在其之上工作，确保发送的信息是可靠的。它首先将需要发送的数据分解成**数据包**（然后IP将进一步将其分解成数据报），并确保所有数据包都到达目的地，它们是无错误的，并且它们告诉接收者一切事物的顺序。它是通过在机器之间建立连接并发送数据包来做到这一点的，接收者随后将检查这些数据包。数据包包含接收者可以使用以验证数据是否正确的数据。它们还包括序列号，告诉接收者它们的顺序。如果一个数据包损坏，或者接收者发现某些数据丢失，它可以请求发送者重新发送数据，这是TCP提供的另一个关键功能。'
- en: TCP/IP is a great combination because, in a large network with a lot of machines
    (like the internet), there are a lot of routes between them and connections that
    packets can be transmitted across. If one connection is broken – maybe because
    someone accidentally cut a network cable while doing some roadwork – a different
    route can be chosen. In such a scenario, the fact that IP doesn’t provide concrete
    guarantees doesn’t matter because TCP on top of it has all the information it
    needs to request a retry from the sender as needed, and this can continue until
    all the data is received correctly and in the right order. This provides redundancy
    for the network. Yes, if packets suddenly must travel halfway around the world
    to get where they’re going, things will slow down a bit, but the data will still
    get there, and that’s the key thing TCP provides when working in conjunction with
    IP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 是一个很好的组合，因为在拥有大量机器（如互联网）的大型网络中，它们之间有很多路由和连接，数据包可以通过这些路由传输。如果某个连接中断——可能是因为有人在修路时不小心切断了网络电缆——可以选择不同的路由。在这种情况下，IP
    不提供具体保证的事实并不重要，因为 TCP 在其之上拥有所有所需的信息，可以根据需要请求发送者重试，并且这可以一直持续到所有数据都正确且按顺序接收为止。这为网络提供了冗余。是的，如果数据包必须绕地球半圈才能到达目的地，速度会稍微慢一些，但数据仍然会到达，这正是
    TCP 与 IP 协同工作时提供的关键功能。
- en: However, while TCP/IP serves as, conceptually, the foundational protocols of
    the internet, the web has its own protocol that sits on top of TCP/IP, and that’s
    HTTP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管 TCP/IP 在概念上作为互联网的基础协议，但网络有其自己的协议，它位于 TCP/IP 之上，那就是 HTTP。
- en: Understanding HTTP
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 HTTP
- en: You can think of **HTTP**, which is an acronym for **HyperText Transfer Protocol**,
    as the foundation for data communication on the web.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 **HTTP**（超文本传输协议的缩写）视为网络数据通信的基础。
- en: HTTP works as a request-response model between two machines, one acting as a
    client and one acting as a server. HTTP is what we call a **stateless** protocol,
    which means that each request is independent. In other words, when you enter a
    URL in your browser, a connection is established from your machine to the server,
    but that connection ends once the HTML page is returned to you. When an image
    or style sheet needs to be retrieved, a new connection is established. Well, more
    modern versions of HTTP will actually reuse connections to some degree, but the
    connections still don’t last forever, which is what we mean by stateless – there
    is not a constant connection between the two machines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 在两台机器之间作为请求-响应模型工作，一台作为客户端，另一台作为服务器。HTTP 是我们所说的无状态协议，这意味着每个请求都是独立的。换句话说，当你你在浏览器中输入一个
    URL 时，从你的机器到服务器的连接就会建立，但一旦 HTML 页面返回给你，这个连接就会结束。当需要检索图片或样式表时，会建立一个新的连接。更现代的 HTTP
    版本实际上会在一定程度上重用连接，但连接仍然不会永远持续，这就是我们所说的无状态——两台机器之间没有恒定的连接。
- en: When you use HTTP to connect from one machine to another, each request uses
    an HTTP method, which comprises a basic set of operations that can be used to
    interact with a server. They are meant to, at least generally, convey to the server
    what the client wants to do. Note that this is different from a JS method – a
    function that is attached to an object – and is really just a fancy way of saying
    that it tells us what *kind* of HTTP request is made.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 HTTP 从一台机器连接到另一台机器时，每个请求都使用一个 HTTP 方法，它包含一组基本操作，可以用来与服务器交互。它们旨在（至少在一般情况下）向服务器传达客户端想要做什么。请注意，这与
    JS 方法不同——一个附加到对象上的函数——这实际上是一种更复杂的方式来说明它告诉我们做出了什么 *类型* 的 HTTP 请求。
- en: 'HTTP defines several methods, where each one has a typical (although not concrete)
    intended use:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 定义了几个方法，其中每个方法都有一个典型的（尽管不是具体的）预期用途：
- en: '**GET**: Retrieve data from the server'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**: 从服务器检索数据'
- en: '**POST**: Send data to be processed by the server'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**: 向服务器发送要处理的数据'
- en: '**PUT**: Update existing data on the server'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**: 更新服务器上的现有数据'
- en: '**DELETE**: Remove data from the server'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**: 从服务器删除数据'
- en: '`GET` but a more limited version'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 只是一个更有限的版本'
- en: '**OPTIONS**: Discover allowed methods on a resource'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPTIONS**: 发现资源上允许的方法'
- en: When you enter a URL in your browser, a `GET` request is made. That makes sense
    if you think about it – your browser is asking for data from the server, an HTML
    document usually. Other situations call for other methods – when you’re sending
    information to the server, you will probably use `POST` or `PUT`, depending on
    the situation – but you’ll see how choosing other methods comes into play in just
    a little while.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中输入一个 URL 时，会发起一个 `GET` 请求。如果您这样考虑，这是有道理的——您的浏览器正在请求服务器上的数据，通常是 HTML 文档。其他情况下需要其他方法——当您向服务器发送信息时，您可能会使用
    `POST` 或 `PUT`，具体取决于情况——但您很快就会看到选择其他方法是如何发挥作用的。
- en: 'It’s worth noting that HTTP, being closely tied to HTML, has a similar concept
    to the head and body in HTML, instead called the **headers** and body. Headers
    are bits of data that provide some metadata to the receiver. There are a substantial
    number of headers, and you can create your own too, so I’m not going to go into
    any here; instead, I’ll opt to introduce headers when necessary later. However,
    one thing I *will* tell you is that they are sent in **key-value pairs**. This
    is a common programming idea that looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，HTTP 与 HTML 密切相关，有一个类似于 HTML 中的 head 和 body 的概念，但称为 **headers** 和 body。Headers
    是提供一些元数据给接收者的数据块。有大量的 headers，您也可以创建自己的，所以在这里我不会深入探讨；相反，我会在必要时介绍 headers。然而，有一件事我会告诉您，它们是以
    **键值对** 的形式发送的。这是一个常见的编程思想，看起来像这样：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, it can look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以是这样的：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Whether a colon or equal sign (or possibly some other character) is used depends
    on the context, but the key point is that you have a key (`first_name`) and a
    value (`Frank`). The value is identified by the key. You can almost think of them
    as variables in JS in that you can look up the value associated with a key when
    needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用冒号或等号（或者可能是其他字符），这取决于上下文，但关键点是您有一个键（`first_name`）和一个值（`Frank`）。值是通过键来识别的。您几乎可以将它们视为
    JS 中的变量，因为您可以在需要时查找与键关联的值。
- en: The body of an HTTP request can contain arbitrary data, whether that’s text,
    an image, an audio file, or anything else. When an HTTP request has a body and
    data in it, almost always it will use a `POST` method. You’re about to see an
    example of that, as part of a discussion of something else – HTML forms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求的主体可以包含任意数据，无论是文本、图像、音频文件还是其他任何东西。当一个 HTTP 请求有主体并且包含数据时，几乎总是使用 `POST`
    方法。您很快就会看到一个例子，作为讨论其他内容的部分——HTML 表单。
- en: HTTP versus HTTPS
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 与 HTTPS 的比较
- en: Oh, and if that wasn’t enough, there’s also HTTPS. Fortunately, that’s simple
    – it’s just HTTP but encrypted, with the **S** standing for **Secure**. If you
    see a URL with HTTP, it means that all the content sent back and forth using that
    connection could potentially be looked at by other people on the network (it’s
    not quite that easy to do, but it’s also not especially difficult). With HTTPS
    though, all that content is encrypted, and without some secret information called
    *keys*, a person who intercepts the data would essentially see a lot of gibberish.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，如果还不够的话，还有 HTTPS。幸运的是，这很简单——它只是加密的 HTTP，其中的 **S** 代表 **Secure**。如果您看到一个带有
    HTTP 的 URL，这意味着通过该连接发送和接收的所有内容都可能被网络上的其他人看到（这并不那么容易做到，但也不是特别困难）。然而，通过 HTTPS，所有内容都是加密的，没有一些称为
    *keys* 的秘密信息，拦截数据的人基本上会看到很多乱码。
- en: There was a time when HTTPS was only used for sensitive sites such as banking
    sites and shopping sites. That’s because, for a long time, the encryption and
    decryption process – which is based on some complex mathematics – was an expensive
    thing for computers to do. It was expensive in terms of money and, more importantly,
    in terms of performance. An HTTPS connection would simply be slower than an HTTP
    one. However, nowadays, that’s no longer the case. Computers are fast enough and
    often have specialized hardware specifically for encryption/decryption, so most
    connections are, in fact, HTTPS now. Browsers will even make you aware that a
    connection isn’t secure, and some will even disallow a non-HTTPS connection entirely.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，HTTPS 只用于像银行网站和购物网站这样的敏感网站。这是因为，在很长一段时间里，加密和解密过程——它基于一些复杂的数学——对计算机来说是一件昂贵的事情。从金钱的角度来看，这很昂贵，更重要的是，在性能方面也很昂贵。HTTPS
    连接简单地比 HTTP 连接慢。然而，现在情况已经不再是这样了。计算机足够快，并且通常有专门用于加密/解密的硬件，所以现在大多数连接实际上都是 HTTPS。浏览器甚至会让你知道连接不安全，有些甚至完全不允许非
    HTTPS 连接。
- en: For most intents and purposes, you can generally treat HTTP and HTTPS connections
    the same. However, in terms of development, setting up an HTTPS connection takes
    some additional configuration that can be non-trivial to set up. If you ever hear
    the term *certificates*, that’s what’s involved. That’s a whole other topic that
    can get rather complicated, so it won’t be covered in this book. When developing
    on your own machine, you can simply use HTTP, which is what will be used by default
    if you don’t explicitly set up HTTPS, and you needn’t worry about certificates
    and all that unless and until you really have to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数意图和目的，你通常可以一般性地将HTTP和HTTPS连接视为相同。然而，在开发方面，设置HTTPS连接需要一些额外的配置，这可能相当复杂。如果你听说过*证书*这个词，那就是涉及的。这是一个完全不同的主题，可能会相当复杂，所以它不会在本书中涉及。在你自己的机器上开发时，你可以简单地使用HTTP，这是默认情况下如果你没有明确设置HTTPS将会使用的，你不需要担心证书和所有那些，除非你真的需要。
- en: With this basic understanding of how things communicate over the internet (and
    most networks generally) in hand, we can now move on to building the aforementioned
    registration app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了互联网（以及大多数网络）上事物如何通信的基本理解之后，我们现在可以继续构建前面提到的注册应用程序。
- en: Building an interactive web app – the frontend
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式Web应用程序——前端
- en: For this chapter, rather than just using simple HTML as you’ve previously seen,
    let’s create an application that looks somewhat more “real.” By that, I mean let’s
    create something you might actually have to build on the job someday – a user
    registration page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们不仅仅使用之前看到的简单HTML，而是创建一个看起来更“真实”的应用程序。我的意思是，让我们创建一些你可能在某天的工作中真正需要构建的东西——一个用户注册页面。
- en: The goal will be simple – give a user a way to enter a few key pieces of information
    (their title, first and last names, age, and email address) and then send that
    information to a server, where we’ll generate a response to confirm that the user
    is now registered. We won’t actually register the user in any fashion – we won’t
    even store the information they sent – but it’ll be enough to see how such a client-server
    interaction works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目标将很简单——给用户一种方式来输入一些关键信息（他们的头衔、名、姓、年龄和电子邮件地址），然后将这些信息发送到服务器，在那里我们将生成一个响应来确认用户现在已经注册。我们实际上不会以任何方式注册用户——我们甚至不会存储他们发送的信息——但这足以看到这样的客户端-服务器交互是如何工作的。
- en: Building a registration page
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建注册页面
- en: The first step is to build a page where the user enters their information.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是构建一个用户可以输入信息的页面。
- en: Well, I take that back, because the *real* first step is to start a project.
    As you learned in the previous chapters, this can be as simple as creating an
    HTML file; however, you also saw how you can use NPM to create a new project.
    Since we know we’ll be building a server later for this project, let’s go ahead
    and do that now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我收回刚才的话，因为*真正的*第一步是开始一个项目。正如你在前面的章节中学到的，这可以简单到创建一个HTML文件；然而，你也看到了如何使用NPM来创建一个新的项目。既然我们知道我们将在稍后为这个项目构建一个服务器，让我们现在就做吧。
- en: As before, simply create a directory, go to a command prompt, navigate to the
    directory, and execute `npm init`. For now, you can just press *Enter* for every
    question, as this will be sufficient for our needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前，只需创建一个目录，进入命令提示符，导航到该目录，并执行`npm init`。现在，你可以为每个问题都按*Enter*键，因为这将满足我们的需求。
- en: Once that’s done, it’s time to write some HTML, the result of which will be
    what you see in *Figure 3**.1*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，是时候编写一些HTML了，其结果将是你将在*图3.1*中看到的内容。
- en: '![Figure 3.1: The registration page we’re building](img/B18315_03_1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：我们正在构建的注册页面](img/B18315_03_1.jpg)'
- en: 'Figure 3.1: The registration page we’re building'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：我们正在构建的注册页面
- en: You would begin this project by creating a file in your project directory, named
    `index.html`, and then get to work writing the code in it. Of course, I’ve already
    done that part for you! In the GitHub repo, you’ll find this file in the `ch-03/1-form`
    directory. Since there is a bit more to it than in the prior examples, we’ll tackle
    it bit by bit, breaking it down into manageable chunks, starting with `<head>`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你会从在项目目录中创建一个名为`index.html`的文件开始这个项目，然后开始编写其中的代码。当然，我已经为你完成这部分工作了！在GitHub仓库中，你可以在`ch-03/1-form`目录下找到这个文件。由于它比之前的例子要复杂一些，我们将逐步解决它，将其分解成可管理的块，从`<head>`开始。
- en: Creating the head
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建头部
- en: 'For our registration page, we start the HTML document, as before, with an `<html>`
    tag and then a `<head>` section within it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的注册页面，我们像之前一样，从`<html>`标签开始，然后在其中添加一个`<head>`部分：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By now, the code should be starting to make some sense to you, since you’ve
    seen it before.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，代码应该开始对您有了一些意义，因为您之前已经见过它。
- en: However, unlike the examples shown in the previous chapters, there is no `<style>`
    block in `<head>`. Instead, all the CSS is in an external `styles.css` file. I
    did this for one main reason – so that I could skip the CSS for now! There’s not
    much CSS to deal with at all; however, it will make more sense if you see how
    HTML styles it first, so we’ll be coming back to it at the end. For now, just
    know that the style sheet file gets imported by the `<link>` tag and acts as if
    it were a `<style>` block directly in `<head>`, as seen in the previous chapters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与前面章节中展示的示例不同，`<head>`中没有`<style>`块。相反，所有CSS都在一个外部的`styles.css`文件中。我这样做的主要原因——这样我就可以暂时跳过CSS！实际上要处理的CSS并不多；然而，如果您先看到HTML是如何应用样式的，这会更有意义，所以我们将在最后回到它。现在，只需知道样式表文件通过`<link>`标签导入，并像在前面章节中看到的那样，直接在`<head>`中的`<style>`块中起作用。
- en: There is also no JS in this project, so that’s actually all there is for `<head>`.
    Now, we can move on to creating `<body>`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中也没有使用JS，所以这就是`<head>`中所有内容。现在，我们可以继续创建`<body>`。
- en: Creating the body
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主体
- en: 'As with `<head>`, `<body>` starts out very simply:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与`<head>`一样，`<body>`开始时非常简单：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have a heading with a paragraph of text under it. Of course,
    you know there’s more – all those fields you saw in *Figure 3**.1* where the user
    can enter their information and the button to submit it – but all of those constitute
    a new concept that I’ll introduce now – forms.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个标题，下面有一段文字。当然，您知道还有更多——您在*图3*1中看到的那些字段，用户可以输入他们的信息，以及提交按钮——但所有这些都构成了我现在要介绍的新概念——表单。
- en: Getting to know forms
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解表单
- en: 'In HTML, forms are how we provide a way for users to enter information. A form
    consists of one or more form fields, and these fields come in several types. You
    may not realize it, but unless you’ve literally never used a website, then you
    know many of these fields, even if you don’t realize you do. Putting that aside,
    it all starts with defining a form itself, and with HTML, that means a new tag:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，表单是我们提供用户输入信息的方式。一个表单由一个或多个表单字段组成，这些字段有多种类型。您可能没有意识到，但除非您从未真正使用过网站，否则您知道许多这些字段，即使您没有意识到您在使用。先不考虑这一点，一切从定义表单本身开始，而在HTML中，这意味着一个新的标签：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `<form>` tag is how we begin a form. This tag has several attributes, but
    the two key ones are `action` and `method`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form>`标签是我们开始表单的方式。这个标签有几个属性，但两个关键属性是`action`和`method`。'
- en: The `action` attribute tells the browser what URL to send the information the
    user enters. You can express this URL as an *absolute* URL or a *relative* URL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`属性告诉浏览器将用户输入的信息发送到哪个URL。您可以将此URL表示为绝对URL或相对URL。'
- en: An absolute URL contains all the information needed to get to a given resource.
    For example, www.packt.com/takeMyInfo is an absolute URL because it starts with
    a domain name and includes a full path to a resource on the server. [www.packt.com/books/zammetti/forms/takeMyInfo](http://www.packt.com/books/zammetti/forms/takeMyInfo
    ) might be another (this is fake, for the record!) example of an absolute URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对URL包含获取特定资源所需的所有信息。例如，www.packt.com/takeMyInfo是一个绝对URL，因为它以域名开头，并包含服务器上资源的完整路径。[www.packt.com/books/zammetti/forms/takeMyInfo](http://www.packt.com/books/zammetti/forms/takeMyInfo)可能另一个例子（这是虚构的，仅供参考！）绝对URL。
- en: What, then, is a relative URL? A relative URL starts from an absolute URL or,
    more precisely, *part* of one. /takeMyInfo is an example of a relative URL. If
    the document that uses that URL is loaded from [www.packt.com](http://www.packt.com),
    the browser interprets all relative URLs as being relative to that base URL. So,
    the full URL that /takeMyInfo leads to is www.packt.com/takeMyInfo.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是相对URL？相对URL从绝对URL开始，或者更准确地说，是从其*部分*开始的。/takeMyInfo是一个相对URL的例子。如果使用该URL的文档是从[www.packt.com](http://www.packt.com)加载的，则浏览器将所有相对URL解释为相对于该基本URL。因此，/takeMyInfo指向的完整URL是www.packt.com/takeMyInfo。
- en: In a more complex example, /books/zammetti/forms/takeMyInfo could be a relative
    URL. If you loaded an HTML document from [www.packt.com/books/zammetti](http://www.packt.com/books/zammetti),
    then you could have a relative URL of /forms/takeMyInfo, since the two get joined
    together by the browser behind the scenes, forming the absolute URL that it will
    then request resources with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的例子中，/books/zammetti/forms/takeMyInfo 可以是一个相对URL。如果你从一个HTML文档 [www.packt.com/books/zammetti](http://www.packt.com/books/zammetti)
    加载，那么你可以有一个相对URL为 /forms/takeMyInfo，因为这两个URL在浏览器幕后被合并，形成一个绝对URL，然后浏览器将使用这个URL请求资源。
- en: In this `<form>` though, `/register` is the URL the form will be sent to, and
    you’ll see what is there waiting for it later when we talk about the server part
    of this project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个 `<form>` 中，`/register` 是表单将被发送到的URL，你将在我们讨论这个项目的服务器部分时看到那里等待的内容。
- en: The other key attribute is `method`. This is the HTTP method used to transmit
    the form, and it will be either `GET` or `POST`. The difference is that when it’s
    `GET`, the information on the form is added to the URL as a `?aaa=bbb&…` form,
    where `aaa` is a key and `bbb` is a value. For example, in this form, we’re going
    to ask the user for their first name and last name. If this information is sent
    via `GET`, a query string will be appended to the URL as `?first_name=Frank&last_name=Zammetti`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键属性是 `method`。这是用于传输表单的HTTP方法，它将是 `GET` 或 `POST` 之一。区别在于当它是 `GET` 时，表单上的信息将以
    `?aaa=bbb&…` 的形式添加到URL中，其中 `aaa` 是键，`bbb` 是值。例如，在这个表单中，我们将要求用户输入他们的名字和姓氏。如果这个信息通过
    `GET` 发送，那么一个查询字符串将被附加到URL上，作为 `?first_name=Frank&last_name=Zammetti`。
- en: This is fine in some cases, but in most, it’s a bad idea because it has security
    implications and also because a URL has a size limit, and the information might
    be larger than you have space for. So, you can POST the information instead, which
    will cause the browser to send it in the body of the HTTP request, where there
    is effectively no limit and where it’s not *quite* as exposed to the world (it’s
    still quite easy to get, but every little bit helps).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下这没问题，但在大多数情况下，这并不是一个好主意，因为它有安全影响，也因为URL有一个大小限制，信息可能比你拥有的空间要大。所以，你可以用POST方法发送信息，这将导致浏览器在HTTP请求的正文部分发送它，那里实际上没有限制，而且它对世界的暴露也不是“完全”的（它仍然很容易获取，但每一点帮助都很大）。
- en: 'Once we have `<form>`, we can start adding fields to it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `<form>`，我们就可以开始向其中添加字段：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<p>` tag is, strictly speaking, not necessary in a form. In fact, you can
    define your HTML and your layout however you like, but here, I just want each
    field to go down the screen, so putting each field in `<p>` does the job simply.
    I want each field to have a text label too, and that’s where the `Title` text
    comes in. I want that label to be above the field itself, so `<br>`, a line break
    in other words, ensures this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`<p>` 标签在表单中不是必需的。实际上，你可以定义你自己的HTML和布局，但在这里，我只是想让每个字段沿着屏幕向下延伸，所以将每个字段放在
    `<p>` 中简单地完成了这个任务。我还想每个字段都有一个文本标签，这就是 `Title` 文本的作用。我想让这个标签在字段本身之上，所以 `<br>`，换句话说，是一个换行符，确保了这一点。
- en: An `<input>` tag defines a field in the form where the user can enter information.
    In most cases, a single-entry field on the screen is also a single `<input>` tag
    in the HTML, with a `type` attribute that tells the browser what kind of field
    it is out of several choices. However, in the case of a `radio` button, which
    is the type of control where you can select one and only one from a set of options,
    there will be multiple `<input>` tags of type `radio`, one for each option. The
    `name` attribute tells the browser what the name – the key – of the input value
    should be in the form. Here, we’re saying that in this form, we want to have a
    key named `title`, and it will have one of the three values available (which are
    defined literally by the `value` attribute of each `<input>` element). When the
    user selects one of the three options, the `title` value in the form will reflect
    that selected `value`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>` 标签定义了一个表单字段，用户可以在其中输入信息。在大多数情况下，屏幕上的单个输入字段在HTML中也是一个单个 `<input>`
    标签，它有一个 `type` 属性，告诉浏览器它属于几种选择中的哪一种。然而，在单选按钮的情况下，这是一种可以从中选择一个且仅选择一个选项的控件类型，将会有多个类型为
    `radio` 的 `<input>` 标签，每个选项一个。`name` 属性告诉浏览器输入值的名称（键）在表单中应该是什么。在这里，我们说在这个表单中，我们想要一个名为
    `title` 的键，并且它将有一个三个可用的值（这些值由每个 `<input>` 元素的 `value` 属性直接定义）。当用户选择三个选项中的一个时，表单中的
    `title` 值将反映所选的 `value`。'
- en: If that seems a bit confusing, don’t worry – I think you’ll find it makes more
    sense later in this chapter when you see the server interaction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来有点令人困惑，不要担心——我认为你会在本章的后面看到服务器交互时发现它更有意义。
- en: 'After that comes two `<input>` fields, for the first and last names:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是两个 `<input>` 字段，用于输入姓名的首字母和姓氏：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have another kind of `<input>` field – a `text` field. This allows
    the user to enter any arbitrary text they want to. Then, again, the `type` attribute
    tells the browser what kind of field we want, and `name` tells it what key will
    hold the value the user enters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们又有另一种 `<input>` 字段——一个 `text` 字段。这允许用户输入他们想要的任何任意文本。然后，同样，`type` 属性告诉浏览器我们想要哪种字段，而
    `name` 属性告诉它哪个键将保存用户输入的值。
- en: The `size` attribute tells the browser how large the field physically is, and
    it’s defined as how many characters wide the field should be. When we talk about
    non-proportional fonts – meaning that each character takes up a variable amount
    of space (the letter “I” doesn’t take us as much space horizontally as “W” does,
    for instance) – this value can be a little fungible. But, as a rule of thumb,
    if `size` is `20`, then you can generally see 20 characters at a time in it, give
    or take a little. Note that this does not set a limit on how many characters can
    actually be entered; the field will scroll if you enter more than the size attribute
    allows for (there is a `maxlength` attribute that sets a limit on how many can
    be entered).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 属性告诉浏览器字段的实际大小，它定义为字段应该有多宽。当我们谈论非比例字体——意味着每个字符占据可变的空间（例如，“I”字母在水平方向上占用的空间不如“W”多）——这个值可能有些灵活。但作为一个经验法则，如果
    `size` 是 `20`，那么你通常可以在其中看到大约 20 个字符，略有增减。请注意，这并不设置实际可以输入的字符数上限；如果你输入的字符数超过了 `size`
    属性允许的，字段将滚动（有一个 `maxlength` 属性设置了可以输入的最大字符数）。'
- en: 'Next, we have a different kind of input field:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个不同类型的输入字段：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `type` of `number` ensures that only numeric values can be entered; if you
    try to enter a letter, the browser won’t allow it. In addition, most browsers
    will show up and down arrows to allow the user to scroll through available values.
    This tag allows us to set a limit on the numbers entered; here, 13–100 is allowed
    by setting the `min` and `max` attributes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 为 `number` 确保只能输入数值；如果你尝试输入字母，浏览器将不允许这样做。此外，大多数浏览器将显示上下箭头以允许用户滚动查看可用值。此标签允许我们设置输入数字的限制；在这里，通过设置
    `min` 和 `max` 属性，允许输入的范围是 13–100。'
- en: Next, the `step` attribute tells us by what increment the number changes when
    the arrow buttons are used (if the value were 2 instead of 1, then it would jump
    from 13 to 15 to 17 when the up arrow is clicked, for example).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`step` 属性告诉我们当使用箭头按钮时数字变化的增量（如果值是 2 而不是 1，例如，当点击向上箭头时，它将从 13 跳到 15，然后到 17）。
- en: '*Figure 3**.2* shows the presentation of the up and down arrows, which could
    be different depending on the browser (this example is from Chrome):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.2**显示了上下箭头的呈现方式，这可能会根据浏览器而有所不同（此示例来自 Chrome）：'
- en: '![Figure 3.2: How Chrome shows the arrows in a number field](img/B18315_03_2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![**图 3.2**：Chrome 显示数字字段中的箭头](img/B18315_03_2.jpg)'
- en: 'Figure 3.2: How Chrome shows the arrows in a number field'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.2**：Chrome 显示数字字段中的箭头方式'
- en: 'After that comes the final input field:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是最后一个输入字段：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `email` type ensures that the value entered is a valid email address. If
    you enter a value that isn’t valid (`none@@@nowhere`, for example), the field
    will be highlighted, and hovering over it will show a tooltip explaining the problem.
    Note that the presentation of this is browser-specific, but *Figure 3**.3* shows
    what you should see when hovering over the field in Chrome:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`email` 类别确保输入的值是一个有效的电子邮件地址。如果你输入了一个无效的值（例如 `none@@@nowhere`），该字段将被突出显示，并且悬停在其上会显示一个工具提示来解释问题。请注意，这种呈现方式是浏览器特定的，但**图
    3.3**显示了在 Chrome 中悬停在该字段时应看到的内容：'
- en: '![Figure 3.3: How Chrome shows errors in an email field](img/B18315_03_3.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![**图 3.3**：Chrome 显示电子邮件字段中的错误](img/B18315_03_3.jpg)'
- en: 'Figure 3.3: How Chrome shows errors in an email field'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.3**：Chrome 显示电子邮件字段中的错误'
- en: 'After the input fields, we need a button for the user to click to send the
    information to the server:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入字段之后，我们需要一个按钮供用户点击以将信息发送到服务器：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are several types of buttons, and you’ll see another later in this chapter,
    but `submit` is perhaps the most important, as it literally tells the browser
    that, when clicked, it needs to send the information entered to the server. The
    text between the opening and closing `<button>` tags is the label that will be
    shown on the button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的按钮，你将在本章后面看到另一种，但 `submit` 可能是最重要的，因为它实际上告诉浏览器，当点击时，它需要将输入的信息发送到服务器。在
    `<button>` 标签的打开和关闭之间的是按钮上显示的标签。
- en: 'Only one thing remains now, and that’s to close the form properly:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下最后一件事，那就是正确地关闭表单：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With all that done, we have ourselves a complete HTML form that will send its
    information to the specified `action` URL when the user clicks the button. But
    we’re not quite done yet; we still have an HTML document to complete!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们就有一个完整的 HTML 表单，当用户点击按钮时，它将发送其信息到指定的 `action` URL。但我们还没有完成；我们仍然有一个要完成的
    HTML 文档！
- en: Finishing the body and the document
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成主体和文档
- en: 'Of course, we have to close the body of the document using the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须使用以下方式来关闭文档的主体：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we have to close the document itself using the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须使用以下方式关闭文档本身：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With those tasks complete, we now have a complete HTML page.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些任务后，我们现在有一个完整的 HTML 页面。
- en: Remember when I said we’d skip the style sheet earlier? Well, it’s time to look
    at that now!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我之前说我们会跳过样式表吗？现在，是时候看看那个了！
- en: Adding some style
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一些样式
- en: 'Earlier, you saw that the `styles.css` file is imported in `<head>`. The content
    in this file isn’t very voluminous, but it demonstrates a few new CSS concepts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你看到 `styles.css` 文件在 `<head>` 中被导入。这个文件的内容并不多，但它展示了一些新的 CSS 概念：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first new concept is `<a>` tag can be displayed in three different states
    – when the user has never clicked it (unvisited), when the user has clicked it
    before (visited), and when the user’s mouse pointer hovers over it. If you want
    a link to be red when unvisited, blue when visited, and green when hovered over,
    you can create a CSS class with the names `a:visited`, `a:unvisited`, and `a:hover`,
    setting the appropriate `color` property value on each. The colon and the word
    after it are the pseudo-class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新概念是 `<a>` 标签可以显示三种不同的状态——当用户从未点击它时（未访问），当用户之前点击过它时（已访问），以及当用户的鼠标指针悬停在其上时。如果你想使链接在未访问时为红色，在已访问时为蓝色，在悬停时为绿色，你可以创建一个名为
    `a:visited`、`a:unvisited` 和 `a:hover` 的 CSS 类，并在每个类中设置适当的 `color` 属性值。冒号及其后面的单词是伪类。
- en: In this case, I want to ensure that the email field specifically will have a
    red border when an invalid email address is entered. Fortunately, there is a pseudo-class
    on the input selector for that, namely `:invalid`. So, `input:invalid` is the
    selector to use to target an invalid input field.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我想确保当输入无效的电子邮件地址时，电子邮件字段将特别有一个红色边框。幸运的是，对于输入选择器有一个伪类，即 `:invalid`。因此，`input:invalid`
    是用来定位无效输入字段的选择器。
- en: The second new concept is the `outline` property. This property allows us to
    draw a border around an element (it’s one of two ways to do this, and you’ll see
    the other later). This property also actually demonstrates a third bonus concept
    – **shorthand properties**. Let me explain that a bit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个新概念是 `outline` 属性。这个属性允许我们在元素周围绘制边框（这是两种方法之一，你稍后会看到另一种）。这个属性实际上还展示了第三个额外概念——**缩写属性**。让我稍微解释一下。
- en: 'You see, there are three things defined by this property:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这个属性定义了三件事：
- en: The width of the border to draw around the field (2 pixels – `px` is short for
    pixels, which are the dots that make up the picture on your monitor)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制在字段周围的边框宽度（2像素 - `px` 是像素的缩写，它们是构成你显示器上图片的点）
- en: The style of the border (`solid` here)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边框的样式（这里为 `solid`）
- en: The color of the border
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边框的颜色
- en: These could each be defined by independent properties too – `outline-width`,
    `outline-style`, and `outline-color`. However, just using the `outline` shorthand
    property allows us to set all three at once.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也可以由独立的属性定义——`outline-width`、`outline-style` 和 `outline-color`。然而，仅使用 `outline`
    缩写属性就可以一次设置所有三个。
- en: Several groups of related properties have shorthand properties like this in
    CSS, and you’ll see some more of them later too. However, to not keep you in suspense,
    some of the others include `margin` (shorthand for `margin-top`, `margin-bottom`,
    `margin-left`, and `margin-right`), `padding` (shorthand for `padding-top`, `padding-bottom`,
    `padding-left`, and `padding-right`), `background` (shorthand for `background-color`,
    `background-image`, `background-repeat`, `background-attachment`, and `background-position`),
    and `font` (shorthand for `font-style`, `font-weight`, `font-variant`, `font-size`/`line-height`,
    and `font-family`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，一些相关的属性组有这种简写属性，你稍后也会看到更多。然而，为了不让你感到悬念，其他的一些包括`margin`（`margin-top`、`margin-bottom`、`margin-left`和`margin-right`的简写）、`padding`（`padding-top`、`padding-bottom`、`padding-left`和`padding-right`的简写）、`background`（`background-color`、`background-image`、`background-repeat`、`background-attachment`和`background-position`的简写），以及`font`（`font-style`、`font-weight`、`font-variant`、`font-size`/`line-height`和`font-family`的简写）。
- en: Now that we have a frontend (a client), let’s build a backend (a server) for
    it to talk to. This will require us to write some code that will accept the data
    the user enters on the form and return a response of some sort for the browser
    to display to them. Let’s get to work!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了前端（客户端），让我们为它构建后端（服务器）以便与之通信。这将要求我们编写一些代码来接受用户在表单中输入的数据，并为浏览器提供一个响应以显示给用户。让我们开始工作！
- en: Building an interactive web app – the backend
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式Web应用——后端
- en: To build the server for this little project, we’ll again use Node. However,
    rather than write a server from scratch as we did in the last chapter, this time
    we’ll use possibly the most popular package available for Node to take care of
    a lot of the basic details for us – Express.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个小型项目的服务器，我们再次使用Node。然而，与上一章从头开始编写服务器不同，这次我们将使用Node最流行的包之一来处理许多基本细节——Express。
- en: Introducing Express
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Express
- en: When you write a Node server from scratch, you must take care of all of the
    details yourself. That means that, for example, if you want to have a server respond
    to multiple different URLs, in your handler function you’ll need to examine the
    URL that was requested and, based on it, branch to a piece of code to return the
    appropriate response. It doesn’t take too long for an application to become large
    enough that this becomes a real headache.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从头开始编写Node服务器时，你必须自己处理所有细节。这意味着，例如，如果你想让服务器响应多个不同的URL，在你的处理函数中，你需要检查请求的URL，并根据它分支到一段代码以返回适当的响应。当应用程序足够大时，这会变成一个真正的头疼问题。
- en: So, very often, we’ll use an add-on package for Node that handles a lot of that
    for us – one such package is called **Express**. Express is actually a very powerful
    module that can handle all sorts of things for us, including security, file uploads
    and downloads, the logging of operations, and templating (the ability to have
    HTML and other response types built in a generic way that can then have data plugged
    into an outline, or template, to return a full response).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们经常会使用Node的附加包来处理这些事情——其中一个这样的包叫做**Express**。实际上，Express是一个非常强大的模块，可以为我们处理各种事情，包括安全、文件上传和下载、操作日志记录以及模板化（以通用方式构建HTML和其他响应类型的能力，然后可以将数据插入到概要或模板中，以返回完整的响应）。
- en: Express is also the first **framework** you’re meeting. A framework is a pre-written
    code library that provides a foundation to build your own code. It offers a defined
    structure to your code, so you don’t have to guess and make it up yourself, and
    it pushes you to use best practices. In essence, they are meant to make it easier
    to develop software and allow you to write less code yourself, which as a general
    rule is a good thing, since it means fewer opportunities for you to make mistakes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Express也是你遇到的第一个**框架**。框架是一个预写的代码库，为构建自己的代码提供基础。它为你的代码提供了一种定义的结构，这样你就不必猜测并自己构建，而且它推动你使用最佳实践。本质上，它们旨在使软件开发更容易，并允许你编写更少的代码，这通常是一个好事情，因为它意味着你犯错误的机会更少。
- en: To be more specific, Express is what’s called an “unopinionated” framework.
    Whereas opinionated frameworks ensure that there’s really only one “right” way
    to do things, and you’d better do it that way or you’ll find yourself having a
    challenging time, unopinionated frameworks don’t force as much on you. Express,
    being unopinionated, allows you much more flexibility and, while saving you a
    lot of effort, still allows you to do things your way for the most part. The debate
    about whether opinionated or unopinionated frameworks are better is an age-old
    one that I’m not even going to attempt to answer here!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，Express 被称为“无意见”框架。而“有意见”的框架确保只有一种“正确”的方式来做事，你最好按照这种方式来做，否则你会发现自己在遇到挑战，而“无意见”框架则不会对你施加太多限制。Express
    作为“无意见”框架，为你提供了更多的灵活性，在节省你大量努力的同时，仍然允许你大部分情况下按照自己的方式做事。关于“有意见”或“无意见”框架哪个更好的争论是一个由来已久的话题，我甚至不打算在这里尝试回答！
- en: To get started with Express, we have to add it as a dependency of our project,
    so let’s do that now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Express，我们必须将其添加为我们项目的依赖项，所以现在让我们来做这件事。
- en: Adding dependencies
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: Remember the `package.json` file that was created when you ran the `npm init`
    command? I said that it provides Node and NPM metadata about our project, but
    I also said we’d largely ignore it. Well, we *have* to look at it now!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记得当你运行 `npm init` 命令时创建的 `package.json` 文件吗？我说过它提供了 Node 和 NPM 关于我们项目的元数据，但我还说过我们基本上会忽略它。然而，我们现在必须查看它！
- en: 'Here’s what I got from the `npm init` command (remember, yours could look slightly
    different depending on the values you may have entered, but it should look *substantially*
    the same):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `npm init` 命令的输出结果（记住，你的输出可能因你输入的值而略有不同，但应该看起来 *大体上* 相同）：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of this is still ignorable, but one thing we now have to care about is
    the `dependencies` element. This tells Node and NPM what packages our project
    depends on. Yours will be empty at this point, but I’ve already added the Express
    dependency in mine, and I’ve also specified exactly which version I want. If you
    head over to [https://www.npmjs.com](https://www.npmjs.com), you can explore all
    the different packages available. NPM uses this site to download the dependencies
    you add to your `package.json` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容仍然可以忽略，但我们现在必须关注的是 `dependencies` 元素。这个元素告诉 Node 和 NPM 我们的项目依赖于哪些包。你的项目此时可能为空，但我在我的项目中已经添加了
    Express 依赖，并且我还指定了确切的版本。如果你访问 [https://www.npmjs.com](https://www.npmjs.com)，你可以探索所有可用的不同包。NPM
    使用这个网站来下载你添加到 `package.json` 文件中的依赖项。
- en: 'But how do you actually add a dependency into `package.json`? Well, given that
    this is just a text file, you could just go and edit it by hand. However, there
    is a better way. First, execute this command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但你实际上是如何将依赖项添加到 `package.json` 中的呢？好吧，鉴于这只是一个文本文件，你可以直接手动编辑它。然而，有一个更好的方法。首先，执行以下命令：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, open `package.json` again, and you should now find the same dependency
    entry as shown in that command. The `npm install` command tells NPM to install
    the package you name in your project (it gets added to `node_modules`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次打开 `package.json` 文件，你应该会找到与该命令中显示相同的依赖项条目。`npm install` 命令告诉 NPM 安装你在项目中命名的包（它会被添加到
    `node_modules` 目录中）。
- en: Here, I’ve specified the version as `@4.18.2`. You don’t *have* to specify the
    version like this, and in fact, you usually will not want to. What will happen
    when you don’t is that NPM will install whatever the latest version of the package
    is. I’ve specified the version explicitly here because, with a book, you need
    to ensure that a reader, months or years after the book was written, will still
    get the exact right versions that are known to work with the code; otherwise,
    a newer version might possibly not work with the code as written and described
    by the text (I’ve learned this lesson the hard way!)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我指定了版本为 `@4.18.2`。你不必像这样指定版本，实际上，你通常也不需要这样做。当你不指定版本时，NPM 将安装该包的最新版本。我在这里明确指定了版本，因为，对于一本书来说，你需要确保几个月或几年后读者仍然能够获得已知与代码兼容的确切版本；否则，更新的版本可能无法与书中描述的代码兼容（我为此付出了惨痛的代价！）。
- en: 'Finally, in order to update the `package.json` file, we need to specify the
    `–save` option. Not doing so will cause NPM to install Express in `node_modules`
    but not add it to the list of dependencies in the `package.json` file. When you’re
    just experimenting with a new package and don’t yet know whether you’ll continue
    to use it in your project, not specifying `–save` is good because nothing is permanently
    altered that way. But since we know we want Express to stick around, we *do* want
    to update the file, and the reason you want the file to be updated is that you
    can give another developer your `package.json` file, and all they have to do is
    execute this command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了更新`package.json`文件，我们需要指定`–save`选项。如果不这样做，NPM将只在`node_modules`中安装Express，但不会将其添加到`package.json`文件中的依赖项列表中。当你只是尝试一个新的包，还不知道是否会在你的项目中继续使用它时，不指定`–save`是好的，因为这样不会永久更改任何内容。但既然我们知道我们希望Express保留下来，我们*确实*想要更新文件，而你想更新文件的原因是你可以将你的`package.json`文件给另一位开发者，他们只需要执行这个命令：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: NPM will then look in `package.json` and install all the dependencies listed.
    That way, the developer is ready to work on your code and will have all the same
    dependencies as you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: NPM将接着查找`package.json`并安装列出的所有依赖项。这样，开发者就可以准备好在你的代码上工作，并将拥有与你相同的所有依赖项。
- en: It’s something you wouldn’t know unless you’ve experienced it, but setting up
    a new developer’s development environment hasn’t always been that easy. In the
    past, they would have to go to the internet and manually download all the dependencies
    – which weren’t always on one site – and that’s assuming they even had a list
    of what was needed. NPM, through its `package.json` file, solves all those problems!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种除非你亲身体验过，否则不会知道的事情，但设置新开发者的开发环境并不总是那么容易。在过去，他们必须上网并手动下载所有依赖项——这些依赖项并不总是在一个网站上——而且这还假设他们甚至有一份所需内容的清单。NPM通过其`package.json`文件解决了所有这些问题！
- en: The last thing I want to mention is that if you look in your project directory,
    you’ll find a new directory has been created, called `node_modules`. This is a
    directory that NPM creates to keep all the packages it downloads in. For the most
    part, you don’t need to look at this directory or care what’s in it; just let
    Node and NPM do their thing with it. You should also be aware that it can get
    rather large at times because if a package itself depends on another package,
    then that package will be downloaded, and that sort of chain of dependencies can
    keep going for a while. So, `node_modules` will be stuffed with packages you don’t
    recognize because they all have dependencies. That’s how it’s meant to work. If
    you ever delete `node_modules`, that’s fine; you can just run `npm install` again
    and it will be recreated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后想提到的是，如果你查看你的项目目录，你会找到一个新目录被创建，称为`node_modules`。这是一个NPM创建的目录，用于保存它下载的所有包。在大多数情况下，你不需要查看这个目录或关心里面有什么；只需让Node和NPM处理它。你也应该意识到，有时它可能会变得相当大，因为如果一个包本身依赖于另一个包，那么那个包就会被下载，这种依赖链可能会持续一段时间。所以，`node_modules`将充满你不认识的包，因为它们都有依赖项。这就是它的工作方式。如果你任何时候删除`node_modules`，那没关系；你只需再次运行`npm
    install`，它就会被重新创建。
- en: Now that we have the dependencies added that we need, let’s address one issue
    that you may not have even realized in the code for the previous chapter – that
    of developer efficiency – and in the process, you’ll see a new capability that
    the `package.json` file provides for – scripts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所需的依赖项，让我们解决一个你可能甚至没有意识到的问题——那就是开发者效率问题——在这个过程中，你将看到`package.json`文件提供的新功能——脚本。
- en: Adding scripts
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加脚本
- en: In the past, starting our server would be done with the `node index.js` command.
    However, when another developer wants to work on our project, they may not know
    that. With only a single JS file, it’s easy enough to guess, but imagine if we
    had hundreds of files, which definitely can be the case in larger projects – how
    would you know where to start?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，启动我们的服务器只需使用`node index.js`命令。然而，当另一位开发者想要在我们的项目上工作，他们可能不知道这一点。只有一个JS文件，猜测起来足够简单，但想象一下如果我们有成百上千个文件，这在大型项目中确实可能发生——你将如何知道从哪里开始呢？
- en: Of course, you might guess it’s `index.js`, since that is the default value
    that NPM will set for the `main` property in `package.json` when you execute `npm
    init` in a project, but a) there might not be an `index.js` file at all, and b)
    that may not be the right answer even if it *is* there, as the developer of the
    project may have made a different choice. We can tell the developer which file
    it is of course, but shouldn’t there be a better way to communicate that information
    without explicitly having to tell someone?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会猜它是`index.js`，因为当你在一个项目中执行`npm init`时，NPM 会将默认值设置为`package.json`中的`main`属性，但a)可能根本不存在`index.js`文件，b)即使存在，这也可能不是正确的答案，因为项目的开发者可能做出了不同的选择。我们可以告诉开发者它是哪个文件，但难道没有更好的方法来传达这个信息，而无需明确告诉某人吗？
- en: There is, and it comes about due to another available element in the `package.json`
    file – `scripts`. The `scripts` element gives us a way to, in a sense, create
    custom NPM commands. Anything that appears in that element can be run with the
    `npm run XXX` command, where `XXX` is a key in `scripts`. NPM, by default, gives
    us a `test` command, so you can run that with `npm` `run tests`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有，这是由于`package.json`文件中另一个可用的元素——`scripts`。`scripts`元素提供了一种在某种程度上创建自定义 NPM 命令的方式。该元素中出现的任何内容都可以使用`npm
    run XXX`命令运行，其中`XXX`是`scripts`中的一个键。默认情况下，NPM 给我们一个`test`命令，所以你可以用`npm run tests`来运行它。
- en: 'We can use this capability to provide a way to start the server:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个功能来提供一个启动服务器的方法：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, we can execute `npm run dev` to start the server, and the `scripts`
    entry knows which file to run, so the developer doesn’t need to. This is a common
    command to include, so many developers will know it automatically. But even if
    they don’t, they can simply look in `package.json` and see the available commands.
    It is, in a sense, a way to document the proper start up command for our project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以执行`npm run dev`来启动服务器，`scripts`条目知道要运行哪个文件，因此开发者不需要这样做。这是一个常见的命令，所以许多开发者会自动知道它。但即使他们不知道，他们也可以简单地查看`package.json`并查看可用的命令。在某种程度上，这是一种记录我们项目正确启动命令的方式。
- en: Now that we have Express added to our project, and a start-up script to run
    it with, let’s use it to write our server code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Express 添加到我们的项目中，并且有一个启动脚本来运行它，让我们用它来编写我们的服务器代码。
- en: Writing the server code
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写服务器代码
- en: We start by creating an `index.js` file in the project directory. This will
    again be the server code from the previous chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在项目目录中创建一个`index.js`文件。这将是前一章中的服务器代码。
- en: 'Any time you add a package to a Node project, you’ll almost certainly need
    to import it into your code, and that is indeed the first thing we have in `index.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你向 Node 项目添加一个包时，你几乎肯定需要将其导入到你的代码中，而这确实是我们在`index.js`中的第一件事：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This gives us an object named `express`, from which we can use several properties
    and methods. However, the object itself is a function in this case – in other
    words, the `express` variable points to a function, so we can execute it as a
    function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个名为`express`的对象，我们可以使用它的几个属性和方法。然而，在这个情况下，对象本身是一个函数——换句话说，`express`变量指向一个函数，因此我们可以像函数一样执行它：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result of the `express()` function is that a server object is returned
    to us. Express handles all the setup and creation of that server. However, because
    the object is returned to us, Express gives us the ability to configure the server
    to meet our specific needs, and the first thing we need to do is tell it that
    we want to be able to handle forms being sent in:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`express()`函数的结果是返回给我们一个服务器对象。Express 处理所有服务器的设置和创建。然而，因为对象是返回给我们的，Express
    允许我们配置服务器以满足我们的特定需求，我们首先需要做的是告诉它我们想要能够处理发送的表单：'
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `app.use()` function allows us to configure Express **middleware**. That’s
    really just a fancy way of saying that we can tell Express to execute one or more
    functions for every request that comes in. This comes in handy for things such
    as logging the incoming request to make debugging easier, implementing some sort
    of security, or, in this case, telling it to handle form data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use()`函数允许我们配置 Express 中间件。这实际上只是说我们可以告诉 Express 为每个进入的请求执行一个或多个函数。这对于记录传入的请求以简化调试、实现某种安全措施，或者在这种情况下，告诉它处理表单数据都很有用。'
- en: Adding Express middleware
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Express 中间件
- en: 'When a form is sent to a server via `POST`, it gets encoded in a unique way
    in the body of the request, such as the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表单通过`POST`方式发送到服务器时，它会在请求体中以独特的方式进行编码，如下所示：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the server to be able to make sense of that, it must know how to parse it
    and what middleware function to use to do so. Express provides several prebuilt
    middleware functions, one of which is given to us if we call the `express.urlencoded()`
    function. It returns the function, which we then add to Express as middleware
    by passing it to the `app.use()` function. Without this, Express wouldn’t be able
    to handle the form data that our client code will send to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让服务器能够理解这一点，它必须知道如何解析它以及使用哪个中间件函数来做到这一点。Express 提供了几个预构建的中间件函数，其中之一是在我们调用
    `express.urlencoded()` 函数时提供给我们的。它返回一个函数，然后我们通过将其传递给 `app.use()` 函数将其添加到 Express
    作为中间件。没有这个，Express 就无法处理我们的客户端代码将发送给它的表单数据。
- en: You can add zero, one, or more middleware functions via calls to `app.use()`.
    Each time you call it, you give it a reference to a function, whether it’s one
    you create yourself, one that Express supplies, or one from a third-party source,
    and it gets added to the chain of middleware functions that Express will execute
    for each request that comes into it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `app.use()` 添加零个、一个或多个中间件函数。每次调用它时，你给它一个函数的引用，无论是你自己创建的，还是 Express 提供的，或者来自第三方来源的，它会被添加到
    Express 将为每个进入它的请求执行的中间件函数链中。
- en: Creating Express routes with JS arrow functions
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 JS 箭头函数创建 Express 路由
- en: 'Perhaps the key concept of Express is the idea of **routes**. Routes are really
    just URLs. Defining a route in Express means defining the function to execute
    for a given URL. For our little app, we need two routes, beginning with the default
    route:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 也许 Express 的关键概念是 **路由** 的想法。路由实际上只是 URL。在 Express 中定义路由意味着定义针对给定 URL 执行的函数。对于我们的小程序，我们需要两个路由，从默认路由开始：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the default route because it’s what will execute when the URL has nothing
    after the domain. In other words, if you access [http://localhost](http://localhost)
    with the server running, this is the route that will be hit because there’s nothing
    after the domain, which is `localhost` in this case. The `"/"` argument equates
    to “nothing after the domain.”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认路由，因为它是在 URL 在域名之后没有任何内容时执行的。换句话说，如果你在服务器运行时访问 [http://localhost](http://localhost)，这将是被触发的路由，因为没有域名之后的内容，在这个例子中域名是
    `localhost`。`"/"` 参数等同于“域名之后没有内容”。
- en: Calling the `app.get()` function registers a route with Express that will be
    accessed using the HTTP `GET` method, which you’ll recall is what the browser
    uses by default, so that’s what we need here. The second argument passed to this
    function is what we call a **handler function**, which is just a plain old JS
    function to execute when a request comes in via this route.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `app.get()` 函数将一个路由注册到 Express 中，该路由将通过 HTTP `GET` 方法访问，你可能会记得这是浏览器默认使用的，所以这就是我们在这里需要的。传递给此函数的第二个参数是我们所说的
    **处理函数**，它只是一个普通的 JS 函数，当通过此路由收到请求时执行。
- en: 'However, here, I’m using a different form of functions available to us in JS
    that you haven’t seen before – `app.get()` call so that we can look at it in isolation,
    it would be just this snippet of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里，我正在使用 JS 中可用的不同形式的函数，这是你之前没有见过的 – `app.get()` 调用，这样我们就可以单独查看它，它就只是这段代码片段：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That is equivalent to this code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下代码等价：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, we could write that `app.get()` call like this instead:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将 `app.get()` 调用写成这样：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With arrow functions, you’re essentially trading the `function` keyword for
    the `=>` characters. In most cases, these two are absolutely equivalent, but there
    are some subtle differences that can become large in more advanced situations.
    I’m going to skip that for now because there are some other concepts you would
    need to be introduced to before you could understand the explanation. At this
    point, I’ll just say that, at the time of writing, developers tend to use arrow
    functions more because they are shorter (although only by a character or two)
    and more aesthetically pleasing. Your opinion may be different, but at the end
    of the day, you can generally just choose whichever you prefer (at least until
    you hit the situations where it matters what you choose, which I’ll touch on in
    later chapters). Arrow functions can be written in some other forms as well depending
    on developer needs, but I’ll explain those when we get to them in other code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，你实际上是在用`function`关键字交换`=>`字符。在大多数情况下，这两个是绝对等价的，但有些细微的差异在更高级的情况下可能会变得很大。我现在先跳过这一点，因为还有一些其他的概念你需要先了解，这样你才能理解解释。目前，我只能说，在写作的时候，开发者倾向于使用箭头函数更多，因为它们更短（尽管只是字符或两个）并且更美观。你的观点可能不同，但最终，你通常可以随意选择你更喜欢的（至少直到你遇到选择很重要的情况，我将在后面的章节中提到）。根据开发者的需求，箭头函数也可以以其他形式编写，但我会在我们到达其他代码时解释这些。
- en: Arrow function syntax aside, the function performs a simple task – sending a
    file back to the browser. The file that is sent back is `index.html`, sent by
    calling the `sendFile()` method that the `inResponse` argument provides to us.
    `inRequest` and `inResponse` are objects that Express and Node create and pass
    to the function that we can use to construct a response. They provide many methods
    and properties to examine the incoming request, get data from it, and produce
    a response, `sendFile()` being one of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了箭头函数的语法之外，该函数执行一个简单的任务——将文件发送回浏览器。发送回的文件是`index.html`，通过调用`inResponse`参数提供的`sendFile()`方法发送。`inRequest`和`inResponse`是Express和Node创建并传递给函数的对象，我们可以使用它们来构建响应。它们提供了许多方法和属性来检查传入的请求，从中获取数据，并生成响应，`sendFile()`就是其中之一。
- en: However, let’s talk about what is passed to `sendFile()` a bit. In JS, the backtick
    character (`` ` ``) is used to define a special kind of string, called a `${}`,
    with something between the braces. And what is the something? Well, it can be
    any valid JS! What happens is that the JS engine, when it encounters such a template
    literal string, will replace each of those expressions, resulting in the JS executing
    within it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们谈谈传递给`sendFile()`的内容。在JS中，反引号字符（`` ` ``）用于定义一种特殊的字符串，称为`${}`，其中包含花括号之间的内容。那么这个“某物”是什么呢？嗯，它可以是有任何有效的JS！发生的情况是，当JS遇到这样的模板字符串时，它会替换每个这样的表达式，从而在它内部执行JS。
- en: Here, the JS to execute is actually just the name of a variable that Express
    provides – `__dirname`. When JS sees just a variable name like this, it simply
    inserts the current value of that variable into the string. The `__dirname` variable
    contains the full path of the directory that the `index.js` file is in at runtime.
    When we append `/index.html` to it – which is what happens when this template
    literal is interpreted by JS – we get a full path to that file, which just so
    happens is what `sendFile()` needs to return that file to the browser.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要执行的JS实际上是Express提供的变量名称——`__dirname`。当JS看到这样的变量名时，它只是将变量的当前值插入到字符串中。`__dirname`变量包含在运行时`index.js`文件所在的目录的完整路径。当我们将其与`/index.html`连接起来——这是当这个模板字符串被JS解释时发生的事情——我们得到指向该文件的完整路径，这恰好是`sendFile()`需要返回给浏览器文件的。
- en: 'We have to add another route specifically for the style sheet file that is
    imported; otherwise, you’ll find that the styles don’t work because the file can’t
    be loaded:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为导入的样式表文件添加另一个特定的路由；否则，你会发现样式不起作用，因为文件无法加载：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we’re serving a specific file using a specific URL, the one specified
    in the `<link>` tag in `index.html`. Remember that our server won’t do anything
    we don’t specifically program it to do, including responding to the browser’s
    request for that stylesheet file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用特定的URL提供特定的文件，这是在`index.html`中的`<link>`标签中指定的。记住，我们的服务器不会做我们没有特别编程它去做的事情，包括对浏览器请求该样式表文件的响应。
- en: 'That route will allow us to see the registration page, but we also need a route
    for the form to be submitted to, so we’ll define that next:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由将允许我们看到注册页面，但我们还需要一个路由来提交表单，所以我们将定义它：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time, remember that we’re going to send the form to the server with the
    HTTP `POST` method, so we have to call `app.post()` this time. The URL will be
    [http://localhost/register](http://localhost/register) this time, so the route
    is `/register` (again, relative to the base URL, which in this case is just the
    domain name).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，记住我们将使用 HTTP `POST` 方法将表单发送到服务器，所以这次我们必须调用 `app.post()`。这次 URL 将是 [http://localhost/register](http://localhost/register)，所以路由是
    `/register`（再次强调，相对于基本 URL，在这个例子中只是域名）。
- en: The handler function we pass along this time returns content directly from this
    code, not from a separate file, and the `inResponse.send()` function allows us
    to do that. We pass it a string, and that string is returned to the browser. The
    string, in this case, is the actual HTML document to return, our registration
    acknowledgment page. And here, you can see why being able to spread a template
    literal string onto multiple lines is nice – imagine if all that HTML was put
    on a single, lengthy line, which is what we’d have to do with plain old strings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次传递的处理函数直接从这段代码返回内容，而不是从单独的文件中返回，`inResponse.send()` 函数允许我们这样做。我们传递一个字符串，这个字符串被返回到浏览器。在这个例子中，这个字符串是实际要返回的
    HTML 文档，我们的注册确认页面。在这里，你可以看到为什么能够将模板字面量字符串扩展到多行是件好事——想象一下，如果所有的 HTML 都放在一个单一的、长行中，那我们会怎么做，因为我们只能用普通的字符串来做。
- en: I would think that, at this point, most of that HTML looks pretty self-explanatory
    to you, save for the style classes defined there. You will know, based on the
    selectors, that the classes must style some HTML elements called `th`, `tr`, and
    `td`, but at this point, you don’t know what they are. Let’s remedy that situation
    now by talking about a new HTML concept – tables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，到这个时候，大部分的 HTML 对你来说应该已经很直观了，除了那里定义的样式类。根据选择器，你知道这些类必须为一些名为 `th`、`tr` 和 `td`
    的 HTML 元素设置样式，但到目前为止，你还不知道它们是什么。让我们通过讨论一个新的 HTML 概念——表格——来解决这个问题。
- en: Introducing tables
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍表格
- en: 'Tables in HTML are a lot like spreadsheets – they allow us to organize data
    in rows and columns. We begin a table with, unsurprisingly, a `<``table>` tag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 中的表格与电子表格非常相似——它们允许我们在行和列中组织数据。我们用 `<table>` 标签开始一个表格，这是意料之中的。
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, a table won’t have a border, but I want it to in this case, so I’ve
    added an inline style for it. The `border` property is very much like the `outline`
    property you saw earlier. It’s another of those shorthand properties I previously
    explained, and in this case, it has the same values as `outline` – the width of
    the border in pixels, the style of it, and the color.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表格不会有边框，但在这个例子中，我想让它有边框，所以我为它添加了内联样式。`border` 属性非常类似于你之前看到的 `outline`
    属性。它也是那些我之前解释过的简写属性之一，在这种情况下，它具有与 `outline` 相同的值——边框的像素宽度、样式和颜色。
- en: 'Once we have a table, we can begin filling it with rows of data. Each row is
    defined with a `<tr>` element (short for **Table Row**):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了表格，我们就可以开始用数据行填充它。每一行都由一个 `<tr>` 元素定义（简称**表格行**）：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside of a row, we define one or more columns, and here we have a choice:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行内，我们定义一个或多个列，这里我们有选择：
- en: We can use a `<th>` tag, which stands for `<th>`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `<th>` 标签，它代表 `<th>`。
- en: We could use a `<td>` tag, which stands for `<td>` (or, if you don’t want a
    header row at all, you can just start with `<td>` right away).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `<td>` 标签，它代表 `<td>`（或者，如果你根本不想有标题行，你可以直接从 `<td>` 开始）。
- en: Whether we use `<th>` or `<td>`, we generically call either one a *cell*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用 `<th>` 还是 `<td>`，我们通常将它们统称为 *单元格*。
- en: 'Each `<th>` element defines a column, and since this is the header row, the
    values inside the `<th>` elements are the header text for each column. In this
    case, we’re only going to have a single row after the header row:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `<th>` 元素定义一个列，由于这是标题行，所以 `<th>` 元素内的值是每个列的标题文本。在这种情况下，我们将在标题行之后只有一个单行：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, `<tr>` creates a row, and then for each column, we have a `<td>` element.
    Remember that this HTML is being built inside of a template literal string in
    JS code, so we can use those expressions I mentioned earlier. For each cell, a
    property in the `inRequest` object is used – `body`. This will hold the information
    sent to the server from the form, so we can then grab each piece of data using
    properties named after the form fields.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`<tr>`创建一个行，然后对于每一列，我们都有一个`<td>`元素。记住，这个HTML是在JS代码中的模板字面量字符串内构建的，因此我们可以使用我之前提到的那些表达式。对于每个单元格，`inRequest`对象中的一个属性被使用——`body`。这将保存从表单发送到服务器的信息，然后我们可以使用表单字段的属性名来获取每条数据。
- en: 'Then, we just have to close the table:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需关闭表格：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result of this is shown in *Figure 3**.4*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果在*图3.4*中显示：
- en: '![Figure 3.4: The registration acknowledgment screen, using an HTML table](img/B18315_03_4.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：注册确认屏幕，使用HTML表格](img/B18315_03_4.jpg)'
- en: 'Figure 3.4: The registration acknowledgment screen, using an HTML table'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：注册确认屏幕，使用HTML表格
- en: A warning about table usage
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于表格使用的警告
- en: Tables are often used in HTML, and they are sometimes even abused because tables
    can be used to lay out your pages if you want. The content inside a `<td>` element
    can be anything, even more HTML, so it’s possible to build tables nested inside
    `<td>` elements with all sorts of complex HTML and use the table structure to
    define the structure of the page. However, this practice is frowned upon for several
    reasons, including performance, the complexity of the markup, and a more philosophical
    “it’s just not what tables are meant for” arguments. There are preferable ways
    to do layout in CSS, some of which wind up looking an awful lot like tables anyway
    but with more flexibility. I only mention this so that you’re aware – tables shouldn’t
    be thought of as being used for layout, even though they can be (and for many
    years before CSS evolved into what it is today, it was extremely common to do
    so).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表格在HTML中经常被使用，有时甚至被滥用，因为如果需要，表格可以用来布局页面。`<td>`元素内的内容可以是任何东西，甚至是更多的HTML，因此可以在`<td>`元素内构建嵌套的表格，并使用所有种类的复杂HTML，利用表格结构来定义页面的结构。然而，这种做法因性能、标记的复杂性以及更哲学的“这根本不是表格的用途”等理由而受到批评。在CSS中有更可取的布局方式，其中一些方式最终看起来非常像表格，但具有更多的灵活性。我之所以提到这一点，是为了让你知道——表格不应该被视为用于布局的工具，尽管它们可以（在CSS演变到今天这个样子之前，这样做是非常常见的）。
- en: Now, you have the context to understand the CSS classes applied to `tr`, `th`,
    and `td` that you saw earlier when the response to the `/register` route was generated
    – these elements are the `<tr>`, `<td>`, and `<th>` tags that the styles apply
    to! Simply put, they put a background color on the `<th>` elements in the header
    row so that they stand out from the data, and then a border is put around each
    `<tr>` and `<td>` element, really just for aesthetic reasons so that the data
    doesn’t all run together.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了理解之前在生成`/register`路由的响应时看到的`tr`、`th`和`td`所应用的CSS类的上下文——这些元素是应用样式的`<tr>`、`<td>`和`<th>`标签！简单来说，它们在表头行中的`<th>`元素上设置了背景颜色，以便它们从数据中突出出来，然后每个`<tr>`和`<td>`元素周围都放置了一个边框，这主要是为了美观，以便数据不会全部连在一起。
- en: Completing the response
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成响应
- en: 'To wrap things up properly, we need to close the body and the HTML document
    that our response constructs, as well as close the `inResponse.send()` call and
    the `app.post()` function call. That’s done here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地结束，我们需要关闭由我们的响应构建的HTML文档的主体，以及关闭`inResponse.send()`调用和`app.post()`函数调用。这在这里完成：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that done, the only thing left to do is to start the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，唯一剩下要做的就是启动服务器。
- en: Starting the server
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'Starting the server means telling the object that Express gave back to us to
    start listening for requests:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器意味着告诉Express返回给我们的对象开始监听请求：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The aptly named `listen()` method of the `app` object is what allows us to do
    that. We pass to it what port to listen to and, optionally, a function to execute
    when it starts up. Since there are no arguments we need to pass to it, an empty
    set of parentheses is all we need (because it’s still a function we’re defining,
    after all), and then we again use arrow notation for the function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`对象中名为`listen()`的方法正是允许我们做到这一点。我们传递给它要监听的端口，以及可选的启动时执行的函数。由于我们不需要传递任何参数给它，所以只需要一个空的括号组（因为毕竟我们还是在定义一个函数），然后我们再次使用箭头符号来表示函数。'
- en: 'Go ahead and run the server (`npm run dev`) and play with it a bit to see it
    in action, including the start up text being displayed, as you can see in *Figure
    3**.5*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，运行服务器（`npm run dev`）并稍微玩一下，看看它的实际效果，包括启动文本的显示，正如你在*图3.5*中看到的那样。5：
- en: '![Figure 3.5: The output of console.log()](img/B18315_03_5.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：console.log()的输出](img/B18315_03_5.jpg)'
- en: 'Figure 3.5: The output of console.log()'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：console.log()的输出
- en: Deprecation warnings
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用警告
- en: By the way, the warning you can see in the preceding screenshot can be ignored.
    It’s a deprecation warning, which means that there is some change in process in
    a package that the server code depends on. The authors of that package alert us
    to the fact that, eventually, we’ll need to change our code in some way; otherwise,
    it will break (the change, in this case, is that the call to `express.urlencoded()`
    earlier will eventually require an object to be passed with an extended attribute
    – you can add `{extended:false}` as an argument to that call to get rid of the
    message now if you’d like, but it isn’t yet necessary, which is the point of a
    deprecation warning).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以在前面的屏幕截图中看到的警告可以忽略。这是一个弃用警告，这意味着服务器代码所依赖的包中有些过程发生了变化。该包的作者提醒我们，最终我们需要以某种方式更改我们的代码；否则，它将崩溃（在这个例子中，变化是，之前对`express.urlencoded()`的调用最终将需要一个带有扩展属性的对象——如果你愿意，现在可以添加`{extended:false}`作为该调用的参数来消除消息，但这还不是必要的，这就是弃用警告的目的）。
- en: Speaking of that start up text, inside of the function passed to `app.listen()`
    is a call to the `log()` method of an object named `console`. It’s easy enough
    to surmise that `console` is an object representing the command-line output, frequently
    called the *console*. And it’s easy to guess that `log()` is the method that allows
    us to write text to that console. But all that opens up a whole new world of knowledge
    that we’ll explore a little bit later in the *Loving your new best friend –* *DevTools*
    section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 说到启动文本，在传递给`app.listen()`的函数内部，有一个调用名为`console`的对象的`log()`方法。很容易推断出`console`是一个表示命令行输出的对象，通常被称为*控制台*。而且很容易猜测`log()`是允许我们将文本写入该控制台的方法。但所有这些都开启了一个全新的知识世界，我们将在稍后的*爱上你的新最佳朋友——*
    *开发者工具*部分稍作探讨。
- en: Well, that wasn’t so bad, was it? Writing servers is easy! However, so far,
    you’ve only written one *type* of server. Let’s now talk about another way we
    could write this server and registration page that is a little more modern.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那也不是那么糟糕，对吧？编写服务器很容易！然而，到目前为止，你只编写了一种类型的服务器。现在让我们谈谈另一种编写这个服务器和注册页面的方法，这种方法稍微现代一些。
- en: Exploring a different approach – single-page apps
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索不同的方法——单页应用程序
- en: When you click the button on our registration page, the form is sent to the
    server, which then produces a new HTML document. This document is sent back to
    the browser, which replaces the entire registration page with the results page.
    This is what is often referred to – at least by (relative!) old-timers like me
    – as the “classic” model of the web. In short, for every user action, the server
    is contacted, generating a new page to be displayed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击我们的注册页面上的按钮时，表单会被发送到服务器，然后生成一个新的HTML文档。这个文档被发送回浏览器，浏览器用结果页面替换了整个注册页面。这通常被（至少像我这样的相对较老的）人称为“经典”的网页模型。简而言之，对于每个用户操作，服务器都会被联系，生成一个新页面来显示。
- en: That’s an inefficient model, frankly. Imagine thousands of users all doing the
    same thing – the server must handle all those requests, and quickly, because users
    hate to wait! But even if it’s almost instantaneous, think about it from the user’s
    perspective – the screen is constantly being redrawn. It just doesn’t *look* great,
    or at least it doesn’t look like an app they run on their operating system. Imagine
    if your web browser had to completely redraw itself every time you, say, click
    a menu item on the toolbar. However, that doesn’t happen; the menu simply appears.
    So, why can’t a website work the same?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，这是一个低效的模型。想象一下，有成千上万的用户都在做同样的事情——服务器必须快速处理所有这些请求，因为用户讨厌等待！但即使它几乎是瞬间的，从用户的角度来看——屏幕一直在重绘。这看起来并不好，至少不像他们在操作系统上运行的那些应用程序。想象一下，如果你的网页浏览器每次你点击工具栏上的菜单项时都必须完全重绘自己。然而，这种情况并没有发生；菜单只是简单地出现。那么，为什么一个网站不能以同样的方式工作呢？
- en: In fact, it can! An approach referred to as *SPAs* does it. **SPA** stands for
    **Single Page App**, and what it means is that the HTML document you initially
    load is never thrown away and replaced with another. Instead, what happens is
    that when a request goes to the server, the server responds with just data, not
    a full HTML document. We then use JS to take that data and do something with it.
    It might be as simple as showing it on the page, which we can do through DOM functions.
    Alternatively, maybe we use it to do some calculations and display the result
    of those on the screen, or maybe we use it to modify the page somehow. In all
    cases, the main point is that the single HTML document that was loaded at the
    start is still there.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它可以！一种被称为*SPAs*的方法做到了。**SPA**代表**Single Page App**，这意味着你最初加载的HTML文档永远不会被丢弃并替换为另一个。相反，当请求发送到服务器时，服务器只响应数据，而不是完整的HTML文档。然后我们使用JS来处理这些数据。这可能只是简单地将其显示在页面上，我们可以通过DOM函数来实现。或者，也许我们用它来进行一些计算，并在屏幕上显示这些计算的结果，或者也许我们用它以某种方式修改页面。在所有情况下，主要观点是，最初加载的单个HTML文档仍然存在。
- en: This may sound a bit confusing right now, but I think once you see what we’re
    going to do to our little registration page, it’ll make a lot of sense. However,
    before we touch the code at all, I want to solve one minor problem and make life
    a little easier for us developers!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能现在听起来有点令人困惑，但我认为一旦你看到我们将要对我们的这个小注册页面做的事情，它就会变得很有意义。然而，在我们触摸代码之前，我想解决一个小的麻烦，让我们的生活作为开发者变得容易一些！
- en: Improving developer productivity through automation
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自动化提高开发者生产力
- en: You may not have noticed this, but if you were to make a change to the `index.js`
    file, such as changing the HTML it returns when the form is submitted, you would
    find that the change doesn’t take effect immediately. You have to stop and restart
    the server for the changes to “kick in,” so to speak. That’s quite inconvenient
    if you ask me! If you were making a lot of changes, that would get annoying fast.
    Fortunately, there’s an easy solution – **nodemon**!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到这一点，但如果你要对`index.js`文件进行修改，比如更改表单提交时返回的HTML，你会发现这个更改并不会立即生效。你必须停止并重新启动服务器，以便更改“生效”，这么说吧。对我来说，这相当不方便！如果你要做出很多更改，很快就会变得烦人。幸运的是，有一个简单的解决方案——**nodemon**！
- en: 'First, since `nodemon`’s an NPM package, we need to add it to our project.
    To do so, execute this command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于`nodemon`是一个NPM包，我们需要将其添加到我们的项目中。为此，执行以下命令：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Earlier, you saw how Express was added with the `–save` option, which added
    it to the dependencies element in `package.json`. The `–save-dev` option is similar
    but a little different. You see, there is also a `devDependencies` element that
    may be present in `package.json`. This works the same as the `dependencies` element,
    with one key difference – these are dependencies that we need during development
    but which our code itself does not depend on; `nodemon` is one such dependency.
    So, after executing that command, you’ll find a `devDependencies` element has
    been added, and `nodemon` has been added as a dependency in it (note this time
    that I did not specify an explicit version number, so NPM will install the latest
    version of `nodemon` – since our code doesn’t depend on it, this is safe and most
    likely desired, since having the latest version gives us any new features it may
    offer).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你看到了如何使用`–save`选项添加Express，它将其添加到`package.json`中的依赖项元素。`–save-dev`选项类似，但略有不同。你看，`package.json`中可能还有一个`devDependencies`元素。它的工作方式与`dependencies`元素相同，但有一个关键的区别——这些是我们开发期间需要的依赖项，但我们的代码本身并不依赖于它们；`nodemon`就是这样一种依赖项。因此，执行该命令后，你会发现已添加了一个`devDependencies`元素，并且`nodemon`已作为依赖项添加到其中（注意这次我没有指定显式的版本号，因此NPM将安装`nodemon`的最新版本——由于我们的代码不依赖于它，这是安全的，而且很可能是期望的，因为拥有最新版本可以给我们带来它可能提供的任何新功能）。
- en: 'Now, what `nodemon` does is watch (or *monitors*, hence the name `nodemon`)
    our files for changes and, when they are detected, restart our application for
    us. However, to make that happen, we have to start the server using `nodemon`.
    The way we do this is to modify the `dev` script we added to `package.json` earlier.
    Now, it should be as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`nodemon`所做的是监视（或*监控*，因此得名`nodemon`）我们的文件以检测更改，一旦检测到更改，就会为我们重新启动应用程序。然而，为了实现这一点，我们必须使用`nodemon`启动服务器。我们这样做的方式是修改之前添加到`package.json`中的`dev`脚本。现在，它应该是这样的：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `npx` command is an alternate version of `npm` that basically says, “*Run
    a program that is supplied by a dependency in our project.*” In this case, that
    of course means `nodemon`. But note how you would still, as a developer, execute
    the same `npm run dev` command to start the server. That command is what will
    start `nodemon`, using `npx` as per the script. And, by default, `nodemon` will
    simply monitor all the `.js` files in the project directory, and since we just
    have one, that’s all we need (you can configure `nodemon` to only monitor specific
    files, subdirectories, or many other options, but the defaults work just fine
    for us here).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx` 命令是 `npm` 的一个替代版本，基本上是这么说，“*运行我们项目中依赖提供的程序。*”在这种情况下，当然是指 `nodemon`。但请注意，作为一个开发者，你仍然会执行相同的
    `npm run dev` 命令来启动服务器。这个命令就是会启动 `nodemon`，按照脚本使用 `npx`。默认情况下，`nodemon` 将简单地监控项目目录中的所有
    `.js` 文件，由于我们只有一个，所以这就足够了（你可以配置 `nodemon` 只监控特定的文件、子目录或许多其他选项，但默认设置对我们来说已经足够好了）。'
- en: Writing a new kind of client
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写新的客户端类型
- en: Now, what we’re going to do is modify our registration page to work as an SPA.
    Rather than listing out all the code, I’m just going to show the changes required,
    just to save a few trees! If I don’t mention a specific change, then you can assume
    the code is the same as the original version.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改我们的注册页面，使其作为一个单页应用（SPA）工作。而不是列出所有代码，我只会展示所需的更改，以节省一些树木！如果我没有提到特定的更改，那么你可以假设代码与原始版本相同。
- en: 'The first change is a simple one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改很简单：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `action` and `method` attributes have been removed and an `id` attribute
    added. Removing `action` and `method` is a change I didn’t technically need to
    make, but it makes obvious the fact that the form won’t be submitted like before.
    Instead, the information from the form will be sent to the server in an entirely
    different way, which we’ll get to shortly. Adding the `id` attribute though is
    necessary, as you’ll see shortly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`action` 和 `method` 属性已被移除，并添加了 `id` 属性。移除 `action` 和 `method` 是一个技术上我不必做出的改变，但它清楚地表明，表单将不会像以前那样提交。相反，表单的信息将以完全不同的方式发送到服务器，我们很快就会了解到这一点。不过，添加
    `id` 属性是必要的，正如你很快就会看到的。'
- en: 'The only other change is to the button:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的另一个更改是按钮：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, the `type` attribute’s value is just `button` instead of `submit`. That’s
    because the `submit` type creates a special button that knows to submit the form
    to the server when clicked. But since we don’t want that to happen now, it’s changed
    to a plain button, which has no intrinsic action when clicked. To give it an action,
    we need to attach an event handler to it. The `onClick` handler is what executes
    when the user clicks the button of course, and in that case, we need it to execute
    some JS, the `registerNow()` function specifically, which we’ll look at very soon.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`type` 属性的值只是 `button` 而不是 `submit`。这是因为 `submit` 类型创建了一个特殊的按钮，当点击时会知道将表单提交到服务器。但既然我们不想这样，它就变成了一个普通的按钮，点击时没有固有的动作。要给它一个动作，我们需要给它附加一个事件处理器。`onClick`
    处理器当然是在用户点击按钮时执行的，在这种情况下，我们需要它执行一些 JavaScript，具体是 `registerNow()` 函数，我们很快就会看到。
- en: But first, there is a new bit of markup that needs to be added.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，需要添加一些新的标记。
- en: Embedding the response page
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入响应页面
- en: 'Remember, the whole point of what we’re trying to accomplish here is to submit
    the form data to the server, get some data back, and display it on the screen,
    *without* overwriting what’s there already. So, we’re going to need a place to
    show that data, and that’s what we’ll discover next:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在这里试图实现的整体目标是提交表单数据到服务器，获取一些数据回来，并在屏幕上显示，*而不覆盖现有的内容*。因此，我们需要一个地方来显示这些数据，这就是我们接下来要发现的：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code should look rather familiar to you – it’s almost exactly identical
    to the markup that the server generates in the original version. The key differences
    are first that everything is wrapped up in a `<div>` now, the one with the `theResults`
    ID. In addition, an inline style is used here. The `display` property in CSS tells
    the browser whether the content inside this element should be visible or not.
    Setting it to `none`, as is done here, means that this entire `<div>` will not
    be seen, at least not at first. And, indeed, if you run this code now, you’ll
    find that it looks exactly like the original version, but none of the content
    inside `<div>` is shown.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该对你来说相当熟悉——它几乎与原始版本中服务器生成的标记完全相同。关键的不同之处在于，现在所有内容都被包裹在一个带有`theResults`
    ID 的`<div>`中。此外，这里使用了内联样式。CSS中的`display`属性告诉浏览器这个元素内的内容是否应该可见。将其设置为`none`，就像这里所做的那样，意味着这个整个`<div>`将不会显示，至少最初不会。实际上，如果你现在运行这段代码，你会发现它看起来与原始版本完全一样，但`<div>`内的内容都没有显示。
- en: Secondly, the content in the row where the data is displayed is different. No
    longer do we have expressions like in the original version because, remember,
    this isn’t a template literal string like it is there; this is just plain old
    HTML. Instead, each of the `<td>` elements is now given an `id`, which will allow
    us to reference them in code later. And I prefixed the `id` values with `results_`
    so they can be differentiated from the fields in the form at a glance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，显示数据的行中的内容也有所不同。我们不再有原始版本中的表达式，因为，记住，这不是一个模板字面量字符串，而只是普通的HTML。相反，每个`<td>`元素现在都被赋予了一个`id`，这将允许我们稍后在代码中引用它们。并且我给`id`值加上了`results_`前缀，这样就可以一眼区分出表单中的字段。
- en: And, speaking of the code, that’s exactly where we’re headed next!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，说到代码，这正是我们接下来要去的方向！
- en: Executing the new JS code
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行新的JavaScript代码
- en: Coming back to that `registerNow()` function I mentioned earlier, you’ll find
    that it is contained within a `<script>` block that comes right before the closing
    `</html>` tag. That’s something you haven’t seen before – you’ve only ever seen
    a `<script>` tag inside `<head>` before now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我之前提到的`registerNow()`函数，你会发现它被包含在一个紧接在`</html>`标签之前的`<script>`块中。这是你之前没有见过的——你之前只见过在`<head>`内部使用`<script>`标签。
- en: As you can guess, you can put `<script>` tags anywhere because, remember, they
    aren’t content that is shown to the user, so they have no impact on your markup
    no matter where you put them. I put a `<script>` tag at the end for just one reason
    – so that I could discuss the markup changes first and not have to pull a “we’ll
    come back to this later” with the JS code, which is what I would have had to do
    if it was in `<head>`!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，你可以把`<script>`标签放在任何地方，因为，记住，它们不是展示给用户的内容，所以无论你把它们放在哪里，都不会影响你的标记。我把`<script>`标签放在最后，只有一个原因——这样我就可以先讨论标记变化，而不必用“我们稍后再回来”的方式处理JavaScript代码，如果它在`<head>`中，我就不得不这样做！
- en: 'But now, we’re ready to look at it, and I’m going to break it up into pieces
    to make it easier to digest, starting with this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们已经准备好查看它了，我将把它分成几个部分来更容易地消化，首先是这个：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You’ve seen a function defined before, but that `async` thing is new. Normally,
    when a function executes, it completes from start to finish in one go. However,
    there are some cases where we might need to do something in a function that can
    take a while. A good example – the one in play here – is calling the server. We
    need a way to, in effect, make our function “pause” until the server responds,
    which it normally would not do. The `async` keyword tells JS that we’re doing
    something like that here. On its own, it’s only part of the equation, and you’ll
    see the other part soon.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前见过函数的定义，但那个`async`特性是新的。通常情况下，当一个函数执行时，它会从开始到结束一次性完成。然而，有些情况下我们可能需要在函数中做一些可能需要花费一些时间的事情。一个很好的例子——这里正在使用的例子——就是调用服务器。我们需要一种方法，实际上让我们的函数“暂停”，直到服务器响应，而它通常不会这样做。`async`关键字告诉JavaScript我们在这里正在做类似的事情。单独来看，它只是方程的一部分，你很快就会看到另一部分。
- en: 'But first, let’s return to the function’s code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们回到函数的代码：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `getElementById()` method of the `document` object, which is an object the
    browser always provides to us, allows us to get a reference to a DOM node based
    on its ID. In this case, the form has an `id` of `theForm`, so the `theForm` variable
    now references the form.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`document`对象中的`getElementById()`方法，这是一个浏览器始终为我们提供的对象，允许我们根据ID获取一个DOM节点的引用。在这种情况下，表单有一个`id`为`theForm`，所以`theForm`变量现在引用了这个表单。'
- en: 'From there, we can pull out the data from the form:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以从表单中提取数据：
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Every entry field in the form is an element in an object named `elements`, which
    is a property of the form object referenced by the `theForm` variable. So, we
    can access each of them using bracket notation, as you can any property of an
    object.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的每个输入字段都是名为`elements`的对象中的一个元素，这个对象是`theForm`变量引用的表单对象的属性。因此，我们可以使用括号符号访问它们，就像访问对象的任何属性一样。
- en: What we’re doing here is building an object with keys for each of the form fields.
    We define an object with an opening and closing brace and then list the properties
    we want in it, in a key-value pair form. Then, just to prove that worked, the
    object is displayed in the console using `console.log()`, as you saw on the server
    side. However, here, you see another capability of that method – the ability to
    pass multiple arguments. Each argument will be displayed separated by some space.
    And if we pass an object as an argument, as is the case for the second argument
    here, `console.log()` will display the contents of that object for us. Immensely
    helpful, isn’t it?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是创建一个对象，它为每个表单字段定义了键。我们定义一个带有开闭花括号的对象，然后以键值对的形式列出我们想要其中的属性。然后，为了证明这起作用了，使用`console.log()`在控制台显示这个对象，就像你在服务器端看到的那样。然而，在这里，你看到了这个方法的其他能力——能够传递多个参数。每个参数都会通过一些空格分开显示。如果我们传递一个对象作为参数，就像这里的第二个参数一样，`console.log()`将为我们显示该对象的内容。这不是非常有帮助吗？
- en: I’m going to talk more about `console` and the wider world it hints at near
    the end of this chapter, so just keep it in the back of your mind for now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章的结尾更详细地讨论`console`以及它所暗示的更广阔的世界，所以现在就把它放在心里吧。
- en: 'Once we have that object, we can then call on the server using JS:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个对象，我们就可以使用JS调用服务器：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is where the second part of the `async` puzzle comes into play – the `await`
    keyword. This tells JS that whatever function or code follows may take some time
    to execute, and we *do not* want the rest of the function to execute until it
    does, as it normally would. We want to *await* the outcome of that call, in other
    words.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`async`谜题的第二部分发挥作用的地方——`await`关键字。这告诉JS，随后的函数或代码可能需要一些时间来执行，我们不希望函数的其他部分在它执行之前执行，就像它通常那样。我们的意思是想要等待这个调用的结果。
- en: In this case, what we’re awaiting is the result of a call to the `fetch()` function.
    This is a function the browser provides that allows us to make an HTTP request
    to a remote system – in this case, our server. The `fetch()` function can take
    in a lot of information to do its job, but in its simplest form, it requires two
    arguments – the URL to send the request to (`/register` in this case, just like
    the original version of this page) and an object with several properties that
    provides the data needed to make the call. Here, we first specify the HTTP `method`
    to use as `POST` again, as with the original form. Then, we need to provide some
    `headers`. Recall from earlier that headers are metadata that can be sent on a
    request to tell the server something about that request. In this case, we’re telling
    it that we’re sending something called JSON. The `Content-Type` header is the
    key in a key-value pair that allows us to express that, and the value is `application/json`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们正在等待对`fetch()`函数的调用结果。这是一个浏览器提供的函数，允许我们向远程系统发起HTTP请求——在这个例子中，就是我们的服务器。`fetch()`函数可以接收大量信息来完成其任务，但在其最简单的形式中，它需要两个参数——发送请求的URL（在这个例子中是`/register`，就像这个页面的原始版本一样）和一个包含所需数据的对象，以便进行调用。在这里，我们首先指定使用`POST`作为HTTP
    `method`，就像原始表单一样。然后，我们需要提供一些`headers`。回想一下，headers是可以在请求中发送的元数据，可以用来告诉服务器有关该请求的一些信息。在这种情况下，我们告诉它我们正在发送一种称为JSON的数据。`Content-Type`
    header是键值对中的键，允许我们表达这一点，其值是`application/json`。
- en: You’ll see strings like this frequently in headers, and when you do, this is
    something called a MIME type, where `application/json` value specifically is a
    common one these days, where `userInfo` object before, that was JSON! The server
    needs to know that the client is sending JSON, so this header and that specific
    MIME type do that.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在headers中经常看到这样的字符串，当你这样做的时候，这被称为MIME类型，其中`application/json`值在当今特别常见，就像之前的`userInfo`对象一样，它也是JSON！服务器需要知道客户端正在发送JSON，所以这个header和那个特定的MIME类型就做到了这一点。
- en: After that, we of course have to include the `userInfo` object, and this becomes
    the `body` of the request. However, when you make an HTTP request, the body is
    always a string. At this point though, we only have `userInfo` as a JS object,
    not a string. Fortunately, the JS engine provides an object called `JSON`, which
    gives us access to several useful methods, `stringify()` being one of them. You
    simply pass this function to a JS object, and it will return a string version
    of it, which we can then make the body of the request.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们当然必须包含`userInfo`对象，这将成为请求的`body`部分。然而，当你发起一个HTTP请求时，`body`始终是一个字符串。然而，在这个时候，我们只有`userInfo`作为一个JS对象，而不是一个字符串。幸运的是，JS引擎提供了一个名为`JSON`的对象，它为我们提供了访问几个有用方法的能力，其中`stringify()`就是其中之一。你只需将这个函数传递给一个JS对象，它就会返回该对象的字符串版本，然后我们可以将其作为请求的`body`。
- en: 'Once the response comes back, it will be put into the `response` variable.
    However, it will be a string at this point, and we want a JS object so that we
    can get the values from it. To do that, we can call the `json()` method of the
    `response` object. This is another asynchronous call though, so we have to use
    `await` again, after which we can display the resultant object:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦响应返回，它将被放入`response`变量中。然而，此时它将是一个字符串，而我们想要一个JS对象，以便从中获取值。为此，我们可以调用`response`对象的`json()`方法。然而，这又是一个异步调用，因此我们必须再次使用`await`，之后我们就可以显示结果对象：
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, now that we have an object with the data returned by the server, the
    last step is to show it on the screen (well, the last step after displaying it
    in the console, which is something you can do in a browser, just like in the server-side
    code):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们有了服务器返回数据的对象，最后一步是在屏幕上显示它（嗯，这是在控制台显示之后的最后一步，你可以在浏览器中这样做，就像在服务器端代码中一样）：
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the five data values are inserted into the page. Again, the `document.getElementById()`
    function is used, referencing the IDs assigned to the `<td>` elements from earlier.
    That gives us a DOM node object back, and many DOM node objects have an `innerHTML`
    property. This allows us to insert content between two tags – in this case, between
    the `<td>` and `</td>` tags corresponding to a given `id` value. The text to insert
    is simply the value of the various properties of the `results` object that `response.json()`
    gave to us.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，五个数据值被插入到页面中。同样，使用`document.getElementById()`函数，引用之前分配给`<td>`元素的ID。这给我们返回一个DOM节点对象，许多DOM节点对象都有一个`innerHTML`属性。这允许我们在两个标签之间插入内容——在这种情况下，在对应于给定`id`值的`<td>`和`</td>`标签之间。要插入的文本只是`response.json()`给我们的`results`对象的各个属性的值。
- en: Now, it’s great that all the data is inserted at this point, but it’s still
    not visible. To make it visible, we have to change the display CSS property of
    the `<div>` tag that contains the table. DOM nodes almost always have a `style`
    property, which allows us to alter any CSS properties on that node that we want
    to, so we can set the `display` property to an empty string. This may seem weird,
    but by default, the `display` property has no value, which tells the browser that
    it *should* be displayed, so that’s what we do here.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有数据都插入到这里真是太好了，但它仍然不可见。为了使其可见，我们必须更改包含表格的`<div>`标签的显示CSS属性。DOM节点几乎总是有一个`style`属性，这允许我们更改该节点上我们想要的任何CSS属性，因此我们可以将`display`属性设置为空字符串。这听起来可能有点奇怪，但默认情况下，`display`属性没有值，这告诉浏览器它*应该*被显示，所以我们就是这样做的。
- en: 'As a result, you can now see the data that the server sent back, as shown in
    *Figure 3**.6*:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你现在可以看到服务器发送回来的数据，如图*图3.6*所示：
- en: '![Figure 3.6: The result of calling the server](img/B18315_03_6.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：调用服务器的结果](img/B18315_03_6.jpg)'
- en: 'Figure 3.6: The result of calling the server'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：调用服务器的结果
- en: Now that we’ve reworked the client-side code for this new SPA approach, let’s
    look at what changes are required on the server side to ensure that the client
    and the server can talk to each other properly in the new way.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新设计了客户端代码以适应这种新的SPA方法，让我们看看在服务器端需要进行哪些更改，以确保客户端和服务器能够以新的方式正确地相互通信。
- en: Writing a new kind of server
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一种新的服务器类型
- en: Okay, great, we’ve modified our frontend code to prepare for this great new
    SPA version; now, we need to make some changes on the server. Once again, I’ll
    just show the changes; however, in this case, I’d definitely suggest looking at
    the complete code from GitHub because the one thing you’ll find is that it’s shorter.
    And that makes sense if you think about it – the styles and HTML that the server
    returns in the original version are now effectively part of the `index.html` source.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了，我们已经修改了前端代码以准备这个伟大的新 SPA 版本；现在，我们需要在服务器上进行一些更改。再次提醒，我会只展示这些更改；然而，在这种情况下，我确实建议查看
    GitHub 上的完整代码，因为你会发现它更短。如果你这么想，这是有道理的——原始版本中服务器返回的样式和 HTML 现在实际上是 `index.html`
    源代码的一部分。
- en: 'First up, we must tell Express that it needs to be able to work with JSON:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须告诉 Express 它需要能够处理 JSON：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `express.json()` method returns a function – a bit of Express middleware
    again – that knows how to work with JSON. Cool, that was easy!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.json()` 方法返回一个函数——这是 Express 中间件的一部分——它知道如何处理 JSON。太棒了，这很简单！'
- en: 'The next change comes in the handler function for a POST to the `/``register`
    route:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变化出现在对 `/register` 路由的 POST 请求的处理函数中：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Like I said, it’s shorter! The only real purpose of the server in this app is
    to echo back to the client the information received. Normally, you’d probably
    validate this data somehow, store it in a database, and so on. But remember, I’m
    just trying to demonstrate a client-server interaction here, which is the whole
    point of the chapter, so none of that needs to come into play.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我说的一样，这更简洁！在这个应用中，服务器的唯一真正目的是将接收到的信息回显给客户端。通常，你可能需要以某种方式验证这些数据，将其存储在数据库中等等。但请记住，我只是在尝试演示客户端-服务器交互，这是本章的全部重点，所以这些都不需要发挥作用。
- en: However, we will display the data that was received via the call to `console.log()`
    first, just so we have it ready if we need to debug. After that, an object is
    created, referenced by the `responseObj` variable, just like you saw earlier on
    the client side. This object is then passed to `inResponse.send()`, which results
    in a call to `JSON.stringify()`, as you saw earlier, being made automatically
    for us, since Express is aware that we want JSON – in the form of a string – returned.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将首先通过调用 `console.log()` 显示接收到的数据，以便在需要调试时可以使用。之后，创建了一个对象，由 `responseObj`
    变量引用，就像你之前在客户端看到的。然后，这个对象被传递给 `inResponse.send()`，这导致自动调用 `JSON.stringify()`，就像你之前看到的，因为
    Express 知道我们想要返回 JSON（以字符串的形式）。
- en: 'Let’s walk through this whole flow from client to server, detailing the steps
    involved:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头到尾梳理一下从客户端到服务器的整个流程，详细说明涉及的步骤：
- en: The JS in `index.html` sent an object in the form of a JSON string to the server.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html` 中的 JS 发送了一个 JSON 字符串形式的对象到服务器。'
- en: Express took that string and turned it into a JS object.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express 将那个字符串转换成了一个 JS 对象。
- en: Our server-side code then used the properties of that JS object to construct
    another object, with the data that was sent copied into it.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务器端代码随后利用那个 JS 对象的特性来构建另一个对象，并将发送的数据复制到其中。
- en: That object was then returned to the JS running in the browser as a string of
    JSON.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个对象随后以 JSON 字符串的形式返回给浏览器中的 JS。
- en: The code in the browser converted the string back into an object.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中的代码将字符串转换回对象。
- en: We then used the data from that object to populate the hidden table cells on
    the screen.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用那个对象中的数据来填充屏幕上隐藏的表格单元格。
- en: We then showed the table by updating the style of the `<div>` containing `<table>`.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过更新包含 `<table>` 的 `<div>` 的样式来显示表格。
- en: Critically, note that the original registration form is still there, untouched
    by the response from the server. That, in a nutshell, is the entire point of this
    new SPA version of this small and simple app. If you imagine this on a much larger
    and grander scale, such as Google’s Gmail or Microsoft’s Office Online, then hopefully
    you can quickly start to see the benefits. There’s more code involved of course,
    but you get better performance (usually), less server load (usually), and less
    network traffic (usually) with this SPA approach rather than the “classic” web
    approach, and that’s why the former is actually the more common approach to web
    development today overall. There definitely is still a place for the classic web
    approach, but that place is shrinking as time goes on.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，请注意原始注册表单仍然在那里，没有被服务器响应所触及。简而言之，这就是这个小型简单应用的新 SPA 版本的全部意义。如果你想象在一个更大更宏伟的规模上，比如
    Google 的 Gmail 或 Microsoft 的 Office Online，那么你可能会很快开始看到好处。当然，涉及的代码更多，但与“经典”的 Web
    方法相比，这种方法通常能带来更好的性能（通常），更少的服务器负载（通常），以及更少的网络流量（通常），这就是为什么前者实际上是今天整体上更常见的 Web 开发方法。当然，经典
    Web 方法仍然有它的位置，但随着时间的推移，这个位置正在缩小。
- en: Now that you’ve seen these two approaches – the “classic” web model and the
    SPA model – let’s discuss the topic I hinted at when I mentioned the `console.log()`
    function – developer DevTools.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了这两种方法——“经典”的 Web 模型和 SPA 模型——让我们讨论我提到 `console.log()` 函数时暗示的话题——开发者工具。
- en: Loving your new best friend – DevTools
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爱上你的新最佳朋友——开发者工具
- en: 'While `console.log()` is available in Node code on the server side, it’s an
    exceedingly small part of a much larger palette of tools that are available on
    the client side in the browser. To begin exploring that palette, go to a random
    website of your choosing, maybe www.microsoft.com or some other well-known site,
    and press *F12* once the page loads. You should find a new area in your browser
    opens up that looks something like *Figure 3**.7*:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `console.log()` 在服务器端的 Node 代码中可用，但它只是浏览器客户端可用的更大工具集的一个极小部分。要开始探索这个工具集，请访问你选择的任意网站，比如
    www.microsoft.com 或其他知名网站，页面加载完成后按 *F12*。你应该会在浏览器中打开一个新区域，看起来像 *图 3**.7*：
- en: '![Figure 3.7: Browser DevTools in “action”](img/B18315_03_7.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：浏览器开发者工具“行动”中的样子](img/B18315_03_7.jpg)'
- en: 'Figure 3.7: Browser DevTools in “action”'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：浏览器开发者工具“行动”中的样子
- en: 'These are the browser DevTools, and they are available in some form in all
    modern web browsers. Here, you can dig into the guts of the site you’re viewing.
    As you can see, there are many different tabs, each containing a wealth of data:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是浏览器开发者工具，它们以某种形式存在于所有现代 Web 浏览器中。在这里，你可以深入了解你正在查看的网站。正如你所看到的，有许多不同的标签页，每个标签页都包含大量数据：
- en: The `console.log()` statements. You can also see JS errors here, as well as
    network requests. In fact, now would be a good time to open DevTools while viewing
    our little user registration app and see what is output to the `console.log()`
    messages there, although remember that you’ll only see those for the code running
    in the browser, not those in the server-side code running in Node (those are output
    to the console).
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log()` 语句。你还可以在这里看到 JS 错误以及网络请求。实际上，现在是一个很好的时机，在查看我们的小型用户注册应用时打开开发者工具，看看那里输出的
    `console.log()` 消息是什么，尽管请记住，你只能看到在浏览器中运行的代码的这些消息，而不是在 Node 服务器端运行的代码中的那些（那些是输出到控制台的）。'
- en: The other tab that you’ll probably use most often is the **Network** tab. Here,
    you can also see network requests, but you’ll see a lot more of them than in the
    **Console** tab and a lot more details about them. In fact, assuming you’re looking
    at that tab now on some site, go ahead and click on a request and examine some
    of the details. You can see things such as the headers sent on the request and
    the body content, if there are any.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你最可能经常使用的另一个标签页是**网络**标签页。在这里，你同样可以看到网络请求，但你会看到比**控制台**标签页中更多的请求，以及更多关于它们的细节。实际上，假设你现在正在某个网站上查看那个标签页，就点击一个请求并检查一些细节。你可以看到诸如请求发送的头部和如果有内容的话，请求的主体内容。
- en: The **Elements** tab is another area of immense importance because it’s here
    that you can examine the DOM, examine individual nodes, and even alter their styles
    directly. Yes, you can actually change things about someone else’s web page! Not
    permanently of course, only in your own browser. But it’s a fantastic way to see
    how other developers have done things and how you can modify their work in numerous
    ways.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素**选项卡是另一个极其重要的区域，因为在这里你可以检查DOM，检查单个节点，甚至可以直接更改它们的样式。是的，你实际上可以更改别人的网页内容！当然不是永久性的，只是在你的浏览器中。但这是了解其他开发者是如何做事以及你可以以多种方式修改他们的工作的绝佳方式。'
- en: The **Sources** tab is where you can see all the various JS files, CSS files,
    and other resources that make up the website. And again, here you can actually
    edit that code, temporarily.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**选项卡是你可以看到构成网站的各个JS文件、CSS文件和其他资源的区域。同样，在这里你可以实际编辑这些代码，暂时性地。'
- en: The other tab I’d say is most important is the **Application** tab. Here is
    where you can find things such as cookies (small bits of information stored on
    your computer by websites) and other data that some sites store on your machine
    to do their work.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个我认为最重要的选项卡是**应用程序**选项卡。在这里你可以找到诸如cookie（网站存储在您计算机上的小信息块）和其他一些网站在您的机器上存储的数据。
- en: There are many other tabs, some of which are hidden by default unless and until
    you decide you need them, but I’d say those four are probably the ones you’ll
    find yourself using most commonly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选项卡，其中一些默认隐藏，除非你决定需要它们，但我会说这四个可能是你发现自己最常使用的。
- en: 'But let’s go back to that console object for a moment because `log()` isn’t
    the only method it offers. While not an exhaustive list, here are a few I think
    you’ll find most interesting:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们暂时回到那个控制台对象，因为 `log()` 不是它提供的唯一方法。虽然不是详尽的列表，但以下是一些我认为你会觉得最有趣的：
- en: '`clear()`: Well, it’s no surprise but this clears the console! This comes in
    handy in sections of your code where you want to focus on some messages and get
    rid of older ones.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 嗯，这并不令人惊讶，但它确实清除了控制台！这在你的代码中想要关注某些消息并去除旧消息的部分非常有用。'
- en: '`debug()`/`error(`)/`info()`/`warn()`: These are similar to `log()` except
    that they output messages that are usually colored or highlighted in some way,
    depending on the severity of the message. For example, you can call `console.error()`
    to display a message in bold red text so that an error stands out against messages
    that are just information that you might output with `console.info()` or `console.log()`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug()`/`error()`/`info()`/`warn()`: 这些方法与 `log()` 类似，但它们输出的消息通常会根据消息的严重性以某种方式着色或突出显示。例如，你可以调用
    `console.error()` 以加粗红色文本显示消息，从而使错误与仅包含信息的消息（你可能使用 `console.info()` 或 `console.log()`
    输出）区分开来。'
- en: '`time()`/`timeEnd(`)/`timeLog()`: Calling `console.time()` acts like you pressing
    the start button on a stopwatch, and then `console.timeEnd()` acts like you clicking
    it again, at which point you can call `console.timeLog()` to display the elapsed
    time between the (virtual) clicks. This is handy when you want to figure out how
    long some code takes to execute, usually to aid in performance tuning.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time()`/`timeEnd()`/`timeLog()`: 调用 `console.time()` 就像按下秒表的开始按钮一样，然后 `console.timeEnd()`
    就像再次点击它一样，此时你可以调用 `console.timeLog()` 来显示两次（虚拟）点击之间的经过时间。当你想要找出某些代码执行所需的时间时，这非常有用，通常用于性能调整。'
- en: '`dir()`: This may not have the best name, but it’s very handy. It displays
    an interactive listing of the properties of a specified JS object. You can expand
    and collapse sections of it, making it much easier to navigate larger objects.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir()`: 这个名字可能不是最好的，但它非常实用。它显示了一个指定JS对象属性的交互式列表。你可以展开和折叠它的部分，这使得导航更大的对象变得容易得多。'
- en: As with the tabs in DevTools, there are several more methods, but these are
    probably the most common. Note that the `console` object available in your Node
    code has most of these same methods, although the logging functions may not output
    messages with the same styling as in the browser.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与DevTools中的选项卡一样，还有许多其他方法，但这些可能是最常见的。请注意，在Node代码中可用的 `console` 对象具有这些方法中的大多数，尽管日志函数可能不会以与浏览器中相同的样式输出消息。
- en: As a web developer, you’ll find yourself using browser DevTools *a lot*, so
    I would very much encourage you to explore some random sites with them and see
    what you can do with them. There is an awful lot of power there – you could write
    a whole book on browser DevTools alone if you wanted to – and the best way to
    learn what they’re capable of is to simply jump in and experiment.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名网页开发者，你会发现自己在使用浏览器DevTools时会非常频繁，所以我非常鼓励你用它们探索一些随机的网站，看看你能用它们做什么。那里有非常多的功能——如果你愿意，你可以只写一本关于浏览器DevTools的书——了解它们的能力的最佳方式就是简单地跳进去实验。
- en: 'To help you along though – and assuming you’re using a Chromium-based browser
    such as Chrome, Edge Opera, Vivaldi, or Brave – going right to the source is probably
    best, and that means the Google DevTools team’s website: [https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools).
    Note that non-Chromium browsers such as Firefox and Safari also have DevTools,
    and they’ll be substantially the same, although certainly with differences and
    perhaps their own capabilities.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你——假设你使用的是基于Chromium的浏览器，如Chrome、Edge、Opera、Vivaldi或Brave——直接查看源代码可能是最好的选择，这意味着Google
    DevTools团队的网站：[https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools)。请注意，非Chromium浏览器，如Firefox和Safari，也有DevTools，它们将非常相似，尽管肯定存在差异，也许还有它们自己的功能。
- en: Remember that you can’t do any harm playing around with DevTools because you’re
    not modifying the code of a website for anyone but yourself on your own machine,
    so there’s no reason not to mess around! If you get yourself into a pickle, you
    have only to reload the page, and everything will return to normal.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以随意玩弄DevTools而不会造成任何伤害，因为你不是在为任何人的网站修改代码，而是在自己的机器上，所以没有理由不捣鼓一下！如果你陷入困境，只需重新加载页面，一切就会恢复正常。
- en: Reviewing the roadmap
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检视路线图
- en: 'With this chapter concluded, we can now fill in a few more boxes in our web
    developer roadmap:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束后，我们现在可以在我们的网页开发者路线图上填入一些更多的盒子：
- en: '![Figure 3.8: The roadmap, with a few more boxes filled in](img/B18315_03_8.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：路线图，填入了一些更多的盒子](img/B18315_03_8.jpg)'
- en: 'Figure 3.8: The roadmap, with a few more boxes filled in'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：路线图，填入了一些更多的盒子
- en: With this chapter, you opened up the **Networking** and **Developer Tooling**
    boxes on the roadmap. Of course, you also built up some knowledge about the boxes
    that were opened in the previous chapter too. Hopefully, the big picture is starting
    to form in your mind now, at least a little bit. The upcoming chapters will expand
    that picture of course – some a little, some a lot, but always expanding!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你在路线图上打开了**网络**和**开发者工具**的盒子。当然，你也在前一章中建立了一些关于已打开的盒子的知识。希望现在你的脑海中已经开始形成一幅大图，至少是一点点。接下来的章节当然会扩展这幅图——有的稍微一点，有的很多，但总是不断扩展！
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you built a simple user registration page and a server to work
    with it, using the “classic web” approach. You first built the frontend using
    some new concepts, including basic HTML forms to demonstrate submitting data to
    the server that way, and some new CSS properties, including shorthand properties.
    Then, you saw how to build a server that accepts that data and generates a response
    for the client that is then displayed in the browser using another new concept,
    HTML tables, to display tabular data.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用“经典网络”方法构建了一个简单的用户注册页面和与之配合的服务器。你首先使用一些新概念构建了前端，包括基本的HTML表单来展示如何通过这种方式向服务器提交数据，以及一些新的CSS属性，包括缩写属性。然后，你看到了如何构建一个接受这些数据并为客户端生成响应的服务器，该响应随后在浏览器中使用另一个新概念，HTML表格，来显示表格数据。
- en: Then, you saw an entirely different approach to transmitting data to a server
    and receiving a response, an approach that leads to the more modern SPA paradigm.
    This included building the frontend code that introduced some new JS concepts,
    including `async`/`await`, and `fetch()`. You saw how the server can handle a
    new kind of request from a client and generate a new kind of response using JSON,
    allowing the browser to display the results without overwriting the entire page.
    Finally, you saw how your web browser provides tools specifically for developers
    to examine pages, explore JS and CSS, and work with any website out there at the
    level of the code behind it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你看到了一种完全不同的将数据传输到服务器并接收响应的方法，这种方法导致更现代的SPA范式。这包括构建前端代码，引入了一些新的JS概念，包括`async`/`await`和`fetch()`。你看到了服务器如何处理来自客户端的新类型请求并使用JSON生成新类型的响应，允许浏览器在不覆盖整个页面的情况下显示结果。最后，你看到了你的网络浏览器为开发者提供专门用于检查页面、探索JS和CSS以及在其背后的代码级别上与任何网站交互的工具。
- en: In the next chapter, we’ll step back from code a little bit (not completely
    though!) and look at some other topics that a web developer should be familiar
    with, including source control, Linux, security, integrated development environments,
    and Python.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微从代码中退后一步（但并非完全退后！）并探讨一些网络开发者应该熟悉的其它主题，包括源代码控制、Linux、安全、集成开发环境以及Python。
- en: 'Part 2: Expanding Your Knowledge Base'
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：扩展你的知识库
- en: In this part, you’ll continue to gain technical knowledge about web development,
    including things such as developer tooling, security concerns, cloud infrastructure,
    virtual machines and containers, and DevOps.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将继续获取关于网络开发的技术知识，包括开发工具、安全顾虑、云基础设施、虚拟机和容器，以及DevOps。
- en: We’ll also talk about modern frontend frameworks such as React, Angular, and
    Vue, and see how they can be used to accelerate development, as well as talk about
    responsive design on the frontend.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论现代前端框架，如React、Angular和Vue，并了解它们如何用于加速开发，以及讨论前端上的响应式设计。
- en: We’ll then flip over to look at some backend concerns and technologies, including
    how to build servers with Node.js and Express, Java and Spring Boot, and PHP and
    Python.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将转向查看一些后端关注点和技术，包括如何使用Node.js和Express、Java和Spring Boot、以及PHP和Python构建服务器。
- en: Finally, we’ll begin to talk about some technologies that have the goal of allowing
    you to be a web developer while doing less coding. These include things such as
    content management systems (like WordPress and Drupal) and so-called “no-code”
    solutions such as GoDaddy’s Website Builder.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将开始讨论一些旨在让你在减少编码的同时成为一名网络开发者的技术。这些包括内容管理系统（如WordPress和Drupal）以及所谓的“无代码”解决方案，例如GoDaddy的网站构建器。
- en: 'This part includes the following chapters:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 4*](B18315_04.xhtml#_idTextAnchor105), *Managing, Securing, and Working
    with Code*'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18315_04.xhtml#_idTextAnchor105)，*管理、安全和处理代码*'
- en: '[*Chapter 5*](B18315_05.xhtml#_idTextAnchor129), *Understanding the User Experience,
    Deployment Options, and DevOps*'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18315_05.xhtml#_idTextAnchor129)，*理解用户体验、部署选项和DevOps*'
- en: '[*Chapter 6*](B18315_06.xhtml#_idTextAnchor159), *Exploring Modern Frontend
    Development*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18315_06.xhtml#_idTextAnchor159)，*探索现代前端开发*'
- en: '[*Chapter 7*](B18315_07.xhtml#_idTextAnchor176), *From Front to Back – More
    on Backend Tools and Technologies*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18315_07.xhtml#_idTextAnchor176)，*从前端到后端 - 更多关于后端工具和技术*'
- en: '[*Chapter 8*](B18315_08.xhtml#_idTextAnchor203), *Writing Less Code – CMSs,
    No-Code Solutions, and Generative AI*'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18315_08.xhtml#_idTextAnchor203)，*编写更少的代码 - CMS、无代码解决方案和生成式AI*'
