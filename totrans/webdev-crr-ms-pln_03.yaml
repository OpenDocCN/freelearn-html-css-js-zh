- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expanding the Foundations – Building a User Registration Page, Front to Back!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you’ve started building the technical foundations and have some
    context around web development. You’ve also seen some of the frontend (the client)
    and some of the backend (the server), but so far, you haven’t seen them put together.
    Let’s address that now!
  prefs: []
  type: TYPE_NORMAL
- en: In the process, you’ll first learn a little bit about networking, since the
    internet and websites are all built on top of networking. You’ll then get some
    exposure to more HTML, CSS, JS, and Node, and you’ll do this by building another
    simple web page and seeing how it communicates with the server side now.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to see how the client and server connect, how information is
    transmitted to the server, and how the server handles it and returns a response.
    This is part and parcel of what we do every day in web development, so clearly,
    it’s of paramount importance. Not only will you get some exposure to this but
    you’ll also do so in two different ways, ensuring that you can see that there
    is more than one way to skin a cat in web development.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn a little bit about the tools available to you that come with
    your web browser and how valuable they are, as they are tools you’ll interact
    with constantly as you work to debug and get things working exactly right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting over a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an interactive web app – the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an interactive web app – the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a different approach – single-page apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loving your new best friend – DevTools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purposes of this chapter, the only thing you’ll require is having Node
    installed and working, which you should have done in the previous chapter. You’ll
    also want to be sure you’ve downloaded all of the source code for this book from
    GitHub ([https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan)),
    which you can find in the *Technical requirements* section of [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061).
    As you’ve probably noticed by now, each chapter has its own directory in the downloaded
    code, so you’re interested in the `ch-03/1-form` and `ch-03/2-spa` directories
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: That’s really all you need for this chapter, so now, let’s build ourselves a
    user registration page!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting over a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we actually get to developing code, let’s first talk about something
    more fundamental, networking, and how the web communicates over a network.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned **IP** (**Internet Protocol**) in the last chapter, but I didn’t
    go into too much detail. I really won’t go into it too much here either because
    when we talk about network protocols, which include IP, it quickly becomes an
    expansive topic. However, as a web developer, you should know at least the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IP, as the second word in the acronym states, is a protocol. A protocol is simply
    an agreed-upon standard for how two things communicate. In this case, IP describes
    how small bits of data called **datagrams** are transmitted between two machines
    over a network. As you saw in [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061),
    it’s also what is responsible for giving each machine an IP address that uniquely
    identifies them on the network.
  prefs: []
  type: TYPE_NORMAL
- en: However, it may surprise you to learn that IP doesn’t guarantee the delivery,
    order, or integrity of the datagrams it transmits. In other words, if you want
    to send a picture from one machine to another, that picture will be broken up
    into many datagrams, and they will be transmitted over the network using IP, but
    they may or may not reach the destination, may or may not be in the proper order
    for the other machine to reconstruct the image (in fact, the receiving machine
    wouldn’t even have a way to know what order they should go in), and may or may
    not be corrupted in some way. IP is considered a “best-effort” protocol, meaning
    it’ll *try* to get data from machine A to machine B, but it’s not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds like a recipe for disaster, you’re right! But the benefit of
    it is that it is very simple and fast, and when you have something simple and
    fast in technology, it’s almost always easy to extend it or build something on
    top of it (we’re big on layers in software engineering). And that’s exactly where
    TCP comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TCP**, which stands for **Transmission Control Protocol**, works in conjunction
    with – or *on top of* – IP by ensuring that when information is sent, it is sent
    reliably. It begins by breaking the data to be sent down into **packets** (which
    IP will then further break down into datagrams), and it ensures that the packets
    all arrive at the destination, that they are error-free, and that they tell the
    receiver what order everything all goes in. It does this by establishing a connection
    between machines and then sending the packets, which the receiver will then examine.
    The packets contain data that the receiver can use to validate that the data is
    correct. They also include sequence numbers, which tell the receiver what order
    they go in. If a packet is corrupt, or if the receiver finds some missing, it
    can request the sender to resend the data, which is another key thing that TCP
    provides.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP is a great combination because, in a large network with a lot of machines
    (like the internet), there are a lot of routes between them and connections that
    packets can be transmitted across. If one connection is broken – maybe because
    someone accidentally cut a network cable while doing some roadwork – a different
    route can be chosen. In such a scenario, the fact that IP doesn’t provide concrete
    guarantees doesn’t matter because TCP on top of it has all the information it
    needs to request a retry from the sender as needed, and this can continue until
    all the data is received correctly and in the right order. This provides redundancy
    for the network. Yes, if packets suddenly must travel halfway around the world
    to get where they’re going, things will slow down a bit, but the data will still
    get there, and that’s the key thing TCP provides when working in conjunction with
    IP.
  prefs: []
  type: TYPE_NORMAL
- en: However, while TCP/IP serves as, conceptually, the foundational protocols of
    the internet, the web has its own protocol that sits on top of TCP/IP, and that’s
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of **HTTP**, which is an acronym for **HyperText Transfer Protocol**,
    as the foundation for data communication on the web.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP works as a request-response model between two machines, one acting as a
    client and one acting as a server. HTTP is what we call a **stateless** protocol,
    which means that each request is independent. In other words, when you enter a
    URL in your browser, a connection is established from your machine to the server,
    but that connection ends once the HTML page is returned to you. When an image
    or style sheet needs to be retrieved, a new connection is established. Well, more
    modern versions of HTTP will actually reuse connections to some degree, but the
    connections still don’t last forever, which is what we mean by stateless – there
    is not a constant connection between the two machines.
  prefs: []
  type: TYPE_NORMAL
- en: When you use HTTP to connect from one machine to another, each request uses
    an HTTP method, which comprises a basic set of operations that can be used to
    interact with a server. They are meant to, at least generally, convey to the server
    what the client wants to do. Note that this is different from a JS method – a
    function that is attached to an object – and is really just a fancy way of saying
    that it tells us what *kind* of HTTP request is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP defines several methods, where each one has a typical (although not concrete)
    intended use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET**: Retrieve data from the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST**: Send data to be processed by the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT**: Update existing data on the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: Remove data from the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` but a more limited version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPTIONS**: Discover allowed methods on a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you enter a URL in your browser, a `GET` request is made. That makes sense
    if you think about it – your browser is asking for data from the server, an HTML
    document usually. Other situations call for other methods – when you’re sending
    information to the server, you will probably use `POST` or `PUT`, depending on
    the situation – but you’ll see how choosing other methods comes into play in just
    a little while.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that HTTP, being closely tied to HTML, has a similar concept
    to the head and body in HTML, instead called the **headers** and body. Headers
    are bits of data that provide some metadata to the receiver. There are a substantial
    number of headers, and you can create your own too, so I’m not going to go into
    any here; instead, I’ll opt to introduce headers when necessary later. However,
    one thing I *will* tell you is that they are sent in **key-value pairs**. This
    is a common programming idea that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Whether a colon or equal sign (or possibly some other character) is used depends
    on the context, but the key point is that you have a key (`first_name`) and a
    value (`Frank`). The value is identified by the key. You can almost think of them
    as variables in JS in that you can look up the value associated with a key when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The body of an HTTP request can contain arbitrary data, whether that’s text,
    an image, an audio file, or anything else. When an HTTP request has a body and
    data in it, almost always it will use a `POST` method. You’re about to see an
    example of that, as part of a discussion of something else – HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP versus HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and if that wasn’t enough, there’s also HTTPS. Fortunately, that’s simple
    – it’s just HTTP but encrypted, with the **S** standing for **Secure**. If you
    see a URL with HTTP, it means that all the content sent back and forth using that
    connection could potentially be looked at by other people on the network (it’s
    not quite that easy to do, but it’s also not especially difficult). With HTTPS
    though, all that content is encrypted, and without some secret information called
    *keys*, a person who intercepts the data would essentially see a lot of gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: There was a time when HTTPS was only used for sensitive sites such as banking
    sites and shopping sites. That’s because, for a long time, the encryption and
    decryption process – which is based on some complex mathematics – was an expensive
    thing for computers to do. It was expensive in terms of money and, more importantly,
    in terms of performance. An HTTPS connection would simply be slower than an HTTP
    one. However, nowadays, that’s no longer the case. Computers are fast enough and
    often have specialized hardware specifically for encryption/decryption, so most
    connections are, in fact, HTTPS now. Browsers will even make you aware that a
    connection isn’t secure, and some will even disallow a non-HTTPS connection entirely.
  prefs: []
  type: TYPE_NORMAL
- en: For most intents and purposes, you can generally treat HTTP and HTTPS connections
    the same. However, in terms of development, setting up an HTTPS connection takes
    some additional configuration that can be non-trivial to set up. If you ever hear
    the term *certificates*, that’s what’s involved. That’s a whole other topic that
    can get rather complicated, so it won’t be covered in this book. When developing
    on your own machine, you can simply use HTTP, which is what will be used by default
    if you don’t explicitly set up HTTPS, and you needn’t worry about certificates
    and all that unless and until you really have to.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how things communicate over the internet (and
    most networks generally) in hand, we can now move on to building the aforementioned
    registration app.
  prefs: []
  type: TYPE_NORMAL
- en: Building an interactive web app – the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, rather than just using simple HTML as you’ve previously seen,
    let’s create an application that looks somewhat more “real.” By that, I mean let’s
    create something you might actually have to build on the job someday – a user
    registration page.
  prefs: []
  type: TYPE_NORMAL
- en: The goal will be simple – give a user a way to enter a few key pieces of information
    (their title, first and last names, age, and email address) and then send that
    information to a server, where we’ll generate a response to confirm that the user
    is now registered. We won’t actually register the user in any fashion – we won’t
    even store the information they sent – but it’ll be enough to see how such a client-server
    interaction works.
  prefs: []
  type: TYPE_NORMAL
- en: Building a registration page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to build a page where the user enters their information.
  prefs: []
  type: TYPE_NORMAL
- en: Well, I take that back, because the *real* first step is to start a project.
    As you learned in the previous chapters, this can be as simple as creating an
    HTML file; however, you also saw how you can use NPM to create a new project.
    Since we know we’ll be building a server later for this project, let’s go ahead
    and do that now.
  prefs: []
  type: TYPE_NORMAL
- en: As before, simply create a directory, go to a command prompt, navigate to the
    directory, and execute `npm init`. For now, you can just press *Enter* for every
    question, as this will be sufficient for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s done, it’s time to write some HTML, the result of which will be
    what you see in *Figure 3**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The registration page we’re building](img/B18315_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The registration page we’re building'
  prefs: []
  type: TYPE_NORMAL
- en: You would begin this project by creating a file in your project directory, named
    `index.html`, and then get to work writing the code in it. Of course, I’ve already
    done that part for you! In the GitHub repo, you’ll find this file in the `ch-03/1-form`
    directory. Since there is a bit more to it than in the prior examples, we’ll tackle
    it bit by bit, breaking it down into manageable chunks, starting with `<head>`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the head
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our registration page, we start the HTML document, as before, with an `<html>`
    tag and then a `<head>` section within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By now, the code should be starting to make some sense to you, since you’ve
    seen it before.
  prefs: []
  type: TYPE_NORMAL
- en: However, unlike the examples shown in the previous chapters, there is no `<style>`
    block in `<head>`. Instead, all the CSS is in an external `styles.css` file. I
    did this for one main reason – so that I could skip the CSS for now! There’s not
    much CSS to deal with at all; however, it will make more sense if you see how
    HTML styles it first, so we’ll be coming back to it at the end. For now, just
    know that the style sheet file gets imported by the `<link>` tag and acts as if
    it were a `<style>` block directly in `<head>`, as seen in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: There is also no JS in this project, so that’s actually all there is for `<head>`.
    Now, we can move on to creating `<body>`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with `<head>`, `<body>` starts out very simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a heading with a paragraph of text under it. Of course,
    you know there’s more – all those fields you saw in *Figure 3**.1* where the user
    can enter their information and the button to submit it – but all of those constitute
    a new concept that I’ll introduce now – forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In HTML, forms are how we provide a way for users to enter information. A form
    consists of one or more form fields, and these fields come in several types. You
    may not realize it, but unless you’ve literally never used a website, then you
    know many of these fields, even if you don’t realize you do. Putting that aside,
    it all starts with defining a form itself, and with HTML, that means a new tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `<form>` tag is how we begin a form. This tag has several attributes, but
    the two key ones are `action` and `method`.
  prefs: []
  type: TYPE_NORMAL
- en: The `action` attribute tells the browser what URL to send the information the
    user enters. You can express this URL as an *absolute* URL or a *relative* URL.
  prefs: []
  type: TYPE_NORMAL
- en: An absolute URL contains all the information needed to get to a given resource.
    For example, www.packt.com/takeMyInfo is an absolute URL because it starts with
    a domain name and includes a full path to a resource on the server. [www.packt.com/books/zammetti/forms/takeMyInfo](http://www.packt.com/books/zammetti/forms/takeMyInfo
    ) might be another (this is fake, for the record!) example of an absolute URL.
  prefs: []
  type: TYPE_NORMAL
- en: What, then, is a relative URL? A relative URL starts from an absolute URL or,
    more precisely, *part* of one. /takeMyInfo is an example of a relative URL. If
    the document that uses that URL is loaded from [www.packt.com](http://www.packt.com),
    the browser interprets all relative URLs as being relative to that base URL. So,
    the full URL that /takeMyInfo leads to is www.packt.com/takeMyInfo.
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex example, /books/zammetti/forms/takeMyInfo could be a relative
    URL. If you loaded an HTML document from [www.packt.com/books/zammetti](http://www.packt.com/books/zammetti),
    then you could have a relative URL of /forms/takeMyInfo, since the two get joined
    together by the browser behind the scenes, forming the absolute URL that it will
    then request resources with.
  prefs: []
  type: TYPE_NORMAL
- en: In this `<form>` though, `/register` is the URL the form will be sent to, and
    you’ll see what is there waiting for it later when we talk about the server part
    of this project.
  prefs: []
  type: TYPE_NORMAL
- en: The other key attribute is `method`. This is the HTTP method used to transmit
    the form, and it will be either `GET` or `POST`. The difference is that when it’s
    `GET`, the information on the form is added to the URL as a `?aaa=bbb&…` form,
    where `aaa` is a key and `bbb` is a value. For example, in this form, we’re going
    to ask the user for their first name and last name. If this information is sent
    via `GET`, a query string will be appended to the URL as `?first_name=Frank&last_name=Zammetti`.
  prefs: []
  type: TYPE_NORMAL
- en: This is fine in some cases, but in most, it’s a bad idea because it has security
    implications and also because a URL has a size limit, and the information might
    be larger than you have space for. So, you can POST the information instead, which
    will cause the browser to send it in the body of the HTTP request, where there
    is effectively no limit and where it’s not *quite* as exposed to the world (it’s
    still quite easy to get, but every little bit helps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have `<form>`, we can start adding fields to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `<p>` tag is, strictly speaking, not necessary in a form. In fact, you can
    define your HTML and your layout however you like, but here, I just want each
    field to go down the screen, so putting each field in `<p>` does the job simply.
    I want each field to have a text label too, and that’s where the `Title` text
    comes in. I want that label to be above the field itself, so `<br>`, a line break
    in other words, ensures this.
  prefs: []
  type: TYPE_NORMAL
- en: An `<input>` tag defines a field in the form where the user can enter information.
    In most cases, a single-entry field on the screen is also a single `<input>` tag
    in the HTML, with a `type` attribute that tells the browser what kind of field
    it is out of several choices. However, in the case of a `radio` button, which
    is the type of control where you can select one and only one from a set of options,
    there will be multiple `<input>` tags of type `radio`, one for each option. The
    `name` attribute tells the browser what the name – the key – of the input value
    should be in the form. Here, we’re saying that in this form, we want to have a
    key named `title`, and it will have one of the three values available (which are
    defined literally by the `value` attribute of each `<input>` element). When the
    user selects one of the three options, the `title` value in the form will reflect
    that selected `value`.
  prefs: []
  type: TYPE_NORMAL
- en: If that seems a bit confusing, don’t worry – I think you’ll find it makes more
    sense later in this chapter when you see the server interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that comes two `<input>` fields, for the first and last names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have another kind of `<input>` field – a `text` field. This allows
    the user to enter any arbitrary text they want to. Then, again, the `type` attribute
    tells the browser what kind of field we want, and `name` tells it what key will
    hold the value the user enters.
  prefs: []
  type: TYPE_NORMAL
- en: The `size` attribute tells the browser how large the field physically is, and
    it’s defined as how many characters wide the field should be. When we talk about
    non-proportional fonts – meaning that each character takes up a variable amount
    of space (the letter “I” doesn’t take us as much space horizontally as “W” does,
    for instance) – this value can be a little fungible. But, as a rule of thumb,
    if `size` is `20`, then you can generally see 20 characters at a time in it, give
    or take a little. Note that this does not set a limit on how many characters can
    actually be entered; the field will scroll if you enter more than the size attribute
    allows for (there is a `maxlength` attribute that sets a limit on how many can
    be entered).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a different kind of input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `type` of `number` ensures that only numeric values can be entered; if you
    try to enter a letter, the browser won’t allow it. In addition, most browsers
    will show up and down arrows to allow the user to scroll through available values.
    This tag allows us to set a limit on the numbers entered; here, 13–100 is allowed
    by setting the `min` and `max` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `step` attribute tells us by what increment the number changes when
    the arrow buttons are used (if the value were 2 instead of 1, then it would jump
    from 13 to 15 to 17 when the up arrow is clicked, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.2* shows the presentation of the up and down arrows, which could
    be different depending on the browser (this example is from Chrome):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: How Chrome shows the arrows in a number field](img/B18315_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: How Chrome shows the arrows in a number field'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that comes the final input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `email` type ensures that the value entered is a valid email address. If
    you enter a value that isn’t valid (`none@@@nowhere`, for example), the field
    will be highlighted, and hovering over it will show a tooltip explaining the problem.
    Note that the presentation of this is browser-specific, but *Figure 3**.3* shows
    what you should see when hovering over the field in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: How Chrome shows errors in an email field](img/B18315_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: How Chrome shows errors in an email field'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the input fields, we need a button for the user to click to send the
    information to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are several types of buttons, and you’ll see another later in this chapter,
    but `submit` is perhaps the most important, as it literally tells the browser
    that, when clicked, it needs to send the information entered to the server. The
    text between the opening and closing `<button>` tags is the label that will be
    shown on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one thing remains now, and that’s to close the form properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With all that done, we have ourselves a complete HTML form that will send its
    information to the specified `action` URL when the user clicks the button. But
    we’re not quite done yet; we still have an HTML document to complete!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the body and the document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we have to close the body of the document using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to close the document itself using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With those tasks complete, we now have a complete HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when I said we’d skip the style sheet earlier? Well, it’s time to look
    at that now!
  prefs: []
  type: TYPE_NORMAL
- en: Adding some style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, you saw that the `styles.css` file is imported in `<head>`. The content
    in this file isn’t very voluminous, but it demonstrates a few new CSS concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first new concept is `<a>` tag can be displayed in three different states
    – when the user has never clicked it (unvisited), when the user has clicked it
    before (visited), and when the user’s mouse pointer hovers over it. If you want
    a link to be red when unvisited, blue when visited, and green when hovered over,
    you can create a CSS class with the names `a:visited`, `a:unvisited`, and `a:hover`,
    setting the appropriate `color` property value on each. The colon and the word
    after it are the pseudo-class.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I want to ensure that the email field specifically will have a
    red border when an invalid email address is entered. Fortunately, there is a pseudo-class
    on the input selector for that, namely `:invalid`. So, `input:invalid` is the
    selector to use to target an invalid input field.
  prefs: []
  type: TYPE_NORMAL
- en: The second new concept is the `outline` property. This property allows us to
    draw a border around an element (it’s one of two ways to do this, and you’ll see
    the other later). This property also actually demonstrates a third bonus concept
    – **shorthand properties**. Let me explain that a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You see, there are three things defined by this property:'
  prefs: []
  type: TYPE_NORMAL
- en: The width of the border to draw around the field (2 pixels – `px` is short for
    pixels, which are the dots that make up the picture on your monitor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The style of the border (`solid` here)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The color of the border
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These could each be defined by independent properties too – `outline-width`,
    `outline-style`, and `outline-color`. However, just using the `outline` shorthand
    property allows us to set all three at once.
  prefs: []
  type: TYPE_NORMAL
- en: Several groups of related properties have shorthand properties like this in
    CSS, and you’ll see some more of them later too. However, to not keep you in suspense,
    some of the others include `margin` (shorthand for `margin-top`, `margin-bottom`,
    `margin-left`, and `margin-right`), `padding` (shorthand for `padding-top`, `padding-bottom`,
    `padding-left`, and `padding-right`), `background` (shorthand for `background-color`,
    `background-image`, `background-repeat`, `background-attachment`, and `background-position`),
    and `font` (shorthand for `font-style`, `font-weight`, `font-variant`, `font-size`/`line-height`,
    and `font-family`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a frontend (a client), let’s build a backend (a server) for
    it to talk to. This will require us to write some code that will accept the data
    the user enters on the form and return a response of some sort for the browser
    to display to them. Let’s get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Building an interactive web app – the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build the server for this little project, we’ll again use Node. However,
    rather than write a server from scratch as we did in the last chapter, this time
    we’ll use possibly the most popular package available for Node to take care of
    a lot of the basic details for us – Express.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write a Node server from scratch, you must take care of all of the
    details yourself. That means that, for example, if you want to have a server respond
    to multiple different URLs, in your handler function you’ll need to examine the
    URL that was requested and, based on it, branch to a piece of code to return the
    appropriate response. It doesn’t take too long for an application to become large
    enough that this becomes a real headache.
  prefs: []
  type: TYPE_NORMAL
- en: So, very often, we’ll use an add-on package for Node that handles a lot of that
    for us – one such package is called **Express**. Express is actually a very powerful
    module that can handle all sorts of things for us, including security, file uploads
    and downloads, the logging of operations, and templating (the ability to have
    HTML and other response types built in a generic way that can then have data plugged
    into an outline, or template, to return a full response).
  prefs: []
  type: TYPE_NORMAL
- en: Express is also the first **framework** you’re meeting. A framework is a pre-written
    code library that provides a foundation to build your own code. It offers a defined
    structure to your code, so you don’t have to guess and make it up yourself, and
    it pushes you to use best practices. In essence, they are meant to make it easier
    to develop software and allow you to write less code yourself, which as a general
    rule is a good thing, since it means fewer opportunities for you to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, Express is what’s called an “unopinionated” framework.
    Whereas opinionated frameworks ensure that there’s really only one “right” way
    to do things, and you’d better do it that way or you’ll find yourself having a
    challenging time, unopinionated frameworks don’t force as much on you. Express,
    being unopinionated, allows you much more flexibility and, while saving you a
    lot of effort, still allows you to do things your way for the most part. The debate
    about whether opinionated or unopinionated frameworks are better is an age-old
    one that I’m not even going to attempt to answer here!
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Express, we have to add it as a dependency of our project,
    so let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the `package.json` file that was created when you ran the `npm init`
    command? I said that it provides Node and NPM metadata about our project, but
    I also said we’d largely ignore it. Well, we *have* to look at it now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what I got from the `npm init` command (remember, yours could look slightly
    different depending on the values you may have entered, but it should look *substantially*
    the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most of this is still ignorable, but one thing we now have to care about is
    the `dependencies` element. This tells Node and NPM what packages our project
    depends on. Yours will be empty at this point, but I’ve already added the Express
    dependency in mine, and I’ve also specified exactly which version I want. If you
    head over to [https://www.npmjs.com](https://www.npmjs.com), you can explore all
    the different packages available. NPM uses this site to download the dependencies
    you add to your `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do you actually add a dependency into `package.json`? Well, given that
    this is just a text file, you could just go and edit it by hand. However, there
    is a better way. First, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, open `package.json` again, and you should now find the same dependency
    entry as shown in that command. The `npm install` command tells NPM to install
    the package you name in your project (it gets added to `node_modules`).
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve specified the version as `@4.18.2`. You don’t *have* to specify the
    version like this, and in fact, you usually will not want to. What will happen
    when you don’t is that NPM will install whatever the latest version of the package
    is. I’ve specified the version explicitly here because, with a book, you need
    to ensure that a reader, months or years after the book was written, will still
    get the exact right versions that are known to work with the code; otherwise,
    a newer version might possibly not work with the code as written and described
    by the text (I’ve learned this lesson the hard way!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to update the `package.json` file, we need to specify the
    `–save` option. Not doing so will cause NPM to install Express in `node_modules`
    but not add it to the list of dependencies in the `package.json` file. When you’re
    just experimenting with a new package and don’t yet know whether you’ll continue
    to use it in your project, not specifying `–save` is good because nothing is permanently
    altered that way. But since we know we want Express to stick around, we *do* want
    to update the file, and the reason you want the file to be updated is that you
    can give another developer your `package.json` file, and all they have to do is
    execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: NPM will then look in `package.json` and install all the dependencies listed.
    That way, the developer is ready to work on your code and will have all the same
    dependencies as you.
  prefs: []
  type: TYPE_NORMAL
- en: It’s something you wouldn’t know unless you’ve experienced it, but setting up
    a new developer’s development environment hasn’t always been that easy. In the
    past, they would have to go to the internet and manually download all the dependencies
    – which weren’t always on one site – and that’s assuming they even had a list
    of what was needed. NPM, through its `package.json` file, solves all those problems!
  prefs: []
  type: TYPE_NORMAL
- en: The last thing I want to mention is that if you look in your project directory,
    you’ll find a new directory has been created, called `node_modules`. This is a
    directory that NPM creates to keep all the packages it downloads in. For the most
    part, you don’t need to look at this directory or care what’s in it; just let
    Node and NPM do their thing with it. You should also be aware that it can get
    rather large at times because if a package itself depends on another package,
    then that package will be downloaded, and that sort of chain of dependencies can
    keep going for a while. So, `node_modules` will be stuffed with packages you don’t
    recognize because they all have dependencies. That’s how it’s meant to work. If
    you ever delete `node_modules`, that’s fine; you can just run `npm install` again
    and it will be recreated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the dependencies added that we need, let’s address one issue
    that you may not have even realized in the code for the previous chapter – that
    of developer efficiency – and in the process, you’ll see a new capability that
    the `package.json` file provides for – scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, starting our server would be done with the `node index.js` command.
    However, when another developer wants to work on our project, they may not know
    that. With only a single JS file, it’s easy enough to guess, but imagine if we
    had hundreds of files, which definitely can be the case in larger projects – how
    would you know where to start?
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might guess it’s `index.js`, since that is the default value
    that NPM will set for the `main` property in `package.json` when you execute `npm
    init` in a project, but a) there might not be an `index.js` file at all, and b)
    that may not be the right answer even if it *is* there, as the developer of the
    project may have made a different choice. We can tell the developer which file
    it is of course, but shouldn’t there be a better way to communicate that information
    without explicitly having to tell someone?
  prefs: []
  type: TYPE_NORMAL
- en: There is, and it comes about due to another available element in the `package.json`
    file – `scripts`. The `scripts` element gives us a way to, in a sense, create
    custom NPM commands. Anything that appears in that element can be run with the
    `npm run XXX` command, where `XXX` is a key in `scripts`. NPM, by default, gives
    us a `test` command, so you can run that with `npm` `run tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this capability to provide a way to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can execute `npm run dev` to start the server, and the `scripts`
    entry knows which file to run, so the developer doesn’t need to. This is a common
    command to include, so many developers will know it automatically. But even if
    they don’t, they can simply look in `package.json` and see the available commands.
    It is, in a sense, a way to document the proper start up command for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Express added to our project, and a start-up script to run
    it with, let’s use it to write our server code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the server code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by creating an `index.js` file in the project directory. This will
    again be the server code from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time you add a package to a Node project, you’ll almost certainly need
    to import it into your code, and that is indeed the first thing we have in `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us an object named `express`, from which we can use several properties
    and methods. However, the object itself is a function in this case – in other
    words, the `express` variable points to a function, so we can execute it as a
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `express()` function is that a server object is returned
    to us. Express handles all the setup and creation of that server. However, because
    the object is returned to us, Express gives us the ability to configure the server
    to meet our specific needs, and the first thing we need to do is tell it that
    we want to be able to handle forms being sent in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `app.use()` function allows us to configure Express **middleware**. That’s
    really just a fancy way of saying that we can tell Express to execute one or more
    functions for every request that comes in. This comes in handy for things such
    as logging the incoming request to make debugging easier, implementing some sort
    of security, or, in this case, telling it to handle form data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Express middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a form is sent to a server via `POST`, it gets encoded in a unique way
    in the body of the request, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For the server to be able to make sense of that, it must know how to parse it
    and what middleware function to use to do so. Express provides several prebuilt
    middleware functions, one of which is given to us if we call the `express.urlencoded()`
    function. It returns the function, which we then add to Express as middleware
    by passing it to the `app.use()` function. Without this, Express wouldn’t be able
    to handle the form data that our client code will send to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can add zero, one, or more middleware functions via calls to `app.use()`.
    Each time you call it, you give it a reference to a function, whether it’s one
    you create yourself, one that Express supplies, or one from a third-party source,
    and it gets added to the chain of middleware functions that Express will execute
    for each request that comes into it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Express routes with JS arrow functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perhaps the key concept of Express is the idea of **routes**. Routes are really
    just URLs. Defining a route in Express means defining the function to execute
    for a given URL. For our little app, we need two routes, beginning with the default
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the default route because it’s what will execute when the URL has nothing
    after the domain. In other words, if you access [http://localhost](http://localhost)
    with the server running, this is the route that will be hit because there’s nothing
    after the domain, which is `localhost` in this case. The `"/"` argument equates
    to “nothing after the domain.”
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `app.get()` function registers a route with Express that will be
    accessed using the HTTP `GET` method, which you’ll recall is what the browser
    uses by default, so that’s what we need here. The second argument passed to this
    function is what we call a **handler function**, which is just a plain old JS
    function to execute when a request comes in via this route.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, here, I’m using a different form of functions available to us in JS
    that you haven’t seen before – `app.get()` call so that we can look at it in isolation,
    it would be just this snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That is equivalent to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we could write that `app.get()` call like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With arrow functions, you’re essentially trading the `function` keyword for
    the `=>` characters. In most cases, these two are absolutely equivalent, but there
    are some subtle differences that can become large in more advanced situations.
    I’m going to skip that for now because there are some other concepts you would
    need to be introduced to before you could understand the explanation. At this
    point, I’ll just say that, at the time of writing, developers tend to use arrow
    functions more because they are shorter (although only by a character or two)
    and more aesthetically pleasing. Your opinion may be different, but at the end
    of the day, you can generally just choose whichever you prefer (at least until
    you hit the situations where it matters what you choose, which I’ll touch on in
    later chapters). Arrow functions can be written in some other forms as well depending
    on developer needs, but I’ll explain those when we get to them in other code.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow function syntax aside, the function performs a simple task – sending a
    file back to the browser. The file that is sent back is `index.html`, sent by
    calling the `sendFile()` method that the `inResponse` argument provides to us.
    `inRequest` and `inResponse` are objects that Express and Node create and pass
    to the function that we can use to construct a response. They provide many methods
    and properties to examine the incoming request, get data from it, and produce
    a response, `sendFile()` being one of them.
  prefs: []
  type: TYPE_NORMAL
- en: However, let’s talk about what is passed to `sendFile()` a bit. In JS, the backtick
    character (`` ` ``) is used to define a special kind of string, called a `${}`,
    with something between the braces. And what is the something? Well, it can be
    any valid JS! What happens is that the JS engine, when it encounters such a template
    literal string, will replace each of those expressions, resulting in the JS executing
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the JS to execute is actually just the name of a variable that Express
    provides – `__dirname`. When JS sees just a variable name like this, it simply
    inserts the current value of that variable into the string. The `__dirname` variable
    contains the full path of the directory that the `index.js` file is in at runtime.
    When we append `/index.html` to it – which is what happens when this template
    literal is interpreted by JS – we get a full path to that file, which just so
    happens is what `sendFile()` needs to return that file to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to add another route specifically for the style sheet file that is
    imported; otherwise, you’ll find that the styles don’t work because the file can’t
    be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’re serving a specific file using a specific URL, the one specified
    in the `<link>` tag in `index.html`. Remember that our server won’t do anything
    we don’t specifically program it to do, including responding to the browser’s
    request for that stylesheet file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That route will allow us to see the registration page, but we also need a route
    for the form to be submitted to, so we’ll define that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This time, remember that we’re going to send the form to the server with the
    HTTP `POST` method, so we have to call `app.post()` this time. The URL will be
    [http://localhost/register](http://localhost/register) this time, so the route
    is `/register` (again, relative to the base URL, which in this case is just the
    domain name).
  prefs: []
  type: TYPE_NORMAL
- en: The handler function we pass along this time returns content directly from this
    code, not from a separate file, and the `inResponse.send()` function allows us
    to do that. We pass it a string, and that string is returned to the browser. The
    string, in this case, is the actual HTML document to return, our registration
    acknowledgment page. And here, you can see why being able to spread a template
    literal string onto multiple lines is nice – imagine if all that HTML was put
    on a single, lengthy line, which is what we’d have to do with plain old strings.
  prefs: []
  type: TYPE_NORMAL
- en: I would think that, at this point, most of that HTML looks pretty self-explanatory
    to you, save for the style classes defined there. You will know, based on the
    selectors, that the classes must style some HTML elements called `th`, `tr`, and
    `td`, but at this point, you don’t know what they are. Let’s remedy that situation
    now by talking about a new HTML concept – tables.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tables in HTML are a lot like spreadsheets – they allow us to organize data
    in rows and columns. We begin a table with, unsurprisingly, a `<``table>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By default, a table won’t have a border, but I want it to in this case, so I’ve
    added an inline style for it. The `border` property is very much like the `outline`
    property you saw earlier. It’s another of those shorthand properties I previously
    explained, and in this case, it has the same values as `outline` – the width of
    the border in pixels, the style of it, and the color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a table, we can begin filling it with rows of data. Each row is
    defined with a `<tr>` element (short for **Table Row**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of a row, we define one or more columns, and here we have a choice:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a `<th>` tag, which stands for `<th>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use a `<td>` tag, which stands for `<td>` (or, if you don’t want a
    header row at all, you can just start with `<td>` right away).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we use `<th>` or `<td>`, we generically call either one a *cell*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `<th>` element defines a column, and since this is the header row, the
    values inside the `<th>` elements are the header text for each column. In this
    case, we’re only going to have a single row after the header row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, `<tr>` creates a row, and then for each column, we have a `<td>` element.
    Remember that this HTML is being built inside of a template literal string in
    JS code, so we can use those expressions I mentioned earlier. For each cell, a
    property in the `inRequest` object is used – `body`. This will hold the information
    sent to the server from the form, so we can then grab each piece of data using
    properties named after the form fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we just have to close the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is shown in *Figure 3**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: The registration acknowledgment screen, using an HTML table](img/B18315_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The registration acknowledgment screen, using an HTML table'
  prefs: []
  type: TYPE_NORMAL
- en: A warning about table usage
  prefs: []
  type: TYPE_NORMAL
- en: Tables are often used in HTML, and they are sometimes even abused because tables
    can be used to lay out your pages if you want. The content inside a `<td>` element
    can be anything, even more HTML, so it’s possible to build tables nested inside
    `<td>` elements with all sorts of complex HTML and use the table structure to
    define the structure of the page. However, this practice is frowned upon for several
    reasons, including performance, the complexity of the markup, and a more philosophical
    “it’s just not what tables are meant for” arguments. There are preferable ways
    to do layout in CSS, some of which wind up looking an awful lot like tables anyway
    but with more flexibility. I only mention this so that you’re aware – tables shouldn’t
    be thought of as being used for layout, even though they can be (and for many
    years before CSS evolved into what it is today, it was extremely common to do
    so).
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have the context to understand the CSS classes applied to `tr`, `th`,
    and `td` that you saw earlier when the response to the `/register` route was generated
    – these elements are the `<tr>`, `<td>`, and `<th>` tags that the styles apply
    to! Simply put, they put a background color on the `<th>` elements in the header
    row so that they stand out from the data, and then a border is put around each
    `<tr>` and `<td>` element, really just for aesthetic reasons so that the data
    doesn’t all run together.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To wrap things up properly, we need to close the body and the HTML document
    that our response constructs, as well as close the `inResponse.send()` call and
    the `app.post()` function call. That’s done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With that done, the only thing left to do is to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting the server means telling the object that Express gave back to us to
    start listening for requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The aptly named `listen()` method of the `app` object is what allows us to do
    that. We pass to it what port to listen to and, optionally, a function to execute
    when it starts up. Since there are no arguments we need to pass to it, an empty
    set of parentheses is all we need (because it’s still a function we’re defining,
    after all), and then we again use arrow notation for the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the server (`npm run dev`) and play with it a bit to see it
    in action, including the start up text being displayed, as you can see in *Figure
    3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The output of console.log()](img/B18315_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The output of console.log()'
  prefs: []
  type: TYPE_NORMAL
- en: Deprecation warnings
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the warning you can see in the preceding screenshot can be ignored.
    It’s a deprecation warning, which means that there is some change in process in
    a package that the server code depends on. The authors of that package alert us
    to the fact that, eventually, we’ll need to change our code in some way; otherwise,
    it will break (the change, in this case, is that the call to `express.urlencoded()`
    earlier will eventually require an object to be passed with an extended attribute
    – you can add `{extended:false}` as an argument to that call to get rid of the
    message now if you’d like, but it isn’t yet necessary, which is the point of a
    deprecation warning).
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of that start up text, inside of the function passed to `app.listen()`
    is a call to the `log()` method of an object named `console`. It’s easy enough
    to surmise that `console` is an object representing the command-line output, frequently
    called the *console*. And it’s easy to guess that `log()` is the method that allows
    us to write text to that console. But all that opens up a whole new world of knowledge
    that we’ll explore a little bit later in the *Loving your new best friend –* *DevTools*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that wasn’t so bad, was it? Writing servers is easy! However, so far,
    you’ve only written one *type* of server. Let’s now talk about another way we
    could write this server and registration page that is a little more modern.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a different approach – single-page apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you click the button on our registration page, the form is sent to the
    server, which then produces a new HTML document. This document is sent back to
    the browser, which replaces the entire registration page with the results page.
    This is what is often referred to – at least by (relative!) old-timers like me
    – as the “classic” model of the web. In short, for every user action, the server
    is contacted, generating a new page to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: That’s an inefficient model, frankly. Imagine thousands of users all doing the
    same thing – the server must handle all those requests, and quickly, because users
    hate to wait! But even if it’s almost instantaneous, think about it from the user’s
    perspective – the screen is constantly being redrawn. It just doesn’t *look* great,
    or at least it doesn’t look like an app they run on their operating system. Imagine
    if your web browser had to completely redraw itself every time you, say, click
    a menu item on the toolbar. However, that doesn’t happen; the menu simply appears.
    So, why can’t a website work the same?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it can! An approach referred to as *SPAs* does it. **SPA** stands for
    **Single Page App**, and what it means is that the HTML document you initially
    load is never thrown away and replaced with another. Instead, what happens is
    that when a request goes to the server, the server responds with just data, not
    a full HTML document. We then use JS to take that data and do something with it.
    It might be as simple as showing it on the page, which we can do through DOM functions.
    Alternatively, maybe we use it to do some calculations and display the result
    of those on the screen, or maybe we use it to modify the page somehow. In all
    cases, the main point is that the single HTML document that was loaded at the
    start is still there.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound a bit confusing right now, but I think once you see what we’re
    going to do to our little registration page, it’ll make a lot of sense. However,
    before we touch the code at all, I want to solve one minor problem and make life
    a little easier for us developers!
  prefs: []
  type: TYPE_NORMAL
- en: Improving developer productivity through automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may not have noticed this, but if you were to make a change to the `index.js`
    file, such as changing the HTML it returns when the form is submitted, you would
    find that the change doesn’t take effect immediately. You have to stop and restart
    the server for the changes to “kick in,” so to speak. That’s quite inconvenient
    if you ask me! If you were making a lot of changes, that would get annoying fast.
    Fortunately, there’s an easy solution – **nodemon**!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, since `nodemon`’s an NPM package, we need to add it to our project.
    To do so, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, you saw how Express was added with the `–save` option, which added
    it to the dependencies element in `package.json`. The `–save-dev` option is similar
    but a little different. You see, there is also a `devDependencies` element that
    may be present in `package.json`. This works the same as the `dependencies` element,
    with one key difference – these are dependencies that we need during development
    but which our code itself does not depend on; `nodemon` is one such dependency.
    So, after executing that command, you’ll find a `devDependencies` element has
    been added, and `nodemon` has been added as a dependency in it (note this time
    that I did not specify an explicit version number, so NPM will install the latest
    version of `nodemon` – since our code doesn’t depend on it, this is safe and most
    likely desired, since having the latest version gives us any new features it may
    offer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what `nodemon` does is watch (or *monitors*, hence the name `nodemon`)
    our files for changes and, when they are detected, restart our application for
    us. However, to make that happen, we have to start the server using `nodemon`.
    The way we do this is to modify the `dev` script we added to `package.json` earlier.
    Now, it should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `npx` command is an alternate version of `npm` that basically says, “*Run
    a program that is supplied by a dependency in our project.*” In this case, that
    of course means `nodemon`. But note how you would still, as a developer, execute
    the same `npm run dev` command to start the server. That command is what will
    start `nodemon`, using `npx` as per the script. And, by default, `nodemon` will
    simply monitor all the `.js` files in the project directory, and since we just
    have one, that’s all we need (you can configure `nodemon` to only monitor specific
    files, subdirectories, or many other options, but the defaults work just fine
    for us here).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new kind of client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, what we’re going to do is modify our registration page to work as an SPA.
    Rather than listing out all the code, I’m just going to show the changes required,
    just to save a few trees! If I don’t mention a specific change, then you can assume
    the code is the same as the original version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is a simple one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `action` and `method` attributes have been removed and an `id` attribute
    added. Removing `action` and `method` is a change I didn’t technically need to
    make, but it makes obvious the fact that the form won’t be submitted like before.
    Instead, the information from the form will be sent to the server in an entirely
    different way, which we’ll get to shortly. Adding the `id` attribute though is
    necessary, as you’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other change is to the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `type` attribute’s value is just `button` instead of `submit`. That’s
    because the `submit` type creates a special button that knows to submit the form
    to the server when clicked. But since we don’t want that to happen now, it’s changed
    to a plain button, which has no intrinsic action when clicked. To give it an action,
    we need to attach an event handler to it. The `onClick` handler is what executes
    when the user clicks the button of course, and in that case, we need it to execute
    some JS, the `registerNow()` function specifically, which we’ll look at very soon.
  prefs: []
  type: TYPE_NORMAL
- en: But first, there is a new bit of markup that needs to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding the response page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember, the whole point of what we’re trying to accomplish here is to submit
    the form data to the server, get some data back, and display it on the screen,
    *without* overwriting what’s there already. So, we’re going to need a place to
    show that data, and that’s what we’ll discover next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code should look rather familiar to you – it’s almost exactly identical
    to the markup that the server generates in the original version. The key differences
    are first that everything is wrapped up in a `<div>` now, the one with the `theResults`
    ID. In addition, an inline style is used here. The `display` property in CSS tells
    the browser whether the content inside this element should be visible or not.
    Setting it to `none`, as is done here, means that this entire `<div>` will not
    be seen, at least not at first. And, indeed, if you run this code now, you’ll
    find that it looks exactly like the original version, but none of the content
    inside `<div>` is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the content in the row where the data is displayed is different. No
    longer do we have expressions like in the original version because, remember,
    this isn’t a template literal string like it is there; this is just plain old
    HTML. Instead, each of the `<td>` elements is now given an `id`, which will allow
    us to reference them in code later. And I prefixed the `id` values with `results_`
    so they can be differentiated from the fields in the form at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: And, speaking of the code, that’s exactly where we’re headed next!
  prefs: []
  type: TYPE_NORMAL
- en: Executing the new JS code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coming back to that `registerNow()` function I mentioned earlier, you’ll find
    that it is contained within a `<script>` block that comes right before the closing
    `</html>` tag. That’s something you haven’t seen before – you’ve only ever seen
    a `<script>` tag inside `<head>` before now.
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess, you can put `<script>` tags anywhere because, remember, they
    aren’t content that is shown to the user, so they have no impact on your markup
    no matter where you put them. I put a `<script>` tag at the end for just one reason
    – so that I could discuss the markup changes first and not have to pull a “we’ll
    come back to this later” with the JS code, which is what I would have had to do
    if it was in `<head>`!
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, we’re ready to look at it, and I’m going to break it up into pieces
    to make it easier to digest, starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You’ve seen a function defined before, but that `async` thing is new. Normally,
    when a function executes, it completes from start to finish in one go. However,
    there are some cases where we might need to do something in a function that can
    take a while. A good example – the one in play here – is calling the server. We
    need a way to, in effect, make our function “pause” until the server responds,
    which it normally would not do. The `async` keyword tells JS that we’re doing
    something like that here. On its own, it’s only part of the equation, and you’ll
    see the other part soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let’s return to the function’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `getElementById()` method of the `document` object, which is an object the
    browser always provides to us, allows us to get a reference to a DOM node based
    on its ID. In this case, the form has an `id` of `theForm`, so the `theForm` variable
    now references the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, we can pull out the data from the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Every entry field in the form is an element in an object named `elements`, which
    is a property of the form object referenced by the `theForm` variable. So, we
    can access each of them using bracket notation, as you can any property of an
    object.
  prefs: []
  type: TYPE_NORMAL
- en: What we’re doing here is building an object with keys for each of the form fields.
    We define an object with an opening and closing brace and then list the properties
    we want in it, in a key-value pair form. Then, just to prove that worked, the
    object is displayed in the console using `console.log()`, as you saw on the server
    side. However, here, you see another capability of that method – the ability to
    pass multiple arguments. Each argument will be displayed separated by some space.
    And if we pass an object as an argument, as is the case for the second argument
    here, `console.log()` will display the contents of that object for us. Immensely
    helpful, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to talk more about `console` and the wider world it hints at near
    the end of this chapter, so just keep it in the back of your mind for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that object, we can then call on the server using JS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is where the second part of the `async` puzzle comes into play – the `await`
    keyword. This tells JS that whatever function or code follows may take some time
    to execute, and we *do not* want the rest of the function to execute until it
    does, as it normally would. We want to *await* the outcome of that call, in other
    words.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, what we’re awaiting is the result of a call to the `fetch()` function.
    This is a function the browser provides that allows us to make an HTTP request
    to a remote system – in this case, our server. The `fetch()` function can take
    in a lot of information to do its job, but in its simplest form, it requires two
    arguments – the URL to send the request to (`/register` in this case, just like
    the original version of this page) and an object with several properties that
    provides the data needed to make the call. Here, we first specify the HTTP `method`
    to use as `POST` again, as with the original form. Then, we need to provide some
    `headers`. Recall from earlier that headers are metadata that can be sent on a
    request to tell the server something about that request. In this case, we’re telling
    it that we’re sending something called JSON. The `Content-Type` header is the
    key in a key-value pair that allows us to express that, and the value is `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see strings like this frequently in headers, and when you do, this is
    something called a MIME type, where `application/json` value specifically is a
    common one these days, where `userInfo` object before, that was JSON! The server
    needs to know that the client is sending JSON, so this header and that specific
    MIME type do that.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we of course have to include the `userInfo` object, and this becomes
    the `body` of the request. However, when you make an HTTP request, the body is
    always a string. At this point though, we only have `userInfo` as a JS object,
    not a string. Fortunately, the JS engine provides an object called `JSON`, which
    gives us access to several useful methods, `stringify()` being one of them. You
    simply pass this function to a JS object, and it will return a string version
    of it, which we can then make the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the response comes back, it will be put into the `response` variable.
    However, it will be a string at this point, and we want a JS object so that we
    can get the values from it. To do that, we can call the `json()` method of the
    `response` object. This is another asynchronous call though, so we have to use
    `await` again, after which we can display the resultant object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, now that we have an object with the data returned by the server, the
    last step is to show it on the screen (well, the last step after displaying it
    in the console, which is something you can do in a browser, just like in the server-side
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, the five data values are inserted into the page. Again, the `document.getElementById()`
    function is used, referencing the IDs assigned to the `<td>` elements from earlier.
    That gives us a DOM node object back, and many DOM node objects have an `innerHTML`
    property. This allows us to insert content between two tags – in this case, between
    the `<td>` and `</td>` tags corresponding to a given `id` value. The text to insert
    is simply the value of the various properties of the `results` object that `response.json()`
    gave to us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s great that all the data is inserted at this point, but it’s still
    not visible. To make it visible, we have to change the display CSS property of
    the `<div>` tag that contains the table. DOM nodes almost always have a `style`
    property, which allows us to alter any CSS properties on that node that we want
    to, so we can set the `display` property to an empty string. This may seem weird,
    but by default, the `display` property has no value, which tells the browser that
    it *should* be displayed, so that’s what we do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you can now see the data that the server sent back, as shown in
    *Figure 3**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The result of calling the server](img/B18315_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The result of calling the server'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reworked the client-side code for this new SPA approach, let’s
    look at what changes are required on the server side to ensure that the client
    and the server can talk to each other properly in the new way.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new kind of server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, great, we’ve modified our frontend code to prepare for this great new
    SPA version; now, we need to make some changes on the server. Once again, I’ll
    just show the changes; however, in this case, I’d definitely suggest looking at
    the complete code from GitHub because the one thing you’ll find is that it’s shorter.
    And that makes sense if you think about it – the styles and HTML that the server
    returns in the original version are now effectively part of the `index.html` source.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we must tell Express that it needs to be able to work with JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `express.json()` method returns a function – a bit of Express middleware
    again – that knows how to work with JSON. Cool, that was easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change comes in the handler function for a POST to the `/``register`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Like I said, it’s shorter! The only real purpose of the server in this app is
    to echo back to the client the information received. Normally, you’d probably
    validate this data somehow, store it in a database, and so on. But remember, I’m
    just trying to demonstrate a client-server interaction here, which is the whole
    point of the chapter, so none of that needs to come into play.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will display the data that was received via the call to `console.log()`
    first, just so we have it ready if we need to debug. After that, an object is
    created, referenced by the `responseObj` variable, just like you saw earlier on
    the client side. This object is then passed to `inResponse.send()`, which results
    in a call to `JSON.stringify()`, as you saw earlier, being made automatically
    for us, since Express is aware that we want JSON – in the form of a string – returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through this whole flow from client to server, detailing the steps
    involved:'
  prefs: []
  type: TYPE_NORMAL
- en: The JS in `index.html` sent an object in the form of a JSON string to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express took that string and turned it into a JS object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our server-side code then used the properties of that JS object to construct
    another object, with the data that was sent copied into it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That object was then returned to the JS running in the browser as a string of
    JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in the browser converted the string back into an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then used the data from that object to populate the hidden table cells on
    the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then showed the table by updating the style of the `<div>` containing `<table>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critically, note that the original registration form is still there, untouched
    by the response from the server. That, in a nutshell, is the entire point of this
    new SPA version of this small and simple app. If you imagine this on a much larger
    and grander scale, such as Google’s Gmail or Microsoft’s Office Online, then hopefully
    you can quickly start to see the benefits. There’s more code involved of course,
    but you get better performance (usually), less server load (usually), and less
    network traffic (usually) with this SPA approach rather than the “classic” web
    approach, and that’s why the former is actually the more common approach to web
    development today overall. There definitely is still a place for the classic web
    approach, but that place is shrinking as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen these two approaches – the “classic” web model and the
    SPA model – let’s discuss the topic I hinted at when I mentioned the `console.log()`
    function – developer DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Loving your new best friend – DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While `console.log()` is available in Node code on the server side, it’s an
    exceedingly small part of a much larger palette of tools that are available on
    the client side in the browser. To begin exploring that palette, go to a random
    website of your choosing, maybe www.microsoft.com or some other well-known site,
    and press *F12* once the page loads. You should find a new area in your browser
    opens up that looks something like *Figure 3**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Browser DevTools in “action”](img/B18315_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Browser DevTools in “action”'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the browser DevTools, and they are available in some form in all
    modern web browsers. Here, you can dig into the guts of the site you’re viewing.
    As you can see, there are many different tabs, each containing a wealth of data:'
  prefs: []
  type: TYPE_NORMAL
- en: The `console.log()` statements. You can also see JS errors here, as well as
    network requests. In fact, now would be a good time to open DevTools while viewing
    our little user registration app and see what is output to the `console.log()`
    messages there, although remember that you’ll only see those for the code running
    in the browser, not those in the server-side code running in Node (those are output
    to the console).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other tab that you’ll probably use most often is the **Network** tab. Here,
    you can also see network requests, but you’ll see a lot more of them than in the
    **Console** tab and a lot more details about them. In fact, assuming you’re looking
    at that tab now on some site, go ahead and click on a request and examine some
    of the details. You can see things such as the headers sent on the request and
    the body content, if there are any.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Elements** tab is another area of immense importance because it’s here
    that you can examine the DOM, examine individual nodes, and even alter their styles
    directly. Yes, you can actually change things about someone else’s web page! Not
    permanently of course, only in your own browser. But it’s a fantastic way to see
    how other developers have done things and how you can modify their work in numerous
    ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Sources** tab is where you can see all the various JS files, CSS files,
    and other resources that make up the website. And again, here you can actually
    edit that code, temporarily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other tab I’d say is most important is the **Application** tab. Here is
    where you can find things such as cookies (small bits of information stored on
    your computer by websites) and other data that some sites store on your machine
    to do their work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other tabs, some of which are hidden by default unless and until
    you decide you need them, but I’d say those four are probably the ones you’ll
    find yourself using most commonly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s go back to that console object for a moment because `log()` isn’t
    the only method it offers. While not an exhaustive list, here are a few I think
    you’ll find most interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: Well, it’s no surprise but this clears the console! This comes in
    handy in sections of your code where you want to focus on some messages and get
    rid of older ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug()`/`error(`)/`info()`/`warn()`: These are similar to `log()` except
    that they output messages that are usually colored or highlighted in some way,
    depending on the severity of the message. For example, you can call `console.error()`
    to display a message in bold red text so that an error stands out against messages
    that are just information that you might output with `console.info()` or `console.log()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time()`/`timeEnd(`)/`timeLog()`: Calling `console.time()` acts like you pressing
    the start button on a stopwatch, and then `console.timeEnd()` acts like you clicking
    it again, at which point you can call `console.timeLog()` to display the elapsed
    time between the (virtual) clicks. This is handy when you want to figure out how
    long some code takes to execute, usually to aid in performance tuning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir()`: This may not have the best name, but it’s very handy. It displays
    an interactive listing of the properties of a specified JS object. You can expand
    and collapse sections of it, making it much easier to navigate larger objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the tabs in DevTools, there are several more methods, but these are
    probably the most common. Note that the `console` object available in your Node
    code has most of these same methods, although the logging functions may not output
    messages with the same styling as in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: As a web developer, you’ll find yourself using browser DevTools *a lot*, so
    I would very much encourage you to explore some random sites with them and see
    what you can do with them. There is an awful lot of power there – you could write
    a whole book on browser DevTools alone if you wanted to – and the best way to
    learn what they’re capable of is to simply jump in and experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you along though – and assuming you’re using a Chromium-based browser
    such as Chrome, Edge Opera, Vivaldi, or Brave – going right to the source is probably
    best, and that means the Google DevTools team’s website: [https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools).
    Note that non-Chromium browsers such as Firefox and Safari also have DevTools,
    and they’ll be substantially the same, although certainly with differences and
    perhaps their own capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can’t do any harm playing around with DevTools because you’re
    not modifying the code of a website for anyone but yourself on your own machine,
    so there’s no reason not to mess around! If you get yourself into a pickle, you
    have only to reload the page, and everything will return to normal.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter concluded, we can now fill in a few more boxes in our web
    developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: The roadmap, with a few more boxes filled in](img/B18315_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The roadmap, with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, you opened up the **Networking** and **Developer Tooling**
    boxes on the roadmap. Of course, you also built up some knowledge about the boxes
    that were opened in the previous chapter too. Hopefully, the big picture is starting
    to form in your mind now, at least a little bit. The upcoming chapters will expand
    that picture of course – some a little, some a lot, but always expanding!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a simple user registration page and a server to work
    with it, using the “classic web” approach. You first built the frontend using
    some new concepts, including basic HTML forms to demonstrate submitting data to
    the server that way, and some new CSS properties, including shorthand properties.
    Then, you saw how to build a server that accepts that data and generates a response
    for the client that is then displayed in the browser using another new concept,
    HTML tables, to display tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you saw an entirely different approach to transmitting data to a server
    and receiving a response, an approach that leads to the more modern SPA paradigm.
    This included building the frontend code that introduced some new JS concepts,
    including `async`/`await`, and `fetch()`. You saw how the server can handle a
    new kind of request from a client and generate a new kind of response using JSON,
    allowing the browser to display the results without overwriting the entire page.
    Finally, you saw how your web browser provides tools specifically for developers
    to examine pages, explore JS and CSS, and work with any website out there at the
    level of the code behind it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll step back from code a little bit (not completely
    though!) and look at some other topics that a web developer should be familiar
    with, including source control, Linux, security, integrated development environments,
    and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Expanding Your Knowledge Base'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you’ll continue to gain technical knowledge about web development,
    including things such as developer tooling, security concerns, cloud infrastructure,
    virtual machines and containers, and DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also talk about modern frontend frameworks such as React, Angular, and
    Vue, and see how they can be used to accelerate development, as well as talk about
    responsive design on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then flip over to look at some backend concerns and technologies, including
    how to build servers with Node.js and Express, Java and Spring Boot, and PHP and
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll begin to talk about some technologies that have the goal of allowing
    you to be a web developer while doing less coding. These include things such as
    content management systems (like WordPress and Drupal) and so-called “no-code”
    solutions such as GoDaddy’s Website Builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18315_04.xhtml#_idTextAnchor105), *Managing, Securing, and Working
    with Code*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18315_05.xhtml#_idTextAnchor129), *Understanding the User Experience,
    Deployment Options, and DevOps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18315_06.xhtml#_idTextAnchor159), *Exploring Modern Frontend
    Development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18315_07.xhtml#_idTextAnchor176), *From Front to Back – More
    on Backend Tools and Technologies*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18315_08.xhtml#_idTextAnchor203), *Writing Less Code – CMSs,
    No-Code Solutions, and Generative AI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
