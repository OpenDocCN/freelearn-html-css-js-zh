- en: Chapter 6. Dashboard with WijmoGrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing rich client applications with jQuery UI results in a large number
    of CSS query selectors and event handlers. In this chapter, you will learn about
    another way of developing interactive user interfaces. Wijmo facilitates the shift
    to this programming paradigm, supporting it with a plugin. This chapter will get
    you started with the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications are often built with the MVC pattern, for the backend.
    What about the frontend? Frameworks such as `Backbone.js` leave a lot of boilerplate
    code to be written. This becomes apparent for large projects. The library is lightweight,
    but lacks strong abstractions. It leaves the task of loading data from the server
    and DOM manipulation to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **ModelViewViewModel** (**MVVM**) pattern, the application logic is
    encapsulated in a set of ViewModel classes that expose an object model that is
    View-friendly. Views rely on bindings to observables to be notified of changes
    in the ViewModel. As a result, the UI refreshes automatically with the data when
    using the MVVM pattern. The flow of data in the MVVM pattern is illustrated in
    this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to MVVM](img/6067OT_6_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From a software design point of view, the MVVM pattern has the benefit of testability,
    separation of concerns, and reusability. The ViewModel doesn't contain any user
    interface elements, making it easy to test. The presentation is kept in the **View**
    with HTML and CSS, which requires different skills than those for working with
    the business logic in the **ViewModel** . The ViewModel can be reused in other
    views, such as a mobile one or in a similar application with a different look.
    In my own experience, I have used subclasses of a common ViewModel to build two
    applications. Both of the applications use the same backend **Model**.
  prefs: []
  type: TYPE_NORMAL
- en: When the MVVM pattern is used in the browser, the Model represents the backend.
    It is an abstraction of the normalized data store for objects and the operations
    (create, read, update, delete) on it. The View is the user interface that displays
    information to the user and fires events to the ViewModel. The ViewModel retrieves
    data from the Model and notifies the View of changes. Also, it receives UI events
    from the View and updates the data in the Model in response.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Knockout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Knockout** is a JavaScript library that implements the MVVM pattern. By using
    Knockout, you can avoid event handling and DOM manipulation with jQuery and work
    with declarative bindings instead. Knockout comes with a rich set of bindings
    for controlling the text, appearance, and flow. These include `foreach`, `if`,
    `visiblility`, and `style` bindings. In addition, there are specific bindings
    for working with form fields. They can be used to handle click events and to enable
    or disable UI elements. These bindings are bound to an observable or an `observableArray`
    object in the ViewModel. An observable issues notifications when their value changes.
    Knockout provides a simple syntax for reading and writing from an observable,
    as we will see. Equally important, Knockout keeps track of the right parts of
    your UI to update when the ViewModel changes. That means if you update an item
    of an `observableArray` object that is rendered with a `foreach` loop, the HTML
    element that corresponds to the item changes with it. If an observable is computed
    from another observable, then the dependency is tracked for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at instantiating and using an observable. To create an observable,
    we assign it to a property of a ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To read from the observable, just call the observable with no parameters. If
    we call `viewModel.name()`, "Bob" is returned. To write to the observable, pass
    the new value as the parameter to the observable. Calling `viewModel.name('Jeff')`
    writes the value `Jeff` to the value `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write the View with a templating language using the `data-bind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The View has the same effect as the following when initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to activate Knockout, we bind the ViewModel layer to the View layer
    with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can place this either at the bottom of the page or a DOM-ready function.
  prefs: []
  type: TYPE_NORMAL
- en: Building a rating system with Knockout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section we build a rating system using Wijmo''s rating widget. The
    rating system lets the user vote for the factors that affect their technology
    choices. They have a total of 10 points to use. The **Finish** button is only
    enabled if the number of points left for use is valid as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a rating system with Knockout](img/6067OT_6_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To build this rating system, we make use of Wijmo''s Knockout binding for its
    rating widgets. The survey is composed of a set of options where the user rates
    the option. For each of the options, we create an answer object with the values
    for the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `answerText` are displayed under the **Option** heading. The
    points are the number of stars under the **Importance** heading. The rating widget
    has many other options, but we only introduce the ones necessary for our use.
    These options are bound to the widget with the `data-bind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our ViewModel, we have an array of options called `answers` and a total
    number of points allowed, the `pointsBudget`. The `pointsUsed` is a dependent
    observable and is calculated by adding up the points in all the answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the jQuery `$.map` function, we can pass an array of option texts to
    the `SurveyViewModel`class. The first argument sets the total number of points
    allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Knockout is an MVVM framework, we need to write the View using a templating
    language. To display the options and the rating widget, we loop through each answer
    in the ViewModel and display the `answerText` string and the points for each answer,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `text` binding applied to `answerText` displays its text value, while the
    `value` binding for `wijrating` shows up as stars. Next, we want to show the number
    of points the user is left with. This is also done with the help of `text` binding,
    which converts a numeric value to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We enable the **Submit** button only when the value of `pointsUsed` doesn''t
    exceed the value we set in the SurveyViewModel. In this case, it''s `10`. The
    `click` binding assigns the `save` action in the SurveyViewModel to the `click`
    event on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To initialize the UI, we bind the ViewModel to the HTML by calling `ko.applyBindings`
    and passing a SurveyViewModel object. Putting it all together, the rating system
    is only a few lines of JavaScript and has no DOM manipulation. For the complete
    source code for this example, refer to the code bundle available for download
    online on the Packt website. Note that in addition to the usual Wijmo imports,
    we add the Knockout library and the Wijmo bindings, which includes `wijrating`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to build a user interface with the MVVM design pattern,
    we go on to building a more complete application with forms and grids.
  prefs: []
  type: TYPE_NORMAL
- en: Building the dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project for the rest of the chapter is based on a mobile-paging application.
    The application allows messages to be sent to pagers with a dashboard showing
    all of the messages. The messages in the dashboard are updated in real time and
    are sortable by column headings. In a real-world application, the messages shown
    in the dashboard would be paginated and sorting each column would send an AJAX
    request to the server. Wijmo already has an example of how to do this with the
    Grid widget, which we will also use in our project. Our project introduces the
    basics of setting up a real-time messaging platform with the MVVM pattern. The
    data is not persisted to a database. However, form submissions are sent to the
    dashboard in real time with WebSockets. After you finish this chapter, I would
    encourage you to take a look at [http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/](http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/).
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message with Knockout and Socket.IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Send Message** page is a form that lets the user submit a message with
    a subject, body, phone number, and message type. We build this form using a combination
    of the bindings that come with Knockout and those provided by Wijmo. First, let''s
    start with a subject and a body. Since the Wijmo''s textbox widget doesn''t have
    a binding for the input value, we use Knockout''s `value` binding. This binding
    can be used on the `<input>`, `<select>`, and `<textarea>` elements and links
    the element''s value with a property in the ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To make these elements use the same styles as the rest of the form, we decorate
    them with the textbox widget. This is done for styling the elements, as the View
    in HTML contains the bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our ViewModel, we initialize the `subject` and `body` fields as observables
    with empty strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After seeing how the `subject` and `body` fields are implemented, you may want
    to use the `wijtextbox` binding directly, as shown in the following demonstration
    that does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Although Knockout has a `value` binding, the `wijtextbox` binding is purely
    for presentation. For a list of supported options for each binding, see [http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout](http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout).
    Only the options listed on the page support two-way bindings while other widget
    options are just used for initialization. In the next step, Wijmo bindings are
    used for the phone number and message type form components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `wijinputmask` binding initializes a `WijmoInputMask` widget with the pattern
    `(___) ___-____`. The `text` option binds it to the observable `phoneNumber` in
    the ViewModel. The `wijcombobox` widget acts as a dropdown for the message type.
    The `data` option sets the `messageTypes` as available. Since the message types
    are only read and not written, we scope it outside of the ViewModel. Changes to
    objects outside of the ViewModel layer do not affect the UI. Later on, we submit
    the ViewModel object to the server and having extraneous data such as message
    types outside of the ViewModel layer simplifies the code. Wijmo's ComboBox takes
    an array of objects with the label and value for the data option. The `label`
    property is the text displayed, while `value` would be stored in the `messageType`
    observable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the message type to `Gamma`, we set it in the observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last item we have left on the form is a submit button which sends
    the data to the server using a WebSocket object. For this part, we will use Socket.IO.
    To set up `So` `cket.IO`, download and install `Node.JS` from [http://nodejs.org/download/](http://nodejs.org/download/),
    then run `npm install socket.io` on the command line. This will make the path
    `/socket.io/socket.io.js` available in the browser when the `Node.JS` server is
    running. On the server, `Socket.IO` listens for message events and broadcasts
    it as news. The `emit` function broadcasts to all clients except the one who sent
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, a WebSocket connection is created to `localhost` by calling
    `io.connect(''http://localhost'')`. The `submit` function sends a message event
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`ko.toJSON` converts the ViewModel data to JSON. JSON includes all of the observables.
    The submit button is bound to the method through the click binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For decorating the button, call `$(''button'').button()`. The jQuery UI button
    method styles the submit button in the same way as other widgets. You may ask,
    why not just write the View so that the jQuery UI button is applied in the binding?
    The following code would work in a perfect world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Yet, Wijmo does not support binding to the `click` event on button widgets.
    So we use Knockout's native `click` binding and jQuery UI's `button` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the View and the ViewModel layers work together, we apply the bindings
    to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Rocket theme, the **Send Message** page looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending a message with Knockout and Socket.IO](img/6067OT_6_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying messages on the Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our ViewModel class for the Dashboard page is simple. It is composed of an
    `observableArray` of message objects. An `observableArray` is useful when you
    want to detect and respond to changes in a collection of JavaScript objects. Since
    the messages on the Dashboard are not editable, the properties of each message
    object do not need to be an observable. Each message has `subject`, `body`, `messageType`,
    and, `phoneNumber` strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'On receiving an update from the server, the message is added to the ViewModel.
    The data is received as text, as in AJAX responses. So the `JSON.parse` method
    turns it into a `message` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a WebSocket connection is made to the server, allowing
    bi-directional communication. However, we only listen for events from the server
    for the Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our View layer is just a table. Wijmo makes displaying tabular data so easy
    that all we need to make it dynamic is just the `wijgrid` binding, along with
    one essential option, `data`. The `data` option takes as its parameter a `wijdatasource`
    widget, an array, or a DOM table. A `wijdatasource` can be used to load data dynamically
    from a remote source with filtering and sorting. Because our application doesn''t
    have a database in the Model, we pass an `observableArray`to the `data` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To enhance the functionality, `allowSorting` is set so that clicking on a column
    heading sorts the table by that column. The `wijgrid` binding takes care of updating
    the table when the ViewModel data changes. As you are now familiar, we are missing
    an essential piece that links the View and the ViewModels: `ko.applyBindings(viewModel)`.
    That finishes the dashboard with the result as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying messages on the Dashboard](img/6067OT_6_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dashboard initially loads with just the first message. When the **Send Message**
    page is submitted, another message is inserted below it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wijmo, combined with Knockout, makes programming interactive applications easy.
    In the rating system example, we have seen how observables that are computed from
    other observables work. We've used a dependent observable to calculate the total
    number of points used as each rating changes. In the Dashboard example, we built
    a dynamic table that is updated by the server with the Wijmo grid widget. Also,
    we coded the Send Message page to use the Wijmo widgets in combination with Knockout
    bindings. The next chapter introduces mobile web development with Wijmo Mobile.
  prefs: []
  type: TYPE_NORMAL
