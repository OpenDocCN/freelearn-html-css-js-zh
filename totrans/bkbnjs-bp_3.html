<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a Live Data Dashboard</h1></div></div></div><p>This is going to be a fun chapter. So far, we've created two relatively simple applications. In both cases, we <a id="id186" class="indexterm"/>mainly created and read data from the browser. While it's all browser-side stuff, it's pretty static. This time, we're going to do something a lot more interesting; we're going to build a table that keeps a track of events. In an interesting twist, though, we'll build a table that will automatically update based on changes made in other browsers that have our app open.</p><p>The following are a couple of chapter spoilers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We'll look at better code organization through multiple files</li><li class="listitem" style="list-style-type: disc">We'll write code to update and delete model instances</li><li class="listitem" style="list-style-type: disc">We'll build an app that polls the server to keep its collection up to date</li></ul></div><p>Once again, we'll start with the project template; however, there are a few modifications we need to make in our last two projects. You may have noticed that our <code class="literal">app.js</code> file was getting a bit lengthy; this makes it tough to navigate between our components and to keep our code clean and manageable in general. So in this project, we're going to split our Backbone code into multiple files. We're going to keep our models and collections in <code class="literal">models.js</code>, our views in <code class="literal">views.js</code> and our router in <code class="literal">router.js</code>. You can go ahead and create these files (they'll be empty for now) in the <code class="literal">public</code> folder; also, remove <code class="literal">app.js</code>. Then, in the <code class="literal">index.ejs</code> file, we'll need to replace the script tag for<code class="literal"> app.js</code> with script tags for those new files, as follows:</p><div><pre class="programlisting">&lt;script src="img/models.js"&gt;&lt;/script&gt;
&lt;script src="img/views.js"&gt;&lt;/script&gt;
&lt;script src="img/router.js"&gt;&lt;/script&gt;</pre></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Planning our application</h1></div></div></div><p>In the<a id="id187" class="indexterm"/> previous chapters, we started writing code immediately. However, in the real world, you're not going to have me to tell you what to write from the beginning. You're going to have to plan your own application. So let's take a moment and do that now.</p><p>We want to <a id="id188" class="indexterm"/>build an application that will show us a list of past and upcoming events. An event will have a title, a description, and a date on which it occurs. This type of data can be nicely displayed in a table. We'll need to be able to create new events, but we also want to be able to edit and delete the existing events. We also want to periodically poll the server for changes to the set of events so that all the connected clients are up to date.</p><p>As this is a pretty basic application, that will be all. Now that we've clarified what it needs to do, we can start thinking in terms of Backbone components. Obviously, we'll need an <code class="literal">Event</code> model and an <code class="literal">Events</code> collection. The table will be an <code class="literal">EventsView </code>instance, and each row will be an <code class="literal">EventView</code> instance. We'll need a form that is used for creating new events, say the <code class="literal">CreateEventView</code> class,  and another form that is used for editing the existing events, say the <code class="literal">EditEventView</code> class. We don't need a whole view used for removing events; we just need a button, probably in the <a id="id189" class="indexterm"/>
<code class="literal">EventView</code> class.</p><p>What about routes?  The whole table can be displayed at the home route, which is <code class="literal">/</code>. The creation form can be at <code class="literal">/create</code>, and the edit form can be at <code class="literal">/edit/&lt;id&gt;</code>.</p><p>And that's about it! This doesn't really represent the planning process of a real application, but it should make you realize that building applications is about much more than just writing code. There are smart processes you can follow to facilitate the process. If you're relatively new to programming, you should look into topics such as agile development or test-driven development. When you're starting out, these ideas may seem to make your projects take longer than necessary, but believe me, they will make building and maintaining big projects much simpler.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Setting up precompiled templates</h1></div></div></div><p>Let's start by <a id="id190" class="indexterm"/>talking about the templates we use for our view classes. In the previous chapter, we've put our template source text right in the <code class="literal">index.ejs</code> file, inside script tags. This time we're going to do something different. We're going to precompile our templates. Think about the timeline of a template; it starts as text in a script tag. We've been getting that text and passing it to the <code class="literal">_.template</code> function that compiles the text into a <code class="literal">template</code> function, which it returns to us. Then, we pass our data to that function and get the HTML with our data interpolated back. All this must be done before we can display anything for the user.</p><p>What we want to do is cut a few steps out of this process. We want to send the <code class="literal">template</code> function to the browser, instead of sending the template text and having the browser compile it. To do this, we need to compile the templates as part of our development process.</p><p>The easiest<a id="id191" class="indexterm"/> way to do this is to use Grunt, a handy build tool. First, we'll need to install it, using the following commands:</p><div><pre class="programlisting">
<strong>npm install grunt --save-dev</strong>
<strong>npm install grunt-contrib-jst --save-dev</strong>
</pre></div><p>We won't be learning Grunt in depth here. If you aren't familiar with the library, there are many great resources to learn about it online. Start on the home page <a class="ulink" href="http://gruntjs.com/">http://gruntjs.com/</a>.</p><p>We're using npm to install both Grunt and the<a id="id192" class="indexterm"/> <strong>JavaScript Templates</strong> (<strong>JST</strong>) Grunt plugin. JST will do the compiling for us.</p><p>Next, we're going to need a <code class="literal">Gruntfile.js</code> file, which will configure this plugin. Put <code class="literal">Gruntfile.js</code> in the root of our project directory. In that file, start with the following code:</p><div><pre class="programlisting">module.exports = function (grunt) {
  grunt.initConfig({});

  grunt.loadNpmTasks('grunt-contrib-jst');
  grunt.registerTask('default', ['jst']);
};</pre></div><p>You might recollect that, in the previous chapter, we used the <code class="literal">exports</code> object to export functions from our <code class="literal">signin.js</code> module. We can also completely overwrite that <code class="literal">exports</code> object; however, when we do that, we have to use its full name, <code class="literal">module.exports</code>. To this we assign a function that takes a <code class="literal">grunt</code> object as a parameter. Inside this function, then, we configure Grunt for our project.</p><p>We start by calling the <code class="literal">initConfig</code> method<a id="id193" class="indexterm"/>, which configures all the plugins. After this, we register the plugin with Grunt; and finally, we can register a task. We're creating the default task, which will run when we call <code class="literal">grunt</code> on the command line. We're simply telling it to run the <code class="literal">jst</code> task.</p><p>Now, let's go back to that <code class="literal">initConfig</code> method call for a second using the following code:</p><div><pre class="programlisting">grunt.initConfig({
  jst: {
    templates: {
      options:  {
        templateSettings: {
          interpolate : /\{\{(.+?)\}\}/g
        },
        processName: function (filename) {
          return filename.split('/')[1].split('.')[0];
        }
      },
      files: {
        "public/templates.js": ["templates/*.html"]
      }
    }
  }
});</pre></div><p>We start<a id="id194" class="indexterm"/> with a <code class="literal">jst</code> property, because that's the name of the task we're configuring. Inside that, we create a target, which is a set of options for our task and the files we want to perform the task on (with those options). We're calling our target <code class="literal">templates</code>. The first option is the <code class="literal">templateSettings</code> object, which we've used in both the previous chapters; it allows us to use the curly-brace delimiter syntax. The second option that we're setting is a function that will name the templates. Our templates will be HTML files in the <code class="literal">templates</code> folder, so by default their names will be their file paths; something like <code class="literal">templates/event.html</code>. The <code class="literal">processName</code> function<a id="id195" class="indexterm"/> will convert that to just <code class="literal">event</code>. This name is how we will refer to them from the view code.</p><p>In <code class="literal">files</code>, we choose what files to work on. Here, we're saying that all the template files that match the string, <code class="literal">templates/*.html</code>, will be compiled into <code class="literal">public/templates.js</code>.</p><p>This might seem like a lot to set up, but now all we need to do is run <code class="literal">grunt</code> on the command line to get precompiled templates. We'll test this out when we make our views.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Creating the models</h1></div></div></div><p>Now that <a id="id196" class="indexterm"/>we've set up our template-creating process, let's begin with the project code. As earlier, we'll begin with the models. These will go in <code class="literal">models.js</code>:</p><div><pre class="programlisting">var Event = Backbone.Model.extend({});
var Events = Backbone.Collection.extend({
  model: Event,
  url: '/events'
});</pre></div><p>For now, this <a id="id197" class="indexterm"/>will do. We'll be coming back later to make some interesting changes.</p><p>In the <code class="literal">server.js</code> file, we'll make our route functions for the route we just defined in the <code class="literal">Events</code> class. Before that, though, we'll need our database. We create that as follows:</p><div><pre class="programlisting">var db  = new Bourne("db/events.json");</pre></div><p>This time, I'm putting the database JSON file in a folder of its own; if you want to do this, make sure you create the <code class="literal">db</code> folder.</p><p>But now, with the database in place, we can create the GET route. This will simply send all the records in our database back to the browser:</p><div><pre class="programlisting">app.get("/events", function (req, res) {
  db.find(function (err, events) {
    res.json(events);
  });
});</pre></div><p>The POST route is where the data for new event objects will be sent. We'll collect the properties into an object and insert it; our callback function can just send the updated record back to the browser. Here's what that looks like:</p><div><pre class="programlisting">app.post("/events", function (req, res) {
  var attrs = {
    title: req.body.title,
    details: req.body.details,
    date: req.body.date,
    createdOn: new Date()
  };
    
  db.insert(attrs, function (err, event) {
    res.json(event);
  });
});</pre></div><p>One more server method, and that's for the root route:</p><div><pre class="programlisting">app.get('/*', function (req, res) {
  db.find(function (err, events) {
    res.render("index.ejs", { 
      events: JSON.stringify(events) 
    });
  });
});</pre></div><p>This route is very similar<a id="id198" class="indexterm"/> to the get-all routes in both our previous chapters. It will render our <code class="literal">index.ejs</code> template, sending all our event records to the browser.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Creating controls</h1></div></div></div><p>Let's <a id="id199" class="indexterm"/>begin with some controls. As we had decided, we'll need to be able to open a form to create new events, so let's put a button for this on a control bar at the top of our page.</p><p>We can start with the template. If you haven't yet started, create a directory named <code class="literal">templates</code> at the root of our project. Inside that, create a file named <code class="literal">controls.html</code>, and put the following code in it:</p><div><pre class="programlisting">&lt;li&gt;&lt;a href="/create"&gt; Create Event &lt;/a&gt;&lt;/li&gt;</pre></div><p>We're only going to have one control, and it doesn't actually need to be a template, but this gives us the ability to easily extend it later. We can actually test out the precompiling now, by running <code class="literal">grunt</code> on the command line. When you do that, you should get a message saying that <strong>File "public/templates.js" created</strong>. Great! You can check out the content of that file if you want to:</p><div><pre class="programlisting">this["JST"] = this["JST"] || {};

this["JST"]["controls"] = function(obj) {
obj || (obj = {});
var __t, __p = '', __e = _.escape;
with (obj) {
__p += '&lt;li&gt;&lt;a href="/create"&gt; Create Event &lt;/a&gt;&lt;/li&gt;';

}
return __p
};</pre></div><p>It's rather messy, but it will do the job for us. The important thing to notice is that we can now reference this template function via <code class="literal">JST.controls</code>. The last step here is to include this script in our <code class="literal">index.ejs</code> file, just above our script tag from <code class="literal">views.js</code>, as follows:</p><div><pre class="programlisting">&lt;script src="img/templates.js"&gt;&lt;/script&gt;</pre></div><p>Speaking of <code class="literal">views.js</code>, we're ready to open that up and get cracking at the view from this template. We'll call it <code class="literal">ControlsView</code>:</p><div><pre class="programlisting">var ControlsView = Backbone.View.extend({
  tagName: "ul",
  className: "nav nav-pills",
  template: JST.controls,
  initialize: function (options) {
    this.nav = options.nav;
  },
  events: {
    'click a[href="/create"]': 'create'
  },
  render: function () {
    this.el.innerHTML = this.template();
    return this;
  },
  create: function (evt) {
    evt.preventDefault();
    this.nav("create", { trigger: true });
  }
});</pre></div><p>As our template<a id="id200" class="indexterm"/> is a group of list items (well, a single list item), it makes sense that we use a <code class="literal">&lt;ul&gt;</code> element for this view. Then, notice that we're getting our template from the <code class="literal">templates.js</code> file, via <code class="literal">JST.controls</code>; handy, no? The <code class="literal">render</code> function is very basic. It just renders our template; we don't even need to pass it any data. It's more interesting that we're listening for the click event on our <strong>Create Event</strong> link. When that happens, we'll prevent the default behavior, which is requesting the <code class="literal">/create</code> route from the server, and instead we'll send it to our Backbone router.</p><p>We did this in <a class="link" href="ch01.html" title="Chapter 1. Building a Simple Blog">Chapter 1</a>, <em>Building a Simple Blog</em>, but we did it differently. Back then, we used the actual router object inside our views; we just expected it to be available as a global variable. That was a bad idea. This time, we're improving on that in two ways. First, we're expecting to receive the router as a property in our <code class="literal">options</code> object when this view is created. You can see in the <code class="literal">initialize</code> function that we're assigning <code class="literal">this.nav</code> from <code class="literal">options.nav</code>. The second improvement is that this isn't actually the whole router object; it's just the router's <code class="literal">navigate</code> method. This way, we can give select views the power to change routes, and they still can't mess with the rest of the router.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>This is a software design pattern known as dependency injection. Basically, the router's <code class="literal">navigate</code> method is a dependency that we are injecting into our <code class="literal">ControlsView</code> class. This allows us to keep unrelated code separate, which can make updating this code in the future a simpler process. For example, if we need to change the way routing is done in our application, we only need to inject a new or an updated dependency into this class, and hopefully not change much at all in this class. Dependency injection is one way to follow the dependency inversion principle, one of the five SOLID design principles. To read more about them, start at the Wikipedia page <a class="ulink" href="https://en.wikipedia.org/wiki/SOLID">https://en.wikipedia.org/wiki/SOLID</a>.</p></div></div><p>Lastly, you're probably wondering about the <code class="literal">className</code> property. As you perhaps suspect, this<a id="id201" class="indexterm"/> sets the <code class="literal">class</code> attribute on our elements. But where are these classes coming from? Well, in this application, we're going to be using Twitter's Bootstrap library, and these classes create a basic navigation/controls bar.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Including Bootstrap</h2></div></div></div><p>Of course, for this to<a id="id202" class="indexterm"/> work, we'll have to add this library to our projects. You can head over to <a class="ulink" href="http://getbootstrap.com">http://getbootstrap.com</a> and click on <strong>Download Bootstrap</strong>. There are a bunch of files here, but we don't need them all. In our project's <code class="literal">public</code> directory, create a folder named <code class="literal">css</code>, and copy the <code class="literal">bootstrap.min.css</code> file into that. We'll also need <code class="literal">bootstrap.min.js</code>, which we'll put in the <code class="literal">public</code> folder. Bootstrap also comes with the GLYPHICONS fonts (<a class="ulink" href="http://glyphicons.com/">http://glyphicons.com/</a>), so you'll have to create a <code class="literal">fonts</code> folder in the <code class="literal">public</code> directory, and copy the font files from Bootstrap's <code class="literal">font</code> directory. With these pieces in place, we can add a link to the <code class="literal">stylesheet</code> tag in the head of the <code class="literal">index.ejs</code> file:</p><div><pre class="programlisting">&lt;link rel="stylesheet"  href="/css/bootstrap.min.css" /&gt;</pre></div><p>And then, at the bottom, we link to the JavaScript portion of Bootstrap:</p><div><pre class="programlisting">&lt;script src="img/bootstrap.min.js"&gt;&lt;/script&gt;</pre></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>If you aren't familiar with <strong>GLYPHICONS</strong><a id="id203" class="indexterm"/>, it's a collection of symbols that you can use for icons within your web applications. Usually, you have to buy a license, but a few of them are provided with Bootstrap, free for its users.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Starting the router</h1></div></div></div><p>Now, to<a id="id204" class="indexterm"/> render our controls, we need to start building our router. We have created a <code class="literal">router.js</code> file, so let's open that up, as follows:</p><div><pre class="programlisting">var AppRouter = Backbone.Router.extend({
  initialize: function (options) {
    this.main = options.main;
    this.events = options.events;
    this.nav = this.navigate.bind(this);
  },
  routes: {
    '': 'index'
  },
  index: function () {
    var cv = new ControlsView({
      nav: this.nav
    });
    this.main.html(cv.render().el);
  }
});</pre></div><p>From our <code class="literal">initialize</code> function, we can see that we expect to get our main element and an <code class="literal">Events</code> collection as properties of our <code class="literal">options</code> object. We're also creating a <code class="literal">nav</code> property; this is the <code class="literal">nav</code> method that we saw in <code class="literal">ControlsView</code>. It's important to realize that we can't just send <code class="literal">this.navigate</code>; we need to make sure that the function is bound to the router object, which we do with its <code class="literal">bind</code> method. When we bind a function in this way, we're creating a copy of the function whose value of <code class="literal">this</code> (inside the function copy) is whatever object we pass as a parameter to <code class="literal">bind</code>; so anywhere we call the function that is stored in <code class="literal">this.nav</code>, the value of <code class="literal">this</code> will be consistent. To learn more about <code class="literal">this</code> in JavaScript, the JavaScript Garden is a great resource and is available at <a class="ulink" href="http://bonsaiden.github.io/JavaScript-Garden/#function.this">http://bonsaiden.github.io/JavaScript-Garden/#function.this</a>.</p><p>Our index route is pretty simple right now. We're just rendering our controls. It's a start, however! Now, in <code class="literal">index.ejs</code>, we can instantiate the router as follows:</p><div><pre class="programlisting">var r = new AppRouter({
  main: $("#main"),
  events: new Events(&lt;%- events %&gt;)
});
Backbone.history.start({ pushState: true });</pre></div><p>Now, we can start the server up (<code class="literal">npm start</code>) and load the page. This should look like what is shown in the following screenshot:</p><div><img src="img/6997OS_03_01.jpg" alt="Starting the router"/></div><p>As we now have<a id="id205" class="indexterm"/> a button, it makes sense to get that button working. Right now, when we click on the button, our route changes to <code class="literal">/create</code>; but nothing else changes, because we haven't created that route yet. So add this to our router's routes object as follows:</p><div><pre class="programlisting">'create': 'create'</pre></div><p>And then add the <code class="literal">following</code> function to the router as well:</p><div><pre class="programlisting">create: function () {
  var cv = new CreateEventView({
    collection: this.events,
    nav: this.nav
  });
  this.main.prepend(cv.render().el);
}</pre></div><p>We haven't created the <code class="literal">CreateEventView</code> view class yet, but you can see that we'll pass it our collection of events and our <code class="literal">nav</code> method. We'll render it and append it to the main element.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>You might recall from the previous chapter that we didn't name the collection property <code class="literal">collection</code> when we weren't rendering it, so other developers reading our code won't confuse the purpose of giving the view a collection. However, we are naming it <code class="literal">collection</code> in this case because the <code class="literal">events</code> property is already used by Backbone to assign DOM events.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Building the CreateEventView class</h1></div></div></div><p>So let's <a id="id206" class="indexterm"/>create the <code class="literal">CreateEventView</code> view class. Now, let's throw a twist in; since we have Bootstrap on our page, why don't we use its modal component to display our form?</p><p>To do this, we'll begin by creating our template. Create <code class="literal">templates/createEvent.html</code> and put this in that file:</p><div><pre class="programlisting">&lt;div class="modal-dialog"&gt;
&lt;div class="modal-content"&gt;
  &lt;div class="modal-header"&gt;
    &lt;button class="close"&gt;&amp;times;&lt;/button&gt;
    &lt;h4 class="modal-title"&gt; Create New Event &lt;/h4&gt;
  &lt;/div&gt;
  &lt;div class="modal-body"&gt;
    &lt;form&gt;
      &lt;label&gt;Title&lt;/label&gt;
      &lt;input type="text" class="form-control" id="title" /&gt;
      &lt;label&gt;Details&lt;/label&gt;
      &lt;textarea id="details"  class="form-control"&gt;&lt;/textarea&gt;
      &lt;label&gt;Date&lt;/label&gt;
      &lt;input type="datetime-local" class="form-control" id="date" /&gt;    
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div class="modal-footer"&gt;
    &lt;a href="#" class="create btn btn-primary"&gt; Create Event &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div><p>It's a lot of HTML, but you can see the form in the middle there, right? Actually, the Bootstrap model requires another wrapping <code class="literal">&lt;div&gt;</code>, but the view class will provide that. Here's the first portion of that view:</p><div><pre class="programlisting">var CreateEventView = Backbone.View.extend({
  className: "modal fade",
  template: JST.createEvent,
  initialize: function (options) {
    this.nav = options.nav;
  },
  render: function (model) {
    this.el.innerHTML = this.template();
    return this;
  }
});</pre></div><p>This is what we start with, and it's a very basic view. The most important thing to notice here is the <code class="literal">className</code> property; these classes style the modal window. However, at this point, if we compile our <a id="id207" class="indexterm"/>template and click on our button, our modal window won't appear. What's up with that? If you inspect the page in the developer tools of your browser, you'll see that the view's HTML is added to the page, but it isn't viewable. You can see that in the following screenshot:</p><div><img src="img/6997OS_03_02.jpg" alt="Building the CreateEventView class"/></div><p>The problem is that we need to use Bootstrap's jQuery modal plugin, which we had loaded earlier (<code class="literal">bootstrap.min.js</code>). We can use this plugin to show and hide the modal. To show the form, it's as easy as adding the following line of code to our <code class="literal">render</code> method, right after calling the <code class="literal">template</code> function:</p><div><pre class="programlisting">this.$el.modal("show"); </pre></div><p>We get the "jQuer-ified" element and call the <code class="literal">modal</code> method, passing it the command to show the modal window.</p><p>The next step is to add a few events to this class. There are two buttons to consider: the <strong>Create Event</strong> button (to create new <code class="literal">Event</code> model) and the <strong>x</strong> button (to close the modal window, not creating a new model):</p><div><pre class="programlisting">events: {
  "click .close": "close",
  "click .create": "create"
},</pre></div><p>The <code class="literal">close</code> method will be very simple. See the following code:</p><div><pre class="programlisting">close: function (evt) {
  evt.preventDefault();
  this.$el.modal("hide");
},</pre></div><p>We prevent the default action of the button, and then hide the modal window.</p><p>Now, how about writing the <code class="literal">create</code> method? We write it using the following code:</p><div><pre class="programlisting">create: function (evt) {
  evt.preventDefault();
  var e = {
    title: this.$("#title").val(),
    details: this.$("#details").val(),
    date: this.$("#date").val()
  };
  this.$el.modal("hide");
  this.collection.create(e, { wait: true });
  return false;
}</pre></div><p>We collect all<a id="id208" class="indexterm"/> the properties for our new event object and use the collection's <code class="literal">create</code> method to send the data to the server. We're passing the <code class="literal">wait</code> option because we'll soon have views listening for the creation of new events. This way, the views won't be notified until this event object has been successfully saved on the server.</p><p>There's one piece of this puzzle left; when either of the buttons are clicked, the modal is closed, but its DOM elements still exist. To get rid of the elements that make up the view, we need to call the view's <code class="literal">remove</code> method. This method gets rid of the elements and removes any event handlers connected to those elements. So when exactly should we call this <code class="literal">remove</code> method? Well, when we hide the modal, it will fade out; we need to remove the view after that. Handily, the jQuery plugin that we're using emits events at different points. We can listen for the <code class="literal">hidden.bs.modal</code> event<a id="id209" class="indexterm"/>, which will fire once the modal's fade-out sequence has completed.</p><p>So, in the view's <code class="literal">initialize</code> method, we'll listen for that event using the following code:</p><div><pre class="programlisting">this.$el.on("hidden.bs.modal", this.hide.bind(this));</pre></div><p>When it fires, we'll call the <code class="literal">hide</code> method on our view. That method looks like this:</p><div><pre class="programlisting">hide: function () {
  this.remove();
  this.nav('/');
},</pre></div><p>We call the view's <code class="literal">remove</code> function to get rid of the DOM and events; then, we use the <code class="literal">nav</code> method to send our users back to the home page.</p><p>Now, let's pause for a moment and think about how the user might go through our application. They <a id="id210" class="indexterm"/>can start on the home page and click on the <strong>Create Event</strong> button, which will take them to the <code class="literal">/create</code> route. However, it doesn't reload the page; it just fades in the modal. When they close the modal window (either by submitting the form or closing the form), they'll be taken back to the home route; the form will fade out and the control bar will still be there. However, it's also possible that the user will go directly to <code class="literal">/create</code>. They'll get the form, which will work fine; however, when they close the modal, they'll be taken back to the home route, but the page will be blank. This is because we're not triggering the router's <code class="literal">index</code> method when we move back to that route (no <code class="literal">{trigger: true}</code>). Why not trigger that method?</p><p>We're not triggering it because there's a better way here; even if the user goes directly to <code class="literal">/create</code>, we want to render the controls (and the table that will eventually be there). This means that, in the <code class="literal">create</code> router method, we need to check to see whether <code class="literal">index</code> has been called yet. In our case, we'll do that simply by checking for the existence of the navigation. In the <code class="literal">create</code> method, add this just before appending the <code class="literal">CreateEventView</code> instance:</p><div><pre class="programlisting">if ($("ul.nav").length === 0) {
  this.index();
}</pre></div><p>Now, if a user goes directly to the <code class="literal">/create</code> route, the router's <code class="literal">index</code> method will be called if it hasn't been rendered.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Creating the events table</h1></div></div></div><p>At this point, <a id="id211" class="indexterm"/>we're successfully creating new event records and storing them in our database. The next step is to display the table of events. We'll start with the <code class="literal">EventsView</code> class.</p><p>Actually, we'll start with template for this view. In <code class="literal">templates/events.html</code>, we'll create the <code class="literal">thead</code> and <code class="literal">tbody</code> elements as follows:</p><div><pre class="programlisting">&lt;thead&gt;
  &lt;tr&gt;
    &lt;th data-field="id"&gt;ID&lt;/th&gt;
    &lt;th data-field="title"&gt;Title&lt;/th&gt;
    &lt;th data-field="details"&gt;Details&lt;/th&gt;
    &lt;th data-field="date"&gt;Date&lt;/th&gt;
    &lt;th data-field="createdOn"&gt;Created On&lt;/th&gt;
    &lt;th&gt; Actions &lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;/tbody&gt;</pre></div><p>As you can see, our table will show the five fields that our events have. We also have a sixth column for <a id="id212" class="indexterm"/>actions: the edit and delete actions. We have a data attribute on each one of the table heading elements, with names that match the property names of the <code class="literal">Event</code> records. We'll use these later for sorting. You can go ahead and run <code class="literal">grunt</code> on the command line to compile this template function.</p><p>Now, how about <code class="literal">EventsView</code>? We can compile this using the following code:</p><div><pre class="programlisting">var EventsView = Backbone.View.extend({
  tagName: "table",
  className: "table",
  template: JST.events,
  initialize: function (options) {
    this.nav = options.nav;
  },
  render: function () {
    this.el.innerHTML = this.template();
    this.renderRows();
    return this;
  },
  renderRows: function () {
    this.collection.forEach(this.addRow, this);
  },
  addRow: function (event) {
    this.$("tbody").append(new EventView({
      model: event,
      nav: this.nav
    }).render().el);
  }
});</pre></div><p>We start by making the element for this view a table; we're also adding the class <code class="literal">table</code> to get Bootstrap's table styling. In the <code class="literal">initialize</code> method, we can see that we're taking the <code class="literal">nav</code> method in the <code class="literal">options</code> object so that we can change routes. In <code class="literal">render</code>, we're rendering the template and then calling <code class="literal">renderRows</code>. The <code class="literal">renderRows</code> method loops over every item in our <code class="literal">Events</code> collection and calls <code class="literal">addRow</code>. You might wonder why we don't put the single<a id="id213" class="indexterm"/> line of code in this method right in the <code class="literal">render</code> method; it's because we'll need it in its own method later. That <code class="literal">addRow</code> method will take a single event object as a property and render an <code class="literal">EventView</code> instance, placing it in that <code class="literal">tbody</code> element that we put in the template. We'll be coming back to this view to add and adjust things, but let's go over to the <code class="literal">EventView</code> class now.</p><p>As we did earlier, we'll start with the template. The following code snippet should be the content of <code class="literal">templates/event.html</code>:</p><div><pre class="programlisting">&lt;td&gt;{{id}}&lt;/td&gt;
&lt;td&gt;{{title}}&lt;/td&gt;
&lt;td&gt;{{details}}&lt;/td&gt;
&lt;td&gt;{{date}}&lt;/td&gt;
&lt;td&gt;{{createdOn}}&lt;/td&gt;
&lt;td&gt;
  &lt;button class="edit btn btn-inverse"&gt;
    &lt;span class="glyphicon glyphicon-edit glyphicon-white"&gt;&lt;/span&gt;
  &lt;/button&gt;
  &lt;button class="delete btn btn-danger"&gt;
    &lt;span class="glyphicon glyphicon-trash"&gt;&lt;/span&gt;
  &lt;/button&gt;
&lt;/td&gt;</pre></div><p>The first portion of the template is simple. We're just placing the properties of the <code class="literal">Event</code> object in the <code class="literal">&lt;td&gt;</code> elements. In the last <code class="literal">&lt;td&gt;</code> element, we've got two buttons; we're using Bootstrap's button and Glyphicon classes to get the right styling. These will be the edit and delete buttons.</p><p>The following code snippet is the start of the <code class="literal">EventView</code> class:</p><div><pre class="programlisting">var EventView = Backbone.View.extend({
  tagName: "tr",
  template: JST.event,
  initialize: function (options) {
    this.nav = options.nav;
  }
});</pre></div><p>It is similar to the other views that we've seen so far. The <code class="literal">render</code> method, however, will be slightly more involved. Before that, we need to add another third-party library: Moment (<a class="ulink" href="http://momentjs.com/">http://momentjs.com/</a>). This library is a great tool to use for quickly formatting dates. Download the script from the website and add it to the <code class="literal">index.ejs</code> file, anywhere above the <code class="literal">views.js</code> file as follows:</p><div><pre class="programlisting">&lt;script src="img/moment.min.js"&gt;&lt;/script&gt;</pre></div><p>With that in <a id="id214" class="indexterm"/>place, we can add a <code class="literal">render</code> method to the <code class="literal">EventView</code> class as follows:</p><div><pre class="programlisting">render: function () {
  var attrs = this.model.toJSON(),
      date = moment(attrs.date),
      diff = date.unix() - moment().unix();
        
  attrs.date = date.calendar();
  attrs.createdOn = moment(attrs.createdOn).fromNow();
  this.el.innerHTML = this.template(attrs);
        
  if (diff &lt; 0) {
    this.el.className = "error";
  } else if (diff &lt; 172800) { // next 2 days
    this.el.className = "warning";
  } else if (diff &lt; 604800) { // next 7 days
    this.el.className = "info";
  }
        
  return this;
},</pre></div><p>This is easily the most complex <code class="literal">render</code> method that we've seen yet. We start with a few variables. We get the attributes of our model first. Then, we create a <code class="literal">moment</code> object and pass it the <code class="literal">date</code> property of our model. A <code class="literal">moment</code> object wraps a date and gives us access to several helpful date-related methods. Finally, we use Moment's <code class="literal">unix</code> method (which returns the time in seconds since the Unix Epoch) to get the difference between the time this event takes place and right now.</p><p>Next, we use that <code class="literal">date</code> object we just created to overwrite the default date value in the attribute object to be something more readable. We're using Moment's <code class="literal">calendar</code> method to give us a date string such as <code class="literal">Monday at 6:30 PM</code> (or <code class="literal">10/30/2014</code> for dates further away). Then, we replace the <code class="literal">createdOn</code> property with a different date string. With the Moment's <code class="literal">fromNow</code> method, we get a string such as <code class="literal">6 hours ago</code>. Then, we pass our updated attributes object to the <code class="literal">this.template</code> function for rendering.</p><p>After rendering, we make one final adjustment. Bootstrap has a few handy classes used for coloring table rows, so we'll color a row differently depending on the time of the event. If the value of <code class="literal">diff</code> is less<a id="id215" class="indexterm"/> than 0 (which means the event began some time before this table was rendered), we'll add the <code class="literal">danger</code> class, resulting in a red row. If the event occurs within the next two days (<code class="literal">diff &lt; 172800</code>), we'll go with <code class="literal">warning</code> (a yellow row). If the event is in the next week (<code class="literal">diff &lt; 604800</code>), the <code class="literal">success</code> class gives us a green row.</p><p>Let's head back to the router to put the <code class="literal">EventsView</code> and <code class="literal">EventView</code> classes to work. Here's the new <code class="literal">index</code> method:</p><div><pre class="programlisting">index: function () {
  var cv = new ControlsView({
    nav: this.nav
  }),
  av = new EventsView({
    collection: this.events,
    nav: this.nav
  });
  this.main.html(cv.render().el);
  this.main.append(av.render().el);
},</pre></div><p>With this in place, we can reload the home page and see the table. If you add a few events, you should see something like what is shown in the following screenshot:</p><div><img src="img/6997OS_03_03.jpg" alt="Creating the events table"/></div><p>Things are looking pretty good at this point, you'll have to agree. However, there's still a lot to do before<a id="id216" class="indexterm"/> we finish this application. Let's begin by getting that delete button to actually delete a record.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Deleting a record</h1></div></div></div><p>As the button<a id="id217" class="indexterm"/> is already in place, we just have to wire it up. In <code class="literal">EventView</code>, let's add the event listener as follows:</p><div><pre class="programlisting">events: {
  "click .delete" : "destroy"
},</pre></div><p>You know what's next. We need to create the <code class="literal">destroy</code> method in the <code class="literal">EventView</code> class. It can be done as follows:</p><div><pre class="programlisting">destroy: function (evt) {
  evt.preventDefault();
  this.model.destroy();
  this.remove();
},
remove: function () {
  this.$el.fadeOut(Backbone.View.prototype.remove.bind(this));
  return false;
}</pre></div><p>The <code class="literal">destroy</code> method will call the model's <code class="literal">destroy</code> method and then call this view's <code class="literal">remove</code> method. Normally, that would be all, but we want to add a touch more. We want to fade the table row out and then remove the DOM elements. So, we're overwriting the default Backbone View <code class="literal">remove</code> method. We'll use jQuery to fade the element out. The <code class="literal">fadeOut</code> method that jQuery has takes a callback, a function that will be called after the fadeout is complete. We can get the usual Backbone View <code class="literal">remove</code> method from the <code class="literal">Backbone.View.prototype</code> object. Of course, we have to call it on the right view instance by binding the method to the current view, <code class="literal">this</code>.</p><p>We haven't called a Backbone model's <code class="literal">destroy</code> method before, as we're doing here in the view's <code class="literal">destroy</code> method. This method sends a DELETE request to the server, to the route <code class="literal">/events/&lt;id&gt;</code>. We'll need to create a method for this in our <code class="literal">server.js</code> file as follows:</p><div><pre class="programlisting">app.delete("/events/:id", function (req, res) {
  db.delete({ id: parseInt(req.params.id, 10) }, function () {
    res.json({});
  });
});</pre></div><p>It's pretty basic; our database has a <code class="literal">delete</code> method, so we call that, passing it a query object with the <code class="literal">id</code> we get from the route. What we return is irrelevant, so we'll return an empty object.</p><p>With that code in<a id="id218" class="indexterm"/> place, you can now click on the delete button in any of our events' table rows, and that row will fade away. Refresh the page, and you'll see that it's gone for good.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Editing event records</h1></div></div></div><p>The next step <a id="id219" class="indexterm"/>is to allow users to edit their event records. Wiring up our edit button will be simple. First, we listen for the click in the <code class="literal">events</code> object of <code class="literal">EventView</code>, like this:</p><div><pre class="programlisting">"click .edit": "edit"</pre></div><p>And secondly, we navigate to the edit route for that event:</p><div><pre class="programlisting">edit: function (evt) {
  evt.preventDefault();
  this.nav("/edit/" + this.model.get("id"), { trigger: true });
}</pre></div><p>We want our edit routes to act just like our create route does. If the user clicks on an edit button, a modal will fade in and allow editing of the event records. But they should also be able to go directly to the edit route and the table will load under the modal. This means that our router's <code class="literal">edit</code> method should be very similar to its <code class="literal">create</code> method.</p><p>First, we'll add the route to the router's <code class="literal">route</code> object as follows:</p><div><pre class="programlisting">'edit/:id': 'edit'</pre></div><p>Then, the <code class="literal">edit</code> method itself using the following code:</p><div><pre class="programlisting">edit: function (id) {
  var ev = new EditEventView({
    model: this.events.get(parseInt(id, 10)),
    nav: this.nav
  });

  if ($("ul.nav").length === 0) {
    this.index();
  }

  this.main.prepend(ev.render().el);
}</pre></div><p>We haven't<a id="id220" class="indexterm"/> created <code class="literal">EditEventView</code> yet, but if you look back at the <code class="literal">create</code> method, you'll see how similar these both are. That calls for a little refactoring as we have done in the following code snippet:</p><div><pre class="programlisting">create: function () {
  var cv = new CreateEventView({
    collection: this.events,
    nav: this.nav
  });
  this.modal(cv);
},
edit: function (id) {
  var ev = new EditEventView({
    model: this.events.get(parseInt(id, 10)),
    nav: this.nav
  });
  this.modal(ev);
},
modal: function (view) {
  if ($("ul.nav").length === 0) {
    this.index();
  }
  this.main.prepend(view.render().el);
}</pre></div><p>We've pulled the common code out into a <code class="literal">modal</code> method. Then, in both <code class="literal">create</code> and <code class="literal">edit</code>, we pass the view we want to render to that method.</p><p>Next, we need to create the <code class="literal">EditEventView</code> class<a id="id221" class="indexterm"/>. If you pause for a moment and think about this, you'll realize that since we want it to act like the <code class="literal">CreateEventView</code> class<a id="id222" class="indexterm"/>, it'd be great if we could somehow reuse as much of the code for that view as possible. Really, the main difference between the <code class="literal">create</code> and <code class="literal">edit</code> views is that, in the <code class="literal">edit</code> view, the current values of the record will already be in the form input elements. We'll also want the form heading and button text to be appropriately changed.</p><p>We can start with the <code class="literal">createEvent.html</code> file under <code class="literal">templates</code>. We'll prepare it to take the values we need to pass to it as follows:</p><div><pre class="programlisting">&lt;div class="modal-dialog"&gt;
&lt;div class="modal-content"&gt;
  &lt;div class="modal-header"&gt;
    &lt;button class="close"&gt;&amp;times;&lt;/button&gt;
    &lt;h4 class="modal-title"&gt; {{ heading }} &lt;/h4&gt;
  &lt;/div&gt;
  &lt;div class="modal-body"&gt;
    &lt;form&gt;
      &lt;label&gt;Title&lt;/label&gt;
      &lt;input type="text" class="form-control" id="title" value="{{title}}" /&gt;
      &lt;label&gt;Details&lt;/label&gt;
      &lt;textarea id="details"  class="form-control"&gt;{{details}}&lt;/textarea&gt;
      &lt;label&gt;Date&lt;/label&gt;
      &lt;input type="datetime-local" class="form-control" id="date" value="{{date}}" /&gt;    
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div class="modal-footer"&gt;
    &lt;a href="#" class="modify btn btn-primary"&gt; {{btnText}} &lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div><p>Notice <a id="id223" class="indexterm"/>that we're not just expecting values in the form input elements, we're also expecting a heading and text for the button. And, as this template will be used by both <code class="literal">CreateEventView</code> and <code class="literal">EditEventView</code>, let's rename it to <code class="literal">templates/modifyEvent.html</code>.</p><p>Don't forget to recompile the template (<code class="literal">grunt</code>, on the command line).</p><p>Since almost all the behavior we want for the <code class="literal">EditEventView</code> class is the same as we created for the <code class="literal">CreateEventView</code> class, let's extract as much as possible out into a <code class="literal">ModifyEventView</code> class. The following code is what we have come up with:</p><div><pre class="programlisting">var ModifyEventView = Backbone.View.extend({
  className: "modal fade",
  template: JST.modifyEvent,
  events: {
    "click .close": "close",
    "click .modify": "modify"
  },
  initialize: function (options) {
    this.nav = options.nav;
    this.$el.on("hidden.bs.modal", this.hide.bind(this));
  },
  hide: function () {
    this.remove();
    this.nav('/');
  },
  close: function (evt) {
    evt.preventDefault();
    this.$el.modal("hide");
  },
  render: function (model) {
    var data = this.model.toJSON();
    data.heading = this.heading;
    data.btnText = this.btnText;
    this.el.innerHTML = this.template(data);
    this.$el.modal("show");  
    return this;
  },
  modify: function (evt) {
    evt.preventDefault();
    var a = {
      title: this.$("#title").val(),
      details: this.$("#details").val(),
      date: this.$("#date").val()
    };
    this.$el.modal("hide");
    this.save(a);
    return false;
  }
});</pre></div><p>There are a few key differences between this class and the <code class="literal">CreateEventView</code> class. First, notice <a id="id224" class="indexterm"/>that in the <code class="literal">render</code> method, we're adding <code class="literal">heading</code> and <code class="literal">btnText</code> to the data that we put into the template. We'll get to where these come from in a minute. The other thing is that, in the <code class="literal">modify</code> method, we're calling <code class="literal">this.save</code> instead of <code class="literal">this.collection.create</code>. This is one of the big differences between creating a record and updating a record; the way we save them. So we'll need to create a <code class="literal">save</code> method for each, saying how exactly to do the saving.</p><p>Now if this view class acts as a parent class, or a superclass, what about the child views? Well, the <code class="literal">EditEventView</code> is very simple as follows:</p><div><pre class="programlisting">var EditEventView = ModifyEventView.extend({
  heading: "Edit Event",
  btnText: "Update",
  save: function (e) {
    this.model.save(e);
  }
});</pre></div><p>First, notice how we're creating this view: <code class="literal">ModifyEventView.extend</code>. Backbone's class-creating functionality<a id="id225" class="indexterm"/> allows us to extend our own views in the same way that we extend <code class="literal">Backbone.View</code>. Of course, we get access to all the methods and properties of <code class="literal">ModifyEventView</code>, plus whatever we add. This is where we add the <code class="literal">heading</code> and <code class="literal">btnText</code>, which our <code class="literal">render</code> method uses. This is also where the <code class="literal">save</code> method comes in. In this view, we're just using the model's <code class="literal">save</code> method to send the updated attributes back to the server. We'll create a server method for this in a second. But first, we need to update our <code class="literal">CreateEventView</code> to use <code class="literal">ModifyEventView</code> using the following code:</p><div><pre class="programlisting">var CreateEventView = ModifyEventView.extend({
  heading: "Create New Event",
  btnText: "Create",
  initialize: function (options) {
    ModifyEventView.prototype.initialize.call(this, options);
    this.model = new Event();
  },
  save: function (e) {
    this.collection.create(e, { wait: true });
  }
});</pre></div><p>Besides the <code class="literal">heading</code>, <code class="literal">btnText</code>, and <code class="literal">save</code> parts that we're familiar with, we're also overwriting the <code class="literal">initialize</code> method. We do call the parent class' <code class="literal">initialize</code> method in there, but there's something more. If you think about our template for a second, you'll see why. Our template expects to receive attributes to fill in the form inputs with, but the <code class="literal">CreateEventView</code> class doesn't have a model to give it; its job is to create a model! So what we're going to do is create a disposable <code class="literal">Event</code> object with blank attributes, so that no values are actually filled in, but we won't get any errors from the template function.</p><p>However, you probably realize that a blank <code class="literal">Event</code> object won't actually have any attributes. What we need to do is add default values so that the <code class="literal">Event</code> objects will have empty properties to pass to the template. In the <code class="literal">models.js</code> file, insert the following code:</p><div><pre class="programlisting">var Event = Backbone.Model.extend({
  defaults: {
    title: "",
    details: "",
    date: ""
  }
});</pre></div><p>This is our updated model class. Very simple, but it solves our view problems.</p><p>Don't forget, <a id="id226" class="indexterm"/>we're calling <code class="literal">this.model.save</code> in our <code class="literal">EditEventView</code> class. This will send the updated attributes to the server via a PUT request to <code class="literal">/events/&lt;id&gt;</code>. In <code class="literal">server.js</code>, here's how we process those PUT requests:</p><div><pre class="programlisting">app.put("/events/:id", function (req, res) {
  var e = {
    title: req.body.title,
    details: req.body.details,
    date: req.body.date
  };

  db.update({ id: parseInt(req.params.id, 10) }, e, 
    function (err, e) {
      res.json(e);
    });
});</pre></div><p>We'll round up the attributes into an object and pass it to our database's <code class="literal">update</code> method. To find the right record to update, we'll pass a query object with the record's ID. Then, we will return the updated record to the browser as JSON to complete the transaction.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Making it live</h1></div></div></div><p>At this <a id="id227" class="indexterm"/>point, we have a pretty decent application. We can create events that show up in our table. We can update and remove these events as well. However, if multiple people are using the same table of events, we might want to regularly poll the server for changes to the dataset. This way, someone could leave the page open, like a dashboard of sorts, and it would always be up to date.</p><p>This feature sounds like it might be tricky to implement, but it's actually much easier than you think. The first step is to go to the <code class="literal">model.js</code> file, and extend our <code class="literal">Events</code> collection by adding these methods to it:</p><div><pre class="programlisting">initialize: function (models, options) {
  this.wait = (options &amp;&amp; options.wait) || 10000; 
},
refresh: function () {
  this.fetch();
  setTimeout(this.refresh.bind(this), this.wait);
}</pre></div><p>The <code class="literal">refresh</code> method<a id="id228" class="indexterm"/> is the important one here. Mainly, we're calling the collection's <code class="literal">fetch</code> method. This will get the set of models from the server and set them as the model for collection. However, it does it in a smart way. If there are any new models, it will fire an <code class="literal">add</code> event; if there are any updated models, it will fire a <code class="literal">change</code> event; and, if any models were removed, it will fire a <code class="literal">remove</code> event. And it will leave any untouched models alone. Then, we set a timeout, to call this method again after a certain number of seconds.</p><p>We've also added an <code class="literal">initialize</code> method to allow the option of how many seconds to wait between fetches. If the <code class="literal">options</code> object has a <code class="literal">wait</code> property, we'll use that. Otherwise, it's 10 seconds.</p><p>Now, in the <code class="literal">initialize</code> method for the <code class="literal">EventsView</code> class, we just have to call the collection's <code class="literal">refresh</code> method like this:</p><div><pre class="programlisting">this.collection.refresh();</pre></div><p>Getting the updates is that simple. Now, we need to listen for the events and do the right thing.</p><p>Any new records added to the collection from the update will fire an <code class="literal">add</code> event on the collection. Thus, in <code class="literal">EventsView</code>, we should listen for that. We also need to add this to its <code class="literal">initialize</code> method. So, here's the whole <code class="literal">initialize</code> method, with both of these updates:</p><div><pre class="programlisting">initialize: function (options) {
  this.nav = options.nav;
  this.listenTo(this.collection, 'add', this.addRow);
  this.collection.refresh();
},</pre></div><p>Previously, we used the <code class="literal">on</code> method to listen to events. However, <code class="literal">listenTo</code> is an alternative form. It does pretty much the same thing, but it allows the listener—the view, in this case—to keep a track of the events it is listening for. This way, if we ever delete the view object, the <code class="literal">remove</code> method can detach those events and conserve browser memory. Here, we're telling our view to listen for an <code class="literal">add</code> event on the collection; when this occurs, we call <code class="literal">addRow</code>. As we know, this will add an <code class="literal">EventView</code> class to our table.</p><p>That takes <a id="id229" class="indexterm"/>care of additions via AJAX updates. The <code class="literal">remove</code> and <code class="literal">change</code> events will be called on the event model. This means that we listen for the changes in our <code class="literal">EventView</code>. In its <code class="literal">initialize</code> method, we'll listen for the events. Here's the whole new <code class="literal">EventView</code> <code class="literal">initialize</code> method:</p><div><pre class="programlisting">initialize: function (options) {
  this.nav = options.nav;
  this.listenTo(this.model, "remove", this.remove);
  this.listenTo(this.model, "change", this.render);
},</pre></div><p>We've already created the <code class="literal">render</code> and <code class="literal">remove</code> methods, so this is all that we need.</p><p>And that's all! Now, you can open <code class="literal">http://localhost:3000</code> in multiple browser windows. Go ahead and add an event in one browser window; you should see it show up in the other, in less than 10 seconds. You can edit or remove an event, and you'll see the change in the other window. Pretty cool, eh? And it only required a minimal amount of code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Sorting events</h1></div></div></div><p>There's <a id="id230" class="indexterm"/>one more feature we're going to add to our application. We have a table of events, so why not add the ability to sort the rows by whichever field we click on?</p><p>First, we need to sort the models in the collection. You already know that when we make a collection object, we pass it an array of model objects. We can have the collection sort these upon creation, by adding a comparator to the <code class="literal">Events</code> class. In <code class="literal">models.js</code>, add the following line to the <code class="literal">Events</code> collection class:</p><div><pre class="programlisting">comparator: 'date',</pre></div><p>Adding this line will sort the models in the collection by the <code class="literal">date</code> field. This will sort the models initially added to the collection, and any models subsequently added. However, it will not re-sort the models after one of them has been changed. This is important because we want our table rows to reorder if necessary when we edit an event record. We can implement that rather easily. However, when we edit a model, it will emit a <code class="literal">change</code> event, which bubbles up to the collection. We can listen for this in the <code class="literal">Events</code> collection's <code class="literal">initialize</code> method as follows:</p><div><pre class="programlisting">this.listenTo(this, 'change', this.sort);</pre></div><p>It's as simple as listening for the <code class="literal">change</code> event on the collection itself; when that occurs, we manually call the <code class="literal">sort</code> method on the collection.</p><p>However, there's something more to do in the collection. The default <code class="literal">sort</code> method will only sort in one direction. We want to be able to click on a heading a second time and get a reverse sort. So, we'll have to write a <code class="literal">reverse</code> method ourselves. Insert the following code in the <code class="literal">Events</code> collection:</p><div><pre class="programlisting">reverse: function (options) {
  this.sort({ silent: true });
  this.models = this.models.reverse();
  this.trigger('sort', this, options);
}</pre></div><p>First, we call <code class="literal">sort</code>; we pass it the <code class="literal">silent</code> option so that the <code class="literal">sort</code> event will not be fired. Then, we get the internal <code class="literal">models</code> property; this is the array that holds the model instances in our collection. We call the native array method <code class="literal">reverse</code> to reverse the order of the models in the array. We reassign this reversed array back to the <code class="literal">models</code> property. Finally, we trigger the <code class="literal">sort</code> event; this is the event that would usually be triggered by the <code class="literal">sort</code> method, but we silenced that one so that we could reverse the array. We pass the collection object and any options passed to <code class="literal">reverse</code> as parameters of the <code class="literal">sort</code> event.</p><p>If our collection is sorted, when we loop over it in the <code class="literal">EventsView</code> class to add the record to a table, they will be added in the right order. But we want to be able to click on the table headings and sort the rows by the clicked heading. So the next step is to listen for the click event in our <code class="literal">EventsView</code> class. Add the following code to that class:</p><div><pre class="programlisting">events: {
  'click th[data-field]': 'sort'
},</pre></div><p>Here, we listen for a click on any of the table headings that have the <code class="literal">data-field </code>attributes that we put into the template. So, let's write this <code class="literal">sort</code> method in <code class="literal">EventsView</code> as follows:</p><div><pre class="programlisting">sort: function (evt) {
  var target = evt.currentTarget,
      c = this.collection;
        
  c.comparator = target.getAttribute("data-field");
        
  if (target.getAttribute("data-direction") === "asc") {
    c.reverse();
    this.fixSortIcons(target, "desc");
  } else {
    c.sort();
    this.fixSortIcons(target, "asc");
  }
}</pre></div><p>We start by<a id="id231" class="indexterm"/> getting the element that was clicked (the <code class="literal">target</code>); we also make a shorter variable for the collection, just because we use it a lot in this method. Next, we set the new comparator on the collection. Then, we need to figure out which direction we're trying to sort in. We do this by another attribute on our table headings <code class="literal">data-direction</code>. If the attribute is <code class="literal">asc</code>, we'll do the reverse sort. Otherwise, if it's <code class="literal">desc</code>, we'll do a regular sort.</p><p>But where does this attribute come from? We didn't put it in the template. Well, notice the <code class="literal">fixSortIcon</code> method we're calling. This method does two things. First, as we expect, it will set the <code class="literal">data-direction</code> attribute on the element. But we're also setting an icon; an arrow that will indicate the direction of the sort. Here's that method:</p><div><pre class="programlisting">fixSortIcons: function (target, dir) {
  var icon = 'glyphicon glyphicon-arrow-' + (dir === 'asc' ? 'down' : 'up');
  this.$("th i").remove();
  target.setAttribute("data-direction", dir);
  $("&lt;i&gt;").addClass(icon).appendTo(target);
},</pre></div><p>This method takes two parameters: the target element (the table heading that the user clicked on) and the direction (<code class="literal">asc</code> or <code class="literal">desc</code>). First, we get the name for the Glyphicons arrow icons: up for <code class="literal">desc</code>, down for <code class="literal">asc</code>. To show this icon, we're going to need an <code class="literal">&lt;i&gt;</code> element. But, for anything other than the first sort, there's going to be an <code class="literal">&lt;i&gt;</code> element from the previous sort. The next step is to remove those. Then, we set the attribute on the target element. The last step is to create the <code class="literal">&lt;i&gt;</code> element, add the appropriate class, and append it to the target element.</p><p>So now, when we click on a header, the collection will sort by that property. But, how do we actually reorder the table rows? As you know, when the collection is sorted, a <code class="literal">sort</code> event will be emitted. Let's capture that in the <code class="literal">EventsView</code> <code class="literal">initialize</code> method like this:</p><div><pre class="programlisting">this.listenTo(this.collection, 'sort', this.renderRows);</pre></div><p>As we saw earlier, the <code class="literal">renderRows</code> function will add a row for each record in the collection. We already have rows in the table, so we have to figure out what to do with those. The <a id="id232" class="indexterm"/>easiest thing to do would be to simply empty the <code class="literal">&lt;tbody&gt;</code> element and make a bunch of new <code class="literal">EventView</code> instances. However, this isn't great for memory management. We should properly remove the views with their <code class="literal">remove</code> method, to unhook event listeners, and then we could create new <code class="literal">EventViews</code> class. We're going to take an alternate approach; however, we're going to reorder the views that we've already created. This means that we need to keep references to the <code class="literal">EventView</code> instances. In the <code class="literal">EventsView</code> <code class="literal">initialize</code> method, let's create a <code class="literal">children</code> property to keep track of these views. This can be done with the following little code snippet:</p><div><pre class="programlisting">this.children = {};</pre></div><p>Then, we need to change the <code class="literal">addRow</code> method so that it makes use of this property. It should now look like this:</p><div><pre class="programlisting">addRow: function (event) {
  if (!this.children[event.id]) {
    this.children[event.id] = new EventView({
      model: event,
      nav: this.nav
    }).render();
  }
        
  this.$("tbody").append(this.children[event.id].el);
},</pre></div><p>Now, this method will first check to see whether there's a property in our <code class="literal">children</code> object with the ID of this event. If not, we'll create a new <code class="literal">EventView</code> object, render it, and store it in the <code class="literal">children</code> object. Whether it's freshly created or not, we'll append it to <code class="literal">&lt;tbody&gt;</code>. The beauty of this is that even if it's already in <code class="literal">&lt;tbody&gt;</code>, this will move it to the end. After running through the collection, the table rows will be properly sorted.</p><p>That's everything in place! Now, head over to the browser and give the sorting feature a once around. The following screenshot shows the things in action:</p><div><img src="img/6997OS_03_04.jpg" alt="Sorting events"/></div><p>And now, sorting by the ID column can be seen in the following screenshot:</p><div><img src="img/6997OS_03_05.jpg" alt="Sorting events"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>Summary</h1></div></div></div><p>We've covered a lot in this chapter. Previously, we'd only created and read models on the server. Now, we know how to update and delete models on the server as well. This is bread-and-butter stuff for Backbone applications. Many of the apps you build will use all the four CRUD operations: creating, reading, updating, and deleting.</p><p>Another important thing to take away is the way we updated the collection by fetching from the server. You won't do it this way in every application—regularly polling the server—but the events that we listened for will be the same in every case. In fact, there's a common Backbone convention here; listen for the <code class="literal">change</code> event on a model and rerender the view that shows that model. Usually, you'll only need to call the <code class="literal">render</code> method to do that. As the main element of the view is already in the DOM, there's no need to reappend it; it will update when <code class="literal">render</code> is called.</p><p>Also, a notable thing in this chapter is the way we created a <code class="literal">view</code> class and then extended it with two child view classes. Don't forget that your models, collections, and views have the <code class="literal">extend</code> method, just like their Backbone parents. You can use this to your advantage when you find yourself creating two or more extremely similar components.</p><p>Finally, remember that discarding views is about more than just deleting its DOM elements. It's important to do it properly, by calling the view's <code class="literal">remove</code> method. However, as we saw, it's more than just that. When listening for events in the view's <code class="literal">initialize</code> method, it's better to use <code class="literal">this.listenTo</code> than <code class="literal">this.model.on</code> or <code class="literal">this.collection.on</code>. This way, the view can unhook these events when we remove it.</p><p>After creating this <code class="literal">events</code> dashboard, you might look at it and think that it makes a neat calendar. However, we can do much better for a calendar. We'll build that in the next chapter.</p></div></body></html>