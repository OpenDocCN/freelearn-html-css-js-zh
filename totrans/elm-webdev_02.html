<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Your First Elm App</h1>
                </header>
            
            <article>
                
<p> Welcome to the second chapter.<span> </span><span>The goal of this chapter is to understand the following topics:</span></p>
<ul>
<li><span>Immutable data structures</span></li>
<li><span>Elm Architecture basics—working with Model, View, and Update</span></li>
<li><em>Messages</em> in Elm</li>
<li><span>Unidirectional data flows</span></li>
<li>Understanding the <kbd>beginnerProgram</kbd> function</li>
<li>Reinforcing the use of HTML functions in Elm</li>
<li><kbd>If-else</kbd> expressions in Elm</li>
<li><kbd>Case</kbd> expressions in Elm</li>
<li>Basics of Elm data structures (lists, tuples, records, sets, arrays, and dictionaries)</li>
<li>Union types in Elm</li>
<li><span>Using modulus to perform calculations in Elm </span></li>
</ul>
<p>After completing this chapter, you will be able to do the following things:</p>
<ul>
<li>Work with the Elm architecture</li>
<li>Use <kbd>if-else</kbd> expressions and <kbd>case</kbd> expressions in your apps</li>
<li><span>Build a very simple <em>Fruit</em> Cou<em>nter</em> app in Elm</span></li>
<li>Build a very simple <em>FizzBuzz</em> app in Elm</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let's build an app</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss immutable data structures and the basics of the Elm architecture. To make things more practical, we will build a very simple app, which will serve our goal of reinforcing these important concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutable data structures</h1>
                </header>
            
            <article>
                
<p>Elm is a<span> functional programming language. One of the tenets of functional programming languages is that data structures are immutable. Once created, they cannot be changed. I</span><span>n practice, this means that functions in Elm will take in a data structure as its argument, and then return an entirely new data structure</span>.</p>
<p>If you think about it, it makes perfect sense. If all the data structures are immutable, how do we deal with change? More specifically, how do we deal with changes that Elm functions introduce on the existing data? The only obvious answer is to create entirely new data.</p>
<p>How does Elm apply this in practice? </p>
<p>Let's say that we want to build an app in the health niche. The app is a simple countdown app that displays only a button and a number. The app starts with the number 5. The idea of the app is for a user to press a button whenever they have eaten a healthy snack, say, a piece of fruit. That way, a user will improve their healthy habits by making sure that they have eaten five pieces of fruit a day.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Elm architecture</h1>
                </header>
            
            <article>
                
<div>
<p><span>The very minimum that we need to understand about the Elm architecture is that it is made up of four things: Model, View, Message, and Update.</span></p>
<p>It is important to note that the architecture is usually described as being made up of only three things: Model, View, and Update. However, for the sake of clarity and easier learning, at this point of our journey into Elm, we can think of the Message as an equal building block of the Elm architecture. In later chapters, as we dive deeper into both theory and practice, we will clarify these distinctions. However, for the sake of having a clear mental model of all the things that are in play here, we will think of the Elm architecture as having four constituent pieces.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Model</h1>
                </header>
            
            <article>
                
<p>The Model holds our app state. <span>The Model in our <em>Fruit Counter</em> app is very simple: it holds, as its one and only data structure, an integer. When we first run our app, the Model holds the value of 5.</span></p>
<p>Since it is represented in terms of data structures, and since data structures in Elm are immutable, our model will have to be updated as a copy of the previous data plus changes made to it. The model is updated whenever a function operates on it.</p>
<p>When will a function operate on the model? </p>
<p>Since we are building a very simple app, the only time a function will operate on the model is when the user clicks the one button in our app. Clicking this one button will decrement the current value in the model by 1. Since data in Elm is immutable, a function will have to return a new copy of the model, with updates taken into account. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The View</h1>
                </header>
            
            <article>
                
<p>The View can be thought of as <em>the way to see the Model on our screen</em>. The View is a function, and we pass t<span>he Model to it. Thus, the View takes in the Model as its parameter, and returns HTML, which will be rendered in the browser. </span></p>
<p>Another way to think of the View is that it is <em>a way to allow the user to interact with the Model</em>. To use the API reference we made in the previous chapter, the View is sort of like a visual API for the Model. It is a way for the user to manipulate the Model in a structured way.</p>
<p>When a user interacts with the View, they manipulate the Model by changing its state. Since our app is very simple, the only way to change the state is to press that one button in our app, which will decrement the current value that our model holds.  </p>
<p>This one button press will make the View send a Message to the Update.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Message</h1>
                </header>
            
            <article>
                
<p>After the user has interacted with the View (pressed the button), the notification of this action will be sent to the Update function in the form of a Message. Since there is only one possible action that can happen, that Message is simply: <em>decrement.</em></p>
<p>Of course, in any realistic app, the Message will have to have a lot more logic, but for the sake of simplicity, let's leave it at <em>decrement.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Update</h1>
                </header>
            
            <article>
                
<p>The Update function receives the Message. Next, the Update function determines how to update the state of our app, that is, the Model, based on the Message received. Once the update is made, a new Model is created and it renders the View. The user then interacts with the View which results in the Message being sent again. The Update receives the Message and updates the Model, and the cycle continues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unidirectional data flows</h1>
                </header>
            
            <article>
                
<p><span>An interesting way of looking at our app is as flows of data. The reason to have this concept and use it in our discussions is because it is a helpful way of looking at the changing of state in our Elm app.</span></p>
<p><span>Since Elm is built on a lot of restrictions, it only makes sense to have this idea of restrictions applied to its architecture as well.</span></p>
<p><span>If you look at what is happening in our simple app, you will notice that the data always moves in only one direction: From Model to View to Message to Update to Model. That's what unidirectional data flow basically is.</span></p>
<p><span>This concept allows us to be able to track state changes with ease, and it also makes it a lot less difficult to reason about these changes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our app requirements</h1>
                </header>
            
            <article>
                
<p>At this point of the book, we are more than ready to build our first app:</p>
<ul>
<li>We have an idea of how functional programming works</li>
<li>We understand the most basic concepts of how the Elm architecture operates (Model, View, Message, Update)</li>
<li>We know what we want our app to do</li>
</ul>
<p>Armed with this knowledge, we can now build our app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the Fruit Counter app</h1>
                </header>
            
            <article>
                
<p>Let's begin with our app skeleton. Let's point our browser to <a href="http://Ellie-app.com">Ellie-app.com</a>, and we'll be greeted with this code:</p>
<pre>module Main exposing (main)<br/><br/>import HTML exposing (HTML, text)<br/><br/><br/>main : HTML msg<br/>main =<br/>    text "Hello, World!"</pre>
<p>The preceding code will be the starting point for our app. We'll build on top of it by slowly adding features to it, and explaining the underlying concepts at the appropriate times, just when we need to understand them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing everything we need</h1>
                </header>
            
            <article>
                
<p>Let's begin by updating <kbd>module Main</kbd> to expose everything, by adding two dots inside parentheses. We will do the same for the imported <kbd>HTML</kbd> module, since we want do be able to use all the available HTML functions. Specifically, we need access to the <kbd>h1</kbd>, <kbd>p</kbd>, and <kbd>button</kbd> functions.</p>
<p>Next, the line that reads <kbd>main : HTML msg</kbd> is an optional type annotation, so to demonstrate that we can work without it, we'll comment it out by placing two hyphens and a space at the beginning of this line. </p>
<div class="packt_infobox"><br/>
Including type annotations is considered a best practice, and we have commented it out only to show that our app will still run without a type annotation (as well as to demonstrate how to add one-line comments in Elm).</div>
<p>Our app now looks like this:</p>
<pre>module Main exposing (..)<br/><br/>import HTML exposing (..)<br/><br/><br/>-- main : HTML msg<br/>main =<br/>    text "Hello, World!"</pre>
<p>To preview the app at this stage, simply compile it in the Ellie-app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Model</h1>
                </header>
            
            <article>
                
<p>Let's add our model:</p>
<pre>-- MODEL<br/><br/>type alias Model = <br/>    Int</pre>
<p>Our Model is just a simple integer type.</p>
<div class="packt_infobox"><br/>
For now, we'll simply ignore what this <kbd>type alias</kbd> signifies, as it will only distract us from understanding fundamental concepts at the moment. We will return to types later on in the book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The View</h1>
                </header>
            
            <article>
                
<p>Our <kbd>View</kbd> function will receive the current model and will return the following HTML:</p>
<pre>-- VIEW<br/><br/>view model =<br/>    div [] [ h1 [] [ text ("Fruit to eat: " ++ (toString model)) ] ] </pre>
<p>In <a href="7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml">Chapter 1</a>, <em>Why Is This a Great Time to Learn Elm?</em>, we looked at rendering some basic HTML to the screen using Elm's HTML functions. To reinforce that concept in light of the preceding code, let's quickly discuss the HTML that our <kbd>view</kbd> function will render.</p>
<p>The code that we are assigning to the <kbd>view</kbd> function is located to the right of the equals sign (Elm's assignment operator). In this code, we are running the <kbd>div</kbd> function.  Like all other HTML functions in Elm, the <kbd>div</kbd> function has two pairs of square brackets. The first pair of square brackets optionally lists the HTML attributes for the <kbd>div</kbd> function, and the second one lists the content of the actual <kbd>div</kbd>.</p>
<p>We have left the first pair of square brackets empty, which means we have not given any attributes to our <kbd>div</kbd> function. Then, <span>inside the second pair of square brackets of the <kbd>div</kbd> function, </span>we have passed in the <kbd>h1</kbd> function .</p>
<p>Like all other HTML functions, the <kbd>h1</kbd> function also has two pairs of square brackets. In the preceding example, our <kbd>h1</kbd> function has no attributes specified (as the first pair of brackets is empty - just like we did with the <kbd>div</kbd>, its parent function/element). Inside the second pair of brackets of the <kbd>h1</kbd> function, we call the <kbd>text</kbd> function.  </p>
<p>The <kbd>text</kbd> function will render a text node. The text to be output inside the text node is surrounded by parentheses. Inside the parentheses, we are using a string literal and we are concatenating to it the value of the <kbd>model</kbd>, converted to a string (using the <kbd>toString</kbd> function). </p>
<div class="packt_infobox">We've just learned about one of Elm's operators, the <kbd>++</kbd> operator.<br/>
In Elm, <kbd>++</kbd> is the string concatenation operator, used to join together two separate strings.</div>
<p>Since we will initialize our model with the value of 5, the preceding code for the <kbd>view</kbd> function will initially return the following HTML code:</p>
<pre>&lt;div&gt;<br/>    &lt;h1&gt;Fruit to eat: 5&lt;/h1&gt;<br/>&lt;/div&gt;</pre>
<p>Our <kbd>view</kbd> function is now ready at the most rudimentary level. Next, we'll deal with the Message section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Message</h1>
                </header>
            
            <article>
                
<p><span>Let's now look at the Message section, where we'll declare a new type, and we'll call it <kbd>Msg</kbd>:</span></p>
<pre>-- MESSAGE<br/><br/>type Msg = <br/>    Decrement</pre>
<div class="packt_infobox"><br/>
As mentioned earlier in the chapter, we will not deal with explaining types at this time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Update</h1>
                </header>
            
            <article>
                
<p><span>It's time to add our update. </span>In the previous step, we have declared our special type of <kbd>Msg</kbd>. We'll pass it to the <kbd>update</kbd> function:</p>
<pre>-- UPDATE<br/><br/>update msg model =<br/>    model - 1</pre>
<p>By now, it should be easy for you to guess what the <kbd>update</kbd> function will do: it will accept a <kbd>msg</kbd> and a <kbd>model</kbd>, and it will return a copy of the <kbd>model</kbd>, decremented by 1.</p>
<p>At this point of our <em>Fruit Counter</em> app development, all we have to do is make the Model, View, and Update work together, and for that, we'll use the <kbd>beginnerProgram</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the beginnerProgram function</h1>
                </header>
            
            <article>
                
<p>It's time to add the <kbd>beginnerProgram</kbd> function, which we will assign to the <kbd>main</kbd> function.</p>
<p>Our <kbd>main</kbd> function currently looks like this:</p>
<pre>-- main : HTML msg<br/>main =<br/>    text "Hello, World!"</pre>
<p>Let's add our updated <kbd>main</kbd> function, which will now have the <kbd>beginnerProgram</kbd> function assigned to it:</p>
<pre>-- main : HTML msg<br/>main =<br/>  beginnerProgram { model = 5, view = view, update = update }</pre>
<p>As you can see, we just call <span>the <kbd>beginnerProgram</kbd> function. Then, we pass it the <kbd>model</kbd>, <kbd>view</kbd>, and <kbd>update</kbd> functions, and assign each of them a value. </span></p>
<p>We initialize the model with the value of <kbd>5</kbd>. For <span>the <kbd>update</kbd>, we assign it to the value of the <kbd>update</kbd> function. The <kbd>view</kbd> is similarly set to the value of the <kbd>view</kbd> function.</span></p>
<p>After we made these changes to our <kbd>main</kbd> function, the full code of our app now looks like this:</p>
<pre>module Main exposing (..)<br/>import HTML exposing (..)<br/><br/>-- main : HTML msg<br/>main =<br/>  beginnerProgram { model = 5, view = view, update = update }<br/>  <br/>-- MODEL<br/>type alias Model = <br/>    Int<br/><br/>-- VIEW<br/>view model =<br/>    div [] [ h1 [] [ text ("Fruit to eat: " ++ (toString model)) ] ]   <br/><br/>-- MESSAGE<br/>type Msg = <br/>    Decrement<br/>     <br/>-- UPDATE<br/>update msg model =<br/>    model - 1</pre>
<p><span>If we ran our app at this point, everything would work, and we would get the following output on our screen: </span><span class="packt_screen">Fruit to eat: 5</span>.<span><br/></span></p>
<p><span>Even though our app is really basic, i</span>t's great that everything works and that we are not getting any compiler errors at this time.  However, there is one thing we did not do, and that is that we have not added the button, the one entry point to initiate the changing of our app's current state.</p>
<p>Before we do add this button, feel free to look at the preceding code and think a bit about a perfectly stateless app. Currently, our app's model will never change, as the update section of our code will never be run.</p>
<p>Let's rectify that by adding a button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views, buttons, and events</h1>
                </header>
            
            <article>
                
<p>Let's begin by simply adding a static button to our app. We'll do that by updating the view function with the following code:</p>
<pre>-- VIEW<br/>view model =<br/>    div [] <br/>        [ h1 [] [ text ("Fruit to eat: " ++ (toString model)) ] <br/>        , button [ onClick Decrement ] [ text "Eat fruit" ]<br/>        ]   </pre>
<p>If you saved and ran the app right now, the compiler would throw the following error:</p>
<pre><strong>NAMING ERROR</strong><br/><strong>Line 23, Column 20</strong><br/><strong>Cannot find variable onClick</strong></pre>
<p>Why did we get this error? Because we haven't imported the <kbd>onClick</kbd> function. Let's do that now, by adding the import at Line 3 of our app.</p>
<p>Looking at the beginning of our code, this is what the first three lines of code should look like after the update:</p>
<pre>module Main exposing (..)<br/><br/>import HTML exposing (..)<br/>import HTML.Events exposing (onClick)</pre>
<p>Running our app now would give us a simple, rudimentary, but working app built with Elm! </p>
<p>When you click the <span class="packt_screen">Eat fruit</span> button, the <kbd>view</kbd> function hits the first pair of square brackets on the <kbd>button</kbd> function, and it watches for the click event. We have provided the <kbd>onClick</kbd> function with the <kbd>Msg</kbd> to be sent once the button is clicked. Since there is only one possible message in our app, once the click event is triggered, the <kbd>view</kbd> function will send the <kbd>Decrement</kbd> message to the <kbd>update</kbd> function.</p>
<p>Once the <kbd>update</kbd> function has received the message, it will return a new <kbd>model</kbd>, and the new <kbd>model</kbd> gets rendered by the <kbd>view</kbd> function. </p>
<p>However, there is an issue. If we keep clicking the button, our app will ultimately move into counting negative numbers, and that's just impossible. A user should not have negative 2 fruits left to eat.</p>
<p>In the following section, we'll fix this issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constraining the Decrement message</h1>
                </header>
            
            <article>
                
<p>In order to constrain the Decrement message, let's begin by looking at the current update function:</p>
<pre>-- UPDATE<br/>update msg model =<br/>    model - 1</pre>
<p>Now, let's introduce an <kbd>if-else</kbd> statement to cater for different possible scenarios:</p>
<pre>-- UPDATE<br/>update msg model =<br/>    if model &gt; 0 then model - 1 else model == 5</pre>
<p>Unfortunately, the preceding code does not produce the desired results. Instead, we get this compiler message:</p>
<pre><strong>TYPE MISMATCH</strong><br/><strong>Line 39, Column 5</strong><br/><strong>The branches of this if produce different types of values.</strong><br/><br/><strong>The then branch has type:</strong><br/><br/><strong>number</strong><br/><strong>But the else branch is:</strong><br/><br/><strong>Bool</strong><br/><strong>Hint: These need to match so that no matter which branch we take, we always get back the same type of value.</strong></pre>
<p>We briefly touched upon Elm constraints in <a href="7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml">Chapter 1</a>, <em>Why Is This a Great Time to Learn Elm?</em> The preceding issue is a great example of Elm constraints in practice. Because of the way Elm is set up, each branch must return the same data type. In our case, we can either return Booleans for either branch of the <kbd>if-else</kbd> expression, or return numbers, but we can not have them mixed up.</p>
<p>So, how do we rectify this? To keep things simple and still use an <kbd>if-else</kbd> expression we started with, let's think of a terse way to avoid type mismatch. Our counter value should never go under zero, so we can simply do this:</p>
<pre>-- UPDATE<br/>update msg model =<br/>    if model &gt; 0 then model - 1 else model + 5</pre>
<p>Using the preceding code, our <kbd>if-else</kbd> logic will always return a number.  The update function's message value will be incremented by 1 as long as it's greater than zero. Otherwise (in case it is zero), it will be increased by 5. </p>
<p>To wrap this section up, let's look at another way we could have written the main function in our code:</p>
<pre>main =<br/>    HTML.beginnerProgram<br/>        { model = 5<br/>        , update = update<br/>        , view = view<br/>        }</pre>
<p>Before we finish this section of our chapter, let's look at the completed <em>Fruit Counter</em> app, as we will refer to it later in the chapter:</p>
<pre>module Main exposing (..)<br/><br/>import HTML exposing (..)<br/>import HTML.Events exposing (onClick)<br/><br/>-- main : HTML msg<br/>main =<br/>    HTML.beginnerProgram<br/>        { model = 5<br/>        , update = update<br/>        , view = view<br/>        }<br/>  <br/>-- MODEL<br/>type alias Model = <br/>    Int<br/><br/>-- VIEW<br/>view model =<br/>    div [] <br/>        [ h1 [] [ text ("Fruit to eat: " ++ (toString model)) ] <br/>        , button [ onClick Decrement ] [ text "Eat fruit" ]<br/>        ]   <br/><br/>-- MESSAGE<br/>type Msg = <br/>    Decrement<br/>     <br/>-- UPDATE<br/>update msg model =<br/>    if model &gt; 0 then model - 1 else model + 5</pre>
<p>Now that we have looked at a practical implementation of a simple app, let's discuss some of the theoretical concepts behind it, namely values and types in Elm, functions in Elm, and <kbd>if</kbd> expressions. We will wrap it up with a more in-depth look at Elm messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Values, expressions, data structures, and types in Elm</h1>
                </header>
            
            <article>
                
<p>There are no statements in Elm. In the <kbd>if-else</kbd> example we saw earlier in this chapter, the structure that we used was an expression, not a statement.</p>
<p>This difference is important, because it tells us something about the behavior of the Elm language: an expression will always return a value. In fact, everything in Elm is an expression, and thus everything will return a value, even without <span>having to use the <kbd>return</kbd> keyword explicitly (like we have to do in JavaScript, for example).</span></p>
<p>What, then, can this value be? A value is just a result of a calculation. It is the result of running an expression. In other words, when an expression is evaluated, it will result in a value. To test this out, we can have a look at the <strong>Elm REPL</strong>. To keep things simple, we will use the online elm-repl, available at <a href="http://elmrepl.cuberoot.in">elmrepl.cuberoot.in</a>. </p>
<div class="packt_tip">The Elm REPL is an interpreter for the Elm language. It's important to distinguish between the interpreter and the compiler.</div>
<p>Why are we using Elm REPL in the following examples? We are using it because it is a straightforward way to get information on the type of value that each of the expressions we give the REPL will evaluate to. In other words, we will give the Elm REPL a number of expressions, mostly in the form of simple values, and the REPL will give us back their type. We will start with expressions whose values will evaluate to primitive types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Primitive types in Elm</h1>
                </header>
            
            <article>
                
<p>The primitive types in Elm include <kbd>Char</kbd>, <kbd>String</kbd>, <kbd>Bool</kbd>, and <kbd>number</kbd> (<kbd>Int</kbd> and <kbd>Float</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Char and String types</h1>
                </header>
            
            <article>
                
<p>Let's type the following inside the online elm-repl:</p>
<pre><strong>'a'</strong></pre>
<p>The Elm-repl will give us back the result of running the preceding expression, and follow it up with the type of that value. The type of value 'a' is a <kbd>Char</kbd>:</p>
<pre><strong>'a' : Char</strong></pre>
<p>Let's do another one, this time with double quotes:</p>
<pre><strong>"a"</strong></pre>
<p>What we get back is this:</p>
<pre><strong>"a" : String</strong></pre>
<p>We can read the preceding as: Value <kbd>''a''</kbd> has a type of <kbd>String</kbd>.</p>
<div class="packt_tip">Obviously, when we use single quotes, we get <kbd>Chars</kbd>.<br/>
To get the type of <kbd>String</kbd> from a value, we need to surround that value in double quotes.</div>
<p>Multiline strings are written by enclosing any number of lines in three consecutive double quote characters. When using REPL, each line must also end with a backslash. Elm REPL inserts the pipe characters automatically. The entered multiline string value will still evaluate to the type of <kbd>String</kbd>:</p>
<pre><strong>""" \</strong><br/><strong>| This </strong><br/><strong>| is </strong><br/><strong>| a </strong><br/><strong>| multi-line</strong><br/><strong>| string</strong><br/><strong>| """</strong><br/><strong>" \n This \n is \n a \n multi-line  \n string \n " : String</strong></pre>
<p>Let's look at other primitive types in Elm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The number type</h1>
                </header>
            
            <article>
                
<p>If we just type a number, we'll get back that same number, followed with a colon and the <kbd>number</kbd> type:</p>
<pre><strong>&gt; 5</strong><br/><strong>5 : number</strong></pre>
<p>If we test a decimal number, we'll get back the type of <kbd>Float</kbd>:</p>
<pre><strong>&gt; 3.6</strong><br/><strong>3.6 : Float</strong></pre>
<div class="packt_tip packt_infobox">Why are some types capitalized, and some are not?<br/>
<br/>
If a type is capitalized, it means it is an explicit type. <br/>
Basically, the <kbd>number</kbd> type is used for both <kbd>Ints</kbd> and <kbd>Floats</kbd>. Which one it will end up being (which <em>explicit</em> type it will end up being), depends on how that number is used.<br/>
<br/>
Put differently, <kbd>number</kbd> is an implicit type, since it can end up as an explicit <kbd>Int</kbd> or an explicit <kbd>Float</kbd>.</div>
<p>To get back a value of type <kbd>Int</kbd>, let's run the following command:</p>
<pre><strong>&gt; truncate 3.14</strong><br/><strong>3 : Int</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Booleans</h1>
                </header>
            
            <article>
                
<p>Let's look at Boolean values:</p>
<pre><strong>&gt; True</strong><br/><strong>True : Bool</strong><br/><strong>&gt; False</strong><br/><strong>False : Bool</strong></pre>
<p>Capitalization is important! For example, typing <kbd>true</kbd> will throw an error:</p>
<pre><strong>&gt; true</strong><br/><strong>-- NAMING ERROR ---------------------------------------------- repl-temp-000.elm</strong><br/><br/><strong>Cannot find variable `true`</strong><br/><br/><strong>3| true</strong><br/><strong>     ^^^^</strong><br/><strong>Maybe you want one of the following?</strong><br/><br/><strong>    List.take</strong><br/><strong>    String.trim</strong></pre>
<p><span>With this, we have covered the primitive types in Elm. Next, we are going to look at data structures. Since Elm language is statically typed, and since everything in Elm is an expression, it follows that whatever we put into REPL will in fact be an expression, with a value that will evaluate to a type. Data structures are part of this behavior too.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data structures: lists, tuples, records, sets, arrays, and dictionaries</h1>
                </header>
            
            <article>
                
<p>Basic data structures in Elm are lists, tuples, records, sets, arrays, and dictionaries. In this section, we will look at the behavior of each of these data structures, using Elm REPL and the Ellie-app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p>A list in Elm is like an array in JavaScript. For our first example, let's type this value in Elm REPL:</p>
<pre><strong>[ 1, 2, 3, 4 ]</strong></pre>
<p>This is what we get back from the REPL:</p>
<pre><strong>[1,2,3,4] : List number</strong></pre>
<p>Awesome, a List of numbers!</p>
<p>Contrast that with Floats:</p>
<pre><strong>[ 0.1, 0.2, 0.3, 0.4 ]</strong></pre>
<p>The REPL responds with:</p>
<pre><strong>[0.1,0.2,0.3,0.4] : List Float</strong></pre>
<p>Let's try Chars:</p>
<pre><strong>[ 'a', 'b', 'c' ]</strong></pre>
<p>The REPL returns this:</p>
<pre><strong>['a','b','c'] : List Char</strong></pre>
<p>However, mixing values in Lists in Elm is not allowed:</p>
<pre><strong>&gt; [ 1, 2, 3, 'c' ]</strong><br/><strong>-- TYPE MISMATCH --------------------------------------------- repl-temp-000.elm</strong><br/><br/><strong>The 3rd and 4th entries in this list are different types of values.</strong><br/><br/><strong>3| [ 1, 2, 3, 'c' ]</strong><br/><strong>              ^^^</strong><br/><strong>The 3rd entry has this type:</strong><br/><br/><strong>    number</strong><br/><br/><strong>But the 4th is:</strong><br/><br/><strong>    Char</strong><br/><br/><strong>Hint: Every entry in a list needs to be the same type of value. This way you</strong><br/><strong>never run into unexpected values partway through. To mix different types in a</strong><br/><strong>single list, create a "union type" as described in:</strong><br/><strong>&lt;http://guide.elm-lang.org/types/union_types.HTML&gt;</strong><br/><br/></pre>
<p>Evidently, we cannot mix types in Elm Lists. In other words, each List in Elm is a group of expressions that must always evaluate to the same type.</p>
<p>Let's try Strings:</p>
<pre><strong>&gt; [ "just", "a", "bunch", "of", "strings" ]</strong><br/><strong>["just","a","bunch","of","strings"] : List String</strong></pre>
<p>What about an empty list?:</p>
<pre><strong>&gt; []</strong><br/><strong>[] : List a</strong></pre>
<p><em>List a</em> means that this list is empty, that is, that it can hold <em>anything</em>. This wraps up our short overview of Lists in Elm. Next, we will look at tuples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuples</h1>
                </header>
            
            <article>
                
<p>In Elm, a tuple is a data structure that can hold values of various types. </p>
<p>To make a Tuple in Elm REPL, let's simply put a <kbd>String</kbd> and a Boolean inside parentheses:</p>
<pre><strong>( "abc", True )</strong></pre>
<p>The REPL will respond with:</p>
<pre><strong>("abc",True) : ( String, Bool )</strong></pre>
<p>A tuple can hold a maximum of nine values. Interestingly, tuples of different lengths are considered to be of different types. For example, let's make a List that holds two tuples, using Elm REPL:</p>
<pre><strong>[ ( 'a', 'b' ), ( 'c', 'd' ) ]</strong></pre>
<p>This expression will evaluate to:</p>
<pre><strong>[('a','b'),('c','d')] : List ( Char, Char )</strong></pre>
<p>What REPL tells us is that the value we put in is a <kbd>List</kbd> of two tuples, holding values of <kbd>Char</kbd> type.</p>
<p>Let's try to vary the number of Chars in the second tuple:</p>
<pre><strong>[ ( 'a', 'b' ), ( 'c' ) ]</strong></pre>
<p>Running the preceding code in the REPL will throw the following error:</p>
<pre><strong>-- TYPE MISMATCH --------------------------------------------- repl-temp-000.elm</strong><br/><br/><strong>The 1st and 2nd entries in this list are different types of values.</strong><br/><br/><strong>3| [ ( 'a', 'b' ), ( 'c' ) ]</strong><br/><strong>                     ^^^</strong><br/><strong>The 1st entry has this type:</strong><br/><br/><strong>    ( Char, Char )</strong><br/><br/><strong>But the 2nd is:</strong><br/><br/><strong>    Char</strong></pre>
<p>Elm looks at the expression we gave it, and comes back with the <span class="packt_screen">Type Mismatch</span> error. Indeed, for two tuples to be considered to be of the same type, they have to hold the same number of values, and those values <em>also</em> need to be of the same type.</p>
<p>In the preceding working example, we added two tuples of two Chars to a <kbd>List</kbd>, and Elm REPL returned <kbd> List ( Char, Char )</kbd>. </p>
<p><span>The maximum number of values a tuple can hold in Elm is 9. If you try to add 10 or more values to a tuple, Elm will throw an error. Let's try this out:</span></p>
<pre><strong>('1','2','3','4','5','6','7','8','9','0')</strong></pre>
<p>What we get back is the following error:</p>
<pre><strong>elm-make: Could not find `_Tuple10` when solving type constraints.</strong></pre>
<p>In the chapters that follow, we will get to know tuples in much greater depth. For now, let's just mention a common use case: since tuples as a data structure can hold various values, they are useful as a way to store results of calculations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Records</h1>
                </header>
            
            <article>
                
<p>Records in Elm use curly braces, and a label for each value must be provided. Records can also hold multiple values. For example, we can type the following record into Elm REPL:</p>
<pre><strong>{ color="blue", quantity=17 }</strong></pre>
<p>The REPL will return this:</p>
<pre><strong>{ color = "blue", quantity = 17 } : { color : String, quantity : number }</strong></pre>
<p>We will use records a lot in our Elm programs, as records allow us to model the data in a wide variety of scenarios.</p>
<p>We have already used a record in our code in this chapter, in the <em>Adding the beginnerProgram function</em> section. Let's recall the code we used:</p>
<pre>-- main : HTML msg<br/>main =<br/>  beginnerProgram { model = 5, view = view, update = update }</pre>
<p><span>To test out the code in REPL, we will only have to use the record, without all the fluff:</span></p>
<pre><strong>{ model = 5, view = view, update = update }</strong></pre>
<p>REPL will respond with the following error:</p>
<pre><strong>-- NAMING ERROR ---------------------------------------------- repl-temp-000.elm</strong><br/><br/><strong>Cannot find variable `update`</strong><br/><br/><strong>3| { model = 5, view = view, update = update }</strong><br/><strong>                       ^^^^</strong></pre>
<p>The REPL will follow up the preceding error with a similar error saying that the <kbd>'update'</kbd> variable cannot be found either. To rectify this, as an exercise, we can give values to the variables used in our record, as follows:</p>
<pre><strong>&gt; view = "view info"</strong><br/><strong>"view info" : String</strong><br/><strong>&gt; update = "update info"</strong><br/><strong>"update info" : String</strong><br/><strong>&gt; { model = 5, view = view, update = update }</strong><br/><strong>{ model = 5, view = "view info", update = "update info" }</strong><br/><strong>    : { model : number, update : String, view : String }</strong></pre>
<p>We have assigned values of type <kbd>String</kbd> to the <kbd>view</kbd> and <kbd>update</kbd> variables in the Elm REPL. Then we entered the record, and the REPL returned types for each of the variables used in the record. Thus, in the preceding example, the <kbd>model</kbd> is of type <kbd>number</kbd>, the <kbd>update</kbd> is of type <kbd>String</kbd>, and the <kbd>view</kbd> is also of type <kbd>String</kbd>. </p>
<p>Next up, we'll look at sets, arrays, and dictionaries, which have to be imported, although they too are built into Elm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sets</h1>
                </header>
            
            <article>
                
<p>Sets are collections of unique values. Their uniqueness is guaranteed by the Elm programming language. We can instantiate sets as empty sets or use the <kbd>fromList</kbd> function. Creating an empty set is easy: <kbd>set = Set.empty</kbd>.</p>
<p>Let's look at the other way of creating sets in Elm, by pointing our browser to: <a href="http://ellie-app.com/new">ellie-app.com/new</a>.</p>
<p>The page that opens already has some Elm code in it. Let's adjust that code so that it looks as follows:</p>
<pre>module Main exposing (main)<br/><br/>import HTML exposing (HTML, text)<br/>import Set<br/><br/>set = Set.fromList [1,1,1,2]<br/><br/>main : HTML msg<br/>main =<br/>    text (toString set)</pre>
<p>What we did in the preceding code was, after importing <kbd>Set</kbd> (to the variable we named <kbd>set</kbd>), we assigned the returned value from the evaluated expression: <kbd>Set.fromList [1,1,1,2]</kbd>.</p>
<p>Next, we gave the <kbd>set </kbd> variable to our <kbd>main</kbd> function, to render it out as a text node. Of course, before it could be rendered out, we had to convert it to a <kbd>String</kbd>.  After pressing the <span class="packt_screen">Compile</span> button in the Ellie-app, we should see the following result: <span><kbd>Set.fromList [1,2]</kbd>.</span></p>
<p>Sets are useful when we are trying to find differences between data structures. Next, we'll look at arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays</h1>
                </header>
            
            <article>
                
<p>Arrays in Elm are zero-based, just like they are in JavaScript. With arrays, we can work with elements based on their index. Like sets, arrays can be created using the <kbd>fromList</kbd> function.</p>
<p>Alternatively, we can create an empty array like this: <kbd>array = Array.empty</kbd>. Still in the Ellie-app, let's make a slight change to our code to test out arrays:</p>
<pre>module Main exposing (main)<br/><br/>import HTML exposing (HTML, text)<br/>import Array<br/><br/>array = Array.fromList [1,1,1,2]<br/>array2 = Array.get 0 array<br/><br/>main : HTML msg<br/>main =<br/>    text ((toString array) ++ " " ++ (toString array2))</pre>
<p>In the preceding code, we have a slight twist—we grouped the concatenation of two arrays and a space, all converted to <kbd>Strings</kbd>, and then ran the <kbd>text</kbd> function on them, finally passing the value returned from the evaluation of the expression to the main function.</p>
<p>The compiled code will display the following result: <span><kbd>Array.fromList [1,1,1,2] Just 1</kbd>. </span>For now, let's just ignore what this result means, as we'll get back to it later in the book. Next, we'll look at dictionaries in Elm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p>Dictionaries are also created using the <kbd>fromList</kbd> function. Let's revisit the Ellie-app, with our code changed as follows:</p>
<pre>module Main exposing (main)<br/><br/>import HTML exposing (HTML, text)<br/>import Dict<br/><br/>dict = <br/>    Dict.fromList <br/>    [ ("keyOne", "valueOne")<br/>    , ("keyTwo", "valueTwo") <br/>    ]<br/><br/>main : HTML msg<br/>main =<br/>    text (toString dict)</pre>
<p>After compilation, the Ellie-app will return this:</p>
<pre>Dict.fromList [("keyOne","valueOne"),("keyTwo","valueTwo")]</pre>
<p><kbd>Dict</kbd> is the data structure used to store pairs of keys and values. Keys must be unique. To learn more about this data structure, visit the following URL: <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Dict">http://package.elm-lang.org/packages/elm-lang/core/latest/Dict</a>.</p>
<p>Next, we'll look at how types work for functions and <kbd>if</kbd> expressions in the Elm language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions, if expressions, and types</h1>
                </header>
            
            <article>
                
<p>Let's create a new function in Elm REPL. We'll call our function <kbd>multiplyBy5</kbd>:</p>
<pre><strong>multiplyBy5 num = 5 * num</strong></pre>
<p>The REPL will return this:</p>
<pre><strong>&lt;function&gt; : number -&gt; number</strong></pre>
<p>The preceding line says that our <kbd>multiplyBy5</kbd> function has the type of <kbd>number -&gt; number</kbd>. Let's see what type will get returned from a function that works with Strings:</p>
<pre><strong>appendSuffix n = n ++ "ing"</strong></pre>
<p>As we already know, the <kbd>++</kbd> operator is the concat operator in Elm; it will join two <kbd>Strings</kbd> together. Thus, expectedly, Elm REPL will return:</p>
<pre><strong>&lt;function&gt; : String -&gt; String</strong></pre>
<p>As we can see, the preceding function is of type <kbd>String -&gt; String</kbd>.</p>
<p>But, what is this <kbd>String -&gt; String</kbd>? And, along the same lines, what is the <kbd>Int -&gt; Int</kbd> from the previous example? <kbd>String -&gt; String</kbd> simply means that the function expects a <kbd>String</kbd> as its argument, and will also return a <kbd>String</kbd>. For <span>the </span><kbd>Int -&gt; Int</kbd><span> example, the function expects a value of type <kbd>Int</kbd> and will also return a value of type <kbd>Int</kbd>. </span></p>
<p>It's time to take a look at the basics of types in <kbd>if</kbd> expressions in Elm. Consider the following snippet of code and the response REPL gave it:</p>
<pre><strong>&gt; time = 24</strong><br/><strong>24 : number</strong><br/><strong>&gt; if time &lt; 12 then "morning" else "afternoon"</strong><br/><strong>"afternoon" : String</strong></pre>
<p>In the preceding code, we are running an <kbd>if</kbd> expression using the variable <kbd>time</kbd> (which we assign the value of <kbd>24</kbd>).  Then, we are running our comparison. Note that if expressions should actually be referred to as <kbd>if-else</kbd> expressions, as <kbd>if</kbd> expressions must have an else, otherwise they won't work in Elm.  Both the <kbd>if</kbd> and the <kbd>else</kbd> branch must be of the same type. That's why in the preceding example we are making sure that either result we get is of type <kbd>String</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting Elm messages</h1>
                </header>
            
            <article>
                
<p>We started off this chapter by looking at the Elm arhitecture: Model, View, and Update. We also mentioned another important ingredient: Messages, <strong>a way for Views to communicate with Updates</strong>.</p>
<p>We used a very simple example app, <em>Fruit Counter</em>. The app was simple indeed: the only message our view could ever send to the update function was <kbd>Decrement</kbd>. The simplicity of the app we made was a great way for us to understand the architecture without having to introduce too many concepts that would get in the way of learning.</p>
<p>However, now that we have a rudimentary understanding of all the moving parts and how they fit together, we can talk about another level of complexity related to messages in the Elm arhitecture.</p>
<p>To do that, we can look at a finished example straight from the official documentation. This will serve two purposes: first, it will get us in the habit of referring to the excellent official docs as often as possible, and second, it will give us a benchmark that we will initially look up to, and during the course of the book, leave behind as we learn more advanced concepts.</p>
<p>To get started, open the documentation for the buttons example at: <a href="https://guide.elm-lang.org/architecture/user_input/buttons.html">https://guide.elm-lang.org/architecture/user_input/buttons.HTML</a>.</p>
<p>Next, visit the Ellie online editor at <a href="https://ellie-app.com/new">https://ellie-app.com/new</a>, and paste in the code from the buttons example:</p>
<pre>import HTML exposing (HTML, button, div, text)<br/>import HTML.Events exposing (onClick)<br/><br/>main =<br/>  HTML.beginnerProgram { model = model, view = view, update = update }<br/><br/>-- MODEL<br/>type alias Model = Int<br/>model : Model<br/>model =<br/>  0<br/><br/>-- UPDATE<br/>type Msg = Increment | Decrement<br/>update : Msg -&gt; Model -&gt; Model<br/>update msg model =<br/>  case msg of<br/>    Increment -&gt;<br/>      model + 1<br/><br/>    Decrement -&gt;<br/>      model - 1<br/><br/>-- VIEW<br/>view : Model -&gt; HTML Msg<br/>view model =<br/>  div []<br/>    [ button [ onClick Decrement ] [ text "-" ]<br/>    , div [] [ text (toString model) ]<br/>    , button [ onClick Increment ] [ text "+" ]<br/>    ]</pre>
<p>After pasting in the code, click the <span class="packt_screen">Compile</span> button in the right-hand pane and the app will compile and run there. The app itself is very similar to our <em>Fruit Counter</em>, only slightly more advanced. Let's compare these differences.</p>
<p>In <em>Fruit Counter</em>, we had the following message:</p>
<pre>-- MESSAGE<br/><br/>type Msg = <br/>    Decrement</pre>
<p class="mce-root">In the Buttons app, the message is as follows:</p>
<pre>-- UPDATE<br/><br/>type Msg = Increment | Decrement</pre>
<p>The first thing to note is the comment preceding the code. Initially, we used <kbd>MESSAGE</kbd> as the comment text. However, in the Buttons example, they are using <kbd>UPDATE</kbd> in their inline comment. The reason: conventionally, the Elm architecture is considered to consist only of Model, View, and Update. We used Message as a separate part of the architecture only to help understand it easier. The most important point of that understanding is: <strong>the View sends Messages to the Update function</strong>. Conceptually, this is the same in both examples. The only difference is that now the <em>Message</em> is defined in the <em>Update</em> section of our app, as it should be. </p>
<p>The second thing to note is that our message only had the value of <kbd>Decrement</kbd>. It <em>could only be</em> a <kbd>Decrement</kbd> message. In the Buttons app, we have two options: the Message can <span>be </span><em>either</em> a <kbd>Decrement</kbd> <em>or</em> an <kbd>Increment</kbd>.</p>
<p>What's with the <kbd>type</kbd> keyword, and the pipe character, then? It has to do with something known as <strong>union types</strong> (also known as <strong>algebraic data types</strong> or <strong>tagged unions</strong>).</p>
<p>In Elm, a union type is simply a custom type that we can come up with on the fly. In our <em>Fruit Counter</em> app, our <kbd>Msg</kbd> union type has only one value: <kbd>Decrement</kbd>. In the Buttons app, the <kbd>Msg</kbd> union type can have either of the two values: <kbd>Increment</kbd> or <kbd>Decrement</kbd>. To<span> differentiate clearly between possible values in a union type, we use the pipe character. </span></p>
<p>Let's make another custom union type in the Elm REPL:</p>
<pre><strong>type Vehicle = Car | Bike | Boat | Helicopter</strong></pre>
<p>To create a union type, we begin with the <kbd>type</kbd> keyword. Next, we provide the actual type, <kbd>Vehicle</kbd>. We created a custom type on the fly, and named it <kbd>Vehicle</kbd>! To the right of the assignment operator  (the <kbd>=</kbd> sign), we provide the values that the <kbd>Vehicle</kbd> union type can have. <strong>These values are called type constructors</strong>, as you can use them to <strong>construct</strong> new instances of <kbd>Vehicle</kbd>.</p>
<p>Let's create a new instance of <kbd>Vehicle</kbd> in the REPL:</p>
<pre><strong>&gt; friendsRide = Helicopter</strong><br/><strong>Helicopter : Repl.Vehicle</strong></pre>
<p>We have just constructed a new instance of the <kbd>Vehicle</kbd> type. As we can see, the REPL responds with this information—the value is <kbd>Helicopter</kbd>, and its type is <kbd>Vehicle</kbd>.</p>
<p>Sometimes, it is helpful to explain the same concept in a couple of different ways. Another way of looking at union types is that they are a way for us to describe constructor functions, that is, to define them.</p>
<p>In the <kbd>update</kbd> function, we had:</p>
<pre>type Msg = Increment | Decrement</pre>
<p>The preceding code means that to make a <kbd>Msg</kbd>, either the <kbd>Increment</kbd> function or the <kbd>Decrement</kbd> function needs to be called.</p>
<p>The theoretical underpinnings of union types are rooted in mathematical logic, namely the set theory, which is basically the study of collections of things. Thus, we can look at a union type as a combination of any number of collections of things. Both union types and the set theory can get quite abstract, but at this point in our learning, suffice it to say that union types are a way to organize messages in Elm apps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions, pattern matching, and case expressions</h1>
                </header>
            
            <article>
                
<p>The goal of this chapter was to build a simple app and learn important theory behind it. We expanded on this goal by comparing our own app with the one from the official docs. </p>
<p>In this section, we will look at the update function of the Buttons App and take it apart in order to have complete understanding of what it does and how it works.</p>
<p>This is important, because once we understand how the <kbd>update</kbd> function works in the Buttons app, we will be able confidently to implement a similar solution and improve our <em>Fruit Counter</em>.</p>
<p>Let's begin by inspecting the <kbd>update</kbd> function in the Buttons app: </p>
<pre>update msg model =<br/>  case msg of<br/>    Increment -&gt;<br/>      model + 1<br/><br/>    Decrement -&gt;<br/>      model - 1</pre>
<p>We see a new keyword here: <kbd>case</kbd>.</p>
<p>Generally, the way that the <kbd>case</kbd> syntax works is as follows—a variable has a certain value. Based on its value, a certain block of code will execute. When the value is different, the block of code to execute will be different as well. Finally, at the end of a <kbd>case</kbd> expression, there is a block of code that will execute for all the values that were not already specified in the <kbd>case</kbd> expression. In other words, for any unspecified scenario, there is a case block at the bottom to take care of it. This <kbd>case</kbd> block is called the <em>wildcard</em> and it's marked with the underscore character, <kbd>_</kbd>. As we can see in the preceding example, there are situations where the <em>wildcard</em> case does not need to be added, because we have <em>already covered</em> all the possibilities.</p>
<p>Elm <kbd>case</kbd> expressions are evaluated via pattern matching, that is, by verifying whether a <kbd>case</kbd> conforms to a pattern. <em>If expressions</em> and <em>case expressions</em> are quite similar.  One major difference is that <kbd>case</kbd> expressions <em>match patterns</em>, and <kbd>if</kbd> expressions <em>check for true conditions</em> as ways to determine which code blocks to run.</p>
<p>Looking at the syntax of <kbd>case</kbd> expressions, we can see that they start with the <kbd>case</kbd> keyword, followed by the name of the case expression (in our example, <kbd>msg</kbd>). The name is completely arbitrary; instead of <kbd>msg</kbd>, we could have used anything else. For example:</p>
<pre>update whatever model =<br/>  case whatever of<br/>    Increment -&gt;<br/>      model + 1<br/><br/>    Decrement -&gt;<br/>      model - 1</pre>
<p>As you can see in the preceding code snippet, the <em>first parameter</em> of the <kbd>update</kbd> function and the <em>name of the case expression</em> must be the same. To avoid confusion, it's best to stick with <kbd>msg </kbd> as the first parameter here, as that is the norm, and you'll see it used that way in most Elm programs.</p>
<p>So, after the <kbd>case</kbd> keyword, and the name of the case expression, we have another keyword, <kbd>of</kbd>.</p>
<p>Next, we list our cases. The structure of the code is always the same: </p>
<pre>Pattern -&gt; Expression to evaluate</pre>
<p>If we look at the first case, we can see that it's written as follows:</p>
<pre>Increment -&gt;<br/>      model + 1</pre>
<p>In the preceding code snippet, the pattern to match is <kbd>Increment</kbd>, and the expression to evaluate is <kbd>model + 1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the Fruit Counter app</h1>
                </header>
            
            <article>
                
<p>Based on everything we have learned so far, let's improve the <em>Fruit Counter</em> app. Here is the full code:</p>
<pre>module Main exposing (..)<br/><br/>import HTML exposing (..)<br/>import HTML.Events exposing (onClick)<br/><br/>-- main : HTML msg<br/>main =<br/>    HTML.beginnerProgram<br/>        { model = 5<br/>        , update = update<br/>        , view = view<br/>        }<br/>  <br/>-- MODEL<br/>type alias Model = <br/>    Int<br/><br/>-- VIEW<br/>view model =<br/>    div [] <br/>        [ h1 [] [ text ("Fruit to eat: " ++ (toString model)) ] <br/>        , button [ onClick Decrement ] [ text "Eat fruit" ]<br/>        , button [ onClick Reset ] [ text "Reset counter" ]<br/>        ]   <br/><br/>-- MESSAGE<br/>type Msg = Decrement | Reset<br/>     <br/>-- UPDATE<br/>update msg model =<br/>    case msg of<br/>        Decrement -&gt; <br/>            if model &gt;= 1 then <br/>                model - 1<br/>            else<br/>                5<br/>        Reset -&gt; <br/>            5</pre>
<p>Let's highlight the improvements we made to our app:</p>
<ol>
<li>We added another button to our <kbd>view</kbd> function.</li>
<li>We added a new message, <kbd>Reset</kbd>, to be sent when the new button is clicked.</li>
<li>We added the <kbd>Reset</kbd> constructor function to our <kbd>Msg</kbd> union type.</li>
<li>In our <kbd>update</kbd> function, we gave our case expression the name of <kbd>msg</kbd>, and we also gave it two patterns to match: <kbd>Decrement</kbd> and <kbd>Reset</kbd>.</li>
<li>If the <kbd>Decrement</kbd> pattern gets matched, an <kbd>if</kbd> expression will be evaluated (to determine whether the model should be decreased by one or whether its value should be <kbd>5</kbd>).</li>
<li>If the <kbd>Reset</kbd> pattern gets matched, an expression of <kbd>5</kbd> will be evaluated.</li>
</ol>
<p>In the preceding explanation, an effort was made to describe all the updates in accordance with the concepts we learned in this chapter. It is important to understand the preceding explanation as it is the foundation on which we will build more complex apps in chapters that follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a simple FizzBuzz app in Elm</h1>
                </header>
            
            <article>
                
<p>FizzBuzz is a word game for kids. The purpose is to teach math, namely division.</p>
<p>The game is simple: each player calls out a number, starting from 1. If a number can be divided by three, a player needs to call out <em>Fizz</em> instead of a number. Furthermore, if a number can be divided by five, a player needs to call out <em>Buzz</em> instead of a number.</p>
<p>Finally, if a number can be divided by both 3 and 5, a player needs to call out <em>FizzBuzz</em>.</p>
<p>Since this is a well-known game, and a relatively simple problem, it is a great way to test the level of knowledge of a programmer. </p>
<p>In order to go about solving this problem, we will introduce a new operator, the modulus operator, <kbd>%</kbd>. This operator returns the division remainder. </p>
<p>The way it works can be best described by an example. Open up the online Elm REPL, and run the following expression:</p>
<pre><strong>12 % 10</strong></pre>
<p>The REPL will return:</p>
<pre><strong>2 : Int</strong></pre>
<p>What this means is: if we divide <kbd>12</kbd> by <kbd>10</kbd>, we will get <kbd>1</kbd>, and what will remain is <kbd>2</kbd>. Since <kbd>2</kbd> is less then <kbd>10</kbd>, it will not be divided, as the modulus in our example will only divide in increments of <kbd>10</kbd>, and return the remainder. </p>
<p>That's why we said that the modulus operator returns the remainder of a division (that is, whatever is on the right side of the modulus operator determines the size of increments).</p>
<p>So, for example, if we run this:</p>
<pre><strong>10 % 9</strong></pre>
<p>We will get this back:</p>
<pre><strong>1 : Int</strong></pre>
<p>However, we will get the exact same result if we run this:</p>
<pre><strong>19 % 9</strong></pre>
<p>The preceding expression will evaluate to <kbd>1 : Int</kbd> because the size of the increments that will be calculated is <kbd>9</kbd> in the preceding example. Since<span> </span><em>9 * 2 = 18</em>, the remainder of the division is 1.</p>
<p>What will happen if we divide the number by itself? Let's try number <kbd>3</kbd>:</p>
<pre><strong>3 % 3</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>0 : Int</strong></pre>
<p>We get back the value <kbd>0</kbd>, of type <kbd>Int</kbd>. We can do the same for <kbd>5</kbd> and <kbd>15</kbd>:</p>
<pre><strong>&gt; 5 % 5</strong><br/><strong>0 : Int</strong><br/><strong>&gt; 15 % 15</strong><br/><strong>0 : Int</strong></pre>
<p>Again, we get back zero, of type <kbd>Int</kbd>.</p>
<p>What does this mean in practice? It means that we can use an <kbd>if-else</kbd> expression to check for all the numbers that do not have a remainder when divided by 3. For all the numbers that satisfy that condition, we will return <em>Fizz</em>. We will apply a similar approach for numbers 5 and 15, as dictated by the rules of the game.</p>
<p><span>This is enough information for us to create our simple <em>FizzBuzz</em> app. Navigate your browser to ;<a href="https://ellie-app.com/new">https://ellie-app.com/new</a> and type the following code:</span></p>
<pre>module Main exposing (main)<br/><br/>import HTML exposing (text)<br/><br/>fizzBuzz = "FizzBuzz"<br/>fizz = "Fizz"<br/>buzz = "Buzz"<br/><br/>fizzBuzzInput value = <br/>    if value % 15 == 0 then<br/>        fizzBuzz<br/>    else if value % 3 == 0 then<br/>        fizz<br/>    else if value % 5 == 0 then<br/>        buzz<br/>    else (toString value)<br/><br/>main =<br/>    text (fizzBuzzInput 34567)</pre>
<p>At this point, we have enough knowledge fully to understand the preceding code with ease. Looking at the preceding code, one of the important concepts to be reminded of is the principle that we need to obey when working with <kbd>if</kbd> expressions: they should always return the same type of value. That is why we are passing the value to the <kbd>toString</kbd> function at the very bottom of our <kbd>if</kbd> expression.</p>
<p>As a quick reminder of piping syntax (discussed in <a href="7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml">Chapter 1</a>, <em>Why Is This a Great Time to Learn Elm?</em>), here is another way we could have written the main function:</p>
<pre>main =<br/>    fizzBuzzInput 34567<br/>    |&gt; text  </pre>
<div class="packt_infobox">The <kbd>|&gt;</kbd> is called the <strong>forward function application operator</strong>.</div>
<p>We have achieved our goal of making a working <em>FizzBuzz</em> app in Elm. In the chapters that follow, we will look at <span>ways of making improvements to our simple <em>FizzBuzz</em> app</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered a number of important topics, namely:</p>
<ul>
<li><span>Elm syntax: values, types, data structures, <kbd>if-else</kbd> expressions, <kbd>case</kbd> expressions, and some operators</span></li>
<li><span>TEA: The Elm architecture</span></li>
<li><span>The concept of unidirectional data flows</span></li>
<li>Working with Elm REPL and the Ellie-app</li>
</ul>
<p>We also built two working apps, which, although simple, have shown the practical application of the theoretical concepts we covered.</p>
<p>In the next chapter, we will make our own personal portfolio in Elm.</p>


            </article>

            
        </section>
    </body></html>