<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Appreciating Node</h1></div></div></div><p>At the time of writing this book, Node is approaching its fifth year of existence, and its usage has grown in each of those five years. The opportunity for Node to fail has come, and passed. Node is a serious technology built by a highly skilled core team and very active community focused on constantly improving its speed, security, and usefulness.</p><p>Every day, developers face some of the problems that NodeJS aims to solve. Some of them are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scaling networked applications beyond a single server</li><li class="listitem" style="list-style-type: disc">Preventing I/O bottlenecks (database, file, and network access)</li><li class="listitem" style="list-style-type: disc">Monitoring system usage and performance</li><li class="listitem" style="list-style-type: disc">Testing the integrity of system components</li><li class="listitem" style="list-style-type: disc">Managing concurrency safely and reliably</li><li class="listitem" style="list-style-type: disc">Pushing code changes and bug fixes into live environments</li></ul></div><p>In this book, we will look at techniques of deploying, scaling, monitoring, testing, and maintaining your Node applications. The focus will be on how Node's event-driven, nonblocking model can be applied in practice to these aspects of software design and deployment.</p><p>On February 28, 2014, Eran Hammer delivered the keynote address to attendees of NodeDay, a large developer conference organized and sponsored by PayPal. He began his address by reciting some numbers relevant to his employer, Walmart:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">11,000 stores</li><li class="listitem" style="list-style-type: disc">Half a trillion dollars of net sales per year</li><li class="listitem" style="list-style-type: disc">2.2 million employees</li><li class="listitem" style="list-style-type: disc">The largest private employer in the world</li></ul></div><p>He continued:</p><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"55 percent of our Black Friday traffic, which is our Superbowl of the year…we do about 40 percent of annual revenues on Black Friday. 55 percent came on mobile…that 55 percent of traffic went 100 percent through Node. […] We were able to deliver…this massive traffic with the equivalent of two CPUs and 30 Gigs of RAM. That's it. That's what Node needed to handle 100 percent of mobile Node traffic on Black Friday. […] Walmart global e-commerce is a 10-billion-dollar business, and by the end of this year, all 10 billion will go through Node."</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Eran Hammer, Senior Architect, Walmart Labs</em></td></tr></table></div><p>Modern network software, for various reasons, is growing in complexity and, in many ways, changing how we think about application development. Most new platforms and languages are attempting to address these changes. Node is no exception—and JavaScript is no exception.</p><p>Learning about Node means learning about event-driven programming, composing software out of modules, creating and linking data streams, and producing and consuming events and their related data. Node-based architectures are often composed of many small processes and/or services communicating with events—internally, by extending the <code class="literal">EventEmitter</code> interface and using callbacks and externally, over one of several common transport layers (for example, HTTP, TCP) or through a thin messaging layer covering one of these transport layers (for example, 0MQ, Redis PUBSUB, and Kafka). It is likely that these processes are composed of several free, open source, and high-quality <strong>npm</strong> modules, each distributed with unit tests and/or examples and/or documentation.</p><p>In this chapter, we will take a quick tour of Node, highlighting the problems it aims to solve, the solutions implied by its design, and what this means to you. We will also briefly discuss some of the core topics we will explore more comprehensively in later chapters, such as how to structure efficient and stable Node servers, how to make the best use of JavaScript for your application and your team, and how to think about and use Node for best results.</p><p>Let's start with understanding the how and why of Node's design.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding Node's unique design</h1></div></div></div><p>I/O operations (disk and network) are clearly more expensive. The following table shows clock cycles consumed by typical system tasks (from Ryan Dahl's original presentation of Node—<a class="ulink" href="https://www.youtube.com/watch?v=ztspvPYybIY">https://www.youtube.com/watch?v=ztspvPYybIY</a>):</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>L1-cache</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>3 cycles</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>L2-cache</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>14 cycles</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>RAM</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>250 cycles</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Disk</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>41,000,000 cycles</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Network</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>240,000,000 cycles</p>
</td></tr></tbody></table></div><p>The reasons <a id="id0" class="indexterm"/>are clear enough: a disk is a physical device, a spinning metal <a id="id1" class="indexterm"/>platter—storing and retrieving that data is much slower than moving data between solid-state devices (such as microprocessors and memory chips) or indeed optimized on-chip L1/L2 caches. Similarly, data does not move from point to point on a network instantaneously. Light itself needs 0.1344 seconds to circle the globe! In a network used by many billions of people regularly interacting across great distances at speeds much slower than the speed of light, with many detours and few straight lines, this sort of latency builds up.</p><p>When our <a id="id2" class="indexterm"/>software ran on personal computers on our desks, little or no communication was happening over the network. Delays or hiccups in our interactions with a word processor or spreadsheet had to do with disk access time. Much work was done to improve disk access speeds. Data storage and retrieval became faster, software became more responsive, and users now expect this responsiveness in their tools.</p><p>With the advent of cloud computing and browser-based software, your data has left the local disk and exists on a remote disk, and you access this data via a network—the Internet. Data access times have slowed down again, dramatically. Network I/O is slow. Nevertheless, more companies are migrating sections of their applications into the <em>cloud</em>, with some software being entirely network-based.</p><p>Node is designed to make I/O fast. It is designed for this new world of networked software, where data is in many places and must be assembled quickly. Many of the traditional frameworks to build web applications were designed at a time when a single user working on a desktop computer used a browser to periodically make HTTP requests to a single server running a relational database. Modern software must anticipate tens of thousands of simultaneously connected clients concurrently altering enormous, shared data pools via a variety of network protocols on any number of unique devices. Node is designed <a id="id3" class="indexterm"/>specifically to help those building that kind of network software.</p><p>What do concurrency, parallelism, asynchronous execution, callbacks, and events mean to the Node developer?</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Concurrency</h2></div></div></div><p>Running code <a id="id4" class="indexterm"/>procedurally, or in order, is a reasonable idea. We tend to do that when we execute tasks and, for a long time, programming languages <a id="id5" class="indexterm"/>were naturally procedural. Clearly, at some point, the instructions you send to a processor must be executed in a predictable order. If I want to multiply 8 by 6, divide that result by 144 divided by 12, and then add the total result to 10, the order of those operations must proceed sequentially:</p><div><pre class="programlisting">( (8x6) / (144/12) ) + 10</pre></div><p>The order of operations must not be as follows:</p><div><pre class="programlisting">(8x6) / ( (144/12) + 10 )</pre></div><p>This is logical and easy to understand. Early computers typically had one processor, and processing one instruction blocked the processing of subsequent instructions. But things did not stay that way, and we have moved far beyond single-core computers.</p><p>If you think about the previous example, it should be obvious that calculating <code class="literal">144/12</code> and <code class="literal">8x6</code> can be done independently—one need not wait for the other. A problem can be divided into smaller problems and distributed across a pool of available people or workers to work on in parallel, and the results can be combined into a correctly ordered final calculation.</p><p>Multiple processes, each solving one part of a single mathematical problem simultaneously, are an example of <strong>parallelism</strong>.</p><p>Rob Pike, co-inventor of Google's Go programming language, defines <strong>concurrency</strong> in this way:</p><div><blockquote class="blockquote"><p><em>"Concurrency is a way to structure a thing so that you can, maybe, use parallelism to do a better job. But parallelism is not the goal of concurrency; concurrency's goal is a good structure."</em></p></blockquote></div><p>Concurrency is not parallelism. A system demonstrating concurrency allows developers to compose applications <em>as if</em> multiple independent processes are simultaneously executing many possibly related things. Successful high-concurrency application development frameworks provide an easy-to-reason-about vocabulary to describe and build such a system.</p><p>Node's design <a id="id6" class="indexterm"/>suggests that achieving its primary goal—to provide an <a id="id7" class="indexterm"/>easy way to build scalable network programs—includes simplifying how the execution order of coexisting processes is structured and composed. Node helps a developer reasoning about a program, within which many things are happening at once (such as serving many concurrent clients), to better organize his or her code.</p><p>Let's take a look at the differences between parallelism and concurrency, threads and processes, and the special way that Node absorbs the best parts of each into its own unique design.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Parallelism and threads</h2></div></div></div><p>The <a id="id8" class="indexterm"/>following <a id="id9" class="indexterm"/>diagram describes<a id="id10" class="indexterm"/> how<a id="id11" class="indexterm"/> a traditional microprocessor might execute the simple program discussed previously:</p><div><img src="img/1403OS_01_01.jpg" alt="Parallelism and threads"/></div><p>The<a id="id12" class="indexterm"/> program <a id="id13" class="indexterm"/>is broken up into <a id="id14" class="indexterm"/>individual instructions that are executed in order. This works but does<a id="id15" class="indexterm"/> require that instructions be processed in a serial fashion, and, while any one instruction is being processed, subsequent instructions must wait. This is a blocking process—executing any one segment of this chain blocks the execution of subsequent<a id="id16" class="indexterm"/> segments. There is a <strong>single thread</strong> of execution in play.</p><p>However, there is some good news. The processor has (literally) total control of the board, and there is no danger of another processor nulling memory or overriding any other state that this primary processor might manipulate. Speed is sacrificed for stability and safety.</p><p>We do like speed; however, the model discussed earlier rapidly became obsolete as chip designers and systems programmers worked to introduce parallel computing. Rather than having one blocking thread, the goal was to have multiple cooperating threads.</p><p>This<a id="id17" class="indexterm"/> improvement definitely increased the speed of calculation<a id="id18" class="indexterm"/> but introduced some problems, as described in the<a id="id19" class="indexterm"/> following<a id="id20" class="indexterm"/> schematic:</p><div><img src="img/1403OS_01_02.jpg" alt="Parallelism and threads"/></div><p>This diagram illustrates cooperating threads executing in parallel within a single process, which reduces the time necessary to perform the given calculation. Distinct threads are employed to break apart, solve, and compose a solution. As many subtasks can be completed independently, the overall completion time can be reduced dramatically.</p><p>Threads provide parallelism within a single process. A single thread represents a single sequence of (serially executed) instructions. A process can contain any number of threads.</p><p>Difficulties arise out of the complexity of thread synchronization. It is very difficult to model<a id="id21" class="indexterm"/> highly concurrent scenarios using threads, especially <a id="id22" class="indexterm"/>models in which the state is shared. It is difficult to anticipate <a id="id23" class="indexterm"/>all<a id="id24" class="indexterm"/> the ways in which an action taken in one thread will affect all the others if it is never clear when an asynchronously executing thread will complete:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The shared memory and the locking behavior this requires lead to systems that are very difficult to reason about as they grow in complexity.</li><li class="listitem" style="list-style-type: disc">Communication between tasks requires the implementation of a wide range of synchronization primitives, such as mutexes and semaphores, condition variables, and so on. An already challenging environment requires highly complex tools, expanding the level of expertise necessary to complete even relatively simple systems.</li><li class="listitem" style="list-style-type: disc">Race conditions and deadlocks are a common pitfall in these sorts of systems. Contemporaneous read/write operations within a shared program space lead to problems of sequencing, where two threads may be in an unpredictable <em>race</em> for the right to influence a state, event, or other key system characteristic.</li><li class="listitem" style="list-style-type: disc">Because maintaining dependable boundaries between threads and their states is so difficult, ensuring that a library (for Node, it would be a <em>package</em> or <em>module</em>) is thread safe occupies a great deal of the developer's time. Can I know that this library will not destroy some part of my application? Guaranteeing thread safety requires great diligence on the part of a library's developer, and these guarantees may be conditional: for example, a library may be thread safe when reading—but not when writing.</li></ul></div><p>We want the power of parallelization provided by threads but could do without the mind-bending world of semaphores and mutexes. In the Unix world, there is a concept that is sometimes<a id="id25" class="indexterm"/> referred to as the <strong>Rule of Simplicity</strong>: <em>Developers should design for simplicity by looking for ways to break up program systems into small, straightforward cooperating pieces. This rule aims to discourage developers' affection for writing 'intricate and beautiful complexities' that are, in reality, bug-prone programs</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Concurrency and processes</h2></div></div></div><p>Parallelism within a single process is a complicated illusion that is achieved deep within mind-bendingly complex chipsets and other hardware. The question is really about appearances—about how the activity of the system appears to, and can be programmed by, a developer. Threads <a id="id26" class="indexterm"/>offer hyper-efficient parallelism, but make concurrency difficult to reason about.</p><p>Rather than <a id="id27" class="indexterm"/>have the developer struggle with this complexity, Node<a id="id28" class="indexterm"/> itself manages I/O threads, simplifying this complexity by demanding only that control flow be managed between events. There is a need to <em>micromanage</em> I/O threading; one simply designs an application to establish data availability points (callbacks) and the instructions to be executed once the said data is available. A single stream of instructions that explicitly takes and relinquishes control in a clear, collision-free, and predictable way aids development:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instead of concerning themselves with arbitrary locking and other collisions, developers can focus on constructing execution chains, the ordering of which is predictable.</li><li class="listitem" style="list-style-type: disc">Parallelization is accomplished through the use of multiple processes, each with an individual and distinct memory space, due to which communication between processes remains uncomplicated—via the <em>Rule of Simplicity</em>, we achieve not only simple and bug-free components, but also easier interoperability.</li><li class="listitem" style="list-style-type: disc">The state is not (arbitrarily) shared between individual Node processes. A single process is automatically protected from surprise visits from other processes bent on memory reallocation or resource monopolization. Communication is through clear channels using basic protocols, all of which make it very hard to write programs that make unpredictable changes across processes.</li><li class="listitem" style="list-style-type: disc">Thread safety is one less concern for developers to waste time worrying about. Because single-threaded concurrency obviates the collisions present in multithreaded concurrency, development can proceed more quickly and on surer ground.</li></ul></div><p>A single thread describing asynchronous control flow efficiently managed by an event loop brings stability, maintainability, readability, and resilience to Node programs. The big news is that Node continues to deliver the speed and power of multithreading to its developers—the brilliance of Node's design makes such power transparent, reflecting one part of Node's<a id="id29" class="indexterm"/> stated aim of bringing the most power<a id="id30" class="indexterm"/> to<a id="id31" class="indexterm"/> the most people with the least difficulty.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Events</h2></div></div></div><p>Many JavaScript extensions in Node emit events. These are instances of <code class="literal">events.EventEmitter</code>. Any object can extend <code class="literal">EventEmitter</code>, which gives the developer an <a id="id32" class="indexterm"/>elegant toolkit to build tight, asynchronous interfaces to their <a id="id33" class="indexterm"/>object methods.</p><p>Work through this example demonstrating how to set an <code class="literal">EventEmitter</code> object as the prototype of a function constructor. As each constructed instance now has the <code class="literal">EventEmitter</code> object exposed to its prototype chain, <code class="literal">this </code>provides a natural reference to the event's <strong>Application Programming Interface</strong> (<strong>API</strong>). The <code class="literal">counter</code> instance methods <a id="id34" class="indexterm"/>can, therefore, emit events, and these can be listened for. Here, we emit the latest count whenever the <code class="literal">counter.increment</code> method is called and bind a callback to the "incremented" event, which simply prints the current counter value to the command line:</p><div><pre class="programlisting">var EventEmitter = require('events').EventEmitter;
var util = require('util');

var Counter = function(init) {
  this.increment = function() {
    init++;
    this.emit('incremented', init);
  }
}

util.inherits(Counter, EventEmitter);

var counter = new Counter(10);

var callback = function(count) {
  console.log(count);
}
counter.addListener('incremented', callback);

counter.increment(); // 11
counter.increment(); // 12</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>To remove <a id="id35" class="indexterm"/>the event listeners bound to <code class="literal">counter</code>, use <code class="literal">counter.removeListener('incremented', callback)</code>.</p><p>
<code class="literal">EventEmitter</code>, as an <a id="id36" class="indexterm"/>extensible object, adds to the expressiveness of JavaScript. For example, it allows I/O data streams to be handled in an event-oriented manner in keeping with Node's principle of asynchronous, nonblocking programming:</p><div><pre class="programlisting">var stream = require('stream');
var Readable = stream.Readable;
var util = require('util');

var Reader = function() {
  Readable.call(this);
  this.counter = 0;
}

util.inherits(Reader, Readable);

Reader.prototype._read = function() {
  if(++this.counter &gt; 10) {
    return this.push(null);
  }
  this.push(this.counter.toString());
};

// When a #data event occurs, display the chunk.
//
var reader = new Reader();
reader.setEncoding('utf8');
reader.on('data', function(chunk) {
  console.log(chunk);
});
reader.on('end', function() {
  console.log('--finished--');
});</pre></div><p>In this <a id="id37" class="indexterm"/>program, we have a <code class="literal">Readable</code> stream pushing out a set of numbers—with <a id="id38" class="indexterm"/>listeners on that stream's data event catching numbers as they are emitted and logging them—and finishing with a message when the stream has ended. It is plain that the listener is called once per number, which means that running this set did not block the event loop. Because Node's event loop need only commit resources to handling callbacks, many other instructions can be processed in the downtime of each event.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The event loop</h2></div></div></div><p>The code <a id="id39" class="indexterm"/>seen in non-networked software is often synchronous<a id="id40" class="indexterm"/> or blocking. I/O operations in the following pseudo-code are also blocking:</p><div><pre class="programlisting">variable = produceAValue()
print variable
// some value is output when #produceAValue is finished.</pre></div><p>The following iterator will read one file at a time, dump its contents, and then read the next until it is done:</p><div><pre class="programlisting">fileNames = ['a','b','c']
while(filename = fileNames.shift()) {
  fileContents = File.read(filename)
  print fileContents
}
//	&gt; a
//	&gt; b
//	&gt; c</pre></div><p>This is a fine model for many cases. However, what if these files are very large? If each takes 1 second to fetch, all will take 3 seconds to fetch. The retrieval on one file is always waiting on another retrieval to finish, which is inefficient and slow. Using Node, we can initiate file reads on all files simultaneously:</p><div><pre class="programlisting">var fs = require('fs');
var fileNames = ['a','b','c'];
fileNames.forEach(function(filename) {
  fs.readFile(filename, {encoding:'utf8'}, function(err, content) {
    console.log(content);
  });
});
//	&gt; b
//	&gt; a
//	&gt; c</pre></div><p>The Node version will read all three files at once, each call to <code class="literal">fs.readFile</code> returning its result at some <a id="id41" class="indexterm"/>unknowable point in the future. This is why we can't always <a id="id42" class="indexterm"/>expect the files to be returned in the order they were arrayed. We can expect that all three will be returned in roughly the time it took for one to be retrieved—something less than 3 seconds. We have traded a predictable execution order for speed, and, as with threads, achieving synchronization in concurrent environments requires extra work. How do we manage and describe unpredictable data events so that our code is both easy to understand <em>and</em> efficient?</p><p>The key design choice made by Node's designers was the implementation of an event loop as a concurrency manager. The following description of event-driven programming (taken from <a class="ulink" href="http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html">http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html</a>) clearly not only describes the event-driven paradigm, but also introduces <a id="id43" class="indexterm"/>us to how events are handled in Node and how JavaScript is an ideal language for such a paradigm:</p><div><blockquote class="blockquote"><p><em>"In computer programming, event-driven programming or event-based programming is a programming paradigm in which the flow of the program is determined by events—that is, sensor outputs or user actions (mouse clicks, key presses) or messages from other programs or threads.</em></p><p><em>Event-driven programming can also be defined as an application architecture technique in which the application has a main loop that is clearly divided down to two sections: the first is event selection (or event detection), and the second is event handling […]</em></p><p><em>Event-driven programs can be written in any language although the task is easier in languages that provide high-level abstractions, such as closures."</em></p></blockquote></div><a id="id44" class="indexterm"/><p>As we've seen in the preceding quote, single-threaded execution environments block and can, therefore, run slowly. V8 provides a single thread of execution for JavaScript programs.</p><p>How can this single thread be made more efficient?</p><p>Node makes a single thread more efficient by delegating many blocking operations to OS subsystems to process, bothering the main V8 thread only when there is data available for use. The<a id="id45" class="indexterm"/> main thread (your executing Node program) expresses interest in some data (such as via <code class="literal">fs.readFile</code>) by passing a callback and is notified when that data is available. Until that data arrives, no further burden is placed on V8's main JavaScript thread. How? Node <a id="id46" class="indexterm"/>delegates I/O work to <strong>libuv</strong>, as <a id="id47" class="indexterm"/>quoted at <a class="ulink" href="http://nikhilm.github.io/uvbook/basics.html#event-loops">http://nikhilm.github.io/uvbook/basics.html#event-loops</a>:</p><div><blockquote class="blockquote"><p><em>"In event-driven programming, an application expresses interest in certain events and responds to them when they occur. The responsibility of gathering events from the operating system or monitoring other sources of events is handled by libuv, and the user can register callbacks to be invoked when an event occurs."</em></p></blockquote></div><p>
<em>The user</em> in the <a id="id48" class="indexterm"/>preceding quote is the Node process executing a JavaScript program. <em>Callbacks</em> are JavaScript functions, and managing callback invocation for the user is accomplished by Node's event loop. Node manages a queue of I/O requests populated by libuv, which is responsible for polling the OS for I/O data events and handing off the results to JavaScript callbacks.</p><p>Consider the following code:</p><div><pre class="programlisting">var fs = require('fs');
fs.readFile('foo.js', {encoding:'utf8'}, function(err, fileContents) {
  console.log('Then the contents are available', fileContents);
});
console.log('This happens first');</pre></div><p>This program will result in the following output:</p><div><pre class="programlisting">
<strong>&gt; This happens first</strong>
<strong>&gt; Then the contents are available, [file contents shown]</strong>
</pre></div><p>Here's what Node does when executing this program:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Node loads the <code class="literal">fs </code>module. This provides access to <code class="literal">fs.binding</code>, which is <em>a static type map defined in src/node.cc that provides glue between C++ and JS code</em>. (<a class="ulink" href="https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ">https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ</a>).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">fs.readFile</code> method is passed instructions and a JavaScript callback. Through <code class="literal">fs.binding</code>, libuv is notified of the file read request and is passed a specially prepared version of the callback sent by the original program.</li><li class="listitem" style="list-style-type: disc">libuv invokes the OS-level functions necessary to read a file within its own thread pool.</li><li class="listitem" style="list-style-type: disc">The JavaScript program continues, printing <code class="literal">This happens first</code>. Because there is a callback outstanding, the event loop continues to spin, waiting for that callback to resolve.</li><li class="listitem" style="list-style-type: disc">When the file descriptor has been fully read by the OS, libuv (via internal mechanisms) is informed and the callback passed to libuv is invoked, which essentially prepares the original JavaScript callback for re-entrance into the main (V8) thread.</li><li class="listitem" style="list-style-type: disc">The original JavaScript callback is pushed onto the event loop queue and is invoked on the next tick of the loop.</li><li class="listitem" style="list-style-type: disc">The file contents are printed to the console.</li><li class="listitem" style="list-style-type: disc">As there are no further callbacks in flight, the process exits.</li></ul></div><p>Here, we<a id="id49" class="indexterm"/> see the key ideas that Node implements to achieve fast, manageable, and <a id="id50" class="indexterm"/>scalable I/O. If, for example, there were 10 read calls made for <code class="literal">'foo.js'</code> in the preceding program, the execution time would, nevertheless, remain roughly the same. Each call would have been made <em>in parallel</em> in its <em>own thread </em>within the libuv thread pool. Even though we wrote our code "in JavaScript", we are actually deploying a very efficient multithreaded execution engine <em>while avoiding the difficulties of thread management</em>.</p><p>Let's close with more details on how exactly libuv results are returned into the main thread's event loop.</p><p>When data becomes available on a socket or other stream interface, we cannot simply execute our callback immediately. JavaScript is single threaded, so results must be synchronized. We can't suddenly change the state in the middle of an event loop tick—this would create some of the classic multithreaded application problems of race conditions, memory access conflicts, and so on.</p><p>Upon entering <a id="id51" class="indexterm"/>an event loop, Node (in effect) makes a copy of the current instruction queue (also known as <strong>stack</strong>), empties the original queue, and executes its copy. The processing of this instruction queue is referred to as a <em>tick</em>. If libuv, asynchronously, receives results while the chain of instructions copied at the start of this tick are being processed on the single main thread (V8), these results (wrapped as callbacks) are queued. Once the current queue is emptied and its last instruction has completed, the queue is again checked for instructions to execute <em>on the next tick</em>. This pattern of checking and executing the queue will repeat (loop) until the queue is emptied, and no further <a id="id52" class="indexterm"/>data events are expected, at which point the Node process <a id="id53" class="indexterm"/>exits.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>This discussion at <a class="ulink" href="https://github.com/joyent/node/issues/5798">https://github.com/joyent/node/issues/5798</a> among some core Node developers about the <code class="literal">process.nextTick</code> and <code class="literal">setImmediate</code> implementations offers very precise information on how the event loop operates.</p></div></div><p>The following are the sorts of I/O events fed into the queue:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Execution blocks</strong>: These are blocks of JavaScript code comprising the Node program; they <a id="id54" class="indexterm"/>could be expressions, loops, functions, and so on. This includes <code class="literal">EventEmitter</code> events emitted within the current execution context.</li><li class="listitem" style="list-style-type: disc"><strong>Timers</strong>: These <a id="id55" class="indexterm"/>are callbacks deferred to a time in the future specified in milliseconds, such as <code class="literal">setTimeout</code> and <code class="literal">setInterval</code>.</li><li class="listitem" style="list-style-type: disc"><strong>I/O</strong>: These<a id="id56" class="indexterm"/> are prepared callbacks returned to the main thread after being delegated to Node's managed thread pool, such as filesystem calls and network listeners.</li><li class="listitem" style="list-style-type: disc"><strong>Deferred execution blocks</strong>: These are mainly the functions slotted on the stack<a id="id57" class="indexterm"/> according to the rules of <code class="literal">setImmediate</code> and <code class="literal">process.nextTick</code>.</li></ul></div><p>There are two important things to remember:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You don't start <a id="id58" class="indexterm"/>and/or stop the event loop. The event loop starts as soon as a process starts and ends when no further callbacks remain to be performed. The event loop may, therefore, run forever.</li><li class="listitem" style="list-style-type: disc">The event loop executes on a single thread but delegates I/O operations to libuv, which <a id="id59" class="indexterm"/>manages a thread pool that parallelizes these operations, notifying the event loop when results are available. An easy-to-reason-about single-threaded programming model is reinforced with the efficiency of multithreading.</li></ul></div><p>To learn more about how Node is bound to libuv and other core libraries, parse through the <code class="literal">fs</code> module<a id="id60" class="indexterm"/> code at <a class="ulink" href="https://github.com/joyent/node/blob/master/lib/fs.js">https://github.com/joyent/node/blob/master/lib/fs.js</a>. Compare the <code class="literal">fs.read</code> and the <code class="literal">fs.readSync</code> methods to observe the difference between how synchronous and asynchronous actions are implemented—note the <code class="literal">wrapper</code> callback that is passed to the native <code class="literal">binding.read</code> method in <code class="literal">fs.read</code>.</p><p>To take <a id="id61" class="indexterm"/>an even deeper dive into the very heart of Node's design, including<a id="id62" class="indexterm"/> the queue implementation, read through the Node source at <a class="ulink" href="https://github.com/joyent/node/tree/master/src">https://github.com/joyent/node/tree/master/src</a>. Follow <code class="literal">MakeCallback</code> within <code class="literal">fs_event_wrap.cc</code> and <code class="literal">node.cc</code>. Investigate the <code class="literal">req_wrap</code> class, a wrapper for the V8 engine, deployed in <code class="literal">node_file.cc</code> and elsewhere and defined in <code class="literal">req_wrap.h</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The implications of Node's design on system architects</h1></div></div></div><p>Node is a <a id="id63" class="indexterm"/>new technology. At the time of writing this, it has yet to reach its 1.0 version. Security flaws have been found and fixed. Memory leaks have been found and fixed. Eran Hammer, mentioned at the beginning of this chapter, and his entire team at Walmart Labs actively contribute to the Node codebase—in particular when they find flaws! This is true of many other large companies committed to Node, such as PayPal.</p><p>If you have chosen Node, and your application has grown to such a size that you feel you need to read a book on how to deploy Node, you have the opportunity to not only benefit from the community, but have a part, perhaps, in literally designing aspects of the environment based on your particular needs. Node is open source, and you can submit pull requests.</p><p>In addition to events, there are two key design aspects that are important to understand if you are going to do advanced Node work: build your systems out of small parts and use evented<a id="id64" class="indexterm"/> streams when piping data between them.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Building large systems out of small systems</h2></div></div></div><p>In his <a id="id65" class="indexterm"/>book, <em>The Art of Unix Programming</em>, Eric Raymond proposed <a id="id66" class="indexterm"/>the <strong>Rule of Modularity</strong>:</p><div><blockquote class="blockquote"><p><em>"Developers should build a program out of simple parts connected by well-defined interfaces, so problems are local, and parts of the program can be replaced in future versions to support new features. This rule aims to save time on debugging complex code that is complex, long, and unreadable."</em></p></blockquote></div><p>This idea of building complex systems out of "small pieces, loosely joined" is seen in management theory, theories of government, manufacturing, and many other contexts. In terms of software development, it advises developers to contribute only the simplest, most useful component necessary within a larger system. Large systems are hard to reason about, especially if the boundaries of their components are fuzzy.</p><p>One of the primary difficulties when constructing scalable JavaScript programs is the lack of a standard interface to assemble a coherent program out of many smaller ones. For example, a typical web application might load dependencies using a sequence of <code class="literal">&lt;script&gt;</code> tags in <a id="id67" class="indexterm"/>the <code class="literal">&lt;head&gt;</code> section of a <strong>HyperText Markup Language</strong> (<strong>HTML</strong>) document:</p><div><pre class="programlisting">&lt;head&gt;
  &lt;script src="img/fileA.js"&gt;&lt;/script&gt;
  &lt;script src="img/fileB.js"&gt;&lt;/script&gt;
&lt;/head&gt;</pre></div><p>There are many problems with this sort of system:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All potential dependencies must be declared prior to their being needed—dynamic inclusion requires complicated <em>hacks</em>.</li><li class="listitem" style="list-style-type: disc">The introduced scripts are not forcibly encapsulated—nothing stops both files from writing to the same global object. Namespaces can easily collide, which makes arbitrary injection dangerous.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fileA</code> cannot address <code class="literal">fileB</code> as a collection—an addressable context, such as <code class="literal">fileB.method</code>, isn't available.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">&lt;script&gt;</code> method itself isn't systematic, precluding the design of useful module services, such as dependency awareness and version control.</li><li class="listitem" style="list-style-type: disc">Scripts cannot be easily removed or overridden.</li><li class="listitem" style="list-style-type: disc">Because of these dangers and difficulties, sharing is not effortless, thus diminishing opportunities for collaboration in an open ecosystem.</li></ul></div><p>Ambivalently inserting unpredictable code fragments into an application frustrates attempts to predictably shape functionality. What is needed is a standard way to load and share discreet program modules.</p><p>Accordingly, Node introduced the concept of the <strong>package</strong>, following the CommonJS specification. A <a id="id68" class="indexterm"/>package is a collection of program files bundled with a manifest file describing the collection. Dependencies, authorship, purpose, structure, and other important metadata is exposed in a standard way. This encourages the construction of large<a id="id69" class="indexterm"/> systems from many small, interdependent systems. Perhaps, even more importantly, it encourages sharing:</p><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"What I'm describing here is not a technical problem. It's a matter of people getting together and making a decision to step forward and start building up something bigger and cooler together."</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Kevin Dangoor, creator of CommonJS</em></td></tr></table></div><p>In many ways, the success of Node is due to the growth in the number and quality of packages available to the developer community that are distributed via Node's package management<a id="id70" class="indexterm"/> system, <strong>npm</strong>. This system has done much to help make JavaScript a viable, professional option for systems programming.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>A good <a id="id71" class="indexterm"/>introduction to npm for anyone new to Node can be found at: <a class="ulink" href="https://www.npmjs.org/doc/developers.html">https://www.npmjs.org/doc/developers.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Streams</h2></div></div></div><p>In his<a id="id72" class="indexterm"/> book, <em>The C++ Programming Language, Third Edition</em>, Bjarne <a id="id73" class="indexterm"/>Stoustrup states:</p><div><blockquote class="blockquote"><p><em>"Designing and implementing a general input/output facility for a programming language is notoriously difficult. […] An I/O facility should be easy, convenient, and safe to use; efficient and flexible; and, above all, complete."</em></p></blockquote></div><p>It shouldn't<a id="id74" class="indexterm"/> surprise anyone that a design team focused on<a id="id75" class="indexterm"/> providing efficient and easy I/O has delivered such a facility through Node. Through a symmetrical and simple interface, which handles data buffers and stream events so that the implementer does not have to, Node's <code class="literal">Stream</code> module is the preferred way to manage asynchronous data streams for both internal modules and, hopefully, for the modules that developers will create.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>An excellent <a id="id76" class="indexterm"/>tutorial on the <code class="literal">Stream</code> module can be found at <a class="ulink" href="https://github.com/substack/stream-handbook">https://github.com/substack/stream-handbook</a>. Also, the Node documentation is comprehensive at <a class="ulink" href="http://nodejs.org/api/stream.html">http://nodejs.org/api/stream.html</a>.</p></div></div><p>A stream in Node is simply a sequence of bytes or, if you like, a sequence of characters. At any time, a stream contains a buffer of bytes, and this buffer has a length of zero or more.</p><p>Because each character in a stream is well defined, and because every type of digital data can be expressed in bytes, any part of a stream can be redirected, or <em>piped</em>, to any other stream, different chunks of the stream can be sent to different handlers. In this way, stream input and output interfaces are both flexible and predictable and can be easily coupled.</p><p>In addition to events, Node is distinctive for its comprehensive use of streams. Continuing the idea of composing applications out of many small processes emitting events or reacting to events, several Node I/O modules and features are implemented as streams. Network sockets, file readers and writers, stdin and stdout, Zlib, and so on, are all data producers and/or consumers that are easily connected through the abstract <code class="literal">Stream</code> interface. Those familiar with Unix pipes will see some similarities.</p><p>Five distinct base classes are exposed via the abstract <code class="literal">Stream</code> interface: <code class="literal">Readable</code>, <code class="literal">Writable</code>, <code class="literal">Duplex</code>, <code class="literal">Transform</code>, and <code class="literal">PassThrough</code>. Each base class inherits from <code class="literal">EventEmitter</code>, which we know to be an interface to which event listeners and emitters can be bound. Streams in Node are evented streams, and sending data between processes is commonly done using streams. Because streams can be easily chained and otherwise combined, they are fundamental tools for the Node developer.</p><p>It is recommended <a id="id77" class="indexterm"/>that you develop a clear understanding of what <a id="id78" class="indexterm"/>streams are and how they are implemented in Node before going further as we will use streams extensively throughout this book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using full-stack JavaScript to maximum effect</h1></div></div></div><p>JavaScript has<a id="id79" class="indexterm"/> become a full-stack language. A native JavaScript runtime exists in all browsers. V8, the JavaScript interpreter used by Node, is the same engine <a id="id80" class="indexterm"/>powering Google's Chrome browser. And the language has gone even further than covering both the client and server layers of the software stack. JavaScript is used to query the CouchDB database, do map/reduce with MongoDB, and find data in ElasticSearch collections. The wildly popular <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) data format simply represents data as a JavaScript object.</p><p>When <a id="id81" class="indexterm"/>different languages are used within the same application, the cost of <em>context switching</em> goes up. If a system is composed of parts described in different languages, the system architecture becomes more difficult to describe, understand, and extend. If different parts of a system <em>speak</em> differently, every cross-dialect conversation will require expensive translation.</p><p>Inefficiencies in comprehension lead to larger costs and more brittle systems. The members of the engineering team for this system must each be fluent in these many languages or be grouped by different skill sets; engineers are expensive to find and/or train. When the inner workings of significant parts of a system become opaque to all but a few engineers, it is likely that cross-team collaboration will decrease, making product upgrades and additions more difficult and likely leading to more errors.</p><p>What new opportunities open up when these difficulties are reduced or eliminated?</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Hot code</h2></div></div></div><p>Because your <a id="id82" class="indexterm"/>clients and servers will speak the same language, each can pass code to be natively executed on the other. If you are building a web application, this opens up very interesting (and unique) opportunities.</p><p>For example, consider an application that allows one client to make changes to another's environment. This tool allows a software developer to make changes to the JavaScript powering a website and allows their clients to see those changes in real time in their browsers. What this application must do is transform live code in many browsers so that it reflects <a id="id83" class="indexterm"/>changes. One way to do this would be to capture a change set into a transform function, pass that function across to all connected clients, and have that function executed in their local environment, updating it to reflect the <em>canonical</em> view. One application evolves, it emits a <em>genetic</em> update in the code of JavaScript, and the rest of its species similarly evolves. We will use one such technology in <a class="link" href="ch07.html" title="Chapter 7. Deploying and Maintaining">Chapter 7</a>, <em>Deploying and Maintaining</em>.</p><p>Since Node shares the same JavaScript code base, a Node server, on its own initiative, can take this action. The network itself can broadcast code for its clients to execute. Similarly, clients can send code to the server for execution. It is easy to see how this allows hot code pushes, where a Node process sends a unique packet of raw JavaScript to specific clients for execution.</p><p>When <strong>Remote Procedure Calls</strong> (<strong>RPC</strong>) no longer require a broker layer to translate between <a id="id84" class="indexterm"/>communicating contexts, code can exist anywhere in the network for as long or as brief a period as necessary and can execute in multiple contexts, which are chosen for reasons of load balancing, data awareness, computational power, geographic precision, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Browserify</h2></div></div></div><p>JavaScript is the <a id="id85" class="indexterm"/>language common to Node and the browser. However, Node significantly extends the JavaScript language, adding many commands and <a id="id86" class="indexterm"/>other constructs that are not available to the client-side developer. For example, there is no equivalent of the core Node <code class="literal">Stream</code> module in JavaScript.</p><p>Additionally, the npm repository is rapidly growing, and, at the time of writing, contains more than 80,000 Node packages. Many of these packages are equally useful on the client as well as within Node. The spread of JavaScript to the server has, in effect, created two cooperating threads producing enterprise-grade JavaScript libraries and modules.</p><p>
<strong>Browserify</strong> was developed to make it easy to share <strong>npm</strong> modules and core Node modules seamlessly with the client. Once a package has been <em>browserified</em>, it is easily imported into a browser environment using the standard <code class="literal">&lt;script&gt;</code> tag. Installing Browserify is simple:</p><div><pre class="programlisting">
<strong>npm install -g browserify</strong>
</pre></div><p>Let's build an example. Create a file, <code class="literal">math.js</code>, written as you would write an npm module:</p><div><pre class="programlisting">module.exports = function() {
  this.add = function(a, b) {
    return a + b;
  }
  this.subtract = function(a, b) {
    return a - b;
  }
};</pre></div><p>Next, create a program file, <code class="literal">add.js</code>, that uses this module:</p><div><pre class="programlisting">var Math = require('./math.js');
var math = new Math;

console.log(math.add(1,3)); // 4</pre></div><p>Executing<a id="id87" class="indexterm"/> this program using Node on the command line (<code class="literal">&gt; node add.js</code> ) will result in <code class="literal">4</code> being printed to your terminal. What if we wanted to use<a id="id88" class="indexterm"/> our math module in the browser? Client-side JavaScript doesn't have a <code class="literal">require</code> statement, so we browserify it:</p><div><pre class="programlisting">
<strong>browserify math.js -o bundle.js</strong>
</pre></div><p>Browserify walks through your code, finding <code class="literal">require</code> statements and automatically bundling those dependencies (and the dependencies of those dependencies) into one file that you load into your client application:</p><div><pre class="programlisting">&lt;script src="img/bundle.js"&gt;&lt;/script&gt;</pre></div><p>As an added bonus, this bundle automatically introduces some useful Node globals to your browser environment: <code class="literal">__filename</code>, <code class="literal">__dirname</code>, <code class="literal">process</code>, <code class="literal">Buffer</code>, and <code class="literal">global</code>. This means you have, for example, <code class="literal">process.nextTick</code> available in the browser.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>The creator of Browserify, James Halliday, is a prolific contributor to the Node community. Visit him at <a class="ulink" href="https://github.com/substack">https://github.com/substack</a>. Also, there exists an<a id="id89" class="indexterm"/> online service for testing out browserified npm modules at http://requirebin.com. The full documentation can be found at <a class="ulink" href="https://github.com/substack/node-browserify#usage">https://github.com/substack/node-browserify#usage</a>.</p><p>Another <a id="id90" class="indexterm"/>exciting project that, like Browserify, leverages Node to enhance the JavaScript available to browser-based <a id="id91" class="indexterm"/>JavaScript <a id="id92" class="indexterm"/>is <strong>Component</strong>. The authors describe it this way: <em>Component is currently a stopgap for ES6 modules and Web Components. When all modern browsers start supporting these features, Component will begin focusing more on semantic versioning and server-side bundling as browsers would be able to handle the rest</em>. The project is still <a id="id93" class="indexterm"/>in flux but worth a look. Here's the link: <a class="ulink" href="https://github.com/componentjs/guide">https://github.com/componentjs/guide</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, we went on a whirlwind tour of Node. You learned something about why it is designed the way it is and why this event-driven environment is a good solution to modern problems in networked software. Having explained the event loop and the related ideas around concurrency and parallelism, we talked a bit about the Node philosophy of composing software from <em>small pieces loosely joined</em>. You learned about the special advantages that full-stack JavaScript provides and explored new possibilities of applications made possible because of them.</p><p>You now have a good understanding of the kind of applications we will be deploying, and this understanding will help you see the unique concerns and considerations faced when building and maintaining Node applications. In the next chapter, we'll dive right in with building servers with Node, options for hosting these applications, and ideas around building, packaging, and distributing them.</p></div></body></html>