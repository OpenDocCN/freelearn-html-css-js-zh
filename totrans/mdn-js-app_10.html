<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Building User Interfaces Using React</h1></div></div></div><p>Writing code for reactive UI is a difficult task, as writing code to manipulate the DOM using JavaScript whenever the application state changes is difficult and it makes understanding the application difficult. Therefore, the MVC architecture was introduced, where we define the UI and application state separately, and the UI is updated automatically as the application state changes. MVC framework views have been concentrating on making the writing of code for reactive UIs easier but not increasing rendering performance, reusability, and ease of debugging. This is what React aims to solve. It not only makes writing code for reactive UI easier but also takes care of rendering performance, reusability, and ease of debugging.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What React is</li><li class="listitem" style="list-style-type: disc">Virtual DOM technology</li><li class="listitem" style="list-style-type: disc">Component-based UI development using React</li><li class="listitem" style="list-style-type: disc">One-way dataflow programming</li><li class="listitem" style="list-style-type: disc">Using JSX to write React code</li><li class="listitem" style="list-style-type: disc">Using React on the server side to build isomorphic apps</li><li class="listitem" style="list-style-type: disc">Many other topics to help us get a good hold on React</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Introducing React</h1></div></div></div><p>React is <a id="id420" class="indexterm"/>a JavaScript library for building reactive UIs. We usually use jQuery or pure JavaScript to manipulate a reactive UI whenever the application state changes, which makes it difficult to reuse and understand the code. Instead, we can use React, which lets us declare how the UI behaves based on the application state, and it automatically updates the UI whenever the application state changes. There are lots of libraries and technologies, such as web components and templating engines, that aim to make the building of UIs easier, but React stands out from the crowd as it makes it easy to build reusable and high-performance reactive UIs.</p><p>React is <a id="id421" class="indexterm"/>also used as a view library because it is exactly what a view library is supposed to be. A view holds the UI of the application and defines how the UI changes based on the application state, that is, how the application state is displayed. As it's just a view library, it doesn't tell us how to manage, access, and mutate the application state. It can be used as the view layer in any kind of architecture and framework.</p><p>Remember that React is a library and not a framework such as Angular or Ember. Thus, React can be used with Angular to make Angular views better in terms of performance and reusability.</p><p>For example, there is an AngularJS module named ngReact that lets React be used as a view in AngularJS.</p><p>Even the Flux architecture uses React as its view. We will learn more about Flux in the next chapter.</p><p>React is always used with a framework as it only defines the UI but doesn't tell us how to manage the application logic and state, just like a template library or web component is always used with a framework.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>
<strong>Is React a templating engine?</strong>
</p><p>React is not a templating engine. The views of most of the popular MVC frameworks are of a template system. In a templating system, we write HTML with a template language for the UI, and it is processed in order to generate the final HTML. For example, an AngularJS view is a template system that's composed of directives, expressions, and so on. React is not a templating engine because we don't write HTML. Instead, we define the structure of the DOM using JavaScript. React can also do much more than what a templating engine can do. It can also capture user events in the UI. This is how it differs from traditional views. It's just that React works in a different way than a template system.</p></div></div><p>When building user interfaces using React, we don't write any HTML to build the UI like when using other frameworks and libraries; instead, we declare the DOM structure using JavaScript only. This programming style is what makes React able to implement various algorithms and technologies to achieve high rendering performance and reusability.</p><p>Before we get further into learning React, let's first set up a project to use it.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Setting up a basic React project</h2></div></div></div><p>At the time <a id="id422" class="indexterm"/>of writing, the latest version of React was 0.14.7. This is the version this book uses. First, visit <a class="ulink" href="https://facebook.github.io/react/downloads.html">https://facebook.github.io/react/downloads.html</a> to download React. Here, you <a id="id423" class="indexterm"/>will find two types of React builds, namely, production and development builds. The difference between these two build is that the development build is uncompressed and includes extra warnings, whereas the production build is compressed, includes extra performance optimizations, and strips all errors.</p><p>You should use the development build when your application is in the development phase. Once your application is ready for deployment, you should change to the production build.</p><p>Again, you will find two types of production and development build: one with add-ons and the other without. We will use the development version without add-ons.</p><p>You will find CDN links as well as links to download and enqueue React manually. React is composed of two files: <code class="literal">react.js</code> and <code class="literal">react-dom.js</code>. Download both of them manually.</p><p>Create a folder named <code class="literal">react-demo</code> and place both the files in it. Then, create a file called <code class="literal">index.html</code> and put this code in it:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;React Demo&lt;/title&gt;

    &lt;script src="img/react.js"&gt;&lt;/script&gt;
    &lt;script src="img/react-dom.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;script&gt;
      //place React code here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Later on in this chapter, we will learn more about why React is composed of two files and not one. For now, just ignore this.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec65"/>Virtual DOM</h2></div></div></div><p>A browser <a id="id424" class="indexterm"/>interprets HTML and creates a DOM. A DOM is a tree-like structure that defines the structure of the page. The browser then renders the DOM on the page. The DOM API is what we use to manipulate the DOM. When we manipulate it, the browser re-renders the manipulated parts.</p><p>The problem is not with how the DOM works, but how we programmatically alter it. Manipulating nodes of a DOM requires expertise; otherwise, we could often end up re-rendering lots of nodes unnecessarily, which would result in poor rendering performance.</p><p>For example, imagine we have a large list of products in an e-commerce website. We also have a filter widget to filter the items. When we change the values in the filter widget, the list items are reloaded and the complete list is re-rendered, which requires a lot of manipulation to the DOM and can result in bad rendering performance. To get better performance, we can actually manipulate only specific parts of the list, such as product titles, image, and cost. But writing code for this is going to be hard.</p><p>Let's take another example. If you are using <code class="literal">ng-repeat</code> to display a list, then adding a new item to the list will cause the complete re-rending of the list. So, if Facebook or Instagram had used <code class="literal">ng-repeat</code>, then whenever we scrolled down, the whole set of posts would have been re-rendered. The solution to this problem is instead of using <code class="literal">ng-repeat</code>, which re-renders the whole list, we can append a new post to the end of the list using jQuery or pure JavaScript. But if you want to maintain the posts that are being displayed, then you will end up writing some more complex code.</p><p>Due to these kinds of problem, virtual DOM was introduced. Virtual DOM makes sure that anyone can write complex reactive UI code without worrying about performance. Virtual DOM is the secret that React implements to achieve rendering performance.</p><p>A virtual DOM is an abstract version of the real DOM, that is, a description of the real DOM. Virtual DOM elements are just JavaScript objects whereas real DOM elements are real UI elements. Virtual DOM is much faster as it's just a JavaScript data structure and manipulating it doesn't automatically re-render the UI. Earlier, I said that in React, you don't write any HTML but instead declare the structure of the DOM. Actually, you declare the structure of the virtual DOM, not the real DOM. React keeps the real DOM in sync with virtual DOM. Whenever the application state changes to update the UI, React uses complex algorithms to compare the real DOM with the virtual DOM and finds as few mutations as possible for the real DOM to sync with the virtual DOM. We will later see how these algorithms actually find the difference and mutate the real DOM. For example, if we have a list in the virtual DOM and we remove the list and add a new list with just an extra item, then, only the new item is rendered when synced with the real DOM, not the whole list.</p><p>Let's look at some example code to print <strong>Hello World</strong> using React. Inside the <code class="literal">index.html</code> body tag, place this code:</p><div><pre class="programlisting">&lt;div id="container1"&gt;&lt;/div&gt;</pre></div><p>We are going to display <strong>Hello World</strong> inside this <code class="literal">div</code> element. Place this code in the script tag of the <code class="literal">index.html</code> file to display <strong>Hello World</strong>: </p><div><pre class="programlisting">var helloBold = React.createElement("b", {}, "Hello");
var worldItalic = React.createElement("i", {}, " World");
var helloWorld = React.createElement("a", {href: "#"}, helloBold, worldItalic);

ReactDOM.render(helloWorld, document.getElementById("container1"));</pre></div><p>Here is how the code's output looks:</p><div><img src="img/B05154_10_01.jpg" alt="Virtual DOM"/></div><p>Let's <a id="id425" class="indexterm"/>understand how the code works.</p><p>
<code class="literal">React.createElement</code> is used to create an object of a <code class="literal">ReactElement</code> interface. A <code class="literal">ReactElement</code> object is a light, stateless, and virtual representation of a real DOM element, but it's not a real DOM element. It's a virtual DOM, basically. <code class="literal">ReactElement</code> and real DOM elements are of different interfaces. The first parameter of <code class="literal">React.createElement</code> can be an HTML tag name or an object of a <code class="literal">ReactClass</code> interface. We will learn more about <code class="literal">ReactClass</code> later on. The second argument is an object containing attributes of the HTML tag or properties of the <code class="literal">ReactClass</code> object. And then, we can pass an infinite number of arguments, which can be strings, <code class="literal">ReactElement</code> objects, or <code class="literal">ReactClass</code> objects. All the arguments after the second argument are treated as children of the <code class="literal">ReactElement</code> object that's going to be created. If the children are dynamically decided, then you can provide an array as the third argument.</p><p>Here, we created three <code class="literal">ReactElement</code> objects. <code class="literal">helloWorld</code> is an anchor tag with <code class="literal">helloBold</code> and <code class="literal">worldItalic</code> as its children. We assigned the <code class="literal">href</code> attribute of the anchor tag to <code class="literal">#</code>.</p><p>
<code class="literal">ReactDOM.render</code> is used to render <code class="literal">ReactElement</code> objects in the real DOM. <code class="literal">ReactDOM.render</code> takes a <code class="literal">ReactElement</code> object as first argument, and the second argument is the reference to the container element in the real DOM inside which we want to add to the <code class="literal">ReactElement</code>.</p><p>Here, we've rendered the anchor tag inside the container element.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>As a <code class="literal">ReactElement</code> object is stateless, we cannot assign any UI event handlers to the <code class="literal">properties</code> object. Also, directly mutating the properties passed to the <code class="literal">ReactElement</code> object will not have any effect, as React doesn't watch the properties directly.</p></div></div><p>In the beginning, it may feel as if <code class="literal">ReactElement</code> and real DOM elements are just created in <a id="id426" class="indexterm"/>different ways and their interface is the same, but this is not true. Here are a few differences:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instead of the <code class="literal">class</code> attribute, you need to use <code class="literal">className</code></li><li class="listitem" style="list-style-type: disc">Instead of the <code class="literal">for</code> attribute, you need to use the <code class="literal">htmlFor</code> attribute</li><li class="listitem" style="list-style-type: disc">The <code class="literal">style</code> attribute cannot be a string; it has to be a object</li></ul></div><p>There are many more. We will explore them as we go deeper.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec66"/>Components</h2></div></div></div><p>You can use <a id="id427" class="indexterm"/>React using only <code class="literal">ReactElement</code> objects, but to take advantage of React, you have to use React components. <code class="literal">ReactElement</code> objects are stateless and immutable and therefore useless for building reactive UIs. Also, they don't provide a structured mechanism for UI reusability.</p><p>A React component is a reusable custom tag that is mutable and encapsulated with an embedded state, that is, changes to the state or properties will mutate the UI. For example, we can have a component named <code class="literal">clock</code> that takes the current time as an attribute and displays a clock with the passed time. Another exchange could be a Bitcoin price component that displays Bitcoin prices in real time.</p><p>A component state is internal to the component. It's created and mutated inside the component. However, the properties of a component cannot be mutated inside the component; rather, they can be mutated by the code that created the component instance.</p><p>You can break your complete UI into components—this is the style of coding that's recommended when building a UI using react. You can use components inside components as well. Before we get further into components, let's rewrite the previous <strong>Hello World</strong> code using components.</p><p>Inside the <code class="literal">index.html</code> body tag, place this code:</p><div><pre class="programlisting">&lt;div id="container1"&gt;&lt;/div&gt;</pre></div><p>We are going to display <strong>Hello World</strong> inside this <code class="literal">div</code> element. Place this code in the <code class="literal">script</code> tag of the <code class="literal">index.html</code> file to display <strong>Hello World</strong>:</p><div><pre class="programlisting">var anchorWithBoldItalic = React.createClass({
  render: function() {
    return React.createElement(
      "a", 
      {href: this.props.href}, 
      React.createElement("b", {}, this.props.boldText), 
      React.createElement("i", {}, this.props.italicText)
    );
  }
});

var HelloWorld = React.createElement(anchorWithBoldItalic, {href: "#", boldText: "Hello", italicText: " World" });

ReactDOM.render(HelloWorld, document.getElementById("container2"));</pre></div><p>Here <a id="id428" class="indexterm"/>is the output of the previous code:</p><div><img src="img/B05154_10_02.jpg" alt="Components"/></div><p>Here is how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">A component is created using the <code class="literal">React.createClass</code> function. This function takes an object, and the object must have a <code class="literal">render</code> property assigned to a function that returns a <code class="literal">ReactElement</code> object. The <code class="literal">ReactElement</code> object returned by the <code class="literal">render</code> method is said to be the content of the component, that is, it states how the tag is rendered. Whenever we try to display the tag, the contents of the tag are displayed in place.</li><li class="listitem"><code class="literal">React.createClass</code> returns a component. To use the component, we need to create instances of it. Like <code class="literal">React.createElement</code> is used to create a <code class="literal">ReactElement</code> object for an HTML tag, it can also create a <code class="literal">ReactElement</code> object for a component. So, <code class="literal">React.createElement</code> is used to create instances of a component. <code class="literal">this.props</code> is used inside the component to access its properties.</li><li class="listitem">Here, we created a component called <code class="literal">anchorWithBoldItalic</code>, which is an anchor element with some text displayed as bold and some displayed as italic.</li><li class="listitem">Then, we created a <code class="literal">ReactElement</code> object for our component and finally rendered it using <code class="literal">ReactDOM.render</code>.</li></ol></div><div><div><h3 class="title"><a id="note40"/>Note</h3><p>Remember that mutating properties after a component instance has been created will re-render the component.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec67"/>One-way data binding</h2></div></div></div><p>In the previous <a id="id429" class="indexterm"/>subsection, I stated that a component has an enclosing nature. Whenever we make changes to the state, the component is rendered. Components also let you register UI event handlers, and you can mutate the state inside the event handlers too.</p><p>React lets you manage, access, and mutate UI state but not application state. The difference between UI state and application state is that the UI state represents the data that's used to manipulate the UI whereas the application state represents the data that's displayed in the UI. For example, let's assume that you have a comment box. The comments in the comment box are the application state, and the <strong>View more comments</strong> button is the UI state, which may or may not be displayed, depending on whether there are any more posts.</p><p>Data binding between a UI and its state is only one-way. This means that user actions on the UI cannot alter the UI state directly, but the UI state can alter the UI.</p><p>It may seem as if this were a limitation as AngularJS and other popular frameworks provide two-way data binding, but this is actually a feature. This feature makes it easier to understand and debug applications.</p><p>Many developers tend to use UI state as application state, but for complex and large apps, this will cause issues and make it difficult to build the application.</p><p>Let's look at an example of how to use component state by building a button that hides/shows a box when clicked on.</p><p>Place this code in the <code class="literal">&lt;body&gt;</code> tag of the <code class="literal">index.html</code> file:</p><div><pre class="programlisting">&lt;div id="container3"&gt;&lt;/div&gt;</pre></div><p>We will display the component inside this container element.</p><p>Place this code inside the <code class="literal">script</code> tag:</p><div><pre class="programlisting">var hideShowBoxButton = React.createClass({
  getInitialState: function(){
    return {
      display: "inline-block"
    }
  },
  handleClick: function(){
    if(this.state.display == "inline-block")
    {
      this.setState({display: "none"});
    }
    else
    {
        this.setState({display: "inline-block"});
    }
  },
  render: function(){
    return React.createElement(
      "div", 
      {}, 
      React.createElement(
        "a", 
        {href: "#", onClick: this.handleClick}, 
        "Click to Show/Hide"
      ), 
      React.createElement(
        "span", 
        {
          style: {
            display: this.state.display, 
            height: 30, 
            width: 30, 
            backgroundColor: "red"
          }
        }
      )
    );
  }
});

ReactDOM.render(React.createElement(hideShowBoxButton), document.getElementById("container3"));</pre></div><p>This <a id="id430" class="indexterm"/>is the output of the previous code:</p><div><img src="img/B05154_10_03.jpg" alt="One-way data binding"/></div><p>This is how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we create a new component.</li><li class="listitem">The<code class="literal"> getInitialState</code> method returns the initial state of the component.</li><li class="listitem">Then, we create a click handler that toggles the display state. When mutating the state, you must use <code class="literal">this.setState</code> and not directly mutate the state using <code class="literal">this.state</code>.</li><li class="listitem">Then, we <a id="id431" class="indexterm"/>create the <code class="literal">render</code> method, which displays a button and a small red box. The <code class="literal">render</code> method sets the display style of the box to the display state. So, whenever the state changes, React renders the component. Instead of rendering the complete component, React re-renders it by comparing the virtual DOM with the real DOM and mutating only the required DOM elements. This is how it achieves rendering performance.</li><li class="listitem">Finally, we create a component instance and add it to the container element.</li><li class="listitem">Also note that we've only specified a number for height and width without any unit. In such a case, the unit is pixels.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec68"/>Isomorphic UI development</h2></div></div></div><p>
<strong>Isomorphic development</strong> is <a id="id432" class="indexterm"/>where we can use the same <a id="id433" class="indexterm"/>code in both the frontend and backend.</p><p>Till now, we've seen how to use React in the frontend to build reactive UI, but the same React code can also be used in the backend. When used in the backend, React outputs HTML and doesn't provide any kind of UI performance advantage or reactivity.</p><p>The isomorphic nature of React is one of the things that make it so popular and powerful. It has made many things easier. For example, it makes it easier to prevent FOUC by letting us pre-render the page in the backend, and then in the frontend: the same components will just add event bindings.</p><p>React code not only executes in Node.js but can also be executed in PHP, Ruby, .NET, and some other major backend languages.</p><p>Due to the fact that React can be used in both the frontend and backend, the React developer team decided to split React into two files: React core and another part that is specific to the executing environment. That's why when we included React in our HTML file earlier, we included two files. The React core contains <code class="literal">React.createElement</code>, <code class="literal">React.createClass</code>, and so on whereas the React DOM contains <code class="literal">ReactDOM.render</code> and so on.</p><p>Let's look at an example of how to use React in Node.js by creating and displaying the previous hello world component in Node.js. Create a directory named <code class="literal">React-Server-Demo</code>. Inside it, create files named <code class="literal">app.js</code> and <code class="literal">package.json</code>.</p><p>Inside the <code class="literal">package.json</code> file, place this code:</p><div><pre class="programlisting">{
  "name": "React-Server-Demo",
  "dependencies": {
    "express": "4.13.3",
    "react": "0.14.7",
    "react-dom": "0.14.7"
  }
}</pre></div><p>Then, run <code class="literal">npm install</code> to <a id="id434" class="indexterm"/>download the Express and <a id="id435" class="indexterm"/>React modules. Now, in the <code class="literal">app.js</code> file, place the following code and run the <code class="literal">node app.js</code> command:</p><div><pre class="programlisting">var React = require("react");
var ReactDOMServer = require("react-dom/server");
var express = require("express");
var app = express();

var anchorWithBoldItalic = React.createClass({
  render: function() {
    return React.createElement(
      "a", 
      {href: this.props.href}, 
      React.createElement("b", {}, this.props.boldText), 
      React.createElement("i", {}, this.props.italicText)
    );
  }
});

var HelloWorld = React.createElement(anchorWithBoldItalic, {href: "#", boldText: "Hello", italicText: " World" });

app.get("/", function(httpRequest, httpResponse, next){
  var reactHtml = ReactDOMServer.renderToString(HelloWorld);
  httpResponse.send(reactHtml)
})

app.listen(8080);</pre></div><p>Now, open <code class="literal">http://localhost:8080/</code> in your browser; you'll see this output:</p><div><img src="img/B05154_10_04.jpg" alt="Isomorphic UI development"/></div><p>This is how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we <a id="id436" class="indexterm"/>import the React core module, then the <a id="id437" class="indexterm"/>React server-side module, and then Express.</li><li class="listitem">We're using the same code we used earlier to create the component.</li><li class="listitem">Then, we create a route for the root path.</li><li class="listitem">The root path uses the <code class="literal">renderToString</code> method of the React server-side module to generate the HTML code of the component.</li><li class="listitem">Finally, we send the HTML to the client.</li></ol></div><div><div><h3 class="title"><a id="note41"/>Note</h3><p>Note that by default, React will be in development mode. To use React in production mode, set the environment variable <code class="literal">NODE_ENV</code> to <code class="literal">production</code>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Getting started with JSX</h1></div></div></div><p>Writing JavaScript <a id="id438" class="indexterm"/>to define a tree-like structure and attributes while building UI using React is difficult and also makes it difficult to understand the UI. So, the React team came up with an alternative syntax to write React code, which is easier to write and understand. This alternate syntax is called JSX. JSX stands for JavaScript syntax extension. It looks similar to XML. Files that contain JSX code have the<code class="literal">.jsx</code> extension.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec69"/>Compiling JSX</h2></div></div></div><p>Of course, browsers <a id="id439" class="indexterm"/>and server-side engines cannot understand and interpret JSX; therefore, we need to compile JSX into pure JavaScript before using it.</p><p>There are <a id="id440" class="indexterm"/>various open source JSX compilers. You can find the list at <a class="ulink" href="https://github.com/facebook/react/wiki/Complementary-Tools#build-tools">https://github.com/facebook/react/wiki/Complementary-Tools#build-tools</a>. The most <a id="id441" class="indexterm"/>popular and recommended compiler for JSX is Babel. Babel can be installed (<a class="ulink" href="https://babeljs.io/docs/setup/">https://babeljs.io/docs/setup/</a>), we can use the <a id="id442" class="indexterm"/>Babel compiler online (<a class="ulink" href="https://babeljs.io/repl/">https://babeljs.io/repl/</a>), and we can also embed the Babel compiler in our HTML page so that it compiles in the browser.</p><p>For the purpose of demonstration, we will embed the Babel compiler in our HTML page. Compiling <a id="id443" class="indexterm"/>takes time, so in production sites, you should never embed the compiler in web pages; instead, you should precompile and serve JSX code.</p><p>To embed the Babel compiler in a webpage, visit <a class="ulink" href="https://cdnjs.com/libraries/babel-core">https://cdnjs.com/libraries/babel-core</a> and download the Babel core. These are CDN links, so <a id="id444" class="indexterm"/>they can be embedded directly, but let's download and embed them in our webpage. Download the <code class="literal">browser.min.js</code> file and place it in the <code class="literal">react-demo</code> directory. And then, embed it in the <code class="literal">index.html</code> page by placing the following code in the <code class="literal">&lt;head&gt;</code> tag:</p><div><pre class="programlisting">&lt;script src="img/browser.min.js"&gt;&lt;/script&gt;</pre></div><p>Now, create a new <code class="literal">&lt;script&gt;</code> tag at the end of the <code class="literal">body</code> tag and set the <code class="literal">type</code> attribute to <code class="literal">text/babel</code> so that the Babel compiler knows which code to compile. Here is how the code should look:</p><div><pre class="programlisting">&lt;script type="text/babel"&gt;
&lt;/script&gt;</pre></div><p>From now on, all the JSX code will be placed in this script tag.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>
<strong>JSX editors</strong>
</p><p>There are extensions available for almost all the popular code editors to properly highlight JSX syntax.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec70"/>JSX syntax</h2></div></div></div><p>Let's rewrite <a id="id445" class="indexterm"/>the data-binding example code using JSX syntax. Place this code in the <code class="literal">body</code> tag to create a new container element:</p><div><pre class="programlisting">&lt;div id="container4"&gt;&lt;/div&gt;</pre></div><p>Here is the JSX code. Place it in the <code class="literal">script</code> tag that will be compiled by Babel:</p><div><pre class="programlisting">var HideShowBoxButton = React.createClass({
  getInitialState: function(){
    return {
      display: "inline-block"
    }
  },
  handleClick: function(){
    if(this.state.display == "inline-block")
    {
      this.setState({display: "none"});
    }
    else
    {
      this.setState({display: "inline-block"});
    }
  },
  render: function(){
    var boxStyle = {
      display: this.state.display, 
      height: 30, 
      width: 30, 
      backgroundColor: "red"
    };

    return (
      &lt;div&gt;
        &lt;a href="#" onClick={this.handleClick}&gt;Click to Show/Hide&lt;/a&gt;
        &lt;span style={boxStyle}&gt;&lt;/span&gt;
      &lt;/div&gt;
    )
  }
});

ReactDOM.render(&lt;HideShowBoxButton /&gt;, document.getElementById("container4"));</pre></div><p>The <a id="id446" class="indexterm"/>output of the code is as follows:</p><div><img src="img/B05154_10_05.jpg" alt="JSX syntax"/></div><p>Before we see how this code works, let's look at its compiled version:</p><div><pre class="programlisting">var HideShowBoxButton = React.createClass({
  displayName: "HideShowBoxButton",

  getInitialState: function getInitialState() {
    return {
      display: "inline-block"
    };
  },
  handleClick: function handleClick() {
    if (this.state.display == "inline-block") {
      this.setState({ display: "none" });
    }
    else
    {
      this.setState({ display: "inline-block" });
    }
  },
  render: function render() {
    var boxStyle = {
      display: this.state.display,
      height: "30px",
      width: "30px",
      backgroundColor: "red"
    };

    return React.createElement(
      "div",
      null,
      React.createElement(
        "a",
        { href: "#", onClick: this.handleClick },
        "Click to Show/Hide"
      ),
      React.createElement("span", { style: boxStyle })
    );
  }
});

ReactDOM.render(React.createElement(HideShowBoxButton, null), document.getElementById("container4"));</pre></div><p>This compiled <a id="id447" class="indexterm"/>version will give you a basic idea of how JSX syntax works. Let's understand how the previous JSX code works.</p><p>In a nutshell, JSX is used to write the <code class="literal">React.createElement</code> method in XML-like syntax. The XML tag name is the first argument, the attributes are the second argument, and finally, the child elements are the other arguments of <code class="literal">React.createElement</code>.</p><p>If a JSX tag name starts with a lowercase letter, it's an HTML tag, whereas if it starts with a capital letter, it's a component. So here, we made the component name start with a capital H. Had we used a small H, it would have been treated as an HTML tag, and <code class="literal">&lt;hideShowBoxButton&gt;&lt;/hideShowBoxButton&gt;</code> would have been inserted into the page, which would have rendered nothing.</p><p>In the <code class="literal">HideShowBoxButton</code> component, except the <code class="literal">render</code> method code, everything else is the same. We rewrote the <code class="literal">render</code> method using JSX syntax.</p><p>JSX provides <code class="literal">{}</code> braces to wrap JavaScript expressions while assigning them to attributes or using them as child elements. Here, we've assigned JavaScript expressions to <code class="literal">onClick</code> and <code class="literal">style</code> attributes.</p><p>Finally, we created an instance of the component using JSX syntax.</p><p>In the <a id="id448" class="indexterm"/>compiled code, you will find a <code class="literal">displayName</code> property in the object passed to <code class="literal">React.createClass</code>. The <code class="literal">displayName</code> property is used for debugging. If not set, it's set to the component name while compiling.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Digging into components</h1></div></div></div><p>Let's dig <a id="id449" class="indexterm"/>further into components and master them. We'll look at component composition and ownership. Learning this will help us build complex reactive UIs that are easier to manage.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec71"/>Component composition</h2></div></div></div><p>
<strong>Composability</strong> is a <a id="id450" class="indexterm"/>feature that lets you use a component inside <a id="id451" class="indexterm"/>another component's <code class="literal">render</code> method.</p><p>Let's look at a basic example of component composition. First, create a new container element. To do so, place the following code in the <code class="literal">body</code> tag:</p><div><pre class="programlisting">&lt;div id="container5"&gt;&lt;/div&gt;</pre></div><p>Here is the component composition example code. Place this code in the <code class="literal">script</code> tag that's compiled by Babel:</p><div><pre class="programlisting">var ResponsiveImage = React.createClass({
  render: function(){

    var imgWidth = {
      width: "100%"
    }

    return (
      &lt;img src={this.props.src} style={imgWidth} /&gt;
    )
  }
})

var Card = React.createClass({
  render: function(){
    var CardContainerStyle = {
      maxWidth: 300,
      backgroundColor: "grey"
    }

    return (
      &lt;div style={CardContainerStyle}&gt;
        &lt;h4&gt;{this.props.heading}&lt;/h4&gt;
        &lt;ResponsiveImage src={this.props.src} /&gt;
      &lt;/div&gt;
    )
  }
})

ReactDOM.render(&lt;Card src="img/350x150" heading="This is a Card Header" /&gt;, document.getElementById("container5"));</pre></div><p>This <a id="id452" class="indexterm"/>is the output of the code:</p><div><img src="img/B05154_10_06.jpg" alt="Component composition"/></div><p>Here, we've created two different components. Inside the Card component, we are using the <code class="literal">ResponsiveImage</code> component to display a responsive image in it.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec72"/>Component ownership</h2></div></div></div><p>When components <a id="id453" class="indexterm"/>are used inside other components' <code class="literal">render</code> methods, they are said to have an owner-ownee relationship and not a parent-child relationship. Component X is said to be the owner of component Y if component X created an instance of component Y in its <code class="literal">render</code> method.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Note that component X is not called the parent; rather, it's called the owner of component Y.</p></div></div><p>For example, in the <a id="id454" class="indexterm"/>previous code, the <code class="literal">Card</code> component is the owner of the <code class="literal">ResponsiveImage</code> component and <code class="literal">&lt;div&gt;</code> is the parent of <code class="literal">ResponsiveImage</code>.</p><p>If we place a component instance inside the opening and closing tags of a component instance, then they are said to be in a parent-child relationship. The parent can access its children by using the <code class="literal">this.props.children</code> object. React also provides utility functions to <a id="id455" class="indexterm"/>make working with children easier. You can find the utilities at <a class="ulink" href="https://facebook.github.io/react/docs/top-level-api.html#react.children">https://facebook.github.io/react/docs/top-level-api.html#react.children</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Reconciliation</h1></div></div></div><p>
<strong>Reconciliation</strong> is <a id="id456" class="indexterm"/>the process by which React updates the DOM whenever the state changes. React doesn't re-render everything from scratch when the state changes; instead, it first finds whether a mutation is required by comparing the new virtual DOM with the old one, and if there is a difference, it compares the new virtual DOM with the real DOM and makes the necessary mutations.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>Note that reconciliation doesn't happen only when you change the component state; it also happens when you call <code class="literal">ReactDOM.render</code> on the same container element again.</p></div></div><p>Let's see how exactly reconciliation happens by looking at an example. Suppose this is the initial render:</p><div><pre class="programlisting">&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>If we remove <code class="literal">Item 1</code> from the state, then the render will change to this:</p><div><pre class="programlisting">&lt;ul&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>React algorithms compare DOM items one by one, and whenever they find a difference between two nodes, they make mutations. So here, React will remove the <code class="literal">Item 1</code> list item by changing the text of the first list item and removing the last one. This process is much faster than removing both the list items and adding a new list item, which is what <code class="literal">ng-repeat</code> does and what we used to do using JavaScript.</p><p>If the <a id="id457" class="indexterm"/>node type is different, React will treat them as two different subtrees, throw away the first one, and build/insert the second one. For example, if we change <code class="literal">&lt;ul&gt;</code> to <code class="literal">&lt;ol&gt;</code>, the complete <code class="literal">&lt;ul&gt;</code> tree will be deleted.</p><p>This behavior is fine until you add new items to the end of the list or modify them. In case you add new items to the beginning or in between the list, you will start facing rendering performance issues. To understand the issue, let's take an example. Let's add <code class="literal">Item 0</code> to the beginning. Now, the render will look like this:</p><div><pre class="programlisting">&lt;ul&gt;
  &lt;li&gt;Item 0&lt;/li&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Here, while reconciling, React will first change the text of the first list item to <code class="literal">Item 0</code>, then change the text of the second list item to <code class="literal">Item 1</code>, and finally will add a new list item and assign its text to <code class="literal">Item 2</code> instead of simply adding a new list item to the beginning of the list. This behavior makes the rendering actually slower.</p><p>React does provide a way to get around this kind of issue as well. It lets us uniquely identify each child by assigning it a unique key. When React reconciles the keyed children, it will ensure that any child with a key will be reordered (instead of being mutated) or destroyed (instead of being reused). A key is assigned using the <code class="literal">key</code> attribute.</p><p>Let's look at an example of how to create keyed children. Here is the code to create a new container element. Place this code in the <code class="literal">body</code> tag:</p><div><pre class="programlisting">&lt;div id="container6"&gt;&lt;/div&gt;</pre></div><p>Here is the React code for creating keyed children:</p><div><pre class="programlisting">var DynamicList = React.createClass({
  getInitialState: function(){
    return {
      results: this.props.results
    }
  },
  handleClick: function(){ 
    var results = this.state.results;
    var firstId = results[0].id - 1;
    var firstValue = results[0].value - 1;

    results.unshift({id: firstId, value: firstValue});
    this.setState({results: results});
  },
  render: function(){
    return (
      &lt;div&gt;
        &lt;a href="#" onClick={this.handleClick}&gt;Click to add new item&lt;/a&gt;
        &lt;ul&gt;
          {this.state.results.map(function(result) {
            return &lt;li key={result.id}&gt; {result.value} &lt;/li&gt;;
          })}
        &lt;/ul&gt;
      &lt;/div&gt;

    )
  }
})

var results = [{id: 1, value: 1}, {id: 2, value: 2}];

ReactDOM.render(&lt;DynamicList results={results} /&gt;, document.getElementById("container6"));</pre></div><p>Here is <a id="id458" class="indexterm"/>the output of the code:</p><div><img src="img/B05154_10_07.jpg" alt="Reconciliation"/></div><p>Here, when the <code class="literal">anchor</code> element is clicked on, a new object is added to the beginning of the result array. As the state changes, the list is re-rendered. While rendering, React will reorder the list items and add new list items to the beginning instead of mutating them.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>Remember that when dynamically creating component instances, the key should always be supplied to the components in the array, not to the container element of each component in the array.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Default component property values</h1></div></div></div><p>React lets <a id="id459" class="indexterm"/>you define default values for properties in a very declarative way. The default value is used if the parent does not pass a property.</p><p>Default values are returned by a method <code class="literal">getDefaultProps</code>, which is a member of the object passed to <code class="literal">React.createClass</code>. Here is some sample code:</p><div><pre class="programlisting">var ComponentWithDefaultProps = React.createClass({
  getDefaultProps: function() {
    return {
      value: 'default value'
    };
  }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Component life cycle methods</h1></div></div></div><p>Various methods <a id="id460" class="indexterm"/>are executed at specific points in a component's lifecycle. Let's look at them.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec73"/>componentWillMount()</h2></div></div></div><p>The <code class="literal">componentWillMount()</code> method <a id="id461" class="indexterm"/>is invoked once immediately before the initial rendering occurs. If you call <code class="literal">setState</code> within this method, <code class="literal">render()</code> will see the updated state and will be executed only once despite the state change.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec74"/>componentDidMount()</h2></div></div></div><p>The <code class="literal">componentDidMount()</code> method is <a id="id462" class="indexterm"/>invoked only on the client side. It is invoked only once after initial rendering has occurred.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec75"/>componentWillReceiveProps(nextProps)</h2></div></div></div><p>Directly <a id="id463" class="indexterm"/>mutating the properties passed to a component will have no effect because there is no way for React to find value changes as it doesn't watch the properties directly. But sometimes, it is possible for React to predict property value changes, and in that case, it calls the <code class="literal">componentWillReceiveProps</code> method, if it exists, with the new property values as its parameters, and it also re-renders the component.</p><p>For example, if we change the state of the owner of a component, then that sends a signal that <a id="id464" class="indexterm"/>the properties of the components it owns might have changed, so it calls the <code class="literal">componentWillReceiveProps</code> method and re-renders the components it owns.</p><p>Let's look at an example to demonstrate the <code class="literal">componentWillReceiveProps</code> method. We will create a button whose value increments every second. Here is the code to create a new container element. Place it in the <code class="literal">body</code> tag:</p><div><pre class="programlisting">&lt;div id="container7"&gt;&lt;/div&gt;</pre></div><p>Here is the code for our example. Place this code in the <code class="literal">script</code> tag that will be compiled by Babel:</p><div><pre class="programlisting">var ButtonComponent = React.createClass({
  componentWillReceiveProps: function(nextProps){
    console.log("Text changed to " + nextProps.text);
  },
  render: function(){
    return (
      &lt;button&gt;{this.props.text}&lt;/button&gt;
    )
  }
})

var ButtonHolderComponent = React.createClass({
  componentDidMount: function(){
    setInterval(function(){
      this.setState({
        text: this.state.text + 1
      });
    }.bind(this), 1000)
  },
  getInitialState: function(){
    return {
      text: 1
    }
  },
  render: function(){
    return (
      &lt;ButtonComponent text={this.state.text} /&gt;
    )
  }
})

ReactDOM.render(&lt;ButtonHolderComponent /&gt;, document.getElementById("container7"));</pre></div><p>Here is <a id="id465" class="indexterm"/>the output of the code:</p><div><img src="img/B05154_10_08.jpg" alt="componentWillReceiveProps(nextProps)"/></div><p>In the code, we are changing the state of the owner every second after the initial rendering has occurred. Whenever the state changes, the <code class="literal">componentWillReceieveProps</code> object of <code class="literal">ButtonComponent</code> is called. Inside the <code class="literal">componentWillReceieveProps</code> object, we can use <code class="literal">this.props</code> to access the previous values of the properties. The button is rendered whenever its owner's state changes.</p><p>Remember that <code class="literal">componentWillReceieveProps</code> is called before the component is re-rendered, so we can make any state changes we want inside it.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec76"/>shouldComponentUpdate(nextProps, nextState)</h2></div></div></div><p>The <code class="literal">shouldComponentUpdate(nextProps, nextState)</code> method <a id="id466" class="indexterm"/>is called before the <code class="literal">render</code> method is called, that is, before rendering happens. If this method returns <code class="literal">false</code>, then rendering is skipped.</p><p>Remember that this method is not called before forced updates or initial rendering.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>
<strong>What is a forced update?</strong>
</p><p>React provides a <code class="literal">forceUpdate</code> method inside a component, which renders the component when called. This can be used when the <code class="literal">render()</code> method depends on some other data instead of just <code class="literal">this.props</code> and <code class="literal">this.state</code>, as changes to other data don't trigger the <code class="literal">render</code> method.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec77"/>componentWillUpdate(nextProps, nextState)</h2></div></div></div><p>The <code class="literal">componentWillUpdate(nextProps, nextState)</code> method <a id="id467" class="indexterm"/>is invoked immediately before rendering when new props or state are being received. This method is not called for the initial render.</p><p>Note <a id="id468" class="indexterm"/>that you cannot use <code class="literal">this.setState</code> inside this method.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec78"/>componentDidUpdate(prevProps, prevState)</h2></div></div></div><p>The <a id="id469" class="indexterm"/>
<code class="literal">componentDidUpdate(prevProps, prevState)</code> method is invoked immediately after the component's updates are flushed to the real DOM. This method is not called for the initial render.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec79"/>componentWillUnmount()</h2></div></div></div><p>The <a id="id470" class="indexterm"/>
<code class="literal">componentWillUnmount()</code> method is invoked immediately before a component is unmounted from the real DOM.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Mixins</h1></div></div></div><p>There are <a id="id471" class="indexterm"/>times when multiple components share the same code; in such cases, we can use mixins instead of writing the same code again and again.</p><p>A <strong>mixin</strong> is an object that holds component methods that can be easily plugged in to any component.</p><p>Let's look at an example to demonstrate mixins. Here is the code to create a new container element. Place it in the <code class="literal">body</code> tag:</p><div><pre class="programlisting">&lt;div id="container8"&gt;&lt;/div&gt;</pre></div><p>Here is the code for our example. Place it in the <code class="literal">script</code> tag that will be compiled by Babel.</p><div><pre class="programlisting">var Mixin1 = {
  componentWillMount: function(){
    console.log("Component will mount now");
  }
}

var Mixin2 = {
  componentDidMount: function(){
    console.log("Component did mount");
  }
}

var HeadingComponent = React.createClass({
  mixins: [Mixin1, Mixin2],
  render: function(){
    return &lt;h1&gt;React is Awesome&lt;/h1&gt;
  }
});

ReactDOM.render(&lt;HeadingComponent /&gt;, document.getElementById("container8"));</pre></div><p>This is <a id="id472" class="indexterm"/>the output of the code on the page:</p><div><img src="img/B05154_10_09.jpg" alt="Mixins"/></div><p>And this is the output on the console:</p><div><img src="img/B05154_10_10.jpg" alt="Mixins"/></div><p>Here, we've created two mixins and added them to <code class="literal">HeadingComponent</code>. These mixins can be used in any number of methods. Mixins simply increase code reusability.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Using Refs</h1></div></div></div><p>
<strong>Refs</strong> are <a id="id473" class="indexterm"/>used inside components to return references to real DOM elements rendered <a id="id474" class="indexterm"/>by React. So, instead of assigning an <code class="literal">id</code> or <code class="literal">class</code> value to elements, we can assign refs. It's easier to get references to real DOM elements using refs than <code class="literal">id</code> or <code class="literal">class</code> attributes.</p><p>Let's look at a basic example of how to use refs by creating a form. First, create a container element and place it inside the <code class="literal">body</code> tag. Here is the code:</p><div><pre class="programlisting">&lt;div id="container9"&gt;&lt;/div&gt;</pre></div><p>Here is the code for the form, which uses refs:</p><div><pre class="programlisting">var FormComponent = React.createClass({
  clicked: function(){
    console.log(this.refs.myInput.value);
  },
  render: function(){
    return (
      &lt;div&gt;
        &lt;input type="text" placeholder="Write Something" ref="myInput" /&gt;
        &lt;input type="button" value="Click to Submit" onClick={this.clicked} /&gt;
      &lt;/div&gt;

    )
  }
})

ReactDOM.render(&lt;FormComponent /&gt;, document.getElementById("container9"));</pre></div><p>The <a id="id475" class="indexterm"/>output <a id="id476" class="indexterm"/>of this code on the webpage is as follows:</p><div><img src="img/B05154_10_11.jpg" alt="Using Refs"/></div><p>If we enter <code class="literal">Hello World</code> in the text field and click on the button, then the output of the console is this:</p><div><pre class="programlisting">Hello World</pre></div><p>In the previous code, we're assigning a <code class="literal">ref</code> attribute to the button element. To refer to the button in the methods of the component, we use <code class="literal">this.refs</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec77"/>ReactDOMServer.renderToStaticMarkup</h1></div></div></div><p>Earlier in this <a id="id477" class="indexterm"/>chapter, we used React on the server side to generate HTML. The HTML generated by React on the server and client side contains <code class="literal">data-reactid</code> attributes, which are used by React internally. On the client side, it makes sense to have <code class="literal">data-reactid</code>, as it is used during reconciliation and other processes and features.</p><p>You must be wondering what the point of adding this attribute on the server side is. Actually, it is <a id="id478" class="indexterm"/>added so that if you call <code class="literal">ReactDOM.render()</code> on the client side on a node that already has React server-rendered markup, React will preserve it and only reconcile it.</p><p>If you don't want <code class="literal">data-reactid</code> attributes to be generated on the server side, you can use <code class="literal">renderToStaticMarkup</code> instead of <code class="literal">renderToString</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we learned React up to an intermediate level by covering in depth its features and components, JSX, using it for server-side rendering, reconciliation, and so on. We also learned miscellaneous features such as mixins and refs. Now, you should have a basic understanding of how and when to integrate React into your websites.</p><p>In the next chapter, we will learn React in more depth by building an application that uses the Flux and SPA architectures. </p></div></body></html>