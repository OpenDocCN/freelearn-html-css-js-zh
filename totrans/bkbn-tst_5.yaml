- en: Chapter 5. Test Stubs and Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the integration of Sinon.JS into our test infrastructure, we now have deeper
    insight into the methods and actions within our Backbone.js application. As we
    turn to testing the remaining application components, we will move beyond merely
    *observing* methods during tests and actually *replace* method behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sinon.JS has us covered in this respect as well—the library provides solid
    support for functional behavior modifications. Specifically, we can leverage its
    powerful stub and mock abstractions to reduce Backbone.js component dependencies
    and cross-application side effects during testing. In this chapter, we will explore
    these and other Sinon.JS capabilities through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Sinon.JS stubs to replace function behaviors and isolate Backbone.js components
    in tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Sinon.JS mocks that spy, stub, and verify application behavior in
    a single abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for the remaining components of our Backbone.js application and
    deciding on the proper Sinon.JS tools for the given test scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating other contextually useful Sinon.JS test helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faking a remote backend server in Backbone.js collection tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing method behaviors with Sinon.JS stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been able to handle our Backbone.js testing dependencies so far with
    a combination of clever class design and some manual faking. However, we are quickly
    approaching a point where we need a more reliable and consistent approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look to stubs to provide a straightforward and predictable means of
    substituting method behaviors in any Backbone.js component to reduce unintended
    application side effects and dependency issues. The ability to temporarily replace
    existing methods during tests offers an enormous amount of flexibility, particularly
    in situations where:'
  prefs: []
  type: TYPE_NORMAL
- en: A Backbone.js application is under early development and not all of the planned
    components exist. Stubs allow us to write a simulated equivalent of the missing
    functionality in tests that can later be removed when the real application code
    is written. Even after the application code has been implemented, stubs may still
    be appropriate for a subset of the original specs, depending on what type of behavior
    is being tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application code is sensitive to the timing of the UI and/or other events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application depends on external resources such as a database or cloud service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Backbone.js component has application dependencies and/or interactions that
    are too complex to manually swap in tests and that must be faked internally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To kick things off, let''s integrate some stubs into an object literal from
    the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the ensuing spec, we will show you two different ways to stub `obj.multiply()`
    with Sinon.JS. In the first call (`sinon.stub(obj, "multiply").returns(5)`), we
    use the `returns` method to always return a hardcoded value. The second stub takes
    an alternate approach that inserts a replacement function (that adds instead of
    multiplying). In both cases, we call `restore()` after the test finishes to keep
    `obj` from being permanently modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning our attention to `obj.error()` in the ensuing code snippet, we create
    an empty stub on the object method to prevent the real function from throwing
    an exception. We don''t need a replacement function or a `returns` value because
    we just want to *avoid* the default behavior. Additionally, we use the `sinon.test`
    sandbox helper to automatically call `restore()` on any stubs that were created
    within the test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in the previous code snippets, we can now easily replace arbitrary
    methods with different code and/or return values.
  prefs: []
  type: TYPE_NORMAL
- en: The stub API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sinon.JS stubs implement the entire spy API and provide additional methods
    that can swap existing application functions with new code and behaviors during
    our tests. The first step in stubbing is to create a stub object and potentially
    replace one or more object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sinon.stub()`: This creates an anonymous stub without any specified behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sinon.stub(obj, methodName)`: This stubs a single object''s method with an
    empty function. This alone is sufficient to replace the underlying code''s execution
    like we saw in the code with `obj.error()`. Alternatively, you can further call
    stub API methods to modify return, callback, or other behaviors of the stub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sinon.stub(obj, methodName, fn)`: This stubs a single object''s method with
    the replacement function provided in the `fn` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sinon.stub(obj)`: This replaces *all* the methods in an object with stubs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have a stub object, we can enhance it with fake behaviors and responses
    as applicable in a given testing situation. Some of these methods are appropriate
    for synchronous (non-callback) function responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stub.returns(obj)`: This stub will return the value `obj` when called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stub.throws()`: This stub will throw an `Error object` exception when called.
    A specific error will be used if `throws()` is called with a type string (for
    example, `"TypeError"`) or an error object (for example, `new TypeError()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sinon.JS also supports asynchronous callbacks in stubbed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stub.yields(arg1, arg2, ...)`: The first parameter to the stubbed method must
    be a callback function that the stub will call with the parameters `arg1`, `arg2`,
    and so on. In the following code snippet, we''ll stub `obj.async()` and use `yield()`
    to inject the fake arguments `1` and `2` into the callback:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`stub.yieldsOn(context, arg1, arg2, ...)`: This is equivalent to `stub.yields()`,
    except that it also injects the `context` parameter as the special variable `this`
    when invoking the callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stub.yieldsTo(property, arg1, arg2, ...)`: This is also similar to `stub.yields()`,
    except that the callback to the underlying method is expected to be an object
    with a property name matching the `property` parameter value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stub.yieldsToOn(property, context, arg1, arg2, ...)`: This is a combination
    of `stub.yieldsOn()` and `stub.yieldsTo()` that uses an object callback property
    and context variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stub.callsArgWith(index, arg1, arg2, ...)`: The `stub.yields*` collection
    of methods utilizes the *first* parameter of the stubbed method. However, asynchronous
    callbacks can occur in other parameter positions. The `stub.callsArgWith()` method
    allows us to specify the index of the callback parameter to be used and the arguments
    to be passed to the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stub.callsArg*`: In addition to `stub.callsArgWith()`, the methods `stub.callsArg(index)`,
    `stub.callsArgOn(index, context)`, and `stub.callsArgOnWith(index, context, arg1,
    arg2, ...)` take a first parameter named `index` that specifies the index of the
    callback to be invoked in the wrapped method and work in a manner analogous to
    their `yields*` counterparts mentioned previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This set of stub features is sufficient to cover most Backbone.js testing situations.
    At the same time, it is worthwhile to review the full Sinon.JS stub API documentation
    ([http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs)) to learn about
    additional methods and helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Faking and verifying behavior with Sinon.JS mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final test double abstraction that we will cover in this book is the test
    mock. Mocks replace function behaviors like stubs, observe method calls like spies
    and stubs, and additionally verify function behaviors. Essentially, mocks are
    a "one-stop shop" for faking and testing methods.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding when to mock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, when should we use mocks? The Sinon.JS mock API documentation ([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks))
    starts with the appropriate use cases for mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mocks should only be used for the method under test. In every unit test, there
    should be one unit under test. If you want to control how your unit is being used
    and like stating expectations upfront (as opposed to asserting after the fact),
    use a mock."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The documentation cautions that mocks should be *avoided* in many situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mocks come with built-in expectations that may fail your test. Thus, they
    enforce implementation details. The rule of thumb is: if you wouldn''t add an
    assertion for some call specific, don''t mock it. Use a stub instead. In general
    you should never have more than one mock (possibly with several expectations)
    in a single test."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We have a bias in this book towards Sinon.JS stubs for the reasons just discussed
    and because of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Chai and Sinon-Chai adapter libraries allow us to write test assertions
    on stubs that are concise, expressive, and readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sinon.JS mock expectation API is less flexible than using Chai assertions
    against the stub API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, mocks *are* stubs. So, tests can mix and match preprogrammed
    Sinon.JS mock expectations with subsequent Chai stub assertions. Ultimately, after
    we have finished reviewing the details of stubs and mocks in this chapter, we
    leave the choice of abstraction up to the developer and the specific testing scenario
    at hand.
  prefs: []
  type: TYPE_NORMAL
- en: The mock API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sinon.JS mocks ([http://sinonjs.org/docs/#mocks-api](http://sinonjs.org/docs/#mocks-api))
    implement the spy and stub APIs and additionally provide expectations that verify
    application behavior. We''ll begin with a brief discussion of the core mock methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sinon.mock(obj)`: This method mocks all the methods of `obj` and returns a
    mock object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock.expects(methodName)`: This method creates an expectation for the specified
    method of the mocked object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock.verify()`: This method examines and verifies that all expectations were
    met and throws exceptions on assertion failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock.restore()`: This method unwinds and removes all mocked modifications
    of the underlying object that is being tested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we have mocked an object, the usual workflow is to call `mock.expects()`
    on one or more methods and configure expectations for a `mock.verify()` call later.
    For the complete expectations list, see [http://sinonjs.org/docs/#expectations](http://sinonjs.org/docs/#expectations).
    A sampling of some useful expectation methods includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expectation.atLeast(num)`, `expectation.atMost(num)`, and `expectation.exactly(num)`:
    These mocked methods should be called at least/at most/exactly `num` times respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectation.never()`, `expectation.once()`, `expectation.twice()`, and `expectation.thrice()`:
    These are the helpers specifying common assertions for the number of times the
    mocked method was called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectation.withArgs(arg1, arg2, ...)` and `expectation.withExactArgs(arg1,
    arg2, ...)`: Every call to the mocked method has at least/exactly the parameters
    specified in the expectation respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectation.on(obj)`: This mocked method should be called with `obj` as the
    context (`this`) variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectation.verify()`: This method runs assertions on a specific expectation
    (as opposed to `mock.verify()` that confirms *all* expectations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, we create our `mock` object around `obj` and
    declare the expectation that `multiply` will be called two to four times and that
    the first argument to every call will be `2`. We then call `multiply` three times
    with the appropriate parameters. Finally, a single `mock.verify()` call checks
    if all of the mock expectations were met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Testing Backbone.js components with stubs and mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the addition of stubs and mocks to our test infrastructure, we are ready
    to tackle the remaining components of our Backbone.js application that we will
    cover in this book: the `App.Views.NotesItem` view and the `App.Routers.Router`
    router. For those following along in the code examples, we will integrate the
    specs for these application components into the test driver page `chapters/05/test/test.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring stubs and mocks are actually bound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One preliminary Sinon.JS issue that can trip up developers is making sure that
    spies, stubs, and mocks are actually bound to the expected methods of a Backbone.js
    application object during a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple Backbone.js view named `MyView`. The view has a
    custom method named `foo()` that is bound to two event listeners, `wrapped` and
    `unwrapped`. The listeners are functionally equivalent, except that `wrapped`
    wraps the call in a function (`function () { this.foo(); }`) while `unwrapped`
    binds the real (or "naked") `this.foo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although quite similar, the event listeners have an important difference when
    using Sinon.JS fakes; once `initialize()` is called, naked method references,
    such as the one passed to `unwrapped`, cannot be faked by Sinon.JS later. The
    underlying reason is that Sinon.JS can only change properties on the view object
    and not on the direct method references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine a test that instantiates a `MyView` object and then stubs `foo`.
    When we trigger the `wrapped` listener, our stub is called and returns the faked
    value `I''m fake`. However, triggering the `unwrapped` listener never calls the
    stub and invokes the *real* `foo` method instead. Note that we use the Sinon.JS
    `reset()` method to clear out any recorded function call information and return
    a spy, stub, or mock to its original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One solution to the issue is to stub *before* the object is instantiated. In
    the following code snippet, creating the stub *before* the call to `new MyView()`
    correctly hooks the stub into both the `wrapped` and `unwrapped` listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is fairly straightforward to keep track of the order in which Backbone.js
    objects are initialized and stubbed for a single test, such as in the previous
    two code snippets. However, it is important to keep binding in mind for a test
    suite setup and teardown, especially when an object is instantiated in a different
    place from where it will later be mocked or stubbed. Additionally, the issue can
    manifest in various other places in Backbone.js applications, such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View events**: Views can declare an `events` property that binds UI events
    to methods by the string name of the method. This internally behaves similar to
    a naked function reference when a new view object is initialized by Backbone.js.
    An example of this type of declaration is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Router routes**: Similarly, routers typically declare a `routes` property
    that binds hash/URL fragments to named methods on the router object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important takeaway point is to always consider how a Sinon.JS fake
    will be bound to the Backbone.js component that is being tested. It is sometimes
    easier to avoid naked function references in a Backbone.js application component,
    and at other times, it is better to reformulate test code so that stubs can be
    bound before the component is initialized. In the Notes application, we will use
    both of the approaches for the remaining tests in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes list item view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last Notes view that we will discuss and test in this book is the list
    item view. When a user navigates to the home page of the Notes application, they
    are presented with a list of notes identified by their titles. The `App.Views.NotesItem`
    view is responsible for rendering each individual note row and allowing a user
    to view, edit, or delete a note. The following screenshot illustrates the rendered
    output for a single list item view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notes list item view](img/5248OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notes list item view
  prefs: []
  type: TYPE_NORMAL
- en: The title text of a list item can be clicked on to view the rendered Markdown
    for a single note. A list item also contains two action buttons, one with a pencil
    icon for editing and the other with a trash can icon for deleting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list item template string is declared as the `template-notes-item` property
    of `App.Templates` in `notes/app/js/app/templates/templates.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The template renders two `td` cells within a table row, one for the note title
    and the other for the edit/delete buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The list item view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `App.Views.NotesItem` view is defined in `notes/app/js/app/views/notes-list.js`.
    The class definition starts with DOM attributes for rendering a `tr` tag, a `notes-item`
    class, and an `id` property that corresponds to the note model''s identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Click events on a list item''s title and edit/delete buttons are bound to their
    respective view methods, `viewNote`, `editNote`, and `deleteNote`. In terms of
    our earlier Sinon.JS binding discussion, note that all of the event callbacks
    have function wrappers that allow us to create `App.Views.NotesItem` objects that
    can be stubbed at any time during the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `initialize`, the view stores a router reference and sets listeners that
    re-render or remove the view in response to model events. The `render` method
    binds the model data to the template in a fairly conventional manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning to the actions we can perform on a single list item, the `viewNote`
    and `editNote` methods navigate to a single-note view in viewing or editing mode.
    The `deleteNote` function deletes the underlying note model that then triggers
    events that will clean up and remove the view from the list of all notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Testing the list item view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `App.Views.NotesItem` view behaviors that we wish to verify in our test
    suite file `chapters/05/test/js/spec/views/notes-item.spec.js` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The view renders HTML for a single row in the notes list table and shows the
    note's title and the action buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It binds click events to the appropriate note actions (for example, edit) and
    navigates to the appropriate single note page to read or edit a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It correctly cleans up the object state when a user deletes a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test suite starts with the `before()` setup method where we create an `App.Views.NotesItem`
    object with a fake router object literal (containing a `navigate` stub) and a
    real `App.Models.Note` model. In the `afterEach()` method, we reset the `navigate`
    stub so that each spec gets a stub that is free of any previously recorded function
    information. The `after()` teardown function removes the view under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, keeping the Sinon.JS method''s binding issues in mind, we note that
    `this.view` is created in the `before()` setup for the entire test suite. This
    means that stubs, spies, and/or mocks will only work on wrapped `App.Views.NotesItem`
    view methods. At the same time, if the existing `App.Views.NotesItem` suite is
    not amenable to all of the test double bindings that we need, we can easily create
    an additional suite that fakes the class prototype before instantiation, to provide
    additional flexibility in testing the desired application behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first nested test suite checks whether the underlying model''s `destroy`
    event triggers the `view.remove()` method, cleaning up the view. We stub `view.remove()`
    to prevent the view from actually being removed from the test environment when
    called. Then, we trigger the desired model event so that we can verify that the
    stub was called once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next two specs, we tackle an analogous scenario, verifying that the
    note model''s `change` event will trigger a `render()` call on the view. We make
    the same assertions in both the specs, using stubs in one and mocks in the other
    to demonstrate how to write the same functional spec using either abstraction.
    The spec `renders on model change w/ stub` uses a stub to verify the view''s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `renders on model change w/ mock` spec, we rely on a mock to make the
    same assertion using the Sinon.JS `once()` expectation modifier and `mock.verify()`
    instead of Chai assertions on a stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next two specs, we examine the scenarios in which a user clicks on the
    list item title (for viewing) or the pencil button (for editing). We need to check
    if both the clicks call an appropriate view function and cause the router to navigate
    us to the expected single-note page. In the ensuing code snippet, we verify this
    behavior by asserting that the router''s `navigate` stub has been called with
    appropriate arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we ensure that clicking on the trash can button triggers the underlying
    note model to be destroyed. We stub the model''s `destroy` method to verify that
    it was called and to prevent the model from actually being mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All in all, our tests for `App.Views.NotesItem` demonstrate how replacing method
    behaviors with mocks and stubs can simplify our tests and limit the program method's
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes application router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final Backbone.js component that we will test in the Notes application is
    the router, `App.Routers.Router`. The router is responsible for managing client-side
    page locations (URLs or hash fragments) and binding routes to views, events, and
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will use a simplified version of the `App.Routers.Router`
    class, available at `chapters/05/test/js/spec/routers/router.js`, instead of the
    real Notes router file (found in the code samples at `notes/app/js/app/routers/router.js`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the real Backbone.js router is not the most complex beast, it has sufficiently
    complicated dependencies and application logic to warrant omitting the full implementation
    in the text of this chapter, particularly when we just need to introduce a few
    testing tips for routers.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we don't shy away from tests just because we have component
    dependencies. Accordingly, we provide a comprehensive test suite for the real
    `App.Routers.Router` component in the code samples at `notes/test/js/spec/routers/router.spec.js`.
    You are encouraged to review the implementations of the full router and its corresponding
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Notes application contains two routes corresponding to the notes list page
    and the single-note page. We encompass this behavior in the simplified `App.Routers.Router`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our tests should check if the route specifications bind to the correct router
    methods and if the URLs / hash fragments are correctly parsed into parameters
    for the router method. We verify this behavior in the test suite file `chapters/05/test/js/spec/routers/router.spec.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Our setup logic begins by creating stubs around the router's `note` and `notes`
    methods. We then instantiate a router object and start history (which enables
    actual routing). Our setup concludes with binding an anonymous spy to every `route`
    event (fired any time a route is activated).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always on the lookout for Sinon.JS binding issues, note that we have to stub
    the router prototype *before* we instantiate a router object because the router
    object's `routes` property binds routes to method name strings and not to wrapped
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our teardown logic stops the history and unwinds the stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first spec checks if we can navigate to a single note to edit it by calling
    the router''s `navigate` method on the desired route `"note/1/edit"`. We assert
    that this calls the router''s `note` method (which we have stubbed) with the extracted
    parameters `"1"` and `"edit"`. We also confirm the same type of information with
    the `routerSpy` event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second spec verifies that we can navigate to the home page, then to a single-note
    page, and then back to the home page. We use similar verification logic as in
    the previous spec, relying on the `notes` stub (called twice on the `""` home
    page route) and the `routerSpy` spy (called on all three routes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These router tests are not that different from Backbone.js view tests for events—both
    of them bind strings (a route or a UI event) to component methods (via a string
    name or function). All in all, the Sinon.JS mocking and stubbing methods we have
    learned in this chapter should generally apply to any type of Backbone.js component.
  prefs: []
  type: TYPE_NORMAL
- en: Running the view and router tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have test suites for `App.Views.NotesItem` and `App.Routers.Router`,
    we can integrate them into a test driver page. Building on the previous `chapters/04/test/test.html`
    driver page (with a few highlighted additions), our final driver page `chapters/05/test/test.html`
    includes the following relevant parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we have accrued a large number of JavaScript files between the
    vendor libraries and our Backbone.js application components. While this is acceptable
    for tests (and sometimes even desired), it is good practice to concatenate and
    optimize your JavaScript files in production applications with a tool such as
    the Google Closure Compiler ([https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/))
    or UglifyJS ([https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2)).
  prefs: []
  type: TYPE_NORMAL
- en: We can now navigate a browser window to `chapters/05/test/test.html` to run
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are running the report from the code samples, a few extra view specs
    that have not been discussed in this book will appear in the results.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you may notice is that invocations of the `navigate` method in the
    router tests actually modify the browser location, adding hash fragments. While
    this doesn't affect the correctness of our tests, it is a bit unexpected. Taking
    an alternative approach, the Backbone.js library test suite gets around this issue
    by creating a fake `Location` object to substitute for the real browser navigation
    bar. See [https://github.com/documentcloud/backbone/blob/master/test/router.js](https://github.com/documentcloud/backbone/blob/master/test/router.js)
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the rest of the Notes application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the previous view and router tests completed, we are now finished with
    the application and test code that we will present in this book for the localStorage-based
    Notes application. There are, however, a few more parts of the Notes application
    that we simply do not have room to discuss within the confines of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, each of the components (as well as their relevant test files)
    are available as part of the downloadable code samples for this book. The remaining
    parts of the Notes application that you can find in the samples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Views.NotesFilter` (`notes/app/js/app/views/notes-filter.js`): This view
    controls the filter input box and the visibility of the note rows in the displayed
    list of notes. The test file for this view can be found at `notes/test/js/spec/views/notes-filter.spec.js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Views.Notes` (`notes/app/js/app/views/notes.js`): The `App.Views.Notes`
    view contains the `App.Views.NotesItem` and `App.Views.NotesFilter` views and
    is responsible for getting note data from the collection and for rendering a full
    list of notes. The corresponding test file is located at `notes/test/js/spec/views/notes.spec.js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Routers.Router` (`notes/app/js/app/routers/router.js`): This is the full
    implementation of the Backbone.js router for Notes. Its test file is available
    at `notes/test/js/spec/routers/router.spec.js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app` (`notes/app/js/app/app.js`): The `app` object controls the overall Notes
    application. It instantiates all of the top-level application components; for
    example, the `App.Views.Notes` view, the `App.Routers.Router` router, and the
    `App.Collections.Notes` collection. It also kicks off an initial collection `fetch`
    to import existing notes data. We do not include specs for this file, as creating
    and starting an actual application is usually encompassed within the scope of
    full integration testing—an approach we mentioned in [Chapter 2](ch02.html "Chapter 2. Creating
    a Backbone.js Application Test Plan"), *Creating a Backbone.js Application Test
    Plan*, which you are encouraged to learn outside of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notes/test/test.html`: This is the test driver page for all the Notes application
    test suites and specs. This page aggregates all of the Notes specs we have discussed
    in this book as well as the specs for omitted views, and the full router implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These extra files apply the fundamental lessons we have learned throughout this
    book to different application code and scenarios. Thus, reviewing the remaining
    Notes application files will provide you with a much better picture of a full
    Backbone.js application and test infrastructure that follows the testing principles
    we suggest. All in all, we hope that the code samples will send home the topics
    we have covered in this book and possibly give you some ideas and next steps for
    your test development education.
  prefs: []
  type: TYPE_NORMAL
- en: A few more Sinon.JS test helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sinon.JS provides many useful tools beyond the core test double abstractions
    of spies, stubs, and mocks. We have already been introduced to the `sinon.test`
    wrapper in [Chapter 4](ch04.html "Chapter 4. Test Spies"), *Test Spies*, and will
    examine a few more equally convenient helpers in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some test helpers such as timers and servers may require the use of IE-specific
    Sinon.JS libraries when used with the Internet Explorer web browser. See the relevant
    Sinon.JS documentation sections for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Fake timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sinon.JS can patch time and date intervals to help manage asynchronous events
    and callbacks in tests. Sinon.JS fake timers override native JavaScript functions,
    such as `setTimeout` and the `Date` class. Once faked, test code must manually
    advance the time through the API `tick(ms)` function that simulates the passage
    of time for any time-based asynchronous event in the program. See [http://sinonjs.org/docs/#clock](http://sinonjs.org/docs/#clock)
    for the full API reference.
  prefs: []
  type: TYPE_NORMAL
- en: Fake timers are quite useful for testing Backbone.js applications. For example,
    if some UI code has a delayed jQuery effect that is taking 200 milliseconds to
    complete, a test including this behavior would have to wait for that amount of
    time, slowing down the overall test suite. Additionally, timers in native JavaScript
    are not completely predictable. (See, for example, *Accuracy of JavaScript Time*
    by *John Resig* at [http://ejohn.org/blog/accuracy-of-javascript-time](http://ejohn.org/blog/accuracy-of-javascript-time).)
    Using Sinon.JS fake timers, we can *synchronously* and *predictably* simulate
    the advancement of 200 milliseconds for the jQuery effect without any delays in
    a test.
  prefs: []
  type: TYPE_NORMAL
- en: Fake servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sinon.JS can also patch some of the communication internals of a program and
    override the **XMLHttpRequest** (**XHR**) and other related mechanisms. A typical
    Backbone.js application uses XHR to synchronize models and collections to a backend
    datastore, such as a database or a cloud service, making this feature particularly
    relevant to our test infrastructure. The entire range of XHR faking capabilities
    provided by Sinon.JS are discussed at [http://sinonjs.org/docs/#server](http://sinonjs.org/docs/#server).
  prefs: []
  type: TYPE_NORMAL
- en: The fake server API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first API that Sinon.JS provides is `FakeXMLHttpRequest`; this is a low-level
    abstraction around the XHR interface that provides fine-grained control over requests,
    responses, headers, and other details. See [http://sinonjs.org/docs/#FakeXMLHttpRequest](http://sinonjs.org/docs/#FakeXMLHttpRequest)
    for a complete API listing.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS additionally provides a higher-level API in the form of a fake server
    that provides a much easier interface for common use cases in modern JavaScript
    web applications. We will use the latter interface in this chapter as the simpler
    interface is still well suited to our Backbone.js application testing needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sinon.JS fake server API documentation is available at [http://sinonjs.org/docs/#fakeServer](http://sinonjs.org/docs/#fakeServer).
    A useful subset of the API includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sinon.fakeServer.create()`: This creates a fake server object and fakes the
    XHR interface for tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.respondWith(response)`: This configures the server to respond to all
    requests with a response object. A response can take various forms, but the one
    we will use is an array comprised of an HTTP status code, a dictionary of headers,
    and a JSON response string. The default response is `[404, {}, ""]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.respondWith(method, url, response)`: This configures the server to
    respond to requests matching the specified HTTP method and URL with a response
    object. There are further permutations of `respondWith` that can use regular expressions
    for URL matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.respond()`: After a server is configured and a test has started, any
    call to `respond()` will cause the fake server to immediately issue the prearranged
    response object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.autoRespond = true`: The fake server will automatically respond to
    server requests without the need to call `respond()`. By default, the fake server
    will wait 10 milliseconds before responding. A different wait time can be assigned
    to the `server.autoRespondAfter` configuration variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server.restore()`: This unwinds the fake XHR interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faking the remote backend in a Backbone.js application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Notes application that we have presented in this book does not have an external
    backend and relies instead on HTML5 localStorage to store collection data. While
    it is a useful teaching tool, most real-world Backbone.js applications do have
    a remote backing store. Accordingly, the companion code examples for this book
    include a version of Notes that is served as a Node.js Express ([http://expressjs.com](http://expressjs.com))
    application with a MongoDB ([http://www.mongodb.org](http://www.mongodb.org))
    backend database. You can find the full application and its test suite in the
    `notes-rest/` directory of the code examples repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between the localStorage-backed `notes/app` and MongoDB-backed
    `notes-rest/app` Backbone.js applications is in the `App.Collections.Notes` collection
    implementation. The `notes-rest/app` version, available at `notes-rest/app/js/app-rest/collections/notes.js`,
    defines the collection class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The URL `/api/notes` points to a backend REST interface provided by the Node.js
    Express server (`notes-rest/server.js` in the code examples) that interacts with
    the MongoDB datastore.
  prefs: []
  type: TYPE_NORMAL
- en: Our tests for the new `App.Collections.Notes` collection will rely on a fake
    server to intercept all of the remote backend calls and replace the network responses
    with our desired test data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The collection tests in this section fake the entire backend, meaning that the
    tests don't use Node.js or MongoDB servers at all. This provides the advantage
    of the tests running extremely fast and giving us predictable responses. However,
    testing scenarios that seek to exercise the entire application (for example, full
    integration tests) may require that the test infrastructure run live on backend
    servers and/or datastores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the test suite file `notes-rest/test/js/spec-rest/collections/notes.spec.js`
    in the `beforeEach` setup call, we create an empty collection and a fake server
    that automatically responds to backend requests. The `afterEach` call restores
    the normal XHR operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following spec checks if the collection can fetch and populate data from
    the backend. We configure the fake server to respond to GET requests with JSON-serialized
    data for a single note. We then set a callback on the `reset` event to verify
    that the collection has the expected length and has deserialized the data into
    a note model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This spec illustrates the simple manner in which requests can be faked—we just
    make one `this.server.respondWith()` setup call for the specific faked URL and
    the Backbone.js collection is none the wiser that it is not really talking to
    a remote data store. For additional collection tests with Sinon.JS fake servers,
    see the rest of the `notes-rest/test/js/spec-rest/collections/notes.spec.js` file
    in the companion code samples for this book that can be run from the test driver
    page `notes-rest/test/test.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to apply Sinon.JS stubs, mocks, and other fakes
    to isolate Backbone.js components, reduce test complexity, and enhance predictable
    test behavior. We also finished all of the application tests that we will discuss
    in this book for the reference Notes application. Taking a moment to reflect upon
    our progress leading up to this point, we have now covered the basics of creating
    a test infrastructure and applying fundamental testing concepts to all of the
    various Backbone.js application components.
  prefs: []
  type: TYPE_NORMAL
- en: But, this is really just the beginning of the substantive testing journey; the
    tests presented in this book are a subset of those that would be desirable for
    a full production Backbone.js application. Our hope is that you now have the necessary
    tools, development techniques, and starting points to provide full test support
    for your Backbone.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will aim at extending our testing capabilities and use
    cases through test automation. We will move beyond manually running test suites
    in a local browser and introduce testing tools that can execute tests in different
    environments (such as the command line or a build server) and without a web browser.
  prefs: []
  type: TYPE_NORMAL
