- en: Chapter 5. Test Stubs and Mocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。测试存根和模拟
- en: With the integration of Sinon.JS into our test infrastructure, we now have deeper
    insight into the methods and actions within our Backbone.js application. As we
    turn to testing the remaining application components, we will move beyond merely
    *observing* methods during tests and actually *replace* method behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Sinon.JS 集成到我们的测试基础设施中，我们现在对 Backbone.js 应用程序中的方法和动作有了更深入的了解。当我们转向测试剩余的应用程序组件时，我们将超越在测试期间仅仅
    *观察* 方法，并实际上 *替换* 方法行为。
- en: 'Sinon.JS has us covered in this respect as well—the library provides solid
    support for functional behavior modifications. Specifically, we can leverage its
    powerful stub and mock abstractions to reduce Backbone.js component dependencies
    and cross-application side effects during testing. In this chapter, we will explore
    these and other Sinon.JS capabilities through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 在这方面也为我们提供了保障——该库为功能行为修改提供了坚实的支持。具体来说，我们可以利用其强大的存根和模拟抽象来减少 Backbone.js
    组件的依赖性和测试期间的跨应用程序副作用。在本章中，我们将通过以下主题来探索这些和其他 Sinon.JS 功能：
- en: Using Sinon.JS stubs to replace function behaviors and isolate Backbone.js components
    in tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 存根替换函数行为并在测试中隔离 Backbone.js 组件
- en: Introducing Sinon.JS mocks that spy, stub, and verify application behavior in
    a single abstraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Sinon.JS 模拟，它以单个抽象来监视、存根和验证应用程序行为
- en: Writing tests for the remaining components of our Backbone.js application and
    deciding on the proper Sinon.JS tools for the given test scenarios
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们 Backbone.js 应用程序的剩余组件编写测试，并决定给定测试场景中适当的 Sinon.JS 工具
- en: Investigating other contextually useful Sinon.JS test helpers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查其他上下文有用的 Sinon.JS 测试辅助工具
- en: Faking a remote backend server in Backbone.js collection tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Backbone.js 集合测试中伪造远程后端服务器
- en: Replacing method behaviors with Sinon.JS stubs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 存根替换方法行为
- en: We have been able to handle our Backbone.js testing dependencies so far with
    a combination of clever class design and some manual faking. However, we are quickly
    approaching a point where we need a more reliable and consistent approach.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够通过巧妙的设计类和一些手动伪造来处理我们的 Backbone.js 测试依赖项。然而，我们很快就会达到一个需要更可靠和一致的方法的点。
- en: 'We will look to stubs to provide a straightforward and predictable means of
    substituting method behaviors in any Backbone.js component to reduce unintended
    application side effects and dependency issues. The ability to temporarily replace
    existing methods during tests offers an enormous amount of flexibility, particularly
    in situations where:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻求使用存根提供一种简单直接且可预测的方法，以在任何 Backbone.js 组件中替换方法行为，从而减少意外的应用程序副作用和依赖问题。在测试期间临时替换现有方法的能力提供了巨大的灵活性，尤其是在以下情况下：
- en: A Backbone.js application is under early development and not all of the planned
    components exist. Stubs allow us to write a simulated equivalent of the missing
    functionality in tests that can later be removed when the real application code
    is written. Even after the application code has been implemented, stubs may still
    be appropriate for a subset of the original specs, depending on what type of behavior
    is being tested.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone.js 应用程序处于早期开发阶段，并非所有计划中的组件都已存在。存根允许我们在测试中编写缺失功能的模拟等效代码，这些代码在真实应用程序代码编写后可以删除。即使应用程序代码已经实现，存根仍然可能适用于原始规范的一部分，具体取决于正在测试的行为类型。
- en: An application code is sensitive to the timing of the UI and/or other events.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码对 UI 和/或其他事件的时机敏感。
- en: An application depends on external resources such as a database or cloud service.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序依赖于外部资源，如数据库或云服务。
- en: A Backbone.js component has application dependencies and/or interactions that
    are too complex to manually swap in tests and that must be faked internally.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone.js 组件具有过于复杂，无法手动在测试中交换的应用程序依赖性和/或交互。
- en: Getting started with stubs
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用存根
- en: 'To kick things off, let''s integrate some stubs into an object literal from
    the previous chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们将一些存根集成到上一章中的对象字面量中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the ensuing spec, we will show you two different ways to stub `obj.multiply()`
    with Sinon.JS. In the first call (`sinon.stub(obj, "multiply").returns(5)`), we
    use the `returns` method to always return a hardcoded value. The second stub takes
    an alternate approach that inserts a replacement function (that adds instead of
    multiplying). In both cases, we call `restore()` after the test finishes to keep
    `obj` from being permanently modified:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的规范中，我们将向您展示两种不同的方法使用 Sinon.JS 占位 `obj.multiply()`。在第一次调用（`sinon.stub(obj,
    "multiply").returns(5)`）中，我们使用 `returns` 方法始终返回一个硬编码的值。第二个占位符采用不同的方法，插入一个替换函数（而不是相乘）。在两种情况下，测试完成后都调用
    `restore()` 以防止 `obj` 被永久修改：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Turning our attention to `obj.error()` in the ensuing code snippet, we create
    an empty stub on the object method to prevent the real function from throwing
    an exception. We don''t need a replacement function or a `returns` value because
    we just want to *avoid* the default behavior. Additionally, we use the `sinon.test`
    sandbox helper to automatically call `restore()` on any stubs that were created
    within the test function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向接下来的代码片段中的 `obj.error()`，我们在对象方法上创建一个空的占位符以防止真实函数抛出异常。我们不需要替换函数或 `returns`
    值，因为我们只想 *避免* 默认行为。此外，我们使用 `sinon.test` 沙盒助手来自动在测试函数内部创建的任何占位符上调用 `restore()`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As illustrated in the previous code snippets, we can now easily replace arbitrary
    methods with different code and/or return values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们现在可以轻松地用不同的代码和/或返回值替换任意方法。
- en: The stub API
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 占位 API
- en: 'Sinon.JS stubs implement the entire spy API and provide additional methods
    that can swap existing application functions with new code and behaviors during
    our tests. The first step in stubbing is to create a stub object and potentially
    replace one or more object methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 占位符实现了整个间谍 API，并提供了一些额外的方法，可以在测试期间用新代码和行为替换现有的应用程序函数。占位的第一步是创建一个占位对象，并可能替换一个或多个对象方法：
- en: '`sinon.stub()`: This creates an anonymous stub without any specified behavior.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.stub()`: 这创建了一个没有指定行为的匿名占位符。'
- en: '`sinon.stub(obj, methodName)`: This stubs a single object''s method with an
    empty function. This alone is sufficient to replace the underlying code''s execution
    like we saw in the code with `obj.error()`. Alternatively, you can further call
    stub API methods to modify return, callback, or other behaviors of the stub.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.stub(obj, methodName)`: 这用一个空函数占位单个对象的方法。这本身就足以替换我们看到的 `obj.error()`
    代码中的底层代码执行。或者，您还可以进一步调用占位 API 方法来修改占位符的返回、回调或其他行为。'
- en: '`sinon.stub(obj, methodName, fn)`: This stubs a single object''s method with
    the replacement function provided in the `fn` parameter.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.stub(obj, methodName, fn)`: 这使用在 `fn` 参数中提供的替换函数占位单个对象的方法。'
- en: '`sinon.stub(obj)`: This replaces *all* the methods in an object with stubs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.stub(obj)`: 这将用占位符替换对象中的 *所有* 方法。'
- en: 'Once we have a stub object, we can enhance it with fake behaviors and responses
    as applicable in a given testing situation. Some of these methods are appropriate
    for synchronous (non-callback) function responses:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了占位对象，我们就可以根据给定的测试情况添加相应的伪造行为和响应。其中一些方法适用于同步（非回调）函数响应：
- en: '`stub.returns(obj)`: This stub will return the value `obj` when called.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.returns(obj)`: 当调用时，这个占位符将返回值 `obj`。'
- en: '`stub.throws()`: This stub will throw an `Error object` exception when called.
    A specific error will be used if `throws()` is called with a type string (for
    example, `"TypeError"`) or an error object (for example, `new TypeError()`).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.throws()`: 当调用时，这个占位符将抛出一个 `Error 对象` 异常。如果 `throws()` 被带有类型字符串（例如，`"TypeError"`）或错误对象（例如，`new
    TypeError()`）调用，将使用特定的错误。'
- en: 'Sinon.JS also supports asynchronous callbacks in stubbed methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 还支持在占位方法中异步回调：
- en: '`stub.yields(arg1, arg2, ...)`: The first parameter to the stubbed method must
    be a callback function that the stub will call with the parameters `arg1`, `arg2`,
    and so on. In the following code snippet, we''ll stub `obj.async()` and use `yield()`
    to inject the fake arguments `1` and `2` into the callback:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.yields(arg1, arg2, ...)`: 占位方法的第一参数必须是一个回调函数，占位符将使用参数 `arg1`、`arg2` 等调用该函数。在下面的代码片段中，我们将占位
    `obj.async()` 并使用 `yield()` 将伪造的参数 `1` 和 `2` 注入回调：'
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`stub.yieldsOn(context, arg1, arg2, ...)`: This is equivalent to `stub.yields()`,
    except that it also injects the `context` parameter as the special variable `this`
    when invoking the callback.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.yieldsOn(context, arg1, arg2, ...)`: 这与 `stub.yields()` 等效，除了它还会在调用回调时将
    `context` 参数作为特殊变量 `this` 注入。'
- en: '`stub.yieldsTo(property, arg1, arg2, ...)`: This is also similar to `stub.yields()`,
    except that the callback to the underlying method is expected to be an object
    with a property name matching the `property` parameter value.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.yieldsTo(property, arg1, arg2, ...)`: 这与 `stub.yields()` 方法类似，但期望的底层方法的回调是一个具有与
    `property` 参数值匹配的属性名的对象。'
- en: '`stub.yieldsToOn(property, context, arg1, arg2, ...)`: This is a combination
    of `stub.yieldsOn()` and `stub.yieldsTo()` that uses an object callback property
    and context variable.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.yieldsToOn(property, context, arg1, arg2, ...)`: 这是 `stub.yieldsOn()`
    和 `stub.yieldsTo()` 的组合，它使用一个对象回调属性和上下文变量。'
- en: '`stub.callsArgWith(index, arg1, arg2, ...)`: The `stub.yields*` collection
    of methods utilizes the *first* parameter of the stubbed method. However, asynchronous
    callbacks can occur in other parameter positions. The `stub.callsArgWith()` method
    allows us to specify the index of the callback parameter to be used and the arguments
    to be passed to the function.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.callsArgWith(index, arg1, arg2, ...)`: `stub.yields*` 方法集合利用了被模拟方法的第一个参数。然而，异步回调可能发生在其他参数位置。`stub.callsArgWith()`
    方法允许我们指定要使用的回调参数的索引以及传递给函数的参数。'
- en: '`stub.callsArg*`: In addition to `stub.callsArgWith()`, the methods `stub.callsArg(index)`,
    `stub.callsArgOn(index, context)`, and `stub.callsArgOnWith(index, context, arg1,
    arg2, ...)` take a first parameter named `index` that specifies the index of the
    callback to be invoked in the wrapped method and work in a manner analogous to
    their `yields*` counterparts mentioned previously.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stub.callsArg*`: 除了 `stub.callsArgWith()` 方法外，`stub.callsArg(index)`、`stub.callsArgOn(index,
    context)` 和 `stub.callsArgOnWith(index, context, arg1, arg2, ...)` 方法都接受一个名为 `index`
    的第一个参数，该参数指定了在包装方法中要调用的回调函数的索引，并且它们的工作方式与之前提到的 `yields*` 对应方法类似。'
- en: This set of stub features is sufficient to cover most Backbone.js testing situations.
    At the same time, it is worthwhile to review the full Sinon.JS stub API documentation
    ([http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs)) to learn about
    additional methods and helpers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这组桩功能足以覆盖大多数 Backbone.js 测试场景。同时，回顾完整的 Sinon.JS 桩 API 文档（[http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs)）以了解额外的方法和辅助工具是值得的。
- en: Faking and verifying behavior with Sinon.JS mocks
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 模拟进行行为伪造和验证
- en: The final test double abstraction that we will cover in this book is the test
    mock. Mocks replace function behaviors like stubs, observe method calls like spies
    and stubs, and additionally verify function behaviors. Essentially, mocks are
    a "one-stop shop" for faking and testing methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将要介绍的最后一个测试双重抽象是测试模拟（mock）。模拟可以替换桩（stubs）的功能，像间谍（spies）和桩一样观察方法调用，并且还可以验证函数行为。本质上，模拟是伪造和测试方法的“一站式”解决方案。
- en: Deciding when to mock
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定何时使用模拟
- en: 'So, when should we use mocks? The Sinon.JS mock API documentation ([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks))
    starts with the appropriate use cases for mocks:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该在何时使用模拟？Sinon.JS 模拟 API 文档（[http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks)）从模拟的适当使用案例开始：
- en: '"Mocks should only be used for the method under test. In every unit test, there
    should be one unit under test. If you want to control how your unit is being used
    and like stating expectations upfront (as opposed to asserting after the fact),
    use a mock."'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “模拟应该仅用于测试中的方法。在每次单元测试中，应该有一个单元正在被测试。如果你想控制你的单元是如何被使用的，并且喜欢提前声明期望（而不是事后断言），那么请使用模拟。”
- en: 'The documentation cautions that mocks should be *avoided* in many situations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文档警告说，在许多情况下应**避免**使用模拟：
- en: '"Mocks come with built-in expectations that may fail your test. Thus, they
    enforce implementation details. The rule of thumb is: if you wouldn''t add an
    assertion for some call specific, don''t mock it. Use a stub instead. In general
    you should never have more than one mock (possibly with several expectations)
    in a single test."'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “模拟内置了可能会使你的测试失败的期望。因此，它们强制实施实现细节。一般来说，如果你不会为某个特定的调用添加断言，那么不要模拟它。相反，使用桩。通常，你不应该在单个测试中拥有超过一个模拟（可能包含多个期望）。”
- en: 'We have a bias in this book towards Sinon.JS stubs for the reasons just discussed
    and because of the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书倾向于使用 Sinon.JS 模拟桩（stubs）的原因是前面讨论的，以及以下原因：
- en: The Chai and Sinon-Chai adapter libraries allow us to write test assertions
    on stubs that are concise, expressive, and readable
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai 和 Sinon-Chai 适配器库允许我们编写简洁、表达性强且易于阅读的桩测试断言。
- en: The Sinon.JS mock expectation API is less flexible than using Chai assertions
    against the stub API
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sinon.JS 模拟期望 API 比使用 Chai 断言对桩 API 的使用灵活性低。
- en: At the same time, mocks *are* stubs. So, tests can mix and match preprogrammed
    Sinon.JS mock expectations with subsequent Chai stub assertions. Ultimately, after
    we have finished reviewing the details of stubs and mocks in this chapter, we
    leave the choice of abstraction up to the developer and the specific testing scenario
    at hand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，模拟也是存根。因此，测试可以将预编程的Sinon.JS模拟期望与随后的Chai存根断言混合匹配。最终，在我们完成本章中存根和模拟的细节审查后，我们将抽象的选择留给开发者和具体的测试场景。
- en: The mock API
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟API
- en: 'Sinon.JS mocks ([http://sinonjs.org/docs/#mocks-api](http://sinonjs.org/docs/#mocks-api))
    implement the spy and stub APIs and additionally provide expectations that verify
    application behavior. We''ll begin with a brief discussion of the core mock methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS模拟([http://sinonjs.org/docs/#mocks-api](http://sinonjs.org/docs/#mocks-api))实现了间谍和存根API，并额外提供了验证应用程序行为的期望。我们将从对核心模拟方法的简要讨论开始：
- en: '`sinon.mock(obj)`: This method mocks all the methods of `obj` and returns a
    mock object'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.mock(obj)`: 这个方法模拟`obj`的所有方法，并返回一个模拟对象'
- en: '`mock.expects(methodName)`: This method creates an expectation for the specified
    method of the mocked object'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock.expects(methodName)`: 这个方法为模拟对象的指定方法创建一个期望'
- en: '`mock.verify()`: This method examines and verifies that all expectations were
    met and throws exceptions on assertion failures'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock.verify()`: 这个方法检查并验证是否所有期望都得到了满足，在断言失败时抛出异常'
- en: '`mock.restore()`: This method unwinds and removes all mocked modifications
    of the underlying object that is being tested'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock.restore()`: 这个方法撤销并移除正在测试的底层对象的所有模拟修改'
- en: 'After we have mocked an object, the usual workflow is to call `mock.expects()`
    on one or more methods and configure expectations for a `mock.verify()` call later.
    For the complete expectations list, see [http://sinonjs.org/docs/#expectations](http://sinonjs.org/docs/#expectations).
    A sampling of some useful expectation methods includes the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们模拟了一个对象之后，通常的工作流程是调用一个或多个方法的`mock.expects()`，并为后续的`mock.verify()`调用配置期望。对于完整的期望列表，请参阅[http://sinonjs.org/docs/#expectations](http://sinonjs.org/docs/#expectations)。一些有用的期望方法包括以下内容：
- en: '`expectation.atLeast(num)`, `expectation.atMost(num)`, and `expectation.exactly(num)`:
    These mocked methods should be called at least/at most/exactly `num` times respectively'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectation.atLeast(num)`, `expectation.atMost(num)`, 和 `expectation.exactly(num)`:
    这些模拟方法应该分别至少/最多/恰好被调用`num`次'
- en: '`expectation.never()`, `expectation.once()`, `expectation.twice()`, and `expectation.thrice()`:
    These are the helpers specifying common assertions for the number of times the
    mocked method was called'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectation.never()`, `expectation.once()`, `expectation.twice()`, 和 `expectation.thrice()`:
    这些是用于指定模拟方法被调用次数的常用断言辅助工具'
- en: '`expectation.withArgs(arg1, arg2, ...)` and `expectation.withExactArgs(arg1,
    arg2, ...)`: Every call to the mocked method has at least/exactly the parameters
    specified in the expectation respectively'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectation.withArgs(arg1, arg2, ...)` 和 `expectation.withExactArgs(arg1,
    arg2, ...)`: 每次对模拟方法的调用至少/恰好包含期望中指定的参数'
- en: '`expectation.on(obj)`: This mocked method should be called with `obj` as the
    context (`this`) variable'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectation.on(obj)`: 这个模拟方法应该以`obj`作为上下文（`this`）变量被调用'
- en: '`expectation.verify()`: This method runs assertions on a specific expectation
    (as opposed to `mock.verify()` that confirms *all* expectations)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectation.verify()`: 这个方法对特定的期望运行断言（与`mock.verify()`不同，后者确认*所有*期望）'
- en: 'In the following code snippet, we create our `mock` object around `obj` and
    declare the expectation that `multiply` will be called two to four times and that
    the first argument to every call will be `2`. We then call `multiply` three times
    with the appropriate parameters. Finally, a single `mock.verify()` call checks
    if all of the mock expectations were met:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们在`obj`周围创建我们的`mock`对象，并声明期望`multiply`将被调用两次到四次，并且每次调用的第一个参数将是`2`。然后我们使用适当的参数三次调用`multiply`。最后，一个单独的`mock.verify()`调用检查是否所有模拟期望都得到了满足：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing Backbone.js components with stubs and mocks
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根和模拟测试Backbone.js组件
- en: 'With the addition of stubs and mocks to our test infrastructure, we are ready
    to tackle the remaining components of our Backbone.js application that we will
    cover in this book: the `App.Views.NotesItem` view and the `App.Routers.Router`
    router. For those following along in the code examples, we will integrate the
    specs for these application components into the test driver page `chapters/05/test/test.html`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在将存根和模拟添加到我们的测试基础设施后，我们准备好处理本书中将要涵盖的Backbone.js应用程序的剩余组件：`App.Views.NotesItem`视图和`App.Routers.Router`路由器。对于跟随代码示例的开发者，我们将将这些应用程序组件的规范集成到测试驱动页面`chapters/05/test/test.html`中。
- en: Ensuring stubs and mocks are actually bound
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保存根和模拟实际上已绑定
- en: One preliminary Sinon.JS issue that can trip up developers is making sure that
    spies, stubs, and mocks are actually bound to the expected methods of a Backbone.js
    application object during a test.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS的一个初步问题可能会让开发者感到困惑，那就是确保在测试期间间谍、存根和模拟实际上绑定到了Backbone.js应用程序对象预期的方法上。
- en: 'Let''s start with a simple Backbone.js view named `MyView`. The view has a
    custom method named `foo()` that is bound to two event listeners, `wrapped` and
    `unwrapped`. The listeners are functionally equivalent, except that `wrapped`
    wraps the call in a function (`function () { this.foo(); }`) while `unwrapped`
    binds the real (or "naked") `this.foo` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的Backbone.js视图`MyView`开始。该视图有一个名为`foo()`的自定义方法，该方法绑定到两个事件监听器，`wrapped`和`unwrapped`。这两个监听器在功能上是等效的，除了`wrapped`将调用包裹在一个函数中（`function
    () { this.foo(); }`），而`unwrapped`绑定的是真正的（或“裸露的”）`this.foo`方法：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although quite similar, the event listeners have an important difference when
    using Sinon.JS fakes; once `initialize()` is called, naked method references,
    such as the one passed to `unwrapped`, cannot be faked by Sinon.JS later. The
    underlying reason is that Sinon.JS can only change properties on the view object
    and not on the direct method references.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常相似，但在使用Sinon.JS伪造时，事件监听器有一个重要的区别；一旦调用`initialize()`，裸露的方法引用，如传递给`unwrapped`的，就不能被Sinon.JS后来伪造。其根本原因在于Sinon.JS只能更改视图对象上的属性，而不能直接更改方法引用。
- en: 'Let''s examine a test that instantiates a `MyView` object and then stubs `foo`.
    When we trigger the `wrapped` listener, our stub is called and returns the faked
    value `I''m fake`. However, triggering the `unwrapped` listener never calls the
    stub and invokes the *real* `foo` method instead. Note that we use the Sinon.JS
    `reset()` method to clear out any recorded function call information and return
    a spy, stub, or mock to its original state:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个实例化`MyView`对象并随后对`foo`进行存根的测试。当我们触发`wrapped`监听器时，我们的存根被调用并返回伪造的值`I'm
    fake`。然而，触发`unwrapped`监听器从未调用存根，而是调用了真正的`foo`方法。注意，我们使用Sinon.JS的`reset()`方法清除任何记录的函数调用信息，并将间谍、存根或模拟恢复到其原始状态：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One solution to the issue is to stub *before* the object is instantiated. In
    the following code snippet, creating the stub *before* the call to `new MyView()`
    correctly hooks the stub into both the `wrapped` and `unwrapped` listeners:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是在对象实例化之前进行存根。在下面的代码片段中，在调用`new MyView()`之前创建存根，正确地将存根连接到了`wrapped`和`unwrapped`监听器：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is fairly straightforward to keep track of the order in which Backbone.js
    objects are initialized and stubbed for a single test, such as in the previous
    two code snippets. However, it is important to keep binding in mind for a test
    suite setup and teardown, especially when an object is instantiated in a different
    place from where it will later be mocked or stubbed. Additionally, the issue can
    manifest in various other places in Backbone.js applications, such as in the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个测试，如前两个代码片段所示，跟踪Backbone.js对象初始化和存根的顺序相对简单。然而，在测试套件的设置和清理过程中，特别是当对象在稍后模拟或存根的地方实例化时，保持绑定是很重要的。此外，这个问题可以在Backbone.js应用程序的多个地方体现出来，如下所示：
- en: '**View events**: Views can declare an `events` property that binds UI events
    to methods by the string name of the method. This internally behaves similar to
    a naked function reference when a new view object is initialized by Backbone.js.
    An example of this type of declaration is as follows:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图事件**：视图可以声明一个`events`属性，通过方法的字符串名称将UI事件绑定到方法。当Backbone.js初始化新的视图对象时，这内部表现得类似于裸露的函数引用。以下是一个此类声明的示例：'
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Router routes**: Similarly, routers typically declare a `routes` property
    that binds hash/URL fragments to named methods on the router object.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器路由**：类似地，路由器通常声明一个`routes`属性，将哈希/URL片段绑定到路由器对象上的命名方法。'
- en: The most important takeaway point is to always consider how a Sinon.JS fake
    will be bound to the Backbone.js component that is being tested. It is sometimes
    easier to avoid naked function references in a Backbone.js application component,
    and at other times, it is better to reformulate test code so that stubs can be
    bound before the component is initialized. In the Notes application, we will use
    both of the approaches for the remaining tests in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是始终考虑如何将Sinon.JS存根绑定到正在测试的Backbone.js组件。有时在Backbone.js应用组件中避免裸函数引用可能更容易，而在其他时候，最好重新编写测试代码，以便在组件初始化之前绑定存根。在笔记应用中，我们将在这章剩余的测试中使用这两种方法。
- en: The Notes list item view
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记列表项视图
- en: 'The last Notes view that we will discuss and test in this book is the list
    item view. When a user navigates to the home page of the Notes application, they
    are presented with a list of notes identified by their titles. The `App.Views.NotesItem`
    view is responsible for rendering each individual note row and allowing a user
    to view, edit, or delete a note. The following screenshot illustrates the rendered
    output for a single list item view:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们将讨论和测试的最后一个笔记视图是列表项视图。当用户导航到笔记应用的首页时，他们会被展示一个以标题标识的笔记列表。`App.Views.NotesItem`视图负责渲染每个单独的笔记行，并允许用户查看、编辑或删除笔记。以下截图展示了单个列表项视图的渲染输出：
- en: '![The Notes list item view](img/5248OS_05_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![笔记列表项视图](img/5248OS_05_01.jpg)'
- en: Notes list item view
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记列表项视图
- en: The title text of a list item can be clicked on to view the rendered Markdown
    for a single note. A list item also contains two action buttons, one with a pencil
    icon for editing and the other with a trash can icon for deleting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项的标题文本可以点击以查看单个笔记的渲染Markdown。列表项还包含两个操作按钮，一个带有铅笔图标用于编辑，另一个带有垃圾桶图标用于删除。
- en: 'The list item template string is declared as the `template-notes-item` property
    of `App.Templates` in `notes/app/js/app/templates/templates.js`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项模板字符串在`notes/app/js/app/templates/templates.js`中的`App.Templates`的`template-notes-item`属性中声明：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The template renders two `td` cells within a table row, one for the note title
    and the other for the edit/delete buttons.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在表格行内渲染两个`td`单元格，一个用于笔记标题，另一个用于编辑/删除按钮。
- en: The list item view
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表项视图
- en: 'The `App.Views.NotesItem` view is defined in `notes/app/js/app/views/notes-list.js`.
    The class definition starts with DOM attributes for rendering a `tr` tag, a `notes-item`
    class, and an `id` property that corresponds to the note model''s identifier:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.NotesItem`视图在`notes/app/js/app/views/notes-list.js`中定义。类定义从用于渲染`tr`标签的DOM属性开始，一个`notes-item`类和一个与笔记模型标识符对应的`id`属性：'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Click events on a list item''s title and edit/delete buttons are bound to their
    respective view methods, `viewNote`, `editNote`, and `deleteNote`. In terms of
    our earlier Sinon.JS binding discussion, note that all of the event callbacks
    have function wrappers that allow us to create `App.Views.NotesItem` objects that
    can be stubbed at any time during the tests:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项的标题和编辑/删除按钮上的点击事件绑定到它们各自的方法，即`viewNote`、`editNote`和`deleteNote`。就我们之前关于Sinon.JS绑定的讨论而言，请注意所有的事件回调都有函数包装器，这允许我们在测试期间任何时候创建可以被存根的`App.Views.NotesItem`对象：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `initialize`, the view stores a router reference and sets listeners that
    re-render or remove the view in response to model events. The `render` method
    binds the model data to the template in a fairly conventional manner:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`方法中，视图存储了一个路由引用，并设置了监听器，以响应模型事件重新渲染或删除视图。`render`方法以相当传统的方式将模型数据绑定到模板：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Turning to the actions we can perform on a single list item, the `viewNote`
    and `editNote` methods navigate to a single-note view in viewing or editing mode.
    The `deleteNote` function deletes the underlying note model that then triggers
    events that will clean up and remove the view from the list of all notes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 转到单个列表项可以执行的操作，`viewNote`和`editNote`方法在查看或编辑模式下导航到单个笔记视图。`deleteNote`函数删除底层的笔记模型，然后触发事件，清理并从所有笔记列表中删除视图：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testing the list item view
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试列表项视图
- en: 'The `App.Views.NotesItem` view behaviors that we wish to verify in our test
    suite file `chapters/05/test/js/spec/views/notes-item.spec.js` include the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在测试套件文件`chapters/05/test/js/spec/views/notes-item.spec.js`中验证的`App.Views.NotesItem`视图行为包括以下内容：
- en: The view renders HTML for a single row in the notes list table and shows the
    note's title and the action buttons
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图渲染笔记列表表中的单行HTML，并显示笔记的标题和操作按钮
- en: It binds click events to the appropriate note actions (for example, edit) and
    navigates to the appropriate single note page to read or edit a note
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将点击事件绑定到适当的笔记操作（例如，编辑）并导航到适当的单个笔记页面以阅读或编辑笔记
- en: It correctly cleans up the object state when a user deletes a note
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户删除笔记时，它正确地清理了对象状态
- en: The test suite starts with the `before()` setup method where we create an `App.Views.NotesItem`
    object with a fake router object literal (containing a `navigate` stub) and a
    real `App.Models.Note` model. In the `afterEach()` method, we reset the `navigate`
    stub so that each spec gets a stub that is free of any previously recorded function
    information. The `after()` teardown function removes the view under test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件从 `before()` 设置方法开始，我们在其中创建了一个 `App.Views.NotesItem` 对象，该对象包含一个假的具有 `navigate`
    存根的路由器对象字面量（包含一个 `navigate` 存根）和一个真实的 `App.Models.Note` 模型。在 `afterEach()` 方法中，我们重置
    `navigate` 存根，以便每个规范都得到一个没有之前记录的函数信息的存根。`after()` 清理函数移除正在测试的视图。
- en: 'Again, keeping the Sinon.JS method''s binding issues in mind, we note that
    `this.view` is created in the `before()` setup for the entire test suite. This
    means that stubs, spies, and/or mocks will only work on wrapped `App.Views.NotesItem`
    view methods. At the same time, if the existing `App.Views.NotesItem` suite is
    not amenable to all of the test double bindings that we need, we can easily create
    an additional suite that fakes the class prototype before instantiation, to provide
    additional flexibility in testing the desired application behavior:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，考虑到 Sinon.JS 方法中的绑定问题，我们注意到 `this.view` 是在 `before()` 设置中为整个测试套件创建的。这意味着存根、间谍和/或模拟将仅适用于包装的
    `App.Views.NotesItem` 视图方法。同时，如果现有的 `App.Views.NotesItem` 测试套件不适合我们需要的所有测试双倍绑定，我们可以轻松地创建一个额外的套件，在实例化之前模拟类原型，以在测试所需的应用程序行为时提供额外的灵活性：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first nested test suite checks whether the underlying model''s `destroy`
    event triggers the `view.remove()` method, cleaning up the view. We stub `view.remove()`
    to prevent the view from actually being removed from the test environment when
    called. Then, we trigger the desired model event so that we can verify that the
    stub was called once:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个嵌套测试套件检查底层模型的 `destroy` 事件是否触发 `view.remove()` 方法，清理视图。我们存根 `view.remove()`
    以防止在调用时实际从测试环境中移除视图。然后，我们触发所需的模型事件，以便我们可以验证存根被调用了一次：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the next two specs, we tackle an analogous scenario, verifying that the
    note model''s `change` event will trigger a `render()` call on the view. We make
    the same assertions in both the specs, using stubs in one and mocks in the other
    to demonstrate how to write the same functional spec using either abstraction.
    The spec `renders on model change w/ stub` uses a stub to verify the view''s behavior:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个规范中，我们处理了一个类似场景，验证笔记模型的 `change` 事件将触发视图上的 `render()` 调用。我们在两个规范中都做出相同的断言，在一个规范中使用存根，在另一个规范中使用模拟来展示如何使用任何抽象编写相同的函数规范。`renders
    on model change w/ stub` 规范使用存根来验证视图的行为：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `renders on model change w/ mock` spec, we rely on a mock to make the
    same assertion using the Sinon.JS `once()` expectation modifier and `mock.verify()`
    instead of Chai assertions on a stub:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `renders on model change w/ mock` 规范中，我们依赖于模拟，使用 Sinon.JS 的 `once()` 预期修改器和
    `mock.verify()` 来做出相同的断言，而不是在存根上使用 Chai 断言：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the next two specs, we examine the scenarios in which a user clicks on the
    list item title (for viewing) or the pencil button (for editing). We need to check
    if both the clicks call an appropriate view function and cause the router to navigate
    us to the expected single-note page. In the ensuing code snippet, we verify this
    behavior by asserting that the router''s `navigate` stub has been called with
    appropriate arguments:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个规范中，我们检查用户点击列表项标题（用于查看）或铅笔按钮（用于编辑）的场景。我们需要检查这两个点击是否调用适当的视图函数并导致路由器导航到预期的单个笔记页面。在随后的代码片段中，我们通过断言路由器的
    `navigate` 存根已用适当的参数调用来验证此行为：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we ensure that clicking on the trash can button triggers the underlying
    note model to be destroyed. We stub the model''s `destroy` method to verify that
    it was called and to prevent the model from actually being mutated:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保点击垃圾桶按钮会触发底层笔记模型被销毁。我们存根模型的 `destroy` 方法以验证它被调用，并防止模型实际被修改：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All in all, our tests for `App.Views.NotesItem` demonstrate how replacing method
    behaviors with mocks and stubs can simplify our tests and limit the program method's
    side effects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们对 `App.Views.NotesItem` 的测试展示了如何用模拟和存根替换方法行为，从而简化我们的测试并限制程序方法的副作用。
- en: The Notes application router
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记应用程序路由器
- en: The final Backbone.js component that we will test in the Notes application is
    the router, `App.Routers.Router`. The router is responsible for managing client-side
    page locations (URLs or hash fragments) and binding routes to views, events, and
    actions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Notes应用程序中测试的最后一个Backbone.js组件是路由器，`App.Routers.Router`。路由器负责管理客户端页面位置（URL或hash片段）并将路由绑定到视图、事件和动作。
- en: For the purposes of this chapter, we will use a simplified version of the `App.Routers.Router`
    class, available at `chapters/05/test/js/spec/routers/router.js`, instead of the
    real Notes router file (found in the code samples at `notes/app/js/app/routers/router.js`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将使用`chapters/05/test/js/spec/routers/router.js`中可用的`App.Routers.Router`类的简化版本，而不是真实的笔记路由文件（在`notes/app/js/app/routers/router.js`中的代码示例中找到）。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While the real Backbone.js router is not the most complex beast, it has sufficiently
    complicated dependencies and application logic to warrant omitting the full implementation
    in the text of this chapter, particularly when we just need to introduce a few
    testing tips for routers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然真实的Backbone.js路由器不是最复杂的生物，但它有足够的复杂依赖和应用逻辑，足以在文本中省略完整实现，尤其是在我们只需要介绍一些路由器的测试技巧时。
- en: At the same time, we don't shy away from tests just because we have component
    dependencies. Accordingly, we provide a comprehensive test suite for the real
    `App.Routers.Router` component in the code samples at `notes/test/js/spec/routers/router.spec.js`.
    You are encouraged to review the implementations of the full router and its corresponding
    test suite.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们不会因为存在组件依赖而回避测试。因此，我们在代码示例的`notes/test/js/spec/routers/router.spec.js`中为真实的`App.Routers.Router`组件提供了一个全面的测试套件。我们鼓励您审查完整路由及其相应的测试套件的实现。
- en: 'The Notes application contains two routes corresponding to the notes list page
    and the single-note page. We encompass this behavior in the simplified `App.Routers.Router`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Notes应用程序包含两个路由，分别对应笔记列表页面和单个笔记页面。我们在简化的`App.Routers.Router`类中包含这种行为：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our tests should check if the route specifications bind to the correct router
    methods and if the URLs / hash fragments are correctly parsed into parameters
    for the router method. We verify this behavior in the test suite file `chapters/05/test/js/spec/routers/router.spec.js`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试应该检查路由规范是否绑定到正确的路由器方法，以及URL / hash片段是否正确解析为路由器方法的参数。我们在测试套件文件`chapters/05/test/js/spec/routers/router.spec.js`中验证这种行为。
- en: Our setup logic begins by creating stubs around the router's `note` and `notes`
    methods. We then instantiate a router object and start history (which enables
    actual routing). Our setup concludes with binding an anonymous spy to every `route`
    event (fired any time a route is activated).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置逻辑首先在路由器的`note`和`notes`方法周围创建占位符。然后我们实例化一个路由器对象并启动历史记录（这启用了实际的路由）。我们的设置以将匿名间谍绑定到每个`route`事件（在任何路由被激活时触发）结束。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always on the lookout for Sinon.JS binding issues, note that we have to stub
    the router prototype *before* we instantiate a router object because the router
    object's `routes` property binds routes to method name strings and not to wrapped
    functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总是关注Sinon.JS绑定问题，请注意，我们必须在实例化路由器对象之前占位路由器原型，因为路由器对象的`routes`属性将路由绑定到方法名字符串，而不是到包装函数。
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our teardown logic stops the history and unwinds the stubs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拆解逻辑会停止历史记录并回滚占位符：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first spec checks if we can navigate to a single note to edit it by calling
    the router''s `navigate` method on the desired route `"note/1/edit"`. We assert
    that this calls the router''s `note` method (which we have stubbed) with the extracted
    parameters `"1"` and `"edit"`. We also confirm the same type of information with
    the `routerSpy` event listener:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规范检查我们是否可以通过在期望的路由`"note/1/edit"`上调用路由器的`navigate`方法来导航到单个笔记进行编辑。我们断言这调用了我们占位符的`note`方法（我们已占位）并带有提取的参数`"1"`和`"edit"`。我们还通过`routerSpy`事件监听器确认相同类型的信息：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our second spec verifies that we can navigate to the home page, then to a single-note
    page, and then back to the home page. We use similar verification logic as in
    the previous spec, relying on the `notes` stub (called twice on the `""` home
    page route) and the `routerSpy` spy (called on all three routes):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个规范验证我们是否可以导航到主页，然后导航到单个笔记页面，然后返回主页。我们使用与上一个规范类似的验证逻辑，依赖于`notes`占位符（在`""`主页路由上调用两次）和`routerSpy`间谍（在所有三个路由上调用）：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These router tests are not that different from Backbone.js view tests for events—both
    of them bind strings (a route or a UI event) to component methods (via a string
    name or function). All in all, the Sinon.JS mocking and stubbing methods we have
    learned in this chapter should generally apply to any type of Backbone.js component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由测试与 Backbone.js 视图测试中的事件测试并没有太大的不同——两者都将字符串（一个路由或一个 UI 事件）绑定到组件方法（通过字符串名称或函数）。总的来说，我们在本章中学到的
    Sinon.JS 模拟和存根方法通常适用于任何类型的 Backbone.js 组件。
- en: Running the view and router tests
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行视图和路由测试
- en: 'Now that we have test suites for `App.Views.NotesItem` and `App.Routers.Router`,
    we can integrate them into a test driver page. Building on the previous `chapters/04/test/test.html`
    driver page (with a few highlighted additions), our final driver page `chapters/05/test/test.html`
    includes the following relevant parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `App.Views.NotesItem` 和 `App.Routers.Router` 的测试套件，我们可以将它们集成到一个测试驱动页面上。在之前的
    `chapters/04/test/test.html` 驱动页面上（增加了一些突出显示的内容），我们的最终驱动页面 `chapters/05/test/test.html`
    包含以下相关部分：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At this point, we have accrued a large number of JavaScript files between the
    vendor libraries and our Backbone.js application components. While this is acceptable
    for tests (and sometimes even desired), it is good practice to concatenate and
    optimize your JavaScript files in production applications with a tool such as
    the Google Closure Compiler ([https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/))
    or UglifyJS ([https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在供应商库和我们的 Backbone.js 应用程序组件之间积累了大量 JavaScript 文件。虽然这对于测试（有时甚至是被期望的）是可以接受的，但在生产应用程序中使用像
    Google Closure Compiler ([https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/))
    或 UglifyJS ([https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2))
    这样的工具来连接和优化 JavaScript 文件是一种良好的实践。
- en: We can now navigate a browser window to `chapters/05/test/test.html` to run
    the tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导航到浏览器窗口中的 `chapters/05/test/test.html` 来运行测试。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running the report from the code samples, a few extra view specs
    that have not been discussed in this book will appear in the results.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从代码示例中运行报告，结果中会出现一些本书未讨论的额外视图规范。
- en: One thing you may notice is that invocations of the `navigate` method in the
    router tests actually modify the browser location, adding hash fragments. While
    this doesn't affect the correctness of our tests, it is a bit unexpected. Taking
    an alternative approach, the Backbone.js library test suite gets around this issue
    by creating a fake `Location` object to substitute for the real browser navigation
    bar. See [https://github.com/documentcloud/backbone/blob/master/test/router.js](https://github.com/documentcloud/backbone/blob/master/test/router.js)
    for further details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在路由测试中对 `navigate` 方法的调用实际上修改了浏览器位置，添加了哈希片段。虽然这不会影响测试的正确性，但这有点出乎意料。采用另一种方法，Backbone.js
    库测试套件通过创建一个假的 `Location` 对象来替代真实的浏览器导航栏，从而绕过这个问题。有关更多详细信息，请参阅 [https://github.com/documentcloud/backbone/blob/master/test/router.js](https://github.com/documentcloud/backbone/blob/master/test/router.js)。
- en: Finding the rest of the Notes application components
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 Notes 应用程序的其余组件
- en: With the previous view and router tests completed, we are now finished with
    the application and test code that we will present in this book for the localStorage-based
    Notes application. There are, however, a few more parts of the Notes application
    that we simply do not have room to discuss within the confines of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成之前的视图和路由测试后，我们现在已经完成了将在本书中展示的基于 localStorage 的 Notes 应用程序的应用程序和测试代码。然而，Notes
    应用程序中还有一些其他部分，我们无法在本书的范围内进行讨论。
- en: 'Fortunately, each of the components (as well as their relevant test files)
    are available as part of the downloadable code samples for this book. The remaining
    parts of the Notes application that you can find in the samples are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，每个组件（以及它们的相关测试文件）都可以作为本书可下载代码示例的一部分找到。在示例中可以找到的 Notes 应用程序的其余部分如下：
- en: '`App.Views.NotesFilter` (`notes/app/js/app/views/notes-filter.js`): This view
    controls the filter input box and the visibility of the note rows in the displayed
    list of notes. The test file for this view can be found at `notes/test/js/spec/views/notes-filter.spec.js`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.Views.NotesFilter` (`notes/app/js/app/views/notes-filter.js`): 这个视图控制过滤输入框和显示的笔记列表中笔记行的可见性。这个视图的测试文件可以在
    `notes/test/js/spec/views/notes-filter.spec.js` 中找到。'
- en: '`App.Views.Notes` (`notes/app/js/app/views/notes.js`): The `App.Views.Notes`
    view contains the `App.Views.NotesItem` and `App.Views.NotesFilter` views and
    is responsible for getting note data from the collection and for rendering a full
    list of notes. The corresponding test file is located at `notes/test/js/spec/views/notes.spec.js`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.Views.Notes` (`notes/app/js/app/views/notes.js`): `App.Views.Notes` 视图包含
    `App.Views.NotesItem` 和 `App.Views.NotesFilter` 视图，负责从集合中获取笔记数据并渲染笔记的完整列表。相应的测试文件位于
    `notes/test/js/spec/views/notes.spec.js`。'
- en: '`App.Routers.Router` (`notes/app/js/app/routers/router.js`): This is the full
    implementation of the Backbone.js router for Notes. Its test file is available
    at `notes/test/js/spec/routers/router.spec.js`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.Routers.Router` (`notes/app/js/app/routers/router.js`): 这是 Notes 的 Backbone.js
    路由的完整实现。其测试文件可在 `notes/test/js/spec/routers/router.spec.js` 中找到。'
- en: '`app` (`notes/app/js/app/app.js`): The `app` object controls the overall Notes
    application. It instantiates all of the top-level application components; for
    example, the `App.Views.Notes` view, the `App.Routers.Router` router, and the
    `App.Collections.Notes` collection. It also kicks off an initial collection `fetch`
    to import existing notes data. We do not include specs for this file, as creating
    and starting an actual application is usually encompassed within the scope of
    full integration testing—an approach we mentioned in [Chapter 2](ch02.html "Chapter 2. Creating
    a Backbone.js Application Test Plan"), *Creating a Backbone.js Application Test
    Plan*, which you are encouraged to learn outside of this book.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` (`notes/app/js/app/app.js`): `app` 对象控制 Notes 应用程序的整体功能。它实例化所有顶级应用程序组件；例如，`App.Views.Notes`
    视图、`App.Routers.Router` 路由器和 `App.Collections.Notes` 集合。它还启动一个初始集合 `fetch` 操作以导入现有的笔记数据。我们不为此文件包含规范，因为创建和启动实际应用程序通常包含在完整集成测试的范围内——这是我们提到的
    [第 2 章](ch02.html "第 2 章。创建 Backbone.js 应用程序测试计划")，*创建 Backbone.js 应用程序测试计划*，我们鼓励您在本书之外学习。'
- en: '`notes/test/test.html`: This is the test driver page for all the Notes application
    test suites and specs. This page aggregates all of the Notes specs we have discussed
    in this book as well as the specs for omitted views, and the full router implementation.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes/test/test.html`: 这是所有 Notes 应用程序测试套件和规范的测试驱动页面。此页面汇总了我们在本书中讨论的所有 Notes
    规范以及省略的视图的规范，以及完整的路由实现。'
- en: These extra files apply the fundamental lessons we have learned throughout this
    book to different application code and scenarios. Thus, reviewing the remaining
    Notes application files will provide you with a much better picture of a full
    Backbone.js application and test infrastructure that follows the testing principles
    we suggest. All in all, we hope that the code samples will send home the topics
    we have covered in this book and possibly give you some ideas and next steps for
    your test development education.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的文件将我们在本书中学到的基本原理应用于不同的应用程序代码和场景。因此，审查剩余的 Notes 应用程序文件将为您提供一个更全面的 Backbone.js
    应用程序和测试基础设施的图景，该基础设施遵循我们建议的测试原则。总的来说，我们希望这些代码示例能够传达本书中涵盖的主题，并可能为您在测试开发教育中提供一些想法和下一步行动。
- en: A few more Sinon.JS test helpers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Sinon.JS 测试辅助工具
- en: Sinon.JS provides many useful tools beyond the core test double abstractions
    of spies, stubs, and mocks. We have already been introduced to the `sinon.test`
    wrapper in [Chapter 4](ch04.html "Chapter 4. Test Spies"), *Test Spies*, and will
    examine a few more equally convenient helpers in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 提供了许多有用的工具，超出了核心测试替身抽象（间谍、存根和模拟）。我们已经在 [第 4 章](ch04.html "第 4 章。测试间谍")
    中介绍了 `sinon.test` 包装器，*测试间谍*，本章我们将探讨一些同样方便的辅助工具。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some test helpers such as timers and servers may require the use of IE-specific
    Sinon.JS libraries when used with the Internet Explorer web browser. See the relevant
    Sinon.JS documentation sections for more details.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试辅助工具，如计时器和服务器，在使用 Internet Explorer 网络浏览器时可能需要使用 IE 特定的 Sinon.JS 库。有关更多详细信息，请参阅相关的
    Sinon.JS 文档部分。
- en: Fake timers
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟计时器
- en: Sinon.JS can patch time and date intervals to help manage asynchronous events
    and callbacks in tests. Sinon.JS fake timers override native JavaScript functions,
    such as `setTimeout` and the `Date` class. Once faked, test code must manually
    advance the time through the API `tick(ms)` function that simulates the passage
    of time for any time-based asynchronous event in the program. See [http://sinonjs.org/docs/#clock](http://sinonjs.org/docs/#clock)
    for the full API reference.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 可以修补时间和日期间隔，以帮助在测试中管理异步事件和回调。Sinon.JS 伪造计时器覆盖了原生 JavaScript 函数，如 `setTimeout`
    和 `Date` 类。一旦伪造，测试代码必须通过 API `tick(ms)` 函数手动推进时间，该函数模拟程序中任何基于时间的异步事件的时间流逝。有关完整
    API 参考，请参阅 [http://sinonjs.org/docs/#clock](http://sinonjs.org/docs/#clock)。
- en: Fake timers are quite useful for testing Backbone.js applications. For example,
    if some UI code has a delayed jQuery effect that is taking 200 milliseconds to
    complete, a test including this behavior would have to wait for that amount of
    time, slowing down the overall test suite. Additionally, timers in native JavaScript
    are not completely predictable. (See, for example, *Accuracy of JavaScript Time*
    by *John Resig* at [http://ejohn.org/blog/accuracy-of-javascript-time](http://ejohn.org/blog/accuracy-of-javascript-time).)
    Using Sinon.JS fake timers, we can *synchronously* and *predictably* simulate
    the advancement of 200 milliseconds for the jQuery effect without any delays in
    a test.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假计时器对于测试 Backbone.js 应用程序非常有用。例如，如果某些 UI 代码有一个延迟的 jQuery 效果，需要 200 毫秒才能完成，包含此行为的测试将不得不等待这么长时间，从而减慢整个测试套件的运行速度。此外，原生
    JavaScript 中的计时器并不完全可预测。（例如，请参阅 John Resig 的 *JavaScript 时间精度* [http://ejohn.org/blog/accuracy-of-javascript-time](http://ejohn.org/blog/accuracy-of-javascript-time)。）使用
    Sinon.JS 伪造计时器，我们可以在测试中 *同步* 和 *可预测* 地模拟 jQuery 效果的 200 毫秒推进，而无需任何延迟。
- en: Fake servers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假服务器
- en: Sinon.JS can also patch some of the communication internals of a program and
    override the **XMLHttpRequest** (**XHR**) and other related mechanisms. A typical
    Backbone.js application uses XHR to synchronize models and collections to a backend
    datastore, such as a database or a cloud service, making this feature particularly
    relevant to our test infrastructure. The entire range of XHR faking capabilities
    provided by Sinon.JS are discussed at [http://sinonjs.org/docs/#server](http://sinonjs.org/docs/#server).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 还可以修补程序的一些通信内部，并覆盖 **XMLHttpRequest** (**XHR**) 以及其他相关机制。典型的 Backbone.js
    应用程序使用 XHR 将模型和集合同步到后端数据存储，如数据库或云服务，这使得此功能对我们的测试基础设施特别相关。Sinon.JS 提供的整个 XHR 伪造功能范围在
    [http://sinonjs.org/docs/#server](http://sinonjs.org/docs/#server) 中讨论。
- en: The fake server API
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 假服务器 API
- en: The first API that Sinon.JS provides is `FakeXMLHttpRequest`; this is a low-level
    abstraction around the XHR interface that provides fine-grained control over requests,
    responses, headers, and other details. See [http://sinonjs.org/docs/#FakeXMLHttpRequest](http://sinonjs.org/docs/#FakeXMLHttpRequest)
    for a complete API listing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 提供的第一个 API 是 `FakeXMLHttpRequest`；这是一个围绕 XHR 接口的低级抽象，提供了对请求、响应、标题和其他细节的精细控制。有关完整
    API 列表，请参阅 [http://sinonjs.org/docs/#FakeXMLHttpRequest](http://sinonjs.org/docs/#FakeXMLHttpRequest)。
- en: Sinon.JS additionally provides a higher-level API in the form of a fake server
    that provides a much easier interface for common use cases in modern JavaScript
    web applications. We will use the latter interface in this chapter as the simpler
    interface is still well suited to our Backbone.js application testing needs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 还提供了一个高级 API，形式为假服务器，为现代 JavaScript 网络应用程序中的常见用例提供了一个更简单的接口。在本章中，我们将使用后者接口，因为更简单的接口仍然非常适合我们的
    Backbone.js 应用程序测试需求。
- en: 'The Sinon.JS fake server API documentation is available at [http://sinonjs.org/docs/#fakeServer](http://sinonjs.org/docs/#fakeServer).
    A useful subset of the API includes the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 假服务器 API 文档可在 [http://sinonjs.org/docs/#fakeServer](http://sinonjs.org/docs/#fakeServer)
    找到。API 的一个有用子集包括以下内容：
- en: '`sinon.fakeServer.create()`: This creates a fake server object and fakes the
    XHR interface for tests.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon.fakeServer.create()`: 这将创建一个假服务器对象，并伪造 XHR 接口以进行测试。'
- en: '`server.respondWith(response)`: This configures the server to respond to all
    requests with a response object. A response can take various forms, but the one
    we will use is an array comprised of an HTTP status code, a dictionary of headers,
    and a JSON response string. The default response is `[404, {}, ""]`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.respondWith(response)`: 这将配置服务器对所有请求响应一个响应对象。响应可以采取各种形式，但我们将使用的是一个包含
    HTTP 状态码、标题字典和 JSON 响应字符串的数组。默认响应是 `[404, {}, ""]`。'
- en: '`server.respondWith(method, url, response)`: This configures the server to
    respond to requests matching the specified HTTP method and URL with a response
    object. There are further permutations of `respondWith` that can use regular expressions
    for URL matching.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.respondWith(method, url, response)`: 这将配置服务器以响应对象响应与指定 HTTP 方法和方法匹配的请求。`respondWith`
    有进一步的变体，可以使用正则表达式进行 URL 匹配。'
- en: '`server.respond()`: After a server is configured and a test has started, any
    call to `respond()` will cause the fake server to immediately issue the prearranged
    response object.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.respond()`: 在服务器配置完成并开始测试后，任何对 `respond()` 的调用都会导致模拟服务器立即发出预安排的响应对象。'
- en: '`server.autoRespond = true`: The fake server will automatically respond to
    server requests without the need to call `respond()`. By default, the fake server
    will wait 10 milliseconds before responding. A different wait time can be assigned
    to the `server.autoRespondAfter` configuration variable.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.autoRespond = true`: 模拟服务器将自动响应服务器请求，无需调用 `respond()`。默认情况下，模拟服务器将在响应前等待
    10 毫秒。可以将不同的等待时间分配给 `server.autoRespondAfter` 配置变量。'
- en: '`server.restore()`: This unwinds the fake XHR interface.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.restore()`: 这将撤销模拟的 XHR 接口。'
- en: Faking the remote backend in a Backbone.js application
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Backbone.js 应用程序中模拟远程后端
- en: The Notes application that we have presented in this book does not have an external
    backend and relies instead on HTML5 localStorage to store collection data. While
    it is a useful teaching tool, most real-world Backbone.js applications do have
    a remote backing store. Accordingly, the companion code examples for this book
    include a version of Notes that is served as a Node.js Express ([http://expressjs.com](http://expressjs.com))
    application with a MongoDB ([http://www.mongodb.org](http://www.mongodb.org))
    backend database. You can find the full application and its test suite in the
    `notes-rest/` directory of the code examples repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所介绍的笔记应用没有外部后端，而是依赖于 HTML5 localStorage 来存储集合数据。虽然它是一个有用的教学工具，但大多数现实世界的 Backbone.js
    应用确实拥有远程后端存储。因此，本书的配套代码示例包括了一个作为 Node.js Express ([http://expressjs.com](http://expressjs.com))
    应用程序提供的笔记版本，并使用 MongoDB ([http://www.mongodb.org](http://www.mongodb.org)) 后端数据库。您可以在代码示例仓库的
    `notes-rest/` 目录中找到完整的应用程序及其测试套件。
- en: 'The main difference between the localStorage-backed `notes/app` and MongoDB-backed
    `notes-rest/app` Backbone.js applications is in the `App.Collections.Notes` collection
    implementation. The `notes-rest/app` version, available at `notes-rest/app/js/app-rest/collections/notes.js`,
    defines the collection class as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 localStorage 的 `notes/app` 和基于 MongoDB 的 `notes-rest/app` Backbone.js 应用程序之间的主要区别在于
    `App.Collections.Notes` 集合实现。`notes-rest/app` 版本，可在 `notes-rest/app/js/app-rest/collections/notes.js`
    中找到，如下定义集合类：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The URL `/api/notes` points to a backend REST interface provided by the Node.js
    Express server (`notes-rest/server.js` in the code examples) that interacts with
    the MongoDB datastore.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: URL `/api/notes` 指向由 Node.js Express 服务器提供的后端 REST 接口（代码示例中的 `notes-rest/server.js`），该接口与
    MongoDB 数据存储进行交互。
- en: Our tests for the new `App.Collections.Notes` collection will rely on a fake
    server to intercept all of the remote backend calls and replace the network responses
    with our desired test data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对新 `App.Collections.Notes` 集合的测试将依赖于模拟服务器来拦截所有的远程后端调用，并用我们期望的测试数据替换网络响应。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The collection tests in this section fake the entire backend, meaning that the
    tests don't use Node.js or MongoDB servers at all. This provides the advantage
    of the tests running extremely fast and giving us predictable responses. However,
    testing scenarios that seek to exercise the entire application (for example, full
    integration tests) may require that the test infrastructure run live on backend
    servers and/or datastores.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的集合测试模拟了整个后端，这意味着测试根本不使用 Node.js 或 MongoDB 服务器。这提供了测试运行速度极快和给我们提供可预测响应的优势。然而，测试场景如果试图测试整个应用程序（例如，完整的集成测试）可能需要测试基础设施在真实后端服务器和数据存储上运行。
- en: 'Looking at the test suite file `notes-rest/test/js/spec-rest/collections/notes.spec.js`
    in the `beforeEach` setup call, we create an empty collection and a fake server
    that automatically responds to backend requests. The `afterEach` call restores
    the normal XHR operation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看测试套件文件 `notes-rest/test/js/spec-rest/collections/notes.spec.js` 中的 `beforeEach`
    设置调用时，我们创建了一个空集合和一个自动响应后端请求的模拟服务器。`afterEach` 调用将恢复正常的 XHR 操作：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following spec checks if the collection can fetch and populate data from
    the backend. We configure the fake server to respond to GET requests with JSON-serialized
    data for a single note. We then set a callback on the `reset` event to verify
    that the collection has the expected length and has deserialized the data into
    a note model:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规范检查集合是否可以从后端获取并填充数据。我们配置伪造服务器以对GET请求返回单个笔记的JSON序列化数据。然后，我们在`reset`事件上设置一个回调来验证集合具有预期的长度，并且已将数据反序列化为笔记模型：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This spec illustrates the simple manner in which requests can be faked—we just
    make one `this.server.respondWith()` setup call for the specific faked URL and
    the Backbone.js collection is none the wiser that it is not really talking to
    a remote data store. For additional collection tests with Sinon.JS fake servers,
    see the rest of the `notes-rest/test/js/spec-rest/collections/notes.spec.js` file
    in the companion code samples for this book that can be run from the test driver
    page `notes-rest/test/test.html`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范说明了请求可以如何被伪造——我们只需为特定的伪造URL调用一次`this.server.respondWith()`设置即可，Backbone.js集合并不知道它实际上并没有与远程数据存储进行通信。有关使用Sinon.JS伪造服务器的附加集合测试，请参阅本书配套代码示例中的`notes-rest/test/js/spec-rest/collections/notes.spec.js`文件，这些示例可以从测试驱动页面`notes-rest/test/test.html`运行。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to apply Sinon.JS stubs, mocks, and other fakes
    to isolate Backbone.js components, reduce test complexity, and enhance predictable
    test behavior. We also finished all of the application tests that we will discuss
    in this book for the reference Notes application. Taking a moment to reflect upon
    our progress leading up to this point, we have now covered the basics of creating
    a test infrastructure and applying fundamental testing concepts to all of the
    various Backbone.js application components.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何应用Sinon.JS存根、模拟和其他伪造来隔离Backbone.js组件，减少测试复杂性，并增强可预测的测试行为。我们还完成了本书中将要讨论的所有参考笔记应用程序的应用程序测试。花点时间回顾一下到目前为止的进展，我们现在已经涵盖了创建测试基础设施和应用基本测试概念到所有各种Backbone.js应用程序组件的基础知识。
- en: But, this is really just the beginning of the substantive testing journey; the
    tests presented in this book are a subset of those that would be desirable for
    a full production Backbone.js application. Our hope is that you now have the necessary
    tools, development techniques, and starting points to provide full test support
    for your Backbone.js applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这实际上只是实质性测试旅程的开始；本书中展示的测试只是那些对于一个完整的生产级Backbone.js应用程序所期望的测试的一个子集。我们希望你现在拥有了提供完整测试支持的必要工具、开发技术和起点，以支持你的Backbone.js应用程序。
- en: In the next chapter, we will aim at extending our testing capabilities and use
    cases through test automation. We will move beyond manually running test suites
    in a local browser and introduce testing tools that can execute tests in different
    environments (such as the command line or a build server) and without a web browser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将致力于通过测试自动化扩展我们的测试能力和用例。我们将超越在本地浏览器中手动运行测试套件，并引入可以在不同环境中（如命令行或构建服务器）执行测试且无需网络浏览器的测试工具。
