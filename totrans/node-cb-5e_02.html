<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-42">
    <a id="_idTextAnchor041">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-43">
    <a id="_idTextAnchor042">
    </a>
    
     Interacting with the File System
    
   </h1>
   <p>
    
     Before Node.js, JavaScript was predominantly used in the browser.
    
    
     Node.js brought JavaScript to the server and enabled us to interact with the operating system through JavaScript.
    
    
     Today, Node.js is one of the most popular technologies for building
    
    
     
      server-side applications.
     
    
   </p>
   <p>
    
     Node.js interacts with the operating system at a fundamental level:
    
    <strong class="bold">
     
      input and output
     
    </strong>
    
     (
    
    <strong class="bold">
     
      I/O
     
    </strong>
    
     ).
    
    
     This chapter will explore the core APIs provided by Node.js that allow us to interact with standard I/O, the file system, and the
    
    
     
      network stack.
     
    
   </p>
   <p>
    
     This chapter will show you how to read and write files both synchronously and asynchronously.
    
    
     Node.js was built to handle asynchronous code and enable a non-blocking model.
    
    
     Understanding how to read and write asynchronous code is fundamental learning, and it will show how to leverage the capabilities
    
    
     
      of Node.js.
     
    
   </p>
   <p>
    
     We will also learn about the core modules provided by Node.js.
    
    
     We’ll be focusing on the
    
    <strong class="bold">
     
      File System
     
    </strong>
    
     module, which
    
    <a id="_idIndexMarker057">
    </a>
    
     enables you to interact with the file system and files.
    
    
     Newer versions of Node.js have added
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     variants of many file system APIs, which will also be touched upon in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Interacting with the
     
     
      
       file system
      
     
    </li>
    <li>
     
      Working
     
     
      
       with files
      
     
    </li>
    <li>
     
      
       Fetching metadata
      
     
    </li>
    <li>
     
      
       Watching files
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-44">
    <a id="_idTextAnchor043">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter assumes that you have a recent version of Node.js 22 installed, a
    
    <strong class="bold">
     
      Terminal
     
    </strong>
    
     or shell, and an editor of your choice.
    
    
     The code for this chapter is available on GitHub at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     in the
    
    
     <strong class="source-inline">
      
       Chapter02
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     This chapter will use the CommonJS syntax; refer to
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     for more information on CommonJS and
    
    
     
      ECMAScript modules.
     
    
   </p>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor044">
    </a>
    
     Interacting with the file system
    
   </h1>
   <p>
    <strong class="bold">
     
      Standard in
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      stdin
     
    </strong>
    
     ) refers to an
    
    <a id="_idIndexMarker058">
    </a>
    
     input stream that a program can use to read input from a
    
    <a id="_idIndexMarker059">
    </a>
    
     command shell or Terminal.
    
    
     Similarly,
    
    <strong class="bold">
     
      standard out
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     ) refers
    
    <a id="_idIndexMarker060">
    </a>
    
     to the stream that is used to write the output.
    
    <strong class="bold">
     
      Standard error
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      stderr
     
    </strong>
    
     ) is a separate stream to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     that
    
    <a id="_idIndexMarker061">
    </a>
    
     is typically reserved for outputting errors and
    
    
     
      diagnostic data.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to learn how to handle input with
    
    <strong class="source-inline">
     
      stdin
     
    </strong>
    
     , write output to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     , and log errors
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       stderr
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor045">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     For this recipe, let’s first create a single file named
    
    <strong class="source-inline">
     
      greeting.js
     
    </strong>
    
     .
    
    
     The program will ask for user input via
    
    <strong class="source-inline">
     
      stdin
     
    </strong>
    
     , return a greeting via
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     , and log an error to
    
    <strong class="source-inline">
     
      stderr
     
    </strong>
    
     when invalid input is provided.
    
    
     Let’s create a directory to work
    
    
     
      in, too:
     
    
   </p>
   <pre class="console">
$ mkdir interfacing-with-io
$ cd interfacing-with-io
$ touch greeting.js</pre>
   <p>
    
     Now that we’ve set up our directory and file, we’re ready to move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor046">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to create a program that can read from
    
    <strong class="source-inline">
     
      stdin
     
    </strong>
    
     and write to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       stderr
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ol>
    <li>
     
      First, we need to tell the program to listen for user input.
     
     
      This can be done by adding the following lines
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        greeting.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
console.log('What is your name?');
process.stdin.on('data', (data) =&gt; {
  // processing on each data event
});</pre>
    </li>
    <li>
     
      We can
     
     <a id="_idIndexMarker062">
     </a>
     
      run the file using the following command.
     
     
      Observe that the application does not exit because it is continuing to listen for
     
     <strong class="source-inline">
      
       process.stdin
      
     </strong>
     
      
       data events:
      
     
     <pre class="source-code">
<strong class="bold">$ node greeting.js</strong></pre>
    </li>
    <li>
     
      Exit the program using
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     
      <em class="italic">
       
        C
       
      </em>
     
     
      
       .
      
     
    </li>
    <li>
     
      We can now tell the program what it should do each time it detects a data event.
     
     
      Add the following lines below the
     
     <strong class="source-inline">
      
       // processing on each data
      
     </strong>
     
      <strong class="source-inline">
       
        event
       
      </strong>
     
     
      
       comment:
      
     
     <pre class="source-code">
  const name = data.toString().trim().toUpperCase();
  process.stdout.write(`Hello ${name}!`);</pre>
    </li>
    <li>
     
      You can now type input to your program.
     
     
      When you press
     
     <em class="italic">
      
       Enter
      
     </em>
     
      , it will return a greeting and your name
     
     
      
       in uppercase:
      
     
     <pre class="source-code">
<strong class="bold">$ node greeting.js</strong>
What is your name?
<strong class="bold">Beth</strong>
Hello BETH!</pre>
    </li>
    <li>
     
      We can now add a check for whether the input string is empty and log to
     
     <strong class="source-inline">
      
       stderr
      
     </strong>
     
      if it is.
     
     
      Change your file to
     
     
      
       the following:
      
     
     <pre class="source-code">
console.log('What is your name?');
process.stdin.on('data', (data) =&gt; {
  // processing on each data event
  const name = data.toString().trim().toUpperCase();
  if (name !== '') {
    process.stdout.write(`Hello ${name}!`);
  } else {
    process.stderr.write('Input was empty.\n');
  }
});</pre>
    </li>
    <li>
     
      Run the program again and hit
     
     <em class="italic">
      
       Enter
      
     </em>
     
      with
     
     
      
       no input:
      
     
     <pre class="source-code">
<strong class="bold">$ node greeting.js</strong>
What is your name?
Input was empty.</pre>
    </li>
   </ol>
   <p>
    
     We’ve now
    
    <a id="_idIndexMarker063">
    </a>
    
     created a program that can read from
    
    <strong class="source-inline">
     
      stdin
     
    </strong>
    
     and write to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       stderr
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor047">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      process.stdin
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      process.stdout
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      process.stderr
     
    </strong>
    
     properties are all properties on the process object.
    
    
     A global process object provides information and control of the Node.js process.
    
    
     For each of the I/O channels (standard in, standard out, standard error), they emit data events for every chunk of data received.
    
    
     In this recipe, we were running the program in interactive mode where each data chunk was determined by the newline character when you hit
    
    <em class="italic">
     
      Enter
     
    </em>
    
     in
    
    
     
      your shell.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      process.stdin.on('data', (data) =&gt; {...});
     
    </strong>
    
     instance is what listens for these data events.
    
    
     Each data event returns a
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object.
    
    
     The
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object (typically named
    
    <strong class="source-inline">
     
      data
     
    </strong>
    
     ) returns a binary representation of
    
    
     
      the input.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      const name = data.toString()
     
    </strong>
    
     instance is what turns the
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object into a string.
    
    
     The
    
    <strong class="source-inline">
     
      trim()
     
    </strong>
    
     function removes all whitespace characters – including spaces, tabs, and newline characters – from the beginning and end of a string.
    
    
     The whitespace characters include spaces, tabs, and
    
    
     
      newline characters.
     
    
   </p>
   <p>
    
     We write to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      stderr
     
    </strong>
    
     using the respective properties on the process object (
    
    
     <strong class="source-inline">
      
       process.stdout.write
      
     </strong>
    
    
     
      ,
     
    
    
     <strong class="source-inline">
      
       process.stderr.write
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     During the recipe, we also used
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    <em class="italic">
     
      C
     
    </em>
    
     to exit the program in the shell.
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    <em class="italic">
     
      C
     
    </em>
    
     sends
    
    <strong class="source-inline">
     
      SIGINT
     
    </strong>
    
     , or signal interrupt, to the Node.js process.
    
    
     For more information about signal events, refer to the Node.js Process API
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/api/process.html#process_signal_events">
     
      
       https://nodejs.org/api/process.html#process_signal_events
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      Console APIs
     
    </strong>
    
     : Under
    
    <a id="_idIndexMarker064">
    </a>
    
     the hood,
    
    <strong class="source-inline">
     
      console.log
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      console.err
     
    </strong>
    
     are using
    
    <strong class="source-inline">
     
      process.stdout
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      process.stderr
     
    </strong>
    
     .
    
    
     Console methods are higher-level APIs and include automatic formatting.
    
    
     It’s typical to use console methods for convenience and lower-level process methods when you require more control over
    
    
     
      the stream.
     
    
   </p>
   <h2 id="_idParaDest-49">
    <a id="_idTextAnchor048">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     As of Node.js 17.0.0, Node.js provides an Experimental Readline Promises API, which is used for reading a file line by line.
    
    
     The Promises API variant of this allows you to use
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     instead of callbacks, providing a more modern and cleaner approach to handling
    
    
     
      asynchronous operations.
     
    
   </p>
   <p>
    
     Here is an example of how the Promises API variant can be used to create a similar program to the
    
    <strong class="source-inline">
     
      greeting.js
     
    </strong>
    
     file created in the
    
    
     
      main recipe:
     
    
   </p>
   <pre class="source-code">
const readline = require('node:readline/promises');
async function greet () {
  const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
  const name = await rl.question('What is your name?\n');
  console.log(`Hello ${name}!`);
  rl.close();
}
greet();</pre>
   <p>
    
     This Node.js script utilizes the
    
    <strong class="source-inline">
     
      node:readline/promises
     
    </strong>
    
     module, which provides the
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     variant of the Readline API.
    
    
     It defines an asynchronous function,
    
    <strong class="source-inline">
     
      greet()
     
    </strong>
    
     , which prompts the user for their name in the console and then greets them with a personalized message – similar to the main recipe program.
    
    
     Using the Readline Promises API allows us to use the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax for cleaner asynchronous code flow.
    
    
     We’ll cover more about the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax in later recipes
    
    
     
      and chapters.
     
    
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor049">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Decoupling I/O
      
     </em>
     
      recipe in
     
     <a href="B19212_03.xhtml#_idTextAnchor068">
      
       <em class="italic">
        
         Chapter 3
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-51">
    <a id="_idTextAnchor050">
    </a>
    
     Working with files
    
   </h1>
   <p>
    
     Node.js provides
    
    <a id="_idIndexMarker065">
    </a>
    
     several core modules, including the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module.
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     stands for File System, and this module provides the APIs to interact with the
    
    
     
      file system.
     
    
   </p>
   <p>
    
     In this recipe, and throughout the book, we will make use of the
    
    <strong class="source-inline">
     
      node:
     
    </strong>
    
     prefix when importing
    
    
     
      core modules.
     
    
   </p>
   <p>
    
     In this recipe, we’ll learn how to read, write, and edit files using the synchronous functions available in the
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-52">
    <a id="_idTextAnchor051">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Let’s start by preparing a directory and files for
    
    
     
      this recipe:
     
    
   </p>
   <ol>
    <li>
     
      Create another directory for
     
     
      
       this recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir working-with-files</strong>
<strong class="bold">$ cd working-with-files</strong></pre>
    </li>
    <li>
     
      And now, let’s create a file to read.
     
     
      Run the following in your shell to create a file containing some
     
     
      
       simple text:
      
     
     <pre class="source-code">
<strong class="bold">$ echo Hello World! &gt; hello.txt</strong></pre>
    </li>
    <li>
     
      We’ll also need a file for our program—create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        readWriteSync.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch readWriteSync.js</strong></pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      touch
     
    </strong>
    
     utility is a command-line utility included in Unix-based operating systems that is used to update the access and modification date of a file or directory to the current time.
    
    
     However, when
    
    <strong class="source-inline">
     
      touch
     
    </strong>
    
     is run with no additional arguments on a non-existent file, it will create an empty file with that name.
    
    
     The
    
    <strong class="source-inline">
     
      touch
     
    </strong>
    
     utility is a typical way of creating an
    
    
     
      empty file.
     
    
   </p>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor052">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll
    
    <a id="_idIndexMarker066">
    </a>
    
     synchronously read the file named
    
    <strong class="source-inline">
     
      hello.txt
     
    </strong>
    
     , manipulate the contents of the file, and then update the file using synchronous functions provided by the
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module:
     
    
   </p>
   <ol>
    <li>
     
      We’ll start by requiring the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       path
      
     </strong>
     
      built-in modules.
     
     
      Add the following lines
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        readWriteSync.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');</pre>
    </li>
    <li>
     
      Now, let’s create a variable to store the file path of the
     
     <strong class="source-inline">
      
       hello.txt
      
     </strong>
     
      file that we
     
     
      
       created earlier:
      
     
     <pre class="source-code">
const filepath = path.join(process.cwd(), 'hello.txt');</pre>
    </li>
    <li>
     
      We can now synchronously read the file contents using the
     
     <strong class="source-inline">
      
       readFileSync()
      
     </strong>
     
      function provided by the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      module.
     
     
      We’ll also print the file contents to
     
     <strong class="source-inline">
      
       stdout
      
     </strong>
     
      
       using
      
     
     
      <strong class="source-inline">
       
        console.log()
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const contents = fs.readFileSync(filepath, 'utf8');
console.log('File Contents:', contents);</pre>
    </li>
    <li>
     
      Now, we can edit the content of the file – we will convert the lowercase text
     
     
      
       into uppercase:
      
     
     <pre class="source-code">
const upperContents = contents.toUpperCase();</pre>
    </li>
    <li>
     
      To update the file, we can use the
     
     <strong class="source-inline">
      
       writeFileSync()
      
     </strong>
     
      function.
     
     
      We’ll also add a
     
     <strong class="source-inline">
      
       log
      
     </strong>
     
      statement afterward indicating that the file has
     
     
      
       been updated:
      
     
     <pre class="source-code">
fs.writeFileSync(filepath, upperContents);
console.log('File updated.');</pre>
    </li>
    <li>
     
      Run
     
     <a id="_idIndexMarker067">
     </a>
     
      your program with
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ node readWriteSync.js</strong>
File Contents: Hello World!
File updated.</pre>
    </li>
    <li>
     
      To verify the contents were updated, you can open or use
     
     <strong class="source-inline">
      
       cat
      
     </strong>
     
      in your Terminal to show the contents
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        hello.txt
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cat hello.txt</strong>
HELLO WORLD!</pre>
    </li>
   </ol>
   <p>
    
     You now have a program that, when run, will read the contents of
    
    <strong class="source-inline">
     
      hello.txt
     
    </strong>
    
     , convert the text content into uppercase, and update
    
    
     
      the file.
     
    
   </p>
   <h2 id="_idParaDest-54">
    <a id="_idTextAnchor053">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     As is commonplace, the first two lines of the file require the necessary core modules for
    
    
     
      the program.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      const fs = require('node:fs');
     
    </strong>
    
     line will import the core Node.js File System module.
    
    
     The API documentation for the Node.js File System module is available at
    
    <a href="https://nodejs.org/api/fs.html">
     
      https://nodejs.org/api/fs.html
     
    </a>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module provides APIs to interact with the file system using Node.js.
    
    
     Similarly, the core
    
    <strong class="source-inline">
     
      path
     
    </strong>
    
     module provides APIs for working with file and directory paths.
    
    
     The
    
    <strong class="source-inline">
     
      path
     
    </strong>
    
     module API documentation is available
    
    
     
      at
     
    
    <a href="https://nodejs.org/api/path.html">
     
      
       https://nodejs.org/api/path.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Next, we defined a variable to store the file path of
    
    <strong class="source-inline">
     
      hello.txt
     
    </strong>
    
     using the
    
    <strong class="source-inline">
     
      path.join()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      process.cwd()
     
    </strong>
    
     functions.
    
    
     The
    
    <strong class="source-inline">
     
      path.join()
     
    </strong>
    
     function joins the path sections provided as parameters with the separator for the specific platform (for example,
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     on Unix and
    
    <strong class="source-inline">
     
      \
     
    </strong>
    
     on
    
    
     
      Windows environments).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      process.cwd()
     
    </strong>
    
     function is a function on the global process object that returns the current directory of the Node.js process.
    
    
     This program is expecting the
    
    <strong class="source-inline">
     
      hello.txt
     
    </strong>
    
     file to be in the same directory as
    
    
     
      the program.
     
    
   </p>
   <p>
    
     Next, we read the file using the
    
    <strong class="source-inline">
     
      fs.readFileSync()
     
    </strong>
    
     function.
    
    
     We pass this function the file path to read and the encoding, UTF-8.
    
    
     The encoding parameter is optional—when the parameter is omitted, the function will default to returning a
    
    
     <strong class="source-inline">
      
       Buffer
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     To perform
    
    <a id="_idIndexMarker068">
    </a>
    
     manipulation of the file contents, we used the
    
    <strong class="source-inline">
     
      toUpperCase()
     
    </strong>
    
     function available on
    
    
     
      string objects.
     
    
   </p>
   <p>
    
     Finally, we updated the file using the
    
    <strong class="source-inline">
     
      fs.writeFileSync()
     
    </strong>
    
     function.
    
    
     We passed the
    
    <strong class="source-inline">
     
      fs.writeFileSync()
     
    </strong>
    
     function two parameters.
    
    
     The first parameter was the path to the file we wished to update, and the second parameter was the updated
    
    
     
      file contents.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Both the
    
    <strong class="source-inline">
     
      readFileSync()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      writeFileSync()
     
    </strong>
    
     APIs are synchronous, which means that they will block/delay concurrent operations until the file read or write is completed.
    
    
     To avoid blocking, you’ll want to use the asynchronous versions of these functions, covered in the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section of the
    
    
     
      current recipe.
     
    
   </p>
   <h2 id="_idParaDest-55">
    <a id="_idTextAnchor054">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Throughout this recipe, we were operating on our files synchronously.
    
    
     However, Node.js was developed with a focus on enabling the non-blocking I/O model; therefore, in many (if not most) cases, you’ll want your operations to
    
    
     
      be asynchronous.
     
    
   </p>
   <p>
    
     Today, there are three notable ways to handle asynchronous code in Node.js—callbacks, Promises, and
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax.
    
    
     The earliest versions of Node.js only supported the callback pattern.
    
    
     Promises were added to the JavaScript specification with ECMAScript 2015, known as ES6, and subsequently, support for Promises was added to Node.js.
    
    
     Following the addition of
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     support,
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax support was also added
    
    
     
      to Node.js.
     
    
   </p>
   <p>
    
     All currently supported versions of Node.js now support callbacks, Promises, and
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax – you may find any of these used in modern Node.js development.
    
    
     Let’s explore how we can work with files asynchronously using
    
    
     
      these techniques.
     
    
   </p>
   <h3>
    
     Working with files asynchronously
    
   </h3>
   <p>
    
     Asynchronous programming can enable some
    
    <a id="_idIndexMarker069">
    </a>
    
     tasks or processing to continue while other operations
    
    
     
      are happening.
     
    
   </p>
   <p>
    
     The program from the
    
    <em class="italic">
     
      Working with files
     
    </em>
    
     recipe was written using the synchronous functions available in the
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module:
     
    
   </p>
   <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');
const filepath = path.join(process.cwd(), 'hello.txt');
const contents = fs.readFileSync(filepath, 'utf8');
console.log('File Contents:', contents);
const upperContents = contents.toUpperCase();
fs.writeFileSync(filepath, upperContents);
console.log('File updated.');</pre>
   <p>
    
     This means that the program was blocked waiting for the
    
    <strong class="source-inline">
     
      readFileSync()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      writeFileSync()
     
    </strong>
    
     operations to complete.
    
    
     This program can be rewritten to make use of
    
    
     
      asynchronous APIs.
     
    
   </p>
   <p>
    
     The asynchronous version of
    
    <strong class="source-inline">
     
      readFileSync()
     
    </strong>
    
     is
    
    <strong class="source-inline">
     
      readFile()
     
    </strong>
    
     .
    
    
     The general convention is that synchronous APIs will have the term “sync” appended to their name.
    
    
     The asynchronous function requires a callback function to be passed to it.
    
    
     The callback function contains the code that we want to be executed when the asynchronous
    
    
     
      task completes.
     
    
   </p>
   <p>
    
     The following
    
    <a id="_idIndexMarker070">
    </a>
    
     steps will implement the same behavior as the program from the
    
    <em class="italic">
     
      Working with files
     
    </em>
    
     recipe but using
    
    
     
      asynchronous methods:
     
    
   </p>
   <ol>
    <li>
     
      The
     
     <strong class="source-inline">
      
       readFileSync()
      
     </strong>
     
      function in this recipe could be changed to use the asynchronous function with
     
     
      
       the following:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');
const filepath = path.join(process.cwd(),
  'hello.txt');
fs.readFile(filepath, 'utf8', (err, contents) =&gt; {
  if (err) {
    return console.log(err);
  }
  console.log('File Contents:', contents);
  const upperContents = contents.toUpperCase();
  fs.writeFileSync(filepath, upperContents);
  console.log('File updated.');
});</pre>
     <p class="list-inset">
      
       Observe that all the processing that is reliant on the file read needs to take place inside the
      
      
       
        callback function.
       
      
     </p>
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       writeFileSync()
      
     </strong>
     
      function can also be replaced with the
     
     <strong class="source-inline">
      
       writeFile()
      
     </strong>
     
      
       asynchronous function:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');
const filepath = path.join(process.cwd(),
  'hello.txt');
fs.readFile(filepath, 'utf8', (err, contents) =&gt; {
  if (err) {
    return console.log(err);
  }
  console.log('File Contents:', contents);
  const upperContents = contents.toUpperCase();
  fs.writeFile(filepath, upperContents, (err) =&gt; {
    if (err) throw err;
    console.log('File updated.');
  });
});</pre>
     <p class="list-inset">
      
       Note that
      
      <a id="_idIndexMarker071">
      </a>
      
       we now have an asynchronous function that calls another asynchronous function.
      
      
       It’s not recommended to have too many nested callbacks as it can negatively impact the readability of the code.
      
      
       Consider the following to see how having too many nested callbacks impedes the readability of the code, which is sometimes referred to as “
      
      
       
        callback hell”:
       
      
     </p>
     <pre class="source-code">first(args, () =&gt; {
    second(args, () =&gt; {
        third(args, () =&gt; {});
    });
});</pre>
    </li>
    <li>
     
      Some
     
     <a id="_idIndexMarker072">
     </a>
     
      approaches can be taken to avoid too many nested callbacks.
     
     
      One approach would be to split callbacks into explicitly named functions.
     
     
      For example, our file could be rewritten so that the
     
     <strong class="source-inline">
      
       writeFile()
      
     </strong>
     
      call is contained within its own named
     
     
      
       function,
      
     
     
      <strong class="source-inline">
       
        updateFile()
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');
const filepath = path.join(process.cwd(), 'hello.txt');
fs.readFile(filepath, 'utf8', (err, contents) =&gt; {
  if (err) {
    return console.log(err);
  }
  console.log('File Contents:', contents);
  const upperContents = contents.toUpperCase();
  updateFile(filepath, upperContents);
});
function updateFile (filepath, contents) {
  fs.writeFile(filepath, contents, function (err) {
    if (err) throw err;
    console.log('File updated.');
  });
}</pre>
     <p class="list-inset">
      
       Another approach would be to use Promises, which we’ll cover in the
      
      <em class="italic">
       
        Using the fs Promises API
       
      </em>
      
       section of this chapter.
      
      
       But as the earliest versions of Node.js did not support Promises, the use of callbacks is still prevalent in many
      
      <strong class="source-inline">
       
        npm
       
      </strong>
      
       modules and
      
      
       
        existing applications.
       
      
     </p>
    </li>
    <li>
     
      To demonstrate
     
     <a id="_idIndexMarker073">
     </a>
     
      that this code is asynchronous, we can use the
     
     <strong class="source-inline">
      
       setInterval()
      
     </strong>
     
      function to print a string to the screen while the program is running.
     
     
      The
     
     <strong class="source-inline">
      
       setInterval()
      
     </strong>
     
      function enables you to schedule a function to happen after a specified delay in milliseconds.
     
     
      Add the following line to the end of
     
     
      
       your program:
      
     
     <pre class="source-code">
setInterval(() =&gt; process.stdout.write('**** \n'), 1).unref();</pre>
     <p class="list-inset">
      
       Observe that the string continues to be printed every millisecond, even in between when the file is being read and rewritten.
      
      
       This shows that the file reading and writing have been implemented in a non-blocking manner because operations are still completing while the file is
      
      
       
        being handled.
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Using
    
    <strong class="source-inline">
     
      unref()
     
    </strong>
    
     on
    
    <strong class="source-inline">
     
      setInterval()
     
    </strong>
    
     means this timer will not keep the Node.js event loop active.
    
    
     This means that if it is the only active event in the event loop, Node.js may exit.
    
    
     This is useful for timers for which you want to execute an action in the future but do not want to keep the Node.js process
    
    
     
      running solely.
     
    
   </p>
   <ol>
    <li value="5">
     
      To demonstrate this further, you could add a delay between the reading and writing of the file.
     
     
      To do this, wrap the
     
     <strong class="source-inline">
      
       updateFile()
      
     </strong>
     
      function in a
     
     <strong class="source-inline">
      
       setTimeout()
      
     </strong>
     
      function.
     
     
      The
     
     <strong class="source-inline">
      
       setTimeout()
      
     </strong>
     
      function allows you to pass it a function and a delay
     
     
      
       in milliseconds:
      
     
     <pre class="source-code">
setTimeout(() =&gt; updateFile(filepath, upperContents), 10);</pre>
    </li>
    <li>
     
      Now, the
     
     <a id="_idIndexMarker074">
     </a>
     
      output from our program should have more asterisks printed between the file read and write, as this is where we added the
     
     
      
       10-millisecond delay:
      
     
     <pre class="source-code">
<strong class="bold">$ node readFileAsync.js</strong>
****
****
File Contents: HELLO WORLD!
****
****
****
****
****
****
****
****
****
File updated.</pre>
    </li>
   </ol>
   <p>
    
     We can now see that we have converted the program from the
    
    <em class="italic">
     
      Working with files
     
    </em>
    
     recipe to handle the file operations asynchronously using the
    
    
     
      callback syntax.
     
    
   </p>
   <h3>
    
     Using the fs Promises API
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     Promises API was released in Node.js v10.0.0.
    
    
     The API provides File System functions
    
    <a id="_idIndexMarker075">
    </a>
    
     that return
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     objects rather than callbacks.
    
    
     Not all the original
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module APIs have equivalent
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     -based APIs, as only a subset of the original APIs were converted to provide
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     APIs.
    
    
     Refer to the Node.js API documentation for a full list of
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     functions provided via the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     Promises
    
    
     
      API:
     
    
    <a href="https://nodejs.org/docs/latest/api/fs.html#promises-api">
     
      
       https://nodejs.org/docs/latest/api/fs.html#promises-api
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     A
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     is an object that is used to represent the completion of an asynchronous function.
    
    
     The naming is based on the general definition of the term “promise”—an agreement to do something or that something will happen.
    
    
     A
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     object is always in one of the three
    
    
     
      following states:
     
    
   </p>
   <ul>
    <li>
     
      
       Pending
      
     
    </li>
    <li>
     
      
       Fulfilled
      
     
    </li>
    <li>
     
      
       Rejected
      
     
    </li>
   </ul>
   <p>
    
     A
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     will initially be in the pending state and will remain pending until it becomes either fulfilled—when the task has completed successfully—or rejected—when the task
    
    
     
      has failed.
     
    
   </p>
   <p>
    
     The following steps will implement the same behavior as the program from the recipe again but using
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     Promises
    
    
     
      API methods:
     
    
   </p>
   <ol>
    <li>
     
      To use the API, you’ll first need to
     
     
      
       import it:
      
     
     <pre class="source-code">
const fs = require('node:fs/promises');</pre>
    </li>
    <li>
     
      It is then possible to read the file using the
     
     
      <strong class="source-inline">
       
        readFile()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
fs.readFile(filepath, 'utf8').then((contents) =&gt; {
    console.log('File Contents:', contents);
});</pre>
    </li>
    <li>
     
      You can also combine the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      Promises API with the use of the
     
     
      <strong class="source-inline">
       
        async
       
      </strong>
     
     
      
       /
      
     
     
      <strong class="source-inline">
       
        await
       
      </strong>
     
     
      
       syntax:
      
     
     <pre class="source-code">
const fs = require('node:fs/promises');
const path = require('node:path');
const filepath = path.join(process.cwd(),
  'hello.txt');
async function run () {
  try {
    const contents = await fs.readFile(filepath,
      'utf8');
    console.log('File Contents:', contents);
  } catch (error) {
    console.error(error);
  }
}
run();</pre>
    </li>
   </ol>
   <p>
    
     Two notable
    
    <a id="_idIndexMarker076">
    </a>
    
     aspects of this implementation are the use of
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       async function run() {...}
      
     </strong>
     
      : Defines an asynchronous function named
     
     <strong class="source-inline">
      
       run()
      
     </strong>
     
      .
     
     
      Asynchronous functions enable the use of the
     
     <strong class="source-inline">
      
       await
      
     </strong>
     
      keyword for handling promises in a more
     
     
      
       synchronous-looking manner.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await fs.readFile(filepath, 'utf8')
      
     </strong>
     
      : Uses the
     
     <strong class="source-inline">
      
       await
      
     </strong>
     
      keyword to asynchronously read the contents of the
     
     
      
       file specified.
      
     
    </li>
   </ul>
   <p>
    
     Now, we’ve learned how we can interact with files using the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     
      Promises API.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Owing to using CommonJS in this chapter, it was necessary to wrap the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     example in a function as
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     must only be called from within an asynchronous function with CommonJS.
    
    
     From
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     onward, we’ll cover ECMAScript modules, where this wrapper function would be unnecessary due to
    
    <strong class="bold">
     
      top-level await
     
    </strong>
    
     being supported with
    
    
     
      ECMAScript modules.
     
    
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor055">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Fetching metadata
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Watching files
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    
     Fetching metadata
    
   </h1>
   <p>
    
     The
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module
    
    <a id="_idIndexMarker077">
    </a>
    
     generally provides APIs that
    
    <a id="_idIndexMarker078">
    </a>
    
     are modeled around
    
    <strong class="bold">
     
      Portable Operating System Interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      POSIX
     
    </strong>
    
     ) functions.
    
    
     The
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module includes APIs that facilitate the reading of directories and
    
    
     
      file metadata.
     
    
   </p>
   <p>
    
     In this recipe, we will create a small program that returns information about a file, using functions provided by the
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    
     Getting ready
    
   </h2>
   <ol>
    <li>
     
      Get started by creating a directory to
     
     
      
       work in:
      
     
     <pre class="source-code">
$ mkdir fetching-metadata
$ cd fetching-metadata</pre>
    </li>
    <li>
     
      We’ll also need to create a file to read and a file for
     
     
      
       our program:
      
     
     <pre class="source-code">
$ touch metadata.js
$ touch file.txt</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Using the files created in the
    
    <em class="italic">
     
      Getting ready
     
    </em>
    
     section, we will create a program that gives information
    
    <a id="_idIndexMarker079">
    </a>
    
     about the file we pass to it as
    
    
     
      a parameter:
     
    
   </p>
   <ol>
    <li>
     
      As in the previous recipes, we first need to import the necessary core modules.
     
     
      For this recipe, we just need to import the
     
     
      <strong class="source-inline">
       
        fs
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Next, we need the program to be able to read the filename as a command-line argument.
     
     
      To read the file argument, we can use
     
     <strong class="source-inline">
      
       process.argv[2]
      
     </strong>
     
      .
     
     
      Add the following line to
     
     
      
       your program:
      
     
     <pre class="source-code">
const file = process.argv[2];</pre>
    </li>
    <li>
     
      Now, we will create our
     
     
      <strong class="source-inline">
       
        printMetadata
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
function printMetadata(file) {
  const fileStats = fs.statSync(file);
  console.log(fileStats);
}</pre>
    </li>
    <li>
     
      Add a call to the
     
     
      <strong class="source-inline">
       
        printMetadata
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
printMetadata(file);</pre>
    </li>
    <li>
     
      You can now run the program, passing it the
     
     <strong class="source-inline">
      
       ./file.txt
      
     </strong>
     
      argument.
     
     
      Run your program with
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ node metadata.js ./file.txt</strong></pre>
    </li>
    <li>
     
      Expect to see output like
     
     
      
       the following:
      
     
     <pre class="source-code">
Stats {
  dev: 16777231,
  mode: 33188,
  nlink: 1,
  uid: 501,
  gid: 20,
  rdev: 0,
  blksize: 4096,
  ino: 16402722,
  size: 0,
  blocks: 0,
  atimeMs: 1697208041116.9521,
  mtimeMs: 1697208041116.9521,
  ctimeMs: 1697208041116.9521,
  birthtimeMs: 1697208041116.9521,
  atime: 2023-10-13T14:40:41.117Z,
  mtime: 2023-10-13T14:40:41.117Z,
  ctime: 2023-10-13T14:40:41.117Z,
  birthtime: 2023-10-13T14:40:41.117Z
}</pre>
     <p class="list-inset">
      
       You can
      
      <a id="_idIndexMarker080">
      </a>
      
       try adding some random text to
      
      <strong class="source-inline">
       
        file.txt
       
      </strong>
      
       , saving the file, and then rerunning your program; observe that the
      
      <strong class="source-inline">
       
        size
       
      </strong>
      
       and
      
      <strong class="source-inline">
       
        mtime
       
      </strong>
      
       values have
      
      
       
        been updated.
       
      
     </p>
    </li>
    <li>
     
      Now, let’s see what happens when we pass a non-existent file to
     
     
      
       the program:
      
     
     <pre class="source-code">
<strong class="bold">$ node metadata.js ./not-a-file.txt</strong>
node:fs:1658
  const stats = binding.stat(
                        ^
Error: ENOENT: no such file or directory, stat './not-a-file.txt'</pre>
     <p class="list-inset">
      
       The program throws
      
      
       
        an exception.
       
      
     </p>
    </li>
    <li>
     
      We
     
     <a id="_idIndexMarker081">
     </a>
     
      should catch this exception and output a message to the user saying the file path provided does not exist.
     
     
      To do this, change the
     
     <strong class="source-inline">
      
       printMetadata
      
     </strong>
     
      function
     
     
      
       to this:
      
     
     <pre class="source-code">
function printMetadata(file) {
  try {
    const fileStats = fs.statSync(file);
    console.log(fileStats);
  } catch (err) {
    console.error('Error reading file path:', file);
  }
}</pre>
    </li>
    <li>
     
      Run the program again with a
     
     
      
       non-existent file:
      
     
     <pre class="source-code">
$ node metadata.js ./not-a-file.txt
Error reading file: ./not-a-file.txt</pre>
    </li>
   </ol>
   <p>
    
     This time, you should see that the program handled the error rather than throwing
    
    
     
      an exception.
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      process.argv
     
    </strong>
    
     property is a
    
    <a id="_idIndexMarker082">
    </a>
    
     property on the global process object that returns an array containing the arguments that were passed to the Node.js process.
    
    
     The first element of the
    
    <strong class="source-inline">
     
      process.argv
     
    </strong>
    
     array,
    
    <strong class="source-inline">
     
      process.argv[0]
     
    </strong>
    
     , is the path of the
    
    <strong class="source-inline">
     
      node
     
    </strong>
    
     binary that is running.
    
    
     The second element is the path of the file we’re executing – in this case,
    
    <strong class="source-inline">
     
      metadata.js
     
    </strong>
    
     .
    
    
     In the recipe, we passed the filename as the third command-line argument and, therefore, referenced it
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       process.argv[2]
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Next, we created a
    
    <strong class="source-inline">
     
      printMetadata()
     
    </strong>
    
     function that called
    
    <strong class="source-inline">
     
      statSync(file)
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      statSync()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker083">
    </a>
    
     is a synchronous function that returns information about the file path that is passed to it.
    
    
     The file path passed can be either a file or a directory.
    
    
     The information returned is in the form of a
    
    <strong class="source-inline">
     
      stats
     
    </strong>
    
     object.
    
    
     The following table lists the information returned on the
    
    
     <strong class="source-inline">
      
       stats
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <div><div><img alt="Table 2.1 – Table listing properties returned on the stats object" src="img/B19212_02_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 2.1 – Table listing properties returned on the stats object
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In this recipe, we used only the synchronous File System APIs.
    
    
     For most of the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     APIs, there are both synchronous and asynchronous versions of each function.
    
    
     Refer to the
    
    <em class="italic">
     
      Working with files asynchronously
     
    </em>
    
     section of the
    
    <em class="italic">
     
      Working with files
     
    </em>
    
     recipe for more information about using asynchronous File
    
    
     
      System APIs.
     
    
   </p>
   <p>
    
     In the final steps
    
    <a id="_idIndexMarker084">
    </a>
    
     of this recipe, we edited our
    
    <strong class="source-inline">
     
      printMetadata
     
    </strong>
    
     function to account for invalid file paths.
    
    
     We did this by wrapping the
    
    <strong class="source-inline">
     
      statSync
     
    </strong>
    
     function in a
    
    
     <strong class="source-inline">
      
       try
      
     </strong>
    
    
     
      /
     
    
    
     <strong class="source-inline">
      
       catch
      
     </strong>
    
    
     
      statement.
     
    
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Next, we’ll look
    
    <a id="_idIndexMarker085">
    </a>
    
     at how we can check file access and modify file permissions and how to examine a
    
    <strong class="bold">
     
      symbolic
     
    </strong>
    
     <strong class="bold">
      
       link
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       symlink
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <h3>
    
     Checking file access
    
   </h3>
   <p>
    
     It is
    
    <a id="_idIndexMarker086">
    </a>
    
     recommended that if you’re attempting to read, write, or edit a file, you follow the approach of handling the error if the file is not found, as we did in
    
    
     
      the recipe.
     
    
   </p>
   <p>
    
     However, if you simply wanted to check the existence of a file, you could use the
    
    <strong class="source-inline">
     
      fs.access()
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      fs.accessSync()
     
    </strong>
    
     APIs.
    
    
     Specifically, the
    
    <strong class="source-inline">
     
      fs.access()
     
    </strong>
    
     function tests the user’s permissions for accessing the file or directory passed to it.
    
    
     The function also allows an optional argument of
    
    <strong class="source-inline">
     
      mode
     
    </strong>
    
     to be passed to it, where you can request the function to do a specific access check using Node.js file access constants.
    
    
     A list of Node.js file access constants is available in the Node.js
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module API documentation:
    
    <a href="https://nodejs.org/api/fs.html#fs_file_access_constants">
     
      https://nodejs.org/api/fs.html#fs_file_access_constants
     
    </a>
    
     .
    
    
     These enable you to check whether the Node.js process can read, write, or execute the file
    
    
     
      path provided.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     There is a legacy API that is now deprecated, called
    
    <strong class="source-inline">
     
      fs.exists()
     
    </strong>
    
     .
    
    
     It is not recommended you use this function.
    
    
     The reason for deprecation was that the method’s interface was found to be error-prone and could lead to accidental race conditions.
    
    
     The
    
    <strong class="source-inline">
     
      fs.access()
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      fs.stat()
     
    </strong>
    
     APIs should be
    
    
     
      used instead.
     
    
   </p>
   <h3>
    
     Modifying file permissions
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker087">
    </a>
    
     Node.js
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module provides APIs that can be used to alter the permissions on a given file.
    
    
     As with many of the other
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     functions, there is both an asynchronous API,
    
    <strong class="source-inline">
     
      chmod()
     
    </strong>
    
     , and an equivalent synchronous API,
    
    <strong class="source-inline">
     
      chmodSync()
     
    </strong>
    
     .
    
    
     Both functions take a file path and
    
    <strong class="source-inline">
     
      mode
     
    </strong>
    
     as the first and second arguments, respectively.
    
    
     The
    
    <strong class="source-inline">
     
      chmod()
     
    </strong>
    
     function accepts a third parameter, which is the callback function to be executed
    
    
     
      upon completion.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      chmod
     
    </strong>
    
     command
    
    <a id="_idIndexMarker088">
    </a>
    
     is used to change access permissions of file system objects on Unix and similar operating systems.
    
    
     If you’re unfamiliar with Unix file permissions, it is recommended you refer to the Unix manual
    
    
     
      pages (
     
    
    <a href="https://linux.die.net/man/1/chmod">
     
      
       https://linux.die.net/man/1/chmod
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      mode
     
    </strong>
    
     argument can be either in the form of a numeric bitmask using a series of constants provided by the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module or a sequence of three octal digits.
    
    
     The constants that can be used to create a bitmask to define user permissions are defined in the Node.js API
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/api/fs.html#fs_file_modes">
     
      
       https://nodejs.org/api/fs.html#fs_file_modes
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Imagine that you have a file that currently has the
    
    
     
      following permissions:
     
    
   </p>
   <ul>
    <li>
     
      Owner readable
     
     
      
       and writeable
      
     
    </li>
    <li>
     
      
       Group readable
      
     
    </li>
    <li>
     
      Readable only by all other users (sometimes referred to as
     
     
      
       world readable)
      
     
    </li>
   </ul>
   <p>
    
     If we wanted to additionally grant write access to those in the same group, we could use the following
    
    
     
      Node.js code:
     
    
   </p>
   <pre class="source-code">
const fs = require('node:fs');
const file = './file.txt';
fs.chmodSync(
  file,
  fs.constants.S_IRUSR |
    fs.constants.S_IWUSR |
    fs.constants.S_IRGRP |
    fs.constants.S_IWGRP |
    fs.constants.S_IROTH
);</pre>
   <p>
    
     As you can
    
    <a id="_idIndexMarker089">
    </a>
    
     see, this code is quite verbose.
    
    
     Adding a complex series or permissions would require passing many constants to create a numeric bitmask.
    
    
     Alternatively, we can pass the
    
    <strong class="source-inline">
     
      chmodSync()
     
    </strong>
    
     function an octal representation of file permissions, as is commonplace when using the Unix
    
    <strong class="source-inline">
     
      chmod
     
    </strong>
    
     command on the
    
    
     
      command line.
     
    
   </p>
   <p>
    
     We’re going to change the permissions using the equivalent of
    
    <strong class="source-inline">
     
      chmod 664
     
    </strong>
    
     from the command line, but
    
    
     
      via Node.js:
     
    
   </p>
   <pre class="source-code">
const fs = require('fs');
const file = './file.txt';
fs.chmodSync(file, 0o664);</pre>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Refer to
    
    <a href="https://mason.gmu.edu/~montecin/UNIXpermiss.htm">
     
      https://mason.gmu.edu/~montecin/UNIXpermiss.htm
     
    </a>
    
     for more detailed information on how Unix
    
    
     
      permissions work.
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      Windows file permissions
     
    </strong>
    
     : The
    
    <a id="_idIndexMarker090">
    </a>
    
     Windows operating system does not have as refined file permissions as on Unix—it is only possible to denote a file as writeable
    
    
     
      or non-writeable.
     
    
   </p>
   <h3>
    
     Inspecting symbolic links
    
   </h3>
   <p>
    
     A symlink is a
    
    <a id="_idIndexMarker091">
    </a>
    
     special file that stores a reference to another file or directory.
    
    
     When the
    
    <strong class="source-inline">
     
      stat()
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      statSync()
     
    </strong>
    
     function from the
    
    <em class="italic">
     
      Fetching metadata
     
    </em>
    
     recipe is run on a symbolic link, the method will return information about the file the symbolic link is referencing rather than the symbolic
    
    
     
      link itself.
     
    
   </p>
   <p>
    
     The Node.js
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module does, however, provide methods named
    
    <strong class="source-inline">
     
      lstat()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      lstatSync()
     
    </strong>
    
     that inspect the symbolic link itself.
    
    
     The following steps will demonstrate how you can use these methods to inspect a symbolic link that we
    
    
     
      will create:
     
    
   </p>
   <ol>
    <li>
     
      To create a symbolic link, you can use the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ ln -s file.txt link-to-file</strong></pre>
     <p class="list-inset">
      
       Now, you can use the
      
      <a id="_idIndexMarker092">
      </a>
      
       Node.js
      
      <strong class="bold">
       
        Read-Eval-Print Loop
       
      </strong>
      
       (
      
      <strong class="bold">
       
        REPL
       
      </strong>
      
       ) to test the
      
      <strong class="source-inline">
       
        lstatSync()
       
      </strong>
      
       function.
      
      
       The Node.js REPL is an interactive shell we can pass statements to, and it will evaluate them and return the result to
      
      
       
        the user.
       
      
     </p>
    </li>
    <li>
     
      To enter the Node.js REPL, type
     
     <strong class="source-inline">
      
       node
      
     </strong>
     
      in
     
     
      
       your shell:
      
     
     <pre class="source-code">
<strong class="bold">$ node</strong>
Welcome to Node.js v22.9.0.
Type ".help" for more information.
&gt;</pre>
    </li>
    <li>
     
      You can then type commands such as
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">&gt; console.log(</strong>'<strong class="bold">Hello World!</strong>'<strong class="bold">);</strong>
Hello World!
undefined</pre>
    </li>
    <li>
     
      Now, you can try out the
     
     
      <strong class="source-inline">
       
        lstatSync
       
      </strong>
     
     
      
       command:
      
     
     <pre class="source-code">
&gt; <strong class="bold">fs.lstatSync('link-to-file');</strong>
Stats {
  dev: 16777224,
  mode: 41453,
  nlink: 1,
  ...
}</pre>
    </li>
   </ol>
   <p>
    
     Note that we did
    
    <a id="_idIndexMarker093">
    </a>
    
     not need to explicitly import the Node.js
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module.
    
    
     The REPL automatically loads the core (built-in) Node.js modules so that they are available to be used.
    
    
     The REPL is a useful tool for testing out commands without having to
    
    
     
      create files.
     
    
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Watching files
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    
     Watching files
    
   </h1>
   <p>
    
     Node.js’s
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module
    
    <a id="_idIndexMarker094">
    </a>
    
     provides functionality that enables you to watch files and track when files or directories are created, updated,
    
    
     
      or deleted.
     
    
   </p>
   <p>
    
     In this recipe, we’ll create a small program named
    
    <strong class="source-inline">
     
      watch.js
     
    </strong>
    
     that watches for changes in a file using the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     API and then prints a message when a change
    
    
     
      has occurred.
     
    
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    
     Getting ready
    
   </h2>
   <ol>
    <li>
     
      For this recipe, we’ll want to work inside a new directory.
     
     
      Create and change into a directory
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        file-watching
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir file-watching</strong>
<strong class="bold">$ cd file-watching</strong></pre>
    </li>
    <li>
     
      We need to also create a file that we
     
     
      
       can watch:
      
     
     <pre class="source-code">
<strong class="bold">$ echo Hello World! &gt; file.txt</strong></pre>
    </li>
    <li>
     
      Create a
     
     
      <strong class="source-inline">
       
        watch.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
<strong class="bold">$ touch watch.js</strong></pre>
    </li>
   </ol>
   <p>
    
     Now that
    
    <a id="_idIndexMarker095">
    </a>
    
     we have created our directory and file, we can move on to
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re going to create a program that watches for changes in a given file – in this case, the
    
    <strong class="source-inline">
     
      file.txt
     
    </strong>
    
     file we created earlier.
    
    
     We will be using the
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module and, specifically, the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     method to
    
    
     
      achieve this:
     
    
   </p>
   <ol>
    <li>
     
      To get started, import the required core
     
     
      
       Node.js modules:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const path = require('node:path');</pre>
    </li>
    <li>
     
      We also need the program to access a file
     
     
      
       we created:
      
     
     <pre class="source-code">
const file = path.join(process.cwd(), 'file.txt');</pre>
    </li>
    <li>
     
      Next, we call the
     
     
      <strong class="source-inline">
       
        fs.watchFile()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
fs.watchFile(file, (current, previous) =&gt; {
    return console.log(`${file} updated
      ${(current.mtime)}`);
});</pre>
    </li>
    <li>
     
      Now, you can run the program in your shell with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node watch.js</strong></pre>
    </li>
    <li>
     
      In your editor, open
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      and make some edits, saving between each one.
     
     
      You will notice that each time you save, a log entry appears in the Terminal where you’re
     
     
      
       running
      
     
     
      <strong class="source-inline">
       
        watch.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
./file.txt updated Mon Oct 16 2023 00:44:19 GMT+0100 (British Summer Time)</pre>
    </li>
    <li>
     
      While we’re here, we can make the timestamp more readable.
     
     
      To do this, we’re going to make use of the
     
     <strong class="source-inline">
      
       Intl.DateTimeFormat
      
     </strong>
     
      object.
     
     
      It is a built-in JavaScript utility to manipulate dates
     
     
      
       and times.
      
     
    </li>
    <li>
     
      Add and
     
     <a id="_idIndexMarker096">
     </a>
     
      change the following lines to format the date
     
     
      
       using
      
     
     
      <strong class="source-inline">
       
        Intl.DateTimeFormat
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
  const formattedTime = new Intl.DateTimeFormat('en-
    GB', {
    dateStyle: 'full',
    timeStyle: 'long'
  }).format(current.mtime);
  return console.log(`${file} updated
    ${formattedTime}`);</pre>
    </li>
    <li>
     
      Rerun the program and make further edits to
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      —observe that the time is now in a more readable format for your
     
     
      
       time zone:
      
     
     <pre class="source-code">
<strong class="bold">$ node watch.js</strong>
./file.txt updated Monday 16 October 2024 at 00:45:27 BST</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we used
    
    <a id="_idIndexMarker097">
    </a>
    
     the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     function to watch for changes on a given file.
    
    
     The function accepts three arguments—a filename, an optional list of options, and a listener function.
    
    
     The
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object can include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       BigInt
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       BigInt
      
     </strong>
     
      object is a JavaScript object that allows you to represent larger numbers more reliably.
     
     
      This defaults to
     
     <strong class="source-inline">
      
       false
      
     </strong>
     
      ; when set to
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      , the numeric values returned from the object of
     
     <strong class="source-inline">
      
       Stats
      
     </strong>
     
      would be specified
     
     
      
       as
      
     
     
      <strong class="source-inline">
       
        BigInt
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       persistent
      
     </strong>
     
      : This value indicates whether the Node.js process should continue to run while files are still being watched.
     
     
      It defaults
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        true
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       interval
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       interval
      
     </strong>
     
      value controls how often the file should be polled for changes, measured in milliseconds.
     
     
      The default value is 5,007 milliseconds when no interval
     
     
      
       is supplied.
      
     
    </li>
   </ul>
   <p>
    
     The listener
    
    <a id="_idIndexMarker098">
    </a>
    
     function supplied
    
    <a id="_idIndexMarker099">
    </a>
    
     to the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     function will execute every time a change is detected.
    
    
     The listener function’s arguments, current and previous are both
    
    <strong class="source-inline">
     
      Stats
     
    </strong>
    
     objects, representing the current and previous state of
    
    
     
      the file.
     
    
   </p>
   <p>
    
     Our listener function passed to
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     is executed each time a change has been detected in the file being watched.
    
    
     Every time our
    
    <strong class="source-inline">
     
      updated
     
    </strong>
    
     function returns
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , it logs the updated message
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       stdout
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The Node.js
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module provides another function,
    
    <strong class="source-inline">
     
      watch()
     
    </strong>
    
     , which watches for changes in files but can also watch for directories.
    
    
     This function differs from
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     as it utilizes the operating system’s underlying file system notification implementation rather than polling
    
    
     
      for changes.
     
    
   </p>
   <p>
    
     Although faster and more reliable than the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     API, the Watch API is not consistent across various platforms.
    
    
     This is because the Watch API is dependent on the underlying operating system’s method of notifying file system changes.
    
    
     The Node.js API documentation goes into more detail about the limitations of the Watch API across different
    
    
     
      platforms:
     
    
    <a href="https://nodejs.org/docs/latest/api/fs.html#fs_availability">
     
      
       https://nodejs.org/docs/latest/api/fs.html#fs_availability
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      watch()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker100">
    </a>
    
     similarly accepts three parameters—the filename, an array of options, and a listener function.
    
    
     The options that can be passed via the
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     parameter are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       persistent
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       persistent
      
     </strong>
     
      option is a Boolean that indicates whether the Node.js process should continue to run while files are still being watched.
     
     
      By default, the
     
     <strong class="source-inline">
      
       persistent
      
     </strong>
     
      option is set
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        true
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       recursive
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       recursive
      
     </strong>
     
      option is another Boolean that allows the user to specify whether changes in subdirectories should be watched – by default, this value is set to
     
     <strong class="source-inline">
      
       false
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       recursive
      
     </strong>
     
      option is only supported on macOS and Windows
     
     
      
       operating systems.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       encoding
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       encoding
      
     </strong>
     
      option is used to specify which character encoding should be used for the filename specified—the default
     
     
      
       is
      
     
     
      <strong class="source-inline">
       
        utf8
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Signal
      
     </strong>
     
      : An
     
     <strong class="source-inline">
      
       AbortSignal
      
     </strong>
     
      object that can be used to cancel
     
     
      
       file watching.
      
     
    </li>
   </ul>
   <p>
    
     The listener function that is passed to the
    
    <strong class="source-inline">
     
      watch()
     
    </strong>
    
     API is slightly different from the listener function passed to the
    
    <strong class="source-inline">
     
      watchFile()
     
    </strong>
    
     API.
    
    
     The arguments to the listener function are
    
    <strong class="source-inline">
     
      eventType
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      trigger
     
    </strong>
    
     , where
    
    <strong class="source-inline">
     
      eventType
     
    </strong>
    
     is either
    
    <strong class="source-inline">
     
      change
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      rename
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      trigger
     
    </strong>
    
     is the file that triggered an event.
    
    
     The following code represents a
    
    <a id="_idIndexMarker101">
    </a>
    
     similar task to what we implemented in our recipe but using the
    
    
     
      Watch API:
     
    
   </p>
   <pre class="source-code">
const fs = require('node:fs');
const file = './file.txt';
fs.watch(file, (eventType, filename) =&gt; {
  const formattedTime = new Intl.DateTimeFormat('en-GB',
  {
    dateStyle: 'full',
    timeStyle: 'long'
  }).format(new Date());
  return console.log(`${filename} updated
    ${formattedTime}`);
});</pre>
   <p>
    
     The final steps of the recipe cover usage of the comprehensive
    
    <strong class="source-inline">
     
      Intl.DateTimeFormat
     
    </strong>
    
     utility for manipulating dates and times.
    
    
     Refer to
    
    <em class="italic">
     
      MDN Web Docs
     
    </em>
    
     for a list of available formats and APIs on
    
    
     <strong class="source-inline">
      
       Intl.DateTimeFormat
      
     </strong>
    
    
     
      :
     
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat">
     
      
       https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      moment.js
     
    </strong>
    
     library
    
    <a id="_idIndexMarker102">
    </a>
    
     was once a go-to library for date manipulation and formatting in JavaScript.
    
    
     However, with the advancement of modern JavaScript, built-in functionalities such as
    
    <strong class="source-inline">
     
      Intl.DateTimeFormat
     
    </strong>
    
     offers similar capabilities natively.
    
    
     Additionally,
    
    <strong class="source-inline">
     
      moment.js
     
    </strong>
    
     has been put into maintenance mode by its maintainers, meaning no
    
    <a id="_idIndexMarker103">
    </a>
    
     new features will be added.
    
    
     Coupled with concerns about its bundle size, many developers are finding
    
    <strong class="source-inline">
     
      moment.js
     
    </strong>
    
     no longer necessary for their projects and are instead using built-in functionalities or more modern
    
    
     
      alternative libraries.
     
    
   </p>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      nodemon
     
    </strong>
    
     utility
    
    <a id="_idIndexMarker104">
    </a>
    
     is a popular
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     module utility for Node.js that
    
    <a id="_idIndexMarker105">
    </a>
    
     automatically restarts your application when it detects code change.
    
    
     Instead of manually stopping and starting the server after each code change,
    
    <strong class="source-inline">
     
      nodemon
     
    </strong>
    
     handles
    
    
     
      it automatically.
     
    
   </p>
   <p>
    
     Typical installation and usage of
    
    <strong class="source-inline">
     
      nodemon
     
    </strong>
    
     are
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ npm install --global nodemon</strong> // globally install nodemon
<strong class="bold">$ nodemon app.js</strong> // nodemon will watch for updates and restart</pre>
   <p>
    
     More recent versions of Node.js (later than v18.11.0) have a built-in watch-mode capability.
    
    
     To enable watch mode, you supply the
    
    <strong class="source-inline">
     
      --watch
     
    </strong>
    
     command-line
    
    
     
      process flag:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ node --watch app.js</strong></pre>
   <p>
    
     While in watch mode, modifications to the observed files trigger a Node.js process restart.
    
    
     By default, the built-in watch mode will monitor the main entry file and any modules that are required
    
    
     
      or imported.
     
    
   </p>
   <p>
    
     It is also possible to specify the exact files you wish to watch with the
    
    <strong class="source-inline">
     
      --watch-path
     
    </strong>
    
     command-line
    
    
     
      process flag:
     
    
   </p>
   <pre class="console">
<strong class="bold">$ node --watch-path=./src --watch-path=./test app.js</strong></pre>
   <p>
    
     More information can be found in the Node.js API
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch">
     
      
       https://nodejs.org/dist/latest-v22.x/docs/api/cli.html#--watch
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Adopting new JavaScript syntax in Node.js 22
      
     </em>
     
      recipe in
     
     <a href="B19212_01.xhtml#_idTextAnchor019">
      
       <em class="italic">
        
         Chapter 1
        
       </em>
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>