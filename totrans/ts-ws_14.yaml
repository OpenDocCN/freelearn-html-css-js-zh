- en: 13\. Async/Await in TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. TypeScript 中的 Async/Await
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: The `async`/`await` keywords give developers a more concise way to write asynchronous,
    non-blocking programs. In this chapter, we'll learn all about this syntactic sugar,
    a term for more concise and expressive syntax, for promises and how it drives
    modern software development. We will look at common uses of `async`/`await` and
    discuss the landscape of asynchronous programming in TypeScript. By the end of
    this chapter, you will be able to implement async/await keywords in TypeScript
    and use them to write asynchronous programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await` 关键字为开发者提供了一种更简洁的方式来编写异步、非阻塞程序。在本章中，我们将了解这种语法糖，一个用于更简洁和表达性更强的语法的术语，以及它是如何推动现代软件开发。我们将探讨
    `async`/`await` 的常见用法，并讨论 TypeScript 中异步编程的格局。到本章结束时，你将能够将 `async/await` 关键字应用于
    TypeScript，并使用它们来编写异步程序。'
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter got you started on promises in TypeScript. While promises
    improved our ability to write asynchronous code without the ugliness of nested
    callbacks, developers still wanted a better way to write asynchronous code. The
    promise syntax is sometimes challenging for programmers with a background in the
    C family of languages, and so the "syntactic sugar" of `async`/`await` was proposed
    to be added to the ECMAScript specification.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章让你在 TypeScript 中开始了承诺的学习。虽然承诺提高了我们编写异步代码的能力，避免了嵌套回调的丑陋，但开发者仍然想要一种更好的方式来编写异步代码。承诺语法对于有
    C 语言家族背景的程序员来说有时可能具有挑战性，因此提出了将 `async`/`await` 的“语法糖”添加到 ECMAScript 规范的建议。
- en: In this chapter, we'll learn about the introduction of new asynchronous programming
    paradigms to the ECMAScript standard, examine the syntax, and look at their use
    in TypeScript. We'll also cover the new (as of the time of writing) top-level
    `await` feature, which allows asynchronous programming outside of an `async` function.
    We will again look at error handling in asynchronous programming and examine the
    pros and cons of using `async`/`await` syntax versus promises.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解新的异步编程范式被引入 ECMAScript 标准的介绍，检查其语法，并查看它们在 TypeScript 中的使用。我们还将介绍（截至编写时）新的顶级
    `await` 功能，它允许在 `async` 函数之外进行异步编程。我们还将再次探讨异步编程中的错误处理，并检查使用 `async`/`await` 语法与承诺相比的优缺点。
- en: Readers who have been through the prior chapter will see that there is still
    some nesting involved in promises. While the flow is much easier to manage through
    multiple promises than it is with nested callbacks, we still have no mechanism
    by which we can return control to the top level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读过上一章的读者会看到，在承诺中仍然有一些嵌套。虽然通过多个承诺比嵌套回调更容易管理流程，但我们仍然没有一种机制可以将控制权返回到顶层。
- en: 'For example, consider a `getData` function that returns a promise. The code
    that invokes this function will look something like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个返回承诺的 `getData` 函数。调用此函数的代码将类似于以下内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We don''t have any means to propagate the `data` value to the outer scope.
    We couldn''t deal with that value in a subsequent scope. Some programmers may
    attempt to write code that looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有方法将 `data` 值传播到外部作用域。我们无法在后续作用域中处理该值。一些程序员可能会尝试编写类似这样的代码：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code will always log out `undefined`. It seems like it should work, but
    it won''t because the promise callback won''t be invoked until the promise returns.
    Asynchronous programming like this can be confusing and lead to lots of bugs.
    `async`/`await` solve this problem by allowing us to pause the execution of code
    pending the resolution of a promise. We can rewrite the preceding code using `async`/`await`
    syntax:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将始终输出 `undefined`。它看起来应该可以工作，但不会，因为承诺回调将在承诺返回之前被调用。这种异步编程可能会令人困惑，并导致许多错误。`async`/`await`
    通过允许我们在承诺解决之前暂停代码的执行来解决此问题。我们可以使用 `async`/`await` 语法重写前面的代码：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've gone from five lines of code to two. The synchronous operation of `console.log`
    will wait for the promise to resolve. The code is much more understandable, and
    we can store our variable at the top scope without nesting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从五行代码缩减到两行。`console.log` 的同步操作将等待承诺解决。代码更加易于理解，我们可以在顶层作用域中存储变量而不需要嵌套。
- en: Because TypeScript is transpiled to JavaScript in most cases, we need to make
    sure that we select the correct target environment in order for our code to run.
    This topic will be dealt with in greater detail later in the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 在大多数情况下被转换为 JavaScript，我们需要确保我们选择正确的目标环境，以便我们的代码能够运行。这个主题将在本章后面更详细地讨论。
- en: Evolution and Motivation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进化与动机
- en: Although promises moved the needle considerably when it came to asynchronous
    programming paradigms, there remained a desire for a lighter syntax that relied
    less on explicitly declaring promise objects. Adding the `async`/`await` keywords
    to the ECMAScript specification would allow developers to reduce boilerplate and
    work with promises. The concept comes from the C# programming language, which
    in turn borrowed the concept of asynchronous workflows from F#.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然承诺（promises）在异步编程范式方面取得了显著进展，但人们仍然渴望一种更轻量级的语法，它依赖于更少的显式声明承诺对象。将 `async`/`await`
    关键字添加到 ECMAScript 规范中，将允许开发者减少样板代码并使用承诺（promises）。这一概念源自 C# 编程语言，而 C# 又从 F# 编程语言中借鉴了异步工作流的概念。
- en: An asynchronous function allows a program to continue normal operation even
    though that function call has yet to return. The program does not wait for that
    asynchronous function call to complete until the `await` keyword is found. More
    significantly, using `await` will not block the event loop. Even if we have paused
    part of a program to await the result of an asynchronous function call, other
    operations can still complete. The event loop is not blocked. For more on the
    event loop, return to *Chapter 12*, *Guide to Promises in TypeScript*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数允许程序在函数调用尚未返回的情况下继续正常操作。程序不会等待异步函数调用完成，直到找到 `await` 关键字。更重要的是，使用 `await`
    不会阻塞事件循环。即使我们暂停了程序的一部分以等待异步函数调用的结果，其他操作仍然可以完成。事件循环不会被阻塞。有关事件循环的更多信息，请参阅第 12 章，TypeScript
    中承诺的指南。
- en: 'The great thing about these keywords is that they are immediately compatible
    with promises. We can await any promise, thereby avoiding having to use the `then()`
    API. This capability means that along with the concept of promisification (see
    *Chapter 12*, *Guide to Promises in TypeScript*), we can use the latest syntax
    even when integrating with older libraries or modules. To demonstrate this, let''s
    return to an example from the preceding chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字的好处在于它们与承诺（promises）立即兼容。我们可以等待任何承诺（promise），从而避免使用 `then()` API。这种能力意味着，即使在集成较旧的库或模块时，我们也可以使用最新的语法，这与承诺化（promisification）的概念（见第
    12 章，TypeScript 中承诺的指南）相结合。为了演示这一点，让我们回到前一章的一个例子：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example uses the `promises` API from the `fs` (filesystem) module from
    Node.js. The code reads a file from the local filesystem and logs the contents
    to the console. We can use await syntax with this code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 Node.js 的 `fs`（文件系统）模块中的 `promises` API。该代码从本地文件系统中读取文件并将内容记录到控制台。我们可以使用
    `await` 语法来使用此代码：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that in order to run this code, you must be able to use top-level `await`,
    which, at the time of this writing, requires a bit of extra setup. Refer to the
    section later in this chapter. The takeaway from this example is that we are still
    able to use the `promises` API from the `fs` module, even if we prefer `async`/`await`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了运行此代码，您必须能够使用顶层 `await`，这在撰写本文时需要一些额外的设置。请参阅本章后面的部分。从这个例子中我们可以得出的结论是，即使我们更喜欢
    `async`/`await`，我们仍然可以使用 `fs` 模块中的 `promises` API。
- en: async/await in TypeScript
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 中的 async/await
- en: The maintainers of TypeScript begin work on supporting ECMAScript features when
    they are in stages 1 and 2 of the review process, but only formally release them
    when they reach stage 3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的维护者从审查过程的第 1 和第 2 阶段开始支持 ECMAScript 功能，但只有在它们达到第 3 阶段时才会正式发布。
- en: TypeScript began offering experimental support for `async` functions in version
    1.6, released in September 2015, and offered full support in version 1.7, released
    in November 2015\. TypeScript programmers could work with this syntax a full year
    ahead of official browser and Node.js support.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 从 2015 年 9 月发布的 1.6 版本开始提供对 `async` 函数的实验性支持，并在 2015 年 11 月发布的 1.7
    版本中提供完全支持。TypeScript 程序员可以在官方浏览器和 Node.js 支持之前整整一年使用这种语法。
- en: Use of the `async`/`await` keywords in TypeScript does not vary much from JavaScript,
    but we do have an advantage in the ability to be more explicit about which functions
    should return promises and which should return a resolved value or throw an error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中使用 `async`/`await` 关键字与 JavaScript 的使用方式没有太大差异，但我们确实在明确指定哪些函数应该返回承诺（promises）以及哪些应该返回已解析的值或抛出错误方面具有优势。
- en: One thing to be cognizant of when writing modern syntax in TypeScript is that
    most TypeScript code is transpiled to JavaScript for execution in a runtime, such
    as a web browser or Node.js. We need to understand the difference between transpilation
    and a polyfill. `async`/`await` code and transpile to an environment that only
    supports promise syntax. A **polyfill** adds missing language features. If our
    target environment doesn't even support promises, then transpiling async/await
    into promises won't do the trick. We will require a polyfill as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中编写现代语法时，需要注意的一点是，大多数 TypeScript 代码在运行时（如网页浏览器或 Node.js）执行时会被转译为
    JavaScript。我们需要理解转译和 polyfill 之间的区别。`async`/`await` 代码会被转译到只支持 promise 语法的环境中。**polyfill**
    添加缺失的语言特性。如果我们的目标环境甚至不支持 promises，那么将 async/await 转译为 promises 就无法解决问题。我们还需要一个
    polyfill。
- en: 'Exercise 13.01: Transpilation Targets'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.01：转译目标
- en: 'In this exercise, we will use a contrived "Hello World!" example to demonstrate
    how TypeScript handles the transpilation of the `async` /`await` keywords:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个虚构的 "Hello World!" 示例来演示 TypeScript 如何处理 `async` /`await` 关键字的转译：
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/NS8gY](https://packt.link/NS8gY).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/NS8gY](https://packt.link/NS8gY)。
- en: 'Navigate to the `Exercise01` folder and install dependencies with `npm install`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Exercise01` 文件夹，并使用 `npm install` 安装依赖项：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That will install TypeScript and the TS Node execution environment. Now, execute
    the program included by typing `npx ts-node target.ts`. The result will be as
    follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将安装 TypeScript 和 TS Node 执行环境。现在，通过输入 `npx ts-node target.ts` 来执行程序。结果如下：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`World!` printed before `Hello`.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Hello` 之前打印了 `World!`。
- en: Open up `target.ts` and inspect the reason for this. This program creates a
    `sayHello` function, which internally creates a promise that resolves after one
    millisecond. You may notice that the program does exactly the same thing even
    if we remove the `await` keyword. That's OK. It's the different transpilation
    targets here that are interesting. When we run this program using TS Node, this
    will target the current Node.js version we're running. Assuming that's a recent
    version, `async`/`await` will be supported. Instead of doing that, let's try transpiling
    the code into JavaScript using TypeScript to see what happens.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `target.ts` 并检查导致这种情况的原因。这个程序创建了一个 `sayHello` 函数，该函数内部创建了一个在 1 毫秒后解决的 promise。你可能注意到，即使我们移除了
    `await` 关键字，程序仍然会做完全相同的事情。这是可以的。这里有趣的不是 `await` 关键字，而是不同的转译目标。当我们使用 TS Node 运行这个程序时，这将针对我们正在运行的当前
    Node.js 版本。假设这是一个较新的版本，`async`/`await` 将被支持。而不是这样做，让我们尝试使用 TypeScript 将代码转译为 JavaScript，看看会发生什么。
- en: 'Now, open the `tsconfig.json` file and look at it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `tsconfig.json` 文件并查看它：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `target` option being set to `es5` means that TypeScript will attempt to
    produce code that conforms to the ECMAScript5 specification. So let''s give that
    a try:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `target` 选项设置为 `es5` 意味着 TypeScript 将尝试生成符合 ECMAScript5 规范的代码。所以让我们试一试：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No output means that it executed successfully.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有输出意味着它执行成功。
- en: 'Check out the `target.js` file that was produced by TypeScript. The size of
    this file may vary depending on your TypeScript version, but the transpiled code
    module may be more than 50 lines:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看由 TypeScript 生成的 `target.js` 文件。这个文件的大小可能因你的 TypeScript 版本而异，但转译后的代码模块可能超过
    50 行：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete code can be found here: [https://packt.link/HSmyX](https://packt.link/HSmyX).'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的代码可以在此处找到：[https://packt.link/HSmyX](https://packt.link/HSmyX)。
- en: We can execute the transpiled code by typing `node target.js` at the command
    prompt and we'll see that we get the same output as before.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过在命令提示符中输入 `node target.js` 来执行转译后的代码，我们会看到与之前相同的输出。
- en: Promises are not part of the ECMAScript5 specification, so to generate code
    that will work in an ECMAScript5 environment, the transpiler had to create `__awaiter`
    and `__generator` functions to support promise-like functionality.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Promises 不是 ECMAScript5 规范的一部分，因此为了生成在 ECMAScript5 环境中可以工作的代码，转译器必须创建 `__awaiter`
    和 `__generator` 函数以支持类似 promise 的功能。
- en: 'Let''s switch our target to es6\. Open `tsconfig.json` and change the target
    property to `es6`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把目标切换到 es6。打开 `tsconfig.json` 并将目标属性更改为 `es6`：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Invoking the function with `node target.js`, we get exactly the same output
    as before. Now let''s see what TypeScript did when it transpiled our source:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `node target.js` 调用函数，我们得到与之前完全相同的输出。现在让我们看看 TypeScript 在转译我们的源代码时做了什么：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The transpiled code is now 15 lines instead of over 50 because ECMAScript6 is
    much closer to supporting all the functionality we need than es5 is. The `async`/`await`
    keywords are not supported in ECMAScript6, but promises are, so TypeScript is
    leveraging promises to make the outputted code more concise.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转译后的代码现在是 15 行，而不是超过 50 行，因为 ECMAScript6 比 es5 更接近支持我们需要的所有功能。`async`/`await`
    关键字在 ECMAScript6 中不受支持，但 promises 是支持的，所以 TypeScript 正在利用 promises 来使输出的代码更加简洁。
- en: 'Now, let''s change the target to `esnext`, run `npx tsc` one more time, and
    see what that output looks like:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将目标改为 `esnext`，再次运行 `npx tsc`，看看输出结果是什么：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's very similar to our source code! Since `async`/`await` are supported
    in the latest ECMAScript specification, there's no need to transform.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这非常类似于我们的源代码！由于 `async`/`await` 在最新的 ECMAScript 规范中是支持的，因此不需要转换。
- en: 'Older versions of TypeScript did not fully polyfill promises and async/await.
    Downgrade your TypeScript version with `npm i -D typescript@2`, set your compilation
    target back to es5, and then try transpiling:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧版本的 TypeScript 没有完全 polyfill promises 和 async/await。使用 `npm i -D typescript@2`
    降级 TypeScript 版本，将编译目标恢复到 es5，然后尝试转译：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It doesn't work.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不起作用。
- en: 'If you bump up to `es6`, it will still fail:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将目标提升到 `es6`，它仍然会失败：
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Install the latest version of TypeScript with `npm i -D typescript@latest` and
    then everything should work as before.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm i -D typescript@latest` 安装 TypeScript 的最新版本，然后一切应该和以前一样工作。
- en: This aspect of TypeScript can be confusing for newcomers. TypeScript will not
    provide a polyfill for missing promises, but it will provide transformations to
    syntax that is functionally equivalent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，TypeScript 的这个方面可能会令人困惑。TypeScript 不会为缺失的 promises 提供 polyfill，但它会提供对功能等效的语法的转换。
- en: Choosing a Target
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择目标
- en: So how do we choose a compilation target? It's generally safe to use ES2017
    or above unless you need to support outdated browsers, such as Internet Explorer,
    or deprecated Node.js versions. Sometimes, we have no choice but to support outdated
    browsers due to customer needs, but if we have any control over a Node.js runtime
    environment, it's advisable to update to a current, supported version. Doing this
    should allow us to use the latest TypeScript features.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何选择编译目标呢？通常情况下，使用 ES2017 或更高版本是安全的，除非你需要支持过时的浏览器，例如 Internet Explorer，或者废弃的
    Node.js 版本。有时，由于客户需求，我们别无选择，只能支持过时的浏览器，但如果我们对 Node.js 运行时环境有任何控制权，建议更新到当前支持的版本。这样做应该允许我们使用最新的
    TypeScript 功能。
- en: Syntax
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: The two new keywords, `async`/`await`, are often found together, but not always.
    Let's look at the syntax for each of them individually.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新关键字 `async`/`await` 通常会一起出现，但并不总是如此。让我们分别看看每个关键字的语法。
- en: async
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async
- en: The `async` keyword modifies a function. If a function declaration or function
    expression is used, it is placed before the `function` keyword. If an arrow function
    is used, the `async` keyword is placed before the argument list. Adding the `async`
    keyword to a function will cause the function to return a promise.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 关键字修改了一个函数。如果使用函数声明或函数表达式，它放在 `function` 关键字之前。如果使用箭头函数，`async` 关键字放在参数列表之前。给函数添加
    `async` 关键字将导致函数返回一个 promise。'
- en: 'For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just adding the `async` keyword to this simple function will make this function
    return a promise, which is now awaitable and thenable. Since there's nothing asynchronous
    in the function, the promise will resolve immediately.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在这个简单函数中添加 `async` 关键字，这个函数就会返回一个 promise，现在它是可等待的并且是 thenable 的。由于函数中没有异步操作，这个
    promise 将立即解析。
- en: 'The arrow function version of this could be written as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个箭头函数版本可以写成如下：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Exercise 13.02: The async Keyword'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02：`async` 关键字
- en: 'This exercise illustrates how adding the `async` keyword to a function makes
    it return a promise:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习说明了给函数添加 `async` 关键字是如何使其返回一个 promise 的：
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/BgujE](https://packt.link/BgujE).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/BgujE](https://packt.link/BgujE)。
- en: 'Examine the `async.ts` file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `async.ts` 文件：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might expect this program to log out `A Promise`, but let''s see what actually
    happens when we run it:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能期望这个程序输出 `A Promise`，但让我们看看当我们运行它时实际上会发生什么：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `async` keyword wrapped the response in a promise. We can confirm that
    by removing the keyword and running the program again:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async` 关键字将响应封装在一个 promise 中。我们可以通过移除该关键字并再次运行程序来确认这一点：'
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Modifying our function with `async` is exactly equivalent to wrapping it in
    a promise. If we wanted to use promise syntax, we could write the program like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `async` 修改我们的函数与将其包裹在一个承诺中完全等价。如果我们想使用承诺语法，我们可以将程序写成这样：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, running the program written this way will log out the unresolved promise:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，以这种方式编写的程序将输出未解决的承诺：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since we're using TypeScript and return types can be inferred, modifying a function
    with `async` guarantees that TypeScript will always see the function as returning
    a promise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 TypeScript 并且返回类型可以被推断，使用 `async` 修改函数可以保证 TypeScript 总是将其视为返回一个承诺。
- en: The `async` keyword causes the function it modifies to be wrapped in a promise.
    Whether you choose to do that explicitly by declaring a promise or by using the
    `async` keyword is often a matter of taste and style.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 关键字使得它修改的函数被包裹在一个承诺中。你选择通过声明一个承诺或使用 `async` 关键字来显式地这样做，通常是一个品味和风格的问题。'
- en: How can we resolve an `async` function? We'll come to `await` in a moment, but
    what about using `then` and the promise chaining we learned about in *Chapter
    12*, *Guide to Promises in TypeScript*. Yes, that is also possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决一个 `async` 函数？我们稍后会谈到 `await`，但使用 `then` 和我们在 *第 12 章*，*TypeScript 中承诺指南*中学到的承诺链式操作呢？是的，这也是可能的。
- en: 'Exercise 13.03: Resolving an async Function with then'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：使用 then 解决 async 函数
- en: 'This exercise will teach you how to resolve an `async` function using `then`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将教你如何使用 `then` 解决一个 `async` 函数：
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/4Bo4c](https://packt.link/4Bo4c).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在这里找到：[https://packt.link/4Bo4c](https://packt.link/4Bo4c)。
- en: 'Create a new file called `resolve.async.ts` and enter the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `resolve.async.ts` 的新文件，并输入以下代码：
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute this code by entering `npx ts-node resolve.async.ts` into your console
    and you''ll see the expected text message logged, not an unresolved promise:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在控制台中输入 `npx ts-node resolve.async.ts` 执行此代码，你会看到预期的文本消息被记录，而不是未解决的承诺：
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though we never explicitly declared a promise object, the use of `async`
    has ensured that our function will always return a promise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们从未显式地声明承诺对象，但使用 `async` 确保我们的函数始终返回一个承诺。
- en: await
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: await
- en: 'The second half of this combo perhaps has greater value. The `await` keyword
    will attempt to resolve any promise before continuing. This will get us out of
    `then` chaining and allow us to write code that appears to be synchronous. One
    great benefit of using `await` is if we want to assign the result of an asynchronous
    call to some value and then do something with the value. Let''s look at how that''s
    done in a promise:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合的第二部分可能更有价值。`await` 关键字将尝试解决任何承诺，然后再继续。这将使我们摆脱 `then` 链式操作，并允许我们编写看起来是同步的代码。使用
    `await` 的一个巨大好处是，如果我们想将异步调用的结果分配给某个值，然后对这个值进行一些操作。让我们看看在承诺中是如何做到这一点的：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That can work fine and, in fact, this kind of syntax is used widely, but it
    breaks down a little if we need to do something tricky with chaining:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以正常工作，实际上，这种语法被广泛使用，但如果我们需要进行一些复杂的链式操作，它可能会有些问题：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But wait a minute. I thought promises were supposed to get rid of callback
    hell?! It''s actually not that ideal for this kind of chaining. Let''s try using
    `await` instead:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。我以为承诺是用来消除回调地狱的！实际上，对于这种链式操作来说，这并不理想。让我们尝试使用 `await` 代替：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most programmers would agree that this syntax is much cleaner and, in fact,
    this is one of the primary reasons why `async`/`await` were added to the language.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员都会同意这种语法更干净，实际上，这也是为什么在语言中添加 `async`/`await` 的主要原因之一。
- en: 'Exercise 13.04: The await Keyword'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.04：await 关键字
- en: 'This exercise will show you how to resolve a promise using `await`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将展示如何使用 `await` 解决一个承诺：
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/mUzGI](https://packt.link/mUzGI).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在这里找到：[https://packt.link/mUzGI](https://packt.link/mUzGI)。
- en: 'Create a file called `await.ts` and enter the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `await.ts` 的文件，并输入以下代码：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we declare two `async` functions. One of them calls the other using `await`
    to resolve the promise and it should print out the string, rather than an unresolved
    promise.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里我们声明了两个 `async` 函数。其中一个使用 `await` 调用另一个，以解决承诺，并且应该打印出字符串，而不是未解决的承诺。
- en: 'Run the file using `npx` `ts-node` `await.ts` and you should see the following output:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npx` `ts-node` `await.ts` 运行文件，你应该会看到以下输出：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Why did we need to wrap `await` in a second function? That is because normally,
    `await` cannot be used outside of an `async` function. We'll discuss the top-level
    `await` feature later in this chapter, which is an exception to this rule. What
    about mixing `await` with promises? This can certainly be done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在第二个函数中包装 `await`？这是因为通常，`await` 不能在 `async` 函数之外使用。我们将在本章后面讨论顶级 `await`
    功能，这是这个规则的例外。关于将 `await` 与承诺混合呢？这当然可以做到。
- en: 'Exercise 13.05: Awaiting a Promise'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.05：等待承诺
- en: 'This exercise teaches you how you can use `await` with promises:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习教你如何使用 `await` 与承诺：
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/mMDiw](https://packt.link/mMDiw).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/mMDiw](https://packt.link/mMDiw)。
- en: 'Create a new file called `await-promise.ts` and enter the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `await-promise.ts` 的新文件，并输入以下代码：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Execute the code by entering `npx ts-node await-promise.ts` and you''ll see
    the text output:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `npx ts-node await-promise.ts` 执行代码，你会看到文本输出：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A longer way to write this same code with a more explicit promise declaration
    would be:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用更明确的承诺声明来编写相同代码的另一种更长的写法是：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code functions exactly the same:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的功能完全相同：
- en: 'Enter `npx ts-node src/await-promise.ts` to verify that you get the following
    output:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npx ts-node src/await-promise.ts` 以验证你是否得到以下输出：
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Syntactic Sugar
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法糖
- en: The preceding exercises on `async` functions and promises are simply two different
    ways of expressing the exact same operation in TypeScript. Likewise, using `await`
    and resolving a promise with `then` are equivalent. The `async`/`await` keywords
    are what's known as "syntactic sugar," or code structures that enable more expressive
    syntax without changing the behavior of the program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前关于 `async` 函数和承诺的练习只是两种不同的方式，在 TypeScript 中表达完全相同的操作。同样，使用 `await` 和使用 `then`
    解决承诺是等效的。`async`/`await` 关键字被称为“语法糖”，或者代码结构，它允许更具有表现力的语法，而不改变程序的行为。
- en: This means it is possible and, at times, even advisable to mix `async`/`await`
    syntax with promises. A very common reason for doing this would be because you
    are working with a library that was written to use promises, but you prefer `async`/`await`
    syntax. Another reason for mixing the two would be to handle exceptions more explicitly.
    We'll deal with exception handling in detail later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有可能，有时甚至建议将 `async`/`await` 语法与承诺混合。这样做的一个非常常见的原因是，你正在使用一个编写为使用承诺的库，但你更喜欢
    `async`/`await` 语法。混合两种语法的另一个原因可能是更明确地处理异常。我们将在本章后面详细讨论异常处理。
- en: Exception Handling
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: We've been over how to turn `then` chaining into `await`, but what about `catch`?
    If a promise is rejected, the error will bubble up and must be caught in some
    way. Failing to catch an exception in the `async`/`await` world is just as damaging
    as failing to catch a promise rejection. In fact, it's exactly the same and `async`/`await`
    is just syntactic sugar on top of promises.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何将 `then` 链转换为 `await`，但关于 `catch` 呢？如果一个承诺被拒绝，错误将会冒泡并必须以某种方式捕获。在 `async`/`await`
    世界中未能捕获异常与未能捕获承诺拒绝一样有害。事实上，它们是完全相同的，`async`/`await` 只是承诺之上的语法糖。
- en: Failing to handle a rejected promise can lead to system failure where a program
    running in a web browser crashes, resulting in blank pages or broken functionality,
    thereby driving users away from your site. A failure to handle a rejected promise
    on the server side may cause a Node.js process to exit and a server to crash.
    Even if you have a self-healing system that attempts to bring your server back
    online, whatever job you were attempting to complete will have failed and frequently
    repeated restarts will make your infrastructure more expensive to run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理被拒绝的承诺可能导致系统故障，其中在网页浏览器中运行的程序崩溃，导致空白页面或功能损坏，从而驱使用户远离你的网站。在服务器端未能处理被拒绝的承诺可能会导致
    Node.js 进程退出和服务器崩溃。即使你有自我修复系统尝试将服务器恢复在线，你试图完成的任何工作都将失败，频繁的重启会使你的基础设施运行成本更高。
- en: 'The most straightforward way to handle these errors is with `try` and `catch`
    blocks. This syntax is not unique to `async`/`await` and has been part of the
    ECMAScript specification since ECMAScript3\. It is very simple and straightforward
    to use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些错误的最直接方法是使用 `try` 和 `catch` 块。这种语法不仅对 `async`/`await` 是独特的，自 ECMAScript3
    以来一直是 ECMAScript 规范的一部分。它非常简单直接，易于使用：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just as you can catch an error thrown from any of several chained promises,
    you can implement a similar pattern here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以从多个链式承诺中捕获抛出的错误一样，您也可以在这里实现类似的模式：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There may be cases where finer-grained exception handling is required. It is
    possible to nest these structures:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有需要更精细异常处理的情况。这些结构可以嵌套：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, writing code such as this negates most of the benefits of the `async`/`await`
    syntax. A better solution would be to throw specific error messages and test for
    them:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写这样的代码会抵消 `async`/`await` 语法的大部分好处。更好的解决方案是抛出特定的错误消息并对其进行测试：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this technique, we can handle everything in the same block and avoid nesting
    and messy-looking code structures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以将所有内容都在同一个块中处理，避免嵌套和看起来杂乱的代码结构。
- en: 'Exercise 13.06: Exception Handling'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.06：异常处理
- en: 'Let''s see how we can implement error handling in a simple example. In this
    exercise, we will intentionally and explicitly throw an error from an `async`
    function and see how that implements the operation of our program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在简单示例中实现错误处理。在这个练习中，我们将故意并明确地从 `async` 函数中抛出一个错误，并看看它是如何实现我们的程序操作的：
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/wbA8E](https://packt.link/wbA8E).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/wbA8E](https://packt.link/wbA8E)。
- en: 'Start by creating a new file called `error.ts` and entering the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为 `error.ts` 的新文件，并输入以下代码：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This program will, of course, always throw an error. When we execute it by
    entering `npx ts-node error.ts` into the console, we can see quite clearly that
    the error is not being handled properly:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，这个程序总是会抛出错误。当我们通过在控制台中输入 `npx ts-node error.ts` 来执行它时，我们可以清楚地看到错误没有被正确处理：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the deprecation warning. Not only is this an ugly stack trace, at some
    point in the future, exceptions such as this one will cause the Node.js process
    to exit. We clearly need to handle this exception!
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到弃用警告。这不仅是一个难看的堆栈跟踪，在未来的某个时刻，这样的异常将导致 Node.js 进程退出。我们显然需要处理这个异常！
- en: 'Fortunately, we can do so by simply surrounding the call with `try` and `catch`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过简单地用 `try` 和 `catch` 包围调用来实现这一点：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, when we execute the program, we get a more orderly exception and stack
    trace logged:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们执行程序时，我们得到一个更有序的异常和堆栈跟踪记录：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, that message only appears because we explicitly logged it out. We
    could instead choose to throw a default value or perform some other operation
    instead of logging the error.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，这个消息只出现是因为我们明确地记录了它。我们也可以选择抛出一个默认值或执行其他一些操作而不是记录错误。
- en: 'It''s always a good idea to log an error if the system isn''t behaving correctly,
    but depending on your system requirements, you might instead write something like this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果系统行为不正确，记录一个错误总是一个好主意，但根据您的系统要求，您可能更愿意写一些像这样的事情：
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, we just throw a warning and fall back to the secondary system
    because this program was designed to be fault-tolerant. It's still a good idea
    to log the warning so that we can trace how our system is behaving. One more variation
    of this for now.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是抛出一个警告并回退到二级系统，因为这个程序被设计成容错的。仍然记录这个警告以便我们可以追踪我们的系统行为是个好主意。现在就先这样变体一次。
- en: 'Let''s put our `try` and `catch` blocks at the top level and rewrite our program
    like this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把我们的 `try` 和 `catch` 块放在顶层，并像这样重写我们的程序：
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the output that you get:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是您得到的输出：
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You may assume that the program might work the same as putting `try` and `catch`
    inside `asyncFn`, but actually, it will behave the same as no error handling at
    all. That's because we aren't awaiting the function inside the `try` block.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以假设程序可能的工作方式与在 `asyncFn` 内部放置 `try` 和 `catch` 相同，但实际上，它将表现得与没有任何错误处理一样。这是因为我们没有在
    `try` 块内等待函数。
- en: Top-Level await
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶层 await
- en: Top-level `await` is a feature that allows the use of the `await` keyword at
    the module level, outside of any function. This allows a number of interesting
    patterns, such as waiting for a dependency to fully load by calling an asynchronous
    function before attempting to use it. Someday, top-level `await` may support some
    very exciting functional programming paradigms, but at the time of writing, it
    is still technically in preview mode, and so is not ready for widespread use.
    You may be reading this book at a time when top-level `await` is widely available
    and supported, and if so, you should definitely give it a look!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层 `await` 是一个允许在模块级别（任何函数之外）使用 `await` 关键字的功能。这允许一些有趣的模式，例如在尝试使用它之前，通过调用异步函数等待依赖项完全加载。总有一天，顶层
    `await` 可能会支持一些非常令人兴奋的函数式编程范式，但在写作时，它仍然处于技术预览模式，因此尚未准备好广泛使用。您可能是在顶层 `await` 广泛可用和支持的时候阅读这本书，如果是这样，您绝对应该看看它！
- en: 'Writing code with top-level `await` is very straightforward. Here is a very
    short program that attempts to make use of it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶层 `await` 编写代码非常简单。以下是一个非常简短的程序，它试图利用它：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This looks fine. Now let''s see what happens when we try to execute it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来没问题。现在让我们看看当我们尝试执行它时会发生什么：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's not supported, but it gives me some pointers. How can we make this work?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这不被支持，但它给了我一些提示。我们如何才能让它工作？
- en: Top-level `await` requires NodeJS 14.8 or greater. This version of NodeJS entered
    LTS (long-term service) in October of 2020 and so is still new at the time of
    this writing. You can check your NodeJS version on the command line with `node
    -v`. If you aren't running version 14.8 or greater, there are some good utilities
    like `nvm` and `n` that will allow you to switch your version easily.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层 `await` 需要 NodeJS 14.8 或更高版本。这个版本的 NodeJS 在 2020 年 10 月进入了 LTS（长期服务）阶段，因此在写作时仍然很新。您可以在命令行中使用
    `node -v` 检查您的 NodeJS 版本。如果您没有运行 14.8 或更高版本，有一些很好的工具如 `nvm` 和 `n` 可以让您轻松切换版本。
- en: That, however, doesn't fix the problem. It seems that I will need to change
    my `tsconfig.json` `target` property to `es2017` or higher and set the `module`
    property to `esnext`. Adding the `module` property means that I want to use ES
    modules, which is a relatively new way to handle modules and is beyond the scope
    of this book. To enable ES modules, I need to set the `type` property in my `package.json`
    file to `module`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有解决问题。看起来我需要将我的 `tsconfig.json` 的 `target` 属性更改为 `es2017` 或更高版本，并将 `module`
    属性设置为 `esnext`。添加 `module` 属性意味着我想使用 ES 模块，这是一种相对较新的处理模块的方式，超出了本书的范围。为了启用 ES 模块，我需要在
    `package.json` 文件中设置 `type` 属性为 `module`。
- en: 'Now I''ve updated a couple of JSON files and am ready to try again:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经更新了几个 JSON 文件，准备再次尝试：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It still isn''t working. I''ll need to do one more thing to make this work,
    and that is to enable the experimental feature in Node.js and instruct TS Node
    to allow **ES modules** (**esm**). This requires a longer command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不起作用。我还需要做一件事才能让它工作，那就是在 Node.js 中启用实验性功能，并指导 TS Node 允许 **ES 模块**（**esm**）。这需要更长的命令：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But it works. Top-level `await` will likely become much easier and more intuitive
    to work with in the months and years ahead, so make sure to check the latest documentation
    for your runtime.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但它确实工作了。顶层 `await` 很可能在接下来的几个月和几年中变得更加容易和直观，所以请确保检查你运行时的最新文档。
- en: Promise Methods
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺方法
- en: 'In addition to the standard `next` and `catch` methods exposed by promises,
    there are a number of other convenience methods, such as `all`, `allSettled`,
    `any`, and `race`, that make working with promises nicer. How can they be used
    in the `async`/`await` world? They can actually work together quite nicely. For
    example, here is a use of `Promise.all` that employs `then` and `catch`. Given
    three promises, `p1`, `p2`, and `p3`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了承诺（promises）暴露的常规 `next` 和 `catch` 方法之外，还有一些其他便利方法，例如 `all`、`allSettled`、`any`
    和 `race`，这些方法使得与承诺（promises）一起工作更加愉快。它们如何在 `async`/`await` 世界中使用？实际上，它们可以非常和谐地一起工作。例如，这里是一个使用
    `Promise.all` 的例子，它使用了 `then` 和 `catch`。给定三个承诺，`p1`、`p2` 和 `p3`：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There isn''t any kind of `awaitAll` operator, so if we want to execute our
    promises in parallel, we''re still going to need to use `Promise.all`, but we
    can avoid chaining `then` and `catch` if we choose to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何 `awaitAll` 操作符，所以如果我们想并行执行我们的承诺，我们仍然需要使用 `Promise.all`，但如果我们选择的话，可以避免链式使用
    `then` 和 `catch`：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, we might feel like the code isn't improved by the addition of
    `await`, since we've actually expanded it from three lines to six. Some may find
    this form more readable. As always, it's a matter of personal or team preference.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会觉得添加 `await` 并没有提高代码的质量，因为我们实际上已经将代码从三行扩展到了六行。有些人可能会觉得这种形式更易于阅读。像往常一样，这取决于个人或团队的偏好。
- en: 'Exercise 13.07: async/await in Express.js'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.07：Express.js 中的 async/await
- en: In this exercise, we will build a small web application using the popular Express
    framework. Although Express was written for the JavaScript language, typings have
    been published for it and it is fully usable with TypeScript. Express is an unopinionated,
    minimalist framework for building web applications. It's one of the oldest and
    most popular frameworks in use today.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用流行的 Express 框架构建一个小型 Web 应用程序。虽然 Express 是为 JavaScript 语言编写的，但已经为其发布了类型定义，因此它可以完全与
    TypeScript 一起使用。Express 是一个无意见、极简主义的 Web 应用程序构建框架。它是目前使用最久和最受欢迎的框架之一。
- en: 'For our simple application, we''ll start a web server on port `8888` and accept
    `GET` requests. If that request has a `name` parameter in the query string, we
    will log the name in a file called `names.txt`. Then we''ll greet the user. If
    there''s no name in the query string, we log nothing and print out `Hello World!`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单应用程序，我们将在端口 `8888` 上启动一个 Web 服务器并接受 `GET` 请求。如果该请求的查询字符串中有一个 `name` 参数，我们将将其记录在名为
    `names.txt` 的文件中。然后我们将问候用户。如果没有查询字符串中的名称，我们将不记录任何内容并打印出 `Hello World!`：
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/cG4r8](https://packt.link/cG4r8).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/cG4r8](https://packt.link/cG4r8)。
- en: Let's get started by installing the Express framework and typings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Express 框架和类型定义开始吧。
- en: Enter `npm i express` to install Express as a dependency and `npm i -D @types/express
    @types/node` to install the typings that we'll need to support TypeScript.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm i express` 安装 Express 作为依赖项，并输入 `npm i -D @types/express @types/node`
    安装我们需要的类型定义。
- en: Remember the `-D` flag means that it's a `devDependency` that can be managed
    differently from a production dependency, although its use is optional.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住 `-D` 标志表示这是一个 `devDependency`，它可以与生产依赖项不同地管理，尽管它的使用是可选的。
- en: 'With our dependencies installed, let''s create a file called `express.ts`.
    The first thing to do is import `express`, create the app, add a simple handler,
    and listen on port `8888`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了依赖项之后，让我们创建一个名为 `express.ts` 的文件。首先，我们需要导入 `express`，创建应用程序，添加一个简单的处理程序，并监听端口
    `8888`：
- en: '[PRE50]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This looks very much like your standard starter Express app, other than we're
    giving types to the `Request` and `Response` objects. This is already enormously
    useful as we'll be able to use IntelliSense and ascertain what methods we can
    call on those objects without having to look them up.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来非常像你的标准 Express 入门应用程序，除了我们为 `Request` 和 `Response` 对象提供了类型。这已经非常有用了，因为我们能够使用
    IntelliSense 并确定可以调用这些对象上的哪些方法，而无需查找它们。
- en: Our requirements say that we need to listen for a `name` parameter in the query
    string. We might see a request that looks like `http://localhost:8888/?name=Matt`,
    to which we should respond `Hello Matt!`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的要求是，我们需要监听查询字符串中的 `name` 参数。我们可能会看到一个看起来像 `http://localhost:8888/?name=Matt`
    的请求，对此我们应该响应 `Hello Matt!`。
- en: 'The query string is in the `Request` object. If we delve into the typings,
    it is typed as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询字符串位于 `Request` 对象中。如果我们深入研究类型定义，它被标记如下：
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This basically means that it is a hash of key/value pairs and nested key/value
    pairs. In our case, we would expect to see a query object that looks like `{ name:
    ''Matt'' }`. Thus, we can get the `name` attribute by using `const { name } =
    req.query;`. Then we can respond to the request with something like ``res.send(`Hello
    ${name ?? ''World''}!`);``. In this case, we''re using the nullish coalesce operator
    (`??`) to say that we''ll fall back to the `World` string if the `name` variable
    has a nullish (null or undefined) value. We could also use the fallback or logical
    OR operator, `||`.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这基本上意味着它是一个键/值对的哈希表和嵌套键/值对的哈希表。在我们的情况下，我们预计会看到一个查询对象，其外观类似于 `{ name: ''Matt''
    }`。因此，我们可以通过使用 `const { name } = req.query;` 来获取 `name` 属性。然后我们可以用类似 `res.send(`Hello
    ${name ?? ''World''}!`);` 的方式响应请求。在这种情况下，我们使用了空值合并运算符 (`??`) 来表示如果 `name` 变量具有空值（null
    或 undefined），我们将回退到 `World` 字符串。我们也可以使用回退或逻辑 OR 运算符 `||`。'
- en: 'The updated code now looks like this:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的代码现在看起来是这样的：
- en: '[PRE52]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'One requirement is still missing. We need to log the name to a file if it exists.
    To do that, we''ll need to use the `fs` library from Node.js. We''ll also use
    the `path` library to resolve a path to the file we want to write to. First, add
    the new imports:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个要求尚未满足。如果存在，我们需要将名称记录到文件中。为此，我们需要使用 Node.js 的 `fs` 库。我们还将使用 `path` 库来解析要写入的文件的路径。首先，添加新的导入：
- en: '[PRE53]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we''ll use the `promises` API from `fs` to asynchronously write to our
    log file. Since this is a log, we want to append to it, not overwrite it on each
    request. We''ll use `appendFile` and write the name along with a newline character.
    We want this operation to repeat before returning:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `fs` 的 `promises` API 以异步方式将内容写入我们的日志文件。由于这是一个日志，我们希望每次请求时都追加到它，而不是覆盖它。我们将使用
    `appendFile` 并写入名称以及换行符。我们希望在返回之前重复此操作：
- en: '[PRE54]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's almost it, but we should have a warning by now that our handler function
    isn't properly async. All we need to do is add the `async` keyword to it.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这几乎就完成了，但现在我们应该已经意识到我们的处理函数没有正确地使用异步。我们只需要将其添加到 `async` 关键字。
- en: 'The completed code looks like this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的代码如下所示：
- en: '[PRE55]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the program with `npx ts-node express.ts` and try hitting the URL at `http://localhost:8888?name=your_name`
    a few times. Try hitting that URL with different names and watch your log file
    increment. Here are a few examples.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npx ts-node express.ts` 运行程序，并尝试多次点击 `http://localhost:8888?name=your_name`
    的 URL。尝试使用不同的名称点击该 URL，并观察你的日志文件递增。以下是一些示例。
- en: 'The following is the browser output for your_name:![Figure 13.1: Browser message
    for name = your_name'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为 your_name 生成的浏览器输出：![图 13.1：名称为 your_name 的浏览器消息
- en: '](img/B14508_13_01.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14508_13_01.jpg](img/B14508_13_01.jpg)'
- en: 'Figure 13.1: Browser message for name = your_name'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.1：名称为 your_name 的浏览器消息
- en: 'The following is the browser output for Matt:![Figure 13.2: Browser message
    for name = Matt'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为 Matt 生成的浏览器输出：![图 13.2：名称为 Matt 的浏览器消息
- en: '](img/B14508_13_02.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14508_13_02.jpg](img/B14508_13_02.jpg)'
- en: 'Figure 13.2: Browser message for name = Matt'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.2：名称为 Matt 的浏览器消息
- en: 'The following is the browser output for Albert Einstein:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为阿尔伯特·爱因斯坦生成的浏览器输出：
- en: '![Figure 13.3: Browser message for name = Albert Einstein'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3：名称为 Albert Einstein 的浏览器消息'
- en: '](img/B14508_13_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14508_13_03.jpg](img/B14508_13_03.jpg)'
- en: 'Figure 13.3: Browser message for name = Albert Einstein'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：名称为 Albert Einstein 的浏览器消息
- en: 'The `names.txt` file will increment as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`names.txt` 文件将按以下方式递增：'
- en: '![Figure 13.4: Log file'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：日志文件'
- en: '](img/B14508_13_04.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14508_13_04.jpg](img/B14508_13_04.jpg)'
- en: 'Figure 13.4: Log file'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：日志文件
- en: 'Exercise 13.08: NestJS'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.08：NestJS
- en: 'In contrast to Express, NestJS is a highly opinionated and fully featured framework
    for building TypeScript applications. NestJS can be used to quickly bootstrap
    an application. It provides out-of-the-box support for middleware, GraphQL, and
    Websockets. It ships with ESLint, a dependency injection framework, a test framework,
    and many other useful things. Some developers really enjoy working with such a
    full-featured framework and others find all the boilerplate oppressive and prefer
    to work with something more bare-bones, such as Express:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Express 相比，NestJS 是一个高度意见化且功能齐全的框架，用于构建 TypeScript 应用程序。NestJS 可以快速启动应用程序。它提供了中间件、GraphQL
    和 Websockets 的开箱即用支持。它附带 ESLint、依赖注入框架、测试框架以及许多其他有用的东西。一些开发者非常喜欢使用这样一个功能齐全的框架，而另一些开发者则觉得所有样板代码都令人压抑，更愿意使用更裸骨的工具，如
    Express：
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/blRq3](https://packt.link/blRq3).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该练习的代码文件可以在以下位置找到：[https://packt.link/blRq3](https://packt.link/blRq3)。
- en: Let's bootstrap a new NestJS application and give it a closer look.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个新的 NestJS 应用程序，并对其进行更详细的了解。
- en: 'NestJS applications can be generated by a `npm`. Install that package globally:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NestJS 应用程序可以通过 `npm` 生成。全局安装该包：
- en: '[PRE56]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we use the CLI, it will generate a project by creating a new directory
    inside the directory we entered the command into, so you may want to change the
    directory to where you store your projects. Then, generate the project:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用 CLI 时，它会在我们输入命令的目录内创建一个新的目录来生成项目，因此你可能想要将目录更改为你存储项目的地方。然后，生成项目：
- en: '[PRE57]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here the project is named `async-nest`. You can name it differently. NestJS
    will automatically install all dependencies and bootstrap a bare-bones application.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里项目被命名为 `async-nest`。你可以将其命名为其他名称。NestJS 将自动安装所有依赖项并启动一个裸骨应用。
- en: 'Change directory into your new application and start looking at the code. If
    you pop open `main.ts`, you''ll see `async`/`await` already in use. That module
    will look something like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到你的新应用程序目录，并开始查看代码。如果你打开 `main.ts`，你会看到已经使用了 `async`/`await`。该模块看起来可能像这样：
- en: '[PRE58]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: NestJS is built on top of Express. This code will create a new Express application.
    The internals of Express are not exposed to you as you write NestJS code, but
    you always have the option to drop down to them if you need something not supported
    by NestJS.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NestJS 是建立在 Express 之上的。这段代码将创建一个新的 Express 应用程序。Express 的内部结构在编写 NestJS 代码时不会暴露给你，但如果你需要
    NestJS 不支持的功能，你始终可以选择降级到它们。
- en: Let's go over a few useful commands that you can start using immediately. If
    you type `npm test` (or `npm t`), you'll launch a test run by the Jest framework.
    This test launches an instance of your application, invokes it, and then shuts
    it down after verifying the expected response was received. NestJS ships with
    fixtures that allow a light version of your app to be tested.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一些你可以立即开始使用的有用命令。如果你输入 `npm test`（或 `npm t`），Jest 框架将启动一个测试运行。这个测试将启动你的应用程序的一个实例，调用它，并在验证预期的响应被接收后关闭它。NestJS
    随带提供了一些固定值，允许测试你的应用程序的轻量级版本。
- en: It's a great idea to continue adding unit and integration tests to your app
    as you work on it. TypeScript can help you ensure code correctness, but only tests
    will guarantee that your app is behaving as it should.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你开发应用程序的过程中，继续添加单元和集成测试是一个很好的主意。TypeScript 可以帮助你确保代码的正确性，但只有测试才能保证你的应用程序按预期运行。
- en: Another useful command is `npm run lint`. This will check your code style and
    notify you of any issues with it by using the popular ESLint library.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个有用的命令是 `npm run lint`。这将检查你的代码风格，并通过使用流行的 ESLint 库通知你任何与之相关的问题。
- en: Finally, you can type `npm run start:dev` to run the development server in watch
    mode, which means the server will restart whenever you change a file.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以输入 `npm run start:dev` 来以监视模式运行开发服务器，这意味着每次你更改文件时，服务器都会重新启动。
- en: Try running that now and navigate to `http://localhost:3000` and you'll see
    the `Hello World` message. If you open the file called `app.service.ts` and change
    the message returned there, you can just refresh your browser and you should see
    the message change.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试运行它，并导航到 `http://localhost:3000`，你将看到“Hello World”消息。如果你打开名为 `app.service.ts`
    的文件并更改那里返回的消息，你只需刷新浏览器，就应该能看到消息已更改。
- en: 'Now that we''ve seen this simple Hello World app done in two very different
    frameworks, let''s add the same greeting and logging functionality that we did
    in *Exercise 13.07: async/await in Express.js*.'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在两个非常不同的框架中完成的简单的 Hello World 应用程序，让我们添加与在 *练习 13.07：Express.js 中的
    async/await* 中所做的相同的问候和日志记录功能。
- en: To add the custom greeting based on the query param, let's open two files, `app.controller.ts`
    and `app.service.ts`. Notice that `app.service.ts` implements a `getHello` function
    that returns the string "Hello World!". We will need to change this function to
    accept a `name` argument.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了根据查询参数添加自定义问候语，让我们打开两个文件，`app.controller.ts` 和 `app.service.ts`。注意 `app.service.ts`
    实现了一个返回字符串 "Hello World!" 的 `getHello` 函数。我们需要将这个函数更改为接受一个 `name` 参数。
- en: 'Add the `name` argument with the `string` type to the function''s argument
    list, and then change the return to a string template and say Hello. You''ll have
    something like this:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `name` 参数以 `string` 类型添加到函数的参数列表中，然后将返回值更改为字符串模板并说“Hello”。你将得到类似这样的结果：
- en: '[PRE59]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is a simple refactor. If we check `app.controller.ts`, we'll see that our
    IDE is now telling us that `getHello` needs an argument and we're not done yet.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的重构。如果我们检查 `app.controller.ts`，我们会看到我们的 IDE 现在告诉我们 `getHello` 需要一个参数，我们还没有完成。
- en: In the Express application, we found our query parameter on the built-in `Request`
    object. You could do the same thing in NestJS, but it's more common and preferable
    to use a decorator. Decorators are special functions that wrap other functions.
    They are sometimes called higher-order functions and are similar to aspects of
    languages such as Java.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Express 应用程序中，我们在内置的 `Request` 对象上找到了我们的查询参数。你同样可以在 NestJS 中做同样的事情，但更常见且更受欢迎的做法是使用装饰器。装饰器是特殊的函数，它们封装其他函数。它们有时被称为高阶函数，类似于
    Java 等语言的一些特性。
- en: The decorator we want to use is `@Query`, which takes an argument of the name
    of the query parameter and then binds that parameter to one of our function arguments.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要使用的装饰器是 `@Query`，它接受一个参数，即查询参数的名称，然后将该参数绑定到我们的函数参数之一。
- en: 'We can import that decorator from `@nestjs/common`. Then we add the function
    argument to `getHello` and pass it through to the service call. One more thing
    that''s a good idea is to set a default so that we maintain backward compatibility
    and don''t print out `Hello undefined` if we fail to give an argument. Adding
    the default may prompt a hint that you no longer need the type annotation as it
    is trivially inferred from the default type. Go ahead and remove it if you like:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从 `@nestjs/common` 中导入那个装饰器。然后我们将函数参数添加到 `getHello` 中，并将其传递给服务调用。还有一件事值得注意，那就是设置一个默认值，这样我们就可以保持向后兼容性，并且在我们未能提供参数时不会打印出
    `Hello undefined`。添加默认值可能会提示你不再需要类型注解，因为它可以从默认类型中轻易推断出来。如果你喜欢，可以将其删除：
- en: '[PRE60]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The dev server should restart and now, if we browse to `http://localhost:3000/?name=Matt`,
    we''ll see `Hello Matt!`:![Figure 13.5: Browser message for name = Matt'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发服务器应该会重新启动，现在，如果我们浏览到 `http://localhost:3000/?name=Matt`，我们会看到 `Hello Matt!`：![图
    13.5：name = Matt 的浏览器消息
- en: '](img/B14508_13_05.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14508_13_05.jpg]'
- en: 'Figure 13.5: Browser message for name = Matt'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.5：name = Matt 的浏览器消息'
- en: Now let's add the same logging functionality that we implemented in Express.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们在 Express 中实现的相同日志功能。
- en: In a full-scale application, we'd probably want to build a separate logging
    service class. For our purposes, we can implement that as a separate `async` method.
    Add the method to `app.service.ts` and call it with `await` from `getHello`. Test
    it to be sure that it's working correctly.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个完整规模的应用程序中，我们可能想要构建一个单独的日志服务类。为了我们的目的，我们可以将其实现为一个单独的 `async` 方法。将方法添加到 `app.service.ts`
    中，并从 `getHello` 中使用 `await` 调用它。测试以确保它正确工作。
- en: There are a few gotchas here. One is that NestJS is automatically transpiling
    and serving your code from a folder called `dist`, so you'll find your `names.txt`
    file in there once you start logging names. But the bigger trick here is that
    in order to await the logging, we need to make `getHello` in `app.service.ts`
    into an `async` method. This, in turn, will mean that `getHello` in `app.controller.ts`
    must also be `async`. What will changing these methods to `async` do to our app?
    Nothing! NestJS already knows how to resolve the promises before returning the
    request.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的问题。一个是 NestJS 会自动将代码从名为 `dist` 的文件夹中转换并提供服务，所以一旦你开始记录名称，你会在那里找到你的
    `names.txt` 文件。但更大的技巧是，为了等待记录，我们需要将 `app.service.ts` 中的 `getHello` 方法改为 `async`
    方法。这反过来又意味着 `app.controller.ts` 中的 `getHello` 也必须是 `async`。将这些方法改为 `async` 会对我们应用程序产生什么影响？没有！NestJS
    已经知道如何在返回请求之前解决承诺。
- en: 'One more thing to check out in this exercise is the unit test. Since we''ve
    set a default value for the `name` attribute, the test should still work, right?
    Well actually, it doesn''t. Try running `npm test` and you''ll see the problem.
    The issue is that the test isn''t expecting `getHello` to be async. That''s OK.
    We can fix it by making the test callback `async` to look like this:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，还有一件事需要检查，那就是单元测试。由于我们已为 `name` 属性设置了一个默认值，测试应该仍然有效，对吧？实际上，它不起作用。尝试运行
    `npm test`，你会看到问题。问题是测试没有期望 `getHello` 是异步的。没关系。我们可以通过使测试回调 `async` 来修复它，如下所示：
- en: '[PRE61]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The test should now pass. Try adding another test with an argument.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试现在应该通过。尝试添加另一个带有参数的测试。
- en: 'Exercise 13.09: TypeORM'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.09：TypeORM
- en: TypeORM is an object relational mapper written in, and for, TypeScript. TypeORM
    supports many popular databases, such as MySQL, Postgres, SQL Server, SQLite,
    and even MongoDB and Oracle. TypeORM is often used in NestJS applications, so
    in this exercise we will add a local in-memory SQLite database to work with our
    NestJS application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM 是一个用 TypeScript 编写并针对 TypeScript 设计的对象关系映射器。TypeORM 支持许多流行的数据库，例如 MySQL、Postgres、SQL
    Server、SQLite，甚至 MongoDB 和 Oracle。TypeORM 经常用于 NestJS 应用程序中，因此在这个练习中，我们将添加一个本地的内存
    SQLite 数据库来与我们的 NestJS 应用程序一起工作。
- en: 'In this exercise, you will build another REST service to help us keep track
    of the promises we make. Since `Promise` is the name of a built-in object in TypeScript,
    let''s use the term "pledge" so we can differentiate domain concepts from language abstractions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建另一个 REST 服务，帮助我们跟踪我们做出的承诺。由于 `Promise` 是 TypeScript 中内置对象的名称，让我们使用“pledge”这个术语，这样我们就可以区分领域概念和语言抽象：
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/ZywYh](https://packt.link/ZywYh).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/ZywYh](https://packt.link/ZywYh)。
- en: 'To get started, let''s bootstrap a new NestJS project:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，让我们启动一个新的 NestJS 项目：
- en: '[PRE62]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'NestJS has a powerful module system that lets us build out different functional
    areas of our application in cohesive chunks. Let''s create a new module for pledges:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NestJS 有一个强大的模块系统，允许我们将应用程序的不同功能区域构建成连贯的块。让我们为承诺创建一个新的模块：
- en: '[PRE63]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This command will generate a new module under the `/pledge` subdirectory.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令将在 `/pledge` 子目录下生成一个新的模块。
- en: 'We''re also going to need a controller and a service for the pledge API, so
    let''s generate those using the NestJS CLI:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为承诺 API 创建一个控制器和服务，所以让我们使用 NestJS CLI 生成它们：
- en: '[PRE64]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we need to install the `typeorm` library, SQLite3, and NestJS integration:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要安装 `typeorm` 库、SQLite3 和 NestJS 集成：
- en: '[PRE65]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: TypeORM maps database tables to TypeScript entities by means of decorators on
    plain objects.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypeORM 通过在普通对象上的装饰器将数据库表映射到 TypeScript 实体。
- en: 'Let''s create `pledge.entity.ts` under `/pledge` and create our first entity:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `/pledge` 下创建 `pledge.entity.ts` 并创建我们的第一个实体：
- en: '[PRE66]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For this entity, we're using a few specialized decorators, such as `PrimaryGeneratedColumn`.
    These decorators can be very powerful but often rely on underlying database functionality.
    Because SQLite can generate an ID for our table, TypeORM is able to expose that
    in a declarative way with a decorator, but if it couldn't, this wouldn't work.
    It's always good to check the documentation before proceeding with a new implementation.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个实体，我们使用了几个专门的装饰器，例如 `PrimaryGeneratedColumn`。这些装饰器可能非常强大，但通常依赖于底层数据库功能。因为
    SQLite 可以为我们生成表 ID，TypeORM 能够通过装饰器以声明式的方式暴露这一点，但如果它不能这样做，那么这就不起作用了。在开始新的实现之前检查文档总是好的。
- en: Now that we have an entity, we need to provide configuration to TypeORM about
    what our database is and where to find it, as well as what entities we want to
    map. For databases such as MySQL and Postgres, this might include a URI as well
    as database credentials. Since SQLite is a file-based database, we will just provide
    the name of the file we want to write.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个实体，我们需要向 TypeORM 提供配置，说明我们的数据库是什么以及在哪里可以找到它，以及我们想要映射哪些实体。对于 MySQL 和 Postgres
    等数据库，这可能包括 URI 以及数据库凭据。由于 SQLite 是基于文件的数据库，我们只需提供我们想要写入的文件名。
- en: Note that production database credentials should always be handled safely, and
    the best practices for doing so are beyond the scope of this book, but suffice
    to say that they shouldn't be checked into your version control.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，生产数据库凭据应始终安全处理，而这样做最佳实践超出了本书的范围，但可以说，它们不应该被提交到版本控制中。
- en: 'Let''s configure our application to use SQLite. We want to configure TypeORM
    at the root of our application, so let''s import the module into `app.module.ts`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们配置我们的应用程序以使用 SQLite。我们希望在应用程序的根目录下配置 TypeORM，所以让我们将模块导入到 `app.module.ts`：
- en: '[PRE67]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Doing this will require a couple of more imports at the top of the module:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事需要在模块顶部进行几个额外的导入：
- en: '[PRE68]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''re letting NestJS know that our application will use a SQLite database
    and will manage the `Pledge` entity. By setting `synchronize: true`, we are telling
    TypeORM to automatically create any entities that don''t already exist in the
    database when the application starts. This setting should NOT be used in production
    as it may cause data loss. TypeORM supports migrations for managing databases
    in production environments, another topic beyond the scope of this book.'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们让 NestJS 知道我们的应用程序将使用 SQLite 数据库并管理 `Pledge` 实体。通过设置 `synchronize: true`，我们告诉
    TypeORM 在应用程序启动时自动创建数据库中尚不存在的任何实体。这个设置不应该在生产环境中使用，因为它可能会导致数据丢失。TypeORM 支持迁移，用于在生产环境中管理数据库，这是本书范围之外的另一个主题。'
- en: If we start our application now with `npm run start:dev`, it will start up and
    we'll get a new binary file (the SQLite database) called `db`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `npm run start:dev` 启动应用程序，它将启动，我们会得到一个名为 `db` 的新二进制文件（SQLite 数据库）。
- en: 'Before we can use the `Pledge` entity in our new module, we need to do a little
    more boilerplate. Open up `pledge.module.ts` and add an import so that the module
    looks like this:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以在新模块中使用 `Pledge` 实体之前，我们需要做一些额外的样板代码。打开 `pledge.module.ts` 并添加一个导入，使模块看起来像这样：
- en: '[PRE69]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This will allow the `Pledge` entity to be used by `pledge.service.ts`. Again,
    NestJS has quite a lot of boilerplate, which may be jarring to developers who
    are used to unopinionated ExpressJS workflows. This module system can help us
    to isolate our application into functional areas. It's a good idea to understand
    the benefits of a structured application before deciding whether a framework such
    as NestJS is right for your application or team.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许 `Pledge` 实体被 `pledge.service.ts` 使用。再次强调，NestJS 有很多样板代码，这可能会让习惯于无意见的 ExpressJS
    工作流程的开发者感到不适。这个模块系统可以帮助我们将应用程序隔离到功能区域。在决定是否将 NestJS 这样的框架用于您的应用程序或团队之前，了解结构化应用程序的好处是一个好主意。
- en: We can now start to build out our `Pledge` service. TypeORM supports both Active
    Record, where an entity itself has methods for reading and updating, and Data
    Mapper, where such functionality is delegated to a `Repository` object. We will
    follow the Data Mapper pattern in this exercise.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以开始构建我们的 `Pledge` 服务了。TypeORM 支持两种模式：Active Record，其中实体本身具有读取和更新的方法，以及
    Data Mapper，其中此类功能委托给 `Repository` 对象。在这个练习中，我们将遵循 Data Mapper 模式。
- en: 'To start, we will add a constructor to the `Pledge` service and inject the
    repository to expose it as a private member of the class. Once we''ve done that,
    we can start to access some of the repository methods:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在 `Pledge` 服务中添加一个构造函数并注入存储库，将其暴露为类的私有成员。一旦我们这样做，我们就可以开始访问一些存储库方法了：
- en: '[PRE70]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We've now exposed a `findAll` method, which will query the database for all
    the `Pledge` entities and return them in an array.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在公开了一个 `findAll` 方法，它将查询数据库中的所有 `Pledge` 实体并将它们作为一个数组返回。
- en: 'In a production application, it can often be a good idea to implement pagination,
    but this will do for our purposes. Let''s implement some other methods:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产应用程序中，实现分页通常是一个好主意，但这对我们的目的来说已经足够了。让我们实现一些其他方法：
- en: '[PRE71]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can get pretty far using just repository methods, which will generate SQL
    queries for us, but it's also possible to use SQL or a query builder with TypeORM.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用存储库方法走得很远，这些方法会为我们生成 SQL 查询，但也可以使用 TypeORM 的 SQL 或查询构建器。
- en: 'Implementing these methods in a service won''t expose them to our API, so we
    need to add matching controller methods in `pledge.controller.ts`. Each controller
    method will delegate to a service method and NestJS will take care of gluing all
    the pieces together:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务中实现这些方法不会将它们暴露给我们的 API，因此我们需要在 `pledge.controller.ts` 中添加匹配的控制器方法。每个控制器方法将委托给服务方法，NestJS
    将负责将这些部分粘合在一起：
- en: '[PRE72]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This controller will automatically inject the service and can then easily map
    service methods to API endpoints using decorators and dependency injection.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个控制器将自动注入服务，然后可以使用装饰器和依赖注入轻松地将服务方法映射到 API 端点。
- en: Since we ran our application with `npm run start:dev`, it should hot reload
    through all these changes.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用 `npm run start:dev` 运行应用程序，它应该会通过所有这些更改进行热重载。
- en: 'Check the console and make sure there are no errors. If our code is correct,
    we can use a REST client such as Postman to start sending requests to our service.
    If we send a `POST` request with a payload such as `{"desc":"Always lint your
    code", "kept": true}` to `http://localhost:3000/pledge`, we''ll get back a `201
    Created` HTTP response. Then we can issue `GET` requests to `http://localhost:3000/pledge`
    and `http://localhost:3000/pledge/1` to see our record that was stored in SQLite.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '检查控制台，确保没有错误。如果我们的代码是正确的，我们可以使用 Postman 这样的 REST 客户端开始向我们的服务发送请求。如果我们向 `http://localhost:3000/pledge`
    发送包含如下负载的 `POST` 请求：`{"desc":"Always lint your code", "kept": true}`，我们将得到一个 `201
    Created` 的 HTTP 响应。然后我们可以发出 `GET` 请求到 `http://localhost:3000/pledge` 和 `http://localhost:3000/pledge/1`，以查看存储在
    SQLite 中的记录。'
- en: In this exercise, we used NestJS and TypeORM to build a real web API that can
    create and retrieve records from a SQLite database. Doing this isn't very different
    from using a real production-grade database such as MySQL or PostgreSQL.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了 NestJS 和 TypeORM 来构建一个真实的网络 API，该 API 可以从 SQLite 数据库中创建和检索记录。这样做与使用像
    MySQL 或 PostgreSQL 这样的真实生产级数据库并没有太大的区别。
- en: 'Activity 13.01: Refactoring Chained Promises to Use await'
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 13.01：将链式承诺重构为使用 await
- en: 'In this activity, we will refactor a function that chains promises together
    to use `await`. You are supplied with a starter program that is meant to simulate
    the creation of DOM elements for a website and render them one after another.
    In reality, most sites will want to render in parallel, but it''s possible that
    information from one component might inform the rendering of another. It is good
    enough for example purposes in any case:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将重构一个将承诺链在一起的函数，以使用 `await`。你将得到一个入门程序，旨在模拟为网站创建DOM元素并依次渲染它们。在现实中，大多数网站都希望并行渲染，但可能一个组件的信息可能会影响另一个组件的渲染。在任何情况下，这对于示例来说都是足够的：
- en: Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this activity can be found here: [https://packt.link/L5r76](https://packt.link/L5r76).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的代码文件可以在以下链接找到：[https://packt.link/L5r76](https://packt.link/L5r76)。
- en: Start by running the program as-is with `npx ts-node src/refactor.ts`. You'll
    get each message in sequence.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `npx ts-node src/refactor.ts` 运行程序。你会按顺序得到每条消息。
- en: Now, refactor the `renderAll` function to use `async`/`await`. You shouldn't
    have to touch any other parts of the code to make this work. When your refactoring
    is complete, run the program again and verify that the output hasn't changed.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `renderAll` 函数重构为使用 `async`/`await`。你不需要修改代码的其他部分来实现这一点。当你完成重构后，再次运行程序并验证输出是否已更改。
- en: 'The code for the starter program (`refactor.ts`) is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 入门程序的代码（`refactor.ts`）如下：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once you run the program, you should get the following output:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，你应该得到以下输出：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor444).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor444)找到。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Asynchronous programming has come a long way in the past 10 years and the introduction
    of `async`/`await` has continued to move it forward. Although not perfect for
    every use case, this syntactic sugar has proven very popular with the TypeScript
    community and has gained widespread acceptance in popular libraries and frameworks.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10年里，异步编程已经取得了长足的进步，而 `async`/`await` 的引入继续推动其发展。尽管它并不适合每个用例，但这种语法糖在TypeScript社区中非常受欢迎，并在流行的库和框架中得到了广泛接受。
- en: In this chapter, we went over `async`/`await` syntax, how it came to be part
    of the language, and how the use of this syntax is actually complimentary to promises.
    We then toured several popular frameworks in use by TypeScript developers to see
    how application developers use promises and asynchronous programming to develop
    powerful web applications.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 `async`/`await` 语法，它是如何成为语言的一部分，以及这种语法的使用实际上是如何与承诺（promises）相辅相成的。然后，我们游览了几个TypeScript开发者常用的流行框架，以了解应用开发者如何使用承诺和异步编程来开发强大的Web应用程序。
- en: This concludes this book's study of language features. The next chapter will
    look at React for building user interfaces using TypeScript.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书对语言特性的研究到此结束。下一章将探讨使用TypeScript构建用户界面的React。
