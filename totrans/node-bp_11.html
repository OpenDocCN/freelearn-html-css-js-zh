<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;11.&#xA0;Writing a REST API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Writing a REST API</h1></div></div></div><p class="calibre7">In the previous chapter, we learned how to optimize our CSS writing. We learned about the most popular architectural concepts and checked out the available CSS preprocessors. This chapter is about building a REST API with Node.js. We are going to:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Run a web server</li><li class="listitem">Implement routing mechanisms</li><li class="listitem">Process the incoming requests</li><li class="listitem">Send a proper response</li></ul></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Writing a REST API">
<div class="book" title="Discovering REST and API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec72" class="calibre1"/>Discovering REST and API</h1></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">REST</strong></span><a id="id576" class="calibre1"/> stands for <span class="strong"><strong class="calibre8">Representational State Transfer</strong></span> and it is an architectural principle of the Web. In most of the cases, we have resources on the server that need to be created, fetched, updated, or deleted. The REST APIs<a id="id577" class="calibre1"/> provide mechanisms to perform all these operations. Every resource has its own URI and based on the request method, a different action occurs. For example, let's say that we need to manage the users in our social network. To retrieve information about a specific user, we will perform the <code class="email">GET</code> request<a id="id578" class="calibre1"/> to the <code class="email">/user/23</code> address, where the number, <code class="email">23</code>, is the ID of the user. To update the data, we will send the <code class="email">PUT</code> request<a id="id579" class="calibre1"/> to the same URL, and to delete the record, we'll send the<a id="id580" class="calibre1"/> <code class="email">DELETE</code> request. The <code class="email">POST</code> requests<a id="id581" class="calibre1"/> are reserved to create new resources. In other words, the resources' management on the server happens via HTTP requests sent to carefully selected addresses by using the <code class="email">GET</code>, <code class="email">POST</code>, <code class="email">PUT</code>, and <code class="email">DELETE</code> methods, which are very often called <a id="id582" class="calibre1"/>
<span class="strong"><strong class="calibre8">HTTP verbs</strong></span>. A lot of companies adopt this architecture because it is simple, works through the HTTP protocol, and is highly scalable. There are, of course, different approaches such as SOAP<a id="id583" class="calibre1"/> or CORBA<a id="id584" class="calibre1"/> but we have many more rules to follow and the communication between the machines is very often complicated.</p><p class="calibre7">According to Wikipedia, an <span class="strong"><strong class="calibre8">Application Programming Interface</strong></span> (<span class="strong"><strong class="calibre8">API</strong></span>) specifies<a id="id585" class="calibre1"/> how some software components should interact with each other. The API is usually the part of our program that is visible to the outside world.</p><p class="calibre7">In this chapter, we will build one. It's an API of a simple online books library. The resources are the books and they will be accessed through the REST API.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Developing an online library &#x2013; a REST API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec73" class="calibre1"/>Developing an online library – a REST API</h1></div></div></div><p class="calibre7">The<a id="id586" class="calibre1"/> development of a REST API<a id="id587" class="calibre1"/> is the same as the development of every other Node.js application. We need to plan it and carefully implement the different components one by one.</p></div>

<div class="book" title="Developing an online library &#x2013; a REST API">
<div class="book" title="Defining the API parts"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec80" class="calibre1"/>Defining the API parts</h2></div></div></div><p class="calibre7">It's always good to have a <a id="id588" class="calibre1"/>plan before starting a new project. So, let's define the main parts of the API server as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Router</strong></span>: We<a id="id589" class="calibre1"/> know<a id="id590" class="calibre1"/> that Node.js starts listening on a port and accepts an HTTP requests. So, we need a class that will handle them and pass the request to the right logic.</li><li class="listitem"><span class="strong"><strong class="calibre8">Handler</strong></span>: This<a id="id591" class="calibre1"/> is the<a id="id592" class="calibre1"/> place where our logic will be put in. It will process the request and prepare the response.</li><li class="listitem"><span class="strong"><strong class="calibre8">Responder</strong></span>: We <a id="id593" class="calibre1"/>also need a class<a id="id594" class="calibre1"/> that will send the result to the browser. Very often the API has to respond in different formats. For example, XML and, at the same time, JSON.</li></ul></div></div></div>

<div class="book" title="Developing an online library &#x2013; a REST API">
<div class="book" title="Writing the base"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec81" class="calibre1"/>Writing the base</h2></div></div></div><p class="calibre7">Node.js<a id="id595" class="calibre1"/> is very often used to <a id="id596" class="calibre1"/>build REST APIs. Also, because it is a common task, we have several possible approaches. There are even ready-to-use modules such as <code class="email">rest.js</code> or <code class="email">restify</code>. However, we are going to build our REST API from scratch because it will be much more interesting and challenging. We will start by running a Node.js server. Let's create an empty directory and put the following code into the <code class="email">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
var router = function(req, res) {
  res.end('API response');
}
http.createServer(router).listen('9000', '127.0.0.1');
console.log('API listening');</pre></div><p class="calibre7">If we run the script with <code class="email">node ./index.js</code>, we will<a id="id597" class="calibre1"/> be able to open <code class="email">http://127.0.0.1:9000</code> and see <span class="strong"><strong class="calibre8">API response</strong></span> on the screen. All the incoming requests are going through a function. That's the place for our router.</p></div></div>

<div class="book" title="Developing an online library &#x2013; a REST API">
<div class="book" title="Implementing the API router"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec82" class="calibre1"/>Implementing the API router</h2></div></div></div><p class="calibre7">In almost every<a id="id598" class="calibre1"/> web-based <a id="id599" class="calibre1"/>Node.js application, the router plays one of the main roles. That's because it is the entry point of the program. That's the place where the URL is mapped to logic and the request is processed. The router for the REST API should be a little bit more advanced, because it should handle not only the usual <code class="email">GET</code> and <code class="email">POST</code> requests but also <code class="email">PUT</code> and <code class="email">DELETE</code>. Along with our <code class="email">index.js</code>, we need another file called <code class="email">router.js</code>. So, add the following code to the <code class="email">router.js</code> file:</p><div class="informalexample"><pre class="programlisting">var routes = [];
module.exports = {
  register: function(method, route, handler) {
    routes.push({ method: method, route: route, handler: handler });
  },
  process: function(req, res, next) {
    // ...
  }
}</pre></div><p class="calibre7">The module exports an object with two methods. The first one (<code class="email">register</code>) stores records in the <code class="email">routes</code> variable. The second method (<code class="email">process</code>) will be used as a handler of the <code class="email">createServer</code> method in <code class="email">index.js</code>. The following code demonstrates how our router is used:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
var router = require('./router');
http.createServer(router.process).listen('9000', '127.0.0.1');
console.log('API listening');</pre></div><p class="calibre7">The first parameter of the <code class="email">register</code> method will be the HTTP verbs as a string: <code class="email">GET</code>, <code class="email">POST</code>, <code class="email">PUT</code>, or <code class="email">DELETE</code>. The <code class="email">route</code> parameter will be a regular expression and, the last one, a function will be called if the expression matches the current URL.</p><p class="calibre7">The <code class="email">process</code> method will do several things. It will run the defined regular expression against the current request. It will also do few more things, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Fetching the <code class="email">GET</code> parameters from the URL</li><li class="listitem">Fetching the <code class="email">POST</code>/<code class="email">PUT</code> parameters passed with the request</li><li class="listitem">Supporting dynamic URLs</li></ul></div><p class="calibre7">All these mentioned<a id="id600" class="calibre1"/> things could be implemented outside the <code class="email">router</code> variable <a id="id601" class="calibre1"/>but because they are common tasks and we will probably have them in several places, we will add them in the following code. The following code is the full code of the router's <code class="email">process</code> method:</p><div class="informalexample"><pre class="programlisting">process: function(req, res, next) {
  var urlInfo = url.parse(req.url, true);
  var info = {
    get: urlInfo.query,
    post: {},
    path: urlInfo.pathname,
    method: req.method
  }
  for(var i=0; i&lt;routes.length; i++) {
    var r = routes[i];
    var match = info.path.match(r.route);
    if((info.method === r.method || '' === r.method) &amp;&amp; match) {
      info.match = match;
      if(info.method === 'POST' || info.method === 'PUT') {
        processRequest(req, function(body) {
          info.post = body;
          r.handler(req, res, info);
        });
      } else {
        r.handler(req, res, info);
      }
      return;
    }
  }
  res.end('');
}</pre></div><p class="calibre7">There is an <code class="email">info</code> object holding the data which we talked about. We cycled over all the routes and tried to find one which has method and regular expression matching. We also checked if the request method is <code class="email">POST</code> or <code class="email">PUT</code> and got the sent information. At the end, if there is no matching route, we send an empty string. To get the preceding code working, we need to define two variables and one function, which are done in the following code:</p><div class="informalexample"><pre class="programlisting">var url = require('url');
var qs = require('querystring');
var processRequest = function(req, callback) {
  var body = '';
    req.on('data', function (data) {
        body += data;
    });
    req.on('end', function () {
        callback(qs.parse(body));
    });
}</pre></div><p class="calibre7">The<a id="id602" class="calibre1"/> entities, <code class="email">url</code> and <code class="email">querystring</code>, are native Node.js modules. The <code class="email">processRequest</code> variable <a id="id603" class="calibre1"/>is needed because Node.js handles the <code class="email">POST</code>/<code class="email">PUT</code> parameters differently.</p><p class="calibre7">By using the preceding code, we are able to add routes and check if they work properly. For example, see the following code in the <code class="email">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">router.register('GET', /\/books(.+)?/, function(req, res, info) {
  console.log(info);
  res.end('Getting all the books')
});</pre></div><p class="calibre7">Here, we run the server with <code class="email">node ./index.js</code> and fire a request to <code class="email">http://127.0.0.1:9000/books</code>. The result is a text <code class="email">Getting all the books</code> on the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00065.jpeg" alt="Implementing the API router" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">You will also see the following output in our terminal:</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="Implementing the API router" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is no sent data so the <code class="email">get</code> and <code class="email">post</code> properties are empty. Now, let's use the following route:</p><div class="informalexample"><pre class="programlisting">router.register('POST', /\/book(.+)?/, function(req, res, info) {
  console.log(info);
  res.end('New book created')
});</pre></div><p class="calibre7">We should <a id="id604" class="calibre1"/>make sure that <a id="id605" class="calibre1"/>our API accepts the <code class="email">POST</code> and <code class="email">GET</code> requests properly; we can do that by using this route. If we send a <code class="email">POST</code> request with the data <code class="email">name=Node.js blueprints&amp;author=Krasimir Tsonev</code> to the <code class="email">http://127.0.0.1:9000/book?notification=no</code> URL, we will get the following result:</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="Implementing the API router" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is one more thing that our router does. It handles dynamic URLs. By <span class="strong"><em class="calibre9">dynamic</em></span>, we mean URLs such as <code class="email">/book/523/edit</code>, where <code class="email">523</code> is the unique ID of the book and it can be something different and we want to process all requests of this type in one specific handler as follows:</p><div class="informalexample"><pre class="programlisting">router.register('GET', /\/book\/(.+)\/(.+)?/, function(req, res, info) {
  console.log(info);
  res.end('Getting specific book')
});</pre></div><p class="calibre7">The key moment here is the regular expression. There are two capturing parentheses. The first one represents the ID of the book and the second one, the action that we want to perform. For example, <code class="email">edit</code> or <code class="email">delete</code>. The response of <code class="email">127.0.0.1:9000/book/523/edit</code> is as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00068.jpeg" alt="Implementing the API router" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As we can see, <code class="email">523</code> and <code class="email">edit</code> are a part of the <code class="email">match</code> property and we can get them easily. We can improve our router by adding a few additional helper methods. It's a good practice to provide methods for every different type of request. The following code shows how these methods look like:</p><div class="informalexample"><pre class="programlisting">get: function(route, handler) { 
  this.register('GET', route, handler); 
},
post: function(route, handler) { 
  this.register('POST', route, handler); 
},
put: function(route, handler) { 
  this.register('PUT', route, handler); 
},
del: function(route, handler) { 
  this.register('DELETE', route, handler); 
},
all: function(route, handler) { 
  this.register('', route, handler); 
}</pre></div><p class="calibre7">Instead <a id="id606" class="calibre1"/>of <code class="email">router.register('GET', /\/book\/(.+)\/(.+)?/...</code>, we can now write <code class="email">router.get(/\/book\/(.+)\/(.+)?/...</code>, which is <a id="id607" class="calibre1"/>a little bit better. The <code class="email">all</code> function could be used if we need to handle a specific URL but don't care about the <code class="email">request</code> method. The same approach is used in the Express framework, where we have the <code class="email">get</code>, <code class="email">post</code>, <code class="email">put</code>, <code class="email">delete</code>, and <code class="email">all</code> methods.</p></div></div>

<div class="book" title="Developing an online library &#x2013; a REST API">
<div class="book" title="Writing the responder"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec83" class="calibre1"/>Writing the responder</h2></div></div></div><p class="calibre7">Before writing the<a id="id608" class="calibre1"/> logic of our<a id="id609" class="calibre1"/> little REST API library, we need a proper responder, that is, a class which we will use to send the result to the browser. There is something really important that we need to take care of while we are talking about a server which works as an API. Along with the data, we have to send a proper status code. For example, <code class="email">200</code> if everything is fine or <code class="email">404</code> if the resource is missing.</p><p class="calibre7">Our responder will be saved in the <code class="email">responder.js</code> file located in the same directory as <code class="email">index.js</code> and <code class="email">router.js</code>. The module starts with the following code:</p><div class="informalexample"><pre class="programlisting">module.exports = function(res) {
  return {
    c: 200,
    code: function(c) {
      this.c = c;
      return this;
    },
    send: function(content) {
      res.end(content.toString('utf8'));
      this.c = 200;
      return this;
    }
  }
}</pre></div><p class="calibre7">The module requires the response object in order to send the result to the browser. The <code class="email">code</code> method sets the status code. We can get the latest used route and transform it to the following code:</p><div class="informalexample"><pre class="programlisting">var responder = require('./responder');
router.get(/\/book\/(.+)\/(.+)?/, function(req, res, info) {
  console.log(info);
  responder(res).code(200).send('Getting specific book');
});</pre></div><p class="calibre7">At the beginning of this chapter, we said that the API should be able to respond in different formats. We have to add a few methods in the responder to make this possible:</p><div class="informalexample"><pre class="programlisting">json: function(o) {
  res.writeHead(this.c, {'Content-Type': 'application/json; charset=utf-8'});
  return this.send(JSON.stringify(o));
},
html: function(content) {
  res.writeHead(this.c, {'Content-Type': 'text/html; charset=utf-8'});
  return this.send(content);
},
css: function(content) {
  res.writeHead(this.c, {'Content-Type': 'text/css; charset=utf-8'});
  return this.send(content);
},
js: function(content) {
  res.writeHead(this.c, {'Content-Type': 'application/javascript; charset=utf-8'});
  return this.send(content);
},
text: function(content) {
  res.writeHead(this.c, {'Content-Type': 'text/plain; charset=utf-8'});
  return this.send(content);
}</pre></div><p class="calibre7">By adding these<a id="id610" class="calibre1"/> functions, we are <a id="id611" class="calibre1"/>actually able to serve JSON, HTML, CSS, JavaScript, and plain text. The class sends a header to the browser specifying the status code, <code class="email">Content-Type</code> and <code class="email">charset</code>. All the methods of the responder return the class itself, so we can chain them.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with the database"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec74" class="calibre1"/>Working with the database</h1></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 3. Writing a Blog Application with Node.js and AngularJS" href="part0030_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre9">Writing a Blog Application with Node.js and AngularJS</em></span>, we used <a id="id612" class="calibre1"/>MongoDB and <a id="id613" class="calibre1"/>MySQL. We <a id="id614" class="calibre1"/>learned how to read, write, edit, and delete records from these databases. Let's use MongoDB in this chapter, too. We will store our data in a collection named <code class="email">books</code>. To use the database driver, we need to create a <code class="email">package.json</code> file and put the following content in it:</p><div class="informalexample"><pre class="programlisting">{
  "name": "projectname",
  "description": "description",
  "version": "0.0.1",
  "dependencies": {
    "mongodb": "1.3.20"
    "request": "2.34.0"

  }
}</pre></div><p class="calibre7">After running <code class="email">npm install</code>, we will be able to connect to the MongoDB server by using the driver installed in the <code class="email">node_modules</code> directory. The code that we need to interact with the database is the same as the one used in <a class="calibre1" title="Chapter 3. Writing a Blog Application with Node.js and AngularJS" href="part0030_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre9">Writing a Blog Application with Node.js and AngularJS</em></span>, which is as follows:</p><div class="informalexample"><pre class="programlisting">var crypto = require("crypto"),
    client = require('mongodb').MongoClient,
  mongodb_host = "127.0.0.1",
  mongodb_port = "27017",
  collection;

var connection = 'mongodb://';
connection += mongodb_host + ':' + mongodb_port;
connection += '/library';
client.connect(connection, function(err, database) {
  if(err) {
    throw new Error("Can't connect.");
  } else {
    console.log("Connection to MongoDB server successful.");
      collection = database.collection('books');
    }
});</pre></div><p class="calibre7">The<a id="id615" class="calibre1"/> <code class="email">crypto</code> module <a id="id616" class="calibre1"/>will be used to generate a unique ID for the newly created records. There is a MongoDB client initialized. It is connected to the server and makes the <code class="email">collection</code> variable point to the <code class="email">books</code> collection. That's all we need. We can now manage records of our books.</p></div>

<div class="book" title="Working with the database">
<div class="book" title="Creating a new record"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec84" class="calibre1"/>Creating a new record</h2></div></div></div><p class="calibre7">The adding of a<a id="id617" class="calibre1"/> new <a id="id618" class="calibre1"/>book into the database should happen via the <code class="email">POST</code> request. The following code is the route that will handle this task:</p><div class="informalexample"><pre class="programlisting">router.post(/\/book/, function(req, res, info) {
  var book = info.post;
  book.ID = crypto.randomBytes(20).toString('hex');
  if(typeof book.name == 'undefined') {
    responder(res).code(400).json({error: 'Missing name.'});
  } else if(typeof book.author == 'undefined') {
    responder(res).code(400).json({error: 'Missing author.'});
  } else {
    collection.insert(book, {}, function() {
      responder(res).code(201.json({message: 'Record created successful.'});  
    });  
  }
});</pre></div><p class="calibre7">The URL to<a id="id619" class="calibre1"/> add a new book is <code class="email">/book</code>. It can be accessed via the <code class="email">POST</code> method. The expected parameters are <code class="email">name</code> and <code class="email">author</code>. Notice that we are setting the <a id="id620" class="calibre1"/>status code as <code class="email">400</code> if any of these are missing. <code class="email">400</code> means <code class="email">Bad request</code>. If the user forgets to pass them, we should notify him or her of what exactly is wrong. This is really important while designing an API. The developers who use our services should know why they didn't get the proper response. Very often, the well designed APIs could be used without documentation. That's because their methods provide enough information.</p><p class="calibre7">The book's data is written in the JSON format and the answer to the browser is also sent in the JSON format. The following screenshot is a preview of the record saved in the database:</p><div class="mediaobject"><img src="../images/00069.jpeg" alt="Creating a new record" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Working with the database">
<div class="book" title="Editing a record"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec85" class="calibre1"/>Editing a record</h2></div></div></div><p class="calibre7">To implement<a id="id621" class="calibre1"/> editing, we will use the <code class="email">PUT</code> method. We will also need to define a<a id="id622" class="calibre1"/> dynamic route. The following code creates the route and the proper handler:</p><div class="informalexample"><pre class="programlisting">router.put(/\/book\/(.+)?/, function(req, res, info) {
  var book = info.post;
  if(typeof book.name === 'undefined') {
    responder(res).code(400).json({error: 'Missing name.'});
  } else if(typeof book.author === 'undefined') {
    responder(res).code(400).json({error: 'Missing author.'});
  } else {
    var ID = info.match[1];
    collection.find({ID: ID}).toArray(function(err, records) {
      if(records &amp;&amp; records.length &gt; 0) {
        book.ID = ID;
        collection.update({ID: ID}, book, {}, function() {
          responder(res).code(200).json({message: 'Record updated successful.'});
          });
      } else {
        responder(res).code(400).json({error: 'Missing record.'});    
      }
    });
  }
});</pre></div><p class="calibre7">Along with the<a id="id623" class="calibre1"/> checks <a id="id624" class="calibre1"/>for missing <code class="email">name</code> and <code class="email">author</code>, we need to make sure that the ID that is used in the URL exists in our database. If not, a proper error message should be sent.</p></div></div>

<div class="book" title="Working with the database">
<div class="book" title="Deleting a record"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec86" class="calibre1"/>Deleting a record</h2></div></div></div><p class="calibre7">The deletion of<a id="id625" class="calibre1"/> records <a id="id626" class="calibre1"/>is really similar to the editing. We will again need a dynamic route. When we have the ID of the book, we can check if it really exists and if yes, simply remove it from the database. Checkout the following implementation that does the actions that we just described:</p><div class="informalexample"><pre class="programlisting">router.del(/\/book\/(.+)?/, function(req, res, info) {
  var ID = info.match[1];
  collection.find({ID: ID}).toArray(function(err, records) {
    if(records &amp;&amp; records.length &gt; 0) {
      collection.findAndModify({ID: ID}, [], {}, {remove: true}, function() {
        responder(res).code(200).json({message: 'Record removed successfully.'});
        });
    } else {
      responder(res).code(400).json({error: 'Missing record.'});    
    }
  });
});</pre></div></div></div>

<div class="book" title="Working with the database">
<div class="book" title="Displaying all the books"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec87" class="calibre1"/>Displaying all the books</h2></div></div></div><p class="calibre7">This is maybe the<a id="id627" class="calibre1"/> simplest API method, which we will have to implement. There is a query to the database and the result is directly passed to the responder. The following code defines a route books that fetches all the records from the database:</p><div class="informalexample"><pre class="programlisting">router.get(/\/books/, function(req, res, info) {
  collection.find({}).toArray(function(err, records) {
    if(!err) {
      responder(res).code(200).json(records);
    } else {
      responder(res).code(200).json([]);
    }  
  });
});</pre></div></div></div>

<div class="book" title="Working with the database">
<div class="book" title="Adding a default route"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch11lvl2sec88" class="calibre1"/>Adding a default route</h2></div></div></div><p class="calibre7">We should have a<a id="id628" class="calibre1"/> default route, that is, a page that will be sent if the user types in a wrong URL or just visits the root address of the API. In order to catch every type of request, we use the <code class="email">all</code> method of the router:</p><div class="informalexample"><pre class="programlisting">router.all('', function(req, res, info) {
  var html = '';
  html += 'Available methods:&lt;br /&gt;';
  html += '&lt;ul&gt;';
  html += '&lt;li&gt;GET /books&lt;/li&gt;';
  html += '&lt;li&gt;POST /book&lt;/li&gt;';
  html += '&lt;li&gt;PUT /book/[id]&lt;/li&gt;';
  html += '&lt;li&gt;DELETE /book/[id]&lt;/li&gt;';
  html += '&lt;/ul&gt;';
  responder(res).code(200).html(html);
});</pre></div><p class="calibre7">We constructed a simple HTML markup and sent it to the user. The route's regular expression is just an empty string, which matches everything. We are also using the <code class="email">.all</code> function, which handles any type of request. Notice that we need to add this route after all the others; otherwise, if it is at the start, all the requests will go there.</p></div></div>
<div class="book" title="Testing the API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec75" class="calibre1"/>Testing the API</h1></div></div></div><p class="calibre7">To make sure that <a id="id629" class="calibre1"/>everything works, we will write a few tests covering all the methods mentioned in the previous sections. In <a class="calibre1" title="Chapter 9. Automate Your Testing with Node.js" href="part0066_split_000.html#page">Chapter 9</a>, <span class="strong"><em class="calibre9">Automate Your Testing with Node.js</em></span>, we learned about Jasmine and Mocha test frameworks. The following test suite uses Jasmine. We will <a id="id630" class="calibre1"/>also need one additional module to make HTTP requests. The module is called <code class="email">request</code> and we can get it using <code class="email">npm install request</code> or by adding it to our <code class="email">package.json</code> file. The following are the steps along with the code to test the API:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's first test the creation of a new database record:<div class="informalexample"><pre class="programlisting">var request = require('request');
var endpoint = 'http://127.0.0.1:9000/';
var bookID = '';
describe("Testing API", function() {
  it("should create a new book record", function(done) {
    request.post({ 
      url: endpoint + '/book', 
      form: {
        name: 'Test Book',
        author: 'Test Author'
      }
    }, function (e, r, body) {
      expect(body).toBeDefined();
      expect(JSON.parse(body).message).toBeDefined();
      expect(JSON.parse(body).message).toBe('Record created successfully.');
      done();
    });
  });
});</pre></div><p class="calibre16">We are using the <code class="email">.post</code> method of the module. The needed data is attached to a <code class="email">form</code> property. Also, we expect to receive the JSON object containing a specific message.</p></li><li class="listitem" value="2">To get all the books in the database, we need to perform a request to <code class="email">http://127.0.0.1:9000/books</code>:<div class="informalexample"><pre class="programlisting">it("should get all the books", function(done) {
  request.get({ 
    url: endpoint + '/books'
  }, function (e, r, body) {
    var books = JSON.parse(body);
    expect(body).toBeDefined();
    expect(books.length &gt; 0).toBeDefined();
    bookID = books[0].ID;
    expect(bookID).toBeDefined();
    done();
  });
});</pre></div></li><li class="listitem" value="3">The editing and removing operations are similar to the <code class="email">POST</code> and <code class="email">GET</code> requests except for the fact that we are passing an ID. Also, we got it from the last test where we fetched all the records in the collection:<div class="informalexample"><pre class="programlisting">it("should edit", function(done) {
  request.put({ 
    url: endpoint + '/book/' + bookID, 
    form: {
      name: 'New name',
      author: 'New author'
    }
  }, function (e, r, body) {
    expect(body).toBeDefined();
    expect(JSON.parse(body).message).toBeDefined();
    expect(JSON.parse(body).message).toBe('Record updated successfully.');
    done();
  });
});
it("should delete a book", function(done) {
  request.del({ 
    url: endpoint + '/book/' + bookID
  }, function (e, r, body) {
    expect(body).toBeDefined();
    expect(JSON.parse(body).message).toBeDefined();
    expect(JSON.parse(body).message).toBe('Record removed successfully.');
    done();
  });
});</pre></div></li></ol><div class="calibre17"/></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec76" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we built a REST API to store information about books. Node.js handles such tasks well because it has easy-to-work native modules. We successfully covered the <code class="email">GET</code>, <code class="email">POST</code>, <code class="email">PUT</code>, and <code class="email">DELETE</code> requests that created an interface to manage a simple online library.</p><p class="calibre7">In the next and last chapter of this book, we will build a desktop application. We will learn how Node.js can be used not only for web projects, but for desktop programs too. By the end of the next chapter, we should have a working file browser written with Node.js.</p></div></body></html>