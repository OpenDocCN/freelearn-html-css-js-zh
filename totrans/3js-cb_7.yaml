- en: Chapter 7. Animation and Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations with Tween.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation using morph targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation with skeletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using morph animations created in Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using skeleton animations created in Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a simple collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a movie of an animation in Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging and dropping objects around a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a physics engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapters so far, we've mostly dealt with static scenes or scenes with
    limited animation. In this chapter, we show you a number of recipes that you can
    use to make your scenes more dynamic. We show you recipes that talk about how
    to add advanced animations, how to drag and drop objects around your scene, and
    even how to add physics to your scene, such as gravity and collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations with Tween.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, we've
    already showed you how to set up an animation loop, and in [Chapter 2](ch02.html
    "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*, we showed you how
    to create simple animations by changing properties of `THREE.Mesh`. When you have
    many or complex animations, the code can quickly become complex to maintain or
    understand. In this recipe, we'll show you how you can use an external JavaScript
    library that makes the creation of animations easier and more maintainable. We'll
    use the **Tween.js** library for this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we use a library from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/).
    As this is an external library, we first need to make sure it is included in our
    HTML page. For this, first add the following within the head element of your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this recipe, we''ll create a simple animation using this library. If you
    open the `07.01-animation-with-tweenjs.html` example in your browser, you can
    view the final result, which is similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you open this example in your browser, you'll see a small red cube that moves
    to a different position and rotates while it is moving. This animation is configured
    using the `Tween.js` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve added the required library to your HTML page, creating the animation
    only takes a couple of simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this library, we need to first create an instance of a `TWEEN.Tween`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a `TWEEN.Tween` instance. We can use this instance to move the
    provided properties from the start value (the value we added in this step) to
    an end value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to define the target values for the properties. We do this
    by using the `to` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this function, we tell the `tween` object that we want to slowly change
    the provided values in the constructor to these values. So, we change the `x`
    property from `0` to `5`. The second parameter, which is `5000`, defines how many
    milliseconds this change should take.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also choose how the value changes over time. You can for instance use
    a linear easing function, which changes the values at a constant rate, a quadratic
    one, which starts with small changes and quickly increases, or even use an easing
    function that bounces (overshoots) at the end. There are many more easing functions
    that are predefined in `TWEEN` (see the *There''s more…* section for more information).
    You do this by calling the easing function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, we have changed the values of these properties from one value to another,
    but we don''t really do anything when a value changes. In this recipe, we want
    to change the position and the rotation of the cube. You do this by calling the
    `onUpdate` function and passing in the function that should be called on each
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in this code snippet, we use the provided properties to set the
    rotation and position properties of cube.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a number of other settings you can use on the `tween` object to control
    how the animation behaves. For this recipe, we tell the `tween` object to repeat
    its animation indefinitely and use a yo-yo effect that reverses the animation
    each time it is repeated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can start the `tween` object by calling the start function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you won''t see anything happening. There is one last step you
    need to add to the `render` loop to inform the `tween` object how much time has
    passed so that it can calculate the correct values for the properties you provided
    in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will update all the `TWEEN.Tween` objects you've defined and call the `onUpdate`
    functions with the `updated` values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You define the start value, the end value, and how the start value should transition
    to the end value.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you call `TWEEN.update()`, the `TWEEN` library will determine how much
    time has passed from the previous call to `TWEEN.update` for each `TWEEN.Tween`
    object (or in the case of the first time, the time from calling `start()` on the
    `TWEEN.Tween` object). Based on this difference, the start time of `tween`, and
    the configured `easing` property, this library calculates new values for the passed-in
    properties. Finally, it will call the function passed into `onUpdate()` so that
    you can take action on the changed values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we didn't show all the configuration you can pass into the `TWEEN.Tween`
    object. For a complete overview of all the different easing options and other
    properties of the `TWEEN.Tween` object, refer to the GitHub project site at [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next recipe, there is one additional interesting aspect
    of the Tween.js library. In our recipe, we configured the `TWEEN.Tween` object
    step by step. You can also configure the object in one call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This works because Tween.js offers a fluent API. So for each function call,
    this library returns the original `TWEEN.Tween` object. This means that you can
    easily chain calls together like we did in the previous code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the Tween.js library in pretty much every case where we used an
    animation in this book. For instance, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*, we showed you the Rotating an object around
    its own axis recipe. The rotation could be easily managed using a `TWEEN.Tween`
    object. In [Chapter 3](ch03.html "Chapter 3. Working with the Camera"), *Working
    with the Camera*, we showed you how to zoom in on an object in the *Zooming the
    camera to an object* recipe. With the Tween.js library, we can easily animate
    this zoom functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating using morph targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When modeling 3D objects and characters, there are generally two different ways
    of creating animations. You can animate using morph targets, or you can use skeleton-and-bones-based
    animations. Three.js facilitates both of these approaches. In this recipe, we'll
    look at the morph-based animation. With morph-based animations, like the name
    implies, you morph one geometry shape into another. This works great for facial
    expressions and other very detailed animations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we don''t require any additional libraries as morph-based
    animations are supported by the standard Three.js distribution. To make this recipe
    more understandable, we use an existing 3D model to demonstrate how morphing works.
    You can see the model and the available morphs when you open the `07.02-animation-with-morphing.html`
    example in your browser. You will see something similar to what is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can see a simple model of a car. Using the sliders in
    the top-right section, you can slowly morph this car into a different model, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you check the **animate** box, an animation that automatically morphs this
    car will start.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use morphing animations, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is load the model that contains morph targets.
    For this recipe, we''ve got a `JSON`-based model, which we load like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use `THREE.JSONLoader` to load a model, and once it is loaded, we call
    the provided function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we create `THREE.Mesh`, there is one additional step we need to take.
    We need to set the `morphTargets` property on the materials that are set to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create `THREE.Mesh` and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we follow the standard way of creating `THREE.Mesh` and add
    it to the scene just like any other object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got an object in the scene that can be morphed, we can use
    the `morphTargetInfluences` property to set how much the object is morphed into
    a specific direction. In the example for this recipe, we used the UI to control
    this setting as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model we used in this recipe has four morph targets (with names `mt_0`,
    `mt_1`, `mt_2`, and `mt_3`), its base state and three other car models. By increasing
    the `morphTargetInfluence` object of one of those other models, we can morph the
    model into that direction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in this recipe, by simply changing the value of a specific `morphTargetInfluences`
    value, you can change the way your model looks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In models that support multiple morph targets, an additional set of vertices
    is stored to represent that position for each of the targets. So, if you've got
    a face model that has a morph target for a smile, one for a frown, and one for
    a smirk, you effectively store four times as many vertex positions. With the `morphTargetInfluences`
    property, you can tell Three.js how far the base state (the `geometry.vertices`
    property) should be morphed toward that specific morph target. Three.js will then
    calculate the average position of each individual vertex and render the updated
    model. A very interesting thing is that you can combine morph targets. So if you've
    got separate morph targets for eye movement and mouth movement, you can easily
    create very animated and lifelike animations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we loaded an external model that contained the morph targets.
    If you''ve already got a simple geometry that you want to use for morph-based
    animations, you can also easily do that. For instance, if you''ve got a geometry,
    you can add `morphTargets` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The important aspect here is to make sure you provide the same amount of vertices
    to the `vertices` property as there are in the `initial` geometry. You can now
    control the morph between the various targets using the `morphTargetInfluences`
    properties on `THREE.Mesh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative way to animate models can be done using skeleton and bones. We
    explain how to do this in the *Animation with skeletons* recipe. We also provide
    two recipes in this chapter where we define morph-and-skeleton-based animations
    in an external tool (Blender, in our case) and play the animation in Three.js.
    See the *Using morph animations created in Blender* and *Using skeleton animations
    created in Blender* recipes for more information about these approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating with skeletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common way to animate complex models is using bones and skinning. In this
    approach, we define a geometry, add a skeleton, and tie the geometry to that skeleton.
    Whenever we move or rotate one of the bones of the skeleton, the geometry is deformed
    accordingly. In this recipe, we will show you how you can use the Three.js functionality
    to move and rotate bones directly from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we use an external model that already contains a skeleton
    we can move around. To load this model, we use `THREE.JSONLoader`, which is available
    in the standard distribution of Three.js. So, we don''t need to import any additional
    JavaScript files to get this recipe to work. Of course, we''ve provided an example
    of this recipe in action, which you can view by opening the `07.03-animation-with-skeleton.html`
    example in your browser. You will see something similar to what is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example shows you a model of a giraffe and provides an interface that you
    can use to move the neck bone. You can change the rotation of the neck bone and
    even its position. When you do this, you'll see that part of the mesh responds
    to the movement of this bone. In this recipe, we'll show you how to accomplish
    this for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working directly with bones isn''t that difficult and only takes a couple of
    small steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is load a model that contains bones. For this
    recipe, we once again use `THREE.JSONLoader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the model from step 1 has been loaded, we can set up the materials and
    create the mesh. Let''s first look at the materials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we set the `skinning` property of the material to `true`. This tells Three.js
    that this object contains bones and the geometry should deform when the bones
    move.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we create the mesh and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we've used a different kind of mesh for this object. Instead
    of the `THREE.Mesh` object, we've used a `THREE.SkinnedMesh` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the bones, we access the children elements of `THREE.SkinnedMesh`.
    Getting the correct bone to animate might take some experimenting if the bones
    aren't clearly named. The easiest way to determine which bone to use is to look
    through the output of the JavaScript console and browse the children of the mesh.![How
    to do it…](img/1182OS_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we want to rotate the tail bone and rotate and position the neck.
    For this, we add the following to the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Whenever we now change the position of the rotation of the bones
    we used in the previous code snippet, the geometry will deform accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with bones isn't that difficult, but selecting the correct bone to change
    and move around can take some experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you enable the `skinning` property on the material, Three.js passes all
    the information about the relevant bones and positions into its vertex shader.
    The vertex shader will use this information to position the vertices to their
    new position based on the position and rotation of the relevant bones. More information
    and a good introduction on how to execute skeletal animations from a vertex shader
    can be found on the OpenGL website at [https://www.opengl.org/wiki/Skeletal_Animation](https://www.opengl.org/wiki/Skeletal_Animation).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to get a quick overview of how the bones are organized in a model,
    you can use a specific helper class that is provided by Three.js. The following
    code snippet shows you how to create `THREE.SkeletonHelper` for the model we used
    in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will visualize the bones of a model, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you move bones around, which we do in our recipe, you also need to add the
    following line to your `render` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, `THREE.SkeletonHelper` will always reflect the latest state of the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simpler way to animate models is using morph targets. We explain how to do
    this in the *Animation using morph targets* recipe. We also provide two recipes
    in this chapter where we define morph-and-skeleton-based animations in an external
    tool (Blender, in our case) and play the animation in Three.js. Refer to the *Using
    morph animations created in Blender* and *Using skeleton animations created in
    Blender* recipes for more information on these approaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using morph animations created in Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating morph animations by hand is difficult to do in Three.js. Simple transformations
    can probably be handled, but creating advanced animations programmatically is
    very difficult. Luckily, there are a large number of external 3D programs that
    you can use to create the models and animations. In this recipe, we'll use Blender,
    which we already used in [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"),
    *Geometries and Meshes*, to create a morph-based animation and play it back using
    Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use this recipe, you have to have Blender installed and enable the Three.js
    exporter plugin. We've already explained how to do this in the *Creating and exporting
    a model from Blender* recipe, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. So if you haven't already done so, you
    should first install Blender and then the Three.js export plugin. Once you've
    installed Blender, you should create an animation that uses shape keys to define
    various formats. Doing this is out of the scope of this book, but to make sure,
    you can test the steps explained in this recipe—we've included a Blender file,
    which has a minimal shape-keys-based animation. So before we get started with
    the recipe, we'll load the example Blender model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Blender** and navigate to **File** | **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, navigate to the sources provided with the book and
    open the `simplemorph.blend` file, which can be found in the `assets/models/blender`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this file is opened, you'll see a cube in the center of an empty scene
    like this:![Getting ready](img/1182OS_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the starting point from where we start the recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to preview the (very simple) animation we've created here, just
    click on the **play** button or use the *Alt* + *A* key combination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will load this file in Three.js and play the animation we created in Blender.
    To see the final result, open the `07.04-create-morph-in-blender.html` example
    in your browser. You will see something similar to what is shown in the following
    screenshot:![Getting ready](img/1182OS_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see an animating cube that uses morph targets (defined as shape keys
    in Blender) to morph a cube into different shapes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve followed the steps explained in the *Getting ready* section of this
    recipe, you''ll be looking at a simple Blender workspace with a single cube and
    an animation that slowly morphs the cube using a set of shape keys. To export
    this animation from Blender and use it in Three.js, we need to take a couple of
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is export the model and the animation to which
    we can load it in Three.js. To do this, navigate to **File** | **Export** | **Three.js**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, we can select a destination and a filename. For this
    recipe, name the file `simplemorph.js` and set the destination to the `assets/models/morph`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we hit the **Export** button, we need to configure some Three.js-specific
    properties. You can do this in the panel on the left-hand side in the **Export
    Three.js** section. In that section, make sure that the **Morph animation** checkbox
    is selected. Once you've checked the box, click on the **Export** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we''re done with our work in Blender and can load the exported model in
    Three.js. For this, we use `THREE.JSONLoader` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we load the model using `THREE.JSONLoader`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the model is loaded, we need to create a material where we need to set
    the `morphTargets` property to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this material, we can create the mesh to be added to the scene. This time,
    as we want to use the animation provided from Blender, we create `THREE.MorphAnimMesh`,
    which we add to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to take a final step before we can play the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `parseAnimation()` function, Three.js will parse the names of the provided
    morph target elements from the model and use it to create an animation. When you
    export using the Three.js plugin from Blender, the name of the animation is `animation`.
    To play the animation, we call `playAnimation` with the name of the animation
    and the frame rate, and finally, we set the duration (in seconds) of the animation.
    Note that you don't always have to set the duration of an animation. In some cases,
    the model itself provides the duration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final change we need to make is in the `render` function itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a global `THREE.Clock()` instance, which we use to determine
    how much time is passed between sequential calls to the `render` function. This
    is passed into the `updateAnimation` function of `THREE.MorphAnimMesh` so that
    it can calculate which frame to show.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you've seen from the recipe, getting an animation to play in Three.js from
    Blender isn't that difficult. One thing to take into account here, though, is
    that this can result in huge files when you've got models with a high vertex count.
    This happens because the Blender export plugin creates a new morph target for
    each frame of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we've used the Three.js export function of Blender to save the
    model in a format `THREE.JSONLoader` can load. There are a large number of other
    3D formats available, which can be used to store 3D scenes and animations that
    are supported by Three.js. An overview of the file formats that are available
    in Three.js can be found on the Three.js GitHub site at [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve got some other recipes that deal with animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Animation using morph targets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Animation with skeletons*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using skeleton animations created in Blender*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using skeleton animations created in Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Animation with skeletons* recipe, we animated a model by directly changing
    the position and rotation of its bones. This works great in an interactive scenery
    but isn't a practical way to create animations. With Blender and other 3D tools,
    you've got a large set of tools to create animations based on a specific skeleton
    and a set of bones. In this recipe, we'll show you how you can play back a skeleton-based
    animation that was created in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this recipe, you need to have Blender installed and enable the Three.js
    exporter plugin. If you haven''t done so, follow the steps from the *Creating
    and exporting a model from Blender* recipe, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. Once Blender and the Three.js export plugin
    have been installed, we need to create a skeleton-based animation. Creating this
    in Blender is out of the scope of this book, so we''ve provided an existing model
    to demonstrate this recipe. To get started, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Blender** and navigate to **File** | **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, navigate to the sources provided with the book and
    open the `crow-skeleton.blend` file, which can be found in the `assets/models/blender`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this file is open, you'll see a crow in the center of an empty scene like
    this:![Getting ready](img/1182OS_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the starting point of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to preview the crow animation, click on the **play** button or use
    the *Alt* + *A* key combination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have also provided an example that you can open in your browser to see the
    same animation in a Three.js scene. When you open the `07.05-create-skeleton-animation-in-blender.html`
    example in your browser, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use the model in Three.js, we first have to export it from Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: To start the export, first navigate to **File** | **Export** | **Three.js**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that opens, we can select a destination and a filename. For this
    recipe, name the file `crow.js` and set the destination to the `assets/models/bones`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we hit the **Export** button, we need to configure some Three.js-specific
    properties. You can do this in the panel on the left-hand side in the **Export
    Three.js** section. In that section, make sure that the **Bones**, **Skinning**,
    and **Skeletal** animation checkboxes are selected. If the **Morph Animation**
    checkbox is selected, disable it. Once you've checked the box, click on the **Export**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve exported the model, the first thing we need to do in Three.js
    is load the model using `THREE.JSONLoader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the model is loaded in Three.js. we can process it. The first thing we
    do in the callback from the `loader.load` function is to set up the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is just a standard `THREE.MeshLambertMaterial` object. The only thing you
    need to make sure is to set the `skinning` property of the material to `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got the model and the material, we can create a mesh. As we''re
    working with skeletons, we need to create `THREE.SkinnedMesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to select the animation we want to play. For this, you use the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to make sure the `animation` property contains the name of an animation
    from the `model.animations` array. In this case, we've only got one animation
    with the `Crow.ArmatureAction` name. Skeleton-based animations are handled using
    `THREE.AnimationHandler`. So, we add the animation from our model to the handler.
    Next, we need to create a `THREE.Animation` instance. This object combines our
    model with the animation we want to play. When we have this object we can call
    the `play()` function to tell Three.js to play the animation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step we need to take before the animation will play is to update
    the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use `THREE.Clock()` to determine how much time has passed (`t.getDelta()`)
    between this frame and the previous one. This is passed into `THREE.AnimationHandler`
    to update all the registered animations and move the mesh in the correct position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When exporting the animation, the Three.js exporter will write out the position
    and rotation of the bones at the times we specified in Blender. This information
    can then be used directly in Three.js to determine the position and rotation of
    the bones when we're playing back the animation. This way, we can create fairly
    complex animations without having to create huge model files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with skeletons in Blender and creating animations from them is a subject
    on which much is written. If you''re interested in learning more about rigging
    models and creating skeleton-based animations, a couple of good resources to start
    with are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender Tutorial: Basics of Character Rigging at [http://www.youtube.com/watch?v=cGvalWG8HBU](http://www.youtube.com/watch?v=cGvalWG8HBU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender manual: rigging at [http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging](http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender Guru: introduction to rigging at [http://www.blenderguru.com/tutorials/introduction-to-rigging](http://www.blenderguru.com/tutorials/introduction-to-rigging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building A Basic Low Poly Character Rig In Blender at [http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955](http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we have some other recipes that deal with animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Animation using morph targets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Animation with skeletons*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using morph animations created in Blender*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a simple collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're creating games or interactive environments, a common requirement
    is the option to detect collisions between objects. In the *Adding a physics engine*
    recipe, we use an external library to handle collisions (and other physics). This,
    however, is a rather heavy solution if all you require is the option to detect
    collisions. In this recipe, we provide a simple approach that you can use if you
    want to detect collisions without having to use an external library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we use `THREE.Raycaster` to check for collisions. This object
    is provided by the standard Three.js distribution, so you don''t need any additional
    libraries. We''ve provided a simple example that shows you how this recipe can
    be applied. For this, open the `07.06-add-simple-detection-collision.html` example
    in your browser, and you will see something similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can move the central cube around using the arrow keys and
    rotate it around the *y* axis with the *a* and *b* keys. Whenever a collision
    occurs with one of the other cubes, we change the opacity to indicate a collision.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish collision detection, we need to take a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start simple and create the cube that we''ll move around. We will detect
    collisions between this cube and the cubes we define in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create an array that will hold all the objects that we can collide
    with and add some cubes to that array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve got the object to move around and the objects to detect the
    collisions with, we can add the code to detect collisions. In the `render` loop,
    we need to add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this piece of code, we simply check whether one of the vertices of our moving
    cube intersects with any of the cubes in the `cubes` array. If we detect a collision,
    we change the opacity of the cube we collided with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these steps, we have a rudimentary solution to detect collisions. This
    approach works great to detect collisions between flat objects but might miss
    detection with small spike-like objects. You can enhance this solution by checking
    collisions against more vertices. You can, for instance, add more vertices by
    increasing the `widthSegments`, `heightSegments`, and `depthSegments` objects
    of the cube, or you can calculate intermediate vertices yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect collisions in this approach, we shoot a ray using `THREE.RayCaster`
    from the center of the cube that is moving to each of its vertices. If this ray
    intersects with one of the other cubes from the `cubes` array in its path from
    the center to a vertex, it means that one of the vertices is inside one of the
    other cubes. We interpret this as a collision and can take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the great work done by Lee Stemkoski, who provided an
    initial implementation of this approach at [http://stemkoski.github.io/Three.js/Collision-Detection.html](http://stemkoski.github.io/Three.js/Collision-Detection.html).
    Besides a ray-based approach to collision detection, there are, of course, alternative
    approaches. A very common approach is to use the bounding boxes of a mesh to detect
    whether two meshes touch. Three.js even provides a function for this in the `THREE.Box3`
    object called `isIntersectionBox`. As using a ray casting approach is a rather
    computationally expensive way to detect collisions, often a bounding box approach
    is used first, followed by the more accurate ray casting method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of good resources on such an approach can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3D Theory - Collision Detection* at [http://www.euclideanspace.com/threed/animation/collisiondetect/](http://www.euclideanspace.com/threed/animation/collisiondetect/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AABB to AABB detection in C++* at [http://www.miguelcasillas.com/?p=30](http://www.miguelcasillas.com/?p=30)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*3D Collision detection and resolution using sweeping AABB bounding boxes*
    at [http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping](http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physics engine we will use in the *Adding a physics engine* recipe also
    uses a shapes-based approach to collision detection. Besides just a bounding box,
    it provides a number of different shapes to detect collisions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Adding a physics engine* recipe, we detect collisions using the physics
    engine. For another recipe that uses `THREE.RayCaster`, you can also look at the
    *Dragging and dropping objects around a scene* recipe, which can also be found
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a movie of an animation in Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've showed you various ways to create animations. Sometimes,
    however, people don't have a WebGL-enabled browser, or you want to just share
    the resulting animation and not the WebGL website. In these cases, it would be
    very helpful to be able to just save the animation to your local filesystem and
    share it. In this recipe, we show you one approach you can use for this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with this recipe, you need to make sure that you use Google Chrome.
    We use an internal functionality to save the animation as a WebM file, which unfortunately,
    still only works on Google Chrome. We don''t have to create the complete functionality
    for this recipe from scratch, as there is a library available that handles the
    low-level technical stuff for us: CCapture ([https://github.com/spite/ccapture.js/](https://github.com/spite/ccapture.js/)).
    To work with this library, we need to load the following two JavaScript files
    at the top of our HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve provided a very simple example that shows you this recipe in action.
    If you open up `07.07-save-a-movie-of-an-animation.html` in your browser, you''ll
    see a slowly moving cube in your browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason this cube moves so slowly is that in the background, a movie is being
    saved. The libraries used slow down the animation to make sure no frames are skipped.
    To save the movie, click on the **saveMovie** menu button at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting movie can now be played in the movie player of your choice, which
    supports WebM (for instance, VLC or mPlayer) as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve included the appropriate libraries in your HTML page, using this
    library is actually very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a `capture` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a capturer that captures 20 frames per second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step before we start rendering the scene is to start `capturer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to tell `capturer` what to capture in the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these steps, the `capturer` object will start capturing the output of our
    WebGL canvas 20 times per second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last step, we need to add a functionality to save the movie (in our example,
    this is triggered by clicking on the **saveMovie** button):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will download the movie as `video.webm` and save it to your local disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you run this, you will notice that the frame rate in your browser drops
    significantly. The reason is that the CCapture library changes the behavior of
    the `requestAnimationFrame` function to make sure it has enough time to capture
    the screen and add it as a frame to the movie. The movie file that is created
    will look like you expected and have the number of frames per second, as specified
    in step 1 of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach that we showed you in the recipe works great for most types of
    animations. However, when you want to record a user interacting with your scene,
    you can't use this library as it slows down the rendering of your scene, which
    makes interacting with the scene difficult. An alternative way to record the scene
    is using a backend service that collects screenshots and creates a movie server
    side. An example of such a setup can be found at [http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you just want to save a screenshot instead of a complete movie, you can use
    the *Saving WebGL output to disk* recipe, which we explained in [Chapter 6](ch06.html
    "Chapter 6. Point Clouds and Postprocessing"), *Point Clouds and Postprocessing*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging and dropping objects around a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create an interactive environment, a common requirement is the option
    to use your mouse to drag objects around. This functionality isn't something that
    is supported out of the box by Three.js. In this recipe, we'll show you the steps
    that are needed to implement this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we only use the functionality that is available in the standard
    Three.js library. We''ll use the `THREE.Raycaster` object together with `THREE.Projector`
    to implement the drag and drop functionality. To see the drag and drop functionality
    in action, you can open the `07.08-drag-n-drop-object-around-scene.html` example
    in your browser, and you will see something similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see a large number of cubes, which you can move individually.
    Just click on one with the mouse and drag it to a new position. This scene also
    uses `THREE.OrbitControls`, so when you click on the white background, you can
    use your mouse to rotate the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we need to take a fair amount of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is create a number of global variables, which we''ll
    access in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll explain how these objects are used in the upcoming steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we want to move an object around, we need to determine on what plane (around
    which axis) we''re going to move the selected cube. A mouse moves in two dimensions,
    while our scene moves in three. For this, we''ll use a invisible helper plane,
    which we define like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This plane is assigned to the global plane variable we saw in step 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to create all the cubes. For an easy understanding of this
    recipe, we list the code about how cubes are created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The most interesting line is the highlighted one, where we add the created cube
    to the global array with the name objects. Only cubes from this array can be moved
    around.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got the basics out of the way, we need to tell Three.js what
    to do when the mouse moves, when a mouse button is clicked on, and when a mouse
    button is released. Let''s first look at the `onmousemove` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can access the information from the mouse movement, we need to register
    a listener. We do this, as you can see in the code snippet, by assigning a function
    to the `document.onmousemove` property. In the following steps, we'll look at
    the contents of this `onmousemove` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `onmousemove` function, we do a couple of different things. The first
    thing we always need to do is convert the mouse position to a position in 3D space
    and create `THREE.Raycaster` for that position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we can use `THREE.Raycaster` to select objects that are the position
    of our mouse.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to either drag an object around if we''ve already clicked
    on one (see steps 7, 8, and 9 for more details on this), or reposition the plane
    we created in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we've selected an object and are dragging it around, we set the position
    of that object based on the position where the ray cast from our mouse intersects
    the invisible helper plane using the offset that we calculate in step 9\. If we
    aren't dragging an object around, and using our ray we determine that we intersect
    one of the cubes, we move our helper `plane` object to the position of that object
    and make sure the plane faces the camera (`plane.lookAt(camera.position)`). The
    object, if we select it, will move alongside this helper `plane` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to define a function to handle the `onmousedown` events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s look at what to fill in for the `onmousedown` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We once again use `THREE.Raycaster` to determine whether an object intersects
    with a ray cast from the position of our mouse.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know the intersects, we can use them to select the object we''re
    interested in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in this snippet, we first disable the `orbit` controller (as
    we want to drag the object around and not rotate the scene). Next, we assign the
    first intersected object to the `selectedObject` variable, which we used in step
    6 to move the selected cube around. Finally, we need to determine the offset between
    the point where we clicked and the center of the plane. We need this to correctly
    position the cube in step 6.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step we need to take is to enable the orbit controller when we release
    the mouse button and set the `selectedObject` property back to null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there are plenty of steps you need to take to implement this
    recipe. You can also look at the sources from `07.08-drag-n-drop-object-around-scene.html`,
    which also contain inline documentation about why certain steps are needed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe was based on the example from the Three.js website, which you can
    find at [http://threejs.org/examples/#webgl_interactive_draggablecubes](http://threejs.org/examples/#webgl_interactive_draggablecubes).
    So, for another example to play around with, you can look at that implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we showed you how you can move the complete mesh around. You
    can also use this same approach to move individual vertices, faces, or lines around.
    So, with a little bit of effort, you can use this approach to create a kind of
    sculpting tool with which you could directly modify a geometry from your browser.
    For instance, you could create something like this [http://stephaneginier.com/sculptgl/](http://stephaneginier.com/sculptgl/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we also use `THREE.Raycaster` for the *Adding simple collision
    detection* recipe. If you want to drag and drop external files onto your Three.js
    scene, you can refer to the *Dragging a file from the desktop to the scene* recipe
    in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a physics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipes so far, we've added animations and detection collisions to the
    scene manually. In this recipe, we'll show you how to use an external physics
    engine to add gravity, collision detection, and other physics effects to your
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we need to use a couple of external libraries. At the top
    of your HTML page, you have to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This library contains the main implementation of the physics engine. This library
    in itself uses two additional libraries that need to be provided. You first need
    to make sure the `ammo.js` library is stored in the same location as the `physi.js`
    library, and at the beginning of your JavaScript code, you should add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This points to a web worker ([http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/))
    that handles the physics calculations in a separate thread. There is, of course,
    a ready-to-use example of this recipe that you can use as a reference or to experiment
    with. The example for this recipe is called `07.09-add-a-physics-engine.html`,
    and when this is opened in the browser you will see something similar to what
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can use the **addCube** button to add cubes to the scene.
    This cube will be added high above the ground plane and will drop down. The physics
    engine will determine how the falling cube interacts with its environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we only set up a basic physics-enabled scene. Refer to the
    *There''s more…* section of this recipe for additional functionality provided
    by the `Physijs` library. To create a basic scene, you need to take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is that instead of creating `THREE.Scene`, we''ll create
    `Physics.Scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On this newly created scene, we also need to set the `gravity` property. In
    this case, we set a gravity of `-30` on the *y* axis, which means a scene where
    objects fall down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s create `THREE.Geometry` and `THREE.MeshLambertMaterial`, which
    we''ll use for the cubes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is nothing special to do in this step for `Physijs`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to create a mesh object. For objects to work with `Physijs`,
    we need to create a `Physijs` library specific mesh and a `Physijs` library specific
    material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the material, we use the `Physijs.createMaterial` function. This wraps our
    material created in step 2 and allows us to define the friction and restitution
    properties. The friction defines the roughness of the object and affects how far
    it can slide over another object. The `restitution` object is used for the bounciness
    of an object. To create a mesh, we use the `Physijs.BoxMesh` object, provide the
    geometry and the material we just created, and also add the weight of the object.
    `Physijs` provides differently shaped meshes; for more information on them, refer
    to the *There's more…* section of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step we need to take is to update the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we add the `scene.simulate` function. This is used to calculate the new
    positions of all the objects that have been wrapped in a `Physijs` library specific
    mesh.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these basic steps, you've got a fully working physics-enabled Three.js
    scene. An important aspect to take into account when using this engine is that
    there is a hit on performance. For each object of the scene, `Physijs` will need
    to calculate its next position and rotation. This works great for tens of objects,
    but you'll see a severe hit when working with hundreds of Physijs-managed objects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We call `scene.simulate()`, which we added to the `render` loop in step 4, for
    each frame that is rendered. When this function is called, `Physijs` will look
    at all the objects it knows about, and it also looks at the gravity configured
    on the scene and will use that information to calculate new positions and rotations
    for each object if collisions between objects occur. it will use the `friction`
    and `restitution` properties of the `Physijs` material and the weight function
    of an object to determine how that object and the one it collides with should
    react. This is repeated in each `render` loop and gives the simulation of real
    physics in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we''ve done in this recipe is only a very small part of what is possible
    with this physics engine. You can find more information on the Physijs website
    at [http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/).
    Interesting subjects from that site are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for different object shapes: [https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes](https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add constraints to your object. This makes it possible to constrain the
    movement of an object around an axis (like a slider), a joint, or even another
    object. More information on this feature can be found at [https://github.com/chandlerprall/Physijs/wiki/Constraints](https://github.com/chandlerprall/Physijs/wiki/Constraints).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physijs uses an external physics library for all the calculations. For more
    information on that engine, look at the ammo.js website ([https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/)).
    Note that ammo.js itself is a JavaScript port of the Bullet physics engine. So,
    if you really want to dive into the details, you should look at the Bullet documentation
    that can be found at [http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't want to include a complete physics engine inside your project,
    you can also simulate parts of a physics engine yourself. How to add basic collision
    detection to your scene is explained in the *Adding a simple collision detection*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
