- en: Chapter 7. Animation and Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 动画与物理
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍以下配方：
- en: Creating animations with Tween.js
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tween.js创建动画
- en: Animation using morph targets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形变目标进行动画
- en: Animation with skeletons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用骨骼进行动画
- en: Using morph animations created in Blender
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blender创建的形变动画
- en: Using skeleton animations created in Blender
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blender创建的骨骼动画
- en: Adding a simple collision detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加简单的碰撞检测
- en: Saving a movie of an animation in Chrome
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Chrome中保存动画电影
- en: Dragging and dropping objects around a scene
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景周围拖放对象
- en: Adding a physics engine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加物理引擎
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the chapters so far, we've mostly dealt with static scenes or scenes with
    limited animation. In this chapter, we show you a number of recipes that you can
    use to make your scenes more dynamic. We show you recipes that talk about how
    to add advanced animations, how to drag and drop objects around your scene, and
    even how to add physics to your scene, such as gravity and collision detection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的章节中，我们主要处理静态场景或有限动画的场景。在本章中，我们将向您展示一系列您可以用来使场景更加动态的配方。我们展示了关于如何添加高级动画、如何在场景周围拖放对象以及如何向场景添加物理效果（如重力碰撞检测）的配方。
- en: Creating animations with Tween.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tween.js创建动画
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, we've
    already showed you how to set up an animation loop, and in [Chapter 2](ch02.html
    "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*, we showed you how
    to create simple animations by changing properties of `THREE.Mesh`. When you have
    many or complex animations, the code can quickly become complex to maintain or
    understand. In this recipe, we'll show you how you can use an external JavaScript
    library that makes the creation of animations easier and more maintainable. We'll
    use the **Tween.js** library for this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章. 入门")，*入门*中，我们已经向你展示了如何设置动画循环，在[第二章](ch02.html "第二章. 几何体和网格")，*几何体和网格*中，我们展示了如何通过改变`THREE.Mesh`的属性来创建简单的动画。当你有很多或复杂的动画时，代码会迅速变得复杂，难以维护或理解。在这个配方中，我们将向你展示如何使用一个外部JavaScript库，它可以使动画的创建更容易、更易于维护。我们将使用**Tween.js**库来完成这个任务。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we use a library from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/).
    As this is an external library, we first need to make sure it is included in our
    HTML page. For this, first add the following within the head element of your page:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用来自[https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)的库。由于这是一个外部库，我们首先需要确保它包含在我们的HTML页面中。为此，首先在页面头部元素中添加以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this recipe, we''ll create a simple animation using this library. If you
    open the `07.01-animation-with-tweenjs.html` example in your browser, you can
    view the final result, which is similar to what is shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用这个库创建一个简单的动画。如果你在浏览器中打开`07.01-animation-with-tweenjs.html`示例，你可以查看最终结果，它类似于以下截图所示：
- en: '![Getting ready](img/1182OS_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_07_01.jpg)'
- en: If you open this example in your browser, you'll see a small red cube that moves
    to a different position and rotates while it is moving. This animation is configured
    using the `Tween.js` library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中打开这个示例，你会看到一个红色的立方体移动到不同的位置，并在移动过程中旋转。这个动画是通过`Tween.js`库配置的。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Once you''ve added the required library to your HTML page, creating the animation
    only takes a couple of simple steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将所需的库添加到你的HTML页面中，创建动画只需要几个简单的步骤：
- en: 'To use this library, we need to first create an instance of a `TWEEN.Tween`
    object:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用这个库，我们首先需要创建一个`TWEEN.Tween`对象的实例：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates a `TWEEN.Tween` instance. We can use this instance to move the
    provided properties from the start value (the value we added in this step) to
    an end value.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个`TWEEN.Tween`实例。我们可以使用这个实例将提供的属性从起始值（我们在这一步添加的值）移动到结束值。
- en: 'The next step is to define the target values for the properties. We do this
    by using the `to` function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义属性的靶值。我们通过使用`to`函数来完成：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this function, we tell the `tween` object that we want to slowly change
    the provided values in the constructor to these values. So, we change the `x`
    property from `0` to `5`. The second parameter, which is `5000`, defines how many
    milliseconds this change should take.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此功能，我们告诉`tween`对象，我们希望将构造函数中提供的值缓慢地改变到这些值。因此，我们将`x`属性从`0`改为`5`。第二个参数，即`5000`，定义了这种变化需要多少毫秒。
- en: 'We can also choose how the value changes over time. You can for instance use
    a linear easing function, which changes the values at a constant rate, a quadratic
    one, which starts with small changes and quickly increases, or even use an easing
    function that bounces (overshoots) at the end. There are many more easing functions
    that are predefined in `TWEEN` (see the *There''s more…* section for more information).
    You do this by calling the easing function:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以选择值随时间如何变化。例如，您可以使用线性缓动函数，它以恒定速率改变值，一个二次函数，它以小的变化开始并迅速增加，或者甚至使用一个在结束时弹跳（超过）的缓动函数。`TWEEN`
    中预定义了更多缓动函数（有关更多信息，请参阅 *还有更多…* 部分）。您通过调用缓动函数来实现这一点：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, we have changed the values of these properties from one value to another,
    but we don''t really do anything when a value changes. In this recipe, we want
    to change the position and the rotation of the cube. You do this by calling the
    `onUpdate` function and passing in the function that should be called on each
    change:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将这些属性的值从一值更改为另一值，但当一个值改变时，我们并没有真正做任何事情。在这个菜谱中，我们想要改变立方体的位置和旋转。您可以通过调用
    `onUpdate` 函数并传入应在每次更改时调用的函数来实现这一点：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in this code snippet, we use the provided properties to set the
    rotation and position properties of cube.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您在这段代码片段中所见，我们使用提供的属性来设置立方体的旋转和位置属性。
- en: 'There are a number of other settings you can use on the `tween` object to control
    how the animation behaves. For this recipe, we tell the `tween` object to repeat
    its animation indefinitely and use a yo-yo effect that reverses the animation
    each time it is repeated:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在 `tween` 对象上使用许多其他设置来控制动画的行为。对于这个菜谱，我们告诉 `tween` 对象无限期地重复其动画，并使用一个每次重复时都会反转动画的悠悠球效果：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can start the `tween` object by calling the start function:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用起始函数来开始 `tween` 对象：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, you won''t see anything happening. There is one last step you
    need to add to the `render` loop to inform the `tween` object how much time has
    passed so that it can calculate the correct values for the properties you provided
    in step 1:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，您不会看到任何发生。您需要添加到 `render` 循环中的最后一个步骤是通知 `tween` 对象已经过去的时间，以便它可以计算您在步骤
    1 中提供的属性的正确值：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will update all the `TWEEN.Tween` objects you've defined and call the `onUpdate`
    functions with the `updated` values.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将更新您定义的所有 `TWEEN.Tween` 对象，并使用 `updated` 值调用 `onUpdate` 函数。
- en: You define the start value, the end value, and how the start value should transition
    to the end value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义起始值、结束值以及起始值应该如何过渡到结束值。
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Whenever you call `TWEEN.update()`, the `TWEEN` library will determine how much
    time has passed from the previous call to `TWEEN.update` for each `TWEEN.Tween`
    object (or in the case of the first time, the time from calling `start()` on the
    `TWEEN.Tween` object). Based on this difference, the start time of `tween`, and
    the configured `easing` property, this library calculates new values for the passed-in
    properties. Finally, it will call the function passed into `onUpdate()` so that
    you can take action on the changed values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `TWEEN.update()` 时，`TWEEN` 库将确定从上一次调用 `TWEEN.update` 以来每个 `TWEEN.Tween`
    对象（或对于第一次调用，从在 `TWEEN.Tween` 对象上调用 `start()` 以来）经过的时间。基于这个差异，`tween` 的起始时间和配置的
    `easing` 属性，这个库会为传入的属性计算新的值。最后，它将调用传递给 `onUpdate()` 的函数，以便您可以对更改的值采取行动。
- en: There's more…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, we didn't show all the configuration you can pass into the `TWEEN.Tween`
    object. For a complete overview of all the different easing options and other
    properties of the `TWEEN.Tween` object, refer to the GitHub project site at [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们没有展示您可以传递给 `TWEEN.Tween` 对象的所有配置。有关所有不同的缓动选项和 `TWEEN.Tween` 对象的其他属性的完整概述，请参阅
    GitHub 项目网站 [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)。
- en: 'Before we move on to the next recipe, there is one additional interesting aspect
    of the Tween.js library. In our recipe, we configured the `TWEEN.Tween` object
    step by step. You can also configure the object in one call like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一个菜谱之前，有一个关于 Tween.js 库的额外有趣方面。在我们的菜谱中，我们逐步配置了 `TWEEN.Tween` 对象。您也可以像这样在一次调用中配置对象：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This works because Tween.js offers a fluent API. So for each function call,
    this library returns the original `TWEEN.Tween` object. This means that you can
    easily chain calls together like we did in the previous code fragment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为 Tween.js 提供了一个流畅的 API。因此，对于每个函数调用，这个库都会返回原始的 `TWEEN.Tween` 对象。这意味着你可以像我们在前面的代码片段中那样轻松地链式调用。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: You can use the Tween.js library in pretty much every case where we used an
    animation in this book. For instance, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*, we showed you the Rotating an object around
    its own axis recipe. The rotation could be easily managed using a `TWEEN.Tween`
    object. In [Chapter 3](ch03.html "Chapter 3. Working with the Camera"), *Working
    with the Camera*, we showed you how to zoom in on an object in the *Zooming the
    camera to an object* recipe. With the Tween.js library, we can easily animate
    this zoom functionality.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在本书中几乎任何使用动画的地方使用 Tween.js 库。例如，在 [第 2 章](ch02.html "第 2 章。几何体和网格")，*几何体和网格*中，我们展示了如何通过旋转对象绕其自身轴的食谱。旋转可以通过一个
    `TWEEN.Tween` 对象轻松管理。在 [第 3 章](ch03.html "第 3 章。与相机一起工作")，*与相机一起工作*中，我们展示了如何在
    *将相机缩放到对象* 食谱中放大对象。使用 Tween.js 库，我们可以轻松地动画化这个缩放功能。
- en: Animating using morph targets
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用形态目标进行动画化
- en: When modeling 3D objects and characters, there are generally two different ways
    of creating animations. You can animate using morph targets, or you can use skeleton-and-bones-based
    animations. Three.js facilitates both of these approaches. In this recipe, we'll
    look at the morph-based animation. With morph-based animations, like the name
    implies, you morph one geometry shape into another. This works great for facial
    expressions and other very detailed animations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模 3D 对象和角色时，通常有两种不同的创建动画的方式。你可以使用形态目标来动画化，或者使用基于骨骼和骨骼的动画。Three.js 促进了这两种方法。在本例中，我们将查看基于形态的动画。正如其名所示，基于形态的动画会将一个几何形状变形为另一个。这对于面部表情和其他非常详细的动画效果非常适用。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we don''t require any additional libraries as morph-based
    animations are supported by the standard Three.js distribution. To make this recipe
    more understandable, we use an existing 3D model to demonstrate how morphing works.
    You can see the model and the available morphs when you open the `07.02-animation-with-morphing.html`
    example in your browser. You will see something similar to what is shown in the
    following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们不需要任何额外的库，因为基于形态的动画由标准的 Three.js 分发支持。为了使这个食谱更易于理解，我们使用一个现有的 3D 模型来演示变形是如何工作的。当你打开浏览器中的
    `07.02-animation-with-morphing.html` 示例时，你可以看到模型和可用的变形。你将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_07_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_07_02.jpg)'
- en: 'In this example, you can see a simple model of a car. Using the sliders in
    the top-right section, you can slowly morph this car into a different model, as
    shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到一个简单的汽车模型。使用右上角的滑块，你可以将这个汽车缓慢地变形为不同的模型，如下面的截图所示：
- en: '![Getting ready](img/1182OS_07_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_07_03.jpg)'
- en: If you check the **animate** box, an animation that automatically morphs this
    car will start.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你勾选了 **animate** 复选框，一个自动变形的动画就会开始。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use morphing animations, we need to take the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用变形动画，我们需要采取以下步骤：
- en: 'The first thing we need to do is load the model that contains morph targets.
    For this recipe, we''ve got a `JSON`-based model, which we load like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是加载包含形态目标的模型。对于这个食谱，我们有一个基于 `JSON` 的模型，我们这样加载它：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we use `THREE.JSONLoader` to load a model, and once it is loaded, we call
    the provided function.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `THREE.JSONLoader` 来加载一个模型，一旦加载完成，我们就调用提供的函数。
- en: 'Before we create `THREE.Mesh`, there is one additional step we need to take.
    We need to set the `morphTargets` property on the materials that are set to `true`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建 `THREE.Mesh` 之前，还有一步需要我们去做。我们需要将 `morphTargets` 属性设置为 `true` 的材质设置好：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to create `THREE.Mesh` and add it to the scene:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `THREE.Mesh` 并将其添加到场景中：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we follow the standard way of creating `THREE.Mesh` and add
    it to the scene just like any other object.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们遵循创建 `THREE.Mesh` 的标准方式，并将其添加到场景中，就像任何其他对象一样。
- en: 'Now that we''ve got an object in the scene that can be morphed, we can use
    the `morphTargetInfluences` property to set how much the object is morphed into
    a specific direction. In the example for this recipe, we used the UI to control
    this setting as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以在场景中变形的对象，我们可以使用`morphTargetInfluences`属性来设置对象变形到特定方向的程度。在这个配方的示例中，我们使用UI来控制这个设置如下：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The model we used in this recipe has four morph targets (with names `mt_0`,
    `mt_1`, `mt_2`, and `mt_3`), its base state and three other car models. By increasing
    the `morphTargetInfluence` object of one of those other models, we can morph the
    model into that direction.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了具有四个形态目标（名称分别为`mt_0`、`mt_1`、`mt_2`和`mt_3`）的模型，其基础状态和三个其他汽车模型。通过增加其中一个其他模型的`morphTargetInfluence`对象，我们可以将模型变形到那个方向。
- en: As you can see in this recipe, by simply changing the value of a specific `morphTargetInfluences`
    value, you can change the way your model looks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个配方中所示，通过简单地改变一个特定的`morphTargetInfluences`值，你可以改变模型的外观。
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In models that support multiple morph targets, an additional set of vertices
    is stored to represent that position for each of the targets. So, if you've got
    a face model that has a morph target for a smile, one for a frown, and one for
    a smirk, you effectively store four times as many vertex positions. With the `morphTargetInfluences`
    property, you can tell Three.js how far the base state (the `geometry.vertices`
    property) should be morphed toward that specific morph target. Three.js will then
    calculate the average position of each individual vertex and render the updated
    model. A very interesting thing is that you can combine morph targets. So if you've
    got separate morph targets for eye movement and mouth movement, you can easily
    create very animated and lifelike animations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持多个形态目标的模型中，会存储额外的顶点集来表示每个目标的位置。因此，如果你有一个面部模型，它有一个微笑的形态目标、一个皱眉的形态目标和一个嘲笑的形态目标，你实际上存储了四倍的顶点位置。使用`morphTargetInfluences`属性，你可以告诉Three.js基础状态（`geometry.vertices`属性）应该向特定形态目标变形多远。然后Three.js将计算每个单独顶点的平均位置并渲染更新后的模型。一个非常有趣的事情是你可以组合形态目标。所以如果你有分别针对眼球运动和嘴部运动的独立形态目标，你可以轻松创建非常生动逼真的动画。
- en: There's more…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In this recipe, we loaded an external model that contained the morph targets.
    If you''ve already got a simple geometry that you want to use for morph-based
    animations, you can also easily do that. For instance, if you''ve got a geometry,
    you can add `morphTargets` using the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们加载了一个包含形态目标的模型。如果你已经有一个简单的几何体，你想用于基于形态的动画，你也可以轻松地做到这一点。例如，如果你有一个几何体，你可以使用以下代码添加`morphTargets`：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The important aspect here is to make sure you provide the same amount of vertices
    to the `vertices` property as there are in the `initial` geometry. You can now
    control the morph between the various targets using the `morphTargetInfluences`
    properties on `THREE.Mesh`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要方面是确保你提供给`vertices`属性与`initial`几何体中相同的顶点数量。你现在可以使用`THREE.Mesh`上的`morphTargetInfluences`属性来控制各种目标之间的变形：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: An alternative way to animate models can be done using skeleton and bones. We
    explain how to do this in the *Animation with skeletons* recipe. We also provide
    two recipes in this chapter where we define morph-and-skeleton-based animations
    in an external tool (Blender, in our case) and play the animation in Three.js.
    See the *Using morph animations created in Blender* and *Using skeleton animations
    created in Blender* recipes for more information about these approaches.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种动画模型的方法可以使用骨骼和骨头。我们在*使用骨骼进行动画*配方中解释了如何这样做。我们还在本章中提供了两个配方，其中我们在外部工具（在我们的例子中是Blender）中定义基于形态和骨骼的动画，并在Three.js中播放动画。请参阅*使用在Blender中创建的形态动画*和*使用在Blender中创建的骨骼动画*配方以获取有关这些方法的更多信息。
- en: Animating with skeletons
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用骨骼进行动画
- en: A common way to animate complex models is using bones and skinning. In this
    approach, we define a geometry, add a skeleton, and tie the geometry to that skeleton.
    Whenever we move or rotate one of the bones of the skeleton, the geometry is deformed
    accordingly. In this recipe, we will show you how you can use the Three.js functionality
    to move and rotate bones directly from JavaScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 动画复杂模型的一种常见方法是使用骨骼和蒙皮。在这种方法中，我们定义一个几何体，添加一个骨骼，并将几何体绑定到该骨骼上。每当移动或旋转骨骼的任何一个部分时，几何体都会相应地变形。在这个配方中，我们将向您展示如何使用Three.js功能直接从JavaScript中移动和旋转骨骼。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we use an external model that already contains a skeleton
    we can move around. To load this model, we use `THREE.JSONLoader`, which is available
    in the standard distribution of Three.js. So, we don''t need to import any additional
    JavaScript files to get this recipe to work. Of course, we''ve provided an example
    of this recipe in action, which you can view by opening the `07.03-animation-with-skeleton.html`
    example in your browser. You will see something similar to what is shown in the
    following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用一个外部模型，该模型已经包含我们可以移动的骨骼。为了加载此模型，我们使用`THREE.JSONLoader`，这是Three.js标准分布的一部分。因此，我们不需要导入任何额外的JavaScript文件来使这个配方工作。当然，我们提供了一个此配方在动作中的示例，您可以通过在浏览器中打开`07.03-animation-with-skeleton.html`示例来查看。您将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_07_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_07_04.jpg)'
- en: This example shows you a model of a giraffe and provides an interface that you
    can use to move the neck bone. You can change the rotation of the neck bone and
    even its position. When you do this, you'll see that part of the mesh responds
    to the movement of this bone. In this recipe, we'll show you how to accomplish
    this for yourself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例向您展示了一头长颈鹿的模型，并提供了一个您可以用来移动颈部骨骼的界面。您可以更改颈部骨骼的旋转甚至其位置。当您这样做时，您会看到网格的一部分会响应该骨骼的运动。在这个配方中，我们将向您展示如何自己完成这项操作。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Working directly with bones isn''t that difficult and only takes a couple of
    small steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 直接与骨骼一起工作并不困难，只需几个小步骤：
- en: 'The first thing we need to do is load a model that contains bones. For this
    recipe, we once again use `THREE.JSONLoader`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是加载一个包含骨骼的模型。对于这个配方，我们再次使用`THREE.JSONLoader`：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the model from step 1 has been loaded, we can set up the materials and
    create the mesh. Let''s first look at the materials:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦加载了步骤1中的模型，我们就可以设置材质并创建网格。让我们首先看看材质：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we set the `skinning` property of the material to `true`. This tells Three.js
    that this object contains bones and the geometry should deform when the bones
    move.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将材质的`skinning`属性设置为`true`。这告诉Three.js该对象包含骨骼，当骨骼移动时，几何形状应该变形。
- en: 'Next, we create the mesh and add it to the scene:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建网格并将其添加到场景中：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we've used a different kind of mesh for this object. Instead
    of the `THREE.Mesh` object, we've used a `THREE.SkinnedMesh` object.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们为这个对象使用了不同类型的网格。我们使用的是`THREE.SkinnedMesh`对象，而不是`THREE.Mesh`对象。
- en: To access the bones, we access the children elements of `THREE.SkinnedMesh`.
    Getting the correct bone to animate might take some experimenting if the bones
    aren't clearly named. The easiest way to determine which bone to use is to look
    through the output of the JavaScript console and browse the children of the mesh.![How
    to do it…](img/1182OS_07_05.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问骨骼，我们需要访问`THREE.SkinnedMesh`的子元素。如果骨骼没有明确命名，获取正确的骨骼进行动画可能需要进行一些实验。确定要使用哪个骨骼的最简单方法是查看JavaScript控制台的输出并浏览网格的子元素。![如何操作…](img/1182OS_07_05.jpg)
- en: 'In this case, we want to rotate the tail bone and rotate and position the neck.
    For this, we add the following to the `render` loop:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要旋转尾巴骨骼并旋转和定位颈部。为此，我们在`render`循环中添加以下内容：
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it! Whenever we now change the position of the rotation of the bones
    we used in the previous code snippet, the geometry will deform accordingly.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！每当我们现在更改之前代码片段中使用的骨骼的位置或旋转时，几何形状将相应地变形。
- en: Working with bones isn't that difficult, but selecting the correct bone to change
    and move around can take some experimentation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与骨骼一起工作并不困难，但选择要更改和移动的正确骨骼可能需要一些实验。
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you enable the `skinning` property on the material, Three.js passes all
    the information about the relevant bones and positions into its vertex shader.
    The vertex shader will use this information to position the vertices to their
    new position based on the position and rotation of the relevant bones. More information
    and a good introduction on how to execute skeletal animations from a vertex shader
    can be found on the OpenGL website at [https://www.opengl.org/wiki/Skeletal_Animation](https://www.opengl.org/wiki/Skeletal_Animation).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在材质上启用`skinning`属性时，Three.js会将有关相关骨骼和位置的所有信息传递到其顶点着色器中。顶点着色器将使用这些信息根据相关骨骼的位置和旋转将顶点定位到新位置。更多信息和关于如何从顶点着色器执行骨骼动画的良好介绍可以在OpenGL网站上找到，链接为[https://www.opengl.org/wiki/Skeletal_Animation](https://www.opengl.org/wiki/Skeletal_Animation)。
- en: There's more…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you want to get a quick overview of how the bones are organized in a model,
    you can use a specific helper class that is provided by Three.js. The following
    code snippet shows you how to create `THREE.SkeletonHelper` for the model we used
    in this recipe:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速了解模型中骨骼的排列方式，你可以使用Three.js提供的特定辅助类。以下代码片段展示了如何为我们在本配方中使用的模型创建`THREE.SkeletonHelper`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will visualize the bones of a model, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将可视化模型的骨骼，如下面的截图所示：
- en: '![There''s more…](img/1182OS_07_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_07_06.jpg)'
- en: 'If you move bones around, which we do in our recipe, you also need to add the
    following line to your `render` loop:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移动骨骼，就像我们在配方中所做的那样，你还需要在你的`render`循环中添加以下行：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way, `THREE.SkeletonHelper` will always reflect the latest state of the
    model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`THREE.SkeletonHelper`将始终反映模型的最新状态。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A simpler way to animate models is using morph targets. We explain how to do
    this in the *Animation using morph targets* recipe. We also provide two recipes
    in this chapter where we define morph-and-skeleton-based animations in an external
    tool (Blender, in our case) and play the animation in Three.js. Refer to the *Using
    morph animations created in Blender* and *Using skeleton animations created in
    Blender* recipes for more information on these approaches.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形态目标来动画化模型是一种更简单的方法。我们在“使用形态目标进行动画”的配方中解释了如何做到这一点。在本章中，我们还提供了两个配方，其中我们在外部工具（在我们的例子中是Blender）中定义基于形态和骨骼的动画，并在Three.js中播放动画。有关这些方法的更多信息，请参阅“使用在Blender中创建的形态动画”和“使用在Blender中创建的骨骼动画”配方。
- en: Using morph animations created in Blender
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用在Blender中创建的形态动画
- en: Creating morph animations by hand is difficult to do in Three.js. Simple transformations
    can probably be handled, but creating advanced animations programmatically is
    very difficult. Luckily, there are a large number of external 3D programs that
    you can use to create the models and animations. In this recipe, we'll use Blender,
    which we already used in [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"),
    *Geometries and Meshes*, to create a morph-based animation and play it back using
    Three.js.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中手动创建形态动画是困难的。简单的变换可能可以处理，但通过编程创建高级动画非常困难。幸运的是，有许多外部3D程序可以用来创建模型和动画。在本配方中，我们将使用Blender，我们在[第2章](ch02.html
    "第2章。几何体和网格")，“几何体和网格”中已经使用过，来创建基于形态的动画，并使用Three.js回放。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: To use this recipe, you have to have Blender installed and enable the Three.js
    exporter plugin. We've already explained how to do this in the *Creating and exporting
    a model from Blender* recipe, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. So if you haven't already done so, you
    should first install Blender and then the Three.js export plugin. Once you've
    installed Blender, you should create an animation that uses shape keys to define
    various formats. Doing this is out of the scope of this book, but to make sure,
    you can test the steps explained in this recipe—we've included a Blender file,
    which has a minimal shape-keys-based animation. So before we get started with
    the recipe, we'll load the example Blender model.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此配方，你必须安装Blender并启用Three.js导出插件。我们已经在[第2章](ch02.html "第2章。几何体和网格")，“几何体和网格”中的“创建和导出从Blender模型”配方中解释了如何做到这一点。所以如果你还没有这样做，你应该首先安装Blender，然后安装Three.js导出插件。一旦安装了Blender，你应该创建一个使用形状键定义各种格式的动画。这超出了本书的范围，但为了确保，你可以测试本配方中解释的步骤——我们包含了一个Blender文件，它包含一个基于最小形状键的动画。所以在我们开始配方之前，我们将加载示例Blender模型。
- en: 'For this, take the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: Open **Blender** and navigate to **File** | **Open**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Blender**并导航到**文件** | **打开**。
- en: In the window that opens, navigate to the sources provided with the book and
    open the `simplemorph.blend` file, which can be found in the `assets/models/blender`
    directory.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，导航到与本书提供的资源，并打开位于`assets/models/blender`目录中的`simplemorph.blend`文件。
- en: Once this file is opened, you'll see a cube in the center of an empty scene
    like this:![Getting ready](img/1182OS_07_07.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开此文件，你将看到一个立方体位于一个空场景的中心，就像这样：![准备中](img/1182OS_07_07.jpg)
- en: This is the starting point from where we start the recipe.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们开始配方的起点。
- en: If you want to preview the (very simple) animation we've created here, just
    click on the **play** button or use the *Alt* + *A* key combination.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要预览我们在这里创建的（非常简单）动画，只需点击**播放**按钮或使用*Alt* + *A*键组合。
- en: We will load this file in Three.js and play the animation we created in Blender.
    To see the final result, open the `07.04-create-morph-in-blender.html` example
    in your browser. You will see something similar to what is shown in the following
    screenshot:![Getting ready](img/1182OS_07_08.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Three.js中加载此文件并播放我们在Blender中创建的动画。要查看最终结果，在你的浏览器中打开`07.04-create-morph-in-blender.html`示例。你将看到以下截图所示的内容：![准备就绪](img/1182OS_07_08.jpg)
- en: You'll see an animating cube that uses morph targets (defined as shape keys
    in Blender) to morph a cube into different shapes.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到一个使用形态目标（在Blender中定义为形状键）来将一个立方体变形为不同形状的动画立方体。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you''ve followed the steps explained in the *Getting ready* section of this
    recipe, you''ll be looking at a simple Blender workspace with a single cube and
    an animation that slowly morphs the cube using a set of shape keys. To export
    this animation from Blender and use it in Three.js, we need to take a couple of
    steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照本食谱中*准备就绪*部分所解释的步骤进行，你将看到一个简单的Blender工作区，其中有一个立方体和一个动画，该动画使用一系列形状键缓慢地变形立方体。要从Blender导出此动画并在Three.js中使用它，我们需要采取几个步骤：
- en: The first thing we need to do is export the model and the animation to which
    we can load it in Three.js. To do this, navigate to **File** | **Export** | **Three.js**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导出模型和动画，这样我们就可以在Three.js中加载它。为此，导航到**文件** | **导出** | **Three.js**。
- en: In the window that opens, we can select a destination and a filename. For this
    recipe, name the file `simplemorph.js` and set the destination to the `assets/models/morph`
    folder.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，我们可以选择一个目的地和文件名。对于这个食谱，将文件命名为`simplemorph.js`并将目的地设置为`assets/models/morph`文件夹。
- en: Before we hit the **Export** button, we need to configure some Three.js-specific
    properties. You can do this in the panel on the left-hand side in the **Export
    Three.js** section. In that section, make sure that the **Morph animation** checkbox
    is selected. Once you've checked the box, click on the **Export** button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们点击**导出**按钮之前，我们需要配置一些Three.js特定的属性。你可以在**导出Three.js**部分的左侧面板中这样做。在该部分中，确保选中**形态动画**复选框。一旦选中复选框，点击**导出**按钮。
- en: 'Now we''re done with our work in Blender and can load the exported model in
    Three.js. For this, we use `THREE.JSONLoader` like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了在Blender中的工作，可以加载导出的模型到Three.js中。为此，我们使用`THREE.JSONLoader`，如下所示：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code snippet, we load the model using `THREE.JSONLoader`.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用`THREE.JSONLoader`加载模型。
- en: 'Once the model is loaded, we need to create a material where we need to set
    the `morphTargets` property to `true`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模型被加载，我们需要创建一个材质，其中需要将`morphTargets`属性设置为`true`：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this material, we can create the mesh to be added to the scene. This time,
    as we want to use the animation provided from Blender, we create `THREE.MorphAnimMesh`,
    which we add to the scene:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种材质，我们可以创建要添加到场景中的网格。这次，因为我们想使用从Blender提供的动画，我们创建`THREE.MorphAnimMesh`并将其添加到场景中：
- en: '[PRE23]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to take a final step before we can play the animation:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以播放动画之前，我们需要采取最后一步：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the `parseAnimation()` function, Three.js will parse the names of the provided
    morph target elements from the model and use it to create an animation. When you
    export using the Three.js plugin from Blender, the name of the animation is `animation`.
    To play the animation, we call `playAnimation` with the name of the animation
    and the frame rate, and finally, we set the duration (in seconds) of the animation.
    Note that you don't always have to set the duration of an animation. In some cases,
    the model itself provides the duration.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`parseAnimation()`函数，Three.js将解析模型中提供的形态目标元素的名称，并使用它来创建一个动画。当你使用Blender中的Three.js插件导出时，动画的名称是`animation`。要播放动画，我们调用`playAnimation`函数，传入动画名称和帧率，最后设置动画的持续时间（以秒为单位）。请注意，你并不总是需要设置动画的持续时间。在某些情况下，模型本身提供了持续时间。
- en: 'The final change we need to make is in the `render` function itself:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`render`函数本身中进行最后的更改：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we create a global `THREE.Clock()` instance, which we use to determine
    how much time is passed between sequential calls to the `render` function. This
    is passed into the `updateAnimation` function of `THREE.MorphAnimMesh` so that
    it can calculate which frame to show.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个全局的`THREE.Clock()`实例，我们使用它来确定在连续调用`render`函数之间经过的时间。这个实例被传递到`THREE.MorphAnimMesh`的`updateAnimation`函数中，以便它可以计算要显示的帧。
- en: As you've seen from the recipe, getting an animation to play in Three.js from
    Blender isn't that difficult. One thing to take into account here, though, is
    that this can result in huge files when you've got models with a high vertex count.
    This happens because the Blender export plugin creates a new morph target for
    each frame of the animation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 Blender 将动画播放到 Three.js 中并不困难。然而，这里需要注意的是，当模型具有高顶点数时，这可能会导致文件变得非常大。这是因为
    Blender 导出插件为动画的每一帧创建一个新的形态目标。
- en: There's more…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: In this recipe, we've used the Three.js export function of Blender to save the
    model in a format `THREE.JSONLoader` can load. There are a large number of other
    3D formats available, which can be used to store 3D scenes and animations that
    are supported by Three.js. An overview of the file formats that are available
    in Three.js can be found on the Three.js GitHub site at [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 Blender 的 Three.js 导出功能来保存模型，以便 `THREE.JSONLoader` 可以加载。还有大量其他
    3D 格式可供使用，可以用来存储 Three.js 支持的 3D 场景和动画。Three.js 中可用的文件格式概述可以在 [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders)
    的 Three.js GitHub 网站上找到。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter, we''ve got some other recipes that deal with animations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们还有一些其他与动画相关的菜谱：
- en: '*Animation using morph targets*'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用形态目标进行动画制作*'
- en: '*Animation with skeletons*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用骨骼的动画*'
- en: '*Using skeleton animations created in Blender*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用在 Blender 中创建的骨骼动画*'
- en: Using skeleton animations created in Blender
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用在 Blender 中创建的骨骼动画
- en: In the *Animation with skeletons* recipe, we animated a model by directly changing
    the position and rotation of its bones. This works great in an interactive scenery
    but isn't a practical way to create animations. With Blender and other 3D tools,
    you've got a large set of tools to create animations based on a specific skeleton
    and a set of bones. In this recipe, we'll show you how you can play back a skeleton-based
    animation that was created in Blender.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用骨骼的动画* 菜单中，我们通过直接改变模型骨骼的位置和旋转来动画化一个模型。这在交互式场景中效果很好，但并不是创建动画的实用方法。使用 Blender
    和其他 3D 工具，你可以获得一套创建基于特定骨骼和一系列骨骼的动画的工具。在这个菜谱中，我们将向你展示如何播放一个在 Blender 中创建的基于骨骼的动画。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To use this recipe, you need to have Blender installed and enable the Three.js
    exporter plugin. If you haven''t done so, follow the steps from the *Creating
    and exporting a model from Blender* recipe, in [Chapter 2](ch02.html "Chapter 2. Geometries
    and Meshes"), *Geometries and Meshes*. Once Blender and the Three.js export plugin
    have been installed, we need to create a skeleton-based animation. Creating this
    in Blender is out of the scope of this book, so we''ve provided an existing model
    to demonstrate this recipe. To get started, perform the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此菜谱，你需要安装 Blender 并启用 Three.js 导出插件。如果你还没有这样做，请按照 [第 2 章](ch02.html "第 2
    章。几何体和网格") 中 *从 Blender 创建和导出模型* 菜谱的步骤进行操作，*几何体和网格*。一旦 Blender 和 Three.js 导出插件已安装，我们需要创建一个基于骨骼的动画。在
    Blender 中创建这个动画超出了本书的范围，因此我们提供了一个现有的模型来演示这个菜谱。要开始，请执行以下步骤：
- en: Open **Blender** and navigate to **File** | **Open**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Blender** 并导航到 **文件** | **打开**。
- en: In the window that opens, navigate to the sources provided with the book and
    open the `crow-skeleton.blend` file, which can be found in the `assets/models/blender`
    directory.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，导航到书中提供的资源并打开 `assets/models/blender` 目录中的 `crow-skeleton.blend` 文件。
- en: Once this file is open, you'll see a crow in the center of an empty scene like
    this:![Getting ready](img/1182OS_07_09.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开此文件，你将看到一个乌鸦位于一个空场景的中心，如下所示：![准备中](img/1182OS_07_09.jpg)
- en: This is the starting point of this recipe.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是本菜谱的起点。
- en: If you want to preview the crow animation, click on the **play** button or use
    the *Alt* + *A* key combination.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要预览乌鸦动画，请点击**播放**按钮或使用 *Alt* + *A* 键组合。
- en: 'We have also provided an example that you can open in your browser to see the
    same animation in a Three.js scene. When you open the `07.05-create-skeleton-animation-in-blender.html`
    example in your browser, you should see something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个示例，你可以在浏览器中打开以查看 Three.js 场景中的相同动画。当你打开浏览器中的 `07.05-create-skeleton-animation-in-blender.html`
    示例时，你应该会看到如下内容：
- en: '![Getting ready](img/1182OS_07_10.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_07_10.jpg)'
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before we can use the model in Three.js, we first have to export it from Blender:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在 Three.js 中使用模型之前，我们首先必须从 Blender 中导出它：
- en: To start the export, first navigate to **File** | **Export** | **Three.js**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始导出，首先导航到 **文件** | **导出** | **Three.js**。
- en: In the window that opens, we can select a destination and a filename. For this
    recipe, name the file `crow.js` and set the destination to the `assets/models/bones`
    folder.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，我们可以选择一个目的地和文件名。对于这个食谱，将文件命名为 `crow.js` 并将目的地设置为 `assets/models/bones`
    文件夹。
- en: Before we hit the **Export** button, we need to configure some Three.js-specific
    properties. You can do this in the panel on the left-hand side in the **Export
    Three.js** section. In that section, make sure that the **Bones**, **Skinning**,
    and **Skeletal** animation checkboxes are selected. If the **Morph Animation**
    checkbox is selected, disable it. Once you've checked the box, click on the **Export**
    button.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们点击 **导出** 按钮之前，我们需要配置一些 Three.js 特定的属性。你可以在 **导出 Three.js** 部分的左侧面板中完成此操作。在该部分中，确保选中
    **骨骼**、**皮肤** 和 **骨骼动画** 复选框。如果选中了 **形变动画** 复选框，请禁用它。一旦选中复选框，点击 **导出** 按钮。
- en: 'Now that we''ve exported the model, the first thing we need to do in Three.js
    is load the model using `THREE.JSONLoader`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导出了模型，在 Three.js 中我们需要做的第一件事是使用 `THREE.JSONLoader` 加载模型：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the model is loaded in Three.js. we can process it. The first thing we
    do in the callback from the `loader.load` function is to set up the material:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模型在 Three.js 中加载，我们就可以处理它了。从 `loader.load` 函数的回调中，我们首先做的事情是设置材质：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is just a standard `THREE.MeshLambertMaterial` object. The only thing you
    need to make sure is to set the `skinning` property of the material to `true`.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是一个标准的 `THREE.MeshLambertMaterial` 对象。你需要确保的唯一事情是将材质的 `skinning` 属性设置为 `true`。
- en: 'Now that we''ve got the model and the material, we can create a mesh. As we''re
    working with skeletons, we need to create `THREE.SkinnedMesh`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了模型和材质，我们可以创建一个网格。由于我们正在处理骨骼，我们需要创建 `THREE.SkinnedMesh`：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we need to select the animation we want to play. For this, you use the
    following code snippet:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择我们想要播放的动画。为此，你可以使用以下代码片段：
- en: '[PRE29]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You need to make sure the `animation` property contains the name of an animation
    from the `model.animations` array. In this case, we've only got one animation
    with the `Crow.ArmatureAction` name. Skeleton-based animations are handled using
    `THREE.AnimationHandler`. So, we add the animation from our model to the handler.
    Next, we need to create a `THREE.Animation` instance. This object combines our
    model with the animation we want to play. When we have this object we can call
    the `play()` function to tell Three.js to play the animation.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要确保 `animation` 属性包含 `model.animations` 数组中某个动画的名称。在这种情况下，我们只有一个名为 `Crow.ArmatureAction`
    的动画。基于骨骼的动画使用 `THREE.AnimationHandler` 处理。因此，我们将我们的模型中的动画添加到处理器中。接下来，我们需要创建一个
    `THREE.Animation` 实例。该对象将我们的模型与想要播放的动画结合起来。当我们拥有这个对象时，我们可以调用 `play()` 函数来告诉 Three.js
    播放动画。
- en: 'The final step we need to take before the animation will play is to update
    the `render` loop:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画播放之前，我们需要采取的最后一步是更新 `render` 循环：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we use `THREE.Clock()` to determine how much time has passed (`t.getDelta()`)
    between this frame and the previous one. This is passed into `THREE.AnimationHandler`
    to update all the registered animations and move the mesh in the correct position.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `THREE.Clock()` 来确定这一帧和前一帧之间经过的时间 (`t.getDelta()`)。这个值被传递到 `THREE.AnimationHandler`
    中，以更新所有注册的动画并移动网格到正确的位置。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When exporting the animation, the Three.js exporter will write out the position
    and rotation of the bones at the times we specified in Blender. This information
    can then be used directly in Three.js to determine the position and rotation of
    the bones when we're playing back the animation. This way, we can create fairly
    complex animations without having to create huge model files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当导出动画时，Three.js 导出器将输出我们在 Blender 中指定的时刻骨骼的位置和旋转。然后，这些信息可以直接在 Three.js 中使用，以确定播放动画时骨骼的位置和旋转。这样，我们可以在不创建大型模型文件的情况下创建相当复杂的动画。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Working with skeletons in Blender and creating animations from them is a subject
    on which much is written. If you''re interested in learning more about rigging
    models and creating skeleton-based animations, a couple of good resources to start
    with are the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blender 中处理骨骼并从中创建动画是一个被广泛讨论的主题。如果你对学习如何绑定模型和创建基于骨骼的动画感兴趣，以下是一些不错的起点资源：
- en: 'Blender Tutorial: Basics of Character Rigging at [http://www.youtube.com/watch?v=cGvalWG8HBU](http://www.youtube.com/watch?v=cGvalWG8HBU)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender教程：角色绑定基础[http://www.youtube.com/watch?v=cGvalWG8HBU](http://www.youtube.com/watch?v=cGvalWG8HBU)
- en: 'Blender manual: rigging at [http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging](http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender手册：绑定[http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging](http://wiki.blender.org/index.php/Doc:2.6/Manual/Rigging)
- en: 'Blender Guru: introduction to rigging at [http://www.blenderguru.com/tutorials/introduction-to-rigging](http://www.blenderguru.com/tutorials/introduction-to-rigging)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender大师：绑定介绍[http://www.blenderguru.com/tutorials/introduction-to-rigging](http://www.blenderguru.com/tutorials/introduction-to-rigging)
- en: Building A Basic Low Poly Character Rig In Blender at [http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955](http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Blender中构建基本低多边形角色绑定[http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955](http://cgi.tutsplus.com/tutorials/building-a-basic-low-poly-character-rig-in-blender--cg-16955)
- en: See also
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter, we have some other recipes that deal with animations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们还有一些其他处理动画的配方：
- en: '*Animation using morph targets*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用形态目标进行动画*'
- en: '*Animation with skeletons*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用骨骼进行动画*'
- en: '*Using morph animations created in Blender*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Blender创建的形态动画*'
- en: Adding a simple collision detection
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加简单的碰撞检测
- en: When you're creating games or interactive environments, a common requirement
    is the option to detect collisions between objects. In the *Adding a physics engine*
    recipe, we use an external library to handle collisions (and other physics). This,
    however, is a rather heavy solution if all you require is the option to detect
    collisions. In this recipe, we provide a simple approach that you can use if you
    want to detect collisions without having to use an external library.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建游戏或交互式环境时，一个常见的需求是检测对象之间的碰撞。在*添加物理引擎*的配方中，我们使用外部库来处理碰撞（以及其他物理）。然而，如果你只需要检测碰撞的选项，这却是一个相当重的解决方案。在这个配方中，我们提供了一个简单的方案，如果你想在不需要使用外部库的情况下检测碰撞，你可以使用它。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we use `THREE.Raycaster` to check for collisions. This object
    is provided by the standard Three.js distribution, so you don''t need any additional
    libraries. We''ve provided a simple example that shows you how this recipe can
    be applied. For this, open the `07.06-add-simple-detection-collision.html` example
    in your browser, and you will see something similar to what is shown in the following
    screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用`THREE.Raycaster`来检查碰撞。这个对象由标准的Three.js分发提供，所以你不需要任何额外的库。我们提供了一个简单的示例，展示了如何应用这个配方。为此，在你的浏览器中打开`07.06-add-simple-detection-collision.html`示例，你将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_07_11.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_07_11.jpg)'
- en: In this example, you can move the central cube around using the arrow keys and
    rotate it around the *y* axis with the *a* and *b* keys. Whenever a collision
    occurs with one of the other cubes, we change the opacity to indicate a collision.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以使用箭头键移动中央立方体，并使用*a*和*b*键绕*y*轴旋转它。每当与其他立方体发生碰撞时，我们将改变不透明度以指示碰撞。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To accomplish collision detection, we need to take a couple of steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现碰撞检测，我们需要采取几个步骤：
- en: 'Let''s start simple and create the cube that we''ll move around. We will detect
    collisions between this cube and the cubes we define in step 2:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从简单开始，创建我们将要移动的立方体。我们将检测这个立方体与我们定义的第2步中的立方体之间的碰撞：
- en: '[PRE31]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s create an array that will hold all the objects that we can collide
    with and add some cubes to that array:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个数组来存储我们可以与之碰撞的所有对象，并向该数组添加一些立方体：
- en: '[PRE32]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we''ve got the object to move around and the objects to detect the
    collisions with, we can add the code to detect collisions. In the `render` loop,
    we need to add the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了可以移动的对象和可以检测碰撞的对象，我们可以添加代码来检测碰撞。在`render`循环中，我们需要添加以下内容：
- en: '[PRE33]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this piece of code, we simply check whether one of the vertices of our moving
    cube intersects with any of the cubes in the `cubes` array. If we detect a collision,
    we change the opacity of the cube we collided with.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码中，我们简单地检查我们移动的立方体的一个顶点是否与`cubes`数组中的任何立方体相交。如果我们检测到碰撞，我们将改变与之碰撞的立方体的不透明度。
- en: With these steps, we have a rudimentary solution to detect collisions. This
    approach works great to detect collisions between flat objects but might miss
    detection with small spike-like objects. You can enhance this solution by checking
    collisions against more vertices. You can, for instance, add more vertices by
    increasing the `widthSegments`, `heightSegments`, and `depthSegments` objects
    of the cube, or you can calculate intermediate vertices yourself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect collisions in this approach, we shoot a ray using `THREE.RayCaster`
    from the center of the cube that is moving to each of its vertices. If this ray
    intersects with one of the other cubes from the `cubes` array in its path from
    the center to a vertex, it means that one of the vertices is inside one of the
    other cubes. We interpret this as a collision and can take appropriate action.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the great work done by Lee Stemkoski, who provided an
    initial implementation of this approach at [http://stemkoski.github.io/Three.js/Collision-Detection.html](http://stemkoski.github.io/Three.js/Collision-Detection.html).
    Besides a ray-based approach to collision detection, there are, of course, alternative
    approaches. A very common approach is to use the bounding boxes of a mesh to detect
    whether two meshes touch. Three.js even provides a function for this in the `THREE.Box3`
    object called `isIntersectionBox`. As using a ray casting approach is a rather
    computationally expensive way to detect collisions, often a bounding box approach
    is used first, followed by the more accurate ray casting method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of good resources on such an approach can be found here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*3D Theory - Collision Detection* at [http://www.euclideanspace.com/threed/animation/collisiondetect/](http://www.euclideanspace.com/threed/animation/collisiondetect/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AABB to AABB detection in C++* at [http://www.miguelcasillas.com/?p=30](http://www.miguelcasillas.com/?p=30)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*3D Collision detection and resolution using sweeping AABB bounding boxes*
    at [http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping](http://techny.tumblr.com/post/42125198333/3d-collision-detection-and-resolution-using-sweeping)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physics engine we will use in the *Adding a physics engine* recipe also
    uses a shapes-based approach to collision detection. Besides just a bounding box,
    it provides a number of different shapes to detect collisions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Adding a physics engine* recipe, we detect collisions using the physics
    engine. For another recipe that uses `THREE.RayCaster`, you can also look at the
    *Dragging and dropping objects around a scene* recipe, which can also be found
    in this chapter.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a movie of an animation in Chrome
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've showed you various ways to create animations. Sometimes,
    however, people don't have a WebGL-enabled browser, or you want to just share
    the resulting animation and not the WebGL website. In these cases, it would be
    very helpful to be able to just save the animation to your local filesystem and
    share it. In this recipe, we show you one approach you can use for this scenario.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了创建动画的各种方法。然而，有时人们没有启用WebGL的浏览器，或者您只想分享生成的动画而不是WebGL网站。在这些情况下，能够将动画直接保存到本地文件系统并分享它将非常有帮助。在本菜谱中，我们向您展示了一种可以用于此场景的方法。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To work with this recipe, you need to make sure that you use Google Chrome.
    We use an internal functionality to save the animation as a WebM file, which unfortunately,
    still only works on Google Chrome. We don''t have to create the complete functionality
    for this recipe from scratch, as there is a library available that handles the
    low-level technical stuff for us: CCapture ([https://github.com/spite/ccapture.js/](https://github.com/spite/ccapture.js/)).
    To work with this library, we need to load the following two JavaScript files
    at the top of our HTML page:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个菜谱，您需要确保使用Google Chrome。我们使用一个内部功能将动画保存为WebM文件，不幸的是，这仍然只在Google Chrome上工作。我们不需要从头开始创建这个菜谱的完整功能，因为有一个库可以为我们处理底层技术细节：CCapture
    ([https://github.com/spite/ccapture.js/](https://github.com/spite/ccapture.js/))。要使用这个库，我们需要在HTML页面的顶部加载以下两个JavaScript文件：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ve provided a very simple example that shows you this recipe in action.
    If you open up `07.07-save-a-movie-of-an-animation.html` in your browser, you''ll
    see a slowly moving cube in your browser, as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个非常简单的示例，展示了这个菜谱的实际应用。如果您在浏览器中打开 `07.07-save-a-movie-of-an-animation.html`，您将在浏览器中看到一个缓慢移动的立方体，如下面的截图所示：
- en: '![Getting ready](img/1182OS_07_12.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_07_12.jpg)'
- en: The reason this cube moves so slowly is that in the background, a movie is being
    saved. The libraries used slow down the animation to make sure no frames are skipped.
    To save the movie, click on the **saveMovie** menu button at the top of the screen.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个立方体移动得如此缓慢的原因是在后台正在保存一个电影。使用的库会减慢动画速度，以确保不会跳过任何帧。要保存电影，请点击屏幕顶部的**saveMovie**菜单按钮。
- en: 'The resulting movie can now be played in the movie player of your choice, which
    supports WebM (for instance, VLC or mPlayer) as shown in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的电影现在可以在支持WebM的任何电影播放器中播放（例如，VLC或mPlayer），如下面的截图所示：
- en: '![Getting ready](img/1182OS_07_13.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_07_13.jpg)'
- en: How to do it…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Once you''ve included the appropriate libraries in your HTML page, using this
    library is actually very easy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在您的HTML页面中包含了适当的库，使用这个库实际上非常简单：
- en: 'The first thing we need to do is create a `capture` object:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个 `capture` 对象：
- en: '[PRE35]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we create a capturer that captures 20 frames per second.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个每秒捕获20帧的 `capturer`。
- en: 'The next step before we start rendering the scene is to start `capturer`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始渲染场景之前，下一步是启动 `capturer`：
- en: '[PRE36]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to tell `capturer` what to capture in the `render` loop:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在 `render` 循环中告诉 `capturer` 要捕获什么：
- en: '[PRE37]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With these steps, the `capturer` object will start capturing the output of our
    WebGL canvas 20 times per second.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些步骤，`capturer` 对象将开始以每秒20次的速度捕获我们的WebGL画布的输出。
- en: 'As a last step, we need to add a functionality to save the movie (in our example,
    this is triggered by clicking on the **saveMovie** button):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要添加一个保存电影的功能（在我们的例子中，这是通过点击**saveMovie**按钮触发的）：
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will download the movie as `video.webm` and save it to your local disk.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将下载电影为 `video.webm` 并将其保存到您的本地磁盘。
- en: When you run this, you will notice that the frame rate in your browser drops
    significantly. The reason is that the CCapture library changes the behavior of
    the `requestAnimationFrame` function to make sure it has enough time to capture
    the screen and add it as a frame to the movie. The movie file that is created
    will look like you expected and have the number of frames per second, as specified
    in step 1 of this recipe.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行这个程序时，您会注意到浏览器中的帧率显著下降。原因是CCapture库改变了 `requestAnimationFrame` 函数的行为，以确保它有足够的时间捕获屏幕并将其添加为电影的一帧。创建的电影文件将看起来如您预期，并且具有每秒帧数，正如本菜谱的第1步所指定的。
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The approach that we showed you in the recipe works great for most types of
    animations. However, when you want to record a user interacting with your scene,
    you can't use this library as it slows down the rendering of your scene, which
    makes interacting with the scene difficult. An alternative way to record the scene
    is using a backend service that collects screenshots and creates a movie server
    side. An example of such a setup can be found at [http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在食谱中展示的方法对于大多数类型的动画都非常好用。然而，当你想要记录用户与你的场景交互时，你不能使用这个库，因为它会减慢场景的渲染速度，这使得与场景交互变得困难。记录场景的另一种方法是使用后端服务，该服务收集截图并在服务器端创建电影。这种设置的示例可以在[http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets)找到。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: If you just want to save a screenshot instead of a complete movie, you can use
    the *Saving WebGL output to disk* recipe, which we explained in [Chapter 6](ch06.html
    "Chapter 6. Point Clouds and Postprocessing"), *Point Clouds and Postprocessing*.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想保存屏幕截图而不是完整的电影，你可以使用*将WebGL输出保存到磁盘*的食谱，我们在[第6章](ch06.html "第6章。点云和后处理")，*点云和后处理*中解释了它。
- en: Dragging and dropping objects around a scene
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在场景中拖动和放置对象
- en: When you create an interactive environment, a common requirement is the option
    to use your mouse to drag objects around. This functionality isn't something that
    is supported out of the box by Three.js. In this recipe, we'll show you the steps
    that are needed to implement this functionality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个交互式环境时，一个常见的需求是使用鼠标拖动对象。这种功能不是Three.js默认支持的。在这个食谱中，我们将向你展示实现此功能所需的步骤。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we only use the functionality that is available in the standard
    Three.js library. We''ll use the `THREE.Raycaster` object together with `THREE.Projector`
    to implement the drag and drop functionality. To see the drag and drop functionality
    in action, you can open the `07.08-drag-n-drop-object-around-scene.html` example
    in your browser, and you will see something similar to what is shown in the following
    screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们只使用标准Three.js库中可用的功能。我们将使用`THREE.Raycaster`对象与`THREE.Projector`一起实现拖放功能。要查看拖放功能的效果，你可以在浏览器中打开`07.08-drag-n-drop-object-around-scene.html`示例，你将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_07_14.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_07_14.jpg)'
- en: In this example, you can see a large number of cubes, which you can move individually.
    Just click on one with the mouse and drag it to a new position. This scene also
    uses `THREE.OrbitControls`, so when you click on the white background, you can
    use your mouse to rotate the scene.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到大量的立方体，你可以单独移动它们。只需用鼠标点击一个，并将其拖动到新位置。这个场景也使用了`THREE.OrbitControls`，所以当你点击白色背景时，你可以使用鼠标旋转场景。
- en: How to do it…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For this recipe, we need to take a fair amount of steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要进行相当多的步骤：
- en: 'The first thing we do is create a number of global variables, which we''ll
    access in the following steps:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先做的事情是创建一些全局变量，我们将在以下步骤中访问它们：
- en: '[PRE39]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll explain how these objects are used in the upcoming steps.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在接下来的步骤中解释这些对象是如何使用的。
- en: 'When we want to move an object around, we need to determine on what plane (around
    which axis) we''re going to move the selected cube. A mouse moves in two dimensions,
    while our scene moves in three. For this, we''ll use a invisible helper plane,
    which we define like this:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们想要移动一个对象时，我们需要确定我们将要在哪个平面（围绕哪个轴）移动选定的立方体。鼠标在两个维度上移动，而我们的场景在三个维度上移动。为此，我们将使用一个不可见的辅助平面，我们定义如下：
- en: '[PRE40]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This plane is assigned to the global plane variable we saw in step 1.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个平面被分配给了我们在步骤1中看到的全局平面变量。
- en: 'The next step is to create all the cubes. For an easy understanding of this
    recipe, we list the code about how cubes are created:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建所有立方体。为了更容易理解这个食谱，我们列出了创建立方体的代码：
- en: '[PRE41]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The most interesting line is the highlighted one, where we add the created cube
    to the global array with the name objects. Only cubes from this array can be moved
    around.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最有趣的一行是突出显示的那一行，我们将创建的立方体添加到名为objects的全局数组中。只有这个数组中的立方体可以移动。
- en: 'Now that we''ve got the basics out of the way, we need to tell Three.js what
    to do when the mouse moves, when a mouse button is clicked on, and when a mouse
    button is released. Let''s first look at the `onmousemove` function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经处理了基础知识，我们需要告诉 Three.js 当鼠标移动、鼠标按钮被点击或释放时应该做什么。让我们首先看看 `onmousemove` 函数：
- en: '[PRE42]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Before we can access the information from the mouse movement, we need to register
    a listener. We do this, as you can see in the code snippet, by assigning a function
    to the `document.onmousemove` property. In the following steps, we'll look at
    the contents of this `onmousemove` function.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们可以访问鼠标移动的信息之前，我们需要注册一个监听器。如您在代码片段中看到的，我们通过将一个函数分配给 `document.onmousemove`
    属性来完成此操作。在接下来的步骤中，我们将查看此 `onmousemove` 函数的内容。
- en: 'In the `onmousemove` function, we do a couple of different things. The first
    thing we always need to do is convert the mouse position to a position in 3D space
    and create `THREE.Raycaster` for that position:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onmousemove` 函数中，我们做了几件事情。我们首先需要做的第一件事是将鼠标位置转换为 3D 空间中的位置，并为此位置创建 `THREE.Raycaster`：
- en: '[PRE43]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, we can use `THREE.Raycaster` to select objects that are the position
    of our mouse.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用 `THREE.Raycaster` 来选择鼠标位置的物体。
- en: 'The next step is to either drag an object around if we''ve already clicked
    on one (see steps 7, 8, and 9 for more details on this), or reposition the plane
    we created in step 2:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是，如果我们已经点击了一个对象，就拖动它（有关此操作的更多详细信息，请参阅步骤 7、8 和 9），或者重新定位我们在步骤 2 中创建的平面：
- en: '[PRE44]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If we've selected an object and are dragging it around, we set the position
    of that object based on the position where the ray cast from our mouse intersects
    the invisible helper plane using the offset that we calculate in step 9\. If we
    aren't dragging an object around, and using our ray we determine that we intersect
    one of the cubes, we move our helper `plane` object to the position of that object
    and make sure the plane faces the camera (`plane.lookAt(camera.position)`). The
    object, if we select it, will move alongside this helper `plane` object.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们已选择一个对象并在其周围拖动，我们根据从鼠标发出的射线与不可见的辅助平面相交的位置设置该对象的位置，使用我们在步骤 9 中计算的偏移量。如果我们没有拖动对象，并且使用我们的射线确定我们与其中一个立方体相交，我们将我们的辅助
    `plane` 对象移动到该对象的位置，并确保平面面向相机 (`plane.lookAt(camera.position)`)。如果选择了对象，它将沿着这个辅助
    `plane` 对象移动。
- en: 'Next, we need to define a function to handle the `onmousedown` events:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个函数来处理 `onmousedown` 事件：
- en: '[PRE45]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s look at what to fill in for the `onmousedown` event:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `onmousedown` 事件应该填写什么：
- en: '[PRE46]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We once again use `THREE.Raycaster` to determine whether an object intersects
    with a ray cast from the position of our mouse.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次使用 `THREE.Raycaster` 来确定一个对象是否与从鼠标位置发出的射线相交。
- en: 'Now that we know the intersects, we can use them to select the object we''re
    interested in:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了相交点，我们可以使用它们来选择我们感兴趣的对象：
- en: '[PRE47]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see in this snippet, we first disable the `orbit` controller (as
    we want to drag the object around and not rotate the scene). Next, we assign the
    first intersected object to the `selectedObject` variable, which we used in step
    6 to move the selected cube around. Finally, we need to determine the offset between
    the point where we clicked and the center of the plane. We need this to correctly
    position the cube in step 6.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您在这段代码片段中看到的，我们首先禁用了 `orbit` 控制器（因为我们想拖动对象而不是旋转场景）。接下来，我们将第一个相交的对象分配给 `selectedObject`
    变量，我们在步骤 6 中使用它来移动选定的立方体。最后，我们需要确定我们点击的点与平面中心的偏移量。我们需要这个偏移量来在步骤 6 中正确地定位立方体。
- en: 'The last step we need to take is to enable the orbit controller when we release
    the mouse button and set the `selectedObject` property back to null:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是在释放鼠标按钮时启用轨道控制器，并将 `selectedObject` 属性设置回 null：
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, there are plenty of steps you need to take to implement this
    recipe. You can also look at the sources from `07.08-drag-n-drop-object-around-scene.html`,
    which also contain inline documentation about why certain steps are needed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您需要采取许多步骤来实现这个食谱。您还可以查看来自 `07.08-drag-n-drop-object-around-scene.html`
    的源代码，其中也包含有关为什么需要某些步骤的内置文档。
- en: There's more…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: This recipe was based on the example from the Three.js website, which you can
    find at [http://threejs.org/examples/#webgl_interactive_draggablecubes](http://threejs.org/examples/#webgl_interactive_draggablecubes).
    So, for another example to play around with, you can look at that implementation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例基于Three.js网站上的示例，您可以在[http://threejs.org/examples/#webgl_interactive_draggablecubes](http://threejs.org/examples/#webgl_interactive_draggablecubes)找到。因此，如果您想尝试另一个示例，可以查看该实现。
- en: In this recipe, we showed you how you can move the complete mesh around. You
    can also use this same approach to move individual vertices, faces, or lines around.
    So, with a little bit of effort, you can use this approach to create a kind of
    sculpting tool with which you could directly modify a geometry from your browser.
    For instance, you could create something like this [http://stephaneginier.com/sculptgl/](http://stephaneginier.com/sculptgl/).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们向您展示了如何移动整个网格。您也可以使用相同的方法来移动单个顶点、面或线。因此，只需稍加努力，您就可以使用这种方法创建一种雕刻工具，可以直接从浏览器中修改几何形状。例如，您可以创建类似这样的东西
    [http://stephaneginier.com/sculptgl/](http://stephaneginier.com/sculptgl/)。
- en: See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In this chapter, we also use `THREE.Raycaster` for the *Adding simple collision
    detection* recipe. If you want to drag and drop external files onto your Three.js
    scene, you can refer to the *Dragging a file from the desktop to the scene* recipe
    in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们还使用`THREE.Raycaster`为“添加简单碰撞检测”示例。如果您想将外部文件拖放到Three.js场景中，您可以参考[第1章](ch01.html
    "第1章。入门")中的“从桌面拖动文件到场景”示例，*入门*。
- en: Adding a physics engine
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加物理引擎
- en: In the recipes so far, we've added animations and detection collisions to the
    scene manually. In this recipe, we'll show you how to use an external physics
    engine to add gravity, collision detection, and other physics effects to your
    scene.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们手动添加了动画和检测碰撞到场景中。在这个示例中，我们将向您展示如何使用外部物理引擎添加重力、碰撞检测和其他物理效果到您的场景中。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need to use a couple of external libraries. At the top
    of your HTML page, you have to add the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要使用几个外部库。在您的HTML页面顶部，您必须添加以下内容：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This library contains the main implementation of the physics engine. This library
    in itself uses two additional libraries that need to be provided. You first need
    to make sure the `ammo.js` library is stored in the same location as the `physi.js`
    library, and at the beginning of your JavaScript code, you should add this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含物理引擎的主要实现。该库本身使用两个额外的库，需要提供。您首先需要确保`ammo.js`库存储在与`physi.js`库相同的目录中，并在您的JavaScript代码开头添加以下内容：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This points to a web worker ([http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/))
    that handles the physics calculations in a separate thread. There is, of course,
    a ready-to-use example of this recipe that you can use as a reference or to experiment
    with. The example for this recipe is called `07.09-add-a-physics-engine.html`,
    and when this is opened in the browser you will see something similar to what
    is shown in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这指向一个Web Worker（[http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/）），它在一个单独的线程中处理物理计算。当然，这里有一个现成的示例，您可以将其用作参考或进行实验。这个示例的名称为`07.09-add-a-physics-engine.html`，当在浏览器中打开时，您将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_07_15.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_07_15.jpg)'
- en: In this example, you can use the **addCube** button to add cubes to the scene.
    This cube will be added high above the ground plane and will drop down. The physics
    engine will determine how the falling cube interacts with its environment.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以使用**添加立方体**按钮将立方体添加到场景中。这个立方体将被添加到地面平面之上，然后落下。物理引擎将确定下落的立方体如何与其环境交互。
- en: How to do it…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we only set up a basic physics-enabled scene. Refer to the
    *There''s more…* section of this recipe for additional functionality provided
    by the `Physijs` library. To create a basic scene, you need to take the following
    steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只设置了一个基本的物理启用场景。有关`Physijs`库提供的其他功能的详细信息，请参阅此示例的“更多内容…”部分。要创建一个基本场景，您需要执行以下步骤：
- en: 'The first thing to do is that instead of creating `THREE.Scene`, we''ll create
    `Physics.Scene`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的是，我们不会创建`THREE.Scene`，而是创建`Physics.Scene`：
- en: '[PRE51]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On this newly created scene, we also need to set the `gravity` property. In
    this case, we set a gravity of `-30` on the *y* axis, which means a scene where
    objects fall down.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个新创建的场景中，我们还需要设置`gravity`属性。在这种情况下，我们在*y*轴上设置了`-30`的重力，这意味着一个物体向下掉落的场景。
- en: 'Next, let''s create `THREE.Geometry` and `THREE.MeshLambertMaterial`, which
    we''ll use for the cubes:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`THREE.Geometry`和`THREE.MeshLambertMaterial`，我们将使用它们来创建立方体：
- en: '[PRE52]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There is nothing special to do in this step for `Physijs`.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个步骤中对于`Physijs`没有特殊的事情要做。
- en: 'The next step is to create a mesh object. For objects to work with `Physijs`,
    we need to create a `Physijs` library specific mesh and a `Physijs` library specific
    material:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个网格对象。为了使对象能够与`Physijs`一起工作，我们需要创建一个`Physijs`库特定的网格和一个`Physijs`库特定的材料：
- en: '[PRE53]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For the material, we use the `Physijs.createMaterial` function. This wraps our
    material created in step 2 and allows us to define the friction and restitution
    properties. The friction defines the roughness of the object and affects how far
    it can slide over another object. The `restitution` object is used for the bounciness
    of an object. To create a mesh, we use the `Physijs.BoxMesh` object, provide the
    geometry and the material we just created, and also add the weight of the object.
    `Physijs` provides differently shaped meshes; for more information on them, refer
    to the *There's more…* section of this recipe.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于材料，我们使用`Physijs.createMaterial`函数。这个函数包裹我们在第2步中创建的材料，并允许我们定义摩擦和恢复属性。摩擦定义了物体的粗糙度，并影响它可以在另一个物体上滑动的距离。`restitution`对象用于定义物体的弹性。为了创建网格，我们使用`Physijs.BoxMesh`对象，提供我们刚刚创建的几何形状和材料，并添加对象的重量。`Physijs`提供了不同形状的网格；有关它们的信息，请参阅本配方中的*更多内容…*部分。
- en: 'The final step we need to take is to update the `render` loop:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是更新`render`循环：
- en: '[PRE54]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we add the `scene.simulate` function. This is used to calculate the new
    positions of all the objects that have been wrapped in a `Physijs` library specific
    mesh.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`scene.simulate`函数。这个函数用于计算所有被包裹在`Physijs`库特定网格中的对象的新的位置。
- en: With these basic steps, you've got a fully working physics-enabled Three.js
    scene. An important aspect to take into account when using this engine is that
    there is a hit on performance. For each object of the scene, `Physijs` will need
    to calculate its next position and rotation. This works great for tens of objects,
    but you'll see a severe hit when working with hundreds of Physijs-managed objects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基本步骤，你已经得到了一个完全工作的具有物理功能的Three.js场景。在使用这个引擎时需要考虑的一个重要方面是性能会有所下降。对于场景中的每个对象，`Physijs`都需要计算其下一个位置和旋转。这对于几十个对象来说效果很好，但当你处理数百个由Physijs管理的对象时，你会看到性能的严重下降。
- en: How it works…
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We call `scene.simulate()`, which we added to the `render` loop in step 4, for
    each frame that is rendered. When this function is called, `Physijs` will look
    at all the objects it knows about, and it also looks at the gravity configured
    on the scene and will use that information to calculate new positions and rotations
    for each object if collisions between objects occur. it will use the `friction`
    and `restitution` properties of the `Physijs` material and the weight function
    of an object to determine how that object and the one it collides with should
    react. This is repeated in each `render` loop and gives the simulation of real
    physics in the scene.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`scene.simulate()`，这是我们在第4步中添加到`render`循环中的，对于每个渲染的帧。当这个函数被调用时，`Physijs`将查看它所知道的所有对象，并且它还会查看场景上配置的重力，并将使用这些信息来计算每个对象的新位置和旋转。如果发生对象之间的碰撞，它将使用`Physijs`材料的`friction`和`restitution`属性以及对象的重量函数来确定该对象和与之碰撞的对象应该如何反应。这将在每个`render`循环中重复，从而在场景中模拟真实的物理效果。
- en: There's more…
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'What we''ve done in this recipe is only a very small part of what is possible
    with this physics engine. You can find more information on the Physijs website
    at [http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/).
    Interesting subjects from that site are:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中我们所做的是这个物理引擎可能实现的一小部分。你可以在Physijs网站上找到更多信息：[http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/)。该网站上的有趣主题包括：
- en: 'Support for different object shapes: [https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes](https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同对象形状：[https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes](https://github.com/chandlerprall/Physijs/wiki/Basic-Shapes)。
- en: How to add constraints to your object. This makes it possible to constrain the
    movement of an object around an axis (like a slider), a joint, or even another
    object. More information on this feature can be found at [https://github.com/chandlerprall/Physijs/wiki/Constraints](https://github.com/chandlerprall/Physijs/wiki/Constraints).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为你的对象添加约束。这使得你可以约束对象围绕一个轴（如滑块）、一个关节，甚至另一个对象的运动。关于这个特性的更多信息可以在[https://github.com/chandlerprall/Physijs/wiki/Constraints](https://github.com/chandlerprall/Physijs/wiki/Constraints)找到。
- en: Physijs uses an external physics library for all the calculations. For more
    information on that engine, look at the ammo.js website ([https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/)).
    Note that ammo.js itself is a JavaScript port of the Bullet physics engine. So,
    if you really want to dive into the details, you should look at the Bullet documentation
    that can be found at [http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Physijs使用外部物理库进行所有计算。关于该引擎的更多信息，请查看ammo.js网站([https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/))。注意，ammo.js本身是Bullet物理引擎的JavaScript端口。所以，如果你真的想深入了解细节，你应该查看可以在[http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/)找到的Bullet文档。
- en: See also
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you don't want to include a complete physics engine inside your project,
    you can also simulate parts of a physics engine yourself. How to add basic collision
    detection to your scene is explained in the *Adding a simple collision detection*
    recipe.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想在你的项目中包含完整的物理引擎，你也可以自己模拟物理引擎的部分。如何在场景中添加基本的碰撞检测在*添加简单的碰撞检测*菜谱中有解释。
