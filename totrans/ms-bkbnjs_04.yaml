- en: Chapter 4. Modular Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 模块化代码
- en: As your project's code grows, the number of scripts in the project will be more
    and more, incrementing script-loading complexity. The classic way to load JavaScript
    files is to write a`<script>` tags for every script you have, but you have to
    do it in the right order; if you don't, your code could stop working. That's not
    an efficient way for medium-size projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你项目代码的增长，项目中的脚本数量会越来越多，脚本加载的复杂性也会不断增加。经典的加载JavaScript文件的方式是为每个脚本编写一个`<script>`标签，但你必须按照正确的顺序执行；如果不这样做，你的代码可能会停止工作。这不是中型项目的一个高效方式。
- en: What happens if you forget the order of loading? What if you make a refactorization
    on the code and the order of the script changes? It will be a pain to fix it and
    keep track of all the code and its dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了加载顺序会发生什么？如果你对代码进行了重构并且脚本顺序发生了变化呢？修复它并跟踪所有代码及其依赖项将会很痛苦。
- en: This problem has been addressed in different ways. One is to create a module
    syntax to create, load, and declare explicitly the dependencies of modules; the
    syntax is called **AMD** (**Asynchronous Module Definition**). The AMD modules
    define a list of module dependencies, and the code inside the module will be executed
    only after the dependencies are fully loaded.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题已经以不同的方式得到了解决。一种方法是通过创建模块语法来创建、加载和明确声明模块的依赖项；这种语法被称为**AMD**（**异步模块定义**）。AMD模块定义了一个模块依赖项列表，模块内部的代码只有在依赖项完全加载后才会执行。
- en: The dependencies are loaded asynchronously; that means that you don't need to
    load all the scripts in the HTML page through `<script>` tags. AMD modules are
    better than plain JavaScript because they define dependencies explicitly and can
    be loaded automatically.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项是异步加载的；这意味着你不需要通过`<script>`标签在HTML页面中加载所有脚本。AMD模块比纯JavaScript更好，因为它们明确地定义了依赖项，并且可以自动加载。
- en: Although AMD modules are better than `<script>` tags, working with AMD modules
    can be a pain when unit testing comes in because you need to know the intricacies
    of how the library loads the modules; when you want to do unit testing, you need
    to isolate the pieces of code under test, but is hard to do it in RequireJS, and
    even if you do it the result can be buggy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AMD模块比`<script>`标签更优越，但在进行单元测试时，与AMD模块一起工作可能会很痛苦，因为你需要了解库如何加载模块的细节；当你想要进行单元测试时，你需要隔离待测试的代码片段，但在RequireJS中很难做到，即使你做到了，结果也可能存在bug。
- en: Recently another module loader and dependency manager has arrived; Browserify
    seems to be the most popular at the moment. However, it is not the only one; there
    are many other potentially strong choices such as jspm and steal.js.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，另一个模块加载器和依赖项管理器出现了；Browserify似乎是目前最受欢迎的。然而，它并不是唯一的；还有许多其他潜在的选择，如jspm和steal.js。
- en: In this book, we will work with Browserify because of its popularity, so you
    can find a lot of information and documentation about it on the Web; another good
    reason is that many projects have been built with it, which demonstrates its maturity
    and that it's production-ready. Browserify uses the same Node module syntax to
    define modules and dependencies, so that if you already know about Node you can
    go directly to the Browserify section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Browserify，因为它很受欢迎，因此你可以在网上找到大量关于它的信息和文档；另一个好理由是，许多项目都是用它构建的，这证明了它的成熟度和生产就绪状态。Browserify使用与Node模块相同的语法来定义模块和依赖项，所以如果你已经了解Node，你可以直接进入Browserify部分。
- en: CommonJS modules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS模块
- en: In recent years, Node has been gaining popularity in the software industry;
    indeed it is becoming a very popular choice for backend development in a full
    JavaScript technology stack. If you don't know about Node, you can think about
    it as JavaScript used in the server instead of a browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Node在软件行业中的受欢迎程度一直在上升；确实，它正在成为全JavaScript技术栈中后端开发的非常受欢迎的选择。如果你不了解Node，你可以将其视为在服务器上而不是在浏览器中使用的JavaScript。
- en: Node uses the CommonJS module syntax for its modules; a CommonJS module is a
    file that exports a single value to be used for other modules. It is useful to
    use CommonJS because it provides a clean way to manage JavaScript modules and
    dependencies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node使用CommonJS模块语法来定义其模块；一个CommonJS模块是一个导出一个单一值以供其他模块使用的文件。使用CommonJS是有用的，因为它提供了一种管理JavaScript模块和依赖项的清晰方式。
- en: To support CommonJS, Node uses the `require()` function. With `require()` you
    can load JavaScript files without the need to use `<script>` tags, instead calling
    `require()` with the name of the module/dependency that you need and assigning
    it to a variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 CommonJS，Node 使用 `require()` 函数。使用 `require()`，您可以在不使用 `<script>` 标签的情况下加载
    JavaScript 文件，而是通过调用 `require()` 并将所需的模块/依赖项的名称传递给它，并将其分配给一个变量。
- en: 'To illustrate how CommonJS modules work, let''s write a Node module and see
    how to use the `require()` function. The following code shows a simple module
    that exposes a simple object with the method `sayHello()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 CommonJS 模块的工作原理，让我们编写一个 Node 模块并看看如何使用 `require()` 函数。以下代码展示了一个简单的模块，它暴露了一个具有
    `sayHello()` 方法的简单对象：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This script can be placed in a file named `hello.js`, for example. The hello
    module can be loaded from another module by calling the `require()` function,
    as shown in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可以放置在名为 `hello.js` 的文件中，例如。hello 模块可以通过调用 `require()` 函数从另一个模块中加载，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we require a script with the `require()` function we don't need to add
    the .js extension, Node will do it for us automatically. Note that, if you add
    the extension to the script name, Node will add the extension anyway and you will
    get an error because the `hello.js.js` file does not exist.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `require()` 函数调用脚本时，我们不需要添加 .js 扩展名，Node 会自动为我们添加。请注意，如果您向脚本名称添加扩展名，Node
    仍然会添加扩展名，并且您将收到错误，因为 `hello.js.js` 文件不存在。
- en: 'That''s the way you can define CommonJS modules for your projects: we just
    export the variable that we want to expose to the outside of the module with `module.exports`
    and then load the module where needed with `require()`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以为项目定义 CommonJS 模块的方法：我们只需使用 `module.exports` 导出我们想要暴露给模块外部的变量，然后在需要的地方使用
    `require()` 加载模块。
- en: CommonJS modules are singletons, which means that every time you load a module
    you will get the same instance of the object. Node will cache the returned value
    when it's called for the first time and will reuse it for the next calls.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 模块是单例，这意味着每次您加载一个模块时，您都会得到该对象的相同实例。Node 在第一次调用时将缓存返回的值，并在后续调用中重用它。
- en: NPM and package.json
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM 和 package.json
- en: With Browserify, we can create CommonJS modules that can be executed in the
    browser. When you use CommonJS modules in the browser, Browserify will provide
    the necessary tools to load the modules, which includes a definition for the `require()`
    function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Browserify，我们可以创建可以在浏览器中执行的 CommonJS 模块。当您在浏览器中使用 CommonJS 模块时，Browserify
    将提供必要的工具来加载模块，包括 `require()` 函数的定义。
- en: When you use Browserify, you can use the Node package manager to install and
    define dependencies for your projects. A useful tool is the npm command tool,
    used to install and manage project dependencies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Browserify 时，您可以使用 Node 包管理器为您的项目安装和定义依赖项。一个有用的工具是 npm 命令行工具，用于安装和管理项目依赖项。
- en: The `package.json` file in a Node project is a JSON file used to define, install,
    and manage the version of the libraries that your project depends on. A `package.json`
    file can contain many configuration options; you can see the complete documentation
    on the Node website at [https://docs.npmjs.com/](https://docs.npmjs.com/). Here
    is a list of the main values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node 项目中的 `package.json` 文件是一个 JSON 文件，用于定义、安装和管理项目依赖项的版本。`package.json` 文件可以包含许多配置选项；您可以在
    Node 网站上查看完整的文档，网址为 [https://docs.npmjs.com/](https://docs.npmjs.com/)。以下是主要值的列表。
- en: '`Name` – The name of the project without spaces'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name` – 项目名称，不带空格'
- en: '`Description` – A short description of the project'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description` – 项目的简短描述'
- en: '`Version` – A version number for the project, typically starting with 0.0.1'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version` – 项目的版本号，通常以 0.0.1 开头'
- en: '`Dependencies` – A list of libraries with the version number that the project
    depends on'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dependencies` – 项目依赖的库及其版本号的列表'
- en: '`devDependencies` – Same as dependencies, but this list is used only for development
    environments—useful for putting libraries for testing, for instance'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies` – 与 `dependencies` 相同，但这个列表仅用于开发环境——例如，用于放置测试库'
- en: '`licence` – A license name for the project code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`licence` – 项目代码的许可证名称'
- en: 'We can start with a very simple `package.json` file that contains only some
    basic fields, and then we can extend it as needed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个非常简单的 `package.json` 文件开始，该文件仅包含一些基本字段，然后根据需要扩展它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we don''t have any dependency yet. We can install our first
    dependency with `npm`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们目前还没有任何依赖。我们可以使用 `npm` 安装我们的第一个依赖项：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will install the basic dependencies to work with `backbone`; the
    save flag will update automatically the `package.json` file, adding the library
    names and its current versions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装与 `backbone` 一起工作的基本依赖项；保存标志将自动更新 `package.json` 文件，添加库的名称及其当前版本：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The format of the library version follows the `semver` standard; you can see
    more about this format in the official `semver` website.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 库版本格式遵循 `semver` 标准；你可以在官方 `semver` 网站上了解更多关于此格式的信息。
- en: 'One advantage of using the `package.json` file in your project is that, the
    next time you want to install the dependencies, you don''t need to remember the
    libraries and their versions; you can just hit **Install** without any argument
    and Node will read the `package.json` file and make the installs for you:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中使用 `package.json` 文件的一个优点是，下次你想安装依赖项时，你不需要记住库及其版本；你只需不带任何参数点击 **安装**，Node
    就会读取 `package.json` 文件并为你进行安装：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `npm` you can install development packages such as the mocha testing library,
    but instead of using the save flag use `save-dev`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm` 你可以安装开发包，例如 mocha 测试库，但不要使用保存标志，而是使用 `save-dev`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you know how to install dependencies and save them in the `package.json`
    file, we can start using Browserify in the Contacts app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何安装依赖项并将它们保存在 `package.json` 文件中，我们就可以开始在联系人应用中使用 Browserify 了。
- en: Browserify
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Browserify
- en: With Browserify we can use Node modules directly in the browser. This means
    that you can build your projects with the power of the npm package manager and
    the Node module syntax exposed in the previous sections. Then Browserify can take
    your source code and apply some transformations to be able to run your code in
    the browser environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Browserify，我们可以在浏览器中直接使用 Node 模块。这意味着你可以利用 npm 包管理器和在前几节中暴露的 Node 模块语法来构建你的项目。然后
    Browserify 可以将你的源代码进行一些转换，以便能够在浏览器环境中运行你的代码。
- en: 'A very simple module that exposes an object with a method that prints a hello
    message can be written as a Node module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的模块，它暴露了一个带有打印问候消息的方法的对象，可以写成 Node 模块的形式：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simple piece of code can be loaded from another script as shown next:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码可以从另一个脚本中加载，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code works perfectly with Node. You can run it as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 Node 完美兼容。你可以按照以下方式运行它：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However this code will not run in the browser because the `require` function
    and the module object are not defined. Browserify takes your project entry code
    and tracks all the dependencies to create a single file with all the scripts concatenated:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码在浏览器中无法运行，因为 `require` 函数和模块对象未定义。Browserify 会跟踪你的项目入口代码中的所有依赖项，创建一个包含所有脚本的单一文件：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Browserify](img/B01962_04_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Browserify](img/B01962_04_01.jpg)'
- en: Figure 4.1 Bundling with Browserify
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 使用 Browserify 打包
- en: Note that our code is still in there; Browserify makes the definition of the
    missing objects and concatenates all the script in a single file. Figure 4.1 shows
    a graphical representation of what happens. If you use libraries such as Backbone,
    then your final script will contain all the Backbone code in the output file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的代码仍然在其中；Browserify 会定义缺失的对象并将所有脚本合并到一个文件中。图 4.1 显示了发生的图形表示。如果你使用像 Backbone
    这样的库，那么你的最终脚本将包含输出文件中的所有 Backbone 代码。
- en: 'To tell Browserify that you want to create a file instead of just putting the
    result in the standard output, use the `-o` flag:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉 Browserify 你想要创建一个文件而不是仅仅将结果输出到标准输出，请使用 `-o` 标志：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That will create an app.js file with the contents of the `hello.js` and `main.js`
    files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含 `hello.js` 和 `main.js` 文件内容的 `app.js` 文件。
- en: Application dependency
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序依赖
- en: When the application is loaded in the browser, it loads all the JavaScript files
    in a specific order. The order is important because it represents the chain of
    dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在浏览器中加载时，它会按特定顺序加载所有 JavaScript 文件。顺序很重要，因为它代表了依赖链。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the standard way of script loading; the browser is responsible to parse
    these script tags, fetch the script files from the assets server, and then execute
    them in that order. So that the Browser will execute jQuery, then Bootstrap, then
    Underscore and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种标准的脚本加载方式；浏览器负责解析这些脚本标签，从资产服务器获取脚本文件，然后按顺序执行它们。因此，浏览器将首先执行 jQuery，然后是 Bootstrap，然后是
    Underscore，依此类推。
- en: As you know, Backbone depends on Underscore and jQuery to work; it uses jQuery
    to handle DOM selections in Backbone views and Underscore as the utility library.
    For this reason, jQuery and Underscore should be loaded before Backbone.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Backbone 依赖于 Underscore 和 jQuery 来工作；它在 Backbone 视图中使用 jQuery 来处理 DOM 选择，并使用
    Underscore 作为工具库。因此，jQuery 和 Underscore 应该在 Backbone 之前加载。
- en: In the project code, `app.js` depends on Backbone, so that it's loaded after
    Backbone. The `apps/contacts/app.js` module is the application façade. It depends
    on all the other modules in the subapplications, which is why it's loaded last.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目代码中，`app.js` 依赖于 Backbone，因此它在 Backbone 之后加载。`apps/contacts/app.js` 模块是应用程序外观。它依赖于子应用程序中的所有其他模块，这就是为什么它最后加载的原因。
- en: Figure 4.2 shows the dependency of the modules graphically. Note that it's a
    simplification and not all the dependencies are shown.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 以图形方式显示了模块的依赖关系。请注意，这是一个简化，并不是所有的依赖关系都显示出来。
- en: '![Application dependency](img/B01962_04_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序依赖关系](img/B01962_04_02.jpg)'
- en: Figure 4.2 Dependency graph
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 依赖关系图
- en: Using Browserify in the app
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中使用 Browserify
- en: Until now we have learned about what Browserify is and how to use it. Now we
    will apply that background to our contacts app to load all the code as Node modules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 Browserify 是什么以及如何使用它。现在，我们将把这个背景应用到我们的联系人应用程序中，以将所有代码作为 Node
    模块加载。
- en: 'Before we continue, ensure that you have installed all the required dependencies
    for the project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请确保您已安装了项目所需的所有依赖项：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The easiest modules to convert are Models and Collections because they don't
    have huge dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易转换的模块是模型和集合，因为它们没有巨大的依赖关系。
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, the module remains almost the same. We have just added the
    `require()` calls and the export statement at the end of the file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模块几乎保持不变。我们只是在文件的末尾添加了 `require()` 调用和导出语句：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Views are easy to convert, too. We just have to add the `require()` calls as
    we did with the `Contact` and `ContactCollection` modules. Before we continue,
    we need an extra step with the views; currently all the views for a given controller
    are contained in a single script; `contactEditor.js` for example contains `ContactForm`,
    `ContactPreview`, and `PhoneList`, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 视图也容易转换。我们只需像对 `Contact` 和 `ContactCollection` 模块所做的那样添加 `require()` 调用。在我们继续之前，我们需要对视图进行一个额外的步骤；目前，给定控制器的所有视图都包含在一个单独的脚本中；例如，`contactEditor.js`
    包含 `ContactForm`、`ContactPreview` 和 `PhoneList` 等。
- en: 'As we are modularizing the project, it''s a good idea to put each view in its
    own file and require it when we need it. The following shows this idea. You have
    many good reasons to do this: to isolate your components for testing, to keep
    your files small, to improve maintenance, and to get interchangeable modules.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在模块化项目，将每个视图放入其自己的文件并在需要时调用它是一个好主意。以下展示了这个想法。你有很多理由这样做：为了隔离你的组件进行测试、保持你的文件小、提高维护性以及获得可互换的模块。
- en: '![Using Browserify in the app](img/B01962_04_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![在应用程序中使用 Browserify](img/B01962_04_03.jpg)'
- en: Figure 4.3 Splitting views to their own files
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 将视图分割到它们自己的文件中
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the conversion of plain JavaScript files to Node modules is
    very easy to do. The code of the business logic is exactly the same. The subapplication
    controller depends on the views that we have converted on the previous step.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将纯 JavaScript 文件转换为 Node 模块非常容易。业务逻辑的代码完全相同。子应用程序控制器依赖于我们在上一步中转换的视图。
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The application façade depends on many subapplication controllers, the models,
    and the collections:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序外观依赖于许多子应用程序控制器、模型和集合：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The routers depend on the subapplication façade and the application infrastructure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 路由依赖于子应用程序外观和应用程序基础设施：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The App object is responsible for loading all the subapplication routers and
    then starting the history module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: App 对象负责加载所有子应用程序路由并启动历史模块：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to start the application by calling the `start()` method on
    the App object; this is done from the `index.html` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过在 App 对象上调用 `start()` 方法来启动应用程序；这是从 `index.html` 文件中完成的：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we are re-packing the application with Browserify, it''s better to create
    a new file to the main entry point:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 Browserify 重新打包应用程序，最好在主入口点创建一个新文件：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once our application is written as Node modules, we can use Browserify to bundle
    the code in a single script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序被编写为 Node 模块，我们就可以使用 Browserify 将代码打包成一个单独的脚本：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will create a bundled file with all the dependencies on it. To use the
    bundled version of the code, we have to change the `index.htm` file to load it
    instead of loading all the individual files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含所有依赖项的打包文件。为了使用代码的打包版本，我们必须将 `index.htm` 文件更改为加载它，而不是加载所有单个文件：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That should be enough; however, the application won't start because we have
    a cyclic dependency issue.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够了；然而，应用程序不会启动，因为我们有一个循环依赖问题。
- en: Solving cyclic dependency
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决循环依赖
- en: Having two modules that depend on each other is called **cyclic dependency**.
    In our Contacts application, the infrastructure application depends on the subapplication
    routers, and the routers depend on the application infrastructure to load the
    subapplication controllers and facades. Figure 4.4 shows how this looks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个相互依赖的模块被称为 **循环依赖**。在我们的 Contacts 应用程序中，基础设施应用程序依赖于子应用程序路由器，而路由器依赖于应用程序基础设施来加载子应用程序控制器和外观。图
    4.4 显示了这是如何表现的。
- en: '![Solving cyclic dependency](img/B01962_04_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![解决循环依赖](img/B01962_04_04.jpg)'
- en: Figure 4.4 Cyclic dependencies
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 循环依赖
- en: It is not possible to run the application properly because of the cyclic dependency.
    Here is what happens in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环依赖，无法正确运行应用程序。以下是详细情况。
- en: The App module is executed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块被执行
- en: 'The App requires `ContactsRouter`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '应用程序需要 `ContactsRouter`:'
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ContactsRouter` requires the App module but the App module is not exported
    yet:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContactsRouter` 需要应用程序模块，但应用程序模块尚未导出：'
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ContactsRouter` receives an `undefined` value for the App variable'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContactsRouter` 为 `App` 变量接收一个 `undefined` 值'
- en: 'The App module continue the execution and finally exposes the App value:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块继续执行并最终暴露 `App` 值：
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`ContactsRouter` matches a route, but as the App value is undefined it triggers
    an error:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContactsRouter` 匹配一个路由，但由于 `App` 值未定义，它触发了错误：'
- en: '[PRE28]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should break the cycle in some way. An easy approach to do it is to require
    the App module after it is exported. Instead of requiring the `App` module from
    `ContactsRouter` on top of the file, we can do it only when it''s necessary:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该以某种方式打破循环。一个简单的方法是在导出 `App` 模块之后要求它。我们可以在文件顶部从 `ContactsRouter` 中要求 `App`
    模块，而不是在必要时才这样做：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a simple but effective way to break a cyclic dependency. Now you can
    re-bundle the application and run the application again. It should work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单但有效的方法来打破循环依赖。现在你可以重新打包应用程序并再次运行它。应该可以工作：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Modularizing templates
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化模板
- en: Until now, templates have been declared as script tags in the `index.html` file.
    While this is a good approach for small projects, it is not a good idea to put
    all your templates directly in the HTML file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，模板已经在 `index.html` 文件中声明为脚本标签。虽然这对于小型项目来说是一个好方法，但将所有模板直接放入HTML文件中并不是一个好主意。
- en: With Browserify, you can extract all your template files into individual files,
    with the advantage of modularization and a cleaner `index.html` file. Another
    benefit of modularizing templates is that you can pre-compile all the templates,
    saving resources in your users' browsers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Browserify，你可以将所有模板文件提取到单独的文件中，具有模块化和更干净的 `index.html` 文件的优势。模块化模板的另一个好处是，你可以预编译所有模板，从而在用户的浏览器中节省资源。
- en: 'With Browserify, you can modularize almost any template format: jade, Handlebars,
    Underscore, and so on. It uses a transformation process described in Figure 4.5\.
    If you have worked with other bundler tools such as webpack, transformations are
    analogous to pre-processors.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Browserify，你可以模块化几乎任何模板格式：jade、Handlebars、Underscore 等。它使用图 4.5 中描述的转换过程。如果你使用过其他打包工具，如
    webpack，转换类似于预处理器。
- en: '![Modularizing templates](img/B01962_04_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![模块化模板](img/B01962_04_05.jpg)'
- en: Figure 4.5 The transformation process
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 转换过程
- en: 'Templates are in plain text; the text is passed to a function that compiles
    it into a JavaScript function that Browserify can process as a regular JavaScript
    file. To apply the necessary transformation to the templates, you will need to
    install a transformation plugin:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是纯文本；文本被传递到一个函数中，该函数将其编译成一个浏览器ify可以处理的JavaScript函数，作为一个常规JavaScript文件。为了对模板应用必要的转换，你需要安装一个转换插件：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The transformation process take place when you instruct webpack to use jstify
    at compilation time:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程发生在你指示 webpack 在编译时使用 jstify 时：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Templates are easy to modularize; just extract the text in the script tags
    and put it in a new file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模板很容易模块化；只需提取脚本标签中的文本并将其放入新文件中：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `contactListLayout.tpl` now contains the text of the layout template for
    the contact list. In the `ContactListLayout` view you can import the template
    as a regular JavaScript file but do not forget to include the `tpl` extension:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`contactListLayout.tpl` 现在包含联系列表布局模板的文本。在 `ContactListLayout` 视图中，你可以将模板作为常规
    JavaScript 文件导入，但不要忘记包含 `tpl` 扩展名：'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you import the template, you will use a function. Because our common views
    support both CSS selectors and pre-compiled templates it should work properly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入模板时，你会使用一个函数。因为我们的通用视图同时支持 CSS 选择器和预编译模板，所以它应该可以正常工作：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now you have a fully modularized project where each piece of code is in a small
    file; one advantage of this is that you can focus on small chunks of code instead
    and avoid the overhead of large files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个完全模块化的项目，其中每个代码片段都在一个小文件中；这个优势之一是你可以专注于小块代码，从而避免大型文件的开销。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned what Browserify is and how you can organize
    your projects into Node modules to manage your code and dependencies in a cleaner
    way. To make the Contacts project compatible with `npm`, we had to alter the code
    of the project; however, the changes are minimal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Browserify 是什么以及如何将你的项目组织成 Node 模块，以便以更整洁的方式管理你的代码和依赖。为了使 Contacts
    项目与 `npm` 兼容，我们不得不修改项目的代码；然而，这些更改非常小。
- en: There are other alternatives to Browserify, too; require.js and the AMD module
    definition are good to work with. However testing with require.js could be very
    difficult; I don't recommend you use `require.js` if you want to test isolated
    modules (unit testing).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Browserify，还有其他替代方案；require.js 和 AMD 模块定义也是不错的选择。然而，使用 require.js 进行测试可能会非常困难；如果你想要测试独立的模块（单元测试），我不建议你使用
    `require.js`。
- en: Webpack is another popular choice to bundle and organize your code base. Its
    main purpose is to work with frontend dependencies; it can load CommonJS modules
    and AMD modules. However, webpack is more complicated to configure and manage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是捆绑和组织你的代码库的另一个流行选择。其主要目的是与前端依赖项一起工作；它可以加载 CommonJS 模块和 AMD 模块。然而，webpack
    的配置和管理更为复杂。
- en: Browserify is the most popular choice for bundling JavaScript projects and is
    easier to configure and maintain than webpack; it is useful to use the same tools
    that Node uses to manage its dependencies and it does a great job.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 是捆绑 JavaScript 项目的最受欢迎的选择，比 webpack 更容易配置和维护；使用 Node 用于管理其依赖项的相同工具是有用的，并且它做得很好。
- en: In the next chapter, we will explore how to deal with files in a Backbone project;
    handling files over a RESTful API is a common issue, so we will discover what
    the common patterns and strategies are.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 Backbone 项目中处理文件；通过 RESTful API 处理文件是一个常见问题，因此我们将发现常见的模式和策略。
- en: In Chapter 7, we will explore how to build applications with automation tools;
    instead of manually running the Browserify command each time we change the code,
    we will create the necessary scripts that will do it for us.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，我们将探讨如何使用自动化工具构建应用程序；每次我们更改代码时，我们不必手动运行 Browserify 命令，我们将创建必要的脚本来自动完成这项工作。
