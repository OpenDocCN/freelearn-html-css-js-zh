- en: Chapter 4. Modular Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 模块化代码
- en: As your project's code grows, the number of scripts in the project will be more
    and more, incrementing script-loading complexity. The classic way to load JavaScript
    files is to write a`<script>` tags for every script you have, but you have to
    do it in the right order; if you don't, your code could stop working. That's not
    an efficient way for medium-size projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你项目代码的增长，项目中的脚本数量会越来越多，脚本加载的复杂性也会不断增加。经典的加载JavaScript文件的方式是为每个脚本编写一个`<script>`标签，但你必须按照正确的顺序执行；如果不这样做，你的代码可能会停止工作。这不是中型项目的一个高效方式。
- en: What happens if you forget the order of loading? What if you make a refactorization
    on the code and the order of the script changes? It will be a pain to fix it and
    keep track of all the code and its dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了加载顺序会发生什么？如果你对代码进行了重构并且脚本顺序发生了变化呢？修复它并跟踪所有代码及其依赖项将会很痛苦。
- en: This problem has been addressed in different ways. One is to create a module
    syntax to create, load, and declare explicitly the dependencies of modules; the
    syntax is called **AMD** (**Asynchronous Module Definition**). The AMD modules
    define a list of module dependencies, and the code inside the module will be executed
    only after the dependencies are fully loaded.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题已经以不同的方式得到了解决。一种方法是通过创建模块语法来创建、加载和明确声明模块的依赖项；这种语法被称为**AMD**（**异步模块定义**）。AMD模块定义了一个模块依赖项列表，模块内部的代码只有在依赖项完全加载后才会执行。
- en: The dependencies are loaded asynchronously; that means that you don't need to
    load all the scripts in the HTML page through `<script>` tags. AMD modules are
    better than plain JavaScript because they define dependencies explicitly and can
    be loaded automatically.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项是异步加载的；这意味着你不需要通过`<script>`标签在HTML页面中加载所有脚本。AMD模块比纯JavaScript更好，因为它们明确地定义了依赖项，并且可以自动加载。
- en: Although AMD modules are better than `<script>` tags, working with AMD modules
    can be a pain when unit testing comes in because you need to know the intricacies
    of how the library loads the modules; when you want to do unit testing, you need
    to isolate the pieces of code under test, but is hard to do it in RequireJS, and
    even if you do it the result can be buggy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AMD模块比`<script>`标签更优越，但在进行单元测试时，与AMD模块一起工作可能会很痛苦，因为你需要了解库如何加载模块的细节；当你想要进行单元测试时，你需要隔离待测试的代码片段，但在RequireJS中很难做到，即使你做到了，结果也可能存在bug。
- en: Recently another module loader and dependency manager has arrived; Browserify
    seems to be the most popular at the moment. However, it is not the only one; there
    are many other potentially strong choices such as jspm and steal.js.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，另一个模块加载器和依赖项管理器出现了；Browserify似乎是目前最受欢迎的。然而，它并不是唯一的；还有许多其他潜在的选择，如jspm和steal.js。
- en: In this book, we will work with Browserify because of its popularity, so you
    can find a lot of information and documentation about it on the Web; another good
    reason is that many projects have been built with it, which demonstrates its maturity
    and that it's production-ready. Browserify uses the same Node module syntax to
    define modules and dependencies, so that if you already know about Node you can
    go directly to the Browserify section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Browserify，因为它很受欢迎，因此你可以在网上找到大量关于它的信息和文档；另一个好理由是，许多项目都是用它构建的，这证明了它的成熟度和生产就绪状态。Browserify使用与Node模块相同的语法来定义模块和依赖项，所以如果你已经了解Node，你可以直接进入Browserify部分。
- en: CommonJS modules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS模块
- en: In recent years, Node has been gaining popularity in the software industry;
    indeed it is becoming a very popular choice for backend development in a full
    JavaScript technology stack. If you don't know about Node, you can think about
    it as JavaScript used in the server instead of a browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Node在软件行业中的受欢迎程度一直在上升；确实，它正在成为全JavaScript技术栈中后端开发的非常受欢迎的选择。如果你不了解Node，你可以将其视为在服务器上而不是在浏览器中使用的JavaScript。
- en: Node uses the CommonJS module syntax for its modules; a CommonJS module is a
    file that exports a single value to be used for other modules. It is useful to
    use CommonJS because it provides a clean way to manage JavaScript modules and
    dependencies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node使用CommonJS模块语法来定义其模块；一个CommonJS模块是一个导出一个单一值以供其他模块使用的文件。使用CommonJS是有用的，因为它提供了一种管理JavaScript模块和依赖项的清晰方式。
- en: To support CommonJS, Node uses the `require()` function. With `require()` you
    can load JavaScript files without the need to use `<script>` tags, instead calling
    `require()` with the name of the module/dependency that you need and assigning
    it to a variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how CommonJS modules work, let''s write a Node module and see
    how to use the `require()` function. The following code shows a simple module
    that exposes a simple object with the method `sayHello()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This script can be placed in a file named `hello.js`, for example. The hello
    module can be loaded from another module by calling the `require()` function,
    as shown in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we require a script with the `require()` function we don't need to add
    the .js extension, Node will do it for us automatically. Note that, if you add
    the extension to the script name, Node will add the extension anyway and you will
    get an error because the `hello.js.js` file does not exist.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the way you can define CommonJS modules for your projects: we just
    export the variable that we want to expose to the outside of the module with `module.exports`
    and then load the module where needed with `require()`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules are singletons, which means that every time you load a module
    you will get the same instance of the object. Node will cache the returned value
    when it's called for the first time and will reuse it for the next calls.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: NPM and package.json
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Browserify, we can create CommonJS modules that can be executed in the
    browser. When you use CommonJS modules in the browser, Browserify will provide
    the necessary tools to load the modules, which includes a definition for the `require()`
    function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When you use Browserify, you can use the Node package manager to install and
    define dependencies for your projects. A useful tool is the npm command tool,
    used to install and manage project dependencies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The `package.json` file in a Node project is a JSON file used to define, install,
    and manage the version of the libraries that your project depends on. A `package.json`
    file can contain many configuration options; you can see the complete documentation
    on the Node website at [https://docs.npmjs.com/](https://docs.npmjs.com/). Here
    is a list of the main values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`Name` – The name of the project without spaces'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description` – A short description of the project'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Version` – A version number for the project, typically starting with 0.0.1'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dependencies` – A list of libraries with the version number that the project
    depends on'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies` – Same as dependencies, but this list is used only for development
    environments—useful for putting libraries for testing, for instance'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`licence` – A license name for the project code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can start with a very simple `package.json` file that contains only some
    basic fields, and then we can extend it as needed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we don''t have any dependency yet. We can install our first
    dependency with `npm`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will install the basic dependencies to work with `backbone`; the
    save flag will update automatically the `package.json` file, adding the library
    names and its current versions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The format of the library version follows the `semver` standard; you can see
    more about this format in the official `semver` website.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of using the `package.json` file in your project is that, the
    next time you want to install the dependencies, you don''t need to remember the
    libraries and their versions; you can just hit **Install** without any argument
    and Node will read the `package.json` file and make the installs for you:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `npm` you can install development packages such as the mocha testing library,
    but instead of using the save flag use `save-dev`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you know how to install dependencies and save them in the `package.json`
    file, we can start using Browserify in the Contacts app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Browserify
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Browserify we can use Node modules directly in the browser. This means
    that you can build your projects with the power of the npm package manager and
    the Node module syntax exposed in the previous sections. Then Browserify can take
    your source code and apply some transformations to be able to run your code in
    the browser environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple module that exposes an object with a method that prints a hello
    message can be written as a Node module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simple piece of code can be loaded from another script as shown next:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code works perfectly with Node. You can run it as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However this code will not run in the browser because the `require` function
    and the module object are not defined. Browserify takes your project entry code
    and tracks all the dependencies to create a single file with all the scripts concatenated:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Browserify](img/B01962_04_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 Bundling with Browserify
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Note that our code is still in there; Browserify makes the definition of the
    missing objects and concatenates all the script in a single file. Figure 4.1 shows
    a graphical representation of what happens. If you use libraries such as Backbone,
    then your final script will contain all the Backbone code in the output file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell Browserify that you want to create a file instead of just putting the
    result in the standard output, use the `-o` flag:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That will create an app.js file with the contents of the `hello.js` and `main.js`
    files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Application dependency
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application is loaded in the browser, it loads all the JavaScript files
    in a specific order. The order is important because it represents the chain of
    dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the standard way of script loading; the browser is responsible to parse
    these script tags, fetch the script files from the assets server, and then execute
    them in that order. So that the Browser will execute jQuery, then Bootstrap, then
    Underscore and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As you know, Backbone depends on Underscore and jQuery to work; it uses jQuery
    to handle DOM selections in Backbone views and Underscore as the utility library.
    For this reason, jQuery and Underscore should be loaded before Backbone.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In the project code, `app.js` depends on Backbone, so that it's loaded after
    Backbone. The `apps/contacts/app.js` module is the application façade. It depends
    on all the other modules in the subapplications, which is why it's loaded last.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 shows the dependency of the modules graphically. Note that it's a
    simplification and not all the dependencies are shown.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Application dependency](img/B01962_04_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 Dependency graph
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Using Browserify in the app
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now we have learned about what Browserify is and how to use it. Now we
    will apply that background to our contacts app to load all the code as Node modules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, ensure that you have installed all the required dependencies
    for the project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The easiest modules to convert are Models and Collections because they don't
    have huge dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, the module remains almost the same. We have just added the
    `require()` calls and the export statement at the end of the file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Views are easy to convert, too. We just have to add the `require()` calls as
    we did with the `Contact` and `ContactCollection` modules. Before we continue,
    we need an extra step with the views; currently all the views for a given controller
    are contained in a single script; `contactEditor.js` for example contains `ContactForm`,
    `ContactPreview`, and `PhoneList`, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are modularizing the project, it''s a good idea to put each view in its
    own file and require it when we need it. The following shows this idea. You have
    many good reasons to do this: to isolate your components for testing, to keep
    your files small, to improve maintenance, and to get interchangeable modules.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Browserify in the app](img/B01962_04_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 Splitting views to their own files
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the conversion of plain JavaScript files to Node modules is
    very easy to do. The code of the business logic is exactly the same. The subapplication
    controller depends on the views that we have converted on the previous step.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The application façade depends on many subapplication controllers, the models,
    and the collections:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The routers depend on the subapplication façade and the application infrastructure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The App object is responsible for loading all the subapplication routers and
    then starting the history module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to start the application by calling the `start()` method on
    the App object; this is done from the `index.html` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we are re-packing the application with Browserify, it''s better to create
    a new file to the main entry point:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once our application is written as Node modules, we can use Browserify to bundle
    the code in a single script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will create a bundled file with all the dependencies on it. To use the
    bundled version of the code, we have to change the `index.htm` file to load it
    instead of loading all the individual files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That should be enough; however, the application won't start because we have
    a cyclic dependency issue.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Solving cyclic dependency
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having two modules that depend on each other is called **cyclic dependency**.
    In our Contacts application, the infrastructure application depends on the subapplication
    routers, and the routers depend on the application infrastructure to load the
    subapplication controllers and facades. Figure 4.4 shows how this looks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving cyclic dependency](img/B01962_04_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 Cyclic dependencies
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to run the application properly because of the cyclic dependency.
    Here is what happens in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The App module is executed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App requires `ContactsRouter`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ContactsRouter` requires the App module but the App module is not exported
    yet:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ContactsRouter` receives an `undefined` value for the App variable'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App module continue the execution and finally exposes the App value:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`ContactsRouter` matches a route, but as the App value is undefined it triggers
    an error:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should break the cycle in some way. An easy approach to do it is to require
    the App module after it is exported. Instead of requiring the `App` module from
    `ContactsRouter` on top of the file, we can do it only when it''s necessary:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a simple but effective way to break a cyclic dependency. Now you can
    re-bundle the application and run the application again. It should work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Modularizing templates
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, templates have been declared as script tags in the `index.html` file.
    While this is a good approach for small projects, it is not a good idea to put
    all your templates directly in the HTML file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: With Browserify, you can extract all your template files into individual files,
    with the advantage of modularization and a cleaner `index.html` file. Another
    benefit of modularizing templates is that you can pre-compile all the templates,
    saving resources in your users' browsers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'With Browserify, you can modularize almost any template format: jade, Handlebars,
    Underscore, and so on. It uses a transformation process described in Figure 4.5\.
    If you have worked with other bundler tools such as webpack, transformations are
    analogous to pre-processors.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Modularizing templates](img/B01962_04_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 The transformation process
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates are in plain text; the text is passed to a function that compiles
    it into a JavaScript function that Browserify can process as a regular JavaScript
    file. To apply the necessary transformation to the templates, you will need to
    install a transformation plugin:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The transformation process take place when you instruct webpack to use jstify
    at compilation time:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Templates are easy to modularize; just extract the text in the script tags
    and put it in a new file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `contactListLayout.tpl` now contains the text of the layout template for
    the contact list. In the `ContactListLayout` view you can import the template
    as a regular JavaScript file but do not forget to include the `tpl` extension:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`contactListLayout.tpl` 现在包含联系列表布局模板的文本。在 `ContactListLayout` 视图中，你可以将模板作为常规
    JavaScript 文件导入，但不要忘记包含 `tpl` 扩展名：'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you import the template, you will use a function. Because our common views
    support both CSS selectors and pre-compiled templates it should work properly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入模板时，你会使用一个函数。因为我们的通用视图同时支持 CSS 选择器和预编译模板，所以它应该可以正常工作：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now you have a fully modularized project where each piece of code is in a small
    file; one advantage of this is that you can focus on small chunks of code instead
    and avoid the overhead of large files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个完全模块化的项目，其中每个代码片段都在一个小文件中；这个优势之一是你可以专注于小块代码，从而避免大型文件的开销。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned what Browserify is and how you can organize
    your projects into Node modules to manage your code and dependencies in a cleaner
    way. To make the Contacts project compatible with `npm`, we had to alter the code
    of the project; however, the changes are minimal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Browserify 是什么以及如何将你的项目组织成 Node 模块，以便以更整洁的方式管理你的代码和依赖。为了使 Contacts
    项目与 `npm` 兼容，我们不得不修改项目的代码；然而，这些更改非常小。
- en: There are other alternatives to Browserify, too; require.js and the AMD module
    definition are good to work with. However testing with require.js could be very
    difficult; I don't recommend you use `require.js` if you want to test isolated
    modules (unit testing).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Browserify，还有其他替代方案；require.js 和 AMD 模块定义也是不错的选择。然而，使用 require.js 进行测试可能会非常困难；如果你想要测试独立的模块（单元测试），我不建议你使用
    `require.js`。
- en: Webpack is another popular choice to bundle and organize your code base. Its
    main purpose is to work with frontend dependencies; it can load CommonJS modules
    and AMD modules. However, webpack is more complicated to configure and manage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是捆绑和组织你的代码库的另一个流行选择。其主要目的是与前端依赖项一起工作；它可以加载 CommonJS 模块和 AMD 模块。然而，webpack
    的配置和管理更为复杂。
- en: Browserify is the most popular choice for bundling JavaScript projects and is
    easier to configure and maintain than webpack; it is useful to use the same tools
    that Node uses to manage its dependencies and it does a great job.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 是捆绑 JavaScript 项目的最受欢迎的选择，比 webpack 更容易配置和维护；使用 Node 用于管理其依赖项的相同工具是有用的，并且它做得很好。
- en: In the next chapter, we will explore how to deal with files in a Backbone project;
    handling files over a RESTful API is a common issue, so we will discover what
    the common patterns and strategies are.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 Backbone 项目中处理文件；通过 RESTful API 处理文件是一个常见问题，因此我们将发现常见的模式和策略。
- en: In Chapter 7, we will explore how to build applications with automation tools;
    instead of manually running the Browserify command each time we change the code,
    we will create the necessary scripts that will do it for us.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，我们将探讨如何使用自动化工具构建应用程序；每次我们更改代码时，我们不必手动运行 Browserify 命令，我们将创建必要的脚本来自动完成这项工作。
