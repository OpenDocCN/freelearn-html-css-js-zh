- en: Chapter 4. Modular Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your project's code grows, the number of scripts in the project will be more
    and more, incrementing script-loading complexity. The classic way to load JavaScript
    files is to write a`<script>` tags for every script you have, but you have to
    do it in the right order; if you don't, your code could stop working. That's not
    an efficient way for medium-size projects.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you forget the order of loading? What if you make a refactorization
    on the code and the order of the script changes? It will be a pain to fix it and
    keep track of all the code and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This problem has been addressed in different ways. One is to create a module
    syntax to create, load, and declare explicitly the dependencies of modules; the
    syntax is called **AMD** (**Asynchronous Module Definition**). The AMD modules
    define a list of module dependencies, and the code inside the module will be executed
    only after the dependencies are fully loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies are loaded asynchronously; that means that you don't need to
    load all the scripts in the HTML page through `<script>` tags. AMD modules are
    better than plain JavaScript because they define dependencies explicitly and can
    be loaded automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Although AMD modules are better than `<script>` tags, working with AMD modules
    can be a pain when unit testing comes in because you need to know the intricacies
    of how the library loads the modules; when you want to do unit testing, you need
    to isolate the pieces of code under test, but is hard to do it in RequireJS, and
    even if you do it the result can be buggy.
  prefs: []
  type: TYPE_NORMAL
- en: Recently another module loader and dependency manager has arrived; Browserify
    seems to be the most popular at the moment. However, it is not the only one; there
    are many other potentially strong choices such as jspm and steal.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will work with Browserify because of its popularity, so you
    can find a lot of information and documentation about it on the Web; another good
    reason is that many projects have been built with it, which demonstrates its maturity
    and that it's production-ready. Browserify uses the same Node module syntax to
    define modules and dependencies, so that if you already know about Node you can
    go directly to the Browserify section.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, Node has been gaining popularity in the software industry;
    indeed it is becoming a very popular choice for backend development in a full
    JavaScript technology stack. If you don't know about Node, you can think about
    it as JavaScript used in the server instead of a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Node uses the CommonJS module syntax for its modules; a CommonJS module is a
    file that exports a single value to be used for other modules. It is useful to
    use CommonJS because it provides a clean way to manage JavaScript modules and
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: To support CommonJS, Node uses the `require()` function. With `require()` you
    can load JavaScript files without the need to use `<script>` tags, instead calling
    `require()` with the name of the module/dependency that you need and assigning
    it to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how CommonJS modules work, let''s write a Node module and see
    how to use the `require()` function. The following code shows a simple module
    that exposes a simple object with the method `sayHello()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This script can be placed in a file named `hello.js`, for example. The hello
    module can be loaded from another module by calling the `require()` function,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we require a script with the `require()` function we don't need to add
    the .js extension, Node will do it for us automatically. Note that, if you add
    the extension to the script name, Node will add the extension anyway and you will
    get an error because the `hello.js.js` file does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the way you can define CommonJS modules for your projects: we just
    export the variable that we want to expose to the outside of the module with `module.exports`
    and then load the module where needed with `require()`.'
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules are singletons, which means that every time you load a module
    you will get the same instance of the object. Node will cache the returned value
    when it's called for the first time and will reuse it for the next calls.
  prefs: []
  type: TYPE_NORMAL
- en: NPM and package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Browserify, we can create CommonJS modules that can be executed in the
    browser. When you use CommonJS modules in the browser, Browserify will provide
    the necessary tools to load the modules, which includes a definition for the `require()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: When you use Browserify, you can use the Node package manager to install and
    define dependencies for your projects. A useful tool is the npm command tool,
    used to install and manage project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The `package.json` file in a Node project is a JSON file used to define, install,
    and manage the version of the libraries that your project depends on. A `package.json`
    file can contain many configuration options; you can see the complete documentation
    on the Node website at [https://docs.npmjs.com/](https://docs.npmjs.com/). Here
    is a list of the main values.
  prefs: []
  type: TYPE_NORMAL
- en: '`Name` – The name of the project without spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description` – A short description of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Version` – A version number for the project, typically starting with 0.0.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dependencies` – A list of libraries with the version number that the project
    depends on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies` – Same as dependencies, but this list is used only for development
    environments—useful for putting libraries for testing, for instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`licence` – A license name for the project code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can start with a very simple `package.json` file that contains only some
    basic fields, and then we can extend it as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we don''t have any dependency yet. We can install our first
    dependency with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install the basic dependencies to work with `backbone`; the
    save flag will update automatically the `package.json` file, adding the library
    names and its current versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The format of the library version follows the `semver` standard; you can see
    more about this format in the official `semver` website.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of using the `package.json` file in your project is that, the
    next time you want to install the dependencies, you don''t need to remember the
    libraries and their versions; you can just hit **Install** without any argument
    and Node will read the `package.json` file and make the installs for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With `npm` you can install development packages such as the mocha testing library,
    but instead of using the save flag use `save-dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to install dependencies and save them in the `package.json`
    file, we can start using Browserify in the Contacts app.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Browserify we can use Node modules directly in the browser. This means
    that you can build your projects with the power of the npm package manager and
    the Node module syntax exposed in the previous sections. Then Browserify can take
    your source code and apply some transformations to be able to run your code in
    the browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple module that exposes an object with a method that prints a hello
    message can be written as a Node module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple piece of code can be loaded from another script as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works perfectly with Node. You can run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However this code will not run in the browser because the `require` function
    and the module object are not defined. Browserify takes your project entry code
    and tracks all the dependencies to create a single file with all the scripts concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Browserify](img/B01962_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 Bundling with Browserify
  prefs: []
  type: TYPE_NORMAL
- en: Note that our code is still in there; Browserify makes the definition of the
    missing objects and concatenates all the script in a single file. Figure 4.1 shows
    a graphical representation of what happens. If you use libraries such as Backbone,
    then your final script will contain all the Backbone code in the output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell Browserify that you want to create a file instead of just putting the
    result in the standard output, use the `-o` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That will create an app.js file with the contents of the `hello.js` and `main.js`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Application dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application is loaded in the browser, it loads all the JavaScript files
    in a specific order. The order is important because it represents the chain of
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the standard way of script loading; the browser is responsible to parse
    these script tags, fetch the script files from the assets server, and then execute
    them in that order. So that the Browser will execute jQuery, then Bootstrap, then
    Underscore and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, Backbone depends on Underscore and jQuery to work; it uses jQuery
    to handle DOM selections in Backbone views and Underscore as the utility library.
    For this reason, jQuery and Underscore should be loaded before Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: In the project code, `app.js` depends on Backbone, so that it's loaded after
    Backbone. The `apps/contacts/app.js` module is the application façade. It depends
    on all the other modules in the subapplications, which is why it's loaded last.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 shows the dependency of the modules graphically. Note that it's a
    simplification and not all the dependencies are shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application dependency](img/B01962_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 Dependency graph
  prefs: []
  type: TYPE_NORMAL
- en: Using Browserify in the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now we have learned about what Browserify is and how to use it. Now we
    will apply that background to our contacts app to load all the code as Node modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, ensure that you have installed all the required dependencies
    for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The easiest modules to convert are Models and Collections because they don't
    have huge dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the module remains almost the same. We have just added the
    `require()` calls and the export statement at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Views are easy to convert, too. We just have to add the `require()` calls as
    we did with the `Contact` and `ContactCollection` modules. Before we continue,
    we need an extra step with the views; currently all the views for a given controller
    are contained in a single script; `contactEditor.js` for example contains `ContactForm`,
    `ContactPreview`, and `PhoneList`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are modularizing the project, it''s a good idea to put each view in its
    own file and require it when we need it. The following shows this idea. You have
    many good reasons to do this: to isolate your components for testing, to keep
    your files small, to improve maintenance, and to get interchangeable modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Browserify in the app](img/B01962_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 Splitting views to their own files
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the conversion of plain JavaScript files to Node modules is
    very easy to do. The code of the business logic is exactly the same. The subapplication
    controller depends on the views that we have converted on the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The application façade depends on many subapplication controllers, the models,
    and the collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The routers depend on the subapplication façade and the application infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The App object is responsible for loading all the subapplication routers and
    then starting the history module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to start the application by calling the `start()` method on
    the App object; this is done from the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are re-packing the application with Browserify, it''s better to create
    a new file to the main entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our application is written as Node modules, we can use Browserify to bundle
    the code in a single script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a bundled file with all the dependencies on it. To use the
    bundled version of the code, we have to change the `index.htm` file to load it
    instead of loading all the individual files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That should be enough; however, the application won't start because we have
    a cyclic dependency issue.
  prefs: []
  type: TYPE_NORMAL
- en: Solving cyclic dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having two modules that depend on each other is called **cyclic dependency**.
    In our Contacts application, the infrastructure application depends on the subapplication
    routers, and the routers depend on the application infrastructure to load the
    subapplication controllers and facades. Figure 4.4 shows how this looks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving cyclic dependency](img/B01962_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 Cyclic dependencies
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to run the application properly because of the cyclic dependency.
    Here is what happens in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The App module is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App requires `ContactsRouter`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ContactsRouter` requires the App module but the App module is not exported
    yet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ContactsRouter` receives an `undefined` value for the App variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App module continue the execution and finally exposes the App value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ContactsRouter` matches a route, but as the App value is undefined it triggers
    an error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should break the cycle in some way. An easy approach to do it is to require
    the App module after it is exported. Instead of requiring the `App` module from
    `ContactsRouter` on top of the file, we can do it only when it''s necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple but effective way to break a cyclic dependency. Now you can
    re-bundle the application and run the application again. It should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Modularizing templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, templates have been declared as script tags in the `index.html` file.
    While this is a good approach for small projects, it is not a good idea to put
    all your templates directly in the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: With Browserify, you can extract all your template files into individual files,
    with the advantage of modularization and a cleaner `index.html` file. Another
    benefit of modularizing templates is that you can pre-compile all the templates,
    saving resources in your users' browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Browserify, you can modularize almost any template format: jade, Handlebars,
    Underscore, and so on. It uses a transformation process described in Figure 4.5\.
    If you have worked with other bundler tools such as webpack, transformations are
    analogous to pre-processors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modularizing templates](img/B01962_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 The transformation process
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates are in plain text; the text is passed to a function that compiles
    it into a JavaScript function that Browserify can process as a regular JavaScript
    file. To apply the necessary transformation to the templates, you will need to
    install a transformation plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The transformation process take place when you instruct webpack to use jstify
    at compilation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Templates are easy to modularize; just extract the text in the script tags
    and put it in a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `contactListLayout.tpl` now contains the text of the layout template for
    the contact list. In the `ContactListLayout` view you can import the template
    as a regular JavaScript file but do not forget to include the `tpl` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import the template, you will use a function. Because our common views
    support both CSS selectors and pre-compiled templates it should work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a fully modularized project where each piece of code is in a small
    file; one advantage of this is that you can focus on small chunks of code instead
    and avoid the overhead of large files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned what Browserify is and how you can organize
    your projects into Node modules to manage your code and dependencies in a cleaner
    way. To make the Contacts project compatible with `npm`, we had to alter the code
    of the project; however, the changes are minimal.
  prefs: []
  type: TYPE_NORMAL
- en: There are other alternatives to Browserify, too; require.js and the AMD module
    definition are good to work with. However testing with require.js could be very
    difficult; I don't recommend you use `require.js` if you want to test isolated
    modules (unit testing).
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is another popular choice to bundle and organize your code base. Its
    main purpose is to work with frontend dependencies; it can load CommonJS modules
    and AMD modules. However, webpack is more complicated to configure and manage.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify is the most popular choice for bundling JavaScript projects and is
    easier to configure and maintain than webpack; it is useful to use the same tools
    that Node uses to manage its dependencies and it does a great job.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to deal with files in a Backbone project;
    handling files over a RESTful API is a common issue, so we will discover what
    the common patterns and strategies are.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 7, we will explore how to build applications with automation tools;
    instead of manually running the Browserify command each time we change the code,
    we will create the necessary scripts that will do it for us.
  prefs: []
  type: TYPE_NORMAL
