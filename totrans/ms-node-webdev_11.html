<html><head></head><body>
<div><h1 class="chapternumber">10</h1>
<h1 class="chaptertitle" id="_idParaDest-174">Using HTML Templates</h1>
<p class="normal1">In this chapter, I describe how templates are used to generate HTML content, allowing an application to adapt the content display to the user to reflect the request that is being processed or the application’s state data.</p>
<p class="normal">Like many of the topics described in this book, templates are much easier to understand once you see how they work. Therefore, I will start by creating a simple custom template system using just the features provided by the JavaScript and Node.js APIs, just to explain how the pieces fit together. I will demonstrate <em class="italic">server-side templates</em>, where the backend server generates the HTML content, and <em class="italic">client-side templates</em>, where the browser generates the content. </p>
<p class="normal">The <a id="_idIndexMarker466" class="calibre3"/>custom templates in this chapter are educational but too limited for use in a real project, so I also introduce a popular template package that has many more features and much better performance, and which is suitable for use in a real project. <em class="italic">Table 10.1</em> puts HTML templates in context.</p>
<p class="packt_figref">Table 10.1: Putting HTML templates in context</p>
<table class="table-container" id="table001-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">HTML templates are HTML documents that contain placeholders that are replaced with dynamic content to reflect the state of the application. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Templates allow the content presented to the user to reflect changes in the application state and are a key building block in most web applications.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">There are many good template packages available and popular frameworks generally include a template system.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">It is important to find a package with a format that you find easy to read, but otherwise, template engines are a positive addition to a web application project.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">You could generate content entirely using JavaScript code, but this tends to be difficult to maintain. You may not be able to avoid using templates if you are using a framework, such as React or Angular.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 10.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 10.2: Chapter summary</p>
<table class="table-container" id="table002-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Dynamically render HTML elements</p>
</td>
<td class="table-cell">
<p class="normal">Use a template engine that mixes HTML elements and expressions that are evaluated to produce data values. </p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">1-4, 11-15, 21-27</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Evaluate template expressions</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">eval</code> keyword to evaluate string expressions as JavaScript statements. </p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">5, 6</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Break up templates into more manageable content</p>
</td>
<td class="table-cell">
<p class="normal">Use partial templates/views.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">7-10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Dynamically render HTML elements at the browser</p>
</td>
<td class="table-cell">
<p class="normal">Compile templates into JavaScript code that is included in the bundle loaded by the browser.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">16-20, 28-31</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-175">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project created in <em class="italic">Chapter 9</em>. No changes are required to prepare for this chapter. Open a command prompt and run the command shown in <em class="italic">Listing 10.1</em> in the <code class="inlinecode">part2app</code> folder to start the development tools.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 10.1: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a web browser, request <code class="inlinecode">http://localhost:5000</code>, and click the <strong class="screentext">Send Request</strong> button. The browser will send a request to the backend server and display details of the results, as shown in <em class="italic">Figure 10.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_10_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-176">Using server-side HTML templates</h1>
<p class="normal1">Server-side HTML templates<a id="_idIndexMarker467" class="calibre3"/> allow the backend server to dynamically generate content to send the browser content that is tailored to an individual request. Tailoring can take any form, but a typical example is to include content that is specific to the user, such as including the user’s name.</p>
<p class="normal">Three things are required for an HTML template: a <em class="italic">template</em> file that has placeholder sections into which dynamic content will be inserted, a <em class="italic">data dictionary</em> or <em class="italic">context</em> that provides the values that will determine the specific dynamic content that will be generated, and a <em class="italic">template engine</em> that processes the view and the dictionary to produce an HTML document into which dynamic<a id="_idIndexMarker468" class="calibre3"/> content has been inserted, and which can be used as a response to an HTTP request, as shown in <em class="italic">Figure 10.2</em>. </p>
<figure class="mediaobject"><img alt="" src="img/B21959_10_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.2: The components of an HTML template</p>
<p class="normal">The task of processing a template is known as <em class="italic">rendering</em> and it occurs entirely in the backend server. Rendering produces a regular HTML document that, from the perspective of the browser, appears no different from regular static content. (There is a different kind of template that is sent to the browser as JavaScript, where it is rendered to create HTML content by the client, as described in the <em class="italic">Using client-side HTML templates</em> section). </p>
<h2 class="heading1" id="_idParaDest-177">Creating a simple template engine</h2>
<p class="normal1">It is <a id="_idIndexMarker469" class="calibre3"/>easy to create a simple template engine to help understand how they work, although it is<a id="_idIndexMarker470" class="calibre3"/> much harder to create one that is production ready. In this section, I’ll create something simple and then introduce an open-source template engine package that is better, faster, and has many more features.</p>
<p class="normal">I am going to start by creating the template, which will help put everything in context. Create the <code class="inlinecode">part2app/templates/server</code> folder and add to it a file named <code class="inlinecode">basic.custom</code> with the content shown in <em class="italic">Listing 10.2</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">Most code editors can be configured to understand that files with a non-standard extension, such as <code class="inlinecode">.custom</code>, contain a well-known format, such as HTML. If you are using Visual Studio Code, for example, click on <strong class="screentext">Plain Text</strong> in the bottom-right corner of the window and either choose the format for a single file or set up an association so that all <code class="inlinecode">.custom</code> files are treated like HTML, which will make it easier to spot mistakes when following the examples. </p>
</div>
<p class="packt_figref">Listing 10.2: The contents of the basic.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;h3 class="m-2"&gt;Message: {{ message }}&lt;/h3&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">This <a id="_idIndexMarker471" class="calibre3"/>template<a id="_idIndexMarker472" class="calibre3"/> is a complete HTML document with one placeholder, which is denoted by the double curly braces (the <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> characters). The content inside of the braces is a <em class="italic">template expression</em> that will be evaluated when the template is rendered and used to replace the placeholder. </p>
<p class="normal">Not all template engines use the <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> characters, although that is a popular choice, and what is important is that the character sequence that denotes a placeholder is unlikely to occur in the static parts of the template, which is why you will usually see sequences of repeating characters, or unusual characters, used. </p>
<h3 class="heading2" id="_idParaDest-178">Creating the custom template engine</h3>
<p class="normal1">The <a id="_idIndexMarker473" class="calibre3"/>Express package has <a id="_idIndexMarker474" class="calibre3"/>integrated support for template engines, which makes it easy to experiment and learn how they work. Add a file named <code class="inlinecode">custom_engine.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 10.3</em>. </p>
<p class="packt_figref">Listing 10.3: The contents of the custom_engine.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFile } from "fs";
import { Express } from "express";
const renderTemplate = (path: string, context: any,
    callback: (err: any, response: string | undefined) =&gt; void) =&gt; {
    readFile(path, (err, data) =&gt; {
        if (err != undefined) {
            callback("Cannot generate content", undefined);
        } else {
            callback(undefined, parseTemplate(data.toString(), context));           
        }
    });
};
const parseTemplate = (template: string, context: any) =&gt; {
    const expr = /{{(.*)}}/gm;
    return template.toString().replaceAll(expr, (match, group) =&gt; {
        return context[group.trim()] ?? "(no data)"
    });               
}
export const registerCustomTemplateEngine = (expressApp: Express) =&gt;
    expressApp.engine("custom", renderTemplate);
</code></pre>
<p class="normal">The <code class="inlinecode">renderTemplate</code> function will be called by Express to render a template. The<a id="_idIndexMarker475" class="calibre3"/> parameters are a <code class="inlinecode">string</code> that contains the template file path, an <code class="inlinecode">object</code> that provides <a id="_idIndexMarker476" class="calibre3"/>context data for rendering the template, and a callback function used to provide Express with the rendered content or an error if something goes wrong.</p>
<p class="normal">The <code class="inlinecode">renderTemplate</code> function uses the <code class="inlinecode">readFile</code> function to read the contents of the template file and then invokes the <code class="inlinecode">parseTemplate</code> function, which uses a regular expression to search for the <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> characters. For each match, a callback function inserts a data value from the context object in the result, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const expr = /{{(.*)}}/gm;
return template.toString().replaceAll(expr, (match, group) =&gt; {
   <strong class="screentext"> return context[group.trim()] ?? "(no data)"</strong>
});
...
</code></pre>
<p class="normal">This is a rudimentary approach, and real engines are more complex and take greater care to <a id="_idIndexMarker477" class="calibre3"/>find template expressions, but this is enough to demonstrate the idea. The <code class="inlinecode">registerCustomTemplateEngine</code> function registers the template engine <a id="_idIndexMarker478" class="calibre3"/>with Express, which is done by calling the <code class="inlinecode">Express.engine</code> method, specifying the file extension and the <code class="inlinecode">renderTemplate</code> function: </p>
<pre class="programlisting"><code class="hljs-code">...
export const registerCustomTemplateEngine = (expressApp: Express) =&gt;
    expressApp.<strong class="screentext">engine</strong>("custom", renderTemplate);
...
</code></pre>
<p class="normal">This statement tells Express to use the <code class="inlinecode">renderTemplate</code> function to render template files that have a <code class="inlinecode">.custom</code> file extension.</p>
<h3 class="heading2" id="_idParaDest-179">Setting up the custom template engine</h3>
<p class="normal1">The<a id="_idIndexMarker479" class="calibre3"/> final part of the<a id="_idIndexMarker480" class="calibre3"/> process is to configure Express and create a route that matches requests that will be handled with a template, as shown in <em class="italic">Listing 10.4</em>. </p>
<p class="packt_figref">Listing 10.4: Setting up the template engine in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { testHandler } from "./testHandler";
import httpProxy from "http-proxy";
import helmet from "helmet";
<strong class="screentext">import { registerCustomTemplateEngine } from "./custom_engine";</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
<strong class="screentext">registerCustomTemplateEngine(expressApp);</strong>
<strong class="screentext">expressApp.set("views", "templates/server");</strong>
expressApp.use(helmet());
expressApp.use(express.json());
<strong class="screentext">expressApp.</strong><strong class="screentext">get("/dynamic/:file", (req, resp) =&gt; {</strong>
<strong class="screentext">    resp.render(`${req.params.file}.custom`, { message: "Hello template" });</strong>
});
expressApp.post("/test", testHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Calling<a id="_idIndexMarker481" class="calibre3"/> the <code class="inlinecode">registerCustomTemplateEngine</code> defined in <em class="italic">Listing 10.4</em> sets up the custom template<a id="_idIndexMarker482" class="calibre3"/> engine. By default, Express looks for template files in the <code class="inlinecode">views</code> folder. </p>
<p class="normal"><em class="italic">Views</em> and <em class="italic">view engines </em>are alternate names for templates and template engines, but to keep the terminology consistent, I used the <code class="inlinecode">ExpressApp.set</code> method to change the template file location:</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.<strong class="screentext">set</strong>("views", "templates/server");
...
</code></pre>
<p class="normal">The complete set of Express configuration properties can be found at <a href="https://expressjs.com/en/4x/api.html#app.set" class="calibre3">https://expressjs.com/en/4x/api.html#app.set</a> and the <code class="inlinecode">views</code> property is used to specify the directory that contains template files.</p>
<p class="normal">The Express router is used to match requests that will be handled by templates, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.<strong class="screentext">get</strong>("/dynamic/:file", (req, resp) =&gt; {
    resp.<strong class="screentext">render</strong>(`${req.params.file}.custom`, { message: "Hello template" });
});
...
</code></pre>
<p class="normal">The <code class="inlinecode">get</code> method <a id="_idIndexMarker483" class="calibre3"/>creates a route that matches paths that start with <code class="inlinecode">/dynamic</code> and captures<a id="_idIndexMarker484" class="calibre3"/> the next path segment to a route parameter named <code class="inlinecode">file</code>. The request handler invokes the <code class="inlinecode">Response.render</code> method, which is responsible for rendering a template. The <code class="inlinecode">file</code> route parameter is used to create the first argument to the render method, which is the name of the template file. The second argument is an object that provides the template engine with context data to help it generate content. In this example, the context object defines a <code class="inlinecode">message</code> property, whose value will be included in the rendered output. </p>
<p class="normal">To test the custom template engine, use a browser to request <code class="inlinecode">http://localhost:5000/dynamic/basic</code>. The <code class="inlinecode">dynamic</code> part of the URL will be matched by the new Express route, and the <code class="inlinecode">basic</code> part corresponds to the <code class="inlinecode">basic.custom</code> file in the templates folder. The custom view engine will process the template file and the results will be written to the response, as shown in <em class="italic">Figure 10.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_10_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.3: Using a custom template engine</p>
<h2 class="heading1" id="_idParaDest-180">Evaluating expressions in templates</h2>
<p class="normal1">Inserting <a id="_idIndexMarker485" class="calibre3"/>data values into templates is a good start, but most template engines have support for evaluating fragments of JavaScript code and inserting the results into the output. <em class="italic">Listing 10.5</em> adds some template expressions to the template. </p>
<p class="packt_figref">Listing 10.5: Adding expressions to the basic.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;link href="/css/bootstrap.min.css" rel="stylesheet" /&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;h3 class="m-2"&gt;Message: {{ message }}&lt;/h3&gt;
        <strong class="screentext">&lt;h3 class="m-2"&gt;Lower: {{ message.toLowerCase() }}&lt;/h3&gt;</strong>
<strong class="screentext">        &lt;h3 class="</strong><strong class="screentext">m-2"&gt;Count: {{ 2 * 3 }}&lt;/h3&gt;</strong>
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal"><em class="italic">Listing 10.6</em> adds support for evaluating expressions to the template engine, using the JavaScript <code class="inlinecode">eval</code> function.</p>
<div><p class="normal"><strong class="screentext">Caution</strong></p>
<p class="normal">The JavaScript <code class="inlinecode">eval</code> function is dangerous, especially if there is the possibility that it might be used with content or data provided by users because it can be used to execute any JavaScript code. This alone is enough reason to use a well-tested template engine package, such as the one introduced in the Using a template package section. </p>
</div>
<p class="packt_figref">Listing 10.6: Evaluating expressions in the custom_engine.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFile } from "fs";
import { Express } from "express";
const renderTemplate = (path: string, context: any,
    callback: (err: any, response: string | undefined) =&gt; void) =&gt; {
    readFile(path, (err, data) =&gt; {
        if (err != undefined) {
            callback("Cannot generate content", undefined);
        } else {
            callback(undefined, parseTemplate(data.toString(), context));           
        }
    });
};
const parseTemplate = (template: string, context: any) =&gt; {
   <strong class="screentext"> const ctx = Object</strong><strong class="screentext">.keys(context)</strong>
<strong class="screentext">        .map((k) =&gt; `const ${k} = context.${k}`)</strong>
<strong class="screentext">        .join(";");</strong>
    const expr = /{{(.*)}}/gm;
    return template.toString().replaceAll(expr, (match, group) =&gt; {
      <strong class="screentext">  return eval(`</strong><strong class="screentext">${ctx};${group}`);</strong>
    });
}
export const registerCustomTemplateEngine = (expressApp: Express) =&gt;
    expressApp.engine("custom", renderTemplate);
</code></pre>
<p class="normal">The <a id="_idIndexMarker486" class="calibre3"/>difficulty of using <code class="inlinecode">eval</code> is making sure that context data is available as local variables when evaluating an expression. To make sure that the context data is in scope, I create a string for each property of the context object and combine those strings with the expression to be evaluated, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
"const message = context.message; message.toLowerCase()"
...
</code></pre>
<p class="normal">This approach ensures that there is a <code class="inlinecode">message</code> value for the expression to use, for example. There are some serious dangers in using <code class="inlinecode">eval</code> but it is fine for the example application, although it bears repeating to say a real template package should be used in real projects, especially when dealing with user-supplied data. Use a browser window to request <code class="inlinecode">http://localhost:5000/dynamic/basic</code> and you will see the results shown in <em class="italic">Figure 10.4</em>. (The browser won’t reload automatically, so you will either have to make a new request or reload the browser).</p>
<figure class="mediaobject"><img alt="" src="img/B21959_10_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.4: Evaluating JavaScript expressions in a template</p>
<h2 class="heading1" id="_idParaDest-181">Adding template features</h2>
<p class="normal1">The<a id="_idIndexMarker487" class="calibre3"/> ability to evaluate expressions provides a foundation for creating additional features, which can be easily written as JavaScript functions and added to the context used to parse the template. Add a file named <code class="inlinecode">custom_features.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 10.7</em>.</p>
<div><p class="normal"><strong class="screentext">Compiling templates</strong></p>
<p class="normal">Most real template engines compile their templates, which means that templates are converted into a series of JavaScript functions that can be invoked to generate content. This doesn’t change the content that is generated but it can improve performance because output can be created without needing to read and search the template file. Client-side templates are also compiled so that the JavaScript functions can be presented to the browser. You can see an example of this process in the <em class="italic">Using a template package</em> section, later in the chapter. </p>
</div>
<p class="packt_figref">Listing 10.7: The contents of the custom_features.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
export const style = (stylesheet: string) =&gt; {
    return `&lt;link href="/css/${stylesheet}" rel="stylesheet" /&gt;`;
}
export const partial = (file: string, context: any) =&gt; {
    const path = `./${context.settings.views}/${file}.custom`;
    return readFileSync(path, "utf-8");
}
</code></pre>
<p class="normal">This <a id="_idIndexMarker488" class="calibre3"/>file defines a <code class="inlinecode">style</code> function that accepts a stylesheet name and returns a <code class="inlinecode">link</code> element. The <code class="inlinecode">partial</code> function reads another template file and returns its content for inclusion in the overall content. The <code class="inlinecode">partial</code> function receives a context object, which it uses to locate the requested file:</p>
<pre class="programlisting"><code class="hljs-code">...
const path = `./${<strong class="screentext">context.settings.views</strong>}/${file}.custom`;
...
</code></pre>
<p class="normal">The context object that Express provides to the template engine has a <code class="inlinecode">settings</code> property, which returns an object that contains the application’s configuration. One of the settings properties is <code class="inlinecode">views</code>, which returns the location of the template files (the <code class="inlinecode">templates/server</code> folder). <em class="italic">Listing 10.8</em> revises the template to use these new features. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">partial</code> function in <em class="italic">Listing 10.7</em> performs a blocking operation to read the contents of the file. As explained in <em class="italic">Chapter 4</em>, this is something that should be avoided as much as possible, and I have used the <code class="inlinecode">readFileSync</code> function only for the sake of simplicity.</p>
</div>
<p class="packt_figref">Listing 10.8: Using template features in the basic.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    <strong class="screentext">&lt;head&gt;{{ @style("bootstrap.min.css") }}&lt;/head&gt;</strong>
    &lt;body&gt;
        <strong class="screentext">{{ @partial("message") }}</strong>
        &lt;h3 class="m-2"&gt;Message: {{ message }}&lt;/h3&gt;
        &lt;h3 class="m-2"&gt;Lower: {{ message.toLowerCase() }}&lt;/h3&gt;
        &lt;h3 class="m-2"&gt;Count: {{ 2 * 3 }}&lt;/h3&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The new features are accessed with a <code class="inlinecode">@</code> prefix, which makes them easy to find when parsing templates. In <em class="italic">Listing 10.8</em>, the <code class="inlinecode">@style</code> expression will invoke the <code class="inlinecode">style</code> function to create a <code class="inlinecode">link</code> element for the Bootstrap CSS file, and the <code class="inlinecode">@partial</code> expression<a id="_idIndexMarker489" class="calibre3"/> will invoke the <code class="inlinecode">partial</code> function to load a template named <code class="inlinecode">message</code>. To create the template – known as a <em class="italic">partial template</em> – that will be loaded by the <code class="inlinecode">@partial</code> expression, create a file named <code class="inlinecode">message.custom</code> in the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 10.9</em>.</p>
<p class="packt_figref">Listing 10.9: The contents of the message.custom in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="bg-primary text-white m-2 p-2"&gt;
    {{ message }}
&lt;/div&gt;
</code></pre>
<h3 class="heading2" id="_idParaDest-182">Mapping expressions to features</h3>
<p class="normal1">All that <a id="_idIndexMarker490" class="calibre3"/>remains is translating the <code class="inlinecode">@</code> expressions in the template to JavaScript statements that invoke the functions from <em class="italic">Listing 10.7</em>. Take the following expression:</p>
<pre class="programlisting"><code class="hljs-code">...
{{ @partial("message") }}
...
</code></pre>
<p class="normal">The preceding expression will be translated into the following:</p>
<pre class="programlisting"><code class="hljs-code">...
features.partial("message", context);
...
</code></pre>
<p class="normal">Once the translation is complete, the result can be evaluated just like any other expression. <em class="italic">Listing 10.10</em> changes the template engine to support the new features.</p>
<p class="packt_figref">Listing 10.10: Supporting template features in the custom_engine.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFile } from "fs";
import { Express } from "express";
<strong class="screentext">import * as features from "./custom_features";</strong>
const renderTemplate = (path: string, context: any,
    callback: (err: any, response: string | undefined) =&gt; void) =&gt; {
    readFile(path, (err, data) =&gt; {
        if (err != undefined) {
            callback("Cannot generate content", undefined);
        } else {
            <strong class="screentext">callback(</strong><strong class="screentext">undefined, parseTemplate(data.toString(),</strong>
<strong class="screentext">                { ...context, features }));</strong>
        }
    });
};
const parseTemplate = (template: string, context: any) =&gt; {
    const ctx = Object.keys(context)
        .map((k) =&gt; `const ${k} = context.${k}`)
        .join(";");
    const expr = /{{(.*)}}/gm;
    return template.toString().replaceAll(expr, (match, group) =&gt; {
        <strong class="screentext">const evalFunc= (expr: string) =&gt; {</strong>
<strong class="screentext">            return eval(</strong><strong class="screentext">`${ctx};${expr}`)</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        try {</strong>
<strong class="screentext">            if (group.trim()[0] === "@") {</strong>
<strong class="screentext">                group = `features.${group.trim().substring(1)}</strong><strong class="screentext">`;</strong>
<strong class="screentext">                group = group.replace(/\)$/m, ", context, evalFunc)");</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            let result = evalFunc(group);</strong>
<strong class="screentext">            if (expr.test(result)) {</strong>
<strong class="screentext">                result = parseTemplate(result, context);</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">            return result;</strong>
<strong class="screentext">        } catch (</strong><strong class="screentext">err: any) {</strong>
<strong class="screentext">            return err;</strong>
<strong class="screentext">        }</strong>
    });
}
export const registerCustomTemplateEngine = (expressApp: Express) =&gt;
    expressApp.engine("custom", renderTemplate);
</code></pre>
<p class="normal">The functions defined in <em class="italic">Listing 10.7</em> are imported and assigned the <code class="inlinecode">features</code> prefix. String manipulation performs the translation from the <code class="inlinecode">@</code> expression to the function name, with the addition of the <code class="inlinecode">context</code> property and an <code class="inlinecode">eval</code> function. This<a id="_idIndexMarker491" class="calibre3"/> allows expressions to access the context object, the settings it includes, and the ability to evaluate expressions with the context. The result from a <code class="inlinecode">@</code> feature may contain other template expressions; therefore, the regular expression is used to recursively parse the result.</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/dynamic/basic</code> and you will see the output produced by the new features, as shown in <em class="italic">Figure 10.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_10_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.5: Adding template features</p>
<h2 class="heading1" id="_idParaDest-183">Using templates to create a simple round-trip application</h2>
<p class="normal1">The<a id="_idIndexMarker492" class="calibre3"/> template engine is simple, but it has just enough functionality to create a basic application that alters the HTML it displays based on user interaction, which is the key function of any web application. To demonstrate, I am going to present the user with a button that increments a counter, where the value of the counter will result in different content being presented to the user. This is an example of a <em class="italic">round-trip application</em>, where each interaction requires an HTTP request to the server to get a new HTML document to display to the user.</p>
<p class="normal">The<a id="_idIndexMarker493" class="calibre3"/> first step is to add the object that represents the HTTP request to the context data given to the custom template engine, as shown in <em class="italic">Listing 10.11</em>. </p>
<p class="packt_figref">Listing 10.11: Adding to the context data in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.get("/dynamic/:file", (req, resp) =&gt; {
   <strong class="screentext"> resp.render(`${req.params.file}.custom`, {</strong>
<strong class="screentext"> </strong><strong class="screentext">message: "Hello template", req</strong>
<strong class="screentext">    });</strong>
});
...
</code></pre>
<p class="normal">Next, add a file named <code class="inlinecode">counter.custom</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 10.12</em>.</p>
<p class="packt_figref">Listing 10.12: The contents of the counter.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;{{ @style("bootstrap.min.css") }}&lt;/head&gt;
    &lt;body&gt;
        &lt;a class="btn btn-primary m-2"
            href="/dynamic/counter?c={{ Number(req.query.c ?? 0) + 1}}"&gt;
                Increment
        &lt;/a&gt;
        &lt;div&gt;
            {{ @conditional("(req.query.c ?? 0) % 2", "odd", "even") }}       
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">This template contains an anchor element (the <code class="inlinecode">a</code> tag) that, when clicked, requests a new HTML document from the backend server using a URL that contains a query string parameter named <code class="inlinecode">c</code>. The value of <code class="inlinecode">c</code> included in the request URL is always one more than the value displayed to the user, such that clicking the button has the effect of incrementing the counter.</p>
<p class="normal">The template contains a <code class="inlinecode">@conditional</code> expression, which will be used to render different partial templates for odd and even values of <code class="inlinecode">c</code>. The arguments to <code class="inlinecode">@conditional</code> are an expression to be evaluated and two partial template <a id="_idIndexMarker494" class="calibre3"/>names that will be used for <code class="inlinecode">true</code> and <code class="inlinecode">false</code> results when the expression is evaluated.</p>
<p class="normal">To create the partial template that will be used for odd values, add a file named <code class="inlinecode">odd.custom</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 10.13</em>.</p>
<p class="packt_figref">Listing 10.13: The content of the odd.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4 class="bg-primary text-white m-2 p-2"&gt;
    Odd value: {{ req.query.c ?? 0}}
&lt;/h4&gt;
</code></pre>
<p class="normal">To create the partial template that will be used for even values, add a file named <code class="inlinecode">even.custom</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 10.14</em>.</p>
<p class="packt_figref">Listing 10.14: The contents of the even.custom file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4 class="bg-secondary text-white m-2 p-2"&gt;
    Even value: {{ req.query.c ?? 0}}
&lt;/h4&gt;
</code></pre>
<p class="normal">The remaining step is to implement the <code class="inlinecode">@conditional</code> expression as a template feature, as shown in <em class="italic">Listing 10.15</em>.</p>
<p class="packt_figref">Listing 10.15: Adding a conditional feature in the custom_features.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
export const style = (stylesheet: string) =&gt; {
    return `&lt;link href="/css/${stylesheet}" rel="stylesheet" /&gt;`;
}
export const partial = (file: string, context: any) =&gt; {
    const path = `./${context.settings.views}/${file}.custom`;
    return readFileSync(path, "utf-8");
}
<strong class="screentext">export const conditional = (expression: string,</strong>
<strong class="screentext">        trueFile: string, falseFile: string, context: any,</strong>
<strong class="screentext">        evalFunc: (expr: string) =&gt; any) =&gt; {</strong>
<strong class="screentext">    return partial(evalFunc(expression) ? trueFile : falseFile, context);</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">conditional</code> function accepts an expression, two file paths, a context object, and a function used to evaluate expressions. The expression is evaluated, and the result is passed to the <code class="inlinecode">partial</code> function, effectively selecting a <a id="_idIndexMarker495" class="calibre3"/>partial view based on whether the expression has evaluated to <code class="inlinecode">true</code> or <code class="inlinecode">false</code>.</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/dynamic/counter</code> and click the <strong class="screentext">Increment</strong> button. Each click causes the browser to request a URL like <code class="inlinecode">http://localhost:5000/dynamic/counter?c=1</code> and the value of <code class="inlinecode">c</code> is used to select the HTML content in the response, as shown in <em class="italic">Figure 10.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/Image10809.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.6: Using templates to create a simple round-trip application</p>
<h1 class="heading" id="_idParaDest-184">Using client-side HTML templates</h1>
<p class="normal1">One drawback <a id="_idIndexMarker496" class="calibre3"/>of the previous example is that a completely new HTML document is generated and sent to the browser every<a id="_idIndexMarker497" class="calibre3"/> time <code class="inlinecode">Increment</code> is clicked, even though only one section of the HTML changes. </p>
<p class="normal"><em class="italic">Client-side HTML templates </em>perform the same task as their server-side counterparts, but the template is parsed by JavaScript code running in the browser. This allows a targeted approach, where selected elements are modified, which can be more responsive than waiting for a new HTML document. This is the basis for <strong class="screentext">single-page applications</strong> (<strong class="screentext">SPAs</strong>), where a single HTML document is delivered to the client and then modified by JavaScript code. </p>
<p class="normal">The main difficulty with client-side templates is that they have to be written entirely in JavaScript, which can make it awkward to express HTML content in a way that is easy to read and maintain.</p>
<p class="normal">The most <a id="_idIndexMarker498" class="calibre3"/>popular client-side frameworks, such as React and Angular, use client-side template formats that are easier to read than pure JavaScript, but they use a compiler to transform the template into a JavaScript function so that it can be added to the JavaScript bundle given to the browser.</p>
<p class="normal">The templates used by the big frameworks have other benefits, such as making it easy to combine templates to create complex content and ensuring that updates to HTML elements are performed as efficiently as possible.</p>
<p class="normal">But, leaving aside these features, the process of generating content at the client is similar to doing so at the server. A good way to understand the issues involved in client-side templating is to recreate the counter example from the previous section using client-side JavaScript. To start, add a file named <code class="inlinecode">counter_custom.js</code> to the <code class="inlinecode">src/client</code> folder with the content shown in <em class="italic">Listing 10.16</em>.</p>
<div><p class="normal"><strong class="screentext">Client-side versus server-side templates</strong></p>
<p class="normal">Most web application projects tend to mix both server-side and client-side templates because each type of template solves a different problem.</p>
<p class="normal">Server-side templates require an HTTP connection for every HTML document, which can impact performance. However, the performance deficit can be offset by how fast the browser can display the contents of the HTML document once it has been received.</p>
<p class="normal">Client-side templates respond to changes more efficiently and without the need to make additional HTTP requests, but this advantage can be undermined by the need to transfer the JavaScript code and the state data in the first place. When a framework like React or Angular is used, the JavaScript for the framework must also be transferred, and this can be a barrier in regions where less capable devices and unreliable networks are common.</p>
<p class="normal">To bridge the gap and give the best of both worlds, some frameworks offer <strong class="screentext">server-side rendering</strong> (<strong class="screentext">SSR</strong>), where templates are rendered at the server to create a round-trip version of the application, which can be displayed quickly by the browser. Once the server-rendered content is displayed, the browser requests JavaScript code and transitions to a single-page application. SSR has improved in recent years, but it is still clunky and doesn’t suit all projects.</p>
</div>
<p class="packt_figref">Listing 10.16: The contents of the counter_custom.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">import { Odd } from "./odd_custom";
import { Even } from "./even_custom";
export const Counter = (context) =&gt; `
    &lt;button class="btn btn-primary m-2" action="incrementCounter"&gt;
        Increment
    &lt;/button&gt;
    &lt;div&gt;
        ${ context.counter % 2 ? Odd(context) : Even(context) }
    &lt;/div&gt;`
</code></pre>
<p class="normal">The templates<a id="_idIndexMarker499" class="calibre3"/> in this example are JavaScript functions that return HTML strings, which is the simplest way to create a client-side template and it doesn’t require a compiler. The JavaScript template functions will receive a <code class="inlinecode">context</code> parameter that contains the current application state.</p>
<p class="normal">The JavaScript string features make it easy to insert data values into HTML strings. In this case, the value of the <code class="inlinecode">counter</code> property on the <code class="inlinecode">context</code> object received by the function is used to choose between the <code class="inlinecode">Odd</code> and <code class="inlinecode">Even</code> functions, which is a simpler approach than the equivalent functionality in the server-side template example.</p>
<p class="normal">One problem with this approach is that handling events from elements can be difficult. Not only does the example application’s content security policy prevent inline event handlers, but it can be difficult to define handler functions that use context data in HTML strings.</p>
<p class="normal">To work around this limitation, I have added an <code class="inlinecode">action</code> attribute to the <code class="inlinecode">button</code> element in <em class="italic">Listing 10.16</em>, which is assigned the value <code class="inlinecode">incrementCounter</code>. Events from the button will be allowed to propagate up the HTML document and I’ll use the <a id="_idIndexMarker500" class="calibre3"/>value of the <code class="inlinecode">action</code> attribute to decide how to respond.</p>
<p class="normal">To create the partial view that will display even values, add a file named <code class="inlinecode">even_custom.js</code> to the <code class="inlinecode">src/client</code> folder with the content shown in <em class="italic">Listing 10.17</em>.</p>
<p class="packt_figref">Listing 10.17: The contents of the even_custom.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">export const Even = (context) =&gt; `
    &lt;h4 class="bg-secondary text-white m-2 p-2"&gt;
        Even value: ${ context.counter }
    &lt;/h4&gt;`
</code></pre>
<p class="normal">The HTML string returned by this function includes the value of the <code class="inlinecode">counter.couter</code> property. To create the template for odd values, create a file named <code class="inlinecode">odd_custom.js</code> in the <code class="inlinecode">src/client</code> folder with the content shown in <em class="italic">Listing 10.18</em>.</p>
<p class="packt_figref">Listing 10.18: The contents of the odd_custom.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">export const Odd = (context) =&gt; `
    &lt;h4 class="bg-primary text-white m-2 p-2"&gt;
        Odd value: ${ context.counter }
    &lt;/h4&gt;`
</code></pre>
<p class="normal"><em class="italic">Listing 10.19</em> replaces the code in the <code class="inlinecode">client.js</code> file to use the new template functions and define the features they require.</p>
<p class="packt_figref">Listing 10.19: Replacing the contents of the client.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">import { Counter } from "./counter_custom";
const context = {
    counter: 0
}
const actions = {
    incrementCounter: () =&gt; {
        context.counter++; render();
    }
}
const render = () =&gt; {
    document.getElementById("target").innerHTML = Counter(context);
}
document.addEventListener('DOMContentLoaded', () =&gt; {
    document.onclick = (ev) =&gt; {
        const action = ev.target.getAttribute("action")
        if (action &amp;&amp; actions[action]) {
            actions[action]()
        }
    }
    render();
});
</code></pre>
<p class="normal">When<a id="_idIndexMarker501" class="calibre3"/> the <code class="inlinecode">DOMContentLoaded</code> event is emitted, which indicates the browser has finished parsing the HTML document, an event listener is created for <code class="inlinecode">click</code> events, and the <code class="inlinecode">render</code> function is invoked. </p>
<p class="normal">The <code class="inlinecode">render</code> function invokes the <code class="inlinecode">Counter</code> template function and uses the HTML string it receives to set the content of an HTML element whose <code class="inlinecode">id</code> is <code class="inlinecode">target</code>. When a <code class="inlinecode">click</code> event is received, the target for the event is checked for an <code class="inlinecode">action</code> attribute, and its value is used to select a function to execute from the <code class="inlinecode">actions</code> object. There is one action in the example, which increments the <code class="inlinecode">counter</code> property of the <code class="inlinecode">context</code> object and calls the <code class="inlinecode">render</code> function to update the content presented to the user.</p>
<p class="normal">The final step is to remove the existing content from the static HTML document and create the element that will be populated with the client-side template content, as shown in <em class="italic">Listing 10.20</em>.</p>
<p class="packt_figref">Listing 10.20: Preparing the HTML document in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        <strong class="screentext">&lt;div id="target"&gt;&lt;/div&gt;</strong>
<strong class="screentext">        &lt;!-- &lt;button id="btn" class="btn btn-primary m-2"&gt;Send Request&lt;/button&gt;</strong>
<strong class="screentext">        &lt;table class="table table-striped"&gt;</strong>
<strong class="screentext">            &lt;tbody&gt;</strong>
<strong class="screentext">                &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;td id="msg"&gt;&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="screentext">                &lt;tr&gt;&lt;th&gt;Response&lt;/th&gt;&lt;td id="body"&gt;&lt;/td&gt;&lt;/tr&gt;</strong>
<strong class="screentext">            &lt;/tbody&gt;</strong>
<strong class="screentext">       &lt;/table&gt; --&gt;</strong>
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Use a <a id="_idIndexMarker502" class="calibre3"/>browser to request <code class="inlinecode">http://localhost:5000</code> and you will be presented with the same content produced by the server-side templates. The difference is that when the <strong class="screentext">Increment</strong> button is clicked, the state change is handled by rendering the client-side templates, as shown in <em class="italic">Figure 10.7</em>, without the need to request a new HTML document from the backend server.</p>
<figure class="mediaobject"><img alt="" src="img/Image10818.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.7: Using simple client-side templates</p>
<h1 class="heading" id="_idParaDest-185">Using a template package</h1>
<p class="normal1">The<a id="_idIndexMarker503" class="calibre3"/> examples so far in this chapter have demonstrated how templates can be used to render content and show how some basic features can be easily created. For real projects, it makes more sense to adopt one of the excellent template packages available for JavaScript. Run the commands shown in <em class="italic">Listing 10.21</em> in the <code class="inlinecode">part2app</code> folder to install one of the most widely used template packages, which is named Handlebars, and a package that integrates it into Express. </p>
<p class="packt_figref">Listing 10.21: Installing a template package</p>
<pre class="programlisting1"><code class="hljs-con">npm install handlebars@4.7.8
npm install express-handlebars@7.1.2
</code></pre>
<p class="normal">There are <a id="_idIndexMarker504" class="calibre3"/>many template packages available, and they all offer similar features. The main difference between packages is the way that templates are written and how expressions are denoted. The <code class="inlinecode">{{</code> and <code class="inlinecode">}}</code> characters are a common way to denote expressions, and they are known as mustache templates because the curly braces are reminiscent of a mustache. The <code class="inlinecode">Handlebars</code> package (<a href="https://handlebarsjs.com" class="calibre3">https://handlebarsjs.com</a>) uses this style of expression, as<a id="_idIndexMarker505" class="calibre3"/> its name suggests. This is the style of JavaScript template I am used to, and familiarity goes a long way when picking a template package.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">There are<a id="_idIndexMarker506" class="calibre3"/> other options if you don’t like the mustache-style templates. The Pug package (<a href="https://pugjs.org" class="calibre3">https://pugjs.org</a>) relies on<a id="_idIndexMarker507" class="calibre3"/> indentation to structure templates, which is a popular choice, and the <strong class="screentext">Embedded JavaScript </strong>(<strong class="screentext">EJS</strong>) (<a href="https://ejs.co" class="calibre3">https://ejs.co</a>) package uses <code class="inlinecode">&lt;%</code> and <code class="inlinecode">%&gt;</code> sequences. Stylistic preferences aside, all of these packages are well-written and have good levels of support.</p>
</div>
<h2 class="heading1" id="_idParaDest-186">Using a package for server-side templates</h2>
<p class="normal1">Handlebars templates are <em class="italic">logic free</em>, which means they cannot contain fragments<a id="_idIndexMarker508" class="calibre3"/> of JavaScript that are evaluated to produce content. Instead, helper functions are defined to implement the logic required to generate content. Add a file named <code class="inlinecode">template_helpers.ts</code> to the <code class="inlinecode">src/server</code> folder with the content shown in <em class="italic">Listing 10.22</em>. </p>
<p class="packt_figref">Listing 10.22: The contents of the template_helpers.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">export const style = (stylesheet: any) =&gt; {
    return `&lt;link href="/css/${stylesheet}" rel="stylesheet" /&gt;`;
}
export const valueOrZero = (value: any) =&gt; {
    return value !== undefined ? value : 0;
}
export const increment = (value: any) =&gt;  {
    return Number(valueOrZero(value)) + 1;
}
export const isOdd = (value: any) =&gt; {
    return Number(valueOrZero(value)) % 2;
}
</code></pre>
<p class="normal">The <code class="inlinecode">style</code> function <a id="_idIndexMarker509" class="calibre3"/>accepts the name of a stylesheet and generates a link element for it. The <code class="inlinecode">valueOrZero</code> function checks to see whether a value is defined and, if it is not, returns zero. The <code class="inlinecode">increment</code> function increments a value. The <code class="inlinecode">isOdd</code> function returns <code class="inlinecode">true</code> if a value is odd.</p>
<h3 class="heading2" id="_idParaDest-187">Defining the templates</h3>
<p class="normal1">The <a id="_idIndexMarker510" class="calibre3"/>package that integrates Handlebars into Express supports <em class="italic">layouts</em>, which are templates that contain the common elements that would otherwise be repeated in every template. Create the <code class="inlinecode">templates/server/layouts</code> folder and add to it a file named <code class="inlinecode">main.handlebars</code> with the content shown in <em class="italic">Listing 10.23</em>.</p>
<p class="packt_figref">Listing 10.23: The contents of the main.handlebars file in the templates/server/layouts folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        {{{ style "bootstrap.min.css" }}}
    &lt;/head&gt;
    &lt;body&gt;
        {{{ body }}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">There are two expressions in this layout. The first invokes the <code class="inlinecode">style</code> helper function defined in <em class="italic">Listing 10.22</em>, using the <code class="inlinecode">bootstrap.min.css</code> string as an argument (arguments for helpers are separated by spaces and not parentheses). The other expression is <code class="inlinecode">body</code>, into which the contents template that has been requested is inserted.</p>
<p class="normal">The expressions<a id="_idIndexMarker511" class="calibre3"/> in the layout are denoted with triple curly braces (<code class="inlinecode">{{{</code> and <code class="inlinecode">}}}</code>), which tells Handlebars that the results should be inserted into the template without being escaped for HTML safety. Care must be taken when dealing with data that has been received from users, and most template engines automatically format content so that it won’t be interpreted as HTML by the browser. A sequence of three curly braces tells Handlebars that the result should be passed on without formatting, which is required when an expression is producing HTML.</p>
<p class="normal">To create the main server-side template for the example project, add a file named <code class="inlinecode">counter.handlebars</code> to the <code class="inlinecode">templates/server</code> folder with the content shown in <em class="italic">Listing 10.24</em>.</p>
<p class="packt_figref">Listing 10.24: The contents of the counter.handlebars in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;a class="btn btn-primary m-2"
    href="/dynamic/counter?c={{ increment req.query.c }}"&gt;
        Increment
&lt;/a&gt;
{{#if (isOdd req.query.c) }}
    {{&gt; odd }}
{{else}}
    {{&gt; even }}
{{/if}}
</code></pre>
<p class="normal">This is the most complex template required by the example. The <code class="inlinecode">increment</code> helper is used to create the URL that the browser will request when the anchor element is clicked:</p>
<pre class="programlisting"><code class="hljs-code">...
href="/dynamic/counter?c=<strong class="screentext">{{ increment req.query.c }}</strong>"&gt;
...
</code></pre>
<p class="normal">The double curly braces denote a template expression that can be formatted for HTML safety. This expression invokes the <code class="inlinecode">increment</code> helper and uses the value of the query parameter as the argument. The helper will increment the value it receives, and the result will be included in the value for the anchor element’s <code class="inlinecode">href</code> attribute.</p>
<p class="normal">The other expressions are more complex. First, there is an <code class="inlinecode">if</code>/<code class="inlinecode">else</code> expression, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
<strong class="screentext">{{#if (isOdd req.query.c) }}</strong>
    {{&gt; odd }}
<strong class="screentext">{{else}}</strong>
    {{&gt; even }}
<strong class="screentext">{{/if}}</strong>
...
</code></pre>
<p class="normal">The <code class="inlinecode">#if</code> expression<a id="_idIndexMarker512" class="calibre3"/> is evaluated, and the result is used to determine whether the content in the first or second block is included in the result. In this example, the outcomes apply further template expressions:</p>
<pre class="programlisting"><code class="hljs-code">...
{{#if (isOdd req.query.c)}}
    <strong class="screentext">{{&gt; odd }}</strong>
{{else}}
    <strong class="screentext">{{&gt; even }}</strong>
{{/if}}
...
</code></pre>
<p class="normal">The <code class="inlinecode">&gt;</code> character tells the template engine to load a partial template. If the <code class="inlinecode">#if</code> expression is <code class="inlinecode">true</code>, then the <code class="inlinecode">odd</code> partial will be used, otherwise it will be the <code class="inlinecode">even</code> partial. <em class="italic">Table 10.3</em> describes the most useful template features. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">You must not insert a space (or any other character) between the <code class="inlinecode">{{</code> sequence and the rest of the expression, otherwise the template engine will report an error. So, <code class="inlinecode">{{/if }}</code> is OK but <code class="inlinecode">{{ /if }}</code> won’t work.</p>
</div>
<p class="packt_figref">Table 10.3: Useful template features</p>
<table class="table-container" id="table003-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">{{#if val}}</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">Content will be included in the output if the value in the expression is <code class="inlinecode">true</code>. There is also an <code class="inlinecode">
                {{else }}</code> clause that can be used to create an <code class="inlinecode">if/then/else</code> effect.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">{{#unless val}}</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">Content will be included in the output if the value in the expression is <code class="inlinecode">false</code>. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">{{&gt; partial }}</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This expression inserts the specified partial template into the result.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">{{each arr }}</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This expression repeats a set of elements for each item in an array, as demonstrated in <em class="italic">Chapter 12</em>.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">To create the partial template for even values, create the <code class="inlinecode">templates/server/partials</code> folder and add to it a file named <code class="inlinecode">even.handlebars</code> with the content shown in <em class="italic">Listing 10.25</em>.</p>
<p class="packt_figref">Listing 10.25: The contents of the even.handlebars file in the templates/server/partials folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4 class="bg-secondary text-white m-2 p-2"&gt;
    Handlebars Even value: {{ valueOrZero req.query.c }}
&lt;/h4&gt;
</code></pre>
<p class="normal">The <a id="_idIndexMarker513" class="calibre3"/>partial template contains an expression that uses the <code class="inlinecode">valueOrZero</code> helper to display the <code class="inlinecode">c</code> value from the query string or zero if there is no value. Add a file named <code class="inlinecode">odd.handlebars</code> to the <code class="inlinecode">templates/server/partials</code> folder with the content shown in <em class="italic">Listing 10.26</em>.</p>
<p class="packt_figref">Listing 10.26: The contents of the odd.handlebars file in the templates/server/partial folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4 class="bg-primary text-white m-2 p-2"&gt;
    Handlebars Odd value: {{ valueOrZero req.query.c}}
&lt;/h4&gt;
</code></pre>
<p class="normal">There are other ways to recreate the example using Handlebars, which has some excellent features, but this approach most closely matches the custom engine that was created earlier. The final step is to configure the application to use Handlebars, as shown in <em class="italic">Listing 10.27</em>.</p>
<p class="packt_figref">Listing 10.27: Setting up the template engine in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { testHandler } from "./testHandler";
import httpProxy from "http-proxy";
import helmet from "helmet";
<strong class="screentext">//import { registerCustomTemplateEngine } from "./custom_engine";</strong>
<strong class="screentext">import { engine } from "express-handlebars";</strong>
<strong class="screentext">import * as helpers from "./template_helpers"</strong><strong class="screentext">;</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
<strong class="screentext">//registerCustomTemplateEngine(expressApp);</strong>
expressApp.set("views", "templates/server");
<strong class="screentext">expressApp.engine("handlebars", engine</strong><strong class="screentext">());</strong>
<strong class="screentext">expressApp.set("view engine", "handlebars");</strong>
expressApp.use(helmet());
expressApp.use(express.json());
<strong class="screentext">expressApp.get("/dynamic/:file"</strong><strong class="screentext">, (req, resp) =&gt; {</strong>
<strong class="screentext">    resp.render(`${req.params.file}.handlebars`,</strong>
<strong class="screentext">        { message: "Hello template", req,</strong>
<strong class="screentext">            helpers: { ...helpers }</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">});</strong>
expressApp.post("/test", testHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <code class="inlinecode">express-handlebars</code> package is used to integrate the Handlebars template engine into Express. One difference is that the help functions are added to the context<a id="_idIndexMarker514" class="calibre3"/> object that is used to render the template, but otherwise, the configuration is similar to the custom engine.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The integration of Handlebars with Express provides support for providing extra data values, known as locals, outside of the call to the <code class="inlinecode">render</code> method. <em class="italic">Chapter 15</em> demonstrates the use of this feature to include authentication details in the template.</p>
</div>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/dynamic/counter</code> and you will see the round-trip application but rendered by a real template package, with the addition of the word “Handlebars” in the partial templates to emphasize the change, as shown in <em class="italic">Figure 10.8</em>.</p>
<figure class="mediaobject"><img alt="" src="img/Image11047.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.8: Using a package for server-side templates</p>
<h2 class="heading1" id="_idParaDest-188">Using a package for client-side templates</h2>
<p class="normal1">Many<a id="_idIndexMarker515" class="calibre3"/> template packages can also be used in the browser to create client-side templating, but this requires wrapping templates in <code class="inlinecode">script</code> elements in the HTML documents sent to the browser, which is awkward to do. For this reason, most template packages offer integrations with popular build tools and bundlers, such as webpack, that compile templates into JavaScript code. Run the command shown in <em class="italic">Listing 10.28</em> in the <code class="inlinecode">part2app</code> folder to add a package that integrates Handlebars into webpack. </p>
<p class="packt_figref">Listing 10.28: Installing an integration package</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev handlebars-loader@1.7.3
</code></pre>
<p class="normal">A change is <a id="_idIndexMarker516" class="calibre3"/>required to the webpack configuration file to add support for compiling Handlebars templates, as shown in <em class="italic">Listing 10.29</em>.</p>
<p class="packt_figref">Listing 10.29: Changing the configuration in the webpack.config.mjs file in the part2app folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./src/client/client.js",
    devtool: "source-map",   
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
    },
    devServer: {
        static: ["./static"],        
        port: 5100,
        client: { webSocketURL: "http://localhost:5000/ws" }
    },
  <strong class="screentext">  module: {</strong>
<strong class="screentext">        rules: [</strong>
<strong class="screentext">            { test: /\.handlebars$/, loader: "handlebars-loader" }</strong>
<strong class="screentext">          ]</strong>
<strong class="screentext">    },</strong>
<strong class="screentext">    resolve: {</strong>
<strong class="screentext"> </strong><strong class="screentext">alias: {</strong>
<strong class="screentext">            "@templates": path.resolve(__dirname, "templates/client")</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
};
</code></pre>
<p class="normal">The <code class="inlinecode">module</code> configuration section adds support for processing Handlebars templates. The <code class="inlinecode">resolve</code> section creates an alias so that JavaScript files created from templates can be imported with <code class="inlinecode">@templates</code>, rather than using a relative path in an <code class="inlinecode">import</code> statement.</p>
<p class="normal">Webpack <a id="_idIndexMarker517" class="calibre3"/>doesn’t detect changes to its configuration file, so stop the build tools and run the <code class="inlinecode">npm start</code> command again so the new configuration takes effect.</p>
<p class="normal">To define the client-side template, add a file named <code class="inlinecode">counter_client.handlebars</code> in the <code class="inlinecode">templates/client</code> folder with the content shown in <em class="italic">Listing 10.30</em>.</p>
<p class="packt_figref">Listing 10.30: The contents of the counter_client.handlebars file in the templates/client folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;button class="btn btn-primary m-2" action="incrementCounter"&gt;
    Increment
&lt;/button&gt;
&lt;div&gt;
    {{#if (isOdd counter) }}
        &lt;h4 class="bg-primary text-white m-2 p-2"&gt;
            Client Odd Value: {{ counter }}
        &lt;/h4&gt;               
    {{else}}
        &lt;h4 class="bg-secondary text-white m-2 p-2"&gt;
            Client Even Value: {{ counter }}
        &lt;/h4&gt;      
    {{/if}}
&lt;/div&gt;
</code></pre>
<p class="normal">All the Handlebars features are available in client-side templates, including partial templates, but I have combined everything for simplicity. The content security policy restrictions on inline event handlers still apply and so I have used the <code class="inlinecode">action</code> attribute on the <code class="inlinecode">button</code> element to identify what action should be performed when the button is clicked.</p>
<p class="normal">Only one helper is required on the client side. Add a file named <code class="inlinecode">isOdd.js</code> to the <code class="inlinecode">templates/client</code> folder with the contents shown in <em class="italic">Listing 10.31</em>.</p>
<p class="packt_figref">Listing 10.31: The contents of the isOdd.js file in the templates/client folder</p>
<pre class="programlisting"><code class="hljs-code">export default (value) =&gt; value % 2;
</code></pre>
<p class="normal">The location of files is specified by the <code class="inlinecode">handlebars-loader</code> package and the default <a id="_idIndexMarker518" class="calibre3"/>configuration has template helper functions defined in individual files with the helper name used as the filename, alongside the templates that use them. <em class="italic">Listing 10.32</em> updates the <code class="inlinecode">client.js</code> file to use the Handlebars template.</p>
<p class="packt_figref">Listing 10.32: Using a template in the client.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">//import { Counter } from "./counter_custom";</strong>
<strong class="screentext">import * as</strong><strong class="screentext"> Counter from "@templates/counter_client.handlebars";</strong>
const context = {
    counter: 0
}
const actions = {
    incrementCounter: () =&gt; {
        context.counter++; render();
    }
}
const render = () =&gt; {
    document.getElementById("target").innerHTML = Counter(context);
}
document.addEventListener('DOMContentLoaded', () =&gt; {
    document.onclick = (ev) =&gt; {
        const action = ev.target.getAttribute("action")
        if (action &amp;&amp; actions[action]) {
            actions[action]()
        }
    }
    render();
});
</code></pre>
<p class="normal">The compiled template is a drop-in replacement for the custom function I defined earlier in the chapter. When webpack builds the client-side bundle, the Handlebars template files are compiled into JavaScript. (You may receive a build error when you save the changes in <em class="italic">Listing 10.32</em>. If that happens, stop the development tools, and start them again using the <code class="inlinecode">npm start</code> command).</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code> and you will see the client-side <a id="_idIndexMarker519" class="calibre3"/>application, as shown in <em class="italic">Figure 10.9</em>.</p>
<figure class="mediaobject"><img alt="" src="img/Image11054.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 10.9: Using a package for client-side templates</p>
<h1 class="heading" id="_idParaDest-189">Summary</h1>
<p class="normal1">In this chapter, I demonstrated how server-side and client-side templates work, and how they can be used to generate HTML content. The following information was also covered:</p>
<ul class="calibre4">
<li class="bulletlist">Templates are a mix of static content with placeholders for data values.</li>
<li class="bulletlist1">When a template is rendered, the result is an HTML document or fragment that reflects the current state of the application.</li>
<li class="bulletlist1">Templates can be rendered by Node.js, as server-side templates, or by JavaScript running in the browser, as client-side templates.</li>
<li class="bulletlist1">Client-side templates are usually compiled into JavaScript functions so they can be easily rendered by the browser.</li>
<li class="bulletlist1">There are many good open-source template packages available, all of which offer similar features, but use different template file formats.</li>
</ul>
<p class="normal">In the next chapter, I will explain how you can use HTML forms to receive data from the user, and how to validate the data when it is received.</p>
</div>
</body></html>