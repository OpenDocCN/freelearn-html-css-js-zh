- en: Chapter 8. Data Persistence through REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we''ve been dealing with frontend aspects of Ember.js-powered
    applications. Your typical application will, however, need to connect to backend
    services such as databases. Ember.js makes this simple by integrating solutions
    for such needs. This chapter assumes no knowledge of server-side technologies,
    but it will attempt to explain any samples that contain server-side code as clearly
    as possible. Ensure that you also attempt the given exercises in order to understand
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making Ajax requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Ember-data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating data stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring model relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a store's adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing a store's serializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Ajax requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most web applications communicate with backend services through either of the
    following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will mainly deal with Ajax, which enables client applications
    to send asynchronous requests to remote services through the use of `XMLHttpRequests`.
    Web sockets will be handled in a later chapter, but we''ll find that many concepts
    used will be related. Here''s an example of a `POST` request to a music catalog
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is obviously boilerplate code, and jQuery makes this as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are numerous ways we could integrate this into an Ember.js application.
    For example, if this was to be initiated after a form submission, we could implement
    it in a `save` action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user submits the provided form, the index controller''s `saveAlbum`
    action would be called to post the album to the server using jQuery. Ideally,
    we could create an `album` class to separate concerns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this class, we could then do a final refactor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we may wish to load the saved albums from the server to present
    to the user. A simple way would be to implement a `find` class method to load
    these albums, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example adds a static class method to the `Album` class, which would then
    be used to query the backend for albums, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is a common practice, the Ember.js community also maintains another
    project called **Ember-data** ([http://github.com/emberjs/data](http://github.com/emberjs/data))
    and that aims to abstract such needs. This chapter is, therefore, going to walk
    us through using Ember-data in RESTful applications. These applications use **REST**
    (**Representational State Transfer**), which, as we know, lets us consume APIs
    that use some of the following HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Ember-data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ember-data is another ambitious, opinionated, open source project used to develop
    applications that need to communicate with backend database services. A suitable
    version can be downloaded from [http://builds.emberjs.com/](http://builds.emberjs.com/).
    In our case, we will be using Version 1.0.0-beta.9 build that is already included
    in the chapter samples. These samples define a simple **Todos** application implementation
    of [http://github.com/component/todo](http://github.com/component/todo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Ember-data](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be using the `fixtures-adapter` sample first, which you can load via
    the `index.html` file. This application enables users to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load saved todos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and save new todos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter loaded todos by state (complete versus incomplete todos)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember-data namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ember-data library utilizes its own global namespace named `DS`, from which
    we will be referencing commonly-used classes such as `DS.Store` and `DS.Model`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications that use Ember-data usually use a single storage repository that
    stores all records that are available to the application. This store is defined
    from the `DS.Store` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is automatically executed by Ember.js, and so we do not
    need to do anything. Just like the router, this class is usually autoinstantiated
    and made accessible to all routes and controllers as a `store` property. Here''s
    an example that demonstrates a route that accesses the application''s store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry about what this does. The important thing to learn from the preceding
    snippet is how the store instance is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the introductory chapters, we learned how to organize application objects
    into reusable classes called `models`. Ember-data provides support for defining
    such models that extend `DS.Model`, and from which records can then be created.
    For example, let''s review the `Todo` model that was defined in the samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As illustrated, the model was defined by extending the `DS.Model` class. We
    then defined two attributes using the `DS.attr` class methods that take two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional options object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attribute''s type is usually one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we learn later that it's possible to define other custom types. The
    options object commonly contains a `defaultValue` property, which could be a value
    or a function that evaluates to the value to be used as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records in our application may be related; thus, Ember-data supports defining
    some of the following common relations:'
  prefs: []
  type: TYPE_NORMAL
- en: One-one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this type of relation, only one model can belong to the other. For example,
    we can define two objects, a person and a passport, where the person only owns
    one passport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finding records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ember-data provides various ways to query loaded records as well to pull new
    ones from backend services. To find all records of a particular model, we can
    simply utilize the store''s `find` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This method loads all todos from the server via a promise that we then consume,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we, however, want to only query loaded records, we can use the store''s
    `all` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we may want to query a record by a given `id`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Querying records by search terms is also as easy as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining a store's adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every store needs an adapter that sits at the network layer, where it makes
    the actual API request calls. This is what differentiates the two variants of
    our Todos application, where each of its stores defines an adapter that communicates
    with different remote data stores. For example, the first sample defines its adapter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All adapters need to implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findQuery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createRecord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateRecord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteRecord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These adapters enable applications to stay in sync with various data stores
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Local caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser's local storage or indexdb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote databases through REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote databases through RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote databases through WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These adapters are, therefore, swappable in case applications need to use different
    data providers. Ember-data comes with two built-in adapters: the `fixtures-adapter`
    and the `rest-adapter`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixtures adapter uses an in-browser cache to store the application''s records.
    This adapter is especially useful when the backend service of the project is either
    inaccessible for testing or is still being developed. When using this adapter,
    it may be necessary to add initial data called fixtures to mock out the existing
    records. These records can be loaded into the application''s store by adding them
    in the `FIXTURES` property of the affected model, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once satisfied with the workings of the models, we may then swap out the fixtures
    adapter with the `rest-adapter`, that as you guessed, communicates with remote
    data stores through REST. The second sample includes a simple Node.js server (Server.js)
    that uses Express.js ([http://expressjs.com](http://expressjs.com)) to demonstrate
    the use of this adapter. To test the application, you will need to install Node.js
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download your platform's Node.js binary at [http://nodejs.org/download/](http://nodejs.org/download/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Un-archive the downloaded package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the location of the `bin` directory inside the un-archived directory into
    your environment `PATH` setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test out the installation by running `node` in a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start the application, navigate to the `rest-adapter` sample directory and
    then simply run the following two commands in your shell emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, visit `http://localhost:5000` in your browser. We notice that the two
    applications are different in that the latter persists data to the running backend.
    If we add new todos and visit a new tab, we will realize that the new changes
    are reflected. The application, however, does not persist the changes in a real
    database as this is out of the scope of this book. Therefore, as an exercise,
    try and reimplement this sample in your favorite server-side stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest-adapter makes a few assumptions that our todos server API must adhere
    to, shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Request HTTP verb | Request URL | RequestJSON payload | Response
    JSON data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Create` | `POST` | `/todos` | `{todo: data}` | `{todo: data} or id` |'
  prefs: []
  type: TYPE_TB
- en: '| `Find all` | `GET` | `/todos` | `None` | `{todo: data}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Find query` | `GET` | `/todos?complete=true` | `None` | `{todo: data}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Find one` | `GET` | `/todos/1` | `None` | `{todo: data}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Update` | `UPDATE` | `/todos/1` | `{todo: data}` | `{todo: data} or None`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Delete` | `DELETE` | `/todos/1` | `None` | `None` |'
  prefs: []
  type: TYPE_TB
- en: This implementation can be found in the `api.js` module. Therefore, it is wise
    to use such a format when creating new APIs that are primarily consumed by Ember-data
    applications. This convention is also documented at [http://jsonapi.org/](http://jsonapi.org/),
    which may be a great resource for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Related objects can also be loaded in a similar way. For example, in our *tweet-retweet*
    case, we could load retweets of a particular tweet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that Ember-data expects that the property in the response data that
    contains the related objects should be named as the pluralized form of the related
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the API can only send the IDs of the related objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Ember-data will then *side-load* the corresponding objects into the data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a model may have more than one relation of the same model. For example,
    a typical Facebook user has followers and followings, whose model can then be
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Ember-data will then expect the response data to contain a list of related
    objects named `users`. However, since there is more than one attribute that depends
    on the user model, we can easily resolve this by using the `inverse` option, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can then return a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application consumes APIs from different endpoints, we will need to
    define different adapters for each of the models, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, adapters can be customized in many different
    ways in order to meet the needs of your APIs and domain logic. This ensures that
    the existing APIs can still be consumed easily rather than having to build separate
    API endpoints reserved for Ember-data applications.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a store's serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to a store''s adapter, all stores have a serializer that serializes
    and deserializes data that comes in and out of the application. For example, if
    the data models in our backend use primary keys other than `id`, we can easily
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this could also be specified per model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transformations are the different types of model attributes. Application authors
    are not limited to the built-in ones, so they may define their own transformations
    easily. For example, one of our backend services may represent Booleans as zeros
    and ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We could create a transformation that resolves these values where necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We just created a new transformation by extending `DS.Transform` and then defining
    the following two methods that act on the attribute''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serialize`: This converts the attribute value to a form acceptable by the
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deserialize`: This converts the value loaded from the server into what the
    application will use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then easily use this new type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed how to use Ember-data to create applications
    that need to communicate with backend storage services through REST. We have learned
    how to create records from defined models as well as updating and deleting them.
    We have also learned the different customizations we would need to make in order
    to consume existing APIs as much as possible. We should, therefore, be comfortable
    enough to start writing any client-side applications backed by REST APIs. As we
    proceed to the other exciting chapters, we should start thinking of how web sockets,
    JSONP, and RPC can be integrated with Ember-data seamlessly.
  prefs: []
  type: TYPE_NORMAL
