- en: Chapter 8. Data Persistence through REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 通过 REST 实现数据持久化
- en: 'Up to this point, we''ve been dealing with frontend aspects of Ember.js-powered
    applications. Your typical application will, however, need to connect to backend
    services such as databases. Ember.js makes this simple by integrating solutions
    for such needs. This chapter assumes no knowledge of server-side technologies,
    but it will attempt to explain any samples that contain server-side code as clearly
    as possible. Ensure that you also attempt the given exercises in order to understand
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理由 Ember.js 驱动的应用程序的前端方面。然而，您的典型应用程序将需要连接到后端服务，例如数据库。Ember.js 通过集成满足此类需求解决方案使其变得简单。本章假设您对服务器端技术没有了解，但它将尽可能清晰地解释包含服务器端代码的任何示例。确保您也尝试完成给定的练习，以便理解以下内容：
- en: Making Ajax requests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 Ajax 请求
- en: Understanding Ember-data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Ember-data
- en: Creating data stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据存储
- en: Defining models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模型
- en: Declaring model relations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明模型关系
- en: Creating records
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建记录
- en: Updating records
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新记录
- en: Deleting records
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除记录
- en: Persisting data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化数据
- en: Finding records
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找记录
- en: Defining a store's adapter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义存储适配器
- en: Creating REST APIs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 REST API
- en: Customizing a store's serializer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义存储序列化器
- en: Making Ajax requests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 Ajax 请求
- en: 'Most web applications communicate with backend services through either of the
    following technologies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序通过以下两种技术之一与后端服务进行通信：
- en: Web sockets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web sockets
- en: Ajax
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax
- en: 'This chapter will mainly deal with Ajax, which enables client applications
    to send asynchronous requests to remote services through the use of `XMLHttpRequests`.
    Web sockets will be handled in a later chapter, but we''ll find that many concepts
    used will be related. Here''s an example of a `POST` request to a music catalog
    endpoint:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要处理 Ajax，它通过使用 `XMLHttpRequests` 允许客户端应用程序向远程服务发送异步请求。Web sockets 将在后面的章节中处理，但我们会发现许多概念是相关的。以下是一个向音乐目录端点发送
    `POST` 请求的示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is obviously boilerplate code, and jQuery makes this as simple as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是样板代码，jQuery 使其变得非常简单：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are numerous ways we could integrate this into an Ember.js application.
    For example, if this was to be initiated after a form submission, we could implement
    it in a `save` action, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有无数种方法可以将这些集成到 Ember.js 应用程序中。例如，如果这是在表单提交后启动的，我们可以在 `save` 动作中实现它，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When a user submits the provided form, the index controller''s `saveAlbum`
    action would be called to post the album to the server using jQuery. Ideally,
    we could create an `album` class to separate concerns, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交提供的表单时，索引控制器的 `saveAlbum` 动作会被调用，使用 jQuery 将专辑发布到服务器。理想情况下，我们可以创建一个 `album`
    类来分离关注点，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this class, we could then do a final refactor, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个课程，我们就可以进行最后的重构，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition, we may wish to load the saved albums from the server to present
    to the user. A simple way would be to implement a `find` class method to load
    these albums, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能希望从服务器加载已保存的专辑以向用户展示。一种简单的方法是实现一个 `find` 类方法来加载这些专辑，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example adds a static class method to the `Album` class, which would then
    be used to query the backend for albums, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例向 `Album` 类添加了一个静态类方法，然后可以使用它来查询后端专辑，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As this is a common practice, the Ember.js community also maintains another
    project called **Ember-data** ([http://github.com/emberjs/data](http://github.com/emberjs/data))
    and that aims to abstract such needs. This chapter is, therefore, going to walk
    us through using Ember-data in RESTful applications. These applications use **REST**
    (**Representational State Transfer**), which, as we know, lets us consume APIs
    that use some of the following HTTP verbs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个常见的做法，Ember.js 社区还维护了另一个名为 **Ember-data** 的项目（[http://github.com/emberjs/data](http://github.com/emberjs/data)），该项目的目标是抽象化此类需求。因此，本章将带我们了解如何在
    RESTful 应用程序中使用 Ember-data。这些应用程序使用 **REST**（**表示状态传输**），正如我们所知，它允许我们消费使用以下 HTTP
    动词的一些 API：
- en: '`GET`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`POST`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`DELETE`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: Understanding Ember-data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Ember-data
- en: 'Ember-data is another ambitious, opinionated, open source project used to develop
    applications that need to communicate with backend database services. A suitable
    version can be downloaded from [http://builds.emberjs.com/](http://builds.emberjs.com/).
    In our case, we will be using Version 1.0.0-beta.9 build that is already included
    in the chapter samples. These samples define a simple **Todos** application implementation
    of [http://github.com/component/todo](http://github.com/component/todo):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ember-data 是另一个雄心勃勃、有观点的开源项目，用于开发需要与后端数据库服务通信的应用程序。可以从 [http://builds.emberjs.com/](http://builds.emberjs.com/)
    下载合适的版本。在我们的案例中，我们将使用已包含在章节示例中的 1.0.0-beta.9 版本构建。这些示例定义了一个简单的 **Todos** 应用程序实现，位于
    [http://github.com/component/todo](http://github.com/component/todo)：
- en: '![Understanding Ember-data](img/00012.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Ember-data](img/00012.jpeg)'
- en: 'We will be using the `fixtures-adapter` sample first, which you can load via
    the `index.html` file. This application enables users to do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `fixtures-adapter` 示例，您可以通过 `index.html` 文件来加载它。此应用程序允许用户执行以下操作：
- en: Load saved todos
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载保存的待办事项
- en: Create and save new todos
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并保存新的待办事项
- en: Filter loaded todos by state (complete versus incomplete todos)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过状态（已完成与未完成）过滤已加载的待办事项
- en: Ember-data namespace
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ember-data 命名空间
- en: The Ember-data library utilizes its own global namespace named `DS`, from which
    we will be referencing commonly-used classes such as `DS.Store` and `DS.Model`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ember-data 库利用其自己的全局命名空间 `DS`，我们将从其中引用常用类，如 `DS.Store` 和 `DS.Model`。
- en: Creating a data store
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据存储
- en: 'Applications that use Ember-data usually use a single storage repository that
    stores all records that are available to the application. This store is defined
    from the `DS.Store` class, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ember-data 的应用程序通常使用单个存储库，该存储库存储所有可供应用程序使用的记录。此存储库由 `DS.Store` 类定义，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is automatically executed by Ember.js, and so we do not
    need to do anything. Just like the router, this class is usually autoinstantiated
    and made accessible to all routes and controllers as a `store` property. Here''s
    an example that demonstrates a route that accesses the application''s store:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将由 Ember.js 自动执行，因此我们不需要做任何事情。就像路由器一样，这个类通常会被自动实例化，并作为 `store` 属性对所有路由和控制器可用。以下是一个演示如何访问应用程序存储的示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do not worry about what this does. The important thing to learn from the preceding
    snippet is how the store instance is accessed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这会做什么。从前面代码片段中学习的重要事情是如何访问存储实例。
- en: Defining models
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型
- en: 'In the introductory chapters, we learned how to organize application objects
    into reusable classes called `models`. Ember-data provides support for defining
    such models that extend `DS.Model`, and from which records can then be created.
    For example, let''s review the `Todo` model that was defined in the samples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍性章节中，我们学习了如何将应用程序对象组织成可重用的类，称为 `models`。Ember-data 提供了对定义此类模型的支撑，这些模型扩展 `DS.Model`，然后可以从中创建记录。例如，让我们回顾一下在示例中定义的
    `Todo` 模型：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As illustrated, the model was defined by extending the `DS.Model` class. We
    then defined two attributes using the `DS.attr` class methods that take two arguments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，模型是通过扩展 `DS.Model` 类定义的。然后我们使用 `DS.attr` 类方法定义了两个属性，该方法接受两个参数：
- en: The name of the attribute
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的名称
- en: An optional options object
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的选项对象
- en: 'The attribute''s type is usually one of the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的类型通常是以下之一：
- en: String
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Number
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Date
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Boolean
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: However, we learn later that it's possible to define other custom types. The
    options object commonly contains a `defaultValue` property, which could be a value
    or a function that evaluates to the value to be used as the default.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们稍后了解到，可以定义其他自定义类型。选项对象通常包含一个 `defaultValue` 属性，它可以是值或函数，该函数评估为用作默认值的值。
- en: Declaring relations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明关系
- en: 'Records in our application may be related; thus, Ember-data supports defining
    some of the following common relations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的记录可能相关；因此，Ember-data 支持定义以下常见关系：
- en: One-one
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一
- en: One-many
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多
- en: Many-many
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多
- en: One to one
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: 'In this type of relation, only one model can belong to the other. For example,
    we can define two objects, a person and a passport, where the person only owns
    one passport:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种关系类型中，只有一个模型可以属于另一个。例如，我们可以定义两个对象，一个人和一个护照，其中这个人只拥有一本护照：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finding records
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找记录
- en: 'Ember-data provides various ways to query loaded records as well to pull new
    ones from backend services. To find all records of a particular model, we can
    simply utilize the store''s `find` method, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ember-data提供了各种方法来查询已加载的记录，以及从后端服务拉取新的记录。要查找特定模型的全部记录，我们可以简单地利用存储的`find`方法，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method loads all todos from the server via a promise that we then consume,
    shown as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过一个我们随后消费的承诺从服务器加载所有待办事项，如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we, however, want to only query loaded records, we can use the store''s
    `all` method, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想查询已加载的记录，我们可以使用存储的`all`方法，如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, we may want to query a record by a given `id`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可能想通过给定的`id`查询一个记录，如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Querying records by search terms is also as easy as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过搜索词查询记录同样简单：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Defining a store's adapter
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义商店的适配器
- en: 'Every store needs an adapter that sits at the network layer, where it makes
    the actual API request calls. This is what differentiates the two variants of
    our Todos application, where each of its stores defines an adapter that communicates
    with different remote data stores. For example, the first sample defines its adapter
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个商店都需要一个位于网络层的适配器，在那里它执行实际的API请求调用。这就是我们的Todos应用程序的两个变体之间的区别，其中每个商店定义了一个与不同远程数据存储进行通信的适配器。例如，第一个示例如下定义其适配器：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All adapters need to implement the following methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有适配器都需要实现以下方法：
- en: '`find`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`'
- en: '`findAll`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAll`'
- en: '`findQuery`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findQuery`'
- en: '`createRecord`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createRecord`'
- en: '`updateRecord`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateRecord`'
- en: '`deleteRecord`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteRecord`'
- en: 'These adapters enable applications to stay in sync with various data stores
    such as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器使应用程序能够与各种数据存储保持同步，例如：
- en: Local caches
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地缓存
- en: A browser's local storage or indexdb
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的本地存储或indexdb
- en: Remote databases through REST
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过REST的远程数据库
- en: Remote databases through RPC
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过RPC的远程数据库
- en: Remote databases through WebSockets
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebSockets的远程数据库
- en: 'These adapters are, therefore, swappable in case applications need to use different
    data providers. Ember-data comes with two built-in adapters: the `fixtures-adapter`
    and the `rest-adapter`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果应用程序需要使用不同的数据提供者，这些适配器是可以互换的。Ember-data自带两个内置适配器：`fixtures-adapter`和`rest-adapter`。
- en: 'The fixtures adapter uses an in-browser cache to store the application''s records.
    This adapter is especially useful when the backend service of the project is either
    inaccessible for testing or is still being developed. When using this adapter,
    it may be necessary to add initial data called fixtures to mock out the existing
    records. These records can be loaded into the application''s store by adding them
    in the `FIXTURES` property of the affected model, shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: fixtures 适配器使用浏览器内的缓存来存储应用程序的记录。此适配器在项目的后端服务因测试不可用或仍在开发时特别有用。使用此适配器时，可能需要添加初始数据，称为
    fixtures，以模拟现有记录。这些记录可以通过在受影响的模型的`FIXTURES`属性中添加它们来加载到应用程序的存储中，如下所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating REST APIs
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建REST API
- en: 'Once satisfied with the workings of the models, we may then swap out the fixtures
    adapter with the `rest-adapter`, that as you guessed, communicates with remote
    data stores through REST. The second sample includes a simple Node.js server (Server.js)
    that uses Express.js ([http://expressjs.com](http://expressjs.com)) to demonstrate
    the use of this adapter. To test the application, you will need to install Node.js
    by following these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对模型的工作原理感到满意，我们就可以用`rest-adapter`替换掉 fixtures 适配器，正如你所猜想的，它通过REST与远程数据存储进行通信。第二个示例包括一个简单的Node.js服务器（Server.js），它使用Express.js
    ([http://expressjs.com](http://expressjs.com)) 来演示此适配器的使用。为了测试应用程序，你需要按照以下步骤安装Node.js：
- en: Download your platform's Node.js binary at [http://nodejs.org/download/](http://nodejs.org/download/).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [http://nodejs.org/download/](http://nodejs.org/download/) 下载你平台的Node.js二进制文件。
- en: Un-archive the downloaded package.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载的包。
- en: Add the location of the `bin` directory inside the un-archived directory into
    your environment `PATH` setting.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未存档目录中的`bin`目录的位置添加到你的环境`PATH`设置中。
- en: Test out the installation by running `node` in a terminal.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`node`来测试安装。
- en: 'To start the application, navigate to the `rest-adapter` sample directory and
    then simply run the following two commands in your shell emulator:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序，请导航到`rest-adapter`示例目录，然后在你的shell模拟器中简单地运行以下两个命令：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, visit `http://localhost:5000` in your browser. We notice that the two
    applications are different in that the latter persists data to the running backend.
    If we add new todos and visit a new tab, we will realize that the new changes
    are reflected. The application, however, does not persist the changes in a real
    database as this is out of the scope of this book. Therefore, as an exercise,
    try and reimplement this sample in your favorite server-side stack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的浏览器中访问`http://localhost:5000`。我们注意到，两个应用程序的不同之处在于后者将数据持久化到运行的后端。如果我们添加新的待办事项并访问新标签页，我们会意识到新更改已反映出来。然而，该应用程序不会将更改持久化到真实数据库中，因为这超出了本书的范围。因此，作为一个练习，尝试在您喜欢的服务器端堆栈中重新实现此示例。
- en: 'The rest-adapter makes a few assumptions that our todos server API must adhere
    to, shown in the following table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Rest-adapter对我们的待办事项服务器API必须遵守的一些假设如下表所示：
- en: '| Action | Request HTTP verb | Request URL | RequestJSON payload | Response
    JSON data |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 请求HTTP动词 | 请求URL | 请求JSON有效负载 | 响应JSON数据 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `Create` | `POST` | `/todos` | `{todo: data}` | `{todo: data} or id` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Create` | `POST` | `/todos` | `{todo: data}` | `{todo: data} or id` |'
- en: '| `Find all` | `GET` | `/todos` | `None` | `{todo: data}` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Find all` | `GET` | `/todos` | `None` | `{todo: data}` |'
- en: '| `Find query` | `GET` | `/todos?complete=true` | `None` | `{todo: data}` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Find query` | `GET` | `/todos?complete=true` | `None` | `{todo: data}` |'
- en: '| `Find one` | `GET` | `/todos/1` | `None` | `{todo: data}` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Find one` | `GET` | `/todos/1` | `None` | `{todo: data}` |'
- en: '| `Update` | `UPDATE` | `/todos/1` | `{todo: data}` | `{todo: data} or None`
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Update` | `UPDATE` | `/todos/1` | `{todo: data}` | `{todo: data} or None`
    |'
- en: '| `Delete` | `DELETE` | `/todos/1` | `None` | `None` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Delete` | `DELETE` | `/todos/1` | `None` | `None` |'
- en: This implementation can be found in the `api.js` module. Therefore, it is wise
    to use such a format when creating new APIs that are primarily consumed by Ember-data
    applications. This convention is also documented at [http://jsonapi.org/](http://jsonapi.org/),
    which may be a great resource for you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现可以在`api.js`模块中找到。因此，在创建主要供Ember-data应用程序消费的新API时使用此格式是明智的。此约定也在[http://jsonapi.org/](http://jsonapi.org/)中进行了记录，这可能是一个对您非常有用的资源。
- en: 'Related objects can also be loaded in a similar way. For example, in our *tweet-retweet*
    case, we could load retweets of a particular tweet, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 相关对象也可以以类似的方式加载。例如，在我们的*tweet-retweet*案例中，我们可以加载特定推文的转发，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that Ember-data expects that the property in the response data that
    contains the related objects should be named as the pluralized form of the related
    model:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Ember-data期望响应数据中包含相关对象的属性应命名为相关模型的复数形式：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, the API can only send the IDs of the related objects, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，API可以只发送相关对象的ID，如下所示：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ember-data will then *side-load* the corresponding objects into the data store.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ember-data将随后将相应的对象*侧加载*到数据存储中。
- en: 'Sometimes, a model may have more than one relation of the same model. For example,
    a typical Facebook user has followers and followings, whose model can then be
    defined as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个模型可能具有多个相同模型的关联关系。例如，典型的Facebook用户有粉丝和关注者，其模型可以定义为如下：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Ember-data will then expect the response data to contain a list of related
    objects named `users`. However, since there is more than one attribute that depends
    on the user model, we can easily resolve this by using the `inverse` option, as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Ember-data将期望响应数据包含一个名为`users`的相关对象列表。然而，由于有多个属性依赖于用户模型，我们可以通过使用`inverse`选项轻松解决这个问题，如下所示：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this, we can then return a response as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，我们就可以返回如下所示的响应：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the application consumes APIs from different endpoints, we will need to
    define different adapters for each of the models, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序从不同的端点消费API，我们需要为每个模型定义不同的适配器，如下所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As shown in the preceding code, adapters can be customized in many different
    ways in order to meet the needs of your APIs and domain logic. This ensures that
    the existing APIs can still be consumed easily rather than having to build separate
    API endpoints reserved for Ember-data applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，适配器可以以多种不同的方式自定义，以满足您的API和领域逻辑的需求。这确保了现有的API仍然可以轻松消费，而不是必须为Ember-data应用程序构建单独的API端点。
- en: Customizing a store's serializer
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义存储序列化器
- en: 'In addition to a store''s adapter, all stores have a serializer that serializes
    and deserializes data that comes in and out of the application. For example, if
    the data models in our backend use primary keys other than `id`, we can easily
    do this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储的适配器之外，所有存储都包含一个序列化器，该序列化器将应用程序进出数据序列化和反序列化。例如，如果我们的后端数据模型使用除 `id` 之外的主键，我们可以轻松地做到这一点：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that this could also be specified per model, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也可以按模型指定，如下所示：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating custom transformations
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义转换
- en: 'Transformations are the different types of model attributes. Application authors
    are not limited to the built-in ones, so they may define their own transformations
    easily. For example, one of our backend services may represent Booleans as zeros
    and ones:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是不同类型的模型属性。应用程序作者不仅限于内置的转换，因此他们可以轻松地定义自己的转换。例如，我们的后端服务可能将布尔值表示为零和一：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could create a transformation that resolves these values where necessary:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个转换，在必要时解决这些值：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We just created a new transformation by extending `DS.Transform` and then defining
    the following two methods that act on the attribute''s value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过扩展 `DS.Transform` 并定义以下两个作用于属性值的方法来创建了一个新的转换：
- en: '`serialize`: This converts the attribute value to a form acceptable by the
    server'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`序列化`: 这将属性值转换为服务器可接受的格式'
- en: '`deserialize`: This converts the value loaded from the server into what the
    application will use'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`反序列化`: 这将服务器加载的值转换为应用程序将使用的格式'
- en: 'We can then easily use this new type as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松地使用这种新类型，如下所示：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've discussed how to use Ember-data to create applications
    that need to communicate with backend storage services through REST. We have learned
    how to create records from defined models as well as updating and deleting them.
    We have also learned the different customizations we would need to make in order
    to consume existing APIs as much as possible. We should, therefore, be comfortable
    enough to start writing any client-side applications backed by REST APIs. As we
    proceed to the other exciting chapters, we should start thinking of how web sockets,
    JSONP, and RPC can be integrated with Ember-data seamlessly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用 Ember-data 创建需要通过 REST 与后端存储服务通信的应用程序。我们学习了如何从定义的模型中创建记录以及更新和删除它们。我们还学习了为了尽可能多地使用现有
    API，我们需要进行的不同定制。因此，我们应该足够舒适地开始编写任何由 REST API 支持的客户端应用程序。随着我们进入其他令人兴奋的章节，我们应该开始思考如何无缝地将
    WebSocket、JSONP 和 RPC 集成到 Ember-data 中。
