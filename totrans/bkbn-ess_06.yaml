- en: Chapter 6. Creating Client-side Pages with Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll examine Backbone''s `Router` class to learn about the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: How routers simulate browser history to create virtual pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create new `Router` subclasses and instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various mechanisms for defining routing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle special cases, such as nonexistent routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a page view to render routes consistently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone routers enable single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all the Backbone features we've looked at have been enhancements
    to previously existing functionality; Backbone's classes improve on native JavaScript
    classes—`Models` and `Collections`—as well as enhance the functionality of objects
    and arrays, and `Views` improve on the DOM manipulation and event binding that
    jQuery already facilitates.
  prefs: []
  type: TYPE_NORMAL
- en: '`Routers`, however, break this trend. Instead of enhancing something that already
    exists, `Routers` allow you to do something entirely new: create an entire site
    using only a single HTML page. As discussed in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Building a Single-Page Site Using Backbone"), *Building a Single-page
    Site Using Backbone*, single-page applications offer several advantages over traditional
    multipage websites: most notably, enhanced performance and complete client-side
    control over the application. Backbone''s `Router` class is what makes all this
    possible.'
  prefs: []
  type: TYPE_NORMAL
- en: How Routers work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a traditional multipage site, the browser provides both routing and page
    history without the need for any extra effort. When a user visits a URL on the
    site, the browser asks the server for that URL's content, and then when the user
    moves to another URL, the browser tracks the change in the user's browsing history.
    In a Backbone-powered site, however, both of these must be handled by a `Router`
    instead. When the user visits a new page, the `Router` determines which `Views`
    to render, and when they leave that page, the `Router` informs the browser of
    the new history entry. This lets a Backbone-powered site act just like a traditional
    one, including allowing the user to use their browser's `Back` button.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different approaches by which a `Router` can accomplish this,
    and Backbone lets you decide which approach you want to use. The first, and default,
    approach is hash-based routing, which takes advantage of URL fragments (also known
    as named anchors). You've probably seen URLs with these fragments before, for
    instance [www.example.com/foo#bar](http://www.example.com/foo#bar). By using these
    fragments to define the pages of your site, Backbone can both know what page to
    load and can tell the browser how to track the user's movement across pages.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want your users to see hashes in your URLs, Backbone offers a second
    option that relies on the recently added HTML5 pushState technology. While this
    definitely helps URLs look cleaner, the pushState approach comes with a significant
    drawback. Although pushState is available in most web browsers, older browsers,
    such as Internet Explorer 9 and below, do not support it. If you try to use pushState-based
    routing in a browser without support for it, Backbone will instead fall back on
    hash-based routing. Even if only 1 percent of your users have an older browser,
    it still means that these 1 percent users will see a different URL from the rest
    of your users, which may cause confusion if (for instance) users with different
    browsers share links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Routing based on pushState also has a minor drawback: if a user refreshes the
    page on a pushState-powered site, the browser will request that URL from the server.
    This can be solved by simply making your server return your application''s single
    HTML page whenever the browser requests for such a URL. However, given both of
    these drawbacks, using pushState is only recommended if you care strongly about
    the appearance of your URLs and believe that all your users will have modern browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because it's possible to use multiple `Routers` at once (although it's not generally
    recommended, as we'll discuss later in the chapter), Backbone has a separate global
    object known as `Backbone.history` that handles history management. It is important
    to understand, however, that this object doesn't actually replace your browser's
    history; instead, it simply helps to manage what gets added to the history and
    when.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you load a page that uses a Backbone `Router`, you need to invoke the
    `start` method of this history object in order to tell Backbone to begin routing.
    This `start` method also lets you tell Backbone which routing technology you need
    to employ. If you want Backbone to rely on hash-based routing, you can simply
    call the `this` method without any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead you wish to use pushState-based routing, you need to provide one
    extra argument to indicate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Differences between routes and pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes and pages are very similar concepts and are often used interchangeably
    by Backbone programmers. This is natural since routes are essentially just the
    Backbone implementation of pages. However, there are important differences between
    the two, at least when you compare the pages of a multi-page website to the routes
    of a Backbone single-page application.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional, multi-page websites, each new page that the user visits requires
    you to make a new request to the site's server. In a Backbone-powered site, however,
    the user can navigate through as many pages (routes) as they want, making new
    requests only when it is necessary to fetch new data. This feature alone accounts
    for a significant increase in speed on a Backbone-powered site.
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference is that standard web pages trigger an entire page
    load, whereas routes trigger only a specific JavaScript function. This means that
    unlike a traditional application, which has to limit the number of pages (and
    thus the number of HTTP requests) it makes, routes can be used for just about
    any possible change in state. Routes can be used in a similar way to traditional
    web pages, or they can be used for much smaller changes to a page. They can even
    (rarely) be used when there is no change to the DOM at all.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, while Backbone routes have many advantages, they also have some downsides.
    The most important downside is that because they do not refresh the page, existing
    DOM elements, style changes, and event bindings are not cleared automatically.
    This means that you will need to handle these clean-up tasks yourself. Luckily,
    this isn't very difficult to do, especially if you rely on a page view, which
    we will introduce shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all Backbone classes, you can create a new `Router` subclass by using
    `extend`, where the first argument provides the class''s instance properties and
    methods and the second argument provides the static ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `Views`, `Routers` take only a single `options` argument when they
    are instantiated. This argument is completely optional, and the only real option
    it takes is the `routes` option. As mentioned, once the `Router` has been created,
    you will need to run `Backbone.history.start()` before it can handle routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with passing in your routes when you create a `Router` is that
    you have to supply all the routing functions together with your routes, which
    (especially if you have a lot of routes on your site) can easily become messy.
    Instead, many Backbone programmers define their routes on the `Router` class itself,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this approach simplifies the routes' definition and makes them
    more similar to the `events` properties of `Models` and `Collections`. Instead
    of defining routing methods with the routes themselves, you can simply give the
    route the name of a routing method and Backbone will look for that method inside
    the `Router` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a third way to add routes and that is by using Backbone''s `route`
    method. This method takes the `route` as the first argument, the route''s name
    as the second argument, and the route''s handler as the third argument. If the
    third argument is omitted, Backbone will look for a method on the `Router` with
    the same name as the `route` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just as the `on` method of `Models` and `Collections` lets you create event
    bindings after an instance of the class is created, the `route` method of `Routers`
    allows you to define a new route at any time. This means that you can dynamically
    create all your routes on the fly after the `Router` class is created. However,
    just as you would normally want all the pages of your site to be available to
    your user when they first visit it, you will generally want all your routes to
    be available too, which means that you will usually create them in your `Routers
    initialize` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of using the `route` method is that you can apply logic
    to your routes. For instance, let''s say you have several routes on your site
    that are only for administrators. If your `t` can check an `isAdmin` attribute
    of a user `Model`, then it can use this attribute to dynamically add or remove
    these administrator-only routes when the `Router` class is initialized, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, another advantage of using the `route`
    method is that you can organize groups of routes into separate functions. This
    can be useful if you want to turn certain groups of routes on or off together,
    but it can also be useful simply to organize constant routes. In fact, you can
    even define some of your routes in an entirely different file as long as your
    `Router` has access to them, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Route styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to having the choice to decide how you hook up your routes, you
    also have the choice to decide how to define the routes. So far, all the routes
    you've seen have been simple routes; they define a string of characters, and when
    Backbone sees that exact string of characters in the URL, it triggers the appropriate
    routing method. Sometimes, however, you'll want to have routes that are more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that we have a site which sells books and we want to have
    a "learn about a particular book" `route`. If we have a good number of books on
    our site, creating routes for each of them individually might get painful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, there are two alternatives that solve this problem: routing strings
    and regular expression routes. First, let''s look at how regular expression routes
    can solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, we were able to create a single route
    with a regular expression that matches all our possible book routes. Because this
    expression contains a group (the part of the regular expression that is surrounded
    by parentheses), Backbone will pass the matching part of the route to the routing
    function as an argument, allowing us to know the book's ID from within our routing
    function. If we were to include multiple groups in our regular expression, Backbone
    would have provided each matching part of the route as a separate argument to
    our routing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are powerful, which makes them a good choice for defining
    routes. However, they have one major downside: they are hard for humans to read,
    especially when you revisit them months after writing them. As the old programming
    adage goes: you had a problem and tried to solve it using regular expressions.
    Now you have two problems. For this reason, Backbone provides a third option for
    defining routes: routing strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing strings are similar to regular expressions; in that, they let you define
    dynamic routes but are much more limited. You can only define groups (also known
    as **parameters**), wildcard groups (also known as **splats**), and optional parts.
    By trading away some of the power of regular expressions, routing strings gain
    a great deal of readability. Instead of using `(\d+)` to match a part of the route
    for a book's ID, a routing string will use the more readable `bookId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with a regular expression route, Backbone will provide the route''s
    parameters as arguments to the routing function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to make that part of the route optional, we can wrap it with parentheses
    (for example, `book/(:bookId)`). However, there''s a problem; routing strings
    stop matching parameters (optional or not) when they see a `/` character, which
    means that they won''t work if your book ID has a */* in it. For instance, if
    we tried to navigate to `book/example/with/slash/5`, our route wouldn''t get triggered.
    To get around this issue, Backbone provides a `wildcard` or `splat` option, which
    will match the remaining portion of the `route` class. These splats are like parameters,
    but they use a `*` character instead of a `:` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because Backbone is not particular about whether you use simple routes, regular
    expressions, or routing strings, you can freely combine all the three types in
    any given `Router`. You'll probably find it best, however, to use the most readable
    form possible each time. In other words, you should start by trying to use a simple
    route, then switch to a routing string if you need to add a few variables, and
    only use a regular expression if you can't define the route with a routing string.
  prefs: []
  type: TYPE_NORMAL
- en: A note about routing conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whichever method you use to create your routes, you should be careful to avoid
    defining the same route twice or defining two routes that overlap each other,
    such as `foo` and `splatThatCouldBeFoo`. While Backbone will allow you to define
    such routes and will continue working fine in spite of them, it will silently
    ignore any routes after the first that match. Take an example of the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One could take advantage of this behavior by deliberately defining specific
    routes, and then less specific overlapping routes, but this is not generally recommended.
    While a few simple overlapping routes are unlikely to cause problems, if you have
    too many they can make your `Router` difficult to work with. When you have such
    overlapping routes you have to first stop and understand every route involved
    before you can make changes to any of them, and then if you make a mistake it's
    all to easy to create a difficult to find bug.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing slashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on from routes there is one last detail worth mentioning: trailing
    slashes. Normally web developers don''t need to think about trailing slashes,
    because most web servers treat `foo` and `foo`/ the same. Technically however
    they are different, and Backbone treats them as such, which means that a route
    of `foo` will not be triggered when the user navigates to `foo`/.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily this can easily be solved if you are using routing strings by adding
    (`/`) to the end of each string. If you are using regular expressions you can
    achieve a similar effect by adding `\/?` to the end of each of your regular expressions.
    However, if you are using simple strings you will either need to define two separate
    routes (`foo` and `foo`/), or you will just need to be careful never to create
    any links to `foo`/.
  prefs: []
  type: TYPE_NORMAL
- en: Redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally users traverse a site by clicking on anchor tags, better known as
    hyperlinks. The same is true for Backbone-powered sites; even if you use hash-based
    routes you can still create normal hyperlinks for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes however you will want to move the user to a different route using
    JavaScript instead. For instance, you might have a **Submit** button on a page
    and after it triggers a save of the page''s `Model` you want it to redirect the
    user to a different route. This can be done by using the `Routers navigate` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note the addition of the `trigger` option as the second argument
    to `navigate`. Without this extra argument, Backbone will take the user to the
    route's URL but won't actually trigger the route's logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `navigate` method can also take one other option: `replace`. If this option
    is provided, Backbone will navigate to the specified route but will not add an
    entry to the browser''s history. Take an example of the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Not creating a history entry means that, for instance, if the user visits another
    page and then clicks on their browser''s **Back** button instead of going back
    to the replaced page, they will be taken to the page before it in the browser''s
    history. Since this sort of behavior will likely be confusing for your user, it
    is recommended that you limit the use of `replace: true` to routes that are temporary,
    such as the route for loading a page.'
  prefs: []
  type: TYPE_NORMAL
- en: 404s and other errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've focused on what happens when a route matches, but what happens
    when the user visits a URL that doesn't have a matching route? This can happen,
    for instance, because of a stale link or because the user mistyped a URL. On a
    traditional website, the server will handle this by throwing a `404` error, but
    on a Backbone-powered site, the `Router` class will just do nothing, by default.
    This means that if you want to have a `404` page on your site, you'll have to
    create it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to rely on the `start` method. This method returns `true`
    or `false` depending on whether any matching routes are found for the current
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since that method will only be called once, when the page is first
    loaded, it won''t allow you to catch nonmatching routes that occur after the page
    is loaded. To catch these cases, you''ll need to define a special `404` route,
    which you can do using the routing string''s `splat` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Routing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, route-based logic is handled by the `Router` class itself. However,
    sometimes you may wish to *trigger* additional logic. For instance, you may want
    to add a certain element to the page whenever the user visits one of several routes.
    In such a case, you can take advantage of the fact that Backbone triggers events
    each time routing occurs, allowing you to listen and respond to route changes
    from outside the `Router` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can listen for routing events the same way as events in `Models` and `Collections`,
    by using the `on` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the three different routing events that you can listen
    for on a `Router` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Trigger |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `route` | This is triggered when any route is matched |'
  prefs: []
  type: TYPE_TB
- en: '| `route:name` | This is triggered when the route with the specified name is
    matched |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | This is triggered when any event is triggered on the `Router` class
    |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, Backbone also provides a `route` event that you can listen to
    on the `Backbone.history` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of listening to `history` instead of a particular `Router` is
    that it will catch events from all the `Routers` on your site, instead of just
    a particular one.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, you only need a single `Router` to power your entire site. However,
    if you have reason to do so, you can easily include multiple `Routers`, and Backbone
    will happily allow this. If two or more `Routers` on the same page match a particular
    route, Backbone will trigger the route from the first `Router` with a matching
    route defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons why you should use multiple `Routers`. The first
    reason is to separate your routing into logical groups. For instance, in an earlier
    example, we used a conditional to add certain admin-only routes to the `Router`
    class when the current user was an administrator. If our site has enough of these
    routes, it might make sense to create a separate `Router` for the admin-only routes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The other reason why you need to use multiple `Routers` is when you have two
    different sites that need to share some common code. For instance, a book-selling
    site might want a main site for their shoppers to buy books and an entirely different
    site for publishers to submit new books. However, even though the sites are different,
    they might both want to share some common code, such as a `Book Model` or a book-rendering
    `View`. By using multiple `Routers`, our bookseller can share any code they want
    between the two sites, while keeping the pages/routes of each entirely separate
    from one another.
  prefs: []
  type: TYPE_NORMAL
- en: In practice though, using multiple `Routers` can be confusing, especially if
    they have overlapping routes. Since you can easily add routes dynamically (as
    we did with our earlier administrator example), there typically won't be any need
    for you to rely on multiple `Routers` and you will likely avoid confusion by sticking
    to only one.
  prefs: []
  type: TYPE_NORMAL
- en: Page views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, it's worth discussing how `Views` interact with
    `Routers`. Throughout this chapter, we've deliberately been vague about what you
    should actually do inside your routing functions, and part of the beauty of Backbone
    is that it leaves this decision entirely up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For many Backbone users, however, a very common pattern is to create a special
    `Page View` and then instantiate a different subclass of that `View` in every
    route-handling method. Take an example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If your site has multiple sections, for instance a side navigation bar and a
    main content area, you can split up these parts into their own `View` classes
    and then make those parts the defaults used by your `Page View` class. You can
    then override these defaults as needed in your `Page View` subclasses to allow
    these `Views` to change the different parts of your site.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say most of the time, your site has a single side navigation
    bar but on certain pages, you wish to add some extra links to it. By using the
    `Page View` architecture, such a scenario is easy to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, our `AlternateSidebar` and `AlternateSidebarPage`
    classes are very short. Thanks to the power of inheritance, they don''t need to
    redefine any of your existing logic and can instead focus entirely on what makes
    them different: the logic for rendering the alternate sidebar. While your site
    may not even have a sidebar, it is no doubt made up of composable parts, and by
    breaking these parts into separate `View` classes, your routes can simply use
    the appropriate class for whichever `View` they wish to render.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Backbone's `Router` class. You learned how Backbone
    simulates pages by creating `routes` on a `Router` class and how `Routers` can
    operate using either hash-based or pushState-based routing. You also learned about
    the three different ways to add routes (via a `routes` option, a `routes` property,
    or the `route` method) and the three types of routes (simple, route strings, and
    regular expressions). Finally, you saw how to handle missing routes, respond to
    routing events, use multiple `Routers`, and most importantly how to combine a
    page view with composable sub-`Views` to power your routing methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at some more advanced uses of Backbone,
    such as using methods in place of Backbone properties, such as `model`, or mixing
    sets of methods into multiple classes.
  prefs: []
  type: TYPE_NORMAL
