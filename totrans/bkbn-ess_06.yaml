- en: Chapter 6. Creating Client-side Pages with Routers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 使用路由器创建客户端页面
- en: 'In this chapter, we''ll examine Backbone''s `Router` class to learn about the
    following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查 Backbone 的 `Router` 类，以了解以下内容：
- en: How routers simulate browser history to create virtual pages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过模拟浏览器历史记录来创建虚拟页面
- en: How to create new `Router` subclasses and instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建新的 `Router` 子类和实例
- en: The various mechanisms for defining routing patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义路由模式的各种机制
- en: How to handle special cases, such as nonexistent routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理特殊案例，例如不存在的路由
- en: How to use a page view to render routes consistently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用页面视图来一致地渲染路由
- en: Backbone routers enable single-page applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone 路由器使单页应用程序成为可能
- en: Until now, all the Backbone features we've looked at have been enhancements
    to previously existing functionality; Backbone's classes improve on native JavaScript
    classes—`Models` and `Collections`—as well as enhance the functionality of objects
    and arrays, and `Views` improve on the DOM manipulation and event binding that
    jQuery already facilitates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的所有 Backbone 功能都是对先前存在功能的增强；Backbone 的类改进了原生 JavaScript 类——`Models`
    和 `Collections`——以及增强对象和数组的功能，而 `Views` 则改进了 jQuery 已经提供的 DOM 操作和事件绑定。
- en: '`Routers`, however, break this trend. Instead of enhancing something that already
    exists, `Routers` allow you to do something entirely new: create an entire site
    using only a single HTML page. As discussed in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Building a Single-Page Site Using Backbone"), *Building a Single-page
    Site Using Backbone*, single-page applications offer several advantages over traditional
    multipage websites: most notably, enhanced performance and complete client-side
    control over the application. Backbone''s `Router` class is what makes all this
    possible.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Routers` 打破了这一趋势。`Routers` 不是增强现有功能，而是允许你做一件完全新的事情：仅使用一个 HTML 页面创建整个网站。如
    [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章. 使用 Backbone 构建单页网站") 中所述，*使用 Backbone
    构建单页网站*，单页应用程序相对于传统多页网站具有几个优点：最显著的是性能增强和完全的客户端控制。Backbone 的 `Router` 类使得所有这些成为可能。
- en: How Routers work
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器的工作原理
- en: On a traditional multipage site, the browser provides both routing and page
    history without the need for any extra effort. When a user visits a URL on the
    site, the browser asks the server for that URL's content, and then when the user
    moves to another URL, the browser tracks the change in the user's browsing history.
    In a Backbone-powered site, however, both of these must be handled by a `Router`
    instead. When the user visits a new page, the `Router` determines which `Views`
    to render, and when they leave that page, the `Router` informs the browser of
    the new history entry. This lets a Backbone-powered site act just like a traditional
    one, including allowing the user to use their browser's `Back` button.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的多页网站上，浏览器在无需额外努力的情况下提供路由和页面历史记录。当用户访问网站上的 URL 时，浏览器会请求该 URL 的内容，然后当用户移动到另一个
    URL 时，浏览器会跟踪用户浏览历史记录中的变化。然而，在由 Backbone 驱动的网站上，这两者都必须由 `Router` 来处理。当用户访问新页面时，`Router`
    确定要渲染哪些 `Views`，当他们离开该页面时，`Router` 会通知浏览器新的历史记录条目。这使得由 Backbone 驱动的网站可以像传统网站一样运行，包括允许用户使用浏览器的
    `Back` 按钮。
- en: There are two different approaches by which a `Router` can accomplish this,
    and Backbone lets you decide which approach you want to use. The first, and default,
    approach is hash-based routing, which takes advantage of URL fragments (also known
    as named anchors). You've probably seen URLs with these fragments before, for
    instance [www.example.com/foo#bar](http://www.example.com/foo#bar). By using these
    fragments to define the pages of your site, Backbone can both know what page to
    load and can tell the browser how to track the user's movement across pages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router` 可以通过两种不同的方法来实现这一点，Backbone 允许你决定使用哪种方法。第一种，也是默认的方法是基于哈希的路由，它利用了 URL
    片段（也称为命名锚点）。你可能之前见过带有这些片段的 URL，例如 [www.example.com/foo#bar](http://www.example.com/foo#bar)。通过使用这些片段来定义网站的页面，Backbone
    可以知道要加载哪个页面，并告诉浏览器如何跟踪用户在页面之间的移动。'
- en: If you don't want your users to see hashes in your URLs, Backbone offers a second
    option that relies on the recently added HTML5 pushState technology. While this
    definitely helps URLs look cleaner, the pushState approach comes with a significant
    drawback. Although pushState is available in most web browsers, older browsers,
    such as Internet Explorer 9 and below, do not support it. If you try to use pushState-based
    routing in a browser without support for it, Backbone will instead fall back on
    hash-based routing. Even if only 1 percent of your users have an older browser,
    it still means that these 1 percent users will see a different URL from the rest
    of your users, which may cause confusion if (for instance) users with different
    browsers share links.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让你的用户在URL中看到哈希值，Backbone提供了一个基于最近添加的HTML5 pushState技术的第二个选项。虽然这确实有助于使URL看起来更干净，但pushState方法存在一个显著的缺点。尽管pushState在大多数网络浏览器中都可用，但像Internet
    Explorer 9及以下版本这样的旧浏览器不支持它。如果你尝试在一个不支持pushState的浏览器中使用基于pushState的路由，Backbone将回退到基于哈希的路由。即使只有1%的用户使用旧浏览器，这也意味着这1%的用户将看到与其它用户不同的URL，这可能会在（例如）不同浏览器的用户分享链接时造成混淆。
- en: 'Routing based on pushState also has a minor drawback: if a user refreshes the
    page on a pushState-powered site, the browser will request that URL from the server.
    This can be solved by simply making your server return your application''s single
    HTML page whenever the browser requests for such a URL. However, given both of
    these drawbacks, using pushState is only recommended if you care strongly about
    the appearance of your URLs and believe that all your users will have modern browsers.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于pushState的路由也有一个小的缺点：如果一个用户在pushState驱动的网站上刷新页面，浏览器将请求从服务器获取该URL。这可以通过简单地让服务器在浏览器请求此类URL时返回你的应用程序的单个HTML页面来解决。然而，鉴于这两个缺点，使用pushState仅在你非常关心URL的外观并且相信所有用户都将使用现代浏览器的情况下推荐。
- en: Backbone.history
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone.history
- en: Because it's possible to use multiple `Routers` at once (although it's not generally
    recommended, as we'll discuss later in the chapter), Backbone has a separate global
    object known as `Backbone.history` that handles history management. It is important
    to understand, however, that this object doesn't actually replace your browser's
    history; instead, it simply helps to manage what gets added to the history and
    when.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以同时使用多个`Routers`（尽管通常不推荐这样做，我们将在本章后面讨论），Backbone有一个名为`Backbone.history`的独立全局对象，用于处理历史管理。然而，重要的是要理解，这个对象实际上并没有替换你的浏览器历史；相反，它只是帮助管理添加到历史记录的内容以及何时添加。
- en: 'When you load a page that uses a Backbone `Router`, you need to invoke the
    `start` method of this history object in order to tell Backbone to begin routing.
    This `start` method also lets you tell Backbone which routing technology you need
    to employ. If you want Backbone to rely on hash-based routing, you can simply
    call the `this` method without any arguments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载一个使用Backbone `Router`的页面时，你需要调用这个历史对象的`start`方法，以便告诉Backbone开始路由。这个`start`方法还允许你告诉Backbone你需要使用哪种路由技术。如果你想Backbone依赖于基于哈希的路由，你可以简单地调用这个`this`方法而不带任何参数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If instead you wish to use pushState-based routing, you need to provide one
    extra argument to indicate it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用基于pushState的路由，你需要提供一个额外的参数来表示这一点：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Differences between routes and pages
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和页面的区别
- en: Routes and pages are very similar concepts and are often used interchangeably
    by Backbone programmers. This is natural since routes are essentially just the
    Backbone implementation of pages. However, there are important differences between
    the two, at least when you compare the pages of a multi-page website to the routes
    of a Backbone single-page application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和页面是非常相似的概念，并且经常被Backbone程序员互换使用。这是自然的，因为路由本质上只是Backbone对页面的实现。然而，两者之间至少在将多页网站的页面与Backbone单页应用的路由进行比较时，存在重要的区别。
- en: In traditional, multi-page websites, each new page that the user visits requires
    you to make a new request to the site's server. In a Backbone-powered site, however,
    the user can navigate through as many pages (routes) as they want, making new
    requests only when it is necessary to fetch new data. This feature alone accounts
    for a significant increase in speed on a Backbone-powered site.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的多页网站上，用户访问的每个新页面都需要你向网站服务器发送一个新的请求。然而，在一个由Backbone驱动的网站上，用户可以导航到他们想要的任意多页（路由），只有在需要获取新数据时才会发送新的请求。仅此一项功能就使得Backbone驱动的网站速度显著提高。
- en: Another important difference is that standard web pages trigger an entire page
    load, whereas routes trigger only a specific JavaScript function. This means that
    unlike a traditional application, which has to limit the number of pages (and
    thus the number of HTTP requests) it makes, routes can be used for just about
    any possible change in state. Routes can be used in a similar way to traditional
    web pages, or they can be used for much smaller changes to a page. They can even
    (rarely) be used when there is no change to the DOM at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Of course, while Backbone routes have many advantages, they also have some downsides.
    The most important downside is that because they do not refresh the page, existing
    DOM elements, style changes, and event bindings are not cleared automatically.
    This means that you will need to handle these clean-up tasks yourself. Luckily,
    this isn't very difficult to do, especially if you rely on a page view, which
    we will introduce shortly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Router
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all Backbone classes, you can create a new `Router` subclass by using
    `extend`, where the first argument provides the class''s instance properties and
    methods and the second argument provides the static ones:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similar to `Views`, `Routers` take only a single `options` argument when they
    are instantiated. This argument is completely optional, and the only real option
    it takes is the `routes` option. As mentioned, once the `Router` has been created,
    you will need to run `Backbone.history.start()` before it can handle routes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating routes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with passing in your routes when you create a `Router` is that
    you have to supply all the routing functions together with your routes, which
    (especially if you have a lot of routes on your site) can easily become messy.
    Instead, many Backbone programmers define their routes on the `Router` class itself,
    as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this approach simplifies the routes' definition and makes them
    more similar to the `events` properties of `Models` and `Collections`. Instead
    of defining routing methods with the routes themselves, you can simply give the
    route the name of a routing method and Backbone will look for that method inside
    the `Router` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a third way to add routes and that is by using Backbone''s `route`
    method. This method takes the `route` as the first argument, the route''s name
    as the second argument, and the route''s handler as the third argument. If the
    third argument is omitted, Backbone will look for a method on the `Router` with
    the same name as the `route` itself:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just as the `on` method of `Models` and `Collections` lets you create event
    bindings after an instance of the class is created, the `route` method of `Routers`
    allows you to define a new route at any time. This means that you can dynamically
    create all your routes on the fly after the `Router` class is created. However,
    just as you would normally want all the pages of your site to be available to
    your user when they first visit it, you will generally want all your routes to
    be available too, which means that you will usually create them in your `Routers
    initialize` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`Models`和`Collections`的`on`方法允许你在创建类的实例之后创建事件绑定一样，`Routers`的`route`方法允许你在任何时间定义一个新的路由。这意味着你可以在创建`Router`类之后动态地创建所有路由。然而，正如你通常希望在用户首次访问你的网站时所有页面都可用一样，你通常也希望所有路由都可用，这意味着你通常会在你的`Routers
    initialize`方法中创建它们。
- en: 'The main advantage of using the `route` method is that you can apply logic
    to your routes. For instance, let''s say you have several routes on your site
    that are only for administrators. If your `t` can check an `isAdmin` attribute
    of a user `Model`, then it can use this attribute to dynamically add or remove
    these administrator-only routes when the `Router` class is initialized, as shown
    here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`route`方法的主要优势是你可以将逻辑应用到你的路由上。例如，假设你在网站上有多条仅针对管理员的路由。如果你的`t`可以检查用户`Model`的`isAdmin`属性，那么它可以使用这个属性在`Router`类初始化时动态地添加或删除这些仅限管理员的路由，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the preceding example, another advantage of using the `route`
    method is that you can organize groups of routes into separate functions. This
    can be useful if you want to turn certain groups of routes on or off together,
    but it can also be useful simply to organize constant routes. In fact, you can
    even define some of your routes in an entirely different file as long as your
    `Router` has access to them, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，使用`route`方法的另一个优势是你可以将路由分组组织成单独的函数。如果你想要一起开启或关闭某些路由组，这可能会很有用；但它也可以简单地用来组织常量路由。实际上，你甚至可以在一个完全不同的文件中定义一些路由，只要你的`Router`可以访问它们，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Route styles
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由样式
- en: In addition to having the choice to decide how you hook up your routes, you
    also have the choice to decide how to define the routes. So far, all the routes
    you've seen have been simple routes; they define a string of characters, and when
    Backbone sees that exact string of characters in the URL, it triggers the appropriate
    routing method. Sometimes, however, you'll want to have routes that are more flexible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有选择如何连接你的路由之外，你还可以选择如何定义路由。到目前为止，你看到的都是简单路由；它们定义了一串字符，当Backbone在URL中看到这个确切的字符串时，它会触发相应的路由方法。然而，有时你可能想要更灵活的路由。
- en: 'For example, imagine that we have a site which sells books and we want to have
    a "learn about a particular book" `route`. If we have a good number of books on
    our site, creating routes for each of them individually might get painful:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个销售书籍的网站，我们想要有一个“了解特定书籍”的路由。如果我们网站上有很多书籍，为每本书单独创建路由可能会变得痛苦：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Luckily, there are two alternatives that solve this problem: routing strings
    and regular expression routes. First, let''s look at how regular expression routes
    can solve this problem:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有两种替代方案可以解决这个问题：路由字符串和正则表达式路由。首先，让我们看看正则表达式路由如何解决这个问题：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the preceding example, we were able to create a single route
    with a regular expression that matches all our possible book routes. Because this
    expression contains a group (the part of the regular expression that is surrounded
    by parentheses), Backbone will pass the matching part of the route to the routing
    function as an argument, allowing us to know the book's ID from within our routing
    function. If we were to include multiple groups in our regular expression, Backbone
    would have provided each matching part of the route as a separate argument to
    our routing function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们能够使用一个匹配所有可能书籍路由的正则表达式创建一个单独的路由。因为这个表达式包含一个组（正则表达式中被括号包围的部分），Backbone会将匹配的路由部分传递给路由函数作为参数，这样我们就可以在路由函数内部知道书籍的ID。如果我们要在正则表达式中包含多个组，Backbone会将每个匹配的路由部分作为单独的参数传递给我们的路由函数。
- en: 'Regular expressions are powerful, which makes them a good choice for defining
    routes. However, they have one major downside: they are hard for humans to read,
    especially when you revisit them months after writing them. As the old programming
    adage goes: you had a problem and tried to solve it using regular expressions.
    Now you have two problems. For this reason, Backbone provides a third option for
    defining routes: routing strings.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式功能强大，这使得它们成为定义路由的好选择。然而，它们有一个主要的缺点：它们对人类来说很难阅读，尤其是在你几个月后再次查看它们时。正如古老的编程格言所说：你遇到了一个问题，并试图使用正则表达式来解决它。现在你有两个问题。因此，Backbone
    为定义路由提供了第三个选项：路由字符串。
- en: Routing strings are similar to regular expressions; in that, they let you define
    dynamic routes but are much more limited. You can only define groups (also known
    as **parameters**), wildcard groups (also known as **splats**), and optional parts.
    By trading away some of the power of regular expressions, routing strings gain
    a great deal of readability. Instead of using `(\d+)` to match a part of the route
    for a book's ID, a routing string will use the more readable `bookId`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 路由字符串类似于正则表达式；在这一点上，它们允许你定义动态路由，但它们的限制性更大。你只能定义组（也称为 **参数**），通配符组（也称为 **splat**），以及可选部分。通过放弃正则表达式的一些功能，路由字符串获得了很大的可读性。与使用
    `(\d+)` 匹配书籍 ID 的路由部分相比，路由字符串将使用更易读的 `bookId`。
- en: 'Just as with a regular expression route, Backbone will provide the route''s
    parameters as arguments to the routing function, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如正则表达式路由一样，Backbone 将将路由的参数作为参数传递给路由函数，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we wanted to make that part of the route optional, we can wrap it with parentheses
    (for example, `book/(:bookId)`). However, there''s a problem; routing strings
    stop matching parameters (optional or not) when they see a `/` character, which
    means that they won''t work if your book ID has a */* in it. For instance, if
    we tried to navigate to `book/example/with/slash/5`, our route wouldn''t get triggered.
    To get around this issue, Backbone provides a `wildcard` or `splat` option, which
    will match the remaining portion of the `route` class. These splats are like parameters,
    but they use a `*` character instead of a `:` character:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使路由的一部分是可选的，我们可以用括号将其包裹（例如，`book/(:bookId)`）。然而，这里有一个问题；当路由字符串看到 `/` 字符时，它们会停止匹配参数（无论是否可选），这意味着如果你的书
    ID 中包含 */*，它们将不起作用。例如，如果我们尝试导航到 `book/example/with/slash/5`，我们的路由就不会被触发。为了解决这个问题，Backbone
    提供了一个 `wildcard` 或 `splat` 选项，它将匹配 `route` 类的剩余部分。这些 splats 就像参数一样，但它们使用 `*` 字符而不是
    `:` 字符：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because Backbone is not particular about whether you use simple routes, regular
    expressions, or routing strings, you can freely combine all the three types in
    any given `Router`. You'll probably find it best, however, to use the most readable
    form possible each time. In other words, you should start by trying to use a simple
    route, then switch to a routing string if you need to add a few variables, and
    only use a regular expression if you can't define the route with a routing string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Backbone 对你是否使用简单路由、正则表达式或路由字符串并不特别关心，你可以在任何给定的 `Router` 中自由组合这三种类型。然而，你可能发现，每次都使用最易读的形式是最好的。换句话说，你应该先尝试使用简单路由，然后如果你需要添加一些变量，再切换到路由字符串，只有在你无法使用路由字符串定义路由时才使用正则表达式。
- en: A note about routing conflicts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于路由冲突的注意事项
- en: 'Whichever method you use to create your routes, you should be careful to avoid
    defining the same route twice or defining two routes that overlap each other,
    such as `foo` and `splatThatCouldBeFoo`. While Backbone will allow you to define
    such routes and will continue working fine in spite of them, it will silently
    ignore any routes after the first that match. Take an example of the following
    code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种方法来创建你的路由，都应该小心避免定义相同的路由两次，或者定义两个相互重叠的路由，例如 `foo` 和 `splatThatCouldBeFoo`。虽然
    Backbone 允许你定义这样的路由，并且即使有这些路由也能继续正常工作，但它会静默地忽略第一个匹配之后的任何路由。以下是一个代码片段的例子：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One could take advantage of this behavior by deliberately defining specific
    routes, and then less specific overlapping routes, but this is not generally recommended.
    While a few simple overlapping routes are unlikely to cause problems, if you have
    too many they can make your `Router` difficult to work with. When you have such
    overlapping routes you have to first stop and understand every route involved
    before you can make changes to any of them, and then if you make a mistake it's
    all to easy to create a difficult to find bug.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过故意定义特定的路由，然后是更不具体的重叠路由来利用这种行为，但这通常不推荐。虽然几个简单的重叠路由不太可能引起问题，但如果太多，它们可能会使你的`Router`难以操作。当你有这种重叠路由时，你必须首先停下来理解所有涉及的路线，然后才能对它们中的任何一个进行更改，然后如果你犯了一个错误，很容易就会创建一个难以找到的错误。
- en: Trailing slashes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随斜杠
- en: 'Before we move on from routes there is one last detail worth mentioning: trailing
    slashes. Normally web developers don''t need to think about trailing slashes,
    because most web servers treat `foo` and `foo`/ the same. Technically however
    they are different, and Backbone treats them as such, which means that a route
    of `foo` will not be triggered when the user navigates to `foo`/.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开路由之前，还有一个值得注意的细节：跟随斜杠。通常，网络开发者不需要考虑跟随斜杠，因为大多数网络服务器将`foo`和`foo/`视为相同。然而，从技术上讲，它们是不同的，Backbone也将它们视为不同，这意味着当用户导航到`foo/`时，`foo`路由不会被触发。
- en: Luckily this can easily be solved if you are using routing strings by adding
    (`/`) to the end of each string. If you are using regular expressions you can
    achieve a similar effect by adding `\/?` to the end of each of your regular expressions.
    However, if you are using simple strings you will either need to define two separate
    routes (`foo` and `foo`/), or you will just need to be careful never to create
    any links to `foo`/.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果你使用路由字符串，可以通过在每个字符串的末尾添加（`/`）来轻松解决这个问题。如果你使用正则表达式，你可以通过在每个正则表达式的末尾添加`\/?`来实现类似的效果。然而，如果你使用简单的字符串，你可能需要定义两个不同的路由（`foo`和`foo/`），或者你只需小心不要创建任何指向`foo/`的链接。
- en: Redirects
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向
- en: 'Normally users traverse a site by clicking on anchor tags, better known as
    hyperlinks. The same is true for Backbone-powered sites; even if you use hash-based
    routes you can still create normal hyperlinks for them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用户通过点击锚点标签（也称为超链接）来遍历网站。对于由Backbone驱动的网站来说，也是如此；即使你使用基于hash的路由，你仍然可以为他们创建正常的超链接：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sometimes however you will want to move the user to a different route using
    JavaScript instead. For instance, you might have a **Submit** button on a page
    and after it triggers a save of the page''s `Model` you want it to redirect the
    user to a different route. This can be done by using the `Routers navigate` method,
    like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能希望使用JavaScript将用户移动到不同的路由。例如，你可能在页面上有一个**提交**按钮，在它触发页面的`Model`保存后，你希望它将用户重定向到不同的路由。这可以通过使用`Routers
    navigate`方法来完成，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's important to note the addition of the `trigger` option as the second argument
    to `navigate`. Without this extra argument, Backbone will take the user to the
    route's URL but won't actually trigger the route's logic.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，将`trigger`选项作为`navigate`的第二个参数添加。如果没有这个额外的参数，Backbone会将用户带到路由的URL，但不会实际触发路由的逻辑。
- en: 'The `navigate` method can also take one other option: `replace`. If this option
    is provided, Backbone will navigate to the specified route but will not add an
    entry to the browser''s history. Take an example of the following line of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigate`方法还可以接受另一个选项：`replace`。如果提供了这个选项，Backbone将导航到指定的路由，但不会在浏览器的历史记录中添加条目。以下是一行代码的示例：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Not creating a history entry means that, for instance, if the user visits another
    page and then clicks on their browser''s **Back** button instead of going back
    to the replaced page, they will be taken to the page before it in the browser''s
    history. Since this sort of behavior will likely be confusing for your user, it
    is recommended that you limit the use of `replace: true` to routes that are temporary,
    such as the route for loading a page.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '不创建历史记录条目意味着，例如，如果用户访问了另一个页面然后点击浏览器上的**后退**按钮而不是回到被替换的页面，他们将被带到浏览器历史记录中的上一个页面。由于这种行为可能会让用户感到困惑，建议你将`replace:
    true`的使用限制在临时路由上，例如加载页面的路由。'
- en: 404s and other errors
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 404和其他错误
- en: Until now, we've focused on what happens when a route matches, but what happens
    when the user visits a URL that doesn't have a matching route? This can happen,
    for instance, because of a stale link or because the user mistyped a URL. On a
    traditional website, the server will handle this by throwing a `404` error, but
    on a Backbone-powered site, the `Router` class will just do nothing, by default.
    This means that if you want to have a `404` page on your site, you'll have to
    create it yourself.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注路由匹配时会发生什么，但用户访问一个没有匹配路由的URL时会发生什么呢？这种情况可能是因为一个过时的链接或用户输入了错误的URL。在一个传统的网站上，服务器将通过抛出`404`错误来处理这种情况，但在Backbone驱动的网站上，`Router`类默认情况下将不会做任何事情。这意味着，如果你想在网站上有一个`404`页面，你必须自己创建它。
- en: 'One way to do this is to rely on the `start` method. This method returns `true`
    or `false` depending on whether any matching routes are found for the current
    URL:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是通过`start`方法。此方法根据当前URL是否找到任何匹配的路由返回`true`或`false`：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, since that method will only be called once, when the page is first
    loaded, it won''t allow you to catch nonmatching routes that occur after the page
    is loaded. To catch these cases, you''ll need to define a special `404` route,
    which you can do using the routing string''s `splat` syntax:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于该方法只会在页面首次加载时被调用一次，因此它不会允许你捕获页面加载后发生的非匹配路由。为了捕获这些情况，你需要定义一个特殊的`404`路由，你可以使用路由字符串的`splat`语法来完成：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Routing events
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由事件
- en: Normally, route-based logic is handled by the `Router` class itself. However,
    sometimes you may wish to *trigger* additional logic. For instance, you may want
    to add a certain element to the page whenever the user visits one of several routes.
    In such a case, you can take advantage of the fact that Backbone triggers events
    each time routing occurs, allowing you to listen and respond to route changes
    from outside the `Router` class itself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于路由的逻辑是由`Router`类本身处理的。然而，有时你可能希望*触发*额外的逻辑。例如，你可能希望在用户访问几个路由之一时，向页面添加某个元素。在这种情况下，你可以利用Backbone在每次路由发生时触发事件的特性，允许你从`Router`类外部监听和响应路由变化。
- en: 'You can listen for routing events the same way as events in `Models` and `Collections`,
    by using the `on` method, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`on`方法以与`Models`和`Collections`中的事件相同的方式监听路由事件，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following table shows the three different routing events that you can listen
    for on a `Router` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了可以在`Router`类上监听的三种不同的路由事件：
- en: '| Event name | Trigger |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 触发 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `route` | This is triggered when any route is matched |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `route` | 当任何路由匹配时触发 |'
- en: '| `route:name` | This is triggered when the route with the specified name is
    matched |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `route:name` | 当匹配指定名称的路由时触发 |'
- en: '| `all` | This is triggered when any event is triggered on the `Router` class
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 当在`Router`类上触发任何事件时触发 |'
- en: 'In addition, Backbone also provides a `route` event that you can listen to
    on the `Backbone.history` object, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Backbone还提供了一个可以在`Backbone.history`对象上监听的`route`事件，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The advantage of listening to `history` instead of a particular `Router` is
    that it will catch events from all the `Routers` on your site, instead of just
    a particular one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 监听`history`而不是特定`Router`的优点是，它将捕获来自你网站上所有`Routers`的事件，而不仅仅是特定的一个。
- en: Multiple routers
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个路由器
- en: In general, you only need a single `Router` to power your entire site. However,
    if you have reason to do so, you can easily include multiple `Routers`, and Backbone
    will happily allow this. If two or more `Routers` on the same page match a particular
    route, Backbone will trigger the route from the first `Router` with a matching
    route defined.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只需要一个`Router`来驱动你的整个网站。然而，如果你有理由这样做，你可以轻松地包含多个`Routers`，Backbone将愉快地允许这样做。如果同一页面上有两个或更多`Routers`匹配特定的路由，Backbone将触发第一个具有匹配路由定义的`Router`的路由。
- en: 'There are two main reasons why you should use multiple `Routers`. The first
    reason is to separate your routing into logical groups. For instance, in an earlier
    example, we used a conditional to add certain admin-only routes to the `Router`
    class when the current user was an administrator. If our site has enough of these
    routes, it might make sense to create a separate `Router` for the admin-only routes,
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用多个`Routers`的主要原因有两个。第一个原因是将你的路由分成逻辑组。例如，在先前的例子中，我们使用条件语句在当前用户是管理员时将某些仅限管理员的路由添加到`Router`类中。如果我们的网站有足够的这些路由，那么为仅限管理员的路由创建一个单独的`Router`可能是有意义的，如下所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The other reason why you need to use multiple `Routers` is when you have two
    different sites that need to share some common code. For instance, a book-selling
    site might want a main site for their shoppers to buy books and an entirely different
    site for publishers to submit new books. However, even though the sites are different,
    they might both want to share some common code, such as a `Book Model` or a book-rendering
    `View`. By using multiple `Routers`, our bookseller can share any code they want
    between the two sites, while keeping the pages/routes of each entirely separate
    from one another.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用多个 `Routers` 的另一个原因是当你有两个不同的网站需要共享一些公共代码时。例如，一个图书销售网站可能希望有一个主网站供购物者购买书籍，并为出版商提供一个完全不同的网站来提交新书。然而，尽管这些网站是不同的，它们可能都希望共享一些公共代码，例如一个
    `Book Model` 或书籍渲染的 `View`。通过使用多个 `Routers`，我们的图书销售商可以在两个网站之间共享他们想要的任何代码，同时保持每个网站页面/路由的完全独立。
- en: In practice though, using multiple `Routers` can be confusing, especially if
    they have overlapping routes. Since you can easily add routes dynamically (as
    we did with our earlier administrator example), there typically won't be any need
    for you to rely on multiple `Routers` and you will likely avoid confusion by sticking
    to only one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用多个 `Routers` 可能会让人感到困惑，尤其是当它们有重叠的路由时。由于你可以轻松地动态添加路由（就像我们在早期的管理员示例中所做的那样），通常你不需要依赖多个
    `Routers`，并且通过坚持只使用一个，你可能会避免混淆。
- en: Page views
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面视图
- en: Before we finish this chapter, it's worth discussing how `Views` interact with
    `Routers`. Throughout this chapter, we've deliberately been vague about what you
    should actually do inside your routing functions, and part of the beauty of Backbone
    is that it leaves this decision entirely up to you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这一章之前，讨论一下 `Views` 如何与 `Routers` 交互是值得的。在本章中，我们故意对你在路由函数内部实际应该做什么保持模糊，Backbone
    的美妙之处在于它完全将这个决定留给了你。
- en: 'For many Backbone users, however, a very common pattern is to create a special
    `Page View` and then instantiate a different subclass of that `View` in every
    route-handling method. Take an example of the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于许多 Backbone 用户来说，一个非常常见的模式是创建一个特殊的 `Page View`，然后在每个路由处理方法中实例化该 `View`
    的不同子类。以下代码片段是一个例子：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If your site has multiple sections, for instance a side navigation bar and a
    main content area, you can split up these parts into their own `View` classes
    and then make those parts the defaults used by your `Page View` class. You can
    then override these defaults as needed in your `Page View` subclasses to allow
    these `Views` to change the different parts of your site.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站有多个部分，例如侧导航栏和主要内容区域，你可以将这些部分拆分成它们自己的 `View` 类，然后让这些部分成为你的 `Page View`
    类的默认使用部分。然后，你可以在 `Page View` 的子类中根据需要覆盖这些默认设置，以允许这些 `Views` 改变你网站的各个部分。
- en: 'For instance, let''s say most of the time, your site has a single side navigation
    bar but on certain pages, you wish to add some extra links to it. By using the
    `Page View` architecture, such a scenario is easy to implement:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设大多数时候，你的网站只有一个侧导航栏，但在某些页面上，你希望向其中添加一些额外的链接。通过使用 `Page View` 架构，这样的场景很容易实现：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in the preceding example, our `AlternateSidebar` and `AlternateSidebarPage`
    classes are very short. Thanks to the power of inheritance, they don''t need to
    redefine any of your existing logic and can instead focus entirely on what makes
    them different: the logic for rendering the alternate sidebar. While your site
    may not even have a sidebar, it is no doubt made up of composable parts, and by
    breaking these parts into separate `View` classes, your routes can simply use
    the appropriate class for whichever `View` they wish to render.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例所示，我们的 `AlternateSidebar` 和 `AlternateSidebarPage` 类非常简短。多亏了继承的力量，它们不需要重新定义任何现有的逻辑，而是可以完全专注于它们的不同之处：渲染替代侧边栏的逻辑。虽然你的网站可能甚至没有侧边栏，但它无疑是由可组合的部分组成的，通过将这些部分拆分成单独的
    `View` 类，你的路由可以简单地使用它们希望渲染的适当类。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Backbone's `Router` class. You learned how Backbone
    simulates pages by creating `routes` on a `Router` class and how `Routers` can
    operate using either hash-based or pushState-based routing. You also learned about
    the three different ways to add routes (via a `routes` option, a `routes` property,
    or the `route` method) and the three types of routes (simple, route strings, and
    regular expressions). Finally, you saw how to handle missing routes, respond to
    routing events, use multiple `Routers`, and most importantly how to combine a
    page view with composable sub-`Views` to power your routing methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Backbone 的 `Router` 类。你学习了 Backbone 如何通过在 `Router` 类上创建 `routes`
    来模拟页面，以及 `Routers` 可以如何使用基于 hash 或基于 pushState 的路由来操作。你还了解了添加路由的三种不同方式（通过 `routes`
    选项、`routes` 属性或 `route` 方法）以及三种类型的路由（简单路由、路由字符串和正则表达式）。最后，你看到了如何处理缺失的路由、响应路由事件、使用多个
    `Routers`，以及最重要的是如何将页面视图与可组合的子 `Views` 结合起来，以增强你的路由方法。
- en: In the next chapter, we'll take a look at some more advanced uses of Backbone,
    such as using methods in place of Backbone properties, such as `model`, or mixing
    sets of methods into multiple classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Backbone 的更多高级用法，例如使用方法代替 Backbone 属性，如 `model`，或者将方法集混合到多个类中。
