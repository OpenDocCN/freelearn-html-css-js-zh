<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing States with Redux</h1>
                </header>
            
            <article>
                
<p>Remember that, previously, we said that it is not good to have application states in multiple places, because it makes debugging much harder. Therefore, <span>we moved states from the input components to the form components. But now that we have two forms, we once again have states in two places. Therefore, we need to move the states up again. The most ideal case is where our application has only one state store.</span></p>
<p>However, if we keep moving states up, and passing the relevant state properties down as props, it can be quite un-performant. Let's say a component is nested 20 layers deep; for it to consume the state it needs, the state needs to have passed through 19 components.</p>
<p>Furthermore, let's say the same heavily nested component needs to change the state; it will have to call its <kbd>onChange</kbd> prop, prompting its parent to call its <kbd>onChange</kbd> prop, and so on, and so on. Having to call 20 <kbd>onChange</kbd> functions for every state change is ineffective.</p>
<p>Luckily, people have faced the same issues before and have come up with <strong>state management</strong> libraries that address them. In this chapter, we will use the most popular state management library, <strong>Redux</strong>, to organize our state in a centralized manner.</p>
<p>By following this chapter, you will learn the following:</p>
<ul>
<li>Different concepts in Redux, such as state <strong>store</strong>, <strong>reducers</strong>, <strong>actions</strong> and <strong>dispatchers</strong></li>
<li>How to lift state up</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State management tools</h1>
                </header>
            
            <article>
                
<p class="FirstParagraph"><span>There are many state management libraries out there, with the two most popular being Redux and MobX.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redux</h1>
                </header>
            
            <article>
                
<p>In Redux, you keep the state of your application inside an object literal that belongs to a <em>store</em>. When the state needs to be changed, an <em>action</em> describing what has happened should be emitted.</p>
<p>Then, you'd define a set of <em>reducer</em> functions, each responding to different types of actions. The purpose of a reducer is to generate a new state object that’ll replace the last one:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/84d96930-a7fa-486c-ac96-09b341d1e6a9.jpg" style="width:24.33em;height:20.67em;"/></div>
<div>
<p>This way, updating the state no longer requires calling 20 different <kbd>onChange</kbd> functions.</p>
<p>However, you'd still need to pass the state via the props of many components. There’s a way to mitigate this through the use of <em>selectors</em>; but more on that later.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MobX</h1>
                </header>
            
            <article>
                
<p>Mobx incorporates functional reactive programming principles, and uses <em>observables</em> as its stores:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3fc86d4c-d080-4f6d-a3f6-da156381b4fd.jpg" style="width:25.58em;height:18.67em;"/></div>
<p>You can tag entities (for example, objects and arrays) as observables using the <kbd>@observable</kbd> decorator. You can also tag some functions with the <kbd>@computed</kbd> decorator to make it into a <em>derivation</em> or <em>reaction</em>. The <kbd>@computed</kbd> functions will be re-run each time the <kbd>@observable</kbd> store has changed.</p>
<div class="packt_infobox">
<p>Decorators are a proposed addition to ECMAScript, currently tracked at <a href="https://github.com/tc39/proposal-decorators">github.com/tc39/proposal-decorators</a>.<a href="https://github.com/tc39/proposal-decorators"/><a href="https://github.com/tc39/proposal-decorators"/><a href="https://github.com/tc39/proposal-decorators"/></p>
</div>
<p>A derivation is a value that can be derived solely from the state. For example, we can make our <kbd>LoginPage</kbd> component a derivation of the state. When the state contains a token property, the user is already logged in and the <kbd>LoginPage</kbd> can display a message saying <span class="packt_screen">"You’re already logged in"</span>. When the state does not contain the token property, <kbd>LoginPage</kbd> will render the <kbd>LoginForm</kbd> component. What the <kbd>LoginPage</kbd> displays can be wholly derived from the value of the token property inside the state object.</p>
<p>Reactions are events that are triggered whenever the state changes. For instance, if the stale state property of a news feed application changes to <kbd>true</kbd>, you may want to query the API to get fresh data.</p>
<p>Lastly, state changes are triggered by <em>actions</em>, which are events that mutate the state. In MobX, actions are simply JavaScript statements that update the state in some way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redux versus MobX</h1>
                </header>
            
            <article>
                
<p>First and foremost, we must be clear that both Redux and MobX work well with React.</p>
<p>Redux has a much bigger community, its developer tools are much more mature, and there is more support when integrating with other tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting to Redux</h1>
                </header>
            
            <article>
                
<p>Let’s start by installing Redux:</p>
<pre><strong>$ yarn add redux</strong></pre>
<p>There’s also an official React binding that provides the <kbd>connect</kbd> method that helps you connect a component to the store:</p>
<pre><strong>$ yarn add react-redux</strong></pre>
<p>You may also want to install the Redux DevTools (<a href="https://github.com/reduxjs/redux-devtools">https://github.com/reduxjs/redux-devtools</a>) as it'll make debugging with Redux much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the store</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, the entire state of the application is stored as a single object inside a construct called the <em>store</em>. The store is central to a Redux application, so let’s create it. Inside <kbd>src/index.jsx</kbd>, add the following lines:</p>
<pre>import { createStore } from 'redux';<br/> <br/> const initialState = {};<br/> const reducer = function (state = initialState, action) {<br/>   return state;<br/> }<br/> const store = createStore(reducer, initialState);</pre>
<p>The <kbd>createStore</kbd> method accepts three parameters:</p>
<ul>
<li><kbd>reducer</kbd> <em>function</em>: A function that takes in the current state and an action, and uses them to generate a new state.</li>
<li><kbd>initialState</kbd> <em>any</em>: The initial state. The <kbd>initialState</kbd> can be of any data type, but we will use an object literal here.</li>
</ul>
<ul>
<li><kbd>enhancer</kbd> <em>function</em>: A function that takes in the current store, and modifies it to create a new, "enhanced" store. You may wish to use enhancers to implement middleware:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ae39ed1-b9bf-4342-9214-19ec75bbac2c.jpg" style="width:25.75em;height:21.50em;"/></div>
<p>At the moment, we’ll just focus on creating a store with a state, so we’re using a dummy reducer, which simply returns the state.</p>
<p>The store object has many methods, the most important of which are:</p>
<ul>
<li><kbd>getState</kbd>: Gets the current state of the store</li>
<li><kbd>dispatch</kbd>: Dispatches an action to the store</li>
<li><kbd>subscribe</kbd>: Subscribe functions to run whenever the store’s state changes</li>
</ul>
<p class="FirstParagraph"><span>We will be using these three methods to implement our Redux integration.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifting the state up</h1>
                </header>
            
            <article>
                
<p>So let’s work on lifting the state up. Currently, we are holding the state in our two form elements. So let’s migrate those <em>local</em> states into the <em>central</em> state we’re keeping inside our Redux store.</p>
<p>Remove the constructor methods inside the <kbd>LoginForm</kbd> and <kbd>RegistrationForm</kbd> components (these were only used to initialize the states), and update our <kbd>initialState</kbd> object to the following:</p>
<pre>const initialState = {<br/>   loginForm: {<br/>     token: null,<br/>     email: {<br/>       value: "",<br/>       valid: null<br/>     },<br/>     password: {<br/>       value: "",<br/>       valid: null<br/>     }<br/>   },<br/>   registrationForm: {<br/>     userId: null,<br/>     email: {<br/>       value: "",<br/>       valid: null<br/>     },<br/>     password: {<br/>       value: "",<br/>       valid: null<br/>     }<br/>   }<br/> };</pre>
<p>Then, we need to make this central state available to the components. We do this by passing the states down to the form components via the <kbd>Route</kbd> component:</p>
<pre>&lt;Route exact path="/register" store={store} render={() =&gt; &lt;RegistrationForm {...store.getState().registrationForm} /&gt;} /&gt;,<br/> &lt;Route exact path="/login" store={store} render={() =&gt; &lt;LoginForm {...store.getState().loginForm} /&gt;} /&gt;,</pre>
<p>We are using <kbd>store.getState()</kbd> to get the current state of the store, and we are passing in only the relevant parts into the component.</p>
<p>Note that we are using the render prop of <kbd>Route</kbd> instead of the component. The render prop is useful when you want to pass in in-scope variables without causing the component to unmount and re-mount.</p>
<p>Then, we need to make sure that <kbd>ReactDOM.render</kbd> is called whenever the state changes, so the UI is a deterministic representation of our state. We do this by wrapping the <kbd>ReactDOM.render</kbd> call in a function, and invoking it each time the state changes by providing it as the argument to <kbd>store.subscribe</kbd>:</p>
<pre>function render () {<br/>   ReactDOM.render( ... );<br/> }<br/> <br/> store.subscribe(render);<br/> <br/> render();</pre>
<p>Lastly, inside the <kbd>LoginForm</kbd> and <kbd>RegistrationForm</kbd> components, change every instance of <kbd>this.state</kbd> to <kbd>this.props</kbd>.</p>
<p>The UI is now a deterministic representation of our state.</p>
<p>Save and run <kbd>yarn run serve</kbd> to serve this new version of our application. You’ll notice that when you type in the input box, the value of the input box doesn't change. This is because we haven’t dispatched an action that'll alter our state.</p>
<p>Try changing the value of <kbd>initialState.loginForm.email.value</kbd> and re-serve the application. You'll see that it is reflected in the form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatching actions</h1>
                </header>
            
            <article>
                
<p>Now we have integrated with React to make our UI a deterministic representation of our state. However, as demonstrated when you tried typing in the input box, there’s no way for us to update the state. Let's change that now.</p>
<p>Just to recap, the way you change a state in Redux is by dispatching an action, and defining reducers that react to those actions and update the state.</p>
<p>Let’s start with a scenario where we are updating the state; for instance, when we type in the input box in one of the forms. At the moment, we are using the <kbd>handleInputChange</kbd> method to update the local state:</p>
<pre>handleInputChange = (name, event) =&gt; {<br/>   const value = event.target.value;<br/>   const valid = validator[name](value);<br/>   this.setState({<br/>     [name]: { value, valid }<br/>   });<br/> }</pre>
<p>Instead, we want to update this event handler to dispatch an action.</p>
<p>An action is simply an object that describes the event that has occurred. It should be as concise as possible. After creating an action, you call the <kbd>dispatch</kbd> method on the store to dispatch the action. For instance, the action to dispatch after an input value changed in our <kbd>RegistrationForm</kbd> component would look like this:</p>
<pre>handleInputChange = (name, event) =&gt; {<br/>   const value = event.target.value;<br/>   const action = {<br/>     type: 'RegistrationForm:update',<br/>     field: name,<br/>     value<br/>   }<br/>   this.props.store.dispatch(action);<br/> }</pre>
<p class="FirstParagraph"><span>Note that we removed the validation logic. This is because it does not describe the event that has occurred (the input value changed). This validation logic belongs in the reducer, which we will implement now.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the state with the Reducer</h1>
                </header>
            
            <article>
                
<p>Update the dummy reducer function to the following:</p>
<pre>import deepmerge from 'deepmerge';<br/> import { validator } from './utils';<br/> const reducer = function (state = initialState, action) {<br/>   if (action.type === 'RegistrationForm:update') {<br/>     const { field, value } = action;<br/>     const valid = validator[field](value);<br/>     const newState = {<br/>       registrationForm: {<br/>         [field]: {<br/>           value,<br/>           valid<br/>         }<br/>       }<br/>     }<br/>     return deepmerge(state, newState);<br/>   }<br/>   return state;<br/> }</pre>
<p>We have migrated the validation logic here, and we are returning a new instance of the state. Because our state object has many layers, simply using <kbd>Object.assign</kbd> or the ES6 spread syntax would not be sufficient. Therefore, we are using an NPM package called <kbd>deepmerge</kbd> to perform the merge of our old and new states. So, make sure we are adding that package to our project:</p>
<pre><strong>$ yarn add deepmerge</strong></pre>
<p>Convert the rest of the <kbd>RegistrationForm</kbd> component to use Redux (that is, change the <kbd>handleRegistration</kbd> method), and then do the same for the <kbd>LoginForm</kbd> component.</p>
<p>Then, serve your application again, and it should work the same way as before. But always run <kbd>yarn run test:e2e</kbd> to make sure!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting with React Redux</h1>
                </header>
            
            <article>
                
<p>So far, we’ve used <kbd>createStore</kbd> to create a new store, <kbd>store.getState</kbd> to get the state of the store, <kbd>store.dispatch</kbd> to dispatch actions that get processed by the reducer to alter the state, and finally <kbd>subscribe</kbd> to re-run our <kbd>render</kbd> function whenever the state changed.</p>
<p>We had to do all that by hand, but there’s a better alternative that simplifies this as well as adds many performance optimizations that prevents unnecessary re-renders. React Redux is the official binding of Redux for React. It provides a <kbd>connect</kbd> function that will replace the role of <kbd>store.subscribe</kbd>, reads from the Redux store’s state, and passes the relevant parts as props to the presentational components (for example, <kbd>Input</kbd> and <kbd>Button</kbd>). Let’s install it now:</p>
<pre><strong>$ yarn add react-redux</strong></pre>
<p class="mce-root"/>
<p>It works with React Redux like this:</p>
<ul>
<li>You wrap the root component of the application with the <kbd>&lt;Provider&gt;</kbd> component. This makes the Redux store available to every component within the app.</li>
<li>Within each container component that needs to read from the state, you use the <kbd>connect</kbd> function to connect the component to the Redux store.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping with the Provider component</h1>
                </header>
            
            <article>
                
<p>First, remove the <kbd>store.subscribe</kbd> call from <kbd>src/index.jsx</kbd>. We no longer need this as <kbd>connect</kbd> will take care of subscribing to changes to the state. This also means we no longer need to wrap our <kbd>ReactDOM.render</kbd> call inside a function.</p>
<p>Next, since we will be calling <kbd>connect</kbd> within each component, there’s no need to pass the store and the state properties as props. Therefore, in our <kbd>&lt;Route&gt;</kbd> components, switch back to using the component prop instead of <kbd>render</kbd>.</p>
<p>Most importantly, wrap our entire application with the <kbd>&lt;Provider&gt;</kbd> component, passing the store as its only prop:</p>
<pre>import { Provider } from 'react-redux';<br/> ReactDOM.render((<br/>   &lt;Provider store={store}&gt;<br/>     &lt;BrowserRouter&gt;<br/>       &lt;Switch&gt;<br/>       &lt;Route exact path="/register" component={RegistrationForm} /&gt;<br/>       &lt;Route exact path="/login" component={LoginForm} /&gt;<br/>       &lt;/Switch&gt;<br/>     &lt;/BrowserRouter&gt;<br/>   &lt;/Provider&gt;<br/> ), document.getElementById('renderTarget'));</pre>
<p>Now, the store is available to all components within the app. To access the store’s state and to dispatch actions to the store, we’d need to use <kbd>connect</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to the Redux store</h1>
                </header>
            
            <article>
                
<p>Now that we are not passing down the store and the state to the form components, we need to use <kbd>connect</kbd> to re-connect the component to the store.</p>
<p>The <kbd>connect</kbd> function has the following signature:</p>
<pre>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</pre>
<p>All arguments are optional, and are described next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">mapStateToProps</h1>
                </header>
            
            <article>
                
<p>If <kbd>mapStateToProps</kbd> is a function, then the component will subscribe to changes in the store’s state. When a change occurs, the <kbd>mapStateToProps</kbd> function will be invoked, and is passed the store’s entire updated state. The function should extract the parts of the state that are relevant to this component, and return them as an object literal. This object literal will then be merged with the props passed to the component and be available in its methods through <kbd>this.props</kbd>.</p>
<p>For our <kbd>LoginForm</kbd> component, we only care about the <kbd>loginForm</kbd> property inside the state, and so replace our current export statement:</p>
<pre>export default LoginForm;</pre>
<p class="FirstParagraph"><span>With this:</span></p>
<pre>function mapStateToProps (state) {<br/>   return state.loginForm;<br/> }<br/> export default connect(mapStateToProps)(LoginForm);</pre>
<p>Do the same for <kbd>RegistrationForm</kbd>.</p>
<p>If a component does not need to read the state from the store, but needs to interact with the store in other ways (for example, dispatching an event), then you can use <kbd>null</kbd> or <kbd>undefined</kbd> for the <kbd>mapStateToProps</kbd> argument. The component would then no longer react to state changes.</p>
<p>The <kbd>connect</kbd> function itself returns a function that you can then use to wrap your component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">mapDispatchToProps</h1>
                </header>
            
            <article>
                
<p>While <kbd>mapStateToProps</kbd> allows a component to subscribe to a store's state changes, <kbd>mapDispatchToProps</kbd> allows a component to dispatch actions to the store.</p>
<p>It is called with a reference to the store’s dispatch method, and should return an object where each key maps to a function that calls the dispatch method.</p>
<p>For instance, our <kbd>mapDispatchToProps</kbd> function may look like this:</p>
<pre>function mapDispatchToProps (dispatch) {<br/>   return {<br/>     handleInputChange: (name, event) =&gt; {<br/>       const value = event.target.value;<br/>       const action = {<br/>         type: 'LoginForm:update',<br/>         field: name,<br/>         value<br/>       }<br/>       dispatch(action);<br/>     }<br/>   };<br/> };</pre>
<p>The <kbd>handleInputChange</kbd> key will get merged into the component's props, and be available in the component’s methods as <kbd>this.props.handleInputChange</kbd>. And thus, we can update the <kbd>onChange</kbd> prop on our Input components to <kbd>onChange={this.props.handleInputChange}</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoupling Redux from components</h1>
                </header>
            
            <article>
                
<p>You may be thinking, "This looks extremely convoluted, why can't I just pass the dispatch as the props and call <kbd>this.props.dispatch()</kbd> in my event handlers? Similar to what we did before?” Like so:</p>
<pre>function mapDispatchToProps (dispatch) {<br/>   return { dispatch };<br/> };</pre>
<p>Whilst that is certainly possible, it couples our component to Redux. Outside Redux, the concept of a dispatch method does not exist. Therefore, using <kbd>dispatch</kbd> within our component’s methods effectively ties the component to the Redux environment.</p>
<p>By using the <kbd>mapDispatchToProps</kbd> function, we are decoupling the component from Redux. Now, <kbd>this.props.handleInputChange</kbd> is just a function we’ve passed down to the component. If we later decide not to use Redux, or we want to re-use the component in a non-Redux environment, we can simply pass down a different function, without changing the component code.</p>
<p>Similarly, we can pull the dispatch call from the <kbd>handleLogin</kbd> event handler into <kbd>mapDispatchToProps</kbd>:</p>
<pre>function mapDispatchToProps (dispatch) {<br/>   return {<br/>     handleInputChange: (name, event) =&gt; { ... },<br/>     handleSuccess: token =&gt; {<br/>       const action = {<br/>         type: 'LoginForm:success',<br/>         token<br/>       }<br/>       dispatch(action);<br/>     }<br/>   };<br/> };</pre>
<p>To connect the dots, pass <kbd>mapStateToProps</kbd> and <kbd>mapDispatchToProps</kbd> into <kbd>connect</kbd>. This returns with a function that you can use to wrap the <kbd>LoginForm</kbd> component:</p>
<pre>export default connect(<br/>   mapStateToProps,<br/>   mapDispatchToProps<br/> )(LoginForm);</pre>
<p>Note that the original component (<kbd>LoginForm</kbd>) is not mutated. Instead, a newly-wrapped component is created and exported.</p>
<p>Then use <kbd>handleSuccess</kbd> in the <kbd>handleLogin</kbd> event handler:</p>
<pre>class LoginForm extends React.Component {<br/>   handleLogin = (event) =&gt; {<br/>     ...<br/>     fetch(request)<br/>       .then( ... )<br/>       .then(this.props.handleSuccess)<br/>       .catch(console.error)<br/>   }<br/> }</pre>
<p>Repeat the same steps for <kbd>RegistrationForm</kbd>. As always, run the tests to ensure there are no typos or mistakes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have migrated our code to use Redux to manage our state. Having a single state store makes things much easier to manage and maintain.</p>
<p>We have now finished our mini-tour of the front-end world. In the next chapter, we will look at how to use <strong>Docker</strong> to containerize our applications and make each service more independent and self-contained.</p>


            </article>

            
        </section>
    </body></html>