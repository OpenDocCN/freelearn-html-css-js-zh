<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating a Map</h1>
                
            
            
                
<p>It's been quite a ride so far. We've gone through all the different aspects that encompass the creation of a map. We've touched on the basics of SVG, JavaScript, and D3. Now, it's time to put all the pieces together and actually have a final deliverable product. In this chapter, we will cover the following topics through a series of experiments:</p>
<ul>
<li>Foundation - creating your basic map</li>
<li>Experiment 1 - adjusting the bounding box</li>
<li>Experiment 2 - creating choropleths</li>
<li>Experiment 3 - adding click events to our visualization</li>
<li>Experiment 4 - using updates and transitions to enhance our visualization</li>
<li>Experiment 5 - adding points of interest</li>
<li>Experiment 6 - adding visualizations as a point of interest</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Foundation - creating your basic map</h1>
                
            
            
                
<p>In this section, we will walk through the basics of creating a standard map.<br/>
The example can be viewed by opening the <kbd>example-1.html</kbd> file of this chapter provided with this book. If you already have the HTTP server running, you can point your browser to <kbd>http://localhost:8080/chapter-4/example-1.html</kbd>. On the screen is Mexico (Oscar's beloved country)!</p>
<div><img src="img/ea3f5f64-7d25-4a43-9eac-c4d892d1740b.png"/></div>
<p>Let's walk through the code to get a step-by-step explanation of how to create this map.</p>
<p>The <kbd>width</kbd> and <kbd>height</kbd> can be anything you want. Depending on where your map will be visualized (cellphones, tablets, or desktops), you might want to consider providing a different <kbd>width</kbd> and <kbd>height</kbd>:</p>
<pre>var height = 600; 
var width = 900; </pre>
<p>The next variable defines a projection algorithm that allows you to go from a cartographic space (latitude and longitude) to a Cartesian space (<em>x, y</em>)—basically a mapping of latitude and longitude to coordinates. You can think of a projection as a way to map the three-dimensional globe to a flat plane. There are many kinds of projections, but <kbd>geoMercator()</kbd> is normally the default value you will use:</p>
<pre>var projection = d3.geoMercator(); 
var mexico = void 0; </pre>
<p>If you were making a map of the USA, you could use a better projection called AlbersUsa. This is to better position Alaska and Hawaii. By creating a <kbd>geoMercator()</kbd> projection, Alaska would render proportionate to its size, rivaling that of the entire US. The <kbd>geoAlbersUsa()</kbd> projection grabs Alaska, makes it smaller, and puts it at the bottom of the visualization. The following screenshot is of <kbd>geoMercator()</kbd>:</p>
<div><img src="img/cad1c5b8-d456-4c31-a56a-c14577435bc7.png"/></div>
<p>This next screenshot is of <kbd>geoAlbersUsa()</kbd>:</p>
<div><img src="img/5d55e359-bcb2-4460-b97c-f2562494bb42.png"/></div>
<p class="gmail-p1">The D3 library currently contains many built-in projection algorithms. An overview of each one can be viewed at <a href="https://github.com/d3/d3-geo/blob/master/README.md#projections" target="_blank">https://github.com/d3/d3-geo/blob/master/README.md#projections</a>.</p>
<p>Next, we will assign the projection to our <kbd>geoPath()</kbd> function. This is a special D3 function that will map the JSON-formatted geographic data into SVG paths. The data format that the <kbd>geoPath()</kbd> function requires is named GeoJSON and will be covered in <a href="80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml">Chapter 6</a>, <em>Finding and Working with Geographic Data</em>:</p>
<pre>var path = d3.geoPath().projection(projection); 
var svg = d3.select("#map") 
    .append("svg") 
    .attr("width", width) 
    .attr("height", height); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Including the dataset</h1>
                
            
            
                
<p>The necessary data has been provided for you within the <kbd>data</kbd> folder, with the filename <kbd>geo-data.json</kbd>:</p>
<pre>d3.json('geo-data.json', function(data) { 
  console.log('mexico', data); </pre>
<p>We get the data from an AJAX call, as we saw in the previous chapter.</p>
<p>After the data has been collected, we want to draw only those parts of the data that we are interested in. In addition, we want to automatically scale the map to fit the defined height and width of our visualization.</p>
<p>If you look at the console, you'll see that <kbd>mexico</kbd> has an <kbd>objects</kbd> property. Nested inside the <kbd>objects</kbd> property is <kbd>MEX_adm1</kbd>. This stands for the administrative areas of Mexico. It is important to understand the geographic data you are using, because other data sources might have different names for the administrative areas property:</p>
<div><img src="img/511285b8-5b6a-4f9b-b242-6d08df5913d5.png"/></div>
<p>Notice that the <kbd>MEX_adm1</kbd> property contains a <kbd>geometries</kbd> array with 32 elements. Each of these elements represents a state in Mexico. Use this data to draw the D3 visualization:</p>
<pre>  var states = topojson.feature(data, data.objects.MEX_adm1); </pre>
<p>Here, we pass all of the administrative areas to the <kbd>topojson.feature()</kbd> function in order to extract and create an array of GeoJSON objects. The preceding <kbd>states</kbd> variable now contains the <kbd>features</kbd> property. This <kbd>features</kbd> array is a list of 32 GeoJSON elements, each representing the geographic boundaries of a state in Mexico. We will set an initial scale and translation to <kbd>1</kbd> and <kbd>[0,0]</kbd> respectively:</p>
<pre>  // Setup the scale and translate 
  projection.scale(1).translate([0, 0]); </pre>
<p>This algorithm is quite useful. The bounding box is a spherical box that returns a two-dimensional array of min/max coordinates, inclusive of the geographic data passed:</p>
<pre>  var b = path.bounds(states); </pre>
<p>To quote the D3 documentation:</p>
<p>"The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]], where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude."</p>
<p>This is very helpful if you want to programmatically set the scale and translation of the map. In this case, we want the entire country to fit in our <kbd>height</kbd> and <kbd>width</kbd>, so we determine the bounding box of every state in the country of Mexico.</p>
<p>The scale is calculated by taking the longest geographic edge of our bounding box and dividing it by the number of pixels of this edge in the visualization:</p>
<pre>var s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - <br/> b[0][1]) / height);</pre>
<p>This can be calculated by first computing the scale of the <kbd>width</kbd>, then the scale of the <kbd>height</kbd>, and, finally, taking the larger of the two. All of the logic is compressed into the single line given earlier. The three steps are explained in the following image:</p>
<div><img src="img/3ad83fa4-dff7-4993-a1ed-f0ff938b4805.png"/></div>
<p>The <kbd>95</kbd> value adjusts the scale because we are giving the map a bit of a breather at the edges in order to not have the paths intersect the edges of the SVG container item, basically reducing the scale by 5%.</p>
<p>Now, we have an accurate scale of our map, given our set <kbd>width</kbd> and <kbd>height</kbd>:</p>
<pre>var t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * <br/> (b[1][1] + b[0][1])) / 2];</pre>
<p>As we saw in <a href="029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml">Chapter 2</a>, <em>Creating Images from Simple Text</em>, when we scale in SVG, it scales all the attributes (even <em>x</em> and <em>y</em>). In order to return the map to the center of the screen, we will use the <kbd>translate()</kbd> function.</p>
<p>The <kbd>translate()</kbd> function receives an array with two parameters: the amount to translate in <em>x</em>, and the amount to translate in <em>y</em>. We will calculate <em>x</em> by finding the center <em>(topRight - topLeft)/2</em> and multiplying it by the scale. The result is then subtracted from the width of the SVG element.</p>
<p>Our <em>y</em> translation is calculated similarly but using the <em>bottomRight - bottomLeft</em> values divided by 2, multiplied by the scale, then subtracted from the <kbd>height</kbd>.</p>
<p>Finally, we will reset the projection to use our new scale and translation:</p>
<pre>  projection.scale(s).translate(t); </pre>
<p>Here, we will create a map variable that will group all of the following SVG elements into a <kbd>&lt;g&gt;</kbd> SVG tag. This will allow us to apply styles and better contain all of the proceeding paths' elements:</p>
<pre>  var map = svg.append('g').attr('class', 'boundary'); </pre>
<p>Finally, we are back to the classic D3 enter, update, and exit pattern. We have our data, the list of Mexico states, and we will join this data to the <kbd>path</kbd> SVG element:</p>
<pre>    mexico = map.selectAll('path').data(states.features); 
 
    //Enter 
    mexico.enter() 
       .append('path') 
       .attr('d', path); </pre>
<p>The <kbd>Enter</kbd> section and the corresponding <kbd>path</kbd> functions are executed on every data element in the array. As a refresher, each element in the array represents a state in Mexico. The <kbd>path</kbd> function has been set up to correctly draw the outline of each state, as well as scale and translate it to fit in our SVG container.</p>
<p>Congratulations! You have created your first map!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 1 – adjusting the bounding box</h1>
                
            
            
                
<p>Now that we have our foundation, let's start with our first experiment. For this experiment, we will manually zoom into a state of Mexico using what we learned in the previous section. The code can be found in <kbd>example-2.html</kbd> (<kbd>http://localhost:8080/chapter-4/example-2.html</kbd>); however, feel free to edit <kbd>example-1.html</kbd> to learn as you go.</p>
<p>For this experiment, we will modify one line of code:</p>
<pre>  var b = path.bounds(states.features[5]); </pre>
<p>Here, we are telling the calculation to create a boundary based on the sixth element of the <kbd>features</kbd> array instead of every state in the country of Mexico. The boundaries data will now run through the rest of the scaling and translation algorithms to adjust the map to the one shown in the following screenshot:</p>
<div><img src="img/e7f20bfe-f9a6-4c5e-895a-60d03c6088a3.png"/></div>
<p>We have basically reduced the min/max of the boundary box to include the geographic coordinates for one state in Mexico (see the next screenshot), and D3 has scaled and translated this information for us automatically:</p>
<div><img src="img/c4bc88ba-d830-4e64-ba46-31ae0abb8659.png"/></div>
<p>This can be very useful in situations where you might not have the data that you need in isolation from the surrounding areas. Hence, you can always zoom into your geography of interest and isolate it from the rest.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 2 – creating choropleths</h1>
                
            
            
                
<p>One of the most common uses of D3.js maps is to make choropleths. This visualization gives you the ability to discern between regions, giving them a different color. Normally, this color is associated with some other value, for instance, levels of influenza or a company's sales. The Choropleths are very easy to make in D3.js. In this experiment, we will create a quick choropleth based on the index value of the state in the array of all the states. Look at the following code, or use your browser and go here: <kbd>http://localhost:8080/chapter-4/example-3.html</kbd>.</p>
<p>We will only need to modify two lines of code in the <kbd>Update</kbd> section of our D3 code. Right after the <kbd>enter()</kbd> section, add the following two lines:</p>
<pre>  //Update 
  var color = d3.scaleLinear().domain([0,33]).range(['red', <br/>   'yellow']); <br/>  //Enter
  mexico.enter()<br/>           .append('path')<br/>           .attr('d', path)<br/>           .attr('fill', function(d,i){<br/>            return color(i);<br/>           });</pre>
<p>The <kbd>color</kbd> variable uses another valuable D3 function named <kbd>scale</kbd>. Scales are extremely powerful when creating visualizations in D3; much more detail on scales can be found at: <a href="https://github.com/d3/d3/blob/master/API.md#scales-d3-scale">https://github.com/d3/d3/blob/master/API.md#scales-d3-scale</a>.</p>
<p>For now, let's describe what this scale defines. Here, we created a new function called <kbd>color()</kbd>. This <kbd>color()</kbd> function looks for any number between <kbd>0</kbd> and <kbd>33</kbd> in an input domain. D3 linearly maps these input values to a color between red and yellow in the output range. D3 has included the capability to automatically map colors in a linear range to a gradient. This means that executing the new function, <kbd>color</kbd>, with <kbd>0</kbd> will return the color red, <kbd>color(15)</kbd> will return an orange color, and <kbd>color(33)</kbd> will return yellow.</p>
<p>Here is a small table just for visual reference. It shows the color and its respective RGB value:</p>
<div><img height="537" width="357" src="img/82b7470e-4f6c-4bf4-a367-af9ce75323bb.png"/></div>
<p>Now, in the update section, we will set the <kbd>fill</kbd> property of the path to the new <kbd>color()</kbd> function. This will provide a linear scale of colors and use the index value <kbd>i</kbd> to determine what color should be returned.</p>
<p>If the color was determined by a different value of the datum, for instance <kbd>d.scales</kbd>, then you would have a choropleth where the colors actually represent sales. The preceding code should render something as follows:</p>
<div><img src="img/d651273d-477a-41be-b137-488f9d9bb65d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 3 – adding click events to our visualization</h1>
                
            
            
                
<p>We've seen how to make a map and set different colors to the different regions of this map. Next, we will add a little bit of interactivity. This will illustrate a simple reference to bind click events to maps. For this experiment, we will build on the previous exercise, <kbd>example-3.html</kbd>. You can see the completed experiment at: <kbd>http://localhost:8080/chapter-4/example-4.html</kbd>.</p>
<p>First, we need a quick reference to each state in the country. To accomplish this, we will create a new function called <kbd>geoID</kbd> right below the <kbd>mexico</kbd> variable:</p>
<pre>  var height = 600; 
  var width = 900; 
  var projection = d3.geoMercator(); 
  var mexico = void 0; 
 
  var geoID = function(d) { 
    return "c" + d.properties.ID_1; 
  }; </pre>
<p>This function takes in a <kbd>state</kbd> data element and generates a new selectable ID based on the <kbd>ID_1</kbd> property found in the data. The <kbd>ID_1</kbd> property contains a unique numeric value for every state in the array. If we insert this as an <kbd>id</kbd> attribute into the DOM, then we would create a quick and easy way to select each state in the country.</p>
<p>The following is the <kbd>geoID()</kbd> function, creating another function called <kbd>click</kbd>:</p>
<pre>  var click = function(d) { 
    d3.selectAll('path').attr('fill-opacity',0.2)<br/>    d3.select('#' + geoID(d)).attr('fill-opacity', 1); 
  }; </pre>
<p>This method makes it easy to separate what the <kbd>click</kbd> is doing. The <kbd>click</kbd> method receives the datum and changes the fill opacity value of all the states to <kbd>0.2</kbd>. This is done so that when you click on one state and then on the other, the previous state does not maintain the <em>clicked</em> style. Notice that the function call is iterating through all the elements of the DOM using the D3 update pattern. After making all the states transparent, we will set a fill opacity of <kbd>1</kbd> for the given clicked item. This removes all the transparent styling from the selected state. Notice that we are reusing the <kbd>geoID()</kbd> function that we created earlier to quickly find the state element in the DOM.</p>
<p>Next, let's update the <kbd>enter()</kbd> method to bind our new <kbd>click</kbd> method to every new DOM element that <kbd>enter()</kbd> appends:</p>
<pre>  //Enter 
  mexico.enter() 
     .append('path') 
     .attr('d', path) 
     .attr('id', geoID) 
     .on("click", click)<br/>     .attr('fill', function(d,i) { return color(i); }) </pre>
<p>We also added an attribute called <kbd>id</kbd>; this inserts the results of the <kbd>geoID()</kbd> function into the <kbd>id</kbd> attribute. Again, this makes it very easy to find the clicked state.</p>
<p>The code base should produce a map as follows. Check it out and make sure that you click on any of the states. You will see its color turn a little brighter than the surrounding states:</p>
<div><img src="img/54243b10-e8eb-4950-b0ed-c572707fd5bc.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 4 – using updates and transitions to enhance our visualization</h1>
                
            
            
                
<p>For our next experiment, we will take all of our combined knowledge and add some smooth transitions to the map. Transitions are a fantastic way to add style and smoothness to data changes.</p>
<p>This experiment will, again, require us to start with <kbd>example-3.html</kbd>. The complete experiment can be viewed at <kbd>http://localhost:8080/chapter-4/example-5.html</kbd>.</p>
<p>If you remember, we leveraged the JavaScript <kbd>setInterval()</kbd> function to execute updates at a regular timed frequency. We will go back to this method now to assign a random number between 1 and 33 to our existing <kbd>color()</kbd> function. We will then leverage a D3 method to smoothly transition between the random color changes.</p>
<p>Right below the update section, add the following <kbd>setInterval()</kbd> block of code:</p>
<pre>    setInterval(function(){<br/>      map.selectAll('path').transition().duration(500)<br/>          .attr('fill', function(d) {<br/>            return color(Math.floor((Math.random() * 32) + 1));<br/>          });<br/>    },2000);</pre>
<p>This method indicates that, for every <kbd>2000</kbd> milliseconds (2 seconds), the <kbd>map</kbd> update section should be executed and the color set to a random number between <kbd>1</kbd> and <kbd>32</kbd>. The new <kbd>transition</kbd> and <kbd>duration</kbd> methods transition from the previous state to the new state over <kbd>500</kbd> milliseconds. Open <kbd>example-5.html</kbd> in your browser and you should see the initial color based on the index of the state. After 2 seconds, the colors should smoothly transition to new values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 5 – adding points of interest</h1>
                
            
            
                
<p>So far, everything we have done has involved working directly with the geographic data and map. However, there are many cases where you will need to layer additional data on top of the map. We will begin slowly by first adding a few cities of interest to the map of Mexico.</p>
<p>This experiment will, again, require us to start with <kbd>example-3.html</kbd>. The complete experiment can be viewed at: <kbd>http://localhost:8080/chapter-4/example-6.html</kbd>.</p>
<p>In this experiment, we will add a <kbd>text</kbd> element to the page to identify the city. To make the text more visually appealing, we will first add some simple styling in the <kbd>&lt;style&gt;</kbd> section:</p>
<pre>text{ 
  font-family: Helvetica; 
  font-weight: 300; 
  font-size: 12px; 
} </pre>
<p>Next, we need some data that will indicate the city name, the latitude, and longitude coordinates. For the sake of simplicity, we have added a file with a few starter cities. The file called <kbd>cities.csv</kbd> is in the same directory as the examples:</p>
<pre>name,lat,lon, 
Cancun,21.1606,-86.8475 
Mexico City,19.4333,-99.1333 
Monterrey,25.6667,-100.3000 
Hermosillo,29.0989,-110.9542 </pre>
<p>Now, add a few lines of code to bring in the data and plot the city locations and names on your map. Add the following block of code right below the exit section (if you are starting with <kbd>example-2.html</kbd>):</p>
<pre>    d3.csv('cities.csv', function(cities) { 
      var cityPoints = svg.selectAll('circle').data(cities); 
      var cityText = svg.selectAll('text').data(cities); 
 
      cityPoints.enter() 
          .append('circle') 
          .attr('cx', function(d) {<br/>             return projection ([d.lon, d.lat])[0]<br/>          })<br/>          .attr('cy', function(d) {<br/>             return projection ([d.lon, d.lat])[1]<br/>          }) 
          .attr('r', 4) 
          .attr('fill', 'steelblue'); 
 
      cityText.enter() 
          .append('text') 
          .attr('x', function(d) {<br/>             return projection([d.lon, d.lat])[0]})<br/>          .attr('y', function(d) {<br/>             return projection([d.lon, d.lat])[1]}) 
          .attr('dx', 5) 
          .attr('dy', 3) 
          .text(function(d) {return d.name}); 
    }); </pre>
<p>Let's review what we just added.</p>
<p>The <kbd>d3.csv</kbd> function will make an AJAX call to our data file and automatically format the entire file into an array of JSON objects. Each property of the object will take on the corresponding name of the column in the <kbd>.csv</kbd> file. For example, take a look at the following lines of code:</p>
<pre>[{ 
  "name": "Cancun",  
  "lat":"21.1606",  
  "lon":"-86.8475" 
}, ...] </pre>
<p>Next, we define two variables to hold our data join to the circle and text the SVG elements.</p>
<p>Finally, we will execute a typical enter pattern to place the points as circles and the names as text SVG tags on the map. The <em>x</em> and <em>y</em> coordinates are determined by calling our previous <kbd>projection()</kbd> function with the corresponding latitude and longitude coordinates from the data file.</p>
<p>Note that the <kbd>projection()</kbd> function returns an array of <em>x</em> and <em>y</em> coordinates (<em>x, y</em>). The <em>x</em> coordinate is determined by taking the <kbd>0</kbd> index of the returned array. The <em>y</em> coordinate is determined from the index, <kbd>1</kbd>. For example, take a look at the following code:</p>
<pre>.attr('cx', function(d) {return projection([d.lon, d.lat])[0]})  </pre>
<p>Here, <kbd>[0]</kbd> indicates the <em>x</em> coordinate.</p>
<p>Your new map should look like the one shown in the following screenshot:</p>
<div><img src="img/26281754-34bd-4a14-9183-4822e7b289af.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 6 – adding visualizations as a point of interest</h1>
                
            
            
                
<p>For our final experiment, we will layer visualizations on top of visualizations! Starting from where we left off at <kbd>http://localhost:8080/chapter-4/example-6.html</kbd>, we will add a fictitious column to the data to indicate a metric of tequila consumption (the final version can be seen at <kbd>http://localhost:8080/chapter-4/example-7.html</kbd>):</p>
<pre>name,lat,lon,tequila 
Cancun,21.1606,-86.8475,85,15 
Mexico City,19.4333,-99.1333,51,49 
Monterrey,25.6667,-100.3000,30,70 
Hermosillo,29.0989,-110.9542,20,80 </pre>
<p>With just two more lines of code, we can have the city points portray meaning. In this experiment, we will scale the radius of the city circles in relation to the amount of tequila consumed:</p>
<pre>var radius = d3.scaleLinear().domain([0,100]).range([5,30]);  </pre>
<p>Here, we will introduce a new scale that linearly distributes the input values from <kbd>1</kbd> to <kbd>100</kbd> to a radius length between <kbd>5</kbd> and <kbd>30</kbd>. This means that the minimum radius of a circle will be <kbd>5</kbd> and the maximum will be <kbd>30</kbd>, preventing the circles from growing too large or too small to be readable:</p>
<pre>cityPoints.enter() 
          .append('circle') 
          .attr('cx', function(d) {<br/>             return projection([d.lon, d.lat])[0];})          <br/>          .attr('cy', function(d) {<br/>             return projection([d.lon, d.lat])[1];}) 
          .attr('r', 4) 
          .attr('fill', 'steelblue'); </pre>
<p>Next, we will change the preceding line of code to call the <kbd>radius</kbd> function instead of the hardcoded value of <kbd>4</kbd>. The code will now look like this:</p>
<pre>.attr('r', function(d) {return radius(d.tequila); }) </pre>
<p>After these two small additions, your map should look like the one shown in the following screenshot:</p>
<div><img src="img/9e4296a3-1638-4667-9d41-64816815a38f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>You learned how to build many different kinds of maps that cover different kinds of needs. The choropleths and data visualizations of maps are some of the most common geographic-based data representations that you will come across. We also added interactivity to our map through basic transitions and events. You will easily realize that, with all the information you've gathered so far, you can independently create engaging map visualizations. You can expand your knowledge by learning advanced interactivity techniques in the next chapter.</p>
<p>Hang on tight!</p>


            

            
        
    </body></html>