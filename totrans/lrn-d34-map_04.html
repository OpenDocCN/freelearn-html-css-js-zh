<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating a Map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's been quite a ride so far. </span><span class="koboSpan" id="kobo.2.2">We've gone through all the different aspects that encompass the creation of a map. </span><span class="koboSpan" id="kobo.2.3">We've touched on the basics of SVG, JavaScript, and D3. </span><span class="koboSpan" id="kobo.2.4">Now, it's time to put all the pieces together and actually have a final deliverable product. </span><span class="koboSpan" id="kobo.2.5">In this chapter, we will cover the following topics through a series of experiments:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Foundation - creating your basic map</span></li>
<li><span class="koboSpan" id="kobo.4.1">Experiment 1 - adjusting the bounding box</span></li>
<li><span class="koboSpan" id="kobo.5.1">Experiment 2 - creating choropleths</span></li>
<li><span class="koboSpan" id="kobo.6.1">Experiment 3 - adding click events to our visualization</span></li>
<li><span class="koboSpan" id="kobo.7.1">Experiment 4 - using updates and transitions to enhance our visualization</span></li>
<li><span class="koboSpan" id="kobo.8.1">Experiment 5 - adding points of interest</span></li>
<li><span class="koboSpan" id="kobo.9.1">Experiment 6 - adding visualizations as a point of interest</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Foundation - creating your basic map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we will walk through the basics of creating a standard map.</span><br/><span class="koboSpan" id="kobo.3.1">
The example can be viewed by opening the </span><kbd><span class="koboSpan" id="kobo.4.1">example-1.html</span></kbd><span class="koboSpan" id="kobo.5.1"> file of this chapter provided with this book. </span><span class="koboSpan" id="kobo.5.2">If you already have the HTTP server running, you can point your browser to </span><kbd><span class="koboSpan" id="kobo.6.1">http://localhost:8080/chapter-4/example-1.html</span></kbd><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">On the screen is Mexico (Oscar's beloved country)!</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img src="assets/ea3f5f64-7d25-4a43-9eac-c4d892d1740b.png"/></span></div>
<p><span class="koboSpan" id="kobo.9.1">Let's walk through the code to get a step-by-step explanation of how to create this map.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The </span><kbd><span class="koboSpan" id="kobo.11.1">width</span></kbd><span class="koboSpan" id="kobo.12.1"> and </span><kbd><span class="koboSpan" id="kobo.13.1">height</span></kbd><span class="koboSpan" id="kobo.14.1"> can be anything you want. </span><span class="koboSpan" id="kobo.14.2">Depending on where your map will be visualized (cellphones, tablets, or desktops), you might want to consider providing a different </span><kbd><span class="koboSpan" id="kobo.15.1">width</span></kbd><span class="koboSpan" id="kobo.16.1"> and </span><kbd><span class="koboSpan" id="kobo.17.1">height</span></kbd><span class="koboSpan" id="kobo.18.1">:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">var height = 600; 
var width = 900; </span></pre>
<p><span class="koboSpan" id="kobo.20.1">The next variable defines a projection algorithm that allows you to go from a cartographic space (latitude and longitude) to a Cartesian space (</span><em><span class="koboSpan" id="kobo.21.1">x, y</span></em><span class="koboSpan" id="kobo.22.1">)—basically a mapping of latitude and longitude to coordinates. </span><span class="koboSpan" id="kobo.22.2">You can think of a projection as a way to map the three-dimensional globe to a flat plane. </span><span class="koboSpan" id="kobo.22.3">There are many kinds of projections, but </span><kbd><span class="koboSpan" id="kobo.23.1">geoMercator()</span></kbd><span class="koboSpan" id="kobo.24.1"> is normally the default value you will use:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">var projection = d3.geoMercator(); 
var mexico = void 0; </span></pre>
<p><span class="koboSpan" id="kobo.26.1">If you were making a map of the USA, you could use a better projection called AlbersUsa. </span><span class="koboSpan" id="kobo.26.2">This is to better position Alaska and Hawaii. </span><span class="koboSpan" id="kobo.26.3">By creating a </span><kbd><span class="koboSpan" id="kobo.27.1">geoMercator()</span></kbd><span class="koboSpan" id="kobo.28.1"> projection, Alaska would render proportionate to its size, rivaling that of the entire US. </span><span class="koboSpan" id="kobo.28.2">The </span><kbd><span class="koboSpan" id="kobo.29.1">geoAlbersUsa()</span></kbd><span class="koboSpan" id="kobo.30.1"> projection grabs Alaska, makes it smaller, and puts it at the bottom of the visualization. </span><span class="koboSpan" id="kobo.30.2">The following screenshot is of </span><kbd><span class="koboSpan" id="kobo.31.1">geoMercator()</span></kbd><span class="koboSpan" id="kobo.32.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.33.1"><img src="assets/cad1c5b8-d456-4c31-a56a-c14577435bc7.png"/></span></div>
<p><span class="koboSpan" id="kobo.34.1">This next screenshot is of </span><kbd><span class="koboSpan" id="kobo.35.1">geoAlbersUsa()</span></kbd><span class="koboSpan" id="kobo.36.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.37.1"><img src="assets/5d55e359-bcb2-4460-b97c-f2562494bb42.png"/></span></div>
<p class="gmail-p1"><span class="koboSpan" id="kobo.38.1">The D3 library currently contains many built-in projection algorithms. </span><span class="koboSpan" id="kobo.38.2">An overview of each one can be viewed at</span><span><span class="koboSpan" id="kobo.39.1"> </span></span><span class="Object"><span class="gmail-s2"><a href="https://github.com/d3/d3-geo/blob/master/README.md#projections" target="_blank"><span class="koboSpan" id="kobo.40.1">https://github.com/d3/d3-geo/blob/master/README.md#projections</span></a></span></span><span class="koboSpan" id="kobo.41.1">.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Next, we will assign the projection to our </span><kbd><span class="koboSpan" id="kobo.43.1">geoPath()</span></kbd><span class="koboSpan" id="kobo.44.1"> function. </span><span class="koboSpan" id="kobo.44.2">This is a special D3 function that will map the JSON-formatted geographic data into SVG paths. </span><span class="koboSpan" id="kobo.44.3">The data format that the </span><kbd><span class="koboSpan" id="kobo.45.1">geoPath()</span></kbd><span class="koboSpan" id="kobo.46.1"> function requires is named GeoJSON and will be covered in </span><a href="80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.47.1">Chapter 6</span></span></a><span class="koboSpan" id="kobo.48.1">, </span><em><span class="koboSpan" id="kobo.49.1">Finding and Working with Geographic Data</span></em><span class="koboSpan" id="kobo.50.1">:</span></p>
<pre><span class="koboSpan" id="kobo.51.1">var path = d3.geoPath().projection(projection); 
var svg = d3.select("#map") 
    .append("svg") 
    .attr("width", width) 
    .attr("height", height); </span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Including the dataset</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The necessary data has been provided for you within the </span><kbd><span class="koboSpan" id="kobo.3.1">data</span></kbd><span class="koboSpan" id="kobo.4.1"> folder, with the filename </span><kbd><span class="koboSpan" id="kobo.5.1">geo-data.json</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">d3.json('geo-data.json', function(data) { 
  console.log('mexico', data); </span></pre>
<p><span class="koboSpan" id="kobo.8.1">We get the data from an AJAX call, as we saw in the previous chapter.</span></p>
<p><span class="koboSpan" id="kobo.9.1">After the data has been collected, we want to draw only those parts of the data that we are interested in. </span><span class="koboSpan" id="kobo.9.2">In addition, we want to automatically scale the map to fit the defined height and width of our visualization.</span></p>
<p><span class="koboSpan" id="kobo.10.1">If you look at the console, you'll see that </span><kbd><span class="koboSpan" id="kobo.11.1">mexico</span></kbd><span class="koboSpan" id="kobo.12.1"> has an </span><kbd><span class="koboSpan" id="kobo.13.1">objects</span></kbd><span class="koboSpan" id="kobo.14.1"> property. </span><span class="koboSpan" id="kobo.14.2">Nested inside the </span><kbd><span class="koboSpan" id="kobo.15.1">objects</span></kbd><span class="koboSpan" id="kobo.16.1"> property is </span><kbd><span class="koboSpan" id="kobo.17.1">MEX_adm1</span></kbd><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">This stands for the administrative areas of Mexico. </span><span class="koboSpan" id="kobo.18.3">It is important to understand the geographic data you are using, because other data sources might have different names for the administrative areas property:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1"><img src="assets/511285b8-5b6a-4f9b-b242-6d08df5913d5.png"/></span></div>
<p><span class="koboSpan" id="kobo.20.1">Notice that the </span><kbd><span class="koboSpan" id="kobo.21.1">MEX_adm1</span></kbd><span class="koboSpan" id="kobo.22.1"> property contains a </span><kbd><span class="koboSpan" id="kobo.23.1">geometries</span></kbd><span class="koboSpan" id="kobo.24.1"> array with 32 elements. </span><span class="koboSpan" id="kobo.24.2">Each of these elements represents a state in Mexico. </span><span class="koboSpan" id="kobo.24.3">Use this data to draw the D3 visualization:</span></p>
<pre><span class="koboSpan" id="kobo.25.1">  var states = topojson.feature(data, data.objects.MEX_adm1); </span></pre>
<p><span class="koboSpan" id="kobo.26.1">Here, we pass all of the administrative areas to the </span><kbd><span class="koboSpan" id="kobo.27.1">topojson.feature()</span></kbd><span class="koboSpan" id="kobo.28.1"> function in order to extract and create an array of GeoJSON objects. </span><span class="koboSpan" id="kobo.28.2">The preceding </span><kbd><span class="koboSpan" id="kobo.29.1">states</span></kbd><span class="koboSpan" id="kobo.30.1"> variable now contains the </span><kbd><span class="koboSpan" id="kobo.31.1">features</span></kbd><span class="koboSpan" id="kobo.32.1"> property. </span><span class="koboSpan" id="kobo.32.2">This </span><kbd><span class="koboSpan" id="kobo.33.1">features</span></kbd><span class="koboSpan" id="kobo.34.1"> array is a list of 32 GeoJSON elements, each representing the geographic boundaries of a state in Mexico. </span><span class="koboSpan" id="kobo.34.2">We will set an initial scale and translation to </span><kbd><span class="koboSpan" id="kobo.35.1">1</span></kbd><span class="koboSpan" id="kobo.36.1"> and </span><kbd><span class="koboSpan" id="kobo.37.1">[0,0]</span></kbd><span class="koboSpan" id="kobo.38.1"> respectively:</span></p>
<pre><span class="koboSpan" id="kobo.39.1">  // Setup the scale and translate 
  projection.scale(1).translate([0, 0]); </span></pre>
<p><span class="koboSpan" id="kobo.40.1">This algorithm is quite useful. </span><span class="koboSpan" id="kobo.40.2">The bounding box is a spherical box that returns a two-dimensional array of min/max coordinates, inclusive of the geographic data passed:</span></p>
<pre><span class="koboSpan" id="kobo.41.1">  var b = path.bounds(states); </span></pre>
<p><span class="koboSpan" id="kobo.42.1">To quote the D3 documentation:</span></p>
<div class="packt_quote"><span class="koboSpan" id="kobo.43.1">"The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]], where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude."</span></div>
<p><span class="koboSpan" id="kobo.44.1">This is very helpful if you want to programmatically set the scale and translation of the map. </span><span class="koboSpan" id="kobo.44.2">In this case, we want the entire country to fit in our </span><kbd><span class="koboSpan" id="kobo.45.1">height</span></kbd><span class="koboSpan" id="kobo.46.1"> and </span><kbd><span class="koboSpan" id="kobo.47.1">width</span></kbd><span class="koboSpan" id="kobo.48.1">, so we determine the bounding box of every state in the country of Mexico.</span></p>
<p><span class="koboSpan" id="kobo.49.1">The scale is calculated by taking the longest geographic edge of our bounding box and dividing it by the number of pixels of this edge in the visualization:</span></p>
<pre><span class="koboSpan" id="kobo.50.1">var s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - </span><br/><span class="koboSpan" id="kobo.51.1"> b[0][1]) / height);</span></pre>
<p><span class="koboSpan" id="kobo.52.1">This can be calculated by first computing the scale of the </span><kbd><span class="koboSpan" id="kobo.53.1">width</span></kbd><span class="koboSpan" id="kobo.54.1">, then the scale of the </span><kbd><span class="koboSpan" id="kobo.55.1">height</span></kbd><span class="koboSpan" id="kobo.56.1">, and, finally, taking the larger of the two. </span><span class="koboSpan" id="kobo.56.2">All of the logic is compressed into the single line given earlier. </span><span class="koboSpan" id="kobo.56.3">The three steps are explained in the following image:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.57.1"><img src="assets/3ad83fa4-dff7-4993-a1ed-f0ff938b4805.png"/></span></div>
<p><span class="koboSpan" id="kobo.58.1">The </span><kbd><span class="koboSpan" id="kobo.59.1">95</span></kbd><span class="koboSpan" id="kobo.60.1"> value adjusts the scale because we are giving the map a bit of a breather at the edges in order to not have the paths intersect the edges of the SVG container item, basically reducing the scale by 5%.</span></p>
<p><span class="koboSpan" id="kobo.61.1">Now, we have an accurate scale of our map, given our set </span><kbd><span class="koboSpan" id="kobo.62.1">width</span></kbd><span class="koboSpan" id="kobo.63.1"> and </span><kbd><span class="koboSpan" id="kobo.64.1">height</span></kbd><span class="koboSpan" id="kobo.65.1">:</span></p>
<pre><span class="koboSpan" id="kobo.66.1">var t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * </span><br/><span class="koboSpan" id="kobo.67.1"> (b[1][1] + b[0][1])) / 2];</span></pre>
<p><span class="koboSpan" id="kobo.68.1">As we saw in </span><a href="029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.69.1">Chapter 2</span></span></a><span class="koboSpan" id="kobo.70.1">, </span><em><span class="koboSpan" id="kobo.71.1">Creating Images from Simple Text</span></em><span class="koboSpan" id="kobo.72.1">, when we scale in SVG, it scales all the attributes (even </span><em><span class="koboSpan" id="kobo.73.1">x</span></em><span class="koboSpan" id="kobo.74.1"> and </span><em><span class="koboSpan" id="kobo.75.1">y</span></em><span class="koboSpan" id="kobo.76.1">). </span><span class="koboSpan" id="kobo.76.2">In order to return the map to the center of the screen, we will use the </span><kbd><span class="koboSpan" id="kobo.77.1">translate()</span></kbd><span class="koboSpan" id="kobo.78.1"> function.</span></p>
<p><span class="koboSpan" id="kobo.79.1">The </span><kbd><span class="koboSpan" id="kobo.80.1">translate()</span></kbd><span class="koboSpan" id="kobo.81.1"> function receives an array with two parameters: the amount to translate in </span><em><span class="koboSpan" id="kobo.82.1">x</span></em><span class="koboSpan" id="kobo.83.1">, and the amount to translate in </span><em><span class="koboSpan" id="kobo.84.1">y</span></em><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">We will calculate </span><em><span class="koboSpan" id="kobo.86.1">x</span></em><span class="koboSpan" id="kobo.87.1"> by finding the center </span><em><span class="koboSpan" id="kobo.88.1">(topRight - topLeft)/2</span></em><span class="koboSpan" id="kobo.89.1"> and multiplying it by the scale. </span><span class="koboSpan" id="kobo.89.2">The result is then subtracted from the width of the SVG element.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Our </span><em><span class="koboSpan" id="kobo.91.1">y</span></em><span class="koboSpan" id="kobo.92.1"> translation is calculated similarly but using the </span><em><span class="koboSpan" id="kobo.93.1">bottomRight - bottomLeft</span></em><span class="koboSpan" id="kobo.94.1"> values divided by 2, multiplied by the scale, then subtracted from the </span><kbd><span class="koboSpan" id="kobo.95.1">height</span></kbd><span class="koboSpan" id="kobo.96.1">.</span></p>
<p><span class="koboSpan" id="kobo.97.1">Finally, we will reset the projection to use our new scale and translation:</span></p>
<pre><span class="koboSpan" id="kobo.98.1">  projection.scale(s).translate(t); </span></pre>
<p><span class="koboSpan" id="kobo.99.1">Here, we will create a map variable that will group all of the following SVG elements into a </span><kbd><span class="koboSpan" id="kobo.100.1">&lt;g&gt;</span></kbd><span class="koboSpan" id="kobo.101.1"> SVG tag. </span><span class="koboSpan" id="kobo.101.2">This will allow us to apply styles and better contain all of the proceeding paths' elements:</span></p>
<pre><span class="koboSpan" id="kobo.102.1">  var map = svg.append('g').attr('class', 'boundary'); </span></pre>
<p><span class="koboSpan" id="kobo.103.1">Finally, we are back to the classic D3 enter, update, and exit pattern. </span><span class="koboSpan" id="kobo.103.2">We have our data, the list of Mexico states, and we will join this data to the </span><kbd><span class="koboSpan" id="kobo.104.1">path</span></kbd><span class="koboSpan" id="kobo.105.1"> SVG element:</span></p>
<pre><span class="koboSpan" id="kobo.106.1">    mexico = map.selectAll('path').data(states.features); 
 
    //Enter 
    mexico.enter() 
       .append('path') 
       .attr('d', path); </span></pre>
<p><span class="koboSpan" id="kobo.107.1">The </span><kbd><span class="koboSpan" id="kobo.108.1">Enter</span></kbd><span class="koboSpan" id="kobo.109.1"> section and the corresponding </span><kbd><span class="koboSpan" id="kobo.110.1">path</span></kbd><span class="koboSpan" id="kobo.111.1"> functions are executed on every data element in the array. </span><span class="koboSpan" id="kobo.111.2">As a refresher, each element in the array represents a state in Mexico. </span><span class="koboSpan" id="kobo.111.3">The </span><kbd><span class="koboSpan" id="kobo.112.1">path</span></kbd><span class="koboSpan" id="kobo.113.1"> function has been set up to correctly draw the outline of each state, as well as scale and translate it to fit in our SVG container.</span></p>
<p><span class="koboSpan" id="kobo.114.1">Congratulations! </span><span class="koboSpan" id="kobo.114.2">You have created your first map!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 1 – adjusting the bounding box</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now that we have our foundation, let's start with our first experiment. </span><span class="koboSpan" id="kobo.2.2">For this experiment, we will manually zoom into a state of Mexico using what we learned in the previous section. </span><span class="koboSpan" id="kobo.2.3">The code can be found in </span><kbd><span class="koboSpan" id="kobo.3.1">example-2.html</span></kbd><span class="koboSpan" id="kobo.4.1"> (</span><kbd><span class="koboSpan" id="kobo.5.1">http://localhost:8080/chapter-4/example-2.html</span></kbd><span class="koboSpan" id="kobo.6.1">); however, feel free to edit </span><kbd><span class="koboSpan" id="kobo.7.1">example-1.html</span></kbd><span class="koboSpan" id="kobo.8.1"> to learn as you go.</span></p>
<p><span class="koboSpan" id="kobo.9.1">For this experiment, we will modify one line of code:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">  var b = path.bounds(states.features[5]); </span></pre>
<p><span class="koboSpan" id="kobo.11.1">Here, we are telling the calculation to create a boundary based on the sixth element of the </span><kbd><span class="koboSpan" id="kobo.12.1">features</span></kbd><span class="koboSpan" id="kobo.13.1"> array instead of every state in the country of Mexico. </span><span class="koboSpan" id="kobo.13.2">The boundaries data will now run through the rest of the scaling and translation algorithms to adjust the map to the one shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img src="assets/e7f20bfe-f9a6-4c5e-895a-60d03c6088a3.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">We have basically reduced the min/max of the boundary box to include the geographic coordinates for one state in Mexico (see the next screenshot), and D3 has scaled and translated this information for us automatically:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img src="assets/c4bc88ba-d830-4e64-ba46-31ae0abb8659.png"/></span></div>
<p><span class="koboSpan" id="kobo.17.1">This can be very useful in situations where you might not have the data that you need in isolation from the surrounding areas. </span><span class="koboSpan" id="kobo.17.2">Hence, you can always zoom into your geography of interest and isolate it from the rest.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 2 – creating choropleths</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the most common uses of D3.js maps is to make choropleths. </span><span class="koboSpan" id="kobo.2.2">This visualization gives you the ability to discern between regions, giving them a different color. </span><span class="koboSpan" id="kobo.2.3">Normally, this color is associated with some other value, for instance, levels of influenza or a company's sales. </span><span class="koboSpan" id="kobo.2.4">The Choropleths are very easy to make in D3.js. </span><span class="koboSpan" id="kobo.2.5">In this experiment, we will create a quick choropleth based on the index value of the state in the array of all the states. </span><span class="koboSpan" id="kobo.2.6">Look at the following code, or use your browser and go here: </span><kbd><span class="koboSpan" id="kobo.3.1">http://localhost:8080/chapter-4/example-3.html</span></kbd><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">We will only need to modify two lines of code in the </span><kbd><span class="koboSpan" id="kobo.6.1">Update</span></kbd><span class="koboSpan" id="kobo.7.1"> section of our D3 code. </span><span class="koboSpan" id="kobo.7.2">Right after the </span><kbd><span class="koboSpan" id="kobo.8.1">enter()</span></kbd><span class="koboSpan" id="kobo.9.1"> section, add the following two lines:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">  //Update 
  var color = d3.scaleLinear().domain([0,33]).range(['red', </span><br/><span class="koboSpan" id="kobo.11.1">   'yellow']); </span><br/><span class="koboSpan" id="kobo.12.1">  //Enter
  mexico.enter()</span><br/><span class="koboSpan" id="kobo.13.1">           .append('path')</span><br/><span class="koboSpan" id="kobo.14.1">           .attr('d', path)</span><br/><span class="koboSpan" id="kobo.15.1">           .attr('fill', function(d,i){</span><br/><span class="koboSpan" id="kobo.16.1">            return color(i);</span><br/><span class="koboSpan" id="kobo.17.1">           });</span></pre>
<p><span class="koboSpan" id="kobo.18.1">The </span><kbd><span class="koboSpan" id="kobo.19.1">color</span></kbd><span class="koboSpan" id="kobo.20.1"> variable uses another valuable D3 function named </span><kbd><span class="koboSpan" id="kobo.21.1">scale</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Scales are extremely powerful when creating visualizations in D3; much more detail on scales can be found at: </span><a href="https://github.com/d3/d3/blob/master/API.md#scales-d3-scale"><span class="URLPACKT"><span class="koboSpan" id="kobo.23.1">https://github.com/d3/d3/blob/master/API.md#scales-d3-scale</span></span></a><span class="koboSpan" id="kobo.24.1">.</span></p>
<p><span class="koboSpan" id="kobo.25.1">For now, let's describe what this scale defines. </span><span class="koboSpan" id="kobo.25.2">Here, we created a new function called </span><kbd><span class="koboSpan" id="kobo.26.1">color()</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">This </span><kbd><span class="koboSpan" id="kobo.28.1">color()</span></kbd><span class="koboSpan" id="kobo.29.1"> function looks for any number between </span><kbd><span class="koboSpan" id="kobo.30.1">0</span></kbd><span class="koboSpan" id="kobo.31.1"> and </span><kbd><span class="koboSpan" id="kobo.32.1">33</span></kbd><span class="koboSpan" id="kobo.33.1"> in an input domain. </span><span class="koboSpan" id="kobo.33.2">D3 linearly maps these input values to a color between red and yellow in the output range. </span><span class="koboSpan" id="kobo.33.3">D3 has included the capability to automatically map colors in a linear range to a gradient. </span><span class="koboSpan" id="kobo.33.4">This means that executing the new function, </span><kbd><span class="koboSpan" id="kobo.34.1">color</span></kbd><span class="koboSpan" id="kobo.35.1">, with </span><kbd><span class="koboSpan" id="kobo.36.1">0</span></kbd><span class="koboSpan" id="kobo.37.1"> will return the color red, </span><kbd><span class="koboSpan" id="kobo.38.1">color(15)</span></kbd><span class="koboSpan" id="kobo.39.1"> will return an orange color, and </span><kbd><span class="koboSpan" id="kobo.40.1">color(33)</span></kbd><span class="koboSpan" id="kobo.41.1"> will return yellow.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Here is a small table just for visual reference. </span><span class="koboSpan" id="kobo.42.2">It shows the color and its respective RGB value:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.43.1"><img height="537" width="357" src="assets/82b7470e-4f6c-4bf4-a367-af9ce75323bb.png"/></span></div>
<p><span class="koboSpan" id="kobo.44.1">Now, in the update section, we will set the </span><kbd><span class="koboSpan" id="kobo.45.1">fill</span></kbd><span class="koboSpan" id="kobo.46.1"> property of the path to the new </span><kbd><span class="koboSpan" id="kobo.47.1">color()</span></kbd><span class="koboSpan" id="kobo.48.1"> function. </span><span class="koboSpan" id="kobo.48.2">This will provide a linear scale of colors and use the index value </span><kbd><span class="koboSpan" id="kobo.49.1">i</span></kbd><span class="koboSpan" id="kobo.50.1"> to determine what color should be returned.</span></p>
<p><span class="koboSpan" id="kobo.51.1">If the color was determined by a different value of the datum, for instance </span><kbd><span class="koboSpan" id="kobo.52.1">d.scales</span></kbd><span class="koboSpan" id="kobo.53.1">, then you would have a choropleth where the colors actually represent sales. </span><span class="koboSpan" id="kobo.53.2">The preceding code should render something as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img src="assets/d651273d-477a-41be-b137-488f9d9bb65d.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 3 – adding click events to our visualization</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We've seen how to make a map and set different colors to the different regions of this map. </span><span class="koboSpan" id="kobo.2.2">Next, we will add a little bit of interactivity. </span><span class="koboSpan" id="kobo.2.3">This will illustrate a simple reference to bind click events to maps. </span><span class="koboSpan" id="kobo.2.4">For this experiment, we will build on the previous exercise, </span><kbd><span class="koboSpan" id="kobo.3.1">example-3.html</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">You can see the completed experiment at: </span><kbd><span class="koboSpan" id="kobo.5.1">http://localhost:8080/chapter-4/example-4.html</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">First, we need a quick reference to each state in the country. </span><span class="koboSpan" id="kobo.7.2">To accomplish this, we will create a new function called </span><kbd><span class="koboSpan" id="kobo.8.1">geoID</span></kbd><span class="koboSpan" id="kobo.9.1"> right below the </span><kbd><span class="koboSpan" id="kobo.10.1">mexico</span></kbd><span class="koboSpan" id="kobo.11.1"> variable:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">  var height = 600; 
  var width = 900; 
  var projection = d3.geoMercator(); 
  var mexico = void 0; 
 
  var geoID = function(d) { 
    return "c" + d.properties.ID_1; 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.13.1">This function takes in a </span><kbd><span class="koboSpan" id="kobo.14.1">state</span></kbd><span class="koboSpan" id="kobo.15.1"> data element and generates a new selectable ID based on the </span><kbd><span class="koboSpan" id="kobo.16.1">ID_1</span></kbd><span class="koboSpan" id="kobo.17.1"> property found in the data. </span><span class="koboSpan" id="kobo.17.2">The </span><kbd><span class="koboSpan" id="kobo.18.1">ID_1</span></kbd><span class="koboSpan" id="kobo.19.1"> property contains a unique numeric value for every state in the array. </span><span class="koboSpan" id="kobo.19.2">If we insert this as an </span><kbd><span class="koboSpan" id="kobo.20.1">id</span></kbd><span class="koboSpan" id="kobo.21.1"> attribute into the DOM, then we would create a quick and easy way to select each state in the country.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The following is the </span><kbd><span class="koboSpan" id="kobo.23.1">geoID()</span></kbd><span class="koboSpan" id="kobo.24.1"> function, creating another function called </span><kbd><span class="koboSpan" id="kobo.25.1">click</span></kbd><span class="koboSpan" id="kobo.26.1">:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">  var click = function(d) { 
    d3.selectAll('path').attr('fill-opacity',0.2)</span><br/><span class="koboSpan" id="kobo.28.1">    d3.select('#' + geoID(d)).attr('fill-opacity', 1); 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.29.1">This method makes it easy to separate what the </span><kbd><span class="koboSpan" id="kobo.30.1">click</span></kbd><span class="koboSpan" id="kobo.31.1"> is doing. </span><span class="koboSpan" id="kobo.31.2">The </span><kbd><span class="koboSpan" id="kobo.32.1">click</span></kbd><span class="koboSpan" id="kobo.33.1"> method receives the datum and changes the fill opacity value of all the states to </span><kbd><span class="koboSpan" id="kobo.34.1">0.2</span></kbd><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">This is done so that when you click on one state and then on the other, the previous state does not maintain the </span><em><span class="koboSpan" id="kobo.36.1">clicked</span></em><span class="koboSpan" id="kobo.37.1"> style. </span><span class="koboSpan" id="kobo.37.2">Notice that the function call is iterating through all the elements of the DOM using the D3 update pattern. </span><span class="koboSpan" id="kobo.37.3">After making all the states transparent, we will set a fill opacity of </span><kbd><span class="koboSpan" id="kobo.38.1">1</span></kbd><span class="koboSpan" id="kobo.39.1"> for the given clicked item. </span><span class="koboSpan" id="kobo.39.2">This removes all the transparent styling from the selected state. </span><span class="koboSpan" id="kobo.39.3">Notice that we are reusing the </span><kbd><span class="koboSpan" id="kobo.40.1">geoID()</span></kbd><span class="koboSpan" id="kobo.41.1"> function that we created earlier to quickly find the state element in the DOM.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Next, let's update the </span><kbd><span class="koboSpan" id="kobo.43.1">enter()</span></kbd><span class="koboSpan" id="kobo.44.1"> method to bind our new </span><kbd><span class="koboSpan" id="kobo.45.1">click</span></kbd><span class="koboSpan" id="kobo.46.1"> method to every new DOM element that </span><kbd><span class="koboSpan" id="kobo.47.1">enter()</span></kbd><span class="koboSpan" id="kobo.48.1"> appends:</span></p>
<pre><span class="koboSpan" id="kobo.49.1">  //Enter 
  mexico.enter() 
     .append('path') 
     .attr('d', path) 
     .attr('id', geoID) 
     .on("click", click)</span><br/><span class="koboSpan" id="kobo.50.1">     .attr('fill', function(d,i) { return color(i); }) </span></pre>
<p><span class="koboSpan" id="kobo.51.1">We also added an attribute called </span><kbd><span class="koboSpan" id="kobo.52.1">id</span></kbd><span class="koboSpan" id="kobo.53.1">; this inserts the results of the </span><kbd><span class="koboSpan" id="kobo.54.1">geoID()</span></kbd><span class="koboSpan" id="kobo.55.1"> function into the </span><kbd><span class="koboSpan" id="kobo.56.1">id</span></kbd><span class="koboSpan" id="kobo.57.1"> attribute. </span><span class="koboSpan" id="kobo.57.2">Again, this makes it very easy to find the clicked state.</span></p>
<p><span class="koboSpan" id="kobo.58.1">The code base should produce a map as follows. </span><span class="koboSpan" id="kobo.58.2">Check it out and make sure that you click on any of the states. </span><span class="koboSpan" id="kobo.58.3">You will see its color turn a little brighter than the surrounding states:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.59.1"><img src="assets/54243b10-e8eb-4950-b0ed-c572707fd5bc.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 4 – using updates and transitions to enhance our visualization</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For our next experiment, we will take all of our combined knowledge and add some smooth transitions to the map. </span><span class="koboSpan" id="kobo.2.2">Transitions are a fantastic way to add style and smoothness to data changes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This experiment will, again, require us to start with </span><kbd><span class="koboSpan" id="kobo.4.1">example-3.html</span></kbd><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The complete experiment can be viewed at </span><kbd><span class="koboSpan" id="kobo.6.1">http://localhost:8080/chapter-4/example-5.html</span></kbd><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">If you remember, we leveraged the JavaScript </span><kbd><span class="koboSpan" id="kobo.9.1">setInterval()</span></kbd><span class="koboSpan" id="kobo.10.1"> function to execute updates at a regular timed frequency. </span><span class="koboSpan" id="kobo.10.2">We will go back to this method now to assign a random number between 1 and 33 to our existing </span><kbd><span class="koboSpan" id="kobo.11.1">color()</span></kbd><span class="koboSpan" id="kobo.12.1"> function. </span><span class="koboSpan" id="kobo.12.2">We will then leverage a D3 method to smoothly transition between the random color changes.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Right below the update section, add the following </span><kbd><span class="koboSpan" id="kobo.14.1">setInterval()</span></kbd><span class="koboSpan" id="kobo.15.1"> block of code:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    setInterval(function(){</span><br/><span class="koboSpan" id="kobo.17.1">      map.selectAll('path').transition().duration(500)</span><br/><span class="koboSpan" id="kobo.18.1">          .attr('fill', function(d) {</span><br/><span class="koboSpan" id="kobo.19.1">            return color(Math.floor((Math.random() * 32) + 1));</span><br/><span class="koboSpan" id="kobo.20.1">          });</span><br/><span class="koboSpan" id="kobo.21.1">    },2000);</span></pre>
<p><span class="koboSpan" id="kobo.22.1">This method indicates that, for every </span><kbd><span class="koboSpan" id="kobo.23.1">2000</span></kbd><span class="koboSpan" id="kobo.24.1"> milliseconds (2 seconds), the </span><kbd><span class="koboSpan" id="kobo.25.1">map</span></kbd><span class="koboSpan" id="kobo.26.1"> update section should be executed and the color set to a random number between </span><kbd><span class="koboSpan" id="kobo.27.1">1</span></kbd><span class="koboSpan" id="kobo.28.1"> and </span><kbd><span class="koboSpan" id="kobo.29.1">32</span></kbd><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The new </span><kbd><span class="koboSpan" id="kobo.31.1">transition</span></kbd><span class="koboSpan" id="kobo.32.1"> and </span><kbd><span class="koboSpan" id="kobo.33.1">duration</span></kbd><span class="koboSpan" id="kobo.34.1"> methods transition from the previous state to the new state over </span><kbd><span class="koboSpan" id="kobo.35.1">500</span></kbd><span class="koboSpan" id="kobo.36.1"> milliseconds. </span><span class="koboSpan" id="kobo.36.2">Open </span><kbd><span class="koboSpan" id="kobo.37.1">example-5.html</span></kbd><span class="koboSpan" id="kobo.38.1"> in your browser and you should see the initial color based on the index of the state. </span><span class="koboSpan" id="kobo.38.2">After 2 seconds, the colors should smoothly transition to new values.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 5 – adding points of interest</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far, everything we have done has involved working directly with the geographic data and map. </span><span class="koboSpan" id="kobo.2.2">However, there are many cases where you will need to layer additional data on top of the map. </span><span class="koboSpan" id="kobo.2.3">We will begin slowly by first adding a few cities of interest to the map of Mexico.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This experiment will, again, require us to start with </span><kbd><span class="koboSpan" id="kobo.4.1">example-3.html</span></kbd><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The complete experiment can be viewed at: </span><kbd><span class="koboSpan" id="kobo.6.1">http://localhost:8080/chapter-4/example-6.html</span></kbd><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this experiment, we will add a </span><kbd><span class="koboSpan" id="kobo.9.1">text</span></kbd><span class="koboSpan" id="kobo.10.1"> element to the page to identify the city. </span><span class="koboSpan" id="kobo.10.2">To make the text more visually appealing, we will first add some simple styling in the </span><kbd><span class="koboSpan" id="kobo.11.1">&lt;style&gt;</span></kbd><span class="koboSpan" id="kobo.12.1"> section:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">text{ 
  font-family: Helvetica; 
  font-weight: 300; 
  font-size: 12px; 
} </span></pre>
<p><span class="koboSpan" id="kobo.14.1">Next, we need some data that will indicate the city name, the latitude, and longitude coordinates. </span><span class="koboSpan" id="kobo.14.2">For the sake of simplicity, we have added a file with a few starter cities. </span><span class="koboSpan" id="kobo.14.3">The file called </span><kbd><span class="koboSpan" id="kobo.15.1">cities.csv</span></kbd><span class="koboSpan" id="kobo.16.1"> is in the same directory as the examples:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">name,lat,lon, 
Cancun,21.1606,-86.8475 
Mexico City,19.4333,-99.1333 
Monterrey,25.6667,-100.3000 
Hermosillo,29.0989,-110.9542 </span></pre>
<p><span class="koboSpan" id="kobo.18.1">Now, add a few lines of code to bring in the data and plot the city locations and names on your map. </span><span class="koboSpan" id="kobo.18.2">Add the following block of code right below the exit section (if you are starting with </span><kbd><span class="koboSpan" id="kobo.19.1">example-2.html</span></kbd><span class="koboSpan" id="kobo.20.1">):</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    d3.csv('cities.csv', function(cities) { 
      var cityPoints = svg.selectAll('circle').data(cities); 
      var cityText = svg.selectAll('text').data(cities); 
 
      cityPoints.enter() 
          .append('circle') 
          .attr('cx', function(d) {</span><br/><span class="koboSpan" id="kobo.22.1">             return projection ([d.lon, d.lat])[0]</span><br/><span class="koboSpan" id="kobo.23.1">          })</span><br/><span class="koboSpan" id="kobo.24.1">          .attr('cy', function(d) {</span><br/><span class="koboSpan" id="kobo.25.1">             return projection ([d.lon, d.lat])[1]</span><br/><span class="koboSpan" id="kobo.26.1">          }) 
          .attr('r', 4) 
          .attr('fill', 'steelblue'); 
 
      cityText.enter() 
          .append('text') 
          .attr('x', function(d) {</span><br/><span class="koboSpan" id="kobo.27.1">             return projection([d.lon, d.lat])[0]})</span><br/><span class="koboSpan" id="kobo.28.1">          .attr('y', function(d) {</span><br/><span class="koboSpan" id="kobo.29.1">             return projection([d.lon, d.lat])[1]}) 
          .attr('dx', 5) 
          .attr('dy', 3) 
          .text(function(d) {return d.name}); 
    }); </span></pre>
<p><span class="koboSpan" id="kobo.30.1">Let's review what we just added.</span></p>
<p><span class="koboSpan" id="kobo.31.1">The </span><kbd><span class="koboSpan" id="kobo.32.1">d3.csv</span></kbd><span class="koboSpan" id="kobo.33.1"> function will make an AJAX call to our data file and automatically format the entire file into an array of JSON objects. </span><span class="koboSpan" id="kobo.33.2">Each property of the object will take on the corresponding name of the column in the </span><kbd><span class="koboSpan" id="kobo.34.1">.csv</span></kbd><span class="koboSpan" id="kobo.35.1"> file. </span><span class="koboSpan" id="kobo.35.2">For example, take a look at the following lines of code:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">[{ 
  "name": "Cancun",  
  "lat":"21.1606",  
  "lon":"-86.8475" 
}, ...] </span></pre>
<p><span class="koboSpan" id="kobo.37.1">Next, we define two variables to hold our data join to the circle and text the SVG elements.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Finally, we will execute a typical enter pattern to place the points as circles and the names as text SVG tags on the map. </span><span class="koboSpan" id="kobo.38.2">The </span><em><span class="koboSpan" id="kobo.39.1">x</span></em><span class="koboSpan" id="kobo.40.1"> and </span><em><span class="koboSpan" id="kobo.41.1">y</span></em><span class="koboSpan" id="kobo.42.1"> coordinates are determined by calling our previous </span><kbd><span class="koboSpan" id="kobo.43.1">projection()</span></kbd><span class="koboSpan" id="kobo.44.1"> function with the corresponding latitude and longitude coordinates from the data file.</span></p>
<p><span class="koboSpan" id="kobo.45.1">Note that the </span><kbd><span class="koboSpan" id="kobo.46.1">projection()</span></kbd><span class="koboSpan" id="kobo.47.1"> function returns an array of </span><em><span class="koboSpan" id="kobo.48.1">x</span></em><span class="koboSpan" id="kobo.49.1"> and </span><em><span class="koboSpan" id="kobo.50.1">y</span></em><span class="koboSpan" id="kobo.51.1"> coordinates (</span><em><span class="koboSpan" id="kobo.52.1">x, y</span></em><span class="koboSpan" id="kobo.53.1">). </span><span class="koboSpan" id="kobo.53.2">The </span><em><span class="koboSpan" id="kobo.54.1">x</span></em><span class="koboSpan" id="kobo.55.1"> coordinate is determined by taking the </span><kbd><span class="koboSpan" id="kobo.56.1">0</span></kbd><span class="koboSpan" id="kobo.57.1"> index of the returned array. </span><span class="koboSpan" id="kobo.57.2">The </span><em><span class="koboSpan" id="kobo.58.1">y</span></em><span class="koboSpan" id="kobo.59.1"> coordinate is determined from the index, </span><kbd><span class="koboSpan" id="kobo.60.1">1</span></kbd><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">For example, take a look at the following code:</span></p>
<pre><span class="koboSpan" id="kobo.62.1">.attr('cx', function(d) {return projection([d.lon, d.lat])[0]})  </span></pre>
<p><span class="koboSpan" id="kobo.63.1">Here, </span><kbd><span class="koboSpan" id="kobo.64.1">[0]</span></kbd><span class="koboSpan" id="kobo.65.1"> indicates the </span><em><span class="koboSpan" id="kobo.66.1">x</span></em><span class="koboSpan" id="kobo.67.1"> coordinate.</span></p>
<p><span class="koboSpan" id="kobo.68.1">Your new map should look like the one shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.69.1"><img src="assets/26281754-34bd-4a14-9183-4822e7b289af.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Experiment 6 – adding visualizations as a point of interest</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For our final experiment, we will layer visualizations on top of visualizations! </span><span class="koboSpan" id="kobo.2.2">Starting from where we left off at </span><kbd><span class="koboSpan" id="kobo.3.1">http://localhost:8080/chapter-4/example-6.html</span></kbd><span class="koboSpan" id="kobo.4.1">, we will add a fictitious column to the data to indicate a metric of tequila consumption (the final version can be seen at </span><kbd><span class="koboSpan" id="kobo.5.1">http://localhost:8080/chapter-4/example-7.html</span></kbd><span class="koboSpan" id="kobo.6.1">):</span></p>
<pre><span class="koboSpan" id="kobo.7.1">name,lat,lon,tequila 
Cancun,21.1606,-86.8475,85,15 
Mexico City,19.4333,-99.1333,51,49 
Monterrey,25.6667,-100.3000,30,70 
Hermosillo,29.0989,-110.9542,20,80 </span></pre>
<p><span class="koboSpan" id="kobo.8.1">With just two more lines of code, we can have the city points portray meaning. </span><span class="koboSpan" id="kobo.8.2">In this experiment, we will scale the radius of the city circles in relation to the amount of tequila consumed:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">var radius = d3.scaleLinear().domain([0,100]).range([5,30]);  </span></pre>
<p><span class="koboSpan" id="kobo.10.1">Here, we will introduce a new scale that linearly distributes the input values from </span><kbd><span class="koboSpan" id="kobo.11.1">1</span></kbd><span class="koboSpan" id="kobo.12.1"> to </span><kbd><span class="koboSpan" id="kobo.13.1">100</span></kbd><span class="koboSpan" id="kobo.14.1"> to a radius length between </span><kbd><span class="koboSpan" id="kobo.15.1">5</span></kbd><span class="koboSpan" id="kobo.16.1"> and </span><kbd><span class="koboSpan" id="kobo.17.1">30</span></kbd><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">This means that the minimum radius of a circle will be </span><kbd><span class="koboSpan" id="kobo.19.1">5</span></kbd><span class="koboSpan" id="kobo.20.1"> and the maximum will be </span><kbd><span class="koboSpan" id="kobo.21.1">30</span></kbd><span class="koboSpan" id="kobo.22.1">, preventing the circles from growing too large or too small to be readable:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">cityPoints.enter() 
          .append('circle') 
          .attr('cx', function(d) {</span><br/><span class="koboSpan" id="kobo.24.1">             return projection([d.lon, d.lat])[0];})          </span><br/><span class="koboSpan" id="kobo.25.1">          .attr('cy', function(d) {</span><br/><span class="koboSpan" id="kobo.26.1">             return projection([d.lon, d.lat])[1];}) 
          .attr('r', 4) 
          .attr('fill', 'steelblue'); </span></pre>
<p><span class="koboSpan" id="kobo.27.1">Next, we will change the preceding line of code to call the </span><kbd><span class="koboSpan" id="kobo.28.1">radius</span></kbd><span class="koboSpan" id="kobo.29.1"> function instead of the hardcoded value of </span><kbd><span class="koboSpan" id="kobo.30.1">4</span></kbd><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">The code will now look like this:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">.attr('r', function(d) {return radius(d.tequila); }) </span></pre>
<p><span class="koboSpan" id="kobo.33.1">After these two small additions, your map should look like the one shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.34.1"><img src="assets/9e4296a3-1638-4667-9d41-64816815a38f.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You learned how to build many different kinds of maps that cover different kinds of needs. </span><span class="koboSpan" id="kobo.2.2">The choropleths and data visualizations of maps are some of the most common geographic-based data representations that you will come across. </span><span class="koboSpan" id="kobo.2.3">We also added interactivity to our map through basic transitions and events. </span><span class="koboSpan" id="kobo.2.4">You will easily realize that, with all the information you've gathered so far, you can independently create engaging map visualizations. </span><span class="koboSpan" id="kobo.2.5">You can expand your knowledge by learning advanced interactivity techniques in the next chapter.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Hang on tight!</span></p>


            </article>

            
        </section>
    </body></html>