<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using the Serverless Framework</h1>
                </header>
            
            <article>
                
<p>When developing a serverless project, you can group multiple features into a single big Lambda function or break each feature into its own small function. If you follow the second option, you will end up managing the deployment of dozens of different functions, each one of them with its own configuration and dependencies. Automating this process could be a real challenge, but it becomes an easy task when you use the Serverless Framework in your workflow. <span>Besides handling the release process, the framework helps you architect the solution and manage different environments, and it provides a clean and succinct syntax for versioning the infrastructure.</span></p>
<p>In this chapter, you will learn how to configure and use the Serverless Framework. We will cover the following topics:</p>
<ul>
<li>How to set up and start using the framework</li>
<li>Deploying a hello-world application</li>
<li>Creating endpoints and enabling CORS</li>
<li>Configuring events to trigger functions</li>
<li>Accessing other AWS resources</li>
</ul>
<p>After this chapter, you'll have learned the basics of how to build the backend of a serverless project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serverless Framework</h1>
                </header>
            
            <article>
                
<p>There are many tools that have been developed to help manage serverless projects. The Serverless Framework is currently the most popular and will be used extensively in this book. This section will help you configure, use, and understand how it will fit in your workflow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Serverless Framework</h1>
                </header>
            
            <article>
                
<p>The Serverless Framework is a powerful Node.js <em>command-line tool</em>, not a cloud service. Its objective is to help developers be more productive by simplifying how they can use and manage cloud resources. It provides a set of commands that will help you quickly start a new project, add functions, endpoints, triggers, configure permissions, and more. In summary, the framework will manage your project, automate the deployment of your code, and integrate with many different services:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/cdb2603f-bd1f-4950-a72d-a516fb6670ae.png"/></div>
<p>We have the following as input:</p>
<ul>
<li><strong>Integration</strong>: Describes what and how different cloud services will trigger our Lambda functions</li>
<li><strong>Configuration</strong>: Sets permissions for Lambda functions, and defines the limits (timeout and RAM memory) under which they will run</li>
<li><strong>Plugins</strong>: Extends the framework functionalities with custom code</li>
</ul>
<p>Here is what the framework provides:</p>
<ul>
<li><strong>Architecture</strong>: Helps to define an architecture that will keep our project consistent.</li>
<li><strong>Deploy</strong>: Automates code deployment. You can deploy anytime with a single command.</li>
<li><strong>Versioning</strong>: Helps versioning the code configuration, which means versioning the infrastructure. Duplicating the same infrastructure into another region or environment is a trivial task.</li>
</ul>
<p>Currently, it supports the following cloud providers: AWS, Microsoft Azure, Google Cloud Platform, and IBM OpenWhisk. Migrating from one cloud to another is possible, but it is not simple. The framework uses the same commands for management tasks and tries to use similar settings, but each one of them requires different configurations and setups.</p>
<p>Another important characteristic is that the Serverless Framework is open source and MIT licensed, so it can be used for free, even in commercial products.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other frameworks</h1>
                </header>
            
            <article>
                
<p>Serverless is a concept that promotes the development of applications without worrying about the servers that will operate them. It's a concept and doesn't specify the tools that will be used, nor the cloud vendors that host the applications. However, taking advantage of the word's hype, the creators of <strong>JAWS</strong> renamed their project to <strong>Serverless Framework</strong> at the end of 2015 and bought the <a href="https://serverless.com">serverless.com</a> domain. To further improve their open source project, they started a venture-backed company named <em>Serverless, Inc</em>.</p>
<p>The Serverless Framework is currently the best tool to build a general-purpose serverless project, but <strong>do not</strong> confuse a product with the concept. The framework promotes serverless applications, but offers <strong>only a subset</strong> of what you can do with serverless. There are many other services and frameworks out there with different features and objectives.</p>
<p>For example, Apex is another framework to manage AWS Lambda functions with an interesting feature that provides support for Go, Rust, and Clojure, even without native support by Lambda. There are also dozens of other tools. For more options, you can take a look at this curated list: <a href="https://github.com/anaibol/awesome-serverless">https://github.com/anaibol/awesome-serverless</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the framework</h1>
                </header>
            
            <article>
                
<p>As the Serverless Framework uses Node.js, you can use npm to install it:</p>
<pre>
<strong>npm install serverless@1.x --global</strong>
</pre>
<p>The <kbd>@1.x</kbd> suffix asks npm to download a package compatible with the 1.x version. This restriction is suggested because this book was written following the 1.18 specification of the framework and the examples may not be compatible with a future 2.x version.</p>
<div class="packt_infobox">
<p>The Serverless Framework requires Node.js v6.5 or higher. Make sure that you have an updated version. You can check this by running <kbd>node --version</kbd>. If you need to update your Node version, consider using v6.10 because this is the latest version that AWS uses to run Lambda functions.</p>
</div>
<p>To confirm that the framework was installed successfully, you can check its version by running the following command:</p>
<pre>
<strong>    serverless --version</strong>
</pre>
<div class="packt_infobox">
<p>Instead of using the <kbd>serverless</kbd> command, you can use the abbreviation <kbd>sls</kbd> for all commands. For example, <kbd>sls --version</kbd>.</p>
<p>Also, for each option that starts with two dashes, such as in <kbd>--version</kbd>, there will always exist a shorter alternative using just one letter, such as <kbd>-v</kbd> in this case.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the framework</h1>
                </header>
            
            <article>
                
<p>The Serverless Framework uses the AWS SDK to manage your account resources, so the configuration that is needed is to set your credentials where the SDK can access them. As described in <a href="246b3080-28af-4aa3-805f-5fbf9908caae.xhtml">Chapter 2</a>, <em>Getting Started with AWS</em>, we have already created a user and set its <strong>Access key</strong> and <strong>Secret access key</strong> into environment variables.</p>
<p>What is missing here is properly restricting this user access. For learning purposes, it's perfectly fine to use an administrator account with full access. However, if you are building a real product, follow the principle of least privilege and set access only for what is expected to be used by the framework. In the previous chapter, you learned how to configure it using the IAM console (<a href="https://console.aws.amazon.com/iam">https://console.aws.amazon.com/iam</a>).</p>
<p>The minimum access requirements are <strong>Lambda</strong>, <strong>CloudFormation</strong>, <strong>IAM</strong>, and <strong>CloudWatch</strong>. While setting permissions, you can anticipate and give access that will be needed later in our sample project. The framework will also need access to <strong>API Gateway</strong>, <strong>IoT</strong>, <strong>SimpleDB</strong>, and <strong>DynamoDB</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing permissions in a team</h1>
                </header>
            
            <article>
                
<p>When working in a team, it's mandatory that everyone must have their own user for a fine-grained set of permissions. Also, it allows audit and traceability which are very important. Audit discourages wrongdoings by team members and traceability is useful for unfortunate cases, for example, if your site is compromised, you can discover the source of the invasion. If you want those features, you must configure <strong>AWS CloudTrail</strong> to store into S3 the log files of the AWS API usage.</p>
<p>If each team member has a unique account, you can restrict access to the production environment for a reduced group of people. Access to production is a great responsibility that should only be entrusted to experienced people to avoid failures due to distraction or lack of knowledge.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new project</h1>
                </header>
            
            <article>
                
<p>Let's start by creating a new folder to store our project data. Name it <kbd>hello-serverless</kbd> and set the command prompt directory to this folder. Now, run the following command:</p>
<pre>
<strong>serverless create --template aws-nodejs --name hello-serverless</strong>
</pre>
<p>Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/cdc49010-631f-4d66-9a14-c7e9256fcb4c.png"/></div>
<p>This command creates one <em>service</em> that is used to group related functions. You can compare a service as a bounded context as defined in <strong>Domain-Driven Design</strong> (<strong>DDD</strong>). For example, in this book, the sample application is an online store. We can say that features that will be implemented to exhibit products and handle sales are part of one context. The features that handle user accounts and profile data are part of another context. We will discuss serverless architectures in <a href="a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml">Chapter 6</a>, <em>Developing the Backend</em>.</p>
<p>After executing the command, the following two files are created:</p>
<ul>
<li>The <kbd>handler.js</kbd> file</li>
<li>The <kbd>serverless.yml</kbd> file</li>
</ul>
<p>Let's see the context of each one and understand their role.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The handler.js file</h1>
                </header>
            
            <article>
                
<p>This file contains the main function that will be executed by AWS Lambda. For a simple example, consider the following code:</p>
<pre>
    module.exports.hello = (event, context, callback) =&gt; <br/>    {<br/><br/>        const response =<br/>        {<br/>              <strong>statusCode</strong>: 200,   <br/>              <strong>body</strong>: JSON.stringify({<br/>                  message: `Hello, ${event.name}!`<br/>            })<br/>        };<br/><br/>        callback(null, response);<br/>    };
</pre>
<div class="packt_infobox">
<p>Our <kbd>response</kbd> object has the properties <kbd>statusCode</kbd> and <kbd>body</kbd>. This schema is mandatory when you want to trigger Lambda functions using the API Gateway and when the Lambda is configured as a proxy, which is the default option selected in the Serverless Framework. Instead of configuring headers, status codes, and other parameters in the API Gateway, the Lambda proxy setting allows this configuration to be part of the code. This is the recommended practice for most use cases.</p>
</div>
<p>The function named <kbd>hello</kbd> will be configured as our main entry. It receives three arguments such as <kbd>event</kbd>, <kbd>context</kbd>, and <kbd>callback</kbd>. The <kbd>event</kbd> variable is our input data, and <kbd>callback</kbd> is the function that must be executed after the Lambda execution finishes and it receives an error object as the first parameter and a <kbd>response</kbd> object as the second one, and the <kbd>context</kbd> is an object that provides data related to our function execution. An example of the <kbd>context</kbd> content is displayed in the following JSON:</p>
<pre>
    {<br/>      "callbackWaitsForEmptyEventLoop": true,<br/>      "logGroupName": "/aws/lambda/hello-serverless-dev-hello",<br/>      "logStreamName":<br/>        "2017/07/15/[$LATEST]01a23456bcd7890ef12gh34i56jk7890",<br/>      "functionName": "hello-serverless-dev-hello",<br/>      "memoryLimitInMB": "1024",<br/>      "functionVersion": "$LATEST",<br/>      "invokeid": "1234a567-8901-23b4-5cde-fg67h8901i23",<br/>      "awsRequestId": "1234a567-8901-23b4-5cde-fg67h8901i23",<br/>      "invokedFunctionArn": "arn:aws:lambda:us-east-1:1234567890:<br/>        function:hello-serverless-dev-hello"<br/>    }
</pre>
<p>In this example, we return <kbd>status code 200 (OK)</kbd>, and the response <kbd>body</kbd> will return a message that uses the event as an input variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The serverless.yml file</h1>
                </header>
            
            <article>
                
<p>This is a configuration file that uses the YAML standard, which has the <span>aim</span> of being more readable by humans. The name YAML is a recursive acronym meaning <em>YAML Ain't Markup Language</em>.</p>
<p>When we created the service, we used the argument <kbd>aws-nodejs</kbd>. It creates a file with the following content:</p>
<pre>
    service: hello-serverless<br/><br/>    provider:<br/>      name: aws<br/>      runtime: nodejs6.10<br/><br/>    functions:<br/>      hello:<br/>        handler: handler.hello
</pre>
<p>Let's take a look at the following settings depicted in the preceding code example:</p>
<ul>
<li><kbd>service</kbd>: This is just the service name that we have specified while creating the service.</li>
<li><kbd>provider</kbd>: This sets the cloud provider and the runtime. We have selected AWS and the latest Node.js version available.</li>
<li><kbd>functions</kbd>: This is where we define the Lambda functions.</li>
</ul>
<p>There are more options available, but we will cover them as we need them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the Lambda limits</h1>
                </header>
            
            <article>
                
<p>While setting the <kbd>serverless.yml</kbd> file, you can configure your function limits. The RAM memory size has the default value of 1,024 MB. The possible values range from 128 MB to 1,536 MB in chunks of 64 MB.</p>
<p>Another possible setting is the <kbd>timeout</kbd> property. If your function exceeds the expected time, it will be aborted. The default value is 6 seconds and the possible values range from 1 second to 300 seconds (5 minutes):</p>
<pre>
    functions:<br/>      hello:<br/>        handler: handler.hello<br/>        memorySize: 128 # measured in megabytes<br/>        timeout: 10 # measured in seconds
</pre>
<div class="packt_infobox">In YAML syntax, a comment begins with the hash sign (<kbd><strong>#</strong></kbd>) and continues until the end of the line.</div>
<p>You can also change the default values by modifying the provider settings. These values will be used when your function doesn't specify them:</p>
<pre>
    provider:<br/>      name: aws<br/>      runtime: nodejs6.10<br/>      memorySize: 512<br/>      timeout: 30
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying a service</h1>
                </header>
            
            <article>
                
<p>Deploying a service is a simple task. We just need to run the following command:</p>
<pre>
<strong>    serverless deploy</strong>
</pre>
<p>You can see the results in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="320" src="assets/0a7da9ea-99c4-4739-980b-a0b4911b30af.png" width="512"/></div>
<p>By default, it will deploy your functions in a <kbd>stage</kbd> named <kbd>dev</kbd> and in the <kbd>region</kbd> named <kbd>us-east-1</kbd>. The <kbd>stage</kbd> is used to simulate different environments. For example, you can create one for development and another for <kbd>production</kbd>, or you can use one for <kbd>v1</kbd> and another for <kbd>v2</kbd> if you want to create versioned APIs. Regarding the region, it's used to identify which AWS <kbd>region</kbd> will be used to host your Lambda functions.</p>
<p>Here are two options to change the default values:</p>
<ul>
<li>The first one is to modify the <kbd>serverless.yml</kbd> file, as shown in the following code example:</li>
</ul>
<pre>
        provider:<br/>          name: aws<br/>          runtime: nodejs6.10<br/>          <strong>stage: production</strong><br/>          <strong>region: eu-west-1</strong>
</pre>
<p> </p>
<ul>
<li>The second option is to use the arguments of the deploy command:</li>
</ul>
<pre>
<strong>        serverless deploy --stage production --region eu-west-1</strong>
</pre>
<div class="packt_tip">
<p>Under <kbd>provider</kbd>, you can set the configuration file to the <kbd>dev</kbd> stage, only when you want to deploy to <kbd>production</kbd>, you can do so using the stage argument with the command line. Using two different approaches for two different environments is a good way to avoid mistakes.</p>
</div>
<p>When we use the <kbd>deploy</kbd> command, it can take a couple of minutes to execute, even for small projects. The performance issue is related with CloudFormation, which needs to update the stack across AWS machines. After deploying the function for the first time, we can use the <kbd>deploy function</kbd> command for code updates because this command will simply swap the ZIP package of the function. As it doesn't need to execute any CloudFormation code, this is a much faster way of deploying changes. The following example shows how to use this command:</p>
<pre>
<strong>    serverless deploy function --function hello</strong>
</pre>
<div class="packt_tip">Always remember to update the function's code using the <kbd>deploy function</kbd> command for fast deployment. If you need to update any kind of configuration, such as permissions or Lambda limits, you need to run the <kbd>deploy</kbd> command (without the <kbd>function</kbd> part).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking a function</h1>
                </header>
            
            <article>
                
<p>We just created and deployed a Lambda function. Now, let's see how this function can be invoked by performing the following steps:</p>
<ol>
<li>Inside your project folder, create an <kbd>event.json</kbd> file with the following content. This file will serve as our input data:</li>
</ol>
<pre>
        {<br/>          "name": "Serverless"<br/>        }
</pre>
<ol start="2">
<li>The next step is to invoke the function and confirm that it is working as expected. You can do so by executing the <kbd>invoke</kbd> command:</li>
</ol>
<pre>
<strong>        serverless invoke --function hello --path event.json</strong>
</pre>
<div class="packt_infobox" style="padding-left: 90px">Passing the <kbd>event.json</kbd> file as input is not mandatory. We are using it because our example uses the input data to create the <kbd>response</kbd> object.</div>
<p style="padding-left: 90px">The following screenshot shows the invoke result:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="325" src="assets/7e2f4786-a807-477f-ac07-dc70db4bfc36.png" width="519"/></div>
<ol start="3">
<li>If you have functions deployed to multiple stages/regions, you can invoke them by specifying the stage/region explicitly. For example, take a look at the following command:</li>
</ol>
<pre>
<strong>        serverless invoke --function hello --stage test --region eu-west-1</strong>
</pre>
<ol start="4">
<li>The last observation is that you can invoke functions locally. This invoke will execute the function using your machine instead of running the function hosted on AWS. For this, just use the <kbd>invoke local</kbd> command:</li>
</ol>
<pre>
<strong>        serverless invoke local --function hello </strong><strong>--path event.json</strong>
</pre>
<div class="packt_infobox">We will see later that we can give or restrict permissions to Lambda functions. However, if you execute the code locally, it won't use the configured roles. The Lambda will execute under your local SDK credentials, so testing Lambda locally can be useful, but you need to know that you won't be testing it with the same permissions that will be used when the function is hosted on AWS.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving logs</h1>
                </header>
            
            <article>
                
<p>When a Lambda function fails due to an unhandled exception, the result will be a generic message:</p>
<pre>
    {<br/>      "errorMessage": "Process exited before completing request"<br/>    }
</pre>
<p>To troubleshoot errors, we need to retrieve the execution logs. You can do so by appending the <kbd>--log</kbd> option to the <kbd>invoke</kbd> command:</p>
<pre>
<strong>    serverless invoke --function hello --log</strong>
</pre>
<p>It will result in an error message similar to this one:</p>
<pre>
    START RequestId: 1ab23cde-4567-89f0-1234-56g7hijk8901<br/>    Version: $LATEST2017-05-15 15:27:03.471 (-03:00) <br/>        1ab23cde-4567-89f0-1234-56g7hijk8901<br/><strong>    ReferenceError: x is not defined </strong><br/><strong>        at module.exports.hello (/var/task/handler.js:9:3)</strong><br/>    END RequestId: 1ab23cde-4567-89f0-1234-56g7hijk8901<br/>    REPORT RequestId: 1ab23cde-4567-89f0-1234-<br/>    56g7hijk8901 <br/>    Duration: 60.26 ms<br/>    Billed Duration: 100 ms        <br/>    Memory Size: 128 MB      <br/>    Max Memory Used: 17 MB<br/><br/>    Process exited before completing request
</pre>
<p>Besides using the <kbd>--log</kbd> command when invoking a function, you can retrieve logs from the Lambda functions that are deployed without invoking new executions. The command for this is as follows:</p>
<pre>
<strong>    serverless logs --function hello</strong>
</pre>
<p>The following is a screenshot with an example of log messages:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="328" src="assets/df3592b2-dc26-4588-9874-1fafe517c916.png" width="518"/></div>
<p>One problem with this feature is that you <em>must</em> specify the function name. You can't have a generic view of how all functions are executing, which would be desirable in a project with dozens of functions.</p>
<p>When running in production, using the command line to watch for logs can be troublesome. You can reduce the amount of results using the <kbd>--filter string</kbd> command to show only messages that contain a specific string. This is useful in finding error messages, for example, using <kbd>--filter Error</kbd>.</p>
<div class="packt_infobox">The <kbd>--filter string</kbd> option is case sensitive. If you want to find error messages, use <kbd>--filter Error</kbd> because most exception messages will start the error word with an uppercase letter, for example: <kbd>ReferenceError</kbd></div>
<p>Another option is to filter by time. You can use <kbd>--startTime time</kbd> to filter only the recent messages. For example, you could replace "time" with <kbd>30m</kbd> to see only messages that happened 30 minutes ago.</p>
<p>Take a look at the following example:</p>
<pre>
<strong>    serverless logs --function hello --filter error --startTime 30m</strong>
</pre>
<p>Also, you can add a listener that will output all new log messages received. In this case, you need to add the <kbd>--tail</kbd> command.</p>
<p>Here's an example:</p>
<pre>
<strong>    serverless logs --function hello --tail</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding endpoints</h1>
                </header>
            
            <article>
                
<p>Endpoints are the addresses that are exposed to the Internet through the API Gateway.</p>
<p>Take a look at the following steps to create an endpoint for our Lambda example:</p>
<ol>
<li>Endpoints are added by setting HTTP events in the <kbd>serverless.yml</kbd> file. In the following example, we specify that a <kbd>GET</kbd> HTTP verb used in the <kbd>my-service/resource</kbd> path will trigger this Lambda function:</li>
</ol>
<pre>
        functions:<br/>          hello:<br/>            handler: handler.hello<br/><strong>            events:</strong><br/><strong>              - http: GET my-service/resource</strong>
</pre>
<ol start="2">
<li>After editing the configuration file, deploy the service again using the following command:</li>
</ol>
<pre>
<strong>        serverless deploy</strong>
</pre>
<p style="padding-left: 90px">Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/41dae216-c0fe-4cc0-b6c6-521e60754489.png"/></div>
<p style="padding-left: 90px">This time, in addition to the Lambda function update, the <kbd>deploy</kbd> command will create an API Gateway resource configured with the preceding path and method. In the previous chapter, we deployed an API Gateway resource that triggered a Lambda function, and it required a lot of steps. Do you see now how powerful the Serverless Framework is? If you have dozens of functions and endpoints, a single command is enough to deploy all of them. This automation and ease of use is what makes the framework so interesting.</p>
<ol start="3">
<li>In the preceding screenshot, we can see that the framework lists the endpoint address that was created. It uses the following format:</li>
</ol>
<pre style="padding-left: 90px">
https://[key].execute-api.[region].amazonaws.com/[stage]/[path]
</pre>
<p> </p>
<ol start="4">
<li>If you use your browser to open this URL, you will see a <kbd>response</kbd> object containing our hello-world message. When using the API Gateway, the <kbd>event</kbd> variable will include much more data, adding information about headers and the request context. Most of this is not useful for us, but we need to use the <kbd>event</kbd> object to find the input data. As this is a <kbd>GET</kbd> request, we can add a query string to the end of the URL to pass variables values and retrieve them, looking for the <kbd>queryStringParameters</kbd> property inside the <kbd>event</kbd> object. Look at the following URL example:</li>
</ol>
<pre>
        https://[key].execute-api.us-east-1.amazonaws.com/dev/my-service/resource?name=Serverless&amp;foo=bar
</pre>
<p style="padding-left: 60px">The <kbd>?name=Serverless&amp;foo=bar</kbd> file is the query string that will be mapped to a JSON object inside the <kbd>queryStringParameters</kbd> property of our <kbd>event</kbd> variable, as shown here:</p>
<pre>
        {<br/>          "name": "Serverless",<br/>          "foo": "bar"<br/>        }
</pre>
<ol start="5">
<li>As we are now using the API Gateway instead of invoking the Lambda function directly, the <kbd>event</kbd> object received will be set with different properties. In this case, we need to adapt our Lambda function to handle it properly. The following example uses <kbd>event.queryStringParameters.name</kbd> instead of <kbd>event.name</kbd>:</li>
</ol>
<pre>
        module.exports.hello = (event, context, callback) =&gt; {<br/><br/>          const response = {<br/>            statusCode: 200,   <br/>            body: JSON.stringify({<br/>              <strong>message: `Hello, ${event.queryStringParameters.name}!`</strong><br/>            })<br/>          };<br/><br/>          callback(null, response);<br/>        };
</pre>
<ol start="6">
<li>To test, deploy the function again, and browse the endpoint address with the query string.</li>
</ol>
<div class="packt_infobox">We will cover other HTTP verbs in <a href="a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml">Chapter 6</a>, <em>Developing the Backend</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-Origin Resource Sharing</h1>
                </header>
            
            <article>
                
<p>If you try to call this API address inside a website through an Ajax call, it will throw an exception. This is because <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) is not enabled by default in API Gateway. CORS is a mechanism that allows a resource to be requested from a web page hosted in another domain. By default, it is disabled to force administrators to give permissions for cross-domain requests only when it makes sense and for specific domains.</p>
<p>We are building a website that will be hosted inside AWS, but the web page will be accessed through our own domain, such as <a href="http://www.example.com">www.example.com</a>, and not from <a href="http://www.amazonaws.com">www.amazonaws.com</a>. As a result, we need to enable CORS to allow our frontend code to consume our services. If you have a Lambda function that should be accessed only by another Lambda or internal AWS service, CORS is not necessary.</p>
<p>To enable CORS, we need to modify our <kbd>handler.js</kbd> function to include the <kbd>"Access-Control-Allow-Origin"</kbd> header:</p>
<pre>
    module.exports.hello = (event, context, callback) =&gt; {<br/>      <br/>      const response = {<br/>        statusCode: 200, <br/>        <strong>headers: {<br/></strong><strong>          "Access-Control-Allow-Origin": "https://www.example.com"<br/></strong><strong>        }, <br/></strong>        body: JSON.stringify({<br/>          message: "Hello, ${event.queryStringParameters.name}!"<br/>        })<br/>      };<br/><br/>      callback(null, response);<br/>    };
</pre>
<p class="mce-root">You can add only <em>one</em> origin per function. This is a problem when we need to support multiple origins, and this requirement is very common. For example, the following addresses are considered different origins because they have different protocols (HTTP versus HTTPS) or different subdomains (none versus www):</p>
<ul>
<li class="mce-root"><kbd>http://example.com</kbd></li>
<li class="mce-root"><kbd>https://example.com</kbd></li>
<li class="mce-root"><kbd>http://www.example.com</kbd></li>
<li class="mce-root"><kbd>https://www.example.com</kbd></li>
</ul>
<p>To support multiple origins, you need to use the following command:</p>
<pre>
<strong>    "Access-Control-Allow-Origin": "*"</strong>
</pre>
<p>Another solution, which is very common in traditional web servers, is to dynamically write the <em>response</em> headers based on the <em>request</em> headers that you can find inside the <kbd>event</kbd> object. If its origin is contained in a predefined whitelist, you can build the <kbd>response</kbd> object using the corresponding origin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing a service</h1>
                </header>
            
            <article>
                
<p>After finishing this example, we can delete our test function and API. The <kbd>remove</kbd> command will delete all AWS resources that were created, but it will leave the project files intact. The syntax is pretty straightforward:</p>
<pre>
<strong>    serverless remove</strong>
</pre>
<p>If you have deployed services to stages or regions that are not configured in the current version of your <kbd>serverless.yml</kbd> file, you can use the <kbd>--stage</kbd> and <kbd>--region</kbd> options to selectively remove them:</p>
<pre>
<strong>    serverless remove --stage production --region eu-west-1</strong>
</pre>
<div class="packt_infobox">
<p>When you make a new deployment to the API Gateway, you receive an API key that is used to compose your API address, for example, <kbd>https://[key].execute-api.[region].amazonaws.com</kbd>. This key is important and will be saved into our frontend code. If you remove your services and recreate them again, a new key will be generated and the frontend key will need to be updated.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going beyond the basics</h1>
                </header>
            
            <article>
                
<p>In this section, we will explore what more we can do using the Serverless Framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using npm packages</h1>
                </header>
            
            <article>
                
<p>When you use the Serverless Framework to deploy your Lambda function, it creates a ZIP file with everything that is inside your project folder. If you need to use a module that is not a Node.js core module or the AWS SDK, you just need to use Node's default workflow to add dependencies.</p>
<p>Take a look at the following steps:</p>
<ol>
<li>Create a <kbd>package.json</kbd> file to store your project dependencies and use <kbd>npm install &lt;your-module&gt; --save</kbd> to download your required module.</li>
<li>With the <kbd>node_modules</kbd> folder inside your project directory, the ZIP file will be deployed to AWS with the necessary dependencies.</li>
<li>In the following example, the Lambda function of the file <kbd>handle.js</kbd> uses an npm module called <kbd>cat-names</kbd>:</li>
</ol>
<pre>
        module.exports.catNames = (event, context, callback) =&gt; {<br/><br/>          <strong>const catNames = require('cat-names');<br/><br/></strong>          const response = {<br/>            statusCode: 200,   <br/>            body: JSON.stringify({<br/>              <strong>message: catNames.random()<br/></strong>            })<br/>          };<br/><br/>          callback(null, response);<br/>        };
</pre>
<ol start="4">
<li>The framework will zip everything that it finds inside the project folder, except what you configure in the <kbd>serverless.yml</kbd> file to be ignored. The following example uses the <kbd>package</kbd> configuration to remove some files that are commonly present in a project folder, but that should never be included in the ZIP file:</li>
</ol>
<pre>
<strong>        </strong>service<span>: </span><span>cat-names<br/></span>        provider<span>:<br/></span>          <span>name</span><span>: </span><span>aws<br/></span>          <span>runtime</span><span>: </span><span>nodejs6.10<br/></span>        functions<span>:<br/></span>          <span>catNames</span><span>:<br/></span>            <span>handler</span><span>: </span><span>handler.catNames<br/></span><strong>        package:</strong><br/><strong>          exclude:</strong><br/><strong>            - package.json<br/>            - event.json<br/>            - tests/**</strong><br/><strong>            - LICENSE</strong><br/><strong>            - README.md</strong>
</pre>
<div class="mce-root packt_infobox">Hidden files and folders are not included in the ZIP package by default, for example, the <kbd>.gitignore</kbd> file and the <kbd>.serverless</kbd> folder, which are part of serverless projects, don't need to be explicitly excluded.</div>
<ol start="5">
<li>To test, just deploy and invoke the <kbd>catNames</kbd> function by using the following command:</li>
</ol>
<pre>
<strong>        serverless deploy </strong><br/><strong>        serverless invoke --function catNames</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing other AWS resources</h1>
                </header>
            
            <article>
                
<p>By default, Lambda functions execute without any permissions. If you want to access S3 buckets, DynamoDB tables, or any kind of Amazon resource, your user must have access to them and you must give explicit permissions to your service.</p>
<p>This configuration is done in the <kbd>serverless.yml</kbd> file under the <kbd>provider</kbd> tag. The following example shows you how to give permissions to an S3 bucket:</p>
<pre>
    provider:<br/>      name: aws<br/>      runtime: nodejs6.10<br/><strong>      iamRoleStatements:</strong><br/><strong>        - Effect: "Allow"</strong><br/><strong>          Action:</strong><br/><strong>            - 's3:PutObject'</strong><br/><strong>            - 's3:GetObject'</strong><br/><strong>          Resource: "arn:aws:s3:::my-bucket-name/*"</strong>
</pre>
<p>To test this statement, we can modify our <kbd>handle.js</kbd> file to write and read files using the following code:</p>
<pre>
    module.exports.testPermissions = (event, context, callback) =&gt; {<br/>      <br/>      const AWS = require('aws-sdk');<br/>      const s3 = new AWS.S3();<br/>      const bucket = 'my-bucket-name';<br/>      const key = 'my-file-name';<br/>      const write = { <br/>        Bucket: bucket, <br/>        Key: key, <br/>        Body: 'Test' <br/>      };<br/><br/>      <strong>s3.putObject</strong>(write, (err, data) =&gt; {<br/>        if (err) return callback(err);<br/><br/>        const read = { Bucket: bucket, Key: key };<br/>        <strong>s3.getObject</strong>(read, (err, data) =&gt; {<br/>          if (err) return callback(err);<br/><br/>          const response = {<br/>            statusCode: 200,   <br/>            body: data.Body.toString()<br/>          };<br/><br/>          callback(null, response);<br/>        });<br/>      });<br/>    };
</pre>
<p>In this example, we are writing a file that contains the <kbd>Test</kbd> string to a bucket and, after finishing the writing, we read the same file and return its contents in our response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Events</h1>
                </header>
            
            <article>
                
<p>The Serverless Framework currently supports the following events:</p>
<ul>
<li><strong>Amazon API Gateway</strong>: This creates RESTful interfaces by triggering Lambda functions through HTTP messages</li>
<li><strong>Amazon S3</strong>: This triggers functions for post-processing when a new file is added or to take an action when a file is removed</li>
<li><strong>Amazon SNS</strong>: This handles SNS notifications with Lambda functions</li>
<li><strong>Schedule</strong>: This triggers functions based on scheduled tasks</li>
<li><strong>Amazon DynamoDB</strong>: This triggers a function when a new entry is added to a table</li>
<li><strong>Amazon Kinesis</strong>: This uses Lambda functions to process Kinesis streams</li>
<li><strong>Amazon Alexa</strong>: This triggers functions with Alexa Skills</li>
<li><strong>AWS IoT</strong>: This handles messages sent to IoT topics</li>
<li><strong>Amazon CloudWatch</strong>: This handles CloudWatch events and log messages using Lambda functions</li>
</ul>
<p>In this list, there are only two services that we haven't seen yet. The first one is Amazon Kinesis, which is a service created to process and analyze streaming data generated by different sources, and the other one is Amazon Alexa, which is <span>Amazon's intelligent personal assistant. Both of them are beyond the scope of this book.</span></p>
<p>We will not cover all event types because the list is extensive, and each one of them requires different configurations. You can see how to use them in the official documentation at <a href="https://serverless.com/framework/docs/providers/aws/events">https://serverless.com/framework/docs/providers/aws/events</a>. In this chapter, we have already exemplified the API Gateway by creating an endpoint for our Lambda function. Now, we will take a look at two more examples: one for Amazon S3, to see how easy it is to create S3 events in comparison to the example from the previous chapter, and the other example is to <strong>Schedule</strong> triggers, which are very useful in running scheduled tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The S3 event</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we configured S3 to trigger a Lambda function when a new file is added to a bucket and its name matches certain rules. The same configuration can be applied here using the following configuration in our <kbd>serverless.yml</kbd> file:</p>
<pre>
    functions:<br/>      processLog:<br/>        handler: handler.processLog<br/>        events:<br/>          - s3:<br/>              bucket: my-bucket-name<br/>              event: s3:ObjectCreated:*<br/>              rules:<br/>                - prefix: logs/<br/>                - suffix: .txt
</pre>
<div class="packt_infobox">The bucket name needs to be a new one. Due to limitations, you can't add events to an existing bucket.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Schedule events</h1>
                </header>
            
            <article>
                
<p>Scheduling Lambda executions is a very important feature for many use cases. This setup is easily done by the framework by modifying the <kbd>serverless.yml</kbd> file using the <kbd>schedule</kbd> event. In the next example, the <kbd>processTask</kbd> function will be executed every 15 minutes:</p>
<pre>
    functions:<br/>      processTask:<br/>        handler: handler.processTask<br/>        events:<br/>          - schedule: rate(15 minutes)
</pre>
<p>This setting accepts either the <kbd>rate</kbd> or <kbd>cron</kbd> expression.</p>
<p>The <kbd>cron</kbd> syntax is compounded by six required fields in the following order: <kbd>Minutes | Hours | Day-of-month | Month | Day-of-week | Year</kbd>. In the next example, the <kbd>cron</kbd> expression is used to schedule a function to run from Monday to Friday at 9:00 am (UTC):</p>
<pre>
    - schedule: cron(0 9 ? * MON-FRI *)
</pre>
<p>Take a look at the following link for more details about this setting:</p>
<p><a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serving HTML pages with Lambda</h1>
                </header>
            
            <article>
                
<p>A very common misunderstanding is that Lambda was designed to serve only JSON data. That's not true. As we have control over the response result, we can properly set the headers to serve HTML content. This is exemplified in the following code:</p>
<pre>
    module.exports.hello = (event, context, callback) =&gt; {<br/><br/>      const html = `<br/>        &lt;!DOCTYPE html&gt;<br/>        &lt;html&gt;<br/>          &lt;head&gt;<br/>            &lt;title&gt;Page Title&lt;/title&gt;<br/>          &lt;/head&gt;<br/>          &lt;body&gt;<br/>            &lt;h1&gt;Hello&lt;/h1&gt;<br/>          &lt;/body&gt;<br/>        &lt;/html&gt;`;<br/><br/>      const response = {    <br/>        statusCode: 200, <br/>        headers: {<br/>          'Access-Control-Allow-Origin': '*',<br/>          <strong>'Content-Type': 'text/html'<br/></strong>        }, <br/>        body: html<br/>      };<br/><br/>      callback(null, response);<br/>    };
</pre>
<p>This approach can be useful for server-side rendering. In <a href="6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml">Chapter 5</a>, <em>Building the Frontend</em>, we will discuss Single-Page Applications, which use client-side rendering, and traditional web applications, which use server-side rendering. Serverless supports both models and it is up to the developer to choose the option that best suits their use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using configuration variables</h1>
                </header>
            
            <article>
                
<p>The Serverless Framework allows the usage of variables in our <kbd>serverless.yml</kbd> configuration file. This flexibility is useful in centralizing configurations that can be referenced at multiple places.</p>
<p>There are many options for using variables. Let's try them out by editing our configuration file:</p>
<ul>
<li><strong>Reference environment variables</strong>:</li>
</ul>
<p style="padding-left: 90px">Take a look at the environment variable used in the following code snippet:</p>
<pre>
        provider:<br/>          name: aws<br/>          runtime: nodejs6.10<br/>          stage: <strong>${env:DEPLOYMENT_STAGE}</strong>
</pre>
<ul>
<li><strong>Load variables from CLI options</strong>:</li>
</ul>
<p style="padding-left: 90px"><span>Take a look at the local variable used in the following code snippet:</span></p>
<pre>
        iamRoleStatements:<br/>          - Effect: "Allow"<br/>             Action:<br/>              - 's3:PutObject'<br/>              - 's3:GetObject'<br/>            Resource: "arn:aws:s3:::<strong>{opt:bucket-name}</strong>/*"
</pre>
<ul>
<li><strong>Store variables in another configuration file</strong>:</li>
</ul>
<p style="padding-left: 90px"><span>Take a look at the usage of a variable defined in another file in the following code snippet:</span></p>
<pre>
        functions:<br/>          hello:<br/>            handler: handler.hello<br/>            events:<br/>              - schedule: <strong>${file(my-vars.yml):schedule}</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plugins</h1>
                </header>
            
            <article>
                
<p>An interesting feature offered by the Serverless Framework is that it is extendable through plugins. You can use plugins for new CLI commands or functionalities that will be executed by hooking into existing commands.</p>
<p>To show how useful they can be, we will test a serverless plugin that supports Lambda development with TypeScript. When we execute the <kbd>deploy</kbd> command, the plugin will compile the code and create a JavaScript version that will be zipped and used by Lambda with the Node.js runtime.</p>
<p>To add this plugin to our project, we need to proceed with the following steps:</p>
<ol>
<li>Install the plugin using npm:</li>
</ol>
<pre>
<strong>        npm install serverless-plugin-typescript --save-dev</strong>
</pre>
<ol start="2">
<li>Add the plugin reference to the end of our <kbd>serverless.yml</kbd> file:</li>
</ol>
<pre class="mce-root">
        plugins:<br/>          - serverless-plugin-typescript
</pre>
<ol start="3">
<li>Write a TypeScript file and save it with the name <kbd>handler.ts</kbd>, as shown in the following code:</li>
</ol>
<pre>
<strong>        export async function hello</strong>(event, context, callback) {<br/><br/>          const response = {<br/>            statusCode: 200,   <br/>            body: JSON.stringify({<br/>              message: 'Hello, TypeScript!'<br/>            })<br/>          };<br/><br/>          callback(null, response);<br/>        }
</pre>
<ol start="4">
<li>Deploy and test using the following command:</li>
</ol>
<pre>
<strong>        serverless deploy<br/>        serverless invoke --function hello</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing deployment information</h1>
                </header>
            
            <article>
                
<p>If you want to know what functions were deployed and their related endpoints, you can use the <kbd>info</kbd> command:</p>
<pre>
<strong>    serverless info</strong>
</pre>
<p>The following screenshot shows this command output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/efb9f3c1-1ad9-4c71-9884-0c2c28ead25e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scaffolding</h1>
                </header>
            
            <article>
                
<p>Scaffolding is a technique that helps developers by providing a sample solution for a common problem. With a <em>boilerplate</em>, you can build a new project, taking advantage of the fact that some features are already configured, developed, and well tested. You start modifying the solution to meet your own requirements following the practices recommended by someone who has more experience than you with this technology and using a code that was used, tested, and improved by a lot of different people. This is the benefit of using open source projects. Also, it's a useful way to learn a new technology through <em>imitation</em>. You learn by seeing how someone else has solved the problem that you want to solve.</p>
<p>Let's perform the following steps to scaffold a project:</p>
<ol>
<li>To scaffold a project, run the following command:</li>
</ol>
<pre>
<strong>        serverless install --url &lt;github-project-url&gt;</strong>
</pre>
<ol start="2">
<li>For example, you can run the following command to scaffold a serverless service to send e-mails:</li>
</ol>
<pre>
<strong>        serverless install \<br/>          --url https://github.com/eahefnawy/serverless-mailer</strong>
</pre>
<div class="packt_infobox">The Serverless Framework team maintains an extensive list of useful examples. Check it out by visiting <a href="https://github.com/serverless/examples">https://github.com/serverless/examples</a>.</div>
<ol start="3">
<li>The objective of this book is to build a sample serverless store. You can find all code that was developed with this objective on GitHub at <a href="https://github.com/zanon-io/serverless-store">https://github.com/zanon-io/serverless-store</a>. This project can also be scaffolded using the same command:</li>
</ol>
<pre>
<strong>        serverless install \<br/>          --url https://github.com/zanon-io/serverless-store</strong>
</pre>
<div class="packt_infobox">The <kbd>\</kbd> (backslash) character in this command was added because the command doesn't fit in one line. It is optional and works for Linux and macOS. On Windows, the <kbd>^</kbd> (caret) is the corresponding symbol.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned what the Serverless Framework is and how it will help us to build serverless applications. After configuring the framework, you have created a hello-world service, added endpoints, enabled CORS, and deployed it to be accessed through a public URL. You also learned how to add npm packages and access AWS resources.</p>
<p>In the next chapter, we will host the frontend following the serverless concept. This will be done using Amazon S3, and we will configure a CloudFront distribution to add a free TLS certificate to support HTTPS connections.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>