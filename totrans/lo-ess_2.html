<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Objects</h1></div></div></div><p>Everything in JavaScript is an object. This includes functions, arrays, and strings. There's also the notion of a plain object—a dictionary of key-value pairs. This latter structure is useful when you need support with looking up values by a key. In other words, something that a programmer would likely want to read—instead of a numerical index found in arrays.</p><p>Lots of APIs return JSON data—you'll often find plain objects. While you can achieve much using JavaScript objects on their own, Lo-Dash makes life easier for doing common things with objects. These functions make the mundane a little less boring as you'll soon find out, you can often find a less verbose approach to working with objects.</p><p>In addition to plain object access and manipulation, Lo-Dash has several utility functions that can be applied to any object in your code. These are mostly concerned with validating the type of object you're working with, a duplicitous task using Vanilla JavaScript.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining an object type</li><li class="listitem" style="list-style-type: disc">Assigning and accessing properties</li><li class="listitem" style="list-style-type: disc">Iterating over objects</li><li class="listitem" style="list-style-type: disc">Calling methods</li><li class="listitem" style="list-style-type: disc">Transforming objects</li><li class="listitem" style="list-style-type: disc">Creating and cloning objects</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Determining an object type</h1></div></div></div><p>In this section, we'll look at <a id="id98" class="indexterm"/>how type validation is typically handled in JavaScript and how the type-checking functions in Lo-Dash improve the situation.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Type coercion</h2></div></div></div><p>Type coercion<a id="id99" class="indexterm"/> happens in JavaScript when one object is compared to another. That is, we have one object operand, the operator, and the second object operand. Depending on the operation being performed, the second object might be coerced into a representation that is compatible with the first operand. Take the following operation, for example:</p><div><pre class="programlisting">true == 1</pre></div><p>These are obviously different objects representing different primitive types. In the spirit of loosely typed programming, this expression triggers type coercion. The first operator is a Boolean value and the second operator is a number. The <code class="literal">==</code> equality operator will take the Boolean representation of <code class="literal">1</code> and compare it with <code class="literal">true</code>. This is why, this expression always evaluates to <code class="literal">true</code>. The values are <em>roughly</em> equal.</p><p>You can avoid<a id="id100" class="indexterm"/> type coercion using the strict equality operator. The following expression will evaluate to <code class="literal">false</code> since the two operators are compared in their raw forms:</p><div><pre class="programlisting">true === 1</pre></div><p>So why turn off type coercion? This seems like a useful tool. Well, it's useful when you don't care about certain things. For example, the previous chapter introduced you to the concept of truthy and falsey values—things that are roughly true or are roughly false. Here, type coercion is your friend because it captures a range of possible values, instead of having to strictly check for equality for a number of possible values. In short, type coercion exists to make your life easier by writing less code.</p><p>There are times, however, where type coercion doesn't help at all, and can instead introduce insidious bugs that are painful to track down. For example, let's negate some values with the following expressions:</p><div><pre class="programlisting">!false;
!undefined;
!0;</pre></div><p>These all evaluate to <code class="literal">true</code> and this fact can be problematic to our code. Especially, the fact that an object can have a missing property, and this will evaluate to the same thing as a defined property with a <code class="literal">false</code> or <code class="literal">0</code> value. Again, it helps you to be explicit in these scenarios and turn off type coercion using the strict equality/inequality operator.</p><p>So, what's the point of all this and what does it have to do with Lo-Dash? The preceding expressions are just a small sampling of the literally thousands of edge cases and issues that can come about when different types of objects interact in our application. Lo-Dash aims to reduce some of these complexities by providing consistent behavior. Internally, Lo-Dash has to perform all kinds of ugly type comparisons and checks so that we don't have to perform them. As an added bonus, these utility functions are exposed in the Lo-Dash API.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Managing function arguments</h2></div></div></div><p>It's not always clear what <a id="id101" class="indexterm"/>kind of arguments our functions will be called with. Nor is it <a id="id102" class="indexterm"/>enforced that the number of arguments specified in our function declaration match the number supplied by the caller—these are called<a id="id103" class="indexterm"/> <strong>variadic</strong> functions. The type-checking facility provided by Lo-Dash can better prepare your functions to handle anything that's thrown in their way.</p><p>For example, you can explicitly check each function argument in order to determine what's being passed to your function. In the case of optional arguments, you can use these functions to explicitly check whether anything was passed as an argument at all, as shown in the following code:</p><div><pre class="programlisting">function hello(name) {
    if (_.isString(name)) {
        return 'hello, ' + name;
    }   
}   

hello('world');
// → "hello, world"

hello();
// → undefined</pre></div><p>If the <code class="literal">name</code> parameter isn't a string, it isn't anything else, in other words, the function does nothing. This is the case in the preceding code, in the second call to <code class="literal">hello()</code>. Rather than doing nothing, we can have some other recourse built into your function, but that's specific to what our function does. The point is that we're conscientious of what might get passed our way.</p><p>A variation on whether an argument is present or not, in a function call, is the order in which the arguments are passed. You can ignore the last parameter because its value is undefined and it's optional anyway. However, what if our function takes three parameters and the second one is optional? We have to juggle the arguments and their values inside our function. A lot of libraries do this and Lo-Dash simplifies matters with its type-checking functions, as shown in the following code:</p><div><pre class="programlisting">function hello(greeting, person) {
    if (_.isPlainObject(greeting)) {
        person = greeting;
        greeting = 'hi, ';
    }   
    return greeting + person.name;
}

hello('hello, ', { name: 'Dillan' });
// → "hello, Dillan"

hello({ name: 'Danielle' });
// → "hi, Danielle"</pre></div><p>Here, the <code class="literal">hello()</code> function expects<a id="id104" class="indexterm"/> a <code class="literal">greeting</code> string and a <code class="literal">person</code> object. It turns<a id="id105" class="indexterm"/> out that the <code class="literal">greeting</code> parameter is actually optional but it's the first parameter. So the function checks whether <code class="literal">greeting</code> is actually a plain object, signaling that the <code class="literal">greeting</code> string was omitted. Then, you just make sure that <code class="literal">person</code> is assigned the value of <code class="literal">greeting</code>.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>All these type-checking operations can actually be done using Vanilla JavaScript. On the other hand, there are nuances to doing this because of JavaScript's esoteric type system. Lo-Dash just takes the common things that you don't have to check yourself and exposes them as easy-to-decipher function names.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Arithmetic</h2></div></div></div><p>If you've ever done<a id="id106" class="indexterm"/> arithmetic in your JavaScript application, you know that using the wrong types as operands can lead to some truly puzzling results. For example, the following expressions might or might not look familiar:</p><div><pre class="programlisting">1/0; // Infinity
1+'one'; // NaN</pre></div><p>The gist of the matter is that when these guys rear their heads, it's generally not a good sign. This can happen as a result of our own function code (under heavy development and not in production, obviously) or it would just be that our function is getting called with bad data. In either scenario, we need to be prepared to troubleshoot what's happening. We do this by providing a safety net for our arithmetical operations, as shown:</p><div><pre class="programlisting">var operand1 = 1/0,
    operand2 = NaN,
    results = [];

_.forEach([ operand1, operand2 ], function(op) {
    if (_.isFinite(op)) {
        results.push('operand 1 is finite');
    } else {
        if (!_.isNumber(op) || _.isNaN(op)) {
            results.push(op.toString() + ' is not a number');
        } else {
            results.push('Infinity cannot be used here');
        }
    }
});

return results;
// → 
// [
//   "Infinity cannot be used here",
//   "NaN is not a number"
// ]</pre></div><p>This code iterates over the <a id="id107" class="indexterm"/>operands and checks whether each operand is finite using the <code class="literal">isFinite()</code> Lo-Dash <a id="id108" class="indexterm"/>function. This function can be thought of as a catch-all; if this test passes, then you're generally safe to perform arithmetic using the operand. The <code class="literal">else</code> code runs if <code class="literal">isFinite()</code> fails, and it's an attempt to find a reason for the failure. If it's not a number, then it's obviously not finite. This will include values such as <code class="literal">true</code>, <code class="literal">String</code>, or <code class="literal">null</code>. On the other hand, if it is a number that's not finite, we know that we're dealing with infinity.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p><code class="literal">NaN</code> is actually a number—the JavaScript type system at its best. That's why the <code class="literal">if</code> statement in the preceding code has a check for <code class="literal">!_.isNumber()</code> or <code class="literal">_.isNaN()</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Callable objects</h2></div></div></div><p>If you've ever tried to<a id="id109" class="indexterm"/> invoke <a id="id110" class="indexterm"/>something that's not a function, you've probably seen an error message along the lines of <code class="literal">TypeError: undefined is not a function</code>. In this case, the property or variable doesn't exist at all. However, we'll get an error message along the same lines if we try to call an object that exists, but is not callable.</p><p>Sometimes this error is desirable, as our code is trying to call something that's not a function. The solution: we go and fix it. Remember that JavaScript is dynamically typed, and depending on how our application is designed, there could be circumstances where you need to explicitly check whether something is a function before trying to call it, as shown in the following example:</p><div><pre class="programlisting">var object = {
    a: function() { return 'ret'; },
    b: []
};

_.isFunction(object.a) &amp;&amp; object.a();
// → "ret" 

_.isFunction(object.b) &amp;&amp; object.b();
// → false</pre></div><p>The first property, <code class="literal">a</code>, is a<a id="id111" class="indexterm"/> function, so the check issued by calling <code class="literal">isFunction()</code> passes, and<a id="id112" class="indexterm"/> the function is invoked. The <code class="literal">b</code> property, on the other hand, is an array and is not callable. So nothing happens there.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Assigning and accessing properties</h1></div></div></div><p>Creating new JavaScript<a id="id113" class="indexterm"/> objects with values assigned to them is a straightforward task. The <a id="id114" class="indexterm"/>tedious part is when we have to merge the contents of one object into another or when we have to ensure that the default values are populated for the new objects. Locating values in objects and validating whether a key exists or not would actually require a significant amount of code were it not for the Lo-Dash tools that help us with these activities.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Extending objects</h2></div></div></div><p>A common pattern in JavaScript libraries is to <a id="id115" class="indexterm"/>extend objects with other objects to assign property values. This can be done by assigning one property to an object on a statement-by-statement basis. The trouble with this approach is that you need to know ahead of time, exactly, which properties are going to be assigned to the destination object. Consider when new values come from a function argument. Having to know ahead of time all the possible properties these argument values might have isn't feasible. It's easier to just take what's passed as the source and extend the destination with it. That's why you'll find this pattern everywhere, including Lo-Dash. These tools are exposed for you to follow the same pattern in your application. An example for this is shown as follows:</p><div><pre class="programlisting">var object = { 
    name: 'Jeremy',
    age: 42
};

_.assign(object, {
    occupation: 'Programmer'
});

// →
// {
//   name: "Jeremy",
//   age: 42,
//   occupation: "Programmer"
// }</pre></div><p>Here, the destination is the <code class="literal">object</code> variable and it gets the <code class="literal">occupation</code> property assigned to it. In fact, using <code class="literal">assign()</code>, we have to be careful because it pays no attention to the existing properties. Any sources passed in will override them, as shown in the following code:</p><div><pre class="programlisting">var object1 = { 
        name: 'Jenny',
        age: 27
    },  
    object2 = { 
        age: 31
    },  
    object3 = { 
        occupation: 'Neurologist'
    };

_.assign(object1, object2, object3);
// →
// {
//   name: "Jenny",
//   age": 31,
//   occupation: "Neurologist"
// }</pre></div><p>Two objects are assigned to the destination, <code class="literal">object1</code>. The <code class="literal">assign()</code> function<a id="id116" class="indexterm"/> takes as many <a id="id117" class="indexterm"/>arguments as you need to pass—they're all chained together, from left to right, successively overriding the previous properties. In the preceding code, for example, there are no new objects being assigned that override the <code class="literal">name</code> property. The second object, though, overrides the <code class="literal">age</code> property. The final object has a brand new property and is simply added to the destination. Note that the final object is <code class="literal">object1</code>, which is modified in place.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Lo-Dash uses aliases for some of its functions. For example, <code class="literal">extend()</code> is simply an alias <a id="id118" class="indexterm"/>for <code class="literal">assign()</code>; it does the exact same thing. It's a matter of personal taste, which one gets used. Do you prefer to think of an object being <em>assigned</em> to another or to think of one object <em>extending</em> another?</p></div></div><p>So far, we've dealt with simple properties that override one another, but what about more complex properties, such as objects and arrays? Would we like these values to merge together instead of being completely overridden? Here's an example showing this:</p><div><pre class="programlisting">var object1 = { 
        states: { running: 'poweroff' },
        names: [ 'CentOS', 'REHL' ]
    },  
    object2 = { 
        states: { off: 'poweron' },
        names: [ 'Ubuntu', 'Debian' ]
    };

_.merge(object1, object2, function(dest, src) {
    if (_.isArray(dest) &amp;&amp; _.isArray(src)) {
        return dest.concat(src);
    }   
});
// →
// {
//   states: {
//     running: "poweroff",
//     off: "poweron"
//   },
//   names: [
//     "CentOS",
//     "REHL",
//     "Ubuntu",
//     "Debian"
//   ]
// }</pre></div><p>The <code class="literal">merge()</code> function will <a id="id119" class="indexterm"/>recursively examine the object's properties before overriding <a id="id120" class="indexterm"/>them, unlike the <code class="literal">assign()</code> function. In other respects, the two functions are similar, we're copying the properties of one or more objects to a single destination object. Notice the <code class="literal">states</code> property—it doesn't get overridden. Instead, <code class="literal">merge()</code> will examine the two objects and merge them together. Other types that already exist in the destination, with the same property name, are simply overridden. This includes arrays.</p><p>Notice that we're able to pass in your own callback function to <code class="literal">merge()</code>. This function determines how to merge properties. The code checks whether the destination property and the source property are arrays. If so, concatenate the source to the destination, otherwise it'll be overridden. The callback will ignore anything that's not an array.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Defaults for new objects</h2></div></div></div><p>A common practice in <a id="id121" class="indexterm"/>JavaScript programming is to customize properties through arguments. That is, when we create a new object instance, we might supply an argument that's unique to the context where the object is being used. However, to use this pattern effectively, we have to provide some default values when the caller doesn't supply any values. There are a number of ways to do this, but Lo-Dash provides a function that will handle the vast majority of cases, as shown in the following code:</p><div><pre class="programlisting">var object = { 
    name: 'George'
};

_.defaults(object, {
    name: '', 
    age: 0,
    occupation: ''
});
// →
// {
//   name: "George",
//   age": 0,
//   occupation": ""
// }</pre></div><p>As we can see, the <code class="literal">name</code> property isn't overridden with the default values. The other two defaults, <code class="literal">age</code> and <code class="literal">occupation</code>, are assigned to the object because they're undefined. If the property exists with any other value, <code class="literal">defaults()</code> will use that, and not the default.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>The <code class="literal">defaults()</code> function<a id="id122" class="indexterm"/> actually uses the <code class="literal">assign()</code> function. It just passes <code class="literal">assign()</code>, a callback function that customizes the way defaults are assigned. Namely, by looking for undefined values.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Finding keys and values</h2></div></div></div><p>Objects, in Vanilla<a id="id123" class="indexterm"/> JavaScript, use the same syntax as arrays for accessing property<a id="id124" class="indexterm"/> values. That is, the square bracket notation but typically with a human-readable string, instead of a numerical index. However, the same issues that exist with numerical indices and arrays exist with objects and keys too. Just because the key is a string doesn't mean that we know which keys are available. Sometimes, we have to search the object to find the key we're looking for.</p><p>We use the <code class="literal">findKey()</code> function<a id="id125" class="indexterm"/> to locate the key of the first object property that callback returns truthy for:</p><div><pre class="programlisting">var object = { 
    name: 'Gene',
    age: 43, 
    occupation: 'System Administrator'
};

_.findKey(object, function(value) {
    return value === 'Gene';
});
// → "name"</pre></div><p>Here, the result is <code class="literal">name</code>; since it's the first property value our callback to <code class="literal">findKey()</code> returns <code class="literal">true</code> for. Strangely enough, the pluck style shorthand doesn't work the way you think it might. Calling <code class="literal">_.findKey(object, 'Gene')</code> doesn't find anything. That's because it's treating each <a id="id126" class="indexterm"/>of the property values as nested objects. Here's an example <a id="id127" class="indexterm"/>of how the where style shorthand works with this function:</p><div><pre class="programlisting">var object = { 
    programmers: {
        Keith: 'C',
        Marilyn: 'JavaScript'
    },  
    designers: {
        Lori: 'CSS',
        Marilyn: 'HTML'
    }   
};

_.findKey(object, { Marilyn: 'JavaScript' });
// → "programmers"</pre></div><p>As we can see, it treats each property value as though it's another object; these are the values the <code class="literal">where</code> criteria is tested against. We can also find the key of object properties that have array values using the following code:</p><div><pre class="programlisting">var object = { 
    Maria: [
        'Python',
        'Lisp',
        'Go'
    ],  
    Douglas: [
        'CSS',
        'Clojure',
        'Haskell'
    ]   
}; 

var lang = 'Lisp';

_.findKey(object, function(value) {
    if (_.isArray(value)) {
        return _.contains(value, lang);
    } else {
        return value === lang;
    }   
});
// → "Maria"</pre></div><p>The callback <a id="id128" class="indexterm"/>function passed to <code class="literal">findKey()</code> checks whether the <a id="id129" class="indexterm"/>property value is an array. If so, it checks whether the value exists inside it. Otherwise, it'll just perform a strict value comparison. Since the <code class="literal">search</code> term exists in the first property value, the resulting key will be <code class="literal">Maria</code>.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>The <code class="literal">findKey()</code> function<a id="id130" class="indexterm"/> has a complementary function<a id="id131" class="indexterm"/> called <code class="literal">findLastKey()</code>. This simply searches in the opposite direction. It's kind of<a id="id132" class="indexterm"/> like <code class="literal">find()</code> and <code class="literal">findLast()</code> for<a id="id133" class="indexterm"/> collections. The difference is that the order is preserved in arrays. With objects, you're working with an unordered collection of key-value pairs. Since the order is never guaranteed, <code class="literal">findLastKey()</code> is limited in usefulness.</p></div></div><p>We might find ourselves working with an object, but we don't necessarily have a use for the keys. Remember that objects are also collections, so you can still use <code class="literal">find()</code> or <code class="literal">where()</code> as you would on arrays, as shown in the following example:</p><div><pre class="programlisting">var object = {
    8490: {
        first: 'Arthur',
        last: 'Evans',
        enabled: false
    },  
    7035: {
        first: 'Shirley',
        last: 'Rivera',
        enabled: false
    },  
    4818: {
        first: 'William',
        last: 'Howard',
        enabled: true
    }   
};

_.find(object, 'enabled');
// → 
// {
//   first: "William",
//   last: "Howard",
//   enabled: true
// }

_.where(object, { last: 'Rivera' });
// → 
// [
//   {
//     first: "Shirley",
//     last: "Rivera",
//     enabled: false
//   }
// ]</pre></div><p>These functions <a id="id134" class="indexterm"/>treat each <code class="literal">object</code> property value as though they were an<a id="id135" class="indexterm"/> element of an array, ignoring the key. Next, we'll look at iterating through objects for cases when simple collection shorthands don't suffice.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Iterating over objects</h1></div></div></div><p>Lo-Dash has a few functions <a id="id136" class="indexterm"/>that are useful when we need to iterate over the properties of an object in order to fulfill the behavior of our component. We'll start off by exploring some basic iterations. Then, we'll look at how to iterate over inherited object properties, followed by looking at keys and values and simple approaches to iterating over them.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Basic For Each</h2></div></div></div><p>Just as we saw in the previous chapter, objects <a id="id137" class="indexterm"/>can be iterated, just as arrays—they're both collections. While the mechanism to do so is slightly different, Lo-Dash abstracts those differences away behind a unified function API, as shown in the following code:</p><div><pre class="programlisting">var object = { 
    name: 'Vince',
    age: 42, 
    occupation: 'Architect'
}, result = [];

_.forOwn(object, function(value, key) {
    result.push(key + ': ' + value);
});
// → 
// [
//   "name: Vince",
//   "age: 42",
//   "occupation: Architect"
// ]</pre></div><p>The preceding code should look somewhat <a id="id138" class="indexterm"/>familiar. It's just like<a id="id139" class="indexterm"/> the <code class="literal">forEach()</code> function. Instead of the index, the second argument passed to the callback function is the property key.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>The <code class="literal">_.forOwn()</code> <a id="id140" class="indexterm"/>and <code class="literal">_.forEach()</code> functions behave identically<a id="id141" class="indexterm"/> when applied to an object. Both of these functions share the same base function that's used to iterate over collections. Lo-Dash has several base functions that are generic enough to serve many purposes. While these aren't exposed as a part of the public API, they make the exposed functions smaller and more comprehensible.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Including inherited properties</h2></div></div></div><p>The object iterations only include <em>own</em> properties. That is, properties defined directly on the object and not elsewhere higher up in the<a id="id142" class="indexterm"/> <strong>prototype chain</strong>. We can test that the property in question is an owned property <a id="id143" class="indexterm"/>using the <code class="literal">hasOwnProperty()</code> method. We pass this method the name of the property we're looking for and it'll return <code class="literal">true</code> if the property is defined on this property and not further up in the prototype chain.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>If the term prototype chain sounds foreign, you might want to read about what they are and how they work. JavaScript objects are prototypical, so understanding this concept is important if you're a JavaScript programmer. This topic goes way beyond the scope of this book, but there are literally hundreds of excellent resources on prototypes available online. You don't need a full understanding of the topic for this book, just this section.</p></div></div><p>Lo-Dash has another object iteration function called <code class="literal">forIn()</code>. This function has the ability to iterate over both the owned properties, and over properties inherited through the prototype chain. An example for this is as follows:</p><div><pre class="programlisting">function Person() {
    this.full = function() {
        return this.first + ' ' + this.last;
    };  
}   

function Employee(first, last, occupation) {
    this.first = first;
    this.last = last;
    this.occupation = occupation;
}   

Employee.prototype = new Person();

var employee = new Employee('Theo', 'Cruz', 'Programmer'),
    resultOwn = [], 
    resultIn = [];

_.forOwn(employee, function(value, key) {
    resultOwn.push(key);
});
// → [ "first", "last", "occupation" ]

_.forIn(employee, function(value, key) {
    resultIn.push(key);)
});
// → [ "first", "last", "occupation", "full" ]</pre></div><p>This code uses both <a id="id144" class="indexterm"/>the forms of object iteration, <code class="literal">forOwn()</code>, followed by <code class="literal">forIn()</code>. The difference between the two is the <code class="literal">full</code> key, which only appears in the result generated by <code class="literal">forIn()</code>. That's because it's defined in the <code class="literal">Person</code> object, which is the prototype of <code class="literal">Employee</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Keys and values</h2></div></div></div><p>Previously, we've been working with <a id="id145" class="indexterm"/>Lo-Dash functions that directly iterate over the object's keys and values. This is the direct route. However, what if we've already written some code that's expecting an array of keys or values? There's an indirect route to iterating over objects that involves fetching the object's keys or its values as an array. You then iterate those.</p><p>For example, here's some code that will iterate over an object's keys:</p><div><pre class="programlisting">var object = { 
    occupation: 'Optometrist',
    last: 'Lynch',
    first: 'Shari'
};

_.sortBy(_.keys(object));
;
// → [ "first", "last", "occupation" ]</pre></div><p>The preceding result is an array of strings<a id="id146" class="indexterm"/> built by the <code class="literal">keys()</code> function. We use<a id="id147" class="indexterm"/> the <code class="literal">sortBy()</code> function<a id="id148" class="indexterm"/> as a quick-and-dirty means to sort the array. Each property key is then pushed, in order, into the <code class="literal">result</code> array. Let's build this example and use it as a means to gain ordered access to object property values:</p><div><pre class="programlisting">var object = { 
    occupation: 'Optometrist',
    last: 'Lynch',
    first: 'Shari'
};
 
return _.at(object, _.sortBy(_.keys(object)));
// → [ "Shari", "Lynch", "Optometrist" ]</pre></div><p>This code takes a bit of a shortcut. However, isn't that what writing good code is all about? Instead of employing the <code class="literal">forEach()</code> function to iterate the keys once they've been sorted, we simply pass them to the <code class="literal">at()</code> function. This function accepts an array of keys or indices and will look up the values for us, in order. The preceding result is an array of property values, sorted by their keys.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>The <code class="literal">keys()</code> function<a id="id149" class="indexterm"/> plays a vital role in the <code class="literal">forOwn()</code> function used to iterate over objects. This function is used to get the object keys, then the keys are iterated over, looking up object values. Again, some of the external Lo-Dash functions play an essential role internally.</p></div></div><p>Complementary to <code class="literal">keys()</code> is <code class="literal">values()</code> when <a id="id150" class="indexterm"/>you really have no use for key names. For example, to build an array of object values, you can use the following code:</p><div><pre class="programlisting">var object = { 
    first: 'Hue',
    last: 'Burton',
    occupation: 'Horticulturalist'
};

_.values(object);
// → [ "Hue", "Burton", "Horticulturalist" ]</pre></div><p>From this point forward, we have an array of values to work with. The keys are disregarded completely. For instance, what if we wanted to sort the <code class="literal">object</code> property values by something specific to the value instead of a key, as we saw earlier? This can be done using the following code:</p><div><pre class="programlisting">var object = { 
    Angular: { name: 'Patrick' },
    Ember: { name: 'Jane' },
    Backbone: { name: 'George' }
};

_.sortBy(_.values(object), 'name');
// → 
// [
//   { name: "George" },
//   { name: "Jane" },
//   { name: "Patrick" }
// ]</pre></div><p>It's like we're just turning <code class="literal">object</code> into an array by truncating the keys. In fact, replacing <code class="literal">values()</code> with <code class="literal">toArray()</code> yields the exact same result. Under the hood, <code class="literal">toArray()</code> actually calls <code class="literal">values()</code> if an object is passed to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Calling methods</h1></div></div></div><p>Objects don't just come with <a id="id151" class="indexterm"/>static property values—some of these values are callable functions. Functions assigned as an object's property are often referred to as methods, since they're generally interacting with the encapsulated state of the object to which they belong. Other times, objects are just a convenient vehicle for assigning and passing functions around the code. At the end of the day, they're just functions assigned to property values and Lo-Dash has some functions that assist with finding and calling them.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Getting results</h2></div></div></div><p>We can use the <code class="literal">result()</code> function<a id="id152" class="indexterm"/> when we're <a id="id153" class="indexterm"/>unsure whether a given property name is a function or another type. This can simplify our code greatly because we don't need to write code that checks whether the property should be accessed like a regular static property value or if the property needs to be invoked. The usage of the <code class="literal">result()</code> function is shown in the following code:</p><div><pre class="programlisting">var object1 = { 
        name: 'Brian'
    },  
    object2 = { 
        name: function() {
            return 'Brian';
        }   
    },  
    object3 = {};

_.result(object1, 'name', 'Brian');
// → "Brian" 

_.result(object2, 'name', 'Brian');
// → "Brian" 

_.result(object3, 'name', 'Brian');
// → "Brian" </pre></div><p>We can see that the result is always <code class="literal">Brian</code> and that<a id="id154" class="indexterm"/> the invocation of <code class="literal">result()</code> is the same on all the three objects. However, the result is <code class="literal">Brian</code> for three different reasons. The first object has a <code class="literal">name</code> property whose string value is <code class="literal">Brian</code>. The second object has a <code class="literal">name</code> property whose value is a function that returns the string <code class="literal">Brian</code>. The third object has no <code class="literal">name</code> attribute, so the default <code class="literal">Brian</code> value is used. With very little effort on your part, using the <code class="literal">result()</code> function's objects promotes consistency in terms of object property access.</p><p>Use <code class="literal">result()</code> judiciously, otherwise we'll get confused by its constant use in our code. In cases where direct property access or direct method invocation produces cleaner code, go that route. In cases where consistent results from property access presents a problem, and these should be rare, <code class="literal">result()</code> is our friend.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Finding methods</h2></div></div></div><p>Before we call a method, we might <a id="id155" class="indexterm"/>want to execute some more complex logic than a simple default value if the method doesn't exist. For example, we might know that a <code class="literal">name()</code> method exists on some objects, but not on others. Something else we know for certain is that there's no <code class="literal">name</code> property with simple values, so the <code class="literal">result()</code> function doesn't help here.</p><p>The <code class="literal">functions()</code> function<a id="id156" class="indexterm"/> will look through an object and return an array of keys whose values are functions, as shown in the following code:</p><div><pre class="programlisting">function Person(first, last) {
    this.first = first;
    this.last = last;
}

Person.prototype.name = function() {
    return this.first + ' ' + this.last;
};

_.functions(new Person('Teresa', 'Collins'));
// → [ "name" ]</pre></div><p>Notice that the <code class="literal">name()</code> method is<a id="id157" class="indexterm"/> defined as a part of the person's prototype and not directly on the <code class="literal">Person</code> instance. This makes sense if we think about it. If the method exists higher up in the prototype chain, it's still callable, using the current instance as its context. So we would want those method names in the resulting array, and that's what happened here.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Transforming objects</h1></div></div></div><p>Sometimes, we're<a id="id158" class="indexterm"/> implementing a feature and the given object we're working with just doesn't fit the bill—you need to transform it into a structure that's better suited for our needs. There are a handful of functions that are shipped with Lo-Dash to help us do this. We can create an array of arrays out of objects, we can pick and choose which object properties we want to work with, and we can turn an object inside out by inverting its keys and values.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Using pairs</h2></div></div></div><p>The <code class="literal">pairs()</code> function<a id="id159" class="indexterm"/> accepts an object argument and generates an array of which each element is itself an array, which contains the key and the value. This structure can be a lot more convenient to work with under some circumstances. An example of this is shown in the following code:</p><div><pre class="programlisting">function format(label, value) {
    return label + ': ' + value;    
}   
var object = { 
    first: 'Katherine',
    last: 'Bailey',
    age: 33
}, result = '';
 
_.forEach(_.pairs(object), function(pair) {
    result += format.apply(null, pair) + '\n';
});
// → "first: Katherine\nlast: Bailey\nage: 33\n" </pre></div><p>This code iterates over <code class="literal">object</code>, but before doing so, it calls the <code class="literal">pairs()</code> function. This transforms the object into an array, so the callback to <code class="literal">forEach()</code> gets an item of this array. The <code class="literal">pair</code> argument is an array, the first element is the key, and the second is the value. Using this key-value pair, we can call <code class="literal">apply()</code> on the <code class="literal">format()</code> function.</p><p>This means that if we have a<a id="id160" class="indexterm"/> generic callback function that's using something like the <code class="literal">format()</code> function, we don't need to pass it specific arguments. As it's illustrated here, when passing the <code class="literal">pair</code> array, you can call <code class="literal">apply()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Picking and omitting properties</h2></div></div></div><p>Sometimes not every<a id="id161" class="indexterm"/> object<a id="id162" class="indexterm"/> property is necessary. In the case <a id="id163" class="indexterm"/>of extending an object with another, it can actually be a <a id="id164" class="indexterm"/>harmful exercise—adding properties that aren't needed. Instead, you can use the <code class="literal">pick()</code> function<a id="id165" class="indexterm"/> to choose the properties you need:</p><div><pre class="programlisting">var object1 = { 
        name: 'Kevin Moore',
        occupation: 'Programmer'
    },  
    object2 = { 
        specialty: 'Python',
        employer: 'Acme'
    };

_.assign(object1, _.pick(object2, 'specialty'));
// →
// {
//   name: "Kevin Moore",
//   occupation: "Programmer",
//   specialty: "Python"
// }</pre></div><p>The second object in this example has only one property we're interested in, <code class="literal">specialty</code>. As it so happens, only one property is dropped, <code class="literal">employer</code>. However, what we've done here, by picking only what we need to extend our existing object with, is rule out the possibility of any unwanted properties causing issues down the line.</p><p>On the other hand, we might know exactly what we don't want from an object. The complementary to <code class="literal">pick()</code> is <code class="literal">omit()</code> that<a id="id166" class="indexterm"/> excludes the specified properties from the object, an example is shown here:</p><div><pre class="programlisting">var object1 = { 
        name: 'Kevin Moore',
        occupation: 'Programmer'
    },  
    object2 = { 
        specialty: 'Python',
        employer: 'Acme'
    };

_.assign(object1, _.omit(object2, 'employer'));
// →
// {
//   name: "Kevin Moore",
//   occupation: "Programmer",
//   specialty: "Python"
// }</pre></div><p>This code is the inverse <a id="id167" class="indexterm"/>of the example on <code class="literal">pick()</code>. Instead of using <code class="literal">pick()</code> to specify what <a id="id168" class="indexterm"/>we want to have included, we use <code class="literal">omit()</code> to specify what we want <a id="id169" class="indexterm"/>excluded from the assignment. Which one we use depends<a id="id170" class="indexterm"/> on the requisite knowledge we have about the objects and which properties are valuable where.</p><p>Aside from providing the names of properties we want to be included or excluded, we can provide custom logic that makes the decision in the form of a callback using the following code:</p><div><pre class="programlisting">var object = { 
    name: 'Lois Long',
    age: 0,
    occupation: null
};

_.omit(object, function(value) {
    return !(!_.isBoolean(value) &amp;&amp; value);
});
// → { name: "Lois Long" }</pre></div><p>This code works in the same vein as <code class="literal">compact()</code> does with collections. Our callback is applied to every <code class="literal">object</code> property value, and if it returns <code class="literal">true</code>, then that value is omitted from the resulting object. Here, we're omitting falsey values with the exception of Boolean types.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Inverting keys and values</h2></div></div></div><p>Our application might <a id="id171" class="indexterm"/>define a<a id="id172" class="indexterm"/> function that uses <code class="literal">keys()</code> or <code class="literal">values()</code> to work with an object. However, we might find ourselves in a situation where we want that same function to work inversely. That is, if the function uses <code class="literal">keys()</code>, we want it to use <code class="literal">values()</code>. If it uses <code class="literal">values()</code>, we want it to use <code class="literal">keys()</code>.</p><p>Rather than altering the function that's used everywhere and we know is stable, we can simply invert the object using Lo-Dash's <code class="literal">invert()</code> function before it's passed:</p><div><pre class="programlisting">function sortValues(object) {
    return _.values(object).sort();
}   

var object1 = { 
        first: 'Mathew',
        last: 'Johnson'
    },  
    object2 = { 
        first: 'Melissa',
        last: 'Willians'
    };

sortValues(object1);
// → [ "Johnson", "Mathew" ]

sortValues(_.invert(object2));
// → [ "first", "last" ]</pre></div><p>The <code class="literal">sortValues()</code> function<a id="id173" class="indexterm"/> is straightforward enough. It accepts an <code class="literal">object</code> argument, uses the <code class="literal">values()</code> function to build a property value array, then returns that array once<a id="id174" class="indexterm"/> it's been sorted. If we would like to reuse <code class="literal">sortValues()</code> on the <a id="id175" class="indexterm"/>object keys, for whatever reason, we just use <code class="literal">invert()</code> on the object before it's passed. This makes the keys of the object the values. So, when <code class="literal">sortValues()</code> calls the <code class="literal">values()</code> function, it's actually getting the keys.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating and cloning objects</h1></div></div></div><p>Our last topic of the chapter is that of <a id="id176" class="indexterm"/>creating and cloning JavaScript objects. We can get by on a day-to-day basis <a id="id177" class="indexterm"/>without putting too much thought into creating or cloning objects. The <code class="literal">new</code> keyword<a id="id178" class="indexterm"/> or the object literal notation serves us just fine. Rarely is there a need to clone objects. However, Lo-Dash nonetheless has tools to deal with both of these scenarios when the need arises.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Creating objects</h2></div></div></div><p>The <code class="literal">create()</code> function <a id="id179" class="indexterm"/>helps us <a id="id180" class="indexterm"/>close the gap between functional and object-oriented paradigms. It allows us to leverage some crucial functional JavaScript components in our objects. Particularly, when it comes to specifying prototypes when creating new objects.</p><p>This might not sound like a big deal, but it can make for some fun, elaborate hacking. Let's say that we have a collection of objects defined using the literal notation. These objects have just straightforward string property values. Let's also say that we have a class that defines some behavior through methods. Using the <code class="literal">create()</code> function, we can pass the property values directly to a new instance of that class, so that you can utilize its behavior, as shown in the following code:</p><div><pre class="programlisting">function Person() {}
Person.prototype.name = function() {
    return this.first + ' ' + this.last;
};  

var collection = [ 
        { first: 'Jean', last: 'Flores' },
        { first: 'Edward', last: 'Baker' },
        { first: 'Jennifer', last: 'Walker' }
    ],  
    people = []; 

_.forEach(collection, function(item) {
    people.push(_.create(Person.prototype, item));
}); 

_.invoke(people, 'name');
// → [ "Jean Flores", "Edward Baker", "Jennifer Walker" ]</pre></div><p>It's helpful in the preceding example to think of the <code class="literal">Person</code> object as a contract or an interface. We then bind that contract to each object in the collection using the <code class="literal">create()</code> function. Now, each of these objects in the collection has a <code class="literal">name()</code> method, and we prove this by generating an array of names using the <code class="literal">invoke()</code> function that will invoke the given method name for each item in the collection.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Cloning objects</h2></div></div></div><p>Creating the same<a id="id181" class="indexterm"/> object instance over and over again can lead to repetitive code. Especially, if we're using the object literal syntax. An alternative is to extend a new object with the new properties, but that can be problematic if we're trying to duplicate something that's not a plain object. Lo-Dash has a <code class="literal">clone()</code> function<a id="id182" class="indexterm"/> that's versatile enough to make a copy of just about anything, including deeply-nested objects. This versatility comes at a performance cost, so use it wisely. An example of using the <code class="literal">clone()</code> function is as follows:</p><div><pre class="programlisting">function Person(first, last) {
    this.first = first;
    this.last = last;
}

var object1 = { 
        first: 'Laura',
        last: 'Gray'
    },  
    object2 = new Person('Bruce', 'Price'),
    clone1 = _.clone(object1),
    clone2 = _.clone(object2);

clone1.first === 'Laura';
// → true

clone2.first === 'Bruce' &amp;&amp; clone2 instanceof Person;
// → false</pre></div><p>The <code class="literal">object1</code> variable holds a<a id="id183" class="indexterm"/> plain object, while the <code class="literal">object2</code> variable holds an instance of the <code class="literal">Person</code> class, but they're essentially the same things. They both have <code class="literal">first</code> and <code class="literal">last</code> properties. The <code class="literal">clone1</code> and <code class="literal">clone2</code> variables hold their respective clones. What's interesting is the assertions we perform next. The first one passes because we're just verifying that the string in the original <code class="literal">name</code> property still exists in the cloned property. The second assertion fails, and not because the <code class="literal">first</code> property of the clone doesn't equal <code class="literal">Bruce</code>. It fails because <code class="literal">clone2</code> isn't an instance of <code class="literal">Person</code>. Instead, it's an instance of <code class="literal">Object</code> because the <code class="literal">clone()</code> function doesn't take the necessary steps of setting up the appropriate constructor property, and so on.</p><p>Other than the cloned object not being an instance of the <code class="literal">Person</code> class, it's pretty much the same object and attribute access, and so on. It should still work as it would on a plain object. The focus of <code class="literal">clone()</code> is really about duplicating a plain object so as to break the reference to the original. Then it can be manipulated without touching the source.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>This chapter introduced us to how we can use Lo-Dash functions to perform sophisticated object interactions. We started with the utilities that made reasoning about the JavaScript type system a little less painful. Next, we saw how object properties can be accessed and assigned in various contexts. Iterating through object properties was the next topic, and there's an abundance of tools at your disposal in Lo-Dash here. In particular, iterating over only an object's keys or values would require a lot of boilerplate code, were it not for the Lo-Dash functions that take care of this for us. Transformations take place when we pass an object to a Lo-Dash function and it yields a new structure. Like when we're looking for a collection of key-value pairs. Picking or omitting properties is a really straightforward activity too. We wrapped up the chapter by taking a look at object creation and cloning facilities. These help us when we need to bend the rules a little to meet the needs of our application.</p><p>Through the first two chapters, you've probably noticed that there are a lot of functions being defined and used. That's no accident—JavaScript embraces the function as a first-class citizen, and Lo-Dash is no different. Functions are the focus of the next chapter.</p></div></body></html>