<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Server-side Highcharts</h1></div></div></div><p>The first edition of <em>Learning Highcharts</em> covered a number of approaches to run Highcharts on the server side. Since then, there has been significant development in this area. It turns out that Highcharts adopts PhantomJS (the headless webkit) for the server solution and PhantomJS/Batik for the server implementation in Java. We will also explore how we can create our own Highcharts server process using PhantomJS and how to use the official server-side script released by Highcharts.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why we want to run Highcharts on the server side</li><li class="listitem" style="list-style-type: disc">Why PhantomJS and Batik are adopted by Highcharts</li><li class="listitem" style="list-style-type: disc">The basics of PhantomJS and Batik</li><li class="listitem" style="list-style-type: disc">Creating our own PhantomJS script to export charts</li><li class="listitem" style="list-style-type: disc">How to use the Highcharts server-side script in both command-line and server modes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec89"/>Running Highcharts on the server side</h1></div></div></div><p>The main reason for running <a id="id994" class="indexterm"/>Highcharts on the server side is to allow the client-based<a id="id995" class="indexterm"/> graphing application to be automated and accessible on the server side. In some cases, it is desirable to produce graphs at the frontend as well as delivering automated reports with graphs at the backend. For the sake of consistency and development costs, we would like to produce the same style of graphs at both ends. Here are other scenarios where we may want to generate graphs on the server side:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application is required to run a scheduled task on the server side. It generates a regular summary report with graphs (for example, the Service Level Agreement report) and automatically e-mails the report to clients or users with a managerial role.</li><li class="listitem" style="list-style-type: disc">The nature of the data means it requires a long time to compute for a graph. Instead, users send the parameters over to the server to generate a graph. Once it is finished, the chart setup is saved, then the users are notified to see a live Highcharts chart from the precomputed JSON setup.</li><li class="listitem" style="list-style-type: disc">The application involves a vast amount of recurring data that is only kept for a certain period, such as data trend graphs that are automatically produced and stored in an image format for your records.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec90"/>Highcharts on the server side</h1></div></div></div><p>In the first edition of this book, we<a id="id996" class="indexterm"/> mentioned a number of technologies that can be used to <a id="id997" class="indexterm"/>produce chart images purely on the server side. Within those technologies, PhantomJS is the most prominent. In a nutshell, it is a standalone program that is capable of running JavaScript on the server. Besides this, it is easy to use, has minimum setup, and is programmable and robust.</p><p>The alternative approach was to use Rhino, a Java implementation of the JavaScript engine, to run JavaScript on the server side so that Highcharts can be run on the server side to export a chart into an SVG file. Then, the SVG file is forwarded to Batik, a generic Java-based SVG toolkit, to produce an image file from SVG.</p><p>Since then, Highcharts have extensively experimented with different approaches and concluded that incorporating PhantomJS is the solution moving forward. There are a number of reasons for this decision. First, Rhino has rendering problems compared to PhantomJS, which makes PhantomJS a better choice. Moreover, PhantomJS can also export images, although it has scalability issues in rendering charts when the number of data points increases to around 1,500. ImageMagick, the image converter, was also considered, but it also has specific performance and reliability issues. For details of the findings, please <a id="id998" class="indexterm"/>see <a class="ulink" href="http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage">http://www.highcharts.com/component/content/article/2-articles/news/52-serverside-generated-charts#phantom_usage</a>.</p><p>For a server-side solution required to implement in Java, Batik is a more natural choice for formatting SVG, whereas PhantomJS is launched to run Highcharts for SVG content. As for a non-Java approach, PhantomJS itself is good enough to drive the whole server-side solution.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec108"/>Batik – an SVG toolkit</h2></div></div></div><p>Batik <a id="id999" class="indexterm"/>is part of the<a id="id1000" class="indexterm"/> Apache foundation <a id="id1001" class="indexterm"/>projects, <a class="ulink" href="http://xmlgraphics.apache.org/batik/">http://xmlgraphics.apache.org/batik/</a>. Its purpose is to provide a web service to view, generate, and transform SVG data. For instance, Highcharts uses this third-party software to convert SVG data into an image format. When the user clicks on the export button, Highcharts internally forwards the chart's SVG data and the user-selected image format request to Batik.</p><p>Then, Batik receives the SVG data and transforms the data into the desired image format. The following diagram summarizes how a normal Highcharts chart uses the export service with Batik:</p><div><img src="img/7451OS_14_01.jpg" alt="Batik – an SVG toolkit"/></div><p>To install Batik, download the latest distribution<a id="id1002" class="indexterm"/> from <a class="ulink" href="http://xmlgraphics.apache.org/batik/download.html#binary">http://xmlgraphics.apache.org/batik/download.html#binary</a> and follow the installation instructions. As for <a id="id1003" class="indexterm"/>Ubuntu, simply do:</p><div><pre class="programlisting">
<strong>apt-get install libbatik-java</strong>
</pre></div><p>Out of the entire Batik package, we only need the image converter component, which is the <code class="literal">batik-rasterizer.jar</code> file. To transcode from an SVG to a PNG file, we can use the following command:</p><div><pre class="programlisting">
<strong>java -jar batik-rasterizer.jar chart.svg</strong>
</pre></div><p>The preceding command will convert <code class="literal">chart.svg</code> and create <code class="literal">chart.png</code> in the same directory.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec109"/>PhantomJS (headless webkit)</h2></div></div></div><p>A webkit is <a id="id1004" class="indexterm"/>basically the <a id="id1005" class="indexterm"/>backend engine that drives browsers such as Safari and Google Chrome. It implements almost everything in HTML5 except the browser's user interface. PhantomJS (found at <a class="ulink" href="http://phantomjs.org/">http://phantomjs.org/</a>, created <a id="id1006" class="indexterm"/>and maintained by Ariya Hidayat) is a headless webkit, which means that the webkit engine can be run as a standalone program. It is useful in a number of ways, and one of them is server-side SVG rendering.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec110"/>Creating a simple PhantomJS script</h2></div></div></div><p>Although Highcharts released a <a id="id1007" class="indexterm"/>PhantomJS script to export charts on the server side, it is worth understanding the concept of PhantomJS and how it works. Suppose we already have a web server and PhantomJS installed and running. To run an HTML page on PhantomJS from a command line, run the following command:</p><div><pre class="programlisting">
<strong>phantomjs loadPage.js</strong>
</pre></div><p>The <code class="literal">loadPage.js</code> page can be as simple as this:</p><div><pre class="programlisting">var page = require('webpage').create();

page.onError = function(msg, trace) {
    console.error(msg);
    phantom.exit(1);
};

page.onConsoleMessage = function(msg) {
    console.log(msg);
};

page.open('http://localhost/mychart.html', function(status) {
    if (status === 'success') {
        console.log('page loaded');
        phantom.exit();
    }
});</pre></div><p>Inside the PhantomJS process, it first loads the <code class="literal">webpage</code> module and creates a <code class="literal">page</code> object.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>This is only a short example for illustration. For a proper way of handling error messages, please refer to the PhantomJS API documentation.</p></div></div><p>The <code class="literal">page.onError</code> and <code class="literal">page.onConsoleMessage</code> methods redirect the page's error and output messages to the terminal output via <code class="literal">console.log</code>. Note that <code class="literal">console.log</code> in this instance is referring to our terminal console. If <code class="literal">console.log</code> is called inside a page, it will only stay within the page object life cycle and we will never see those messages unless <code class="literal">page.onConsoleMessage</code> is defined to redirect them.</p><p>The preceding script only opens the HTML page into a <code class="literal">webpage</code> object and then terminates, which is not particularly useful.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec49"/>Creating our own server-side Highcharts script</h3></div></div></div><p>Let's use PhantomJS<a id="id1008" class="indexterm"/> in a slightly more advanced way. In PhantomJS, we don't need to rely on a web server to serve a page. Instead, we load a Highcharts page file locally and include the series data from another JSON file. Then, we render the result into an image file. So here is how we will run the server-side script on a command line:</p><div><pre class="programlisting">
<strong>phantomjs renderChart.js chart.html data.json chart.png</strong>
</pre></div><p>The <code class="literal">chart.html</code> page is just a simple Highcharts page that we would normally create. In this exercise, we will leave the series data as a variable, <code class="literal">seriesData</code>. The following shows how we structure the <code class="literal">chart.html</code> page:</p><div><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
     &lt;meta&gt; ....
     &lt;script src='..../jquery.min.js'&gt;&lt;/script&gt;
     &lt;script src='..../Highcharts.js'&gt;&lt;/script&gt;
     &lt;script type='text/javascript'&gt;
     $(function () {
     $(document).ready(function() {
        chart = new Highcharts.Chart({
            chart: {
                ....       
            },
            plotOptions: {
                ....  
            },
            ....,
            series: [{
                   name: 'Nasdaq',
                   data: seriesData
            }]
        });
     });
  });
  &lt;/script&gt;
  &lt;/head&gt;        
  &lt;body&gt;
   &lt;div id="container" &gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Then, <code class="literal">data.json</code> is just a simple JSON file containing the array of <em>x</em> and <em>y</em> series data. Here is some of the content:</p><div><pre class="programlisting">[[1336728600000,2606.01],[1336730400000,2622.08],
 [1336732200000,2636.03],[1336734000000,2637.78],
 [1336735800000,2639.15],[1336737600000,2637.09],
 ....</pre></div><p>For the PhantomJS <a id="id1009" class="indexterm"/>file, <code class="literal">renderChart.js</code>, it is surprising how little extra code (highlighted in bold) we need to add to achieve the result:</p><div><pre class="programlisting">var page = require('webpage').create(),
<strong>    system = require('system'),</strong>
<strong>    fs = require('fs');</strong>

// Convert temporary file with series data – data.json
<strong>var jsonData = fs.read(system.args[2]);</strong>
<strong>fs.write('/tmp/data.js', 'var seriesData = ' + jsonData + ';');</strong>

page.onError = function(msg, trace) {
    console.error(msg);
    phantom.exit(1);
}

page.onConsoleMessage = function(msg) {
    console.log(msg);
};

// initializes the seriesData variable before loading the script
<strong>page.onInitialized = function() {</strong>
<strong>     page.injectJs('/tmp/data.js');</strong>
<strong>};</strong>

// load chart.html
page.open(system.args[1], function(status) {
    if (status === 'success') {
        // output to chart.png
        page.render(system.args[3]);
        phantom.exit();
    }
});</pre></div><p>We first load the <code class="literal">system</code> and <code class="literal">fs</code> modules, which are used in this example to select command-line arguments and process file I/O on the JSON file. The script basically reads (<code class="literal">fs.read</code>) the content of the JSON file and converts the content into a JavaScript expression and saves (<code class="literal">fs.write</code>) it in a file. Then, we define the <code class="literal">onInitialized</code> event handler for the page object that is triggered before the URL is loaded. So, we insert (<code class="literal">injectJs</code>) the JavaScript expression of <code class="literal">seriesData</code> before the page object loads the <code class="literal">chart.html</code> page. Once the page is loaded, we export (<code class="literal">page.render</code>) the page content into an image file.</p><p>Notice that the resulting image file is not quite correct in that the line series is actually missing. However, if we observe the image more carefully, actually the line has just started being drawn (see the following screenshot):</p><div><img src="img/7451OS_14_02.jpg" alt="Creating our own server-side Highcharts script"/></div><p>This is because of the<a id="id1010" class="indexterm"/> chart default animation settings. After we turn the initial animation off by setting the <code class="literal">plotOptions.series.animation</code> option to <code class="literal">false</code>, the line series appears:</p><div><img src="img/7451OS_14_03.jpg" alt="Creating our own server-side Highcharts script"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec91"/>Running the Highcharts server script</h1></div></div></div><p>So far, our script example is <a id="id1011" class="indexterm"/>lacking in features and error checking functionality, and is far from perfect. Nonetheless, we can see how easy it is to create our own server-side Highcharts process to produce images. In this section, you will learn how to use the official server-side script by Highcharts, which has more features and can be used in different scenarios.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec111"/>Server script usage</h2></div></div></div><p>Since version 3, Highcharts <a id="id1012" class="indexterm"/>is packaged with server-side script, <code class="literal">highcharts_convert.js</code>, which is located in the <code class="literal">exporting-server/phantomjs</code> directory. The script can be run as either a command line or as a listening server.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>For a full description of usage and <a id="id1013" class="indexterm"/>parameters, refer to <a class="ulink" href="https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs">https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec50"/>Running the script as a standalone command</h3></div></div></div><p>Here is a <a id="id1014" class="indexterm"/>typical<a id="id1015" class="indexterm"/> command-line format for <code class="literal">highcharts_convert.js</code>:</p><div><pre class="programlisting">
<strong>phantomjs highcharts-convert.js -infile file </strong>
<strong>  -outfile chart1.png | -type ( png | jpg | pdf | svg ) -tmpdir dir</strong>
<strong>  [-scale num | -width pixels ] [ -constr (Highcharts | Highstocks) ]</strong>
<strong>  [-callback script.js ]</strong>
</pre></div><p>The following is a list of parameters used in the preceding command:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-infile</code>: This is the<a id="id1016" class="indexterm"/> input source for the script, which can be either a chart configuration in the JSON format (general usage) or an SVG file. The server script automatically detects the content type, and processes and exports the chart/content in the desired format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-outfile</code>, <code class="literal">-type</code>, <code class="literal">-tmpdir</code>: The two<a id="id1017" class="indexterm"/> ways to <a id="id1018" class="indexterm"/>specify the output format are<a id="id1019" class="indexterm"/> by <code class="literal">-type</code> or <code class="literal">-outfile</code>. With the <code class="literal">-outfile</code> parameter, the script will derive the image format from the extension name. Alternatively, <code class="literal">-type</code>, for example, type <code class="literal">png</code>, formats into a PNG image file and combines with <code class="literal">-tmpdir</code> to save the output file in a specific location.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-scale</code>, <code class="literal">-width</code>: There are<a id="id1020" class="indexterm"/> two optional parameters to <a id="id1021" class="indexterm"/>adjust the output image size, by <code class="literal">-scale</code> or by <code class="literal">-width</code>. As the name suggests, one is to adjust the size by scaling and the other is by the absolute size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-constr</code>: The <code class="literal">-constr</code> parameter is to<a id="id1022" class="indexterm"/> instruct the script whether to export the chart as a Highcharts or Highstock chart (another product for financial charts).</li><li class="listitem" style="list-style-type: disc"><code class="literal">-callback</code>: The <code class="literal">-callback</code> parameter is <a id="id1023" class="indexterm"/>to execute additional JavaScript code on the chart once it is loaded and before the chart is exported.</li></ul></div><p>Let's apply the previous chart configuration file into this command line. Furthermore, we are going to superimpose a watermark, <code class="literal">SAMPLE</code>, on top of the chart with the callback argument.</p><p>First, we save the whole chart configuration object into a file including the series data:</p><div><pre class="programlisting">            { chart: {
                renderTo: 'container',
                height: 250,
                spacingRight: 30,
                animation: false
              },
              . . . .
            }</pre></div><p>Then, we create a<a id="id1024" class="indexterm"/> callback script with the <a id="id1025" class="indexterm"/>following code to add the watermark, <code class="literal">watermark.js</code>:</p><div><pre class="programlisting">function(chart) {
    chart.renderer.text('SAMPLE', 220, 200).
          attr({
              rotation: -30
          }).
          css({
              color: '#D0D0D0',
              fontSize: '50px',
              fontWeight: 'bold',
              opacity: 0.8
          }).
          add();
}</pre></div><p>Finally, we run the following command:</p><div><pre class="programlisting">
<strong>phantomjs highcharts-convert.js -infile options.json -outfile chart.png -width 550 -callback watermark.js</strong>
</pre></div><p>The command generates the output as it runs:</p><div><pre class="programlisting">
<strong>Highcharts.options.parsed</strong>
<strong>Highcharts.cb.parsed</strong>
<strong>Highcharts.customCode.parsed</strong>
<strong>/tmp/chart.png</strong>
</pre></div><p>It also produces the following screenshot:</p><div><img src="img/7451OS_14_04.jpg" alt="Running the script as a standalone command"/></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec51"/>Running the script as a listening server</h3></div></div></div><p>To run the script as a server<a id="id1026" class="indexterm"/> listening for HTTP requests, we<a id="id1027" class="indexterm"/> launch the script with the following command:</p><div><pre class="programlisting">
<strong>phantomjs highcharts-convert.js -host address -port num</strong>
<strong>               -type ( png | svg | jpg | pdf )</strong>
</pre></div><p>Let's start a Highcharts export server with the following command:</p><div><pre class="programlisting">
<strong>phantomjs highcharts-convert.js -host 127.0.0.1 -port 9413 -type png</strong>
</pre></div><p>This starts a server listening only to local incoming connections on port 9413, and the following message outputs to the screen:</p><div><pre class="programlisting">
<strong>OK, PhantomJS is ready.</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec52"/>Passing options to the listening server</h3></div></div></div><p>Once the server process is ready, we<a id="id1028" class="indexterm"/> can start sending POST requests embedded within the Highcharts configuration data. The Highcharts options used inside the request are the same ones we used in the command line. Let's reuse the configuration from the last exercise and pack them into a POST request.</p><p>First, we need to "stringify" the whole chart configuration as a value for the <code class="literal">infile</code> option. Next, we treat the callback method in the same manner. Then, we put the rest of the options into one JSON format and save it in a file called <code class="literal">post.json</code>:</p><div><pre class="programlisting">{ "infile" : " { chart: { .... }, series { .... } } " , 
  "callback" : "function(chart) { .... } ",
  "scale" : 1.2
}</pre></div><p>The next task is to package this data into a POST query. Since the purpose of this chapter is the server-side process, we should operate in a command-line style. Hence, we use the <code class="literal">curl</code> utility to create a POST request. The following command can do the job:</p><div><pre class="programlisting">
<strong>curl -X POST -H "Content-Type: application/json" -d @post.json http://localhost:9413/ | base64 -d &gt; /tmp/chart.png</strong>
</pre></div><p>The preceding <code class="literal">curl</code> command is to create a POST request with the JSON content type. The <code class="literal">-d @</code> argument notifies<a id="id1029" class="indexterm"/> the <code class="literal">curl</code> command about which file contains the POST data. Since HTTP is an ASCII protocol, the response of the result binary image data is returned in base-64 encoding. Therefore, we need to pipe the POST response data to another utility, base64, to decode the data and write it to a file.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec92"/>Summary</h1></div></div></div><p>In this chapter, we described the purpose of running Highcharts on the server side and you learned which technology Highcharts has opted to use on a server. You learned the basics of PhantomJS and the role of Batik. You extended your understanding of PhantomJS to create your own server-side script for Highcharts. Besides that, we experimented with how to run the official PhantomJS script released by Highcharts in both single command-line and server mode.</p><p>In the next chapter, we will take a glimpse at which online services Highcharts offer and explore some of the Highcharts plugins.</p></div></body></html>