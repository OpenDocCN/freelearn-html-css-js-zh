<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor079"/>6</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Editing Form Data</h1>
<p>The preceding two chapters showed how to build an HTML form to add new birthdays into the <em class="italic">Birthdays</em> application and how to add server-side validation for that form. This chapter wraps up the form implementation by adding the ability to edit existing <span class="No-Break">birthday information.</span></p>
<p>Doing this will involve adding Svelte component state to track whether the edit form is in listing or <span class="No-Break">editing mode.</span></p>
<p>Up to this point, the <a id="_idIndexMarker169"/>server has stored data in a plain JavaScript array. We have been using TDD to force the simplest implementation that could possibly work. This chapter brings in a more complex implementation that uses a <strong class="source-inline">Map</strong> object, which we’ll do as part of the <em class="italic">Refactor</em> step as part of the <span class="No-Break"><em class="italic">Red-Green-Refactor</em></span><span class="No-Break"> workflow.</span></p>
<p>This chapter will cover the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Planning the <span class="No-Break">path ahead</span></li>
<li>Adding a Playwright test for editing <span class="No-Break">form data</span></li>
<li>Evolving the repository to allow <span class="No-Break">ID lookup</span></li>
<li>Updating the form action to <span class="No-Break">handle edits</span></li>
<li>Updating the list page with a new <span class="No-Break">edit mode</span></li>
</ul>
<p>By the end of the chapter, you’ll have seen how TDD is used to evolve system design when you increase the functionality of a <span class="No-Break">software system.</span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Planning the path ahead</h1>
<p>Before we get started with the code, let’s do a little upfront design so we have a rough course <span class="No-Break">of action.</span></p>
<p>The overall goal <a id="_idIndexMarker170"/>is to allow every birthday entry in the system to be modified. We’d like to reuse the existing <strong class="source-inline">BirthdayForm</strong> component so that it can be used for <span class="No-Break">this purpose.</span></p>
<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> shows a diagram of how we could update the system to support this new feature. Each list item will have an <strong class="bold">Edit</strong> button that, when clicked, opens up a form for editing. This form replaces the text in the list item with a form. In terms of our components, the <strong class="source-inline">Birthday</strong> component will be switched to a <span class="No-Break"><strong class="source-inline">BirthdayForm</strong></span><span class="No-Break"> component:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 6.1 – A mockup of editing birthdays" height="491" src="image/Figure_6.1_B19611.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A mockup of editing birthdays</p>
<p>While in this edit mode, it makes sense to hide the form for adding a birthday and also prohibit editing other birthdays, just to ensure that there’s only ever one active form <span class="No-Break">on display.</span></p>
<p>There’s one question remaining, and that’s how do we let the backend form action know that we’re editing a birthday and not <span class="No-Break">adding one?</span></p>
<p>A straightforward approach to doing this is to add a special <strong class="source-inline">id</strong> property to each birthday data object. This is a unique value that the server can use to identify each individual object. The <strong class="source-inline">id</strong> will never change and cannot be edited, whereas the other data items can be changed. And the user never needs to see the <strong class="source-inline">id</strong> value. Its purpose is simply to enable modification of existing <span class="No-Break">data items.</span></p>
<p>We can use the <a id="_idIndexMarker171"/>standard JavaScript <strong class="source-inline">randomUUID</strong> function to give us a unique string to create an <strong class="source-inline">id</strong> for <span class="No-Break">each birthday.</span></p>
<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em> shows the various SvelteKit components and functions, together with the important bits of data that are needed to make this work, including a new editing state variable in the page component and the <strong class="source-inline">id</strong> field used to pick out the birthday <span class="No-Break">for editing:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="Figure 6.2 – Using the component state and a lookup table to implement edit behavior" height="648" src="image/Figure_6.2_B19611.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Using the component state and a lookup table to implement edit behavior</p>
<p>Before continuing, it’s worth noting that our current birthday repository holds its <strong class="source-inline">birthday</strong> objects in a plain JavaScript array. This is fine for listing and adding new items, but it’s not ideal for replacing existing items without updated versions. A better data structure is a <strong class="source-inline">Map</strong> object, which allows us to easily update items based on a key. Since we’ve already realized we need a fixed <strong class="source-inline">id</strong> value to represent each birthday, we already have a good choice for <span class="No-Break">a key.</span></p>
<p>That covers our up front design. With a plan in place, it’s time for an <span class="No-Break">end-to-end test.</span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Adding a Playwright test for editing form data</h1>
<p>In this section, we’ll build the latest Playwright test for our system. Because this test is quite long, we’ll <a id="_idIndexMarker172"/>build it bit by bit. In <a href="B19611_07.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Tidying up Test Suites</em>, we’ll look at how this test script can <span class="No-Break">be shortened.</span></p>
<p>Let’s <a id="_idIndexMarker173"/>follow these steps to create <span class="No-Break">the test:</span></p>
<ol>
<li>In <strong class="source-inline">tests/birthday.test.js</strong>, begin the test with the following code, which loads the application, the <strong class="source-inline">/birthdays</strong> endpoint, and then completes the form to add a new birthday for <strong class="source-inline">Ares</strong>. We have to be careful to find the button specifically with the <strong class="bold">Save</strong> name. That’s because we’ll now have multiple buttons on the page: one named <strong class="bold">Save</strong>, and then multiple buttons <span class="No-Break">named </span><span class="No-Break"><strong class="bold">Edit</strong></span><span class="No-Break">:</span><pre class="console">
test('edits a birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  // add a birthday using the form
  await page.getByLabel('Name').fill('Ares');
  await page
    .getByLabel('Date of birth')
    .fill('1985-01-01');
  await page
    .getByRole('button', { name: 'Save' })
    .click();
});</pre></li>
<li>Next, add the following command to find the <strong class="bold">Edit</strong> button for <strong class="source-inline">Ares</strong>. This uses the special <strong class="source-inline">getByRole('listitem').filter(...)</strong> chain command, which finds an element with the <strong class="source-inline">listitem</strong> role (meaning the <strong class="source-inline">li</strong> elements) that also contains the <strong class="source-inline">'Ares'</strong> text. We then find the <strong class="bold">Edit</strong> button within that list <span class="No-Break">item element:</span><pre class="console">
await page
  .getByRole('listitem')
  .filter({ hasText: 'Ares' })
  .getByRole('button', { name: 'Edit' })
  .click();</pre></li>
<li>We now <a id="_idIndexMarker174"/>assume that a new form <a id="_idIndexMarker175"/>has appeared for editing the birthday information for <strong class="source-inline">Ares</strong>. Continue the test with the following code, which replaces the <strong class="source-inline">Date of birth</strong> field with another value, and then click the <span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break"> button:</span><pre class="console">
await page
  .getByLabel('Date of birth')
  .fill('1995-01-01');
await page
  .getByRole('button', { name: 'Save' })
  .click();</pre></li>
<li>Finish off the new test with a couple of expectations. We check that the original date of birth no longer appears and that the new date of birth <span class="No-Break">does appear:</span><pre class="console">
// check that the original text doesn't appear
await expect(
  page
    .getByRole('listitem')
    .filter({ hasText: 'Ares' })
).not.toContainText('1985-01-01');
// check that the new text does appear
await expect(
  page
    .getByRole('listitem')
    .filter({ hasText: 'Ares' })
).toContainText('1995-01-01');</pre></li>
<li>Finally, the <a id="_idIndexMarker176"/>previous Playwright <a id="_idIndexMarker177"/>tests need to be modified. Each test assumed that there was just one button on the page, the <strong class="bold">Save</strong> button. But now we’re going to have <strong class="bold">Edit</strong> buttons too, so we must change the locator calls to <strong class="source-inline">find a button</strong> and change them to be <strong class="source-inline">find a button named Save</strong>. Find all the lines that look <span class="No-Break">like this:</span><pre class="console">
await page.getByRole('button').click();</pre></li>
</ol>
<p>And update them to look like this:</p>
<pre class="console">
await page.getByRole('button'<strong class="bold">,</strong>
<strong class="bold">  </strong><strong class="bold">{ name: 'Save' }</strong>
).click();</pre>
<p>That completes the new test. You can see we’ve already made some design decisions about the new <strong class="bold">Edit</strong> buttons and how <span class="No-Break">they operate.</span></p>
<p>If you run tests now with the <strong class="source-inline">npm test</strong> command, you’ll see the new test timeout waiting for the <strong class="bold">Edit</strong> button <span class="No-Break">to appear:</span></p>
<pre class="console">
Test timeout of 30000ms exceeded.
...
waiting for getByRole('listitem').filter({ hasText: 'Ares' }).getByRole('button', { name: 'Edit' })</pre>
<p>In the next section, we’ll translate that into decisions about the <span class="No-Break">application code.</span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Evolving the repository to allow ID lookup</h1>
<p>It’s now <a id="_idIndexMarker178"/>time to update our birthday data items to include an <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> field.</span></p>
<p>Let’s start with a new test to check that <strong class="source-inline">id</strong> <span class="No-Break">is present.</span></p>
<ol>
<li>Start by adding this test into the <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong> file, within the <strong class="source-inline">describe</strong> block named <strong class="source-inline">/birthdays - default action</strong>. It checks that each birthday has a unique <strong class="source-inline">id</strong> field associated <span class="No-Break">with it:</span><pre class="console">
it('saves unique ids onto each new birthday', async () =&gt; {
  const request = createFormDataRequest({
    name: 'Zeus',
    dob: '2009-02-02'
  });
  await actions.default({ request });
  await actions.default({ request });
  expect(birthdayRepository.getAll()[0].id).not
  .toEqual(birthdayRepository.getAll()[1].id);
});</pre></li>
<li>Make that pass in <strong class="source-inline">src/lib/server/birthdayRepository.js</strong>. Start by adding the <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span><pre class="console">
import { randomUUID } from 'crypto';</pre></li>
<li>Then update the definition of the <span class="No-Break"><strong class="source-inline">addNew</strong></span><span class="No-Break"> function:</span><pre class="console">
export const addNew = (item) =&gt;
  db.push(<strong class="bold">{ ...item, id: randomUUID() }</strong>);</pre></li>
<li>If you run tests now, you’ll see that the test passes, but we have a new failure in a different <a id="_idIndexMarker179"/>part of the test suite. The <strong class="source-inline">returns a fixture of two items</strong> test is now erroring because of these new <strong class="source-inline">id</strong> fields. We can fix this by using the <strong class="source-inline">expect.objectContaining</strong> constraining function, which is useful for for saying, <em class="italic">I don’t care about anything except these properties</em>. It’s a useful tool for reducing the brittleness of tests. Update that test now to read as shown in the following <span class="No-Break">code block:</span><pre class="console">
it('returns a fixture of two items', () =&gt; {
  const result = load();
  expect(result.birthdays).toEqual([
    <strong class="bold">expect.objectContaining(</strong>{
      name: 'Hercules',
      dob: '1994-02-02'
    }<strong class="bold">)</strong>,
    <strong class="bold">expect.objectContaining(</strong>{
      name: 'Athena',
      dob: '1989-01-01'
    }<strong class="bold">)</strong>
  ]);
});</pre></li>
<li>Now add this next test, which checks that if we send in a request with an <strong class="source-inline">id</strong> property, then we should choose to update the item matching that <strong class="source-inline">id</strong>, rather than adding <a id="_idIndexMarker180"/>a new birthday. Notice the use of the <strong class="source-inline">storedId</strong> function, which pulls out the <strong class="source-inline">id</strong> property that was saved into <span class="No-Break">the repository:</span><pre class="console">
const storedId = () =&gt;
  birthdayRepository.getAll()[0].id;
it('updates an entry that shares the same id', async () =&gt; {
  let request = createFormDataRequest({
    name: 'Zeus',
    dob: '2009-02-02'
  });
  await actions.default({ request });
  request = createFormDataRequest({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
  await actions.default({ request });
  expect(birthdayRepository.getAll()).toHaveLength(1);
  expect(birthdayRepository.getAll()).toContainEqual({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre></li>
<li>It’s now a great time to refactor our <strong class="source-inline">db</strong> value to be a <strong class="source-inline">Map</strong> object rather than an array, as we discussed in the previous section. Doing that refactor will make this new test <a id="_idIndexMarker181"/>straightforward. But we don’t <em class="italic">refactor</em> on <em class="italic">Red</em>. So, begin by skipping the test you just wrote and checking the test suite <span class="No-Break">is </span><span class="No-Break"><em class="italic">Green</em></span><span class="No-Break">.</span><pre class="console">
it<strong class="bold">.skip</strong>('updates an entry that shares the same id', async () =&gt; {
  ...
});</pre></li>
<li>In <strong class="source-inline">src/lib/server/birthdayRepository.js</strong>, replace <strong class="source-inline">db</strong>, <strong class="source-inline">addNew</strong>, <strong class="source-inline">getAll</strong>, and <strong class="source-inline">clear</strong> with this implementation that uses the <span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break"> object:</span><pre class="console">
<strong class="bold">const db = new Map()</strong>;
export const addNew = (item) =&gt; {
  <strong class="bold">const id = randomUUID();</strong>
  <strong class="bold">db.set(id, { ...item, id });</strong>
};
export const getAll = () =&gt; Array.from(<strong class="bold">db.values()</strong>);
export const clear = () =&gt; <strong class="bold">db.clear()</strong>;</pre></li>
<li>Run your tests after this change and make sure they are <span class="No-Break">still </span><span class="No-Break"><em class="italic">Green</em></span><span class="No-Break">.</span></li>
</ol>
<p class="callout-heading">Refactoring with confidence</p>
<p class="callout">Notice how the presence of your unit tests removes any fear of change when you completely replace the internal data structure. The tests encourage you to make whatever change you need without worrying about unintentional changes <span class="No-Break">in behavior.</span></p>
<p>All the tests should pass – <span class="No-Break">fantastic!</span></p>
<p>This section <a id="_idIndexMarker182"/>has shown you another example of how we can use TDD to delay complex designs until the point that our unit tests force us. You’ve seen how we can migrate an important variable from an array to a <span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break"> object.</span></p>
<p>Now let’s get on with building the <span class="No-Break">edit feature.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Updating the form action to handle edits</h1>
<p>In this section, we’ll continue with updating the repository to handle updating birthdays in addition <a id="_idIndexMarker183"/>to adding new ones. We’ll tackle this in three parts: first, replacing items in the <strong class="source-inline">db</strong> field, second, guarding against invalid <strong class="source-inline">id</strong> values, and third, ensuring that <strong class="source-inline">id</strong> values are passed back in validation errors so that the same birthday can be corrected by <span class="No-Break">the user.</span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Replacing items in the repository</h2>
<p>Let’s get <a id="_idIndexMarker184"/>started with the test you wrote in the <span class="No-Break">previous section:</span></p>
<ol>
<li>Un-skip the last test you wrote in the <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong> file. Make sure to run the tests and watch it fail, ensuring you’re <span class="No-Break">on </span><span class="No-Break"><em class="italic">Red</em></span><span class="No-Break">:</span><pre class="console">
it('updates an entry that shares the same id', async () =&gt; {
  ...
});</pre></li>
<li>To make that test pass, start by adding a <strong class="source-inline">replace</strong> function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">src/lib/server/birthdayRepository.js</strong></span><span class="No-Break">:</span><pre class="console">
export const replace = (id, item) =&gt;
  db.set(id, { ...item, id });</pre></li>
<li>Then, import <a id="_idIndexMarker185"/>that new function <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.server.js</strong></span><span class="No-Break">:</span><pre class="console">
import {
  addNew,
  getAll,
<strong class="bold">  replace</strong>
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>Update the <strong class="source-inline">actions</strong> constant, first by pulling out <strong class="source-inline">id</strong> from the request, and then using that <strong class="source-inline">id</strong> value to switch behavior. If <strong class="source-inline">id</strong> is present, then call the <strong class="source-inline">replace</strong> function; otherwise, call the <span class="No-Break"><strong class="source-inline">addNew</strong></span><span class="No-Break"> function:</span><pre class="console">
export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
<strong class="bold">    const id = data.get('id');</strong>
    ...
<strong class="bold">    if (id) {</strong>
<strong class="bold">      replace(id, {</strong>
<strong class="bold">        name,</strong>
<strong class="bold">        dob</strong>
<strong class="bold">      });</strong>
<strong class="bold">    } else {</strong>
      addNew({ name, dob });
<strong class="bold">    }</strong>
  }
};</pre></li>
<li>Re run <a id="_idIndexMarker186"/>your tests; you should now be <span class="No-Break">on </span><span class="No-Break"><em class="italic">Green</em></span><span class="No-Break">.</span></li>
</ol>
<p>Next, let’s ensure that only valid <strong class="source-inline">id</strong> values <span class="No-Break">are accepted.</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Protecting against unknown identifiers</h2>
<p>The final <a id="_idIndexMarker187"/>validation we need is to make sure that we don’t try to update items in the repository that don’t exist. Let’s begin with a new <span class="No-Break">test context:</span></p>
<ol>
<li>Still in <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong>, add a new nested <strong class="source-inline">describe</strong> block to the <em class="italic">validation errors</em> context, as shown in the following code. I’ve skipped ahead and included <em class="italic">three</em> tests here since we’ve solved these kinds of tests before, and we can feel confident about solving them at the <span class="No-Break">same time:</span><pre class="console">
describe('when the id is unknown', () =&gt; {
  let result;
  beforeEach(async () =&gt; {
    const request = createFormDataRequest({
      id: 'unknown',
      name: 'Hercules',
      dob: '2009-01-02'
    });
    result = await actions.default({
      request
    });
  });
  it('does not save the birthday', () =&gt; {
    expect(load().birthdays).not.toContainEqual(
      expect.objectContaining({
        name: 'Hercules',
        dob: 'unknown'
      })
    );
  });
  it('returns a 422', () =&gt; {
    expect(result.status).toEqual(422);
  });
  it('returns a useful message', () =&gt; {
    expect(result.data.error).toEqual(
      'An unknown ID was provided.'
    );
  });
});</pre></li>
<li>To make this pass, start by adding a new <strong class="source-inline">has</strong> function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">src/lib/server/birthdayRepository.js</strong></span><span class="No-Break">:</span><pre class="console">
export const has = (id) =&gt; db.has(id);</pre></li>
<li>Then <a id="_idIndexMarker188"/>import that <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.server.js</strong></span><span class="No-Break">:</span><pre class="console">
import {
  addNew,
  getAll,
  replace,
<strong class="bold">  has</strong>
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>And finally, make use of it by adding a new <span class="No-Break">guard clause.</span><pre class="console">
if (id &amp;&amp; !has(id)) {
  return fail(422, {
    error: 'An unknown ID was provided.'
  });
}</pre></li>
</ol>
<p>We’re almost done with the form action validations, but there’s one more thing we need <span class="No-Break">to do.</span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Updating return values to include identifiers</h2>
<p>When a validation <a id="_idIndexMarker189"/>error occurs, such as when the <strong class="source-inline">name</strong> field is empty, we need to ensure the <strong class="source-inline">id</strong> form value is included in the return error value. That ensures that back in the web browser, the correct edit form can be reopened to allow the user to correct <span class="No-Break">their edits.</span></p>
<p>Before we launch into the code changes, let’s discuss the strategy. This is how the application code will end <span class="No-Break">up looking:</span></p>
<pre class="source-code">
if (empty(name)) {
  return fail(422, {
<strong class="bold">    </strong><strong class="bold">id,</strong>
    dob,
    error: 'Please provide a name.'
  });
}</pre>
<p>Before you <a id="_idIndexMarker190"/>make that change, however, think about how you’ll test this. We already have a test that checks the contents of the return value, so one option is to go back and edit this test <span class="No-Break">like this:</span></p>
<pre class="source-code">
beforeEach(async () =&gt; {
  const request = createFormDataRequest({
<strong class="bold">    id: '123',</strong>
    name: 'Hercules'
  });
});</pre>
<p>But don’t <span class="No-Break">do this.</span></p>
<p>I find that editing previous tests is generally a bad idea. The reason for that is it can produce tests that end up specifying invalid scenarios that can never happen. The preceding example is indeed an invalid scenario. That’s because there’s no birthday in the system with an <strong class="source-inline">id</strong> value of <strong class="source-inline">123</strong>. To make it valid, we’d need new test setup instructions that create the birthday with the <strong class="source-inline">id </strong>value of <strong class="source-inline">123</strong> to ensure the <strong class="source-inline">id</strong> value <span class="No-Break">is valid.</span></p>
<p>But if we do that, then we have no test for the original scenario of adding a birthday! Instead, let’s create new tests that cover each of the two use cases that can happen: an invalid name or an invalid date of birth when a birthday is <span class="No-Break">being edited.</span></p>
<p class="callout-heading">Scenario-based testing</p>
<p class="callout">When you’re writing unit tests, always make sure your tests cover valid scenarios. If you’re following TDD, that generally means always adding new tests rather than going back to modify <span class="No-Break">existing tests.</span></p>
<p>Let’s begin <a id="_idIndexMarker191"/>by adding a new nested context inside the <strong class="source-inline">validation </strong><span class="No-Break"><strong class="source-inline">errors</strong></span><span class="No-Break"> context:</span></p>
<ol>
<li>Add the following <strong class="source-inline">describe</strong> context with its associated <strong class="source-inline">beforeEach</strong> block, which adds a birthday into <span class="No-Break">the system:</span><pre class="console">
describe('when replacing an item', () =&gt; {
  beforeEach(async () =&gt; {
    let request = createFormDataRequest({
      name: 'Zeus',
      dob: '2009-02-02'
    });
    await actions.default({ request });
  });
});</pre></li>
<li>Now, add the first test into the context. It attempts to edit the created birthday but has an empty name. The expectation checks that the same <strong class="source-inline">id</strong> value is passed back in <span class="No-Break">the response:</span><pre class="console">
it('returns the id when an empty name is provided', async () =&gt; {
  const request = createFormDataRequest({
    id: storedId(),
    name: '',
    dob: '1982-05-01'
  });
  const result = await actions.default({
    request
  });
  expect(result.data).toContain({ id: storedId() });
});</pre></li>
<li>To make <a id="_idIndexMarker192"/>that pass, include the <strong class="source-inline">id</strong> property in the relevant <span class="No-Break">guard clause:</span><pre class="console">
if (empty(name)) {
  return fail(422, {
<strong class="bold">    id,</strong>
    dob,
    error: 'Please provide a name.'
  });
}</pre></li>
<li>Next, add a test for an invalid date <span class="No-Break">of birth:</span><pre class="console">
it('returns the id when an empty date of birth is provided', async () =&gt; {
  const request = createFormDataRequest({
    id: storedId(),
    name: 'Hercules',
    dob: ''
  });
  const result = await actions.default({
    request
  });
  expect(result.data).toContain({ id: storedId() });
});</pre></li>
<li>To make <a id="_idIndexMarker193"/>that pass, update the second guard clause, as <span class="No-Break">shown here:</span><pre class="console">
if (invalidDob(dob)) {
  return fail(422, {
<strong class="bold">    id,</strong>
    name,
    dob,
    error:
      'Please provide a date of birth in the YYYY-MM-DD format.'
  });
}</pre></li>
</ol>
<p>That completes the changes to the <span class="No-Break">form action.</span></p>
<p class="callout-heading">Listening to your tests</p>
<p class="callout">It’s very important to listen to your tests. If they are a slog to write and update, that’s a sign that either the tests can be improved or the application code design can <span class="No-Break">be improved.</span></p>
<p>In <a href="B19611_09.xhtml#_idTextAnchor111"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Extracting Logic Out of the Framework</em>, we’ll move validation into the birthday repository, and this will give us a chance to rethink how these tests <span class="No-Break">are structured.</span></p>
<p>This section has covered a whole bunch of changes: adding repository functionality for replacing items, updating the form action to either add or replace items, adding another guard clause <a id="_idIndexMarker194"/>to protect against invalid replacements, and finally, updating the existing guard clauses to return the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> value.</span></p>
<p>Now it’s time to update the page component to display <strong class="source-inline">BirthdayForm</strong> in <span class="No-Break">edit mode.</span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Updating the list page with a new edit mode</h1>
<p>In this <a id="_idIndexMarker195"/>section, you’ll update the page so that it can <a id="_idIndexMarker196"/>toggle into an edit mode for a given birthday. That relies on having a hidden form field for the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> value.</span></p>
<p class="callout-heading">Testing hidden fields</p>
<p class="callout">Testing Library doesn’t give us an easy way to query the <strong class="source-inline">hidden</strong> input fields because it generally concerns itself with what is visible to the user, and our <strong class="source-inline">id</strong> field is purposefully designed to be an internal <span class="No-Break">system detail.</span></p>
<p class="callout">Fortunately, we can <a id="_idIndexMarker197"/>fall back to the standard <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) Form API to figure <span class="No-Break">this out.</span></p>
<p class="callout">The nature of writing unit tests for frameworks such as SvelteKit means that sometimes you’re checking for internal details <span class="No-Break">like this.</span></p>
<p>Let’s start with a new test in a new nested <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block:</span></p>
<ol>
<li>In the <strong class="source-inline">src/routes/birthdays/BirthdayForm.test.js</strong> file, and within the <strong class="source-inline">BirthdayForm</strong> root in the <strong class="source-inline">describe</strong> block, add this new nested <strong class="source-inline">describe</strong> block <span class="No-Break">and test:</span><pre class="console">
describe('id field', () =&gt; {
  it('contains a hidden field for the id if an id is
  given', () =&gt; {
    render(BirthdayForm, { form: { id: '123' } });
    expect(
      document.forms.birthday.elements.id.value
    ).toEqual('123');
  });
});</pre></li>
<li>To make <a id="_idIndexMarker198"/>that pass, update the <strong class="source-inline">BirthdayForm</strong> component (in <strong class="source-inline">src/routes/birthdays/BirthdayForm.svelte</strong>) to include a new <span class="No-Break">hidden field:</span><pre class="console">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  &lt;input type="hidden" name="id" value={form?.id} /&gt;</strong>
&lt;/form&gt;</pre></li>
<li>Notice how <a id="_idIndexMarker199"/>we need optional chaining (with <strong class="source-inline">form?</strong>) to ensure our existing tests, with no <strong class="source-inline">form</strong> prop, continue to work. However, this presents a problem: what is the value of the <strong class="source-inline">id</strong> field if we’re not editing but creating? We need another test, which you can add to the same <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block:</span><pre class="console">
it('does not include the id field if no id is present', () =&gt; {
  render(BirthdayForm);
  expect(
    document.forms.birthday.elements.id
  ).not.toBeDefined();
});</pre></li>
<li>To make <a id="_idIndexMarker200"/>that pass, pull up the optional <a id="_idIndexMarker201"/>chain into a conditional that wraps the hidden <strong class="source-inline">input</strong> element in the <span class="No-Break"><strong class="source-inline">BirthdayForm</strong></span><span class="No-Break"> component:</span><pre class="console">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  {#if form?.id}</strong>
    &lt;input type="hidden" name="id" value={<strong class="bold">form.id</strong>} /&gt;
<strong class="bold">  {/if}</strong>
&lt;/form&gt;</pre></li>
</ol>
<p>Okay, that’s it for the <strong class="source-inline">BirthdayForm</strong> component itself. Now what about the <span class="No-Break">page component?</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Adding a toggle mode to the page</h2>
<p>In this section, you’ll introduce a component state variable named <strong class="source-inline">editing</strong> that allows us to toggle <a id="_idIndexMarker202"/>between <em class="italic">create</em> and <span class="No-Break"><em class="italic">update</em></span><span class="No-Break"> mode.</span></p>
<p>Let’s start <a id="_idIndexMarker203"/>by displaying the <strong class="bold">Edit</strong> buttons for each of the birthdays listed on <span class="No-Break">the page:</span></p>
<ol>
<li>In <strong class="source-inline">src/routes/birthdays/page.test.js</strong>, add the following test. Remember that the repository has, by default, two items, so this test allows us to test that <em class="italic">both</em> have an <span class="No-Break"><strong class="bold">Edit</strong></span><span class="No-Break"> button:</span><pre class="console">
it('displays an Edit button for each birthday in the list', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(
    screen.queryAllByRole('button', {
      name: 'Edit'
    })
  ).toHaveLength(2);
});</pre></li>
<li>To make <a id="_idIndexMarker204"/>that pass, in <strong class="source-inline">/src/routes/birthdays/+page.svelte</strong>, update each <strong class="source-inline">li</strong> element to contain <a id="_idIndexMarker205"/>a new <span class="No-Break"><strong class="source-inline">button</strong></span><span class="No-Break"> element:</span><pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
      &lt;Birthday {...birthday} /&gt;
<strong class="bold">      &lt;button&gt;Edit&lt;/button&gt;</strong>
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Next, what happens when we click that button? Let’s add a set of tests for checking the behavior when the <strong class="bold">Edit</strong> button is pressed. First, add two new imports. The first is for the <strong class="source-inline">beforeEach</strong> function that we’re going to use to pull out some common setup for each of our tests. The second is for the <strong class="source-inline">click</strong> function, which will be used to simulate a DOM <span class="No-Break">click event:</span><pre class="console">
import {
  describe,
  it,
  expect,
<strong class="bold">  beforeEach</strong>
} from 'vitest';
<strong class="bold">import { click } from '@testing-library/user-event';</strong></pre></li>
<li>Then add this new nested <strong class="source-inline">describe</strong> block and test. The <strong class="source-inline">beforeEach</strong> function is used to pull out the <em class="italic">Arrange</em> portion of the test to avoid having to repeat it <a id="_idIndexMarker206"/>in each of the subsequent tests. This <a id="_idIndexMarker207"/>code also makes use of a helper function named <strong class="source-inline">firstEditButton</strong> that keeps the tests readable <span class="No-Break">and short:</span><pre class="console">
describe('when editing an existing birthday', () =&gt; {
  beforeEach(() =&gt;
    render(Page, { data: { birthdays } })
  );
  const firstEditButton = () =&gt;
    screen.queryAllByRole('button', {
      name: 'Edit'
    })[0];
  it('hides the existing birthday information', async
  () =&gt; {
    await click(firstEditButton());
    expect(
      screen.queryByText('Hercules')
    ).toBeNull();
  });
});</pre></li>
<li>To make that pass, start by introducing a new component state variable named <strong class="source-inline">editing</strong> into the <span class="No-Break">page component:</span><pre class="console">
&lt;script&gt;
  ...
<strong class="bold">  let editing = null;</strong>
&lt;/script&gt;</pre></li>
<li>When the <strong class="bold">Edit</strong> button is pressed, set <strong class="source-inline">editing</strong> to the specific <strong class="source-inline">birthday</strong> object, which <a id="_idIndexMarker208"/>is given to us by the <strong class="source-inline">each</strong> construct. We <a id="_idIndexMarker209"/>can then wrap the original <strong class="source-inline">Birthday</strong> component in a conditional; if <strong class="source-inline">editing</strong> is equal to the current <strong class="source-inline">birthday</strong> object, then don’t <span class="No-Break">show </span><span class="No-Break"><strong class="source-inline">Birthday</strong></span><span class="No-Break">:</span><pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
<strong class="bold">      {#if editing !== birthday}</strong>
        &lt;Birthday {...birthday} /&gt;
<strong class="bold">      {/if}</strong>
        &lt;button
<strong class="bold">          on:click={() =&gt; (editing = birthday)}&gt;</strong>
<strong class="bold">            Edit&lt;/button</strong>&gt;
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Next, we also want to hide the original form for adding <span class="No-Break">the page:</span><pre class="console">
it('hides the birthday form for adding new birthdays', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeNull();
});</pre></li>
<li>To make <a id="_idIndexMarker210"/>that pass, wrap the last bit of the page <a id="_idIndexMarker211"/>component <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break">:</span><pre class="console">
<strong class="bold">{#if !editing}</strong>
  &lt;h1&gt;Add a new birthday&lt;/h1&gt;
  &lt;div&gt;
    &lt;BirthdayForm {form} /&gt;
  &lt;/div&gt;
<strong class="bold">{/if}</strong></pre></li>
</ol>
<p>But hang on a second! We’re now defining behavior on a static element that we’ve never tested before: the heading. The <strong class="source-inline">Add a new birthday</strong> text was something we didn’t bother testing. But now that it’s an integral part of our test suite, surely we should have a test to prove that it’s initially there? (Otherwise, the most straightforward way to get the last test to <em class="italic">Green</em> would have been to delete <span class="No-Break">the heading.)</span></p>
<p>In fact, do that now. Go ahead and delete it and watch your test suite happily pass. To bring it back in, we need a <span class="No-Break">failing test:</span></p>
<ol>
<li>Add this new test right at the top of the <span class="No-Break">test suite:</span><pre class="console">
it('displays a heading for "Add a new birthday"', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeVisible();
});</pre></li>
<li>Watch the test fail, and then go ahead and undelete <span class="No-Break">the heading.</span></li>
<li>Onto the <a id="_idIndexMarker212"/>next test. This time, let’s check that <strong class="source-inline">BirthdayForm</strong> is shown. We can do that by looking for a <strong class="source-inline">Name</strong> field that has the <a id="_idIndexMarker213"/>existing name in there (in this case, <span class="No-Break">that’s </span><span class="No-Break"><strong class="source-inline">Hercules</strong></span><span class="No-Break">):</span><pre class="console">
it('shows the birthday form for editing', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.getByLabelText('Name')
  ).toHaveValue('Hercules');
});</pre></li>
<li>To make that pass, flesh out the <strong class="source-inline">if</strong> conditional block with a new <strong class="source-inline">:else</strong> block. Notice the order of proceedings swaps around here: if <strong class="source-inline">editing</strong> is equal to <strong class="source-inline">birthday</strong>, then display <strong class="source-inline">BirthdayForm</strong>; otherwise, <span class="No-Break">display </span><span class="No-Break"><strong class="source-inline">Birthday</strong></span><span class="No-Break">:</span><pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
<strong class="bold">      {#if editing == birthday}</strong>
<strong class="bold">        &lt;BirthdayForm form={editing} /&gt;</strong>
<strong class="bold">      {:else}</strong>
        &lt;Birthday {...birthday} /&gt;
      {/if}
      ...
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Now that <a id="_idIndexMarker214"/>we have a <strong class="bold">Save</strong> button on the page, shouldn’t <a id="_idIndexMarker215"/>we hide all the <strong class="bold">Edit</strong> buttons? Yes, let’s <span class="No-Break">do that:</span><pre class="console">
it('hides all the Edit buttons', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.queryByRole('button', {
      name: 'Edit'
    })
  ).toBeNull();
});</pre></li>
<li>To make that pass, introduce another <strong class="source-inline">if</strong> block around <span class="No-Break">the button:</span><pre class="console">
<strong class="bold">{#if !editing}</strong>
  &lt;button
    on:click={() =&gt; (editing = birthday)}&gt;
      Edit&lt;/button&gt;
<strong class="bold">{/if}</strong></pre></li>
<li>There’s one final test left. This is an important one. It checks that if SvelteKit passes us back a <strong class="source-inline">form</strong> object with an <strong class="source-inline">id</strong> value, then we need to immediately start in <em class="italic">edit</em> mode <a id="_idIndexMarker216"/>for that birthday. Since the <strong class="source-inline">id</strong> value is <a id="_idIndexMarker217"/>important here, this test includes its own <strong class="source-inline">data</strong> and <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> properties:</span><pre class="console">
it('opens the form in editing mode if a form id is passed in', () =&gt; {
  render(Page, {
    data: {
      birthdays: [
        {
          id: '123',
          name: 'Hercules',
          dob: '1994-02-02'
        }
      ]
    },
    form: {
      id: '123',
      name: 'Hercules',
      dob: 'bad dob',
      error: 'An error'
    }
  });
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeNull();
});</pre></li>
</ol>
<p class="callout-heading">Using factory methods to shorten tests</p>
<p class="callout">In <a href="B19611_07.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Tidying up Test Suites</em>, you’ll create a factory method for birthdays that will shorten <span class="No-Break">this test.</span></p>
<ol>
<li value="8">The tests allude <a id="_idIndexMarker218"/>to the fact that the initial <a id="_idIndexMarker219"/>value of <strong class="source-inline">editing</strong> depends on <strong class="source-inline">form</strong>. So, update that now to look <span class="No-Break">like this:</span><pre class="console">
let editing = form?.id ? form : null;</pre></li>
<li>Then, because we’re dealing with different objects, we can no longer use equality based on object identity to match the currently edited birthday. So, update the first <strong class="source-inline">if</strong> to be the one shown in the following code, which checks <strong class="source-inline">id</strong> rather than the whole <span class="No-Break">object itself:</span><pre class="console">
{#if <strong class="bold">editing?.id === birthday.id</strong>}
  ...
{/if}</pre></li>
<li>Now, because of this new reliance on the <strong class="source-inline">id</strong> field, you’ll find other tests breaking. Update the <strong class="source-inline">birthdays</strong> array to include the <strong class="source-inline">id</strong> values <span class="No-Break">like this:</span><pre class="console">
const birthdays = [
  {
<strong class="bold">    id: '123',</strong>
    name: 'Hercules',
    dob: '1994-02-02'
  },
  {
<strong class="bold">    </strong><strong class="bold">id: '234',</strong>
    name: 'Athena',
    dob: '1989-01-01'
  }
];</pre></li>
</ol>
<p>After this <a id="_idIndexMarker220"/>point, your tests should pass, including <a id="_idIndexMarker221"/>your <span class="No-Break">Playwright test.</span></p>
<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.3</em> shows what the application looks like if you fire up the dev server (with the <strong class="source-inline">npm run dev</strong> command) and try to replace an existing birthday with an <span class="No-Break">invalid date:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 6.3 – A validation error when editing a birthday" height="576" src="image/Figure_6.3_B19611.jpg" width="1064"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A validation error when editing a birthday</p>
<p>This section has shown you how you can use the Svelte component state to switch between add and edit modes of a form and how you can test-drive those modifications in both the form component and the <span class="No-Break">page component.</span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Summary</h1>
<p>This chapter has demonstrated how the TDD process works once you have a substantial amount of code in place. In addition, you have seen how we can build feature upon feature using the same <em class="italic">Red-Green-Refactor</em> workflow that you learned about in <a href="B19611_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>: first, by refactoring the store implementation, and then by introducing Svelte <span class="No-Break">component state.</span></p>
<p>In the next chapter, we’ll stop to look at some of the ways we can simplify the current <span class="No-Break">code base.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer026">
<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Part 2: Refactoring Tests and Application Code</h1>
<p>Now that you’ve learned about and practiced the test-driven development workflow, it’s time to focus on practices and strategies that will keep your automated tests and application code neat and tidy. The chapters in this part will provide you with guidance on creating elegant and maintainable automated <span class="No-Break">test suites.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em></li>
<li><a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em></li>
<li><a href="B19611_09.xhtml#_idTextAnchor111"><em class="italic">Chapter 9</em></a>, <em class="italic">Extracting Logic Out of the Framework</em></li>
<li><a href="B19611_10.xhtml#_idTextAnchor119"><em class="italic">Chapter 10</em></a>, <em class="italic">Test-Driving API Endpoints</em></li>
<li><a href="B19611_11.xhtml#_idTextAnchor127"><em class="italic">Chapter 11</em></a>, <em class="italic">Replacing Behavior with a Side-By-Side Implementation</em></li>
<li><a href="B19611_12.xhtml#_idTextAnchor134"><em class="italic">Chapter 12</em></a>, <em class="italic">Using Component Mocks to Clarify Tests</em></li>
<li><a href="B19611_13.xhtml#_idTextAnchor148"><em class="italic">Chapter 13</em></a>, <em class="italic">Adding Cucumber Tests</em></li>
</ul>
</div>
<div>
<div id="_idContainer027">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer028">
</div>
</div>
<div>
<div id="_idContainer029">
</div>
</div>
</div></body></html>