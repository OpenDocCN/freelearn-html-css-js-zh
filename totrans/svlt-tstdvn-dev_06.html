<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor079"/>6</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Editing Form Data</h1>
<p>The preceding two chapters showed how to build an HTML form to add new birthdays into the <em class="italic">Birthdays</em> application and how to add server-side validation for that form. This chapter wraps up the form implementation by adding the ability to edit existing birthday information.</p>
<p>Doing this will involve adding Svelte component state to track whether the edit form is in listing or editing mode.</p>
<p>Up to this point, the <a id="_idIndexMarker169"/>server has stored data in a plain JavaScript array. We have been using TDD to force the simplest implementation that could possibly work. This chapter brings in a more complex implementation that uses a <code>Map</code> object, which we’ll do as part of the <em class="italic">Refactor</em> step as part of the <em class="italic">Red-Green-Refactor</em> workflow.</p>
<p>This chapter will cover the following key topics:</p>
<ul>
<li>Planning the path ahead</li>
<li>Adding a Playwright test for editing form data</li>
<li>Evolving the repository to allow ID lookup</li>
<li>Updating the form action to handle edits</li>
<li>Updating the list page with a new edit mode</li>
</ul>
<p>By the end of the chapter, you’ll have seen how TDD is used to evolve system design when you increase the functionality of a software system.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start</a>.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Planning the path ahead</h1>
<p>Before we get started with the code, let’s do a little upfront design so we have a rough course of action.</p>
<p>The overall goal <a id="_idIndexMarker170"/>is to allow every birthday entry in the system to be modified. We’d like to reuse the existing <code>BirthdayForm</code> component so that it can be used for this purpose.</p>
<p><em class="italic">Figure 6</em><em class="italic">.1</em> shows a diagram of how we could update the system to support this new feature. Each list item will have an <code>Birthday</code> component will be switched to a <code>BirthdayForm</code> component:</p>
<div><div><img alt="Figure 6.1 – A mockup of editing birthdays" height="491" src="img/Figure_6.1_B19611.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A mockup of editing birthdays</p>
<p>While in this edit mode, it makes sense to hide the form for adding a birthday and also prohibit editing other birthdays, just to ensure that there’s only ever one active form on display.</p>
<p>There’s one question remaining, and that’s how do we let the backend form action know that we’re editing a birthday and not adding one?</p>
<p>A straightforward approach to doing this is to add a special <code>id</code> property to each birthday data object. This is a unique value that the server can use to identify each individual object. The <code>id</code> will never change and cannot be edited, whereas the other data items can be changed. And the user never needs to see the <code>id</code> value. Its purpose is simply to enable modification of existing data items.</p>
<p>We can use the <a id="_idIndexMarker171"/>standard JavaScript <code>randomUUID</code> function to give us a unique string to create an <code>id</code> for each birthday.</p>
<p><em class="italic">Figure 6</em><em class="italic">.2</em> shows the various SvelteKit components and functions, together with the important bits of data that are needed to make this work, including a new editing state variable in the page component and the <code>id</code> field used to pick out the birthday for editing:</p>
<div><div><img alt="Figure 6.2 – Using the component state and a lookup table to implement edit behavior" height="648" src="img/Figure_6.2_B19611.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Using the component state and a lookup table to implement edit behavior</p>
<p>Before continuing, it’s worth noting that our current birthday repository holds its <code>birthday</code> objects in a plain JavaScript array. This is fine for listing and adding new items, but it’s not ideal for replacing existing items without updated versions. A better data structure is a <code>Map</code> object, which allows us to easily update items based on a key. Since we’ve already realized we need a fixed <code>id</code> value to represent each birthday, we already have a good choice for a key.</p>
<p>That covers our up front design. With a plan in place, it’s time for an end-to-end test.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Adding a Playwright test for editing form data</h1>
<p>In this section, we’ll build the latest Playwright test for our system. Because this test is quite long, we’ll <a id="_idIndexMarker172"/>build it bit by bit. In <a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em>, we’ll look at how this test script can be shortened.</p>
<p>Let’s <a id="_idIndexMarker173"/>follow these steps to create the test:</p>
<ol>
<li>In <code>tests/birthday.test.js</code>, begin the test with the following code, which loads the application, the <code>/birthdays</code> endpoint, and then completes the form to add a new birthday for <code>Ares</code>. We have to be careful to find the button specifically with the <strong class="bold">Save</strong> name. That’s because we’ll now have multiple buttons on the page: one named <strong class="bold">Save</strong>, and then multiple buttons named <strong class="bold">Edit</strong>:<pre class="console">
test('edits a birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  // add a birthday using the form
  await page.getByLabel('Name').fill('Ares');
  await page
    .getByLabel('Date of birth')
    .fill('1985-01-01');
  await page
    .getByRole('button', { name: 'Save' })
    .click();
});</pre></li>
<li>Next, add the following command to find the <code>Ares</code>. This uses the special <code>getByRole('listitem').filter(...)</code> chain command, which finds an element with the <code>listitem</code> role (meaning the <code>li</code> elements) that also contains the <code>'Ares'</code> text. We then find the <strong class="bold">Edit</strong> button within that list item element:<pre class="console">
await page
  .getByRole('listitem')
  .filter({ hasText: 'Ares' })
  .getByRole('button', { name: 'Edit' })
  .click();</pre></li>
<li>We now <a id="_idIndexMarker174"/>assume that a new form <a id="_idIndexMarker175"/>has appeared for editing the birthday information for <code>Ares</code>. Continue the test with the following code, which replaces the <code>Date of birth</code> field with another value, and then click the <strong class="bold">Save</strong> button:<pre class="console">
await page
  .getByLabel('Date of birth')
  .fill('1995-01-01');
await page
  .getByRole('button', { name: 'Save' })
  .click();</pre></li>
<li>Finish off the new test with a couple of expectations. We check that the original date of birth no longer appears and that the new date of birth does appear:<pre class="console">
// check that the original text doesn't appear
await expect(
  page
    .getByRole('listitem')
    .filter({ hasText: 'Ares' })
).not.toContainText('1985-01-01');
// check that the new text does appear
await expect(
  page
    .getByRole('listitem')
    .filter({ hasText: 'Ares' })
).toContainText('1995-01-01');</pre></li>
<li>Finally, the <a id="_idIndexMarker176"/>previous Playwright <a id="_idIndexMarker177"/>tests need to be modified. Each test assumed that there was just one button on the page, the <code>find a button</code> and change them to be <code>find a button named Save</code>. Find all the lines that look like this:<pre class="console">
await page.getByRole('button').click();</pre></li>
</ol>
<p>And update them to look like this:</p>
<pre class="console">
await page.getByRole('button'<strong class="bold">,</strong>
<strong class="bold">  </strong><strong class="bold">{ name: 'Save' }</strong>
).click();</pre>
<p>That completes the new test. You can see we’ve already made some design decisions about the new <strong class="bold">Edit</strong> buttons and how they operate.</p>
<p>If you run tests now with the <code>npm test</code> command, you’ll see the new test timeout waiting for the <strong class="bold">Edit</strong> button to appear:</p>
<pre class="console">
Test timeout of 30000ms exceeded.
...
waiting for getByRole('listitem').filter({ hasText: 'Ares' }).getByRole('button', { name: 'Edit' })</pre>
<p>In the next section, we’ll translate that into decisions about the application code.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Evolving the repository to allow ID lookup</h1>
<p>It’s now <a id="_idIndexMarker178"/>time to update our birthday data items to include an <code>id</code> field.</p>
<p>Let’s start with a new test to check that <code>id</code> is present.</p>
<ol>
<li>Start by adding this test into the <code>src/routes/birthdays/page.server.test.js</code> file, within the <code>describe</code> block named <code>/birthdays - default action</code>. It checks that each birthday has a unique <code>id</code> field associated with it:<pre class="console">
it('saves unique ids onto each new birthday', async () =&gt; {
  const request = createFormDataRequest({
    name: 'Zeus',
    dob: '2009-02-02'
  });
  await actions.default({ request });
  await actions.default({ request });
  expect(birthdayRepository.getAll()[0].id).not
  .toEqual(birthdayRepository.getAll()[1].id);
});</pre></li>
<li>Make that pass in <code>src/lib/server/birthdayRepository.js</code>. Start by adding the <code>import</code> statement:<pre class="console">
import { randomUUID } from 'crypto';</pre></li>
<li>Then update the definition of the <code>addNew</code> function:<pre class="console">
export const addNew = (item) =&gt;
  db.push(<strong class="bold">{ ...item, id: randomUUID() }</strong>);</pre></li>
<li>If you run tests now, you’ll see that the test passes, but we have a new failure in a different <a id="_idIndexMarker179"/>part of the test suite. The <code>returns a fixture of two items</code> test is now erroring because of these new <code>id</code> fields. We can fix this by using the <code>expect.objectContaining</code> constraining function, which is useful for for saying, <em class="italic">I don’t care about anything except these properties</em>. It’s a useful tool for reducing the brittleness of tests. Update that test now to read as shown in the following code block:<pre class="console">
it('returns a fixture of two items', () =&gt; {
  const result = load();
  expect(result.birthdays).toEqual([
    <strong class="bold">expect.objectContaining(</strong>{
      name: 'Hercules',
      dob: '1994-02-02'
    }<strong class="bold">)</strong>,
    <strong class="bold">expect.objectContaining(</strong>{
      name: 'Athena',
      dob: '1989-01-01'
    }<strong class="bold">)</strong>
  ]);
});</pre></li>
<li>Now add this next test, which checks that if we send in a request with an <code>id</code> property, then we should choose to update the item matching that <code>id</code>, rather than adding <a id="_idIndexMarker180"/>a new birthday. Notice the use of the <code>storedId</code> function, which pulls out the <code>id</code> property that was saved into the repository:<pre class="console">
const storedId = () =&gt;
  birthdayRepository.getAll()[0].id;
it('updates an entry that shares the same id', async () =&gt; {
  let request = createFormDataRequest({
    name: 'Zeus',
    dob: '2009-02-02'
  });
  await actions.default({ request });
  request = createFormDataRequest({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
  await actions.default({ request });
  expect(birthdayRepository.getAll()).toHaveLength(1);
  expect(birthdayRepository.getAll()).toContainEqual({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre></li>
<li>It’s now a great time to refactor our <code>db</code> value to be a <code>Map</code> object rather than an array, as we discussed in the previous section. Doing that refactor will make this new test <a id="_idIndexMarker181"/>straightforward. But we don’t <em class="italic">refactor</em> on <em class="italic">Red</em>. So, begin by skipping the test you just wrote and checking the test suite is <em class="italic">Green</em>.<pre class="console">
it<strong class="bold">.skip</strong>('updates an entry that shares the same id', async () =&gt; {
  ...
});</pre></li>
<li>In <code>src/lib/server/birthdayRepository.js</code>, replace <code>db</code>, <code>addNew</code>, <code>getAll</code>, and <code>clear</code> with this implementation that uses the <code>Map</code> object:<pre class="console">
<strong class="bold">const db = new Map()</strong>;
export const addNew = (item) =&gt; {
  <strong class="bold">const id = randomUUID();</strong>
  <strong class="bold">db.set(id, { ...item, id });</strong>
};
export const getAll = () =&gt; Array.from(<strong class="bold">db.values()</strong>);
export const clear = () =&gt; <strong class="bold">db.clear()</strong>;</pre></li>
<li>Run your tests after this change and make sure they are still <em class="italic">Green</em>.</li>
</ol>
<p class="callout-heading">Refactoring with confidence</p>
<p class="callout">Notice how the presence of your unit tests removes any fear of change when you completely replace the internal data structure. The tests encourage you to make whatever change you need without worrying about unintentional changes in behavior.</p>
<p>All the tests should pass – fantastic!</p>
<p>This section <a id="_idIndexMarker182"/>has shown you another example of how we can use TDD to delay complex designs until the point that our unit tests force us. You’ve seen how we can migrate an important variable from an array to a <code>Map</code> object.</p>
<p>Now let’s get on with building the edit feature.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Updating the form action to handle edits</h1>
<p>In this section, we’ll continue with updating the repository to handle updating birthdays in addition <a id="_idIndexMarker183"/>to adding new ones. We’ll tackle this in three parts: first, replacing items in the <code>db</code> field, second, guarding against invalid <code>id</code> values, and third, ensuring that <code>id</code> values are passed back in validation errors so that the same birthday can be corrected by the user.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Replacing items in the repository</h2>
<p>Let’s get <a id="_idIndexMarker184"/>started with the test you wrote in the previous section:</p>
<ol>
<li>Un-skip the last test you wrote in the <code>src/routes/birthdays/page.server.test.js</code> file. Make sure to run the tests and watch it fail, ensuring you’re on <em class="italic">Red</em>:<pre class="console">
it('updates an entry that shares the same id', async () =&gt; {
  ...
});</pre></li>
<li>To make that test pass, start by adding a <code>replace</code> function to <code>src/lib/server/birthdayRepository.js</code>:<pre class="console">
export const replace = (id, item) =&gt;
  db.set(id, { ...item, id });</pre></li>
<li>Then, import <a id="_idIndexMarker185"/>that new function into <code>src/routes/birthdays/+page.server.js</code>:<pre class="console">
import {
  addNew,
  getAll,
<strong class="bold">  replace</strong>
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>Update the <code>actions</code> constant, first by pulling out <code>id</code> from the request, and then using that <code>id</code> value to switch behavior. If <code>id</code> is present, then call the <code>replace</code> function; otherwise, call the <code>addNew</code> function:<pre class="console">
export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
<strong class="bold">    const id = data.get('id');</strong>
    ...
<strong class="bold">    if (id) {</strong>
<strong class="bold">      replace(id, {</strong>
<strong class="bold">        name,</strong>
<strong class="bold">        dob</strong>
<strong class="bold">      });</strong>
<strong class="bold">    } else {</strong>
      addNew({ name, dob });
<strong class="bold">    }</strong>
  }
};</pre></li>
<li>Re run <a id="_idIndexMarker186"/>your tests; you should now be on <em class="italic">Green</em>.</li>
</ol>
<p>Next, let’s ensure that only valid <code>id</code> values are accepted.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Protecting against unknown identifiers</h2>
<p>The final <a id="_idIndexMarker187"/>validation we need is to make sure that we don’t try to update items in the repository that don’t exist. Let’s begin with a new test context:</p>
<ol>
<li>Still in <code>src/routes/birthdays/page.server.test.js</code>, add a new nested <code>describe</code> block to the <em class="italic">validation errors</em> context, as shown in the following code. I’ve skipped ahead and included <em class="italic">three</em> tests here since we’ve solved these kinds of tests before, and we can feel confident about solving them at the same time:<pre class="console">
describe('when the id is unknown', () =&gt; {
  let result;
  beforeEach(async () =&gt; {
    const request = createFormDataRequest({
      id: 'unknown',
      name: 'Hercules',
      dob: '2009-01-02'
    });
    result = await actions.default({
      request
    });
  });
  it('does not save the birthday', () =&gt; {
    expect(load().birthdays).not.toContainEqual(
      expect.objectContaining({
        name: 'Hercules',
        dob: 'unknown'
      })
    );
  });
  it('returns a 422', () =&gt; {
    expect(result.status).toEqual(422);
  });
  it('returns a useful message', () =&gt; {
    expect(result.data.error).toEqual(
      'An unknown ID was provided.'
    );
  });
});</pre></li>
<li>To make this pass, start by adding a new <code>has</code> function to <code>src/lib/server/birthdayRepository.js</code>:<pre class="console">
export const has = (id) =&gt; db.has(id);</pre></li>
<li>Then <a id="_idIndexMarker188"/>import that into <code>src/routes/birthdays/+page.server.js</code>:<pre class="console">
import {
  addNew,
  getAll,
  replace,
<strong class="bold">  has</strong>
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>And finally, make use of it by adding a new guard clause.<pre class="console">
if (id &amp;&amp; !has(id)) {
  return fail(422, {
    error: 'An unknown ID was provided.'
  });
}</pre></li>
</ol>
<p>We’re almost done with the form action validations, but there’s one more thing we need to do.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Updating return values to include identifiers</h2>
<p>When a validation <a id="_idIndexMarker189"/>error occurs, such as when the <code>name</code> field is empty, we need to ensure the <code>id</code> form value is included in the return error value. That ensures that back in the web browser, the correct edit form can be reopened to allow the user to correct their edits.</p>
<p>Before we launch into the code changes, let’s discuss the strategy. This is how the application code will end up looking:</p>
<pre class="source-code">
if (empty(name)) {
  return fail(422, {
<strong class="bold">    </strong><strong class="bold">id,</strong>
    dob,
    error: 'Please provide a name.'
  });
}</pre>
<p>Before you <a id="_idIndexMarker190"/>make that change, however, think about how you’ll test this. We already have a test that checks the contents of the return value, so one option is to go back and edit this test like this:</p>
<pre class="source-code">
beforeEach(async () =&gt; {
  const request = createFormDataRequest({
<strong class="bold">    id: '123',</strong>
    name: 'Hercules'
  });
});</pre>
<p>But don’t do this.</p>
<p>I find that editing previous tests is generally a bad idea. The reason for that is it can produce tests that end up specifying invalid scenarios that can never happen. The preceding example is indeed an invalid scenario. That’s because there’s no birthday in the system with an <code>id</code> value of <code>123</code>. To make it valid, we’d need new test setup instructions that create the birthday with the <code>id </code>value of <code>123</code> to ensure the <code>id</code> value is valid.</p>
<p>But if we do that, then we have no test for the original scenario of adding a birthday! Instead, let’s create new tests that cover each of the two use cases that can happen: an invalid name or an invalid date of birth when a birthday is being edited.</p>
<p class="callout-heading">Scenario-based testing</p>
<p class="callout">When you’re writing unit tests, always make sure your tests cover valid scenarios. If you’re following TDD, that generally means always adding new tests rather than going back to modify existing tests.</p>
<p>Let’s begin <a id="_idIndexMarker191"/>by adding a new nested context inside the <code>validation </code><code>errors</code> context:</p>
<ol>
<li>Add the following <code>describe</code> context with its associated <code>beforeEach</code> block, which adds a birthday into the system:<pre class="console">
describe('when replacing an item', () =&gt; {
  beforeEach(async () =&gt; {
    let request = createFormDataRequest({
      name: 'Zeus',
      dob: '2009-02-02'
    });
    await actions.default({ request });
  });
});</pre></li>
<li>Now, add the first test into the context. It attempts to edit the created birthday but has an empty name. The expectation checks that the same <code>id</code> value is passed back in the response:<pre class="console">
it('returns the id when an empty name is provided', async () =&gt; {
  const request = createFormDataRequest({
    id: storedId(),
    name: '',
    dob: '1982-05-01'
  });
  const result = await actions.default({
    request
  });
  expect(result.data).toContain({ id: storedId() });
});</pre></li>
<li>To make <a id="_idIndexMarker192"/>that pass, include the <code>id</code> property in the relevant guard clause:<pre class="console">
if (empty(name)) {
  return fail(422, {
<strong class="bold">    id,</strong>
    dob,
    error: 'Please provide a name.'
  });
}</pre></li>
<li>Next, add a test for an invalid date of birth:<pre class="console">
it('returns the id when an empty date of birth is provided', async () =&gt; {
  const request = createFormDataRequest({
    id: storedId(),
    name: 'Hercules',
    dob: ''
  });
  const result = await actions.default({
    request
  });
  expect(result.data).toContain({ id: storedId() });
});</pre></li>
<li>To make <a id="_idIndexMarker193"/>that pass, update the second guard clause, as shown here:<pre class="console">
if (invalidDob(dob)) {
  return fail(422, {
<strong class="bold">    id,</strong>
    name,
    dob,
    error:
      'Please provide a date of birth in the YYYY-MM-DD format.'
  });
}</pre></li>
</ol>
<p>That completes the changes to the form action.</p>
<p class="callout-heading">Listening to your tests</p>
<p class="callout">It’s very important to listen to your tests. If they are a slog to write and update, that’s a sign that either the tests can be improved or the application code design can be improved.</p>
<p>In <a href="B19611_09.xhtml#_idTextAnchor111"><em class="italic">Chapter 9</em></a>, <em class="italic">Extracting Logic Out of the Framework</em>, we’ll move validation into the birthday repository, and this will give us a chance to rethink how these tests are structured.</p>
<p>This section has covered a whole bunch of changes: adding repository functionality for replacing items, updating the form action to either add or replace items, adding another guard clause <a id="_idIndexMarker194"/>to protect against invalid replacements, and finally, updating the existing guard clauses to return the <code>id</code> value.</p>
<p>Now it’s time to update the page component to display <code>BirthdayForm</code> in edit mode.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Updating the list page with a new edit mode</h1>
<p>In this <a id="_idIndexMarker195"/>section, you’ll update the page so that it can <a id="_idIndexMarker196"/>toggle into an edit mode for a given birthday. That relies on having a hidden form field for the <code>id</code> value.</p>
<p class="callout-heading">Testing hidden fields</p>
<p class="callout">Testing Library doesn’t give us an easy way to query the <code>hidden</code> input fields because it generally concerns itself with what is visible to the user, and our <code>id</code> field is purposefully designed to be an internal system detail.</p>
<p class="callout">Fortunately, we can <a id="_idIndexMarker197"/>fall back to the standard <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) Form API to figure this out.</p>
<p class="callout">The nature of writing unit tests for frameworks such as SvelteKit means that sometimes you’re checking for internal details like this.</p>
<p>Let’s start with a new test in a new nested <code>describe</code> block:</p>
<ol>
<li>In the <code>src/routes/birthdays/BirthdayForm.test.js</code> file, and within the <code>BirthdayForm</code> root in the <code>describe</code> block, add this new nested <code>describe</code> block and test:<pre class="console">
describe('id field', () =&gt; {
  it('contains a hidden field for the id if an id is
  given', () =&gt; {
    render(BirthdayForm, { form: { id: '123' } });
    expect(
      document.forms.birthday.elements.id.value
    ).toEqual('123');
  });
});</pre></li>
<li>To make <a id="_idIndexMarker198"/>that pass, update the <code>BirthdayForm</code> component (in <code>src/routes/birthdays/BirthdayForm.svelte</code>) to include a new hidden field:<pre class="console">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  &lt;input type="hidden" name="id" value={form?.id} /&gt;</strong>
&lt;/form&gt;</pre></li>
<li>Notice how <a id="_idIndexMarker199"/>we need optional chaining (with <code>form?</code>) to ensure our existing tests, with no <code>form</code> prop, continue to work. However, this presents a problem: what is the value of the <code>id</code> field if we’re not editing but creating? We need another test, which you can add to the same <code>describe</code> block:<pre class="console">
it('does not include the id field if no id is present', () =&gt; {
  render(BirthdayForm);
  expect(
    document.forms.birthday.elements.id
  ).not.toBeDefined();
});</pre></li>
<li>To make <a id="_idIndexMarker200"/>that pass, pull up the optional <a id="_idIndexMarker201"/>chain into a conditional that wraps the hidden <code>input</code> element in the <code>BirthdayForm</code> component:<pre class="console">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  {#if form?.id}</strong>
    &lt;input type="hidden" name="id" value={<strong class="bold">form.id</strong>} /&gt;
<strong class="bold">  {/if}</strong>
&lt;/form&gt;</pre></li>
</ol>
<p>Okay, that’s it for the <code>BirthdayForm</code> component itself. Now what about the page component?</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Adding a toggle mode to the page</h2>
<p>In this section, you’ll introduce a component state variable named <code>editing</code> that allows us to toggle <a id="_idIndexMarker202"/>between <em class="italic">create</em> and <em class="italic">update</em> mode.</p>
<p>Let’s start <a id="_idIndexMarker203"/>by displaying the <strong class="bold">Edit</strong> buttons for each of the birthdays listed on the page:</p>
<ol>
<li>In <code>src/routes/birthdays/page.test.js</code>, add the following test. Remember that the repository has, by default, two items, so this test allows us to test that <em class="italic">both</em> have an <strong class="bold">Edit</strong> button:<pre class="console">
it('displays an Edit button for each birthday in the list', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(
    screen.queryAllByRole('button', {
      name: 'Edit'
    })
  ).toHaveLength(2);
});</pre></li>
<li>To make <a id="_idIndexMarker204"/>that pass, in <code>/src/routes/birthdays/+page.svelte</code>, update each <code>li</code> element to contain <a id="_idIndexMarker205"/>a new <code>button</code> element:<pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
      &lt;Birthday {...birthday} /&gt;
<strong class="bold">      &lt;button&gt;Edit&lt;/button&gt;</strong>
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Next, what happens when we click that button? Let’s add a set of tests for checking the behavior when the <code>beforeEach</code> function that we’re going to use to pull out some common setup for each of our tests. The second is for the <code>click</code> function, which will be used to simulate a DOM click event:<pre class="console">
import {
  describe,
  it,
  expect,
<strong class="bold">  beforeEach</strong>
} from 'vitest';
<strong class="bold">import { click } from '@testing-library/user-event';</strong></pre></li>
<li>Then add this new nested <code>describe</code> block and test. The <code>beforeEach</code> function is used to pull out the <em class="italic">Arrange</em> portion of the test to avoid having to repeat it <a id="_idIndexMarker206"/>in each of the subsequent tests. This <a id="_idIndexMarker207"/>code also makes use of a helper function named <code>firstEditButton</code> that keeps the tests readable and short:<pre class="console">
describe('when editing an existing birthday', () =&gt; {
  beforeEach(() =&gt;
    render(Page, { data: { birthdays } })
  );
  const firstEditButton = () =&gt;
    screen.queryAllByRole('button', {
      name: 'Edit'
    })[0];
  it('hides the existing birthday information', async
  () =&gt; {
    await click(firstEditButton());
    expect(
      screen.queryByText('Hercules')
    ).toBeNull();
  });
});</pre></li>
<li>To make that pass, start by introducing a new component state variable named <code>editing</code> into the page component:<pre class="console">
&lt;script&gt;
  ...
<strong class="bold">  let editing = null;</strong>
&lt;/script&gt;</pre></li>
<li>When the <code>editing</code> to the specific <code>birthday</code> object, which <a id="_idIndexMarker208"/>is given to us by the <code>each</code> construct. We <a id="_idIndexMarker209"/>can then wrap the original <code>Birthday</code> component in a conditional; if <code>editing</code> is equal to the current <code>birthday</code> object, then don’t show <code>Birthday</code>:<pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
<strong class="bold">      {#if editing !== birthday}</strong>
        &lt;Birthday {...birthday} /&gt;
<strong class="bold">      {/if}</strong>
        &lt;button
<strong class="bold">          on:click={() =&gt; (editing = birthday)}&gt;</strong>
<strong class="bold">            Edit&lt;/button</strong>&gt;
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Next, we also want to hide the original form for adding the page:<pre class="console">
it('hides the birthday form for adding new birthdays', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeNull();
});</pre></li>
<li>To make <a id="_idIndexMarker210"/>that pass, wrap the last bit of the page <a id="_idIndexMarker211"/>component in <code>if</code>:<pre class="console">
<strong class="bold">{#if !editing}</strong>
  &lt;h1&gt;Add a new birthday&lt;/h1&gt;
  &lt;div&gt;
    &lt;BirthdayForm {form} /&gt;
  &lt;/div&gt;
<strong class="bold">{/if}</strong></pre></li>
</ol>
<p>But hang on a second! We’re now defining behavior on a static element that we’ve never tested before: the heading. The <code>Add a new birthday</code> text was something we didn’t bother testing. But now that it’s an integral part of our test suite, surely we should have a test to prove that it’s initially there? (Otherwise, the most straightforward way to get the last test to <em class="italic">Green</em> would have been to delete the heading.)</p>
<p>In fact, do that now. Go ahead and delete it and watch your test suite happily pass. To bring it back in, we need a failing test:</p>
<ol>
<li>Add this new test right at the top of the test suite:<pre class="console">
it('displays a heading for "Add a new birthday"', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeVisible();
});</pre></li>
<li>Watch the test fail, and then go ahead and undelete the heading.</li>
<li>Onto the <a id="_idIndexMarker212"/>next test. This time, let’s check that <code>BirthdayForm</code> is shown. We can do that by looking for a <code>Name</code> field that has the <a id="_idIndexMarker213"/>existing name in there (in this case, that’s <code>Hercules</code>):<pre class="console">
it('shows the birthday form for editing', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.getByLabelText('Name')
  ).toHaveValue('Hercules');
});</pre></li>
<li>To make that pass, flesh out the <code>if</code> conditional block with a new <code>:else</code> block. Notice the order of proceedings swaps around here: if <code>editing</code> is equal to <code>birthday</code>, then display <code>BirthdayForm</code>; otherwise, display <code>Birthday</code>:<pre class="console">
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
<strong class="bold">      {#if editing == birthday}</strong>
<strong class="bold">        &lt;BirthdayForm form={editing} /&gt;</strong>
<strong class="bold">      {:else}</strong>
        &lt;Birthday {...birthday} /&gt;
      {/if}
      ...
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
<li>Now that <a id="_idIndexMarker214"/>we have a <strong class="bold">Save</strong> button on the page, shouldn’t <a id="_idIndexMarker215"/>we hide all the <strong class="bold">Edit</strong> buttons? Yes, let’s do that:<pre class="console">
it('hides all the Edit buttons', async () =&gt; {
  await click(firstEditButton());
  expect(
    screen.queryByRole('button', {
      name: 'Edit'
    })
  ).toBeNull();
});</pre></li>
<li>To make that pass, introduce another <code>if</code> block around the button:<pre class="console">
<strong class="bold">{#if !editing}</strong>
  &lt;button
    on:click={() =&gt; (editing = birthday)}&gt;
      Edit&lt;/button&gt;
<strong class="bold">{/if}</strong></pre></li>
<li>There’s one final test left. This is an important one. It checks that if SvelteKit passes us back a <code>form</code> object with an <code>id</code> value, then we need to immediately start in <em class="italic">edit</em> mode <a id="_idIndexMarker216"/>for that birthday. Since the <code>id</code> value is <a id="_idIndexMarker217"/>important here, this test includes its own <code>data</code> and <code>form</code> properties:<pre class="console">
it('opens the form in editing mode if a form id is passed in', () =&gt; {
  render(Page, {
    data: {
      birthdays: [
        {
          id: '123',
          name: 'Hercules',
          dob: '1994-02-02'
        }
      ]
    },
    form: {
      id: '123',
      name: 'Hercules',
      dob: 'bad dob',
      error: 'An error'
    }
  });
  expect(
    screen.queryByRole('heading', {
      name: 'Add a new birthday'
    })
  ).toBeNull();
});</pre></li>
</ol>
<p class="callout-heading">Using factory methods to shorten tests</p>
<p class="callout">In <a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em>, you’ll create a factory method for birthdays that will shorten this test.</p>
<ol>
<li value="8">The tests allude <a id="_idIndexMarker218"/>to the fact that the initial <a id="_idIndexMarker219"/>value of <code>editing</code> depends on <code>form</code>. So, update that now to look like this:<pre class="console">
let editing = form?.id ? form : null;</pre></li>
<li>Then, because we’re dealing with different objects, we can no longer use equality based on object identity to match the currently edited birthday. So, update the first <code>if</code> to be the one shown in the following code, which checks <code>id</code> rather than the whole object itself:<pre class="console">
{#if <strong class="bold">editing?.id === birthday.id</strong>}
  ...
{/if}</pre></li>
<li>Now, because of this new reliance on the <code>id</code> field, you’ll find other tests breaking. Update the <code>birthdays</code> array to include the <code>id</code> values like this:<pre class="console">
const birthdays = [
  {
<strong class="bold">    id: '123',</strong>
    name: 'Hercules',
    dob: '1994-02-02'
  },
  {
<strong class="bold">    </strong><strong class="bold">id: '234',</strong>
    name: 'Athena',
    dob: '1989-01-01'
  }
];</pre></li>
</ol>
<p>After this <a id="_idIndexMarker220"/>point, your tests should pass, including <a id="_idIndexMarker221"/>your Playwright test.</p>
<p><em class="italic">Figure 6</em><em class="italic">.3</em> shows what the application looks like if you fire up the dev server (with the <code>npm run dev</code> command) and try to replace an existing birthday with an invalid date:</p>
<div><div><img alt="Figure 6.3 – A validation error when editing a birthday" height="576" src="img/Figure_6.3_B19611.jpg" width="1064"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A validation error when editing a birthday</p>
<p>This section has shown you how you can use the Svelte component state to switch between add and edit modes of a form and how you can test-drive those modifications in both the form component and the page component.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Summary</h1>
<p>This chapter has demonstrated how the TDD process works once you have a substantial amount of code in place. In addition, you have seen how we can build feature upon feature using the same <em class="italic">Red-Green-Refactor</em> workflow that you learned about in <a href="B19611_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>: first, by refactoring the store implementation, and then by introducing Svelte component state.</p>
<p>In the next chapter, we’ll stop to look at some of the ways we can simplify the current code base.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Part 2: Refactoring Tests and Application Code</h1>
<p>Now that you’ve learned about and practiced the test-driven development workflow, it’s time to focus on practices and strategies that will keep your automated tests and application code neat and tidy. The chapters in this part will provide you with guidance on creating elegant and maintainable automated test suites.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em></li>
<li><a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em></li>
<li><a href="B19611_09.xhtml#_idTextAnchor111"><em class="italic">Chapter 9</em></a>, <em class="italic">Extracting Logic Out of the Framework</em></li>
<li><a href="B19611_10.xhtml#_idTextAnchor119"><em class="italic">Chapter 10</em></a>, <em class="italic">Test-Driving API Endpoints</em></li>
<li><a href="B19611_11.xhtml#_idTextAnchor127"><em class="italic">Chapter 11</em></a>, <em class="italic">Replacing Behavior with a Side-By-Side Implementation</em></li>
<li><a href="B19611_12.xhtml#_idTextAnchor134"><em class="italic">Chapter 12</em></a>, <em class="italic">Using Component Mocks to Clarify Tests</em></li>
<li><a href="B19611_13.xhtml#_idTextAnchor148"><em class="italic">Chapter 13</em></a>, <em class="italic">Adding Cucumber Tests</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>