<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Content Management"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Content Management</h1></div></div></div><p>In the preceding chapter, we developed the static data module that consisted of emulating the edition of a table from a database. Basically, it was a <a id="id658" class="indexterm"/>
<span class="strong"><strong>Create, Read, Update, Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>) of a single table with some extra capabilities. In this chapter, we are going further in the complexity of managing information from a table. Usually, in <a id="id659" class="indexterm"/>real-world applications, the tables, the information of which we want to manage have relationships with other tables, and we have to manage the relationships as well. And this is what this chapter is all about. How can we build screens and manage complex information in Ext JS?</p><p>So in this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing complex information with Ext JS</li><li class="listitem" style="list-style-type: disc">How to handle many-to-many associations</li><li class="listitem" style="list-style-type: disc">Forms with associations</li><li class="listitem" style="list-style-type: disc">Reusing components</li></ul></div><div class="section" title="Managing information – films"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Managing information – films</h1></div></div></div><p>The <a id="id660" class="indexterm"/>Sakila database has four major modules within it: <span class="strong"><strong>Inventory</strong></span>, which consists of the films' information, along with the inventory<a id="id661" class="indexterm"/> information (how many movies we have in each store available for rental); customer data, which consists of customer information; business, which consists of the stores, staff and also rental and payment information (this depends on inventory and customer data to feed some information); and views, which consists of data we can use for reports and charts.</p><p>For now, we are only interested in <a id="id662" class="indexterm"/>
<span class="strong"><strong>Inventory</strong></span>, customer data, and business, which contains the core business information of the application. Let's take a look at <span class="strong"><strong>Inventory</strong></span>, which has more tables than the other two:</p><div class="mediaobject"><img src="graphics/0457OT_08_01.jpg" alt="Managing information – films"/></div><p>According to<a id="id663" class="indexterm"/> the Sakila documentation:</p><p><span class="emphasis"><em>The <code class="literal">film</code> table is a list of all films potentially in stock in the stores. The actual in-stock copies of each film are represented in the <code class="literal">inventory</code> table.</em></span></p><p><span class="emphasis"><em>The <code class="literal">film</code> table refers to the <code class="literal">language</code> table and is referred to by the <code class="literal">film_category</code>, <code class="literal">film_actor</code>, and <code class="literal">inventory</code> tables.</em></span></p><p>The <code class="literal">film</code> table<a id="id664" class="indexterm"/> has a many-to-many relationship with the <code class="literal">category</code> and <code class="literal">actor</code> tables. It has two many-to-one relationships with the <code class="literal">language</code> table. In the last chapter, we have already developed code to manage the <code class="literal">category</code>, <code class="literal">actor</code>, and <code class="literal">language</code> tables. Now, we need to manage the relationships between the <code class="literal">film</code> table and these other tables.</p><p>Ext JS 5 has really nice capabilities to manage associated entities similar to the <code class="literal">film</code> table. We will dive into them in this chapter.</p><p>So let's take a brief look at the screens that we are going to develop in this chapter.</p><p>First, we need a screen to list the films we have, which is as follows:</p><div class="mediaobject"><img src="graphics/0457OT_08_02.jpg" alt="Managing information – films"/></div><p>This screen displays<a id="id665" class="indexterm"/> three data grids. The first one is the <code class="literal">film</code> table, which is going to display the list of all <span class="strong"><strong>Films</strong></span>. The second one is <a id="id666" class="indexterm"/>the <span class="strong"><strong>Film Categories</strong></span>, which represents the many-to-many relationship between the <code class="literal">film</code> and <code class="literal">category</code> tables. And the third one is the <span class="strong"><strong>Film Actors</strong></span>, which represents the many-to-many relationship between the <code class="literal">film</code> and <code class="literal">actor</code> tables.</p><p>Then, if we want to create or edit a film, we will create a FormPanel within a window so that we can edit its information, as follows:</p><div class="mediaobject"><img src="graphics/0457OT_08_03.jpg" alt="Managing information – films"/></div><p>As the <code class="literal">film</code> table<a id="id667" class="indexterm"/> has a many-to-many <a id="id668" class="indexterm"/>association with the <code class="literal">categories</code> table, we also need to handle it within the FormPanel using a different tab. If we want to add more categories associated with the film, we can <span class="strong"><strong>Search</strong></span> and add, as follows:</p><div class="mediaobject"><img src="graphics/0457OT_08_04.jpg" alt="Managing information – films"/></div><p>Likewise, the <code class="literal">film</code> table has also a many-to-many association with the <code class="literal">actor</code> table, so we also need to handle it <a id="id669" class="indexterm"/>within the FormPanel. The following screenshot exemplifies this:</p><div class="mediaobject"><img src="graphics/0457OT_08_05.jpg" alt="Managing information – films"/></div><p>If we want to <a id="id670" class="indexterm"/>add more actors associated to the film, we can use <span class="strong"><strong>Search and Add Actor</strong></span>, as follows:</p><div class="mediaobject"><img src="graphics/0457OT_08_06.jpg" alt="Managing information – films"/></div><p>Notice that we <a id="id671" class="indexterm"/>are taking a different approach for each screen. This way we can learn more ways of handling these scenarios in <a id="id672" class="indexterm"/>Ext JS. By the end of this chapter, we will learn to create this complex form and save associated data as well.</p><p>So now that we have an idea of what we will implement throughout this chapter, let's have some fun and get our hands dirty!</p></div></div>
<div class="section" title="Displaying the Film data grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Displaying the Film data grid</h1></div></div></div><p>First, let's start <a id="id673" class="indexterm"/>with the basics. Whenever <a id="id674" class="indexterm"/>we need to implement a complex screen, we need to start with the simplest component we can develop. When this component is working, we can start incrementing it and add more complex capabilities. So first, we need to create a Model to represent the <code class="literal">film</code> table. In this chapter, we are going to use the MVVM approach, so we can dive into capabilities we have not covered in previous chapters. Once we have this part of the code working, we can work with the relationships between the <code class="literal">category</code>, <code class="literal">language</code>, and <code class="literal">actor</code> tables.</p><div class="section" title="The Film Model"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec82"/>The Film Model</h2></div></div></div><p>First, we <a id="id675" class="indexterm"/>are going to create the Model to represent the <code class="literal">film</code> table. Let's not worry about the relationships this table has for now.</p><p>We need to create a new class named <code class="literal">Packt.view.film.FilmsGrid</code>, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.model.film.Film', {
    extend: 'Packt.model.staticData.Base', //#1

    entityName: 'Film',

    idProperty: 'film_id',

    fields: [
        { name: 'film_id' },
        { name: 'title'},
        { name: 'description'},
        { name: 'release_year', type: 'int'},
        { name: 'language_id'},
        { name: 'original_language_id'},
        { name: 'rental_duration', type: 'int'},
        { name: 'rental_rate', type: 'float'},
        { name: 'length', type: 'int'},
        { name: 'replacement_cost', type: 'float'},
        { name: 'rating'},
        { name: 'special_features'}
    ]
});</pre></div><p>As all Sakila <a id="id676" class="indexterm"/>tables have the <code class="literal">last_update</code> column, we will extend <code class="literal">Packt.model.staticData.Base</code> to avoid declaring this field in every single Model we create that represents a Sakila table. The <code class="literal">staticData.Base</code> class also extends <code class="literal">Packt.model.Base</code>, which contains the <code class="literal">schema</code> and <code class="literal">proxy</code> details for our models.</p><p>For the fields, we will have the same ones we have in the <code class="literal">film</code> table.</p></div><div class="section" title="Films ModelView"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Films ModelView</h2></div></div></div><p>Our next<a id="id677" class="indexterm"/> step is to create a ModelView that will contain a Store that will load the collection of films. Let's create a Store named <code class="literal">films</code> (remember that the Store name is always the plural of the name of the Model—if you want to follow the Sencha naming convention) inside the ViewModel, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmsModel', {
    extend: 'Ext.app.ViewModel',

    alias: 'viewmodel.films',

    stores: {
        films: {
            model: 'Packt.model.film.Film', //#1
            pageSize: 15,   //#2
            autoLoad: true, //#3
            session: true   //#4
        }
    }
});</pre></div><p>We need to create a file named <code class="literal">FilmsModel.js</code> inside the <code class="literal">app/view/film</code> folder and put the preceding code inside the file.</p><p>In the <code class="literal">films</code> Store, we <a id="id678" class="indexterm"/>are declaring the <code class="literal">model</code> as usual (<code class="literal">#1</code>), and we are also declaring <code class="literal">pageSize</code> as <code class="literal">15</code> (<code class="literal">#2</code>), meaning we will use the PagingToolbar in the Films data grid, and we will retrieve sets of 15 films per unit time to display in the GridPanel.</p><p>The <code class="literal">autoLoad</code> configuration is also set to <code class="literal">true</code> (<code class="literal">#3</code>). As the ViewModel is created once the View is instantiated, the Store will be loaded once the View is created as well.</p><p>At last, we have a <code class="literal">session</code> configuration (<code class="literal">#4</code>). We have not worked with sessions so far in this book. When we worked with CRUD in the preceding chapter, we used the Store to save the data. In this chapter, we are going to work with associated data, and a session can be really helpful when we need to save data from different models. The session will be created in the View. Having <code class="literal">session: true</code> declared inside a Store inside the ViewModel links the Store with the session of the View. We will discuss how this works later on in this chapter.</p></div><div class="section" title="Film data grid (with paging)"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Film data grid (with paging)</h2></div></div></div><p>Now that <a id="id679" class="indexterm"/>we have the Model and the ViewModel with the Store, we need to create <code class="literal">FilmsGrid</code>, which we can do as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmsGrid', {
    extend: 'Packt.view.base.Grid', //#1
    xtype: 'films-grid',

    bind : '{films}',  //#2

    reference: 'filmsGrid', //#3

    columns: [{
        text: 'Film Id',
        width: 80,
        dataIndex: 'film_id'
    },{
        text: 'Title',
        flex: 1,
        dataIndex: 'title',
     renderer: function(value, metaData, record ){  //#4
            metaData['tdAttr'] = 'data-qtip="' +
                    record.get('description') + '"'; //#5
            return value;
        }
    },{
        text: 'Language',
        width: 100,
        dataIndex: 'language_id'
    },{
        text: 'Release Year',
        width: 110,
        dataIndex: 'release_year'
    },{
        text: 'Length',
        width: 100,
        dataIndex: 'length',
        renderer: function(value, metaData, record ){ //#6
            return value + ' min';
        }
    },{
        text: 'Rating',
        width: 70,
        dataIndex: 'rating'
    }]
});</pre></div><p>As our application <a id="id680" class="indexterm"/>starts to grow, we notice that we use some of the configurations in different components. For example, for most of the GridPanels, we use a toolbar with the <span class="strong"><strong>Add</strong></span>, <span class="strong"><strong>Edit</strong></span> and <span class="strong"><strong>Delete</strong></span> buttons, or we can use a toolbar with the <span class="strong"><strong>Add</strong></span> button and have the <span class="strong"><strong>Edit</strong></span> and <span class="strong"><strong>Delete</strong></span> buttons inside the grid as Widget Columns (or Action Columns). As all tables from the Sakila database have the <code class="literal">Last Update</code> column, this column is also common to all the GridPanels we use to list information from Sakila tables. For this reason, we can create a super GridPanel (as we did specifically for the static data module). So, for the Films GridPanel, we will extend from <code class="literal">base.Grid</code> (<code class="literal">#1</code>) that we will create next.</p><p>Having declared the ViewModel already, we can <code class="literal">bind</code> the <code class="literal">films</code> Store in this grid as well (<code class="literal">#2</code>). To make our job easier later, we will also declare <code class="literal">reference</code> for this grid (<code class="literal">#3</code>).</p><p>Then, we have the columns mapping <code class="literal">dataIndex</code> with the field of the Film Model. When we want to manipulate the information that is going to be displayed in the grid, we can use the <code class="literal">renderer</code> function. For the length column, we want to display the length and <code class="literal">'min'</code> because the length of a film is based in minutes. So, we can return the value itself (length) concatenated to the string we want (<code class="literal">#6</code>).</p><p>Inside the renderer<a id="id681" class="indexterm"/> function, we can also use other fields to manipulate the information by retrieving the desired field from <code class="literal">record</code>. For example, inside the <code class="literal">renderer</code> function (<code class="literal">#4</code>) of the title column, we want to display a tooltip with the film's <code class="literal">description</code> (<code class="literal">#5</code>) when the user does a mouse over on the title column. But we are not changing the value that is going to be displayed, which is <code class="literal">title</code> (<code class="literal">value</code> parameter of the <code class="literal">renderer</code> function) itself.</p><div class="section" title="Creating the Base Grid"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec41"/>Creating the Base Grid</h3></div></div></div><p>To create the<a id="id682" class="indexterm"/> base <code class="literal">Grid</code> class, we are going to create a new base folder named <code class="literal">base</code> inside <code class="literal">app/view</code> so that we can place all our <code class="literal">base</code> classes. Then we are going to create a new file named <code class="literal">Grid.js</code> with the following content:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.base.Grid', {
    extend: 'Ext.grid.Panel',

    requires: [
        'Packt.util.Glyphs'
    ],

    columnLines: true,
    viewConfig: {
        stripeRows: true
    },

    initComponent: function() {
        var me = this;

        me.columns = Ext.Array.merge(
            me.columns,
            [{
                xtype    : 'datecolumn',
                text     : 'Last Update',
                width    : 150,
                dataIndex: 'last_update',
                format: 'Y-m-j H:i:s',
                filter: true
            },{
                xtype: 'widgetcolumn',
                width: 50,
                sortable: false,
                menuDisabled: true,
                widget: {
                    xtype: 'button',
                    glyph: Packt.util.Glyphs.getGlyph('edit'),
                    tooltip: 'Edit',
<span class="strong"><strong>                    handler: 'onEdit'   //#1</strong></span>
                }
            },{
                xtype: 'widgetcolumn',
                width: 50,
                sortable: false,
                menuDisabled: true,
                widget: {
                    xtype: 'button',
                    glyph: Packt.util.Glyphs.getGlyph('destroy'),
                    tooltip: 'Delete',
<span class="strong"><strong>                    handler: 'onDelete'  //#2</strong></span>
                }
            }]
        );

        me.callParent(arguments);
    }
});</pre></div><p>We have <a id="id683" class="indexterm"/>created a similar class to this one in <a class="link" href="ch07.html" title="Chapter 7. Static Data Management">Chapter 7</a>, <span class="emphasis"><em>Static Data Management</em></span>. However, this class has something different. In lines <code class="literal">#1</code> and <code class="literal">#2</code> we are declaring a <code class="literal">handler</code> that is going to be handled in the ViewController. Working with MVVM and Widget Columns is much simpler than working using the MVC approach because we do not need to fire a custom event; we can simply declare the <code class="literal">onEdit</code> and <code class="literal">onDelete</code> methods inside the ViewController.</p></div><div class="section" title="Adding the RowExpander plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec42"/>Adding the RowExpander plugin</h3></div></div></div><p>Let's go <a id="id684" class="indexterm"/>back to the <code class="literal">FilmsGrid</code> class and add the <code class="literal">RowExpander</code> plugin. The <code class="literal">film</code> table has more columns than the ones we are displaying inside the <code class="literal">FilmsGrid</code> class. We can use the <code class="literal">RowExpander</code> plugin to display other information.</p><p>We are going to add the following code inside the <code class="literal">FilmsGrid</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">plugins: [{
    ptype: 'rowexpander',
    rowBodyTpl: [
        '&lt;b&gt;Description:&lt;/b&gt; {description}&lt;/br&gt;',
        '&lt;b&gt;Special Features:&lt;/b&gt; {special_features}&lt;/br&gt;',
        '&lt;b&gt;Rental Duration:&lt;/b&gt; {rental_duration}&lt;/br&gt;',
        '&lt;b&gt;Rental Rate:&lt;/b&gt; {rental_rate}&lt;/br&gt;',
        '&lt;b&gt;Replacement Cost:&lt;/b&gt; {replacement_cost}&lt;/br&gt;'
    ]
}]</pre></div><p>We need to<a id="id685" class="indexterm"/> configure a template to display the extra information we want. In this case, we are displaying the <code class="literal">description</code> of the film and some other information that could not fit on the columns, such as the <code class="literal">rental</code> information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>For more information about the template, you can visit <a class="ulink" href="http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template">http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template</a> and <a class="ulink" href="http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate">http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate</a>.</p></div></div><p>Unfortunately, it is not possible to use the <code class="literal">RowExpander</code> plugin with the associated models. If we want to display associated data, we can use the <code class="literal">SubTable</code> plugin. It is also not possible to use the <code class="literal">RowExpander</code> and <code class="literal">SubTable</code> plugins at the same time.</p><p>With the preceding code, a new column will be added in the Grid so that we can see this extra information:</p><div class="mediaobject"><img src="graphics/0457OT_08_07.jpg" alt="Adding the RowExpander plugin"/></div></div><div class="section" title="Actor-Language – handling a hasOne association"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec43"/>Actor-Language – handling a hasOne association</h3></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, <span class="emphasis"><em>User Management</em></span>, we handled the <a id="id686" class="indexterm"/>relationship between the <code class="literal">User</code> and <code class="literal">Group</code> models using a <code class="literal">hasOne</code> association by adding a new field in the <code class="literal">User</code> Model (creating a <code class="literal">User</code> Model section). We will learn a different way to display a <code class="literal">hasOne</code> association in the grid in this chapter.</p><p>A film has a <a id="id687" class="indexterm"/>
<code class="literal">hasOne</code> association with language (language has a <code class="literal">hasMany</code> association with film). We will display the language <code class="literal">name</code> instead of <code class="literal">language_id</code> using a <code class="literal">renderer</code> function as demonstrated in the following code:</p><div class="informalexample"><pre class="programlisting">dataIndex: 'language_id',
renderer: function(value, metaData, record ){
   var languagesStore = Ext.getStore('staticData.Languages'); //#1
   var lang = languagesStore.findRecord('language_id', value);//#2
   return lang != null ? lang.get('name') : value;            //#3
} </pre></div><p>We will take <a id="id688" class="indexterm"/>advantage of the fact that the <code class="literal">Languages</code> Store was created within the global scope of the application (which we created in <a class="link" href="ch07.html" title="Chapter 7. Static Data Management">Chapter 7</a>, <span class="emphasis"><em>Static Data Management</em></span>) and use this. This way, we do not need to load the language <code class="literal">name</code> from the server again. So, we are going to retrieve the Store (<code class="literal">#1</code>) using the store manager and search for the <code class="literal">Language</code> Model that has <code class="literal">language_id</code>, which we are looking for (<code class="literal">#2</code>). If the value exists, then we display it; otherwise, we display the <code class="literal">language_id</code> parameter anyway (<code class="literal">#3</code>).</p><p>Even though <a id="id689" class="indexterm"/>Ext JS has the capability to load the information from the server and parse using the association capability, is it worth using it in this scenario since we already have a Store with the values we need loaded? If we do use association, it means that more data will be loaded from the server, and some of them can be duplicated for a different Model (in this case, all films have <code class="literal">language_id</code> as <code class="literal">1</code>, which is English). So the same language Model would be loaded several times, and the JSON we would load from the server would be larger.</p></div><div class="section" title="Adding the PagingToolbar"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec44"/>Adding the PagingToolbar</h3></div></div></div><p>Next, we <a id="id690" class="indexterm"/>are going to declare a PagingToolbar. Inside the <code class="literal">FilmsGrid</code> class, we are going to add the following code:</p><div class="informalexample"><pre class="programlisting">dockedItems: [{
    dock: 'bottom',
    xtype: 'pagingtoolbar',
    bind : {
        store: '{films}' //#1
    },
    displayInfo: true,
    displayMsg: 'Displaying films {0} - {1} of {2}',
    emptyMsg: "No films to display"
}]</pre></div><p>The PagingToolbar is a special toolbar that is bound to a Store. For this reason, we need to specify the Store (<code class="literal">#1</code>). In this case, it will be the same Store we declared in <code class="literal">FilmsGrid</code>.</p><div class="section" title="Handling paging on the server side"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec19"/>Handling paging on the server side</h4></div></div></div><p>Since we are using the PagingToolbar, it is important to remember a few things. Ext JS provides tools to help us to page the content, but let's emphasize the word "provide". Ext JS will not do the paging for us if we retrieve all the records from the database at once.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>If we want to page data that is already loaded, we can use <code class="literal">PagingMemoryProxy</code> (<code class="literal">Ext.ux.data.PagingMemoryProxy</code>) provided within the Ext JS SDK.</p></div></div><p>If we take a look at the request Ext JS sends to the server, we will find that it sends three extra parameters when we use the PagingToolbar. These parameters are <span class="strong"><strong>start</strong></span>, <span class="strong"><strong>limit</strong></span>, and <span class="strong"><strong>page</strong></span>. For example, as we can see, when we load the GridPanel information for the first time, <span class="strong"><strong>start</strong></span> is <span class="strong"><strong>0</strong></span>, <span class="strong"><strong>limit</strong></span> is the <code class="literal">pageSize</code> configuration we set on the Store (in this case, <span class="strong"><strong>15</strong></span>), and <span class="strong"><strong>page</strong></span> is <span class="strong"><strong>1</strong></span>. The following figure exemplifies this:</p><div class="mediaobject"><img src="graphics/0457OT_08_08.jpg" alt="Handling paging on the server side"/></div><p>When we click on the next page of the GridPanel, <span class="strong"><strong>start</strong></span> will be <span class="strong"><strong>15</strong></span> (0 + <span class="strong"><strong>limit</strong></span> (15) = 15), <span class="strong"><strong>limit</strong></span> will have the value <span class="strong"><strong>15</strong></span> (this value does not change unless we change <code class="literal">pageSize</code> dynamically), and <span class="strong"><strong>page</strong></span> will be <span class="strong"><strong>2</strong></span>. This is demonstrated by the following figure:</p><div class="mediaobject"><img src="graphics/0457OT_08_09.jpg" alt="Handling paging on the server side"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>There is a third-party plugin that can change <code class="literal">pageSize</code> dynamically according to the user's selection at <a class="ulink" href="https://github.com/loiane/extjs4-ux-paging-toolbar-resizer">https://github.com/loiane/extjs4-ux-paging-toolbar-resizer</a>.</p></div></div><p>These parameters help us to page the information on the database as well. For example, for MySQL, we only need <code class="literal">start</code> and <code class="literal">limit</code>, so we need to get them from the request, as follows:</p><div class="informalexample"><pre class="programlisting">$start = $_REQUEST['start'];
$limit = $_REQUEST['limit'];</pre></div><p>Then, when we execute the <code class="literal">SELECT</code> query, we need to add <code class="literal">LIMIT $start, $limit</code> at the end (after the <code class="literal">WHERE</code>, <code class="literal">ORDER BY</code>, <code class="literal">GROUP BY</code> clauses, if any):</p><div class="informalexample"><pre class="programlisting">$sql = "SELECT * FROM film LIMIT $start,  $limit";</pre></div><p>This will bring the information we need from the database.</p><p>Another very important detail is that the PagingToolbar displays the total number of records we have on the database:</p><div class="informalexample"><pre class="programlisting">$sql = "SELECT count(*) as num FROM film";</pre></div><p>So, we also need to return a <code class="literal">total</code> property on the JSON with the count of the table:</p><div class="informalexample"><pre class="programlisting">echo json_encode(array(
  "success" =&gt; $mysqli-&gt;connect_errno == 0,
  "data" =&gt; $result,
  <span class="strong"><strong>"total" =&gt; $total</strong></span>
));</pre></div><p>Then Ext JS will receive all the information required to make the paging work as expected.</p><div class="section" title="Paging queries on MySQL, Oracle, and Microsoft SQL Server"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec02"/>Paging queries on MySQL, Oracle, and Microsoft SQL Server</h5></div></div></div><p>We need to be careful because if we use a different database, the query to page the information directly from the database is different.</p><p>If we were using the Oracle database, the <code class="literal">SELECT</code> query with paging would be as follows:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM
  (select rownum as rn, f.* from
    (select * from film order by film_id) as f
  ) WHERE rn &gt; $start  and rn &lt;= ($start + $limit)</pre></div><p>This would be much more complicated than MySQL. Now let's see Microsoft SQL Server (SQL Server 2012):</p><div class="informalexample"><pre class="programlisting">SELECT  *
FROM ( SELECT ROW_NUMBER() OVER ( ORDER BY film_id ) AS RowNum, *
          FROM films
        ) AS RowConstrainedResult
WHERE   RowNum &gt; $start
    AND RowNum &lt;= ($start + $limit)
ORDER BY RowNum</pre></div><p>In SQL Server 2012<span class="strong"><strong>, </strong></span>it is simpler:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM film
ORDER BY film_id
OFFSET $start ROWS
FETCH NEXT $limit ROWS ONLY</pre></div><p>In Firebird<span class="strong"><strong>,</strong></span> it is also simpler than MySQL:</p><div class="informalexample"><pre class="programlisting">SELECT FIRST $limit SKIP $start * FROM film</pre></div><p>So be careful with the SQL syntax if you are using a different database than MySQL.</p></div></div></div></div></div>
<div class="section" title="Creating the films container"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Creating the films container</h1></div></div></div><p>The next step is <a id="id691" class="indexterm"/>creating the <span class="strong"><strong>Films</strong></span> screen that we<a id="id692" class="indexterm"/> presented at the beginning of this chapter. It consists of a toolbar with a button (<span class="strong"><strong>Add</strong></span>), the Films grid, and two associated grids (Categories and Actors). We are going to create this View in the <code class="literal">Films.js</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.Films', {
    extend: 'Ext.panel.Panel',
    xtype: 'films',

    requires: [
        'Packt.view.base.TopToolBar',
        'Packt.view.film.FilmsGrid',
        'Packt.view.film.FilmActorsGrid',
        'Packt.view.film.FilmCategoriesGrid',
        'Packt.view.film.FilmsModel',
        'Packt.view.film.FilmsController'
    ],

    controller: 'films', //#1
    viewModel: {
        type: 'films'    //#2
    },

    session: true,       //#3

    layout: {
        type: 'vbox',
        align: 'stretch'
    },

    items: [{
        xtype: 'films-grid',  //#4
        flex: 1
    },{
        xtype: 'container',
        split: true,
        layout: {
            type: 'hbox',
            align: 'stretch'
        },
        height: 150,
        items: [{
            xtype: 'film-categories', //#5
            flex: 1
        },{
            xtype: 'film-actors',    //#6
            flex: 2
        }]
    }],

    dockedItems: [{
        xtype: 'top-tool-bar'    //#7
    }]
});</pre></div><p>In this class, we <a id="id693" class="indexterm"/>declared a ViewController (<code class="literal">#1</code>) and also the ViewModel (<code class="literal">#2</code>). The ViewModel was already created, so we need to create the ViewController.</p><p>Next, we have <code class="literal">session</code> (<code class="literal">#3</code>). If provided, this creates a new session instance for this component. As this class is a container for other classes, the session will then be inherited by all child components. We will dive into the session when we work in the ViewController.</p><p>In line <code class="literal">#4</code>, we have the <code class="literal">FilmsGrid</code> class we created. And in lines <code class="literal">#5</code> and <code class="literal">#6</code> ,we have the <code class="literal">categories</code> and <code class="literal">actors</code> grid that we will use to display the many-to-many association.</p><p>We also have <code class="literal">TopToolBar</code> declared in line <code class="literal">#7</code>. This toolbar was created separately, so we can reuse it, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.base.TopToolBar', {
    extend: 'Ext.toolbar.Toolbar',
    xtype: 'top-tool-bar',

    requires: [
        'Packt.util.Glyphs'
    ],

    dock: 'top',
    items: [
        {
            xtype: 'button',
            text: 'Add',
            itemId: 'add',
            glyph: Packt.util.Glyphs.getGlyph('add'),
            listeners: {
                click: 'onAdd'
            }
        }
    ]
});</pre></div><p>We cannot <a id="id694" class="indexterm"/>forget to update the <code class="literal">menu</code> table to reflect the films <code class="literal">xtype</code>:</p><div class="informalexample"><pre class="programlisting">UPDATE `sakila`.`menu` SET `className`='films' WHERE `id`='11';</pre></div><p>We will be adding more buttons to this toolbar in the next chapter.</p><div class="section" title="Handling many-to-many associations"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Handling many-to-many associations</h2></div></div></div><p>The <a id="id695" class="indexterm"/>
<code class="literal">film</code> and <code class="literal">category</code> tables are <a id="id696" class="indexterm"/>associated by a many-to-many relationship. When this happens, a matrix table is created with two columns to hold the IDs of a pair of related entities. There is a matrix table representing the many-to-many relationship between the <code class="literal">film</code> and <code class="literal">category</code> tables, called <code class="literal">film_category</code> and a table called <code class="literal">film_actor</code> representing the many-to-many relationship between <code class="literal">film</code> and <code class="literal">actor</code>.</p><p>To represent a many-to-many relationship in Ext JS, we will add the following code to the <code class="literal">Film</code> Model:</p><div class="informalexample"><pre class="programlisting">manyToMany: {
    FilmCategories: {         //#1
        type: 'Category',     //#2
        role: 'categories',   //#3
        field: 'category_id', //#4
        right: {
            field: 'film_id', //#5
            role: 'films'     //#6
        }
    },
    FilmActors: {
        type: 'Actor',
        role: 'actors',
        field: 'actor_id',
        right: {
            field: 'film_id',
            role: 'films'
        }
    }
}</pre></div><p>For each <a id="id697" class="indexterm"/>many-to-many relationship, we need to define a <code class="literal">name</code> (<code class="literal">#1</code>). The name must be unique within the schema. We also need to<a id="id698" class="indexterm"/> define a <code class="literal">type</code> (<code class="literal">#2</code>). The <code class="literal">type</code> is the name of the <code class="literal">model</code> of the association—we can use <code class="literal">entityName</code> to define the associated Model. We can also define <code class="literal">role</code> (<code class="literal">#3</code>), which will be the name of the method generated to retrieve the associated data. We also need to specify the foreign key (<code class="literal">#4</code>) used to identify the association. As the many-to-many relationship is created between two tables, we can also specify the information that links this Model to the matrix table, which is the <code class="literal">field</code> (foreign key—<code class="literal">#5</code>) and also the <code class="literal">role</code> of the association in the <code class="literal">Category</code> and <code class="literal">Actor</code> models (<code class="literal">#6</code>).</p><p>In the <code class="literal">Category</code> Model, we will also declare the many-to-many association:</p><div class="informalexample"><pre class="programlisting">manyToMany: {
    CategoryFilms: {
        type: 'Film',
        role: 'films',
        field: 'film_id',
        right: {
            field: 'category_id',
            role: 'categories'
        }
    }
}</pre></div><p>And we will do this inside the <code class="literal">Actor</code> Model as well:</p><div class="informalexample"><pre class="programlisting">manyToMany: {
    ActorFilms: {
        type: 'Film',
        role: 'films',
        field: 'film_id',
        right: {
            field: 'actor_id',
            role: 'actors'
        }
    }
}</pre></div><div class="section" title="Loading nested JSON from the server"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec45"/>Loading nested JSON from the server</h3></div></div></div><p>In the <a id="id699" class="indexterm"/>server-side code, we need to retrieve the film information and its categories and actors as well. The JSON that the server will return to Ext JS will have the following format:</p><div class="informalexample"><pre class="programlisting">{
   "success":true,
   "data":[
      {
         "film_id":"1",
         "title":"ACADEMY DINOSAUR",
         "description":"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies",
         "release_year":"2006",
         "language_id":"1",
         "original_language_id":null,
         "rental_duration":"6",
         "rental_rate":"0.99",
         "length":"86",
         "replacement_cost":"20.99",
         "rating":"PG",
         "special_features":"Deleted Scenes,Behind the Scenes",
         "last_update":"2006-02-15 05:03:42",
         "categories":[
            {
               "category_id":"6",
               "name":"Documentary",
               "last_update":"2006-02-15 04:46:27"
            }
         ],
         "actors":[
            {
               "actor_id":"1",
               "first_name":"PENELOPE",
               "last_name":"GUINESS",
               "last_update":"2006-02-15 04:34:33"
            },
            {
               "actor_id":"10",
               "first_name":"CHRISTIAN",
               "last_name":"GABLE",
               "last_update":"2006-02-15 04:34:33"
            }
         ]
      }
   ],
   "total":"1000"
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>The server-side code is included within the source code of this book.</p></div></div><p>If we inspect <a id="id700" class="indexterm"/>a <code class="literal">Film</code> Model instance of the <code class="literal">films</code> Store, we will see that a function/method is created for each of the associations, as follows:</p><div class="mediaobject"><img src="graphics/0457OT_08_10.jpg" alt="Loading nested JSON from the server"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>When accessing <code class="literal">model.actors()</code> or <code class="literal">model.categories()</code>, the methods will return a Store for each association and not an array of the <code class="literal">Actor</code> or <code class="literal">Category</code> Model.</p></div></div><div class="section" title="Changing the ViewModel – chained stores"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec20"/>Changing the ViewModel – chained stores</h4></div></div></div><p>Ext JS <a id="id701" class="indexterm"/>will understand the association and will <a id="id702" class="indexterm"/>be able to create the methods and associated stores, but we need to add the stores to the session as well by adding the <code class="literal">actors</code> and <code class="literal">categories</code> Store in the same ViewModel, as follows:</p><div class="informalexample"><pre class="programlisting">categories: {
<span class="strong"><strong>    source: 'staticData.Categories',</strong></span>
    autoLoad: true,
    session: true
},
actors: {
<span class="strong"><strong>    source: 'staticData.Actors',</strong></span>
    autoLoad: true,
    session: true
}</pre></div><p>Note the <a id="id703" class="indexterm"/>highlighted code. The stores we are creating use existing stores (which we created in the preceding chapter, and which are available<a id="id704" class="indexterm"/> in the global scope of the application through their <code class="literal">storeId</code>) through a <code class="literal">source</code> configuration. This capability was also introduced in Ext JS 5, and it is called a chained store (<code class="literal">Ext.data.ChainedStore</code>). A chained store is a store that is a view of an existing store. The data comes from the <code class="literal">source</code>; however, this view of the store can be sorted and filtered independently without having any impact on the source store. This is very useful when we want to have two different stores with synchronized data, but independent instances.</p></div></div><div class="section" title="Film-Actor – handling many-to-many associations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec46"/>Film-Actor – handling many-to-many associations</h3></div></div></div><p>Now that we <a id="id705" class="indexterm"/>have the many-to-many association<a id="id706" class="indexterm"/> in place, we can create the <code class="literal">FilmActorsGrid</code> class. This class will have the following content:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmActorsGrid', {
    extend: 'Ext.grid.Panel',
    xtype: 'film-actors',

    requires: [
        'Packt.util.Glyphs'
    ],

<span class="strong"><strong>    bind : '{filmsGrid.selection.actors}', //#1</strong></span>
    border: true,

    title: 'Film Actors',
    glyph: Packt.util.Glyphs.getGlyph('actor'),

    columns: [
        {
            text: 'Actor Id',
            width: 80,
            dataIndex: 'actor_id'
        },
        {
            xtype: 'templatecolumn',
            text: 'Actor Name',
            flex: 1,
            tpl: '{first_name} {last_name}' //#2
        }
    ]
});</pre></div><p>This grid <a id="id707" class="indexterm"/>contains a column we have not used so far, which is the Template Column. When using this column, you can create a template to display more than one field (<code class="literal">#2</code>) instead of using a <code class="literal">renderer</code> function to do so.</p><p>The preceding code presents how to display associated data in a detail grid. When we select a film from the <code class="literal">FilmsGrid</code>, the Actors grid will automatically display the associated data by binding the <code class="literal">actors</code> (role of the association) with the Actors grid (<code class="literal">#1</code>).</p></div><div class="section" title="Film-Category – handling many-to-many associations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec47"/>Film-Category – handling many-to-many associations</h3></div></div></div><p>We will <a id="id708" class="indexterm"/>use the same approach used for the <a id="id709" class="indexterm"/>Film-Actor many-to-many associations for the Film-Category many-to-many associations. We will create a class named <code class="literal">FilmCategoriesGrid</code>. This class will have the following content:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmCategoriesGrid', {
    extend: 'Ext.grid.Panel',
    xtype: 'film-categories',

    requires: [
        'Packt.util.Glyphs'
    ],

<span class="strong"><strong>    bind : '{filmsGrid.selection.categories}', //#1</strong></span>
    border: true,

    title: 'Film Categories',
    glyph: Packt.util.Glyphs.getGlyph('category'),

    columns: [
        {
            text: 'Category Id',
            width: 100,
            dataIndex: 'category_id'
        },
        {
            text: 'Category Name',
            flex: 1,
            dataIndex: 'name'
        }
    ]
});</pre></div><p>We will also <code class="literal">bind</code> the Store of this grid to the data loaded from the association (<code class="literal">#1</code>).</p></div></div></div>
<div class="section" title="Creating the ViewController"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Creating the ViewController</h1></div></div></div><p>The missing <a id="id710" class="indexterm"/>piece now is the ViewController, which will handle all the handlers and listeners declared in our code. We will split the code into two classes: the <code class="literal">base.ViewController</code> that contains generic code and can be reused, and the <code class="literal">film.FilmsController</code> that contains the code to handle specific details of the <code class="literal">Films</code> View.</p><div class="section" title="The base ViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec86"/>The base ViewController</h2></div></div></div><p>Inside this <a id="id711" class="indexterm"/>class, we will put all the generic code that<a id="id712" class="indexterm"/> can be reused by other views that have the same behavior as the <code class="literal">Films</code> View. For example, editing or deleting a record by clicking on a button of a Widget Column opens the pop-up window. If the user clicks on the <span class="strong"><strong>Add</strong></span> button, then close the pop-up window that is used to create or edit information.</p><p>The code for this class is presented as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.base.ViewController', {
    extend: 'Ext.app.ViewController',

    requires: [
        'Packt.util.Util',
        'Packt.util.Glyphs'
    ],

    onAdd: function(button, e, options){ //#1
        this.createDialog(null);
    },

    onEdit: function(button){ //#2
        this.createDialog(button.getWidgetRecord());
    },

    onCancel: function(button, e, options){ //#3
        var me = this;
        me.dialog = Ext.destroy(me.dialog);
    },

    onDelete: function(button, e, options){ //#4
        var record = button.getWidgetRecord();
        Ext.Msg.show({
            title:'Delete?',
            msg: 'Are you sure you want to delete?',
            buttons: Ext.Msg.YESNO,
            icon: Ext.Msg.QUESTION,
            fn: function (buttonId){
                if (buttonId == 'yes'){
                    record.drop();
                }
            }
        });
    }
});</pre></div><p>In the<a id="id713" class="indexterm"/> preceding <a id="id714" class="indexterm"/>chapter, you learned that it is possible to create a generic Controller in MVC to handle events from multiple screens. It was implemented using a generic selector from the components we created. In MVVM, it is also possible to create a generic ViewController, but not using a generic selector (because we do not work with selectors in MVVM). This is possible if we set a pattern of listeners (the components will have the same <code class="literal">handler</code> name), and declare a generic ViewController. However, we also need to specify a specific ViewController for the View, and this ViewContoller is going to extend our base ViewController. Generic code in ViewController is handled by inheritance.</p><p>In the <code class="literal">FilmsGrid</code>, class we have two handlers: one for the <span class="strong"><strong>Edit</strong></span> Widget Button and one for the <span class="strong"><strong>Delete</strong></span> Widget Button.</p><p>For the <span class="strong"><strong>Delete</strong></span> button (<code class="literal">#4</code>), all we have to do is ask whether the user is certain that they want to delete the <code class="literal">record</code>, and then if we receive a positive response, we use the <code class="literal">record.drop()</code> method to do it. The <code class="literal">drop</code> method marks the record as dropped and waiting to be deleted on the server. When a record is dropped, it is automatically removed from all association stores, and any child record associated with this record is also dropped (a cascade delete) depending on the cascade parameter. As the View and the Store are associated with a session, when we call the method <code class="literal">drop</code>, the session records that this record and its associated data need to be deleted, and the Store is also notified. We could also use the remove method from the Store; it would have the same output.</p><p>For the <span class="strong"><strong>Add</strong></span> (<code class="literal">#1</code>) and <span class="strong"><strong>Edit</strong></span> (<code class="literal">#2</code>) handlers, we want to open the <span class="strong"><strong>Edit</strong></span> window so that we can modify or create a new film. We are going to use the same approach we used in <a class="link" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, <span class="emphasis"><em>User Management</em></span>, when we handled <code class="literal">Users</code> and <code class="literal">Groups</code>. The <code class="literal">createDialog</code> method will be created in the specific ViewController, which is the <code class="literal">FilmsController</code> class we will create next. This way we can have a generic code, but the details will be implemented in the specific ViewController.</p><p>A detail for the <code class="literal">edit</code> and <code class="literal">delete</code> handlers is that we can easily use the method <code class="literal">getWidgetRecord</code> from the button (Widget Column) to retrieve the <code class="literal">record</code> from the grid. This approach is<a id="id715" class="indexterm"/> very different from the approach<a id="id716" class="indexterm"/> we used in the preceding chapter (where we created a custom event to be handled in the MVC Controller).</p><p>Just as we did in <a class="link" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, <span class="emphasis"><em>User Management</em></span>, we will create the <span class="strong"><strong>Edit</strong></span> window, and it will have a <span class="strong"><strong>Cancel</strong></span> button. When the user clicks on this button, we will destroy the window (<code class="literal">#3</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>We can go back to <a class="link" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, <span class="emphasis"><em>User Management</em></span>, and modify the code to use this ViewController as well.</p></div></div></div><div class="section" title="Creating the FilmsController"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Creating the FilmsController</h2></div></div></div><p>Now we are <a id="id717" class="indexterm"/>going to implement the ViewController <a id="id718" class="indexterm"/>for the <code class="literal">Films</code> View. Its initial code is presented here; in the subsequent topics, we will add more code to it:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmsController', {
    extend: 'Packt.view.base.ViewController',

    alias: 'controller.films'
});</pre></div></div><div class="section" title="Adding or editing a film"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Adding or editing a film</h2></div></div></div><p>Now<a id="id719" class="indexterm"/> that <code class="literal">FilmsGrid</code> is already being rendered and loaded and the <code class="literal">add</code> and <code class="literal">edit</code> handlers are in place in the ViewController, we need to create the <code class="literal">createDialog</code> method. But first, we need to create the <code class="literal">Edit</code> window class.</p><p>As we <a id="id720" class="indexterm"/>could see in the screenshots at the beginning of this chapter, the <span class="strong"><strong>Edit</strong></span> window has three tabs: one for editing the film details, another one to edit the categories related to the film, and the third one to edit the actors related to the film. For now, we are going to deal with the film details only.</p><p>So, inside <code class="literal">app/view/film</code>, we are going to create a new view named <code class="literal">Packt.view.film.FilmWindow</code>. This class will be a window that has a form with a TabPanel as an <code class="literal">item</code>. Inside each of the tabs, we will place the film's details, the categories, and the actors, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmWindow', {
    extend: 'Packt.view.base.WindowForm', //#1
    xtype: 'film-window',                 //#2

    requires: [
        'Packt.view.film.FilmFormContainer',
        'Packt.view.film.FilmActorsGrid',
        'Packt.view.film.FilmFormCategories'
    ],

    width: 537,

    items: [
        {
            xtype: 'form',
            reference: 'filmForm',  //#3
            layout: {
                type: 'fit'
            },
            items: [{
                xtype: 'tabpanel', //#4
                activeTab: 0,
                items: [{
                    xtype: 'film-form-container', //#5
                    glyph: Packt.util.Glyphs.getGlyph('film')
                },{
                    xtype: 'film-categories-form', //#6
                    glyph: Packt.util.Glyphs.getGlyph('category')
                }
                //film actors here
            ]
        }
    ]
});</pre></div><p>This <a id="id721" class="indexterm"/>window<a id="id722" class="indexterm"/> extends from a custom class (<code class="literal">#1</code>) that we are going to create. As for the creation and editing of grid rows, we always use a window, so we can create a super window class with the common configuration and use it throughout our application. We will create this new class in a minute; let's finish overviewing this class first. We cannot forget to declare an <code class="literal">xtype</code> configuration (<code class="literal">#2</code>); we will use this <code class="literal">xtype</code> configuration in the ViewController later.</p><p>Inside this window, we have a form (<code class="literal">#3</code>), to which we need to declare a reference to easily retrieve in the ViewController. Inside the form we have a TabPanel (<code class="literal">#4</code>), which contains a tab with the film information (<code class="literal">#5</code>)—we are going to create a separate class for it, and the <a id="id723" class="indexterm"/>categories (<code class="literal">#6</code>), for which we are also going to create a separate class.</p><p>The last <a id="id724" class="indexterm"/>piece of this class is the actors details that are presented in the following code:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'film-actors',    //#7
    reference: 'actorsGrid', //#8
    dockedItems: [{
        dock: 'top',
        items: [
            {
                xtype: 'button',
                text: 'Search and Add',
                glyph: Packt.util.Glyphs.getGlyph('searchAndAdd'),
                listeners: {
                    click: 'onAddActor' //#9
                }
            },
            {
                xtype: 'button',
                text: 'Delete',
                glyph: Packt.util.Glyphs.getGlyph('destroy'),
                listeners: {
                    click: 'onDeleteActor' //#10
                }
            }
        ]
    }]
}</pre></div><p>For the actors details, we are going to reuse the <code class="literal">Actors</code> grid (<code class="literal">#7</code>) displayed in the <code class="literal">Films</code> View. We are going to add a reference as well (<code class="literal">#8</code>), because it is going to be useful when we work on the <span class="strong"><strong>Search and Add</strong></span> screen to handle the <code class="literal">onAddActor</code> (<code class="literal">#9</code>) listener. And at last, we also need a listener for the delete button (<code class="literal">#10</code>).</p><p>The <span class="strong"><strong>Add</strong></span> and <span class="strong"><strong>Delete</strong></span> actor buttons are going to add and delete entries of the <code class="literal">film_actor</code> table.</p><div class="section" title="Packt.view.base.WindowForm"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec48"/>Packt.view.base.WindowForm</h3></div></div></div><p>All <a id="id725" class="indexterm"/>the <span class="strong"><strong>Edit</strong></span> windows we have already <a id="id726" class="indexterm"/>implemented are a window with Fit layout and usually have a FormPanel inside it. The window also has a <span class="strong"><strong>Cancel</strong></span> and a <span class="strong"><strong>Save</strong></span> button. As all these configurations are default for our components, we can create a super window for them:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.base.WindowForm', {
    extend: 'Ext.window.Window',
    alias: 'widget.windowform',

    requires: [
        'Packt.util.Util',
        'Packt.util.Glyphs',
        'Packt.view.base.CancelSaveToolbar'
    ],

    height: 400,
    width: 550,
    autoScroll: true,
    layout: {
        type: 'fit'
    },
    modal: true,
    closable: false,

    bind: {
        title: '{title}', //#1
        glyph: '{glyph}'  //#2
    },

    dockedItems: [{
        xtype: 'cancel-save-toolbar'
    }]
});</pre></div><p>Note that <a id="id727" class="indexterm"/>we <a id="id728" class="indexterm"/>are not declaring a configuration inside the <code class="literal">initConfig</code> method (which is not present in this class). This means this class is a base, and anything can be overridden in a child class.</p><p>An important detail here is that the <code class="literal">title</code> (<code class="literal">#1</code>) and the <code class="literal">glyph</code> (<code class="literal">#2</code>) configurations used in this window can be bound to the information from the ViewModel. We will handle these details in the <code class="literal">createDialog</code> method.</p><p>This window class uses <code class="literal">CancelSaveToolbar</code>. The code for this toolbar is as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.base.CancelSaveToolbar', {
    extend: 'Ext.toolbar.Toolbar',
    xtype: 'cancel-save-toolbar',

    requires: [
        'Packt.util.Glyphs'
    ],

    dock: 'bottom',
    ui: 'footer',
    layout: {
        pack: 'end',
        type: 'hbox'
    },
    items: [
        {
            xtype: 'button',
            text: 'Save',
            glyph: Packt.util.Glyphs.getGlyph('save'),
            listeners: {
                click: 'onSave' //#3
            }
        },
        {
            xtype: 'button',
            text: 'Cancel',
            glyph: Packt.util.Glyphs.getGlyph('cancel'),
            listeners: { 
                click: 'onCancel' //#4
            }
        }
    ]
});</pre></div><p>Inside<a id="id729" class="indexterm"/> the<a id="id730" class="indexterm"/> preceding class there are <code class="literal">listeners</code> for the <span class="strong"><strong>Save</strong></span> button (<code class="literal">#3</code>), which we are going to handle inside the <code class="literal">FilmsController</code> class and for the <span class="strong"><strong>Cancel</strong></span> button (<code class="literal">#4</code>), which is handled by the base ViewController class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>We can go back to the code we implemented in <a class="link" href="ch06.html" title="Chapter 6. User Management">Chapter 6</a>, <span class="emphasis"><em>User Management</em></span>, and <a class="link" href="ch07.html" title="Chapter 7. Static Data Management">Chapter 7</a>, <span class="emphasis"><em>Static Data Management</em></span>, and refactor to use the base classes and toolbar classes. This is what is nice about Ext JS and its object-oriented approach: it allows you to reuse code, and you can refactor it as you can do in any other object-oriented language, and there are no headaches involved.</p></div></div></div><div class="section" title="The films form"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec49"/>The films form</h3></div></div></div><p>The <a id="id731" class="indexterm"/>first item of the TabPanel (<code class="literal">#3</code>) is the <code class="literal">film-form-container</code>. Inside<a id="id732" class="indexterm"/> this class, we are going to declare all the fields that represent the columns of the <code class="literal">film</code> table.</p><p>Let's go back to the Sakila documentation and take a look at the fields of the <code class="literal">film</code> table (<a class="ulink" href="http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html">http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html</a>). You can also refer to the first image of this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">film_id</code>: This<a id="id733" class="indexterm"/> is the primary key of the table and has a unique value. So, for this field, we can use a hidden field to control this.</li><li class="listitem" style="list-style-type: disc"><code class="literal">title</code>: This <a id="id734" class="indexterm"/>is the title of the film. So, we can use a text field for it. The maximum length on the database is 255, so we also need to add validation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">description</code>: This<a id="id735" class="indexterm"/> is a short description or plot summary of the film. As the description can be 5,000 characters in length, we can use a text area to represent it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">release_year</code>: This<a id="id736" class="indexterm"/> is the year in which the movie was released. This can be a numeric field, with a minimum value of 1950 until the current year + 1 (let's say we want to add a film that is going to be released next year).</li><li class="listitem" style="list-style-type: disc"><code class="literal">language_id</code>: This <a id="id737" class="indexterm"/>is a foreign key pointing at the language table. It identifies the language of the film. This can be a combobox with the language Store (already populated when we load the application).</li><li class="listitem" style="list-style-type: disc"><code class="literal">original_language_id</code>: This<a id="id738" class="indexterm"/> is a foreign key pointing at the language table that identifies the original language of the film. This is used when a film has been dubbed in a new language. Also, this can be a combobox with the language Store (already populated when we load the application).</li><li class="listitem" style="list-style-type: disc"><code class="literal">rental_duration</code>: This<a id="id739" class="indexterm"/> is the length of the rental period in days. This can be a number field, with a minimum value of <code class="literal">1</code> and maximum value of <code class="literal">10</code> (let's give a limit to the maximum value).</li><li class="listitem" style="list-style-type: disc"><code class="literal">rental_rate</code>: This is the <a id="id740" class="indexterm"/>cost to rent the film for the period specified in the <code class="literal">rental_duration</code> column. This can also be a number field. The minimum value is <code class="literal">0</code> and the maximum value is <code class="literal">5</code>, and we need to allow decimal values as well.</li><li class="listitem" style="list-style-type: disc"><code class="literal">length</code>: This <a id="id741" class="indexterm"/>is the duration of the film in minutes. The <code class="literal">length</code> column can also be a number field between 1 and 999.</li><li class="listitem" style="list-style-type: disc"><code class="literal">replacement_cost</code>: This<a id="id742" class="indexterm"/> is the amount charged to the customer if the film is not returned or is returned in a damaged state. This is also a numeric field. Let's give a minimum value of <code class="literal">0</code> and maximum value of <code class="literal">100</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rating</code>: This <a id="id743" class="indexterm"/>is the rating assigned to the film. It can be one of <code class="literal">G</code>, <code class="literal">PG</code>, <code class="literal">PG-13</code>, <code class="literal">R</code>, or <code class="literal">NC-17</code>. As these have fixed values, we can represent them on a radio button group or a Combobox. We are going to use a Combobox.</li><li class="listitem" style="list-style-type: disc"><code class="literal">special_features</code>: This <a id="id744" class="indexterm"/>lists which common special features are included on the DVD. It can be zero or more of trailers, commentaries, deleted scenes, and behind the scenes. As this can be one or more, we can use the TagField introduced in Ext JS 5. We can also use checkboxes or a combobox allowing multiple selection.</li></ul></div><p>Let's declare<a id="id745" class="indexterm"/> the class structure first, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmFormContainer', {
    extend: 'Ext.panel.Panel',
    xtype: 'film-form-container',

    requires: [
        'Packt.util.Util',
        'Packt.util.Glyphs'
    ],

    bodyPadding: 10,
    layout: {
        type: 'anchor'
    },
    title: 'Film Information',
    defaults: {
        anchor: '100%',
        msgTarget: 'side',
        labelWidth: 105
    },

    items: [
        //fields
    ]
});</pre></div><p>The fields will be inside a panel (which will become a tab) that uses the Anchor layout, and each field will occupy all available horizontal space (<code class="literal">anchor: 100%</code>). The labels are <code class="literal">105</code> pixels wide, and any error messages will be displayed on the <code class="literal">side</code> of the field. There has been no news for us so far.</p><p>Let's declare the first two fields—<code class="literal">title</code> and <code class="literal">release_year</code>:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'textfield',
    fieldLabel: 'Title',
    afterLabelTextTpl: Packt.util.Util.required,
    bind : '{currentFilm.title}' //#1
},
{
    xtype: 'numberfield',
    fieldLabel: 'Release Year',
    allowDecimals: false,               //#2
    bind : '{currentFilm.release_year}' //#3
},</pre></div><p>Both values <a id="id746" class="indexterm"/>are bound (<code class="literal">#1</code> and <code class="literal">#3</code>) to the fields of a record called <code class="literal">currentFilm</code> (that we will create in <code class="literal">FilmsController</code> later). <code class="literal">Release Year</code> is a numeric field, and as we want the value to be an integer, we will not allow the user to enter decimal numbers (<code class="literal">#2</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>For more information about forms and field validation, please refer to <a class="ulink" href="http://docs.sencha.com/extjs/5.0/components/forms.html">http://docs.sencha.com/extjs/5.0/components/forms.html</a>.</p></div></div><p>Next, we have the language fields, which are as follows:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'combobox',
    fieldLabel: 'Language',
    displayField: 'name',
    valueField: 'language_id',
    queryMode: 'local',
    store: 'staticData.Languages', //#4
    afterLabelTextTpl: Packt.util.Util.required,
    bind : '{currentFilm.language_id}' //#5
},
{
    xtype: 'combobox',
    fieldLabel: 'Original Language',
    displayField: 'name',
    valueField: 'language_id',
    queryMode: 'local',
    store: 'staticData.Languages',
    bind : '{currentFilm.original_language_id}' //#6
},</pre></div><p>As both comboboxes represent language, their configuration is going to be exactly the same except for <code class="literal">fieldLabel</code> and <code class="literal">bind</code> (<code class="literal">#5</code> and <code class="literal">#6</code>).</p><p>Note that we are using the same Store for both fields (<code class="literal">#4</code>) and we want them to have the same values, which means that if the user goes to the language GridPanel on static data and add or change a language, we want these changes to be applied to these stores at the same time, and that is <a id="id747" class="indexterm"/>why we are using the same Store as used by static data module.</p><p>Then we have four numeric fields: <code class="literal">rental_duration</code>, <code class="literal">rental_rate</code>, <code class="literal">length</code>, and <code class="literal">replacement_cost</code>:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'numberfield',
    fieldLabel: 'Rental Duration',
    allowDecimals: false,
    afterLabelTextTpl: Packt.util.Util.required,
    bind : '{currentFilm.rental_duration}'
},
{
    xtype: 'numberfield',
    fieldLabel: 'Rental Rate',
    step: 0.1,
    afterLabelTextTpl: Packt.util.Util.required,
    bind : '{currentFilm.rental_rate}'
},
{
    xtype: 'numberfield',
    fieldLabel: 'Length (min)',
    allowDecimals: false,
    bind : '{currentFilm.length}'

},
{
    xtype: 'numberfield',
    name: 'replacement_cost',
    fieldLabel: 'Replacement Cost',
    step: 0.1,
    afterLabelTextTpl: Packt.util.Util.required,
    bind : '{currentFilm.replacement_cost}'
},</pre></div><p>One thing is very important: whenever we have numeric fields and we want to load them from a Model, we need the field from the Model to be numeric as well (<code class="literal">int</code> or <code class="literal">float</code>); otherwise, the form will not load the values properly.</p><p>Then we have the rating combobox with its <code class="literal">store</code>, as follows:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'combobox',
    fieldLabel: 'Rating',
    displayField: 'text',
    valueField: 'text',
    queryMode: 'local',
    bind: {
        value: '{currentFilm.rating}', //#6
        store: '{ratings}'             //#7
    }
},</pre></div><p>We have the combobox <code class="literal">value</code> (<code class="literal">#6</code>) and a <code class="literal">store</code> (<code class="literal">#7</code>) bound to this <code class="literal">combobox</code>. We are going to create this Store in <code class="literal">FilmsModel</code>.</p><p>And at last, we have <code class="literal">tagfield</code> and <code class="literal">textareafield</code>:</p><div class="informalexample"><pre class="programlisting">{
    xtype: 'tagfield',
    fieldLabel: 'Special Features',
    displayField: 'text',
    valueField: 'text',
    filterPickList: true,
    queryMode: 'local',
    publishes: 'value',
    stacked: true,
    bind: {
        value: '{specialFeatures}', //#8
        store: '{special_features}' //#9
    }
},
{
    xtype: 'textareafield',
    fieldLabel: 'Description',
    bind : '{currentFilm.description}'
}</pre></div><p>Tag field was<a id="id748" class="indexterm"/> introduced in Ext JS 5, and its behavior is very similar to that of a combobox that allows you to select multiple values. To set the selected values, we need to pass an array (<code class="literal">#8</code>). In the <code class="literal">Film</code> Model, <code class="literal">special_features</code> is a string. For this reason, we will handle these values in the ViewModel as well using a formula. We are also going to create a <code class="literal">store</code> configuration (<code class="literal">#9</code>) in the ViewModel to represent this static Store.</p></div><div class="section" title="Film categories"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec50"/>Film categories</h3></div></div></div><p>Now that <a id="id749" class="indexterm"/>we have the film details part covered, we can handle the most complex part, which is the association with the <code class="literal">category</code> and <code class="literal">actor</code> tables. The <code class="literal">category</code> and <code class="literal">actor</code> tables have a many-to-many association with the <code class="literal">film</code> table.</p><p>As declared inside the films form, we are going to declare a new class to represent this tab:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmFormCategories', {
    extend: 'Ext.container.Container',

    xtype: 'film-categories-form',

    requires: [
        'Ext.view.MultiSelector'
    ],

    title: 'Film Categories',

    layout: 'fit',

    items: [{
        xtype: 'multiselector',
        title: 'Selected Categories',
        reference: 'categoriesMultiSelector',

        fieldName: 'name',

        viewConfig: {
            deferEmptyText: false,
            emptyText: 'No categories selected'
        },

        bind: '{currentFilm.categories}', //#1

        search: {
            field: 'name',
            store: {
                type: 'categories', //#2
                autoLoad: true
            }
        }
    }]
});</pre></div><p>This class<a id="id750" class="indexterm"/> contains a <code class="literal">multiselector</code>, which is a new component introduced in Ext JS 5. It created a grid to render the selected values, and it is also going to display a red cross sign to remove unwanted values. We can set any selected values in its Store (<code class="literal">#1</code>). This component also allows you to add values using the plus sign that is configured by the <code class="literal">search</code> configuration. We also need to set a <code class="literal">store</code> (<code class="literal">#2</code>) to<a id="id751" class="indexterm"/> feed the options the user can select.</p></div><div class="section" title="Film Actors"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec51"/>Film Actors</h3></div></div></div><p>The <a id="id752" class="indexterm"/>actor relationship with the film is very similar to the relationship between <code class="literal">category</code> and <code class="literal">film</code> tables, meaning it is also a many-to-many relationship. We will handle the <code class="literal">actor</code> tables' many-to-many relationship in a way that is different from how we handled <code class="literal">film_categories</code>. As the available options for categories are limited, we could use a <code class="literal">multiselector</code> component to represent it. We do not know how many actors we can have in our database, so it is a little bit more complicated. The approach we are going to use here is to display a grid to render the selected actors and have an <span class="strong"><strong>Add</strong></span> button so that the user can search for and add desired values.</p><p>We have declared the grid inside the <code class="literal">FilmWindow</code> class already. What is pending is the class that will display a pop up so that we can search for available Actors.</p><div class="section" title="Search Actors – Live Search combobox"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec21"/>Search Actors – Live Search combobox</h4></div></div></div><p>The <a id="id753" class="indexterm"/>idea of the<a id="id754" class="indexterm"/> Live Search combobox is to display the <span class="strong"><strong>Search</strong></span> screen for the user and a combobox field, where the user can enter a few characters and then the system will do a live search, displaying the actors that match the search made by the user. All the actors that match the search will be displayed as items of the combobox, and the combobox will also have paging. When the user selects the actor, we will display its <code class="literal">last_name</code> and <code class="literal">first_name</code>. Along with the actor name, we will also display a list of films this actor has acted in.</p><div class="section" title="Model"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec03"/>Model</h5></div></div></div><p>First, we <a id="id755" class="indexterm"/>need a Model to represent the information we want to retrieve from the server. We will retrieve the actors information plus the film the actor already made. So, we can create a Model extending from the <code class="literal">Actor</code> Model, and in the <code class="literal">SearchActor</code> Model, we only need to declare the missing field:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.model.film.SearchActor', {
    extend: 'Packt.model.staticData.Actor',

    fields: [
        { name: 'film_info' }
    ]
});</pre></div></div><div class="section" title="Store"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec04"/>Store</h5></div></div></div><p>Next, we need a <a id="id756" class="indexterm"/>Store to load the <code class="literal">SearchActor</code> Model collection, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.store.film.SearchActors', {
    extend: 'Ext.data.Store',

    requires: [
        'Packt.model.film.SearchActor'
    ],

    alias: 'store.search-actors',

    model: 'Packt.model.film.SearchActor',

    pageSize: 2,

    proxy: {
        type: 'ajax',
        url: 'php/actor/searchActors.php',

        reader: {
            type: 'json',
            rootProperty: 'data'
        }
    }
});</pre></div><p>On the server, we will use the <code class="literal">actor_info</code> view to retrieve the information. However, the combobox also passes three extra parameters: <code class="literal">start</code> and <code class="literal">limit</code> for the paging and a parameter named <code class="literal">query</code> with the text the user entered to do the live search.</p><p>Our <code class="literal">SELECT</code> query will be something like the following:</p><div class="informalexample"><pre class="programlisting">$start = $_REQUEST['start'];
$limit = $_REQUEST['limit'];
$query = $_REQUEST['query'];

//select the information
$sql = "SELECT * FROM actor_info ";
$sql .= "WHERE first_name LIKE '%" . $query . "%' OR ";
$sql .= "last_name LIKE '%" . $query . "%' ";
$sql .= "LIMIT $start,  $limit";</pre></div><p>And as we are <a id="id757" class="indexterm"/>working with paging, we cannot forget to <code class="literal">COUNT</code> how many records we have that match the search and return the result inside the <code class="literal">total</code> attribute of the JSON:</p><div class="informalexample"><pre class="programlisting">$sql = "SELECT count(*) as num FROM actor_info ";
$sql .= "WHERE first_name LIKE '%" . $query . "%' OR ";
$sql .= "last_name LIKE '%" . $query . "%' ";</pre></div><p>And now, we are able to retrieve the information according to the search text entered by the user.</p></div><div class="section" title="Live Search combobox"><div class="titlepage"><div><div><h5 class="title"><a id="ch08lvl5sec05"/>Live Search combobox</h5></div></div></div><p>Our next step <a id="id758" class="indexterm"/>now is to implement the view that is going to provide the tools for searching. So, we are going to create a class that extends from <code class="literal">Ext.window.Window</code>, and inside this class, we will have a combobox that will provide all the features to do the Live Search. The code is presented as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.film.FilmSearchActor', {
    extend: 'Ext.window.Window',
    xtype: 'search-actor',

    requires: [
        'Packt.store.film.SearchActors'
    ],

    width: 600,
    bodyPadding: 10,
    layout: {
        type: 'anchor'
    },
    title: 'Search and Add Actor',
    autoShow: true,
    closable: false,
    glyph: Packt.util.Glyphs.getGlyph('searchAndAdd'),
    reference: 'search-actor',

    items: [
        {
            //combobox // #1
        }, {
            xtype: 'component',
            style: 'margin-top:10px',
            html: 'Live search requires a minimum of 2 characters.'
        }
    ]
});</pre></div><p>At the<a id="id759" class="indexterm"/> bottom, there's only a comment for the user to know that they are required to enter at least two characters so that the Live Search can work, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0457OT_08_11.jpg" alt="Live Search combobox"/></div><p>Now, let's see the code for the combobox that goes where <code class="literal">#1</code> is in the previous code:</p><div class="informalexample"><pre class="programlisting">xtype: 'combo',
reference: 'comboActors',   //#2
displayField: 'first_name', //#3
valueField: 'actor_id',     //#4
typeAhead: false,
hideLabel: true,
hideTrigger:true,           //#5
anchor: '100%',
minChars: 2,                //#6
pageSize: 2,                //#7
store: {
    type: 'search-actors'   //#8
},

displayTpl: new Ext.XTemplate( //#9
        '&lt;tpl for="."&gt;' +
        '{[typeof values === "string" ? values : values["last_name"]]}, ' +
        '{[typeof values === "string" ? values : values["first_name"]]}' +
        '&lt;/tpl&gt;'
),

listConfig: {                //#10
    loadingText: 'Searching...',
    emptyText: 'No matching posts found.',

    // Custom rendering template for each item
    getInnerTpl: function() {
        return '&lt;h3&gt;&lt;span&gt;{last_name}, {first_name}&lt;/span&gt;&lt;/h3&gt;&lt;/br&gt;' +
            '{film_info}';
    }
}</pre></div><p>To get <a id="id760" class="indexterm"/>started, we are going to declare <code class="literal">reference</code> so that we can easily retrieve this component in the ViewController later (<code class="literal">#2</code>). As always, we need a <code class="literal">store</code> declaration (<code class="literal">#8</code>) to populate the combobox. In this example, we are instantiating the Store by its type. For this reason, we need to declare the full name of the Store in the <code class="literal">requires</code> of this class.</p><p>Then we need <code class="literal">displayField</code> (<code class="literal">#3</code>). The <code class="literal">displayField</code> will only show the <code class="literal">first_name</code> of the actor when an actor is selected from the Live Search. However, we want to display <code class="literal">last_name</code> and <code class="literal">first_name</code>. So to be able to do it, we need to overwrite the <code class="literal">displayTpl</code> template (<code class="literal">#9</code>). This is the result we will get:</p><div class="mediaobject"><img src="graphics/0457OT_08_12.jpg" alt="Live Search combobox"/></div><p>Next, we have <code class="literal">valueField</code> (<code class="literal">#4</code>), which is the ID of the selected actor; we are going to hide the down arrow (called <code class="literal">trigger</code>—<code class="literal">#5</code>) to make the Live Search work. The user needs to enter at least two characters (<code class="literal">#6</code>), and the combobox will display only two actors per page (<code class="literal">#7</code>).</p><p>Then, we have <code class="literal">listConfig</code> (<code class="literal">#10</code>), where we can configure the loading text and the empty text, and also the template to display the actor's information. Basically, we are displaying <code class="literal">last_name</code>, <code class="literal">first_name</code> at the top and in bold, and on the next line, we are displaying all the films already made by this actor.</p></div></div></div></div><div class="section" title="Complementing the ViewModel"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec89"/>Complementing the ViewModel</h2></div></div></div><p>There are two<a id="id761" class="indexterm"/> pending things we need to do in the ViewModel: add the <code class="literal">ratings</code> and <code class="literal">special_features</code> stores<a id="id762" class="indexterm"/> and also implement the <code class="literal">specialFeatures</code> formula that we used to <code class="literal">bind</code> in the film details form.</p><p>So let's begin declaring the stores to our ViewModel, as follows:</p><div class="informalexample"><pre class="programlisting">ratings: {
    model: 'Packt.model.TextCombo',
    data : [ // ENUM('G','PG','PG-13','R','NC-17')
        ['G'],
        ['PG'],
        ['PG-13'],
        ['R'],
        ['NC-17']
    ],
    session: true
},
special_features: {
    model: 'Packt.model.TextCombo',
    data : [
        ['Trailers'],
        ['Commentaries'],
        ['Deleted Scenes'],
        ['Behind the Scenes']
    ],
    session: true
}</pre></div><p>Both stores have predefined <code class="literal">data</code>, meaning they are an instance of the ArrayStore. This kind of Store is very useful in situations like this. The Model both stores are using is listed as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.model.TextCombo', {
    extend: 'Ext.data.Model',

    idProperty: 'text',

    fields: [
        { name: 'text' }
    ]
});</pre></div><p>The Model is very simple, with a single field. We can reuse this Model for any Store we create to be used in comboboxes.</p><div class="section" title="Working with formulas and two-way data binding"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec52"/>Working with formulas and two-way data binding</h3></div></div></div><p>We created a <a id="id763" class="indexterm"/>tag field to declare the special features of a film. This field requires an array of values to be set and also an array of values to be returned as field values. The out field <code class="literal">special_features</code> in the Model is a string, which clearly is not an array! Until Ext JS 4, we had to encode and decode the values manually in a Controller (or somewhere else in the code, but preferably in a Controller). With Ext JS 5 and the introduction of the ViewModel we can use a capability called formulas.</p><p>It is possible to create simple formulas similar to the extra <code class="literal">fields</code> we can declare in a Model (we declare <code class="literal">groupName</code> in the <code class="literal">User</code> Model), and it is also possible to declare more complex <code class="literal">formulas</code>. In the Ext JS examples, we can find some examples of how to use simple <code class="literal">formulas</code>.</p><p>Let's take a look at the formula named <code class="literal">specialFeatures</code> that we bound to <code class="literal">tagfield</code> in the <code class="literal">FilmFormContainer</code> class:</p><div class="informalexample"><pre class="programlisting">formulas: {
    specialFeatures : { //#1

        bind: {
            bindTo: '{currentFilm.special_features}', //#2
            deep: true                                //#3
        },

        get: function(value){ //#4
            var values = value ? value.split(',') : [],
                texts = [];
            values.forEach(function(item){
                texts.push(Ext.create('Packt.model.TextCombo',{
                    text: item
                }));
            });
            return texts;
        },

        set: function(value){ //#5
            if (value){
                this.get('currentFilm').set('special_features', value.join());
            }
        }
    }
}</pre></div><p>The first thing we need to do is give a name to our <code class="literal">formulas</code> declaration (<code class="literal">#1</code>). We can <code class="literal">bind</code> our formula to an existing value (such as selection). In our case, we are binding to the <code class="literal">special_features</code> attribute of <code class="literal">currentFilm</code> ((<code class="literal">#2</code>)—which we will pass to the <span class="strong"><strong>Edit</strong></span> window later in the ViewController). We are also specifying that this is a <code class="literal">deep</code> data binding (<code class="literal">#3</code>), which means any change that happens in <code class="literal">currentFilm.special_features</code> will update the formula, or any update that happens in the formula through its methods will update <code class="literal">currentFilm.special_features</code> as well.</p><p>We can also define <a id="id764" class="indexterm"/>a getter and a setter method to a formula. First, we are defining a <code class="literal">get</code> method (<code class="literal">#4</code>). This method receives the <code class="literal">value</code> from <code class="literal">currentFilm.special_features</code>, splits the string, and transforms it into an array, and will be used by the tag field. Likewise, we have a <code class="literal">set</code> method (<code class="literal">#5</code>), which will receive the <code class="literal">value</code> set in the tag field, transform it into a string, and update <code class="literal">currentFilm.special_features</code>. Just keep in mind that <code class="literal">currentFilm</code> is an instance of the <code class="literal">Film</code> Model.</p></div></div></div>
<div class="section" title="The Films ViewController"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>The Films ViewController</h1></div></div></div><p>In <a id="id765" class="indexterm"/>past chapters, we have already covered some examples <a id="id766" class="indexterm"/>of how to save data. We used the form <code class="literal">submit</code>, an Ajax <code class="literal">request</code>, and also the writing resource from the Store. In this chapter, let's focus on functionalities we have not implemented yet. Do not worry. The complete implementation is available within the source code distributed with this book.</p><div class="section" title="The createDialog method"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec90"/>The createDialog method</h2></div></div></div><p>We <a id="id767" class="indexterm"/>created all the views for our application. In the base <span class="strong"><strong>ViewController</strong></span>, we created the handlers for the Add and Edit buttons, and both call the <code class="literal">createDialog</code> method, which we are going to develop now.</p><p>The idea is to display a blank <span class="strong"><strong>Edit</strong></span> window in case the user clicks on the <span class="strong"><strong>Add</strong></span> button, and to display the selected film in case the user clicks on the <span class="strong"><strong>Edit</strong></span> button. The source code for this method is as follows:</p><div class="informalexample"><pre class="programlisting">createDialog: function(record){

    var me = this,
        view = me.getView(),        //#1
        glyphs = Packt.util.Glyphs;

    me.isEdit = !!record;           //#2
    me.dialog = view.add({          //#3
        xtype: 'film-window',
        viewModel: {                //#4
            data: {                 //#5
                title: record ? 'Edit: ' + record.get('title') : 'Add Film',
                glyph: record ? glyphs.getGlyph('edit') : glyphs.getGlyph('add')
            },
            links: {                     //#6
                currentFilm: record || { //#7
                    type: 'Film',
                    create: true
                }
            }
        },
        session: true //#8
    });

    me.dialog.show(); //#9
}</pre></div><p>The first thing <a id="id768" class="indexterm"/>we are going to do is get the reference of the View, which is the <code class="literal">Films</code> class (<code class="literal">#1</code>). Next, we are also going to create an <code class="literal">isEdit</code> flag (<code class="literal">#2</code>) and assign it to the ViewController so that we can access other methods later (such as the <code class="literal">save</code> method).</p><p>Then, we are going to instantiate the <span class="strong"><strong>Edit</strong></span> window, adding it to the View (<code class="literal">#3</code>). When we add a child to the main View, it inherits the ViewModel and the ViewController as well. However, in this case, we are setting specific configurations to the <span class="strong"><strong>Edit</strong></span> window ViewModel as well (<code class="literal">#4</code>), meaning it will have access to whatever configuration is already there plus the ones we are setting, such as <code class="literal">title</code> and <code class="literal">glyph</code>, which is predefined <code class="literal">data</code> (<code class="literal">#5</code>) to this ViewModel.</p><p>Next, we will create a link (<code class="literal">#6</code>) to a record called <code class="literal">currentFilm</code> ((<code class="literal">#7</code>), which we used in the bind configurations in the <span class="strong"><strong>Edit</strong></span> window). If it is an <code class="literal">edit</code>, it will link to the selected row in the grid; otherwise, we create a new <code class="literal">Film</code> Model instance.</p><p>We are also going to create a child <code class="literal">session</code> (<code class="literal">#8</code>) for this View. We are going to discuss <code class="literal">session</code> when we discuss the <code class="literal">save</code> method.</p><p>Finally, we display the <span class="strong"><strong>Edit</strong></span> window pop up (<code class="literal">#9</code>).</p></div><div class="section" title="Getting the selected actor from Live Search"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec91"/>Getting the selected actor from Live Search</h2></div></div></div><p>When a user searches for <a id="id769" class="indexterm"/>an actor and clicks on <code class="literal">Add Selected</code>, we will have to handle the event in the ViewController in the <code class="literal">onSaveActors</code> methods. The logic for this method is that we need to get the actor ID selected in<a id="id770" class="indexterm"/> the combobox and search for its value in the <code class="literal">actors</code> Store. Once we have the <code class="literal">Actor</code> Model instance, we can add it to the <code class="literal">actorsGrid</code> store. The code is as follows:</p><div class="informalexample"><pre class="programlisting">onSaveActors: function(button, e, options){
    var me = this,
        value = me.lookupReference('comboActors').getValue(), //#1
        store = me.getStore('actors'),                        //#2
        model = store.findRecord('actor_id', value),          //#3
        actorsGrid = me.lookupReference('actorsGrid'),        //#4
        actorsStore = actorsGrid.getStore();                  //#5

    if (model){
        actorsStore.add(model); //#6
    }

    me.onCancelActors(); //#7
}  </pre></div><p>First, we get the reference of the combobox (<code class="literal">#1</code>) and get its <code class="literal">value</code>, which will return the ID of the selected actor. Next, we will get the reference of the <code class="literal">actors</code> Store declared in the <code class="literal">FilmsModel</code> (<code class="literal">#2</code>). We will search for the actor selected in the Store (<code class="literal">#3</code>); it will return the <code class="literal">Actor</code> Model reference or null if the actor does not exist. Then we get the <code class="literal">actorsGrid</code> reference ((<code class="literal">#4</code>)—the one inside the films form), and we also get its Store (<code class="literal">#5</code>).</p><p>If an actor is found, we add to the <code class="literal">actorsGrid</code> Store (<code class="literal">#6</code>). This grid is bound to the selected film actors association, so if an actor is added or deleted from the grid Store, it is also added or deleted from the association. This is another example of two-way data binding in Ext JS 5.</p><p>And at last, we close the Live Search pop up (<code class="literal">#7</code>) with the following method:</p><div class="informalexample"><pre class="programlisting">onCancelActors: function(button, e, options){
    var me = this;
    me.searchActors = Ext.destroy(me.searchActors);
}</pre></div></div><div class="section" title="Saving the form and working with sessions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/>Saving the form and working with sessions</h2></div></div></div><p>Now it is time <a id="id771" class="indexterm"/>to save any data updated, deleted, or created. Any changes we make in the form will be saved to the session (<code class="literal">Ext.data.Session</code>). Sessions <a id="id772" class="indexterm"/>were introduced in Ext JS 5 and are great for when we are working with associations. We added a session to our films View by adding the configuration <code class="literal">session: true</code> in it. Then, all the stores from the ViewModel are also bound to the session, meaning any change made<a id="id773" class="indexterm"/> in the <a id="id774" class="indexterm"/>stores or in the session will be synchronized.</p><p>Let's take a look at the <code class="literal">onSave</code> method:</p><div class="informalexample"><pre class="programlisting">onSave: function(button, e, options){
    var me = this,
        dialog = me.dialog,
        form = me.lookupReference('filmForm'),
        isEdit = me.isEdit,
        session = me.getSession(), //#1
        id;

    if (form.isValid()) {
        if (!isEdit) {
            id = dialog.getViewModel().get('currentFilm').id; //#2
        }
        dialog.getSession().save(); //#3
        if (!isEdit) {
            me.getStore('films').add(session.getRecord('Film', id)); //#4
        }
        me.onCancel();
    }

    var batch = session.getSaveBatch(); //#5
    if (batch){
        batch.start();                  //#6
    }
}</pre></div><p>We are going to get the pending information to be saved from the session and save it in the server. First, we need to get the <code class="literal">session</code> (<code class="literal">#1</code>). Then, we are going to get the film's <code class="literal">id</code> if it is a new film ((<code class="literal">#2</code>)—a random temporary ID is created for every Model in Ext JS, usually with the name of the entity and a sequential number). This <code class="literal">id</code> will be overwritten after we save it in the database and use the database table sequential ID.</p><p>Remember that when we created the dialog, we assigned a child session to the <span class="strong"><strong>Edit</strong></span> window? This allows us to work with the data without committing to it, meaning we can roll back the changes easily by destroying the <span class="strong"><strong>Edit</strong></span> window. When we want to save the data from the child session into the <code class="literal">Films</code> session officially, we can call the <code class="literal">getSession</code> method from the <span class="strong"><strong>Edit</strong></span> window and save it (<code class="literal">#3</code>). This will save the child session data in the <code class="literal">Film</code> session.</p><p>Next, if it is a new film, we also want to add the record to the <code class="literal">films</code> Store (so it can be displayed in the <code class="literal">FilmsGrid</code> as well—(<code class="literal">#4</code>)).</p><p>There are two different ways to save<a id="id775" class="indexterm"/> information <a id="id776" class="indexterm"/>from a session. The first way is using <code class="literal">batch</code> (<code class="literal">Ext.data.Batch</code>) that can be retrieved from the session (<code class="literal">#5</code>), and the second way is executing its method <code class="literal">start</code> (<code class="literal">#6</code>). This will trigger the CRUD operations and will use the <code class="literal">proxy</code> details to connect to the server of the pending models of the session to be saved.</p><div class="section" title="Custom Writer – saving associated data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec53"/>Custom Writer – saving associated data</h3></div></div></div><p>However, the <a id="id777" class="indexterm"/>session does not save associated data. If we create a Film, Category, and Actor, the create operation from each respective Model will be triggered, but the data to be saved in the many-to-many matrix tables will not be sent to the server.</p><p>We can create a custom <code class="literal">writer</code> class that will send any associated data to the server as well in a single batch. Then, we need to handle the proper CRUD operations of the associated data on the server as well. The code is as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.ux.data.writer.AssociatedWriter', {
    extend: 'Ext.data.writer.Json',
    alias: 'writer.associatedjson',

    constructor: function(config) {
        this.callParent(arguments);
    },

    getRecordData: function (record, operation) {
        record.data = this.callParent(arguments);
        Ext.apply(record.data, record.getAssociatedData());
        return record.data;
    }
});</pre></div><p>Then, we need to go back to the <code class="literal">Packt.model.Base</code> class, add this <code class="literal">writer</code> class to the <code class="literal">requires</code> declaration, and change the writer type as follows:</p><div class="informalexample"><pre class="programlisting">writer: {
<span class="strong"><strong>    type: 'associatedjson',</strong></span>
    //...
},</pre></div><p>All associated data will be sent to the server; in the same way, we are receiving a nested JSON from the server when we read information from it.</p></div><div class="section" title="Saving session data manually"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec54"/>Saving session data manually</h3></div></div></div><p>A <a id="id778" class="indexterm"/>second option to save the session data to the server is doing it manually. If we use the <code class="literal">getChanges</code> method of the session, it will return an object with all the pending information to be saved in the server, including associated data.</p><p>For example, if we try to edit a Film, add some Actor information and Category information, and call <code class="literal">JSON.stringify(session. getChanges(), null, 4)</code>, we will have an output similar to the following:</p><div class="informalexample"><pre class="programlisting">{
    "Film": {
        "U": [
            {
                "title": "ACADEMY DINOSAUR - edit",
                "language_id": "2",
                "original_language_id": "3",
                "film_id": "1",
                "id": null
            }
        ],
        "categories": {
            "D": {
                "1": [
                    "6"
                ]
            },
            "C": {
                "1": [
                    "7",
                    "8",
                    "9"
                ]
            }
        },
        "actors": {
            "D": {
                "1": [
                    "1"
                ]
            },
            "C": {
                "1": [
                    "71"
                ]
            }
        }
    }
}</pre></div><p>This means <a id="id779" class="indexterm"/>we are updating (<code class="literal">U</code>) some fields of the Film with ID of <code class="literal">1</code>, deleting (<code class="literal">D</code>) the category with ID of <code class="literal">6</code> from the Film <code class="literal">1</code> and adding (<code class="literal">C</code>) the categories <code class="literal">7</code>, <code class="literal">8</code>, and <code class="literal">9</code> to the Film <code class="literal">1</code> as well. We are also deleting (<code class="literal">D</code>) the Actor <code class="literal">1</code> from Film <code class="literal">1</code> and adding (<code class="literal">C</code>) the Actor <code class="literal">71</code> to the Film <code class="literal">1</code> as well. Note that the <code class="literal">categories</code> and <code class="literal">actors</code> are the names of the many-to-many associations we created for <code class="literal">Film</code> Model.</p><p>We can also use this object to save the data manually in the server.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, you learned how to implement a more complex screen to manage the inventory information from the database. You learned to handle a many-to-many association as well. You learned how to use some different form fields and how to do a Live Search. You also learned how to save data from a session.</p><p>In the next chapter, we will learn how to add some extra capabilities that are not native to the Ext JS API to the screens we have already developed so far, such as print, export to Excel, and export to PDF, the contents of a GridPanel. Also, we will learn how to implement charts and export them to images and PDFs.</p></div></body></html>