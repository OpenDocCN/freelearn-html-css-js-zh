- en: Chapter 4. Making It More Fun!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a chat room. In this chapter, we are going
    to improve on that chat room by giving our users a name, having multiple chat
    rooms, and integrating the express and socket.io sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Giving names to users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a name for our users, chatting becomes difficult. It is impossible to
    identify who sent the message. So let us provide our users with a method by which
    they can set a nickname for themselves, so that a message from them can be identified
    with their name.
  prefs: []
  type: TYPE_NORMAL
- en: We have already worked with the `message` event in socket.io to send and receive
    messages. We also saw the socket.io module's predefined events. In this section,
    we will learn more about those events and also see how we can work with our own
    events. We will also see how we can save some information for the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating the user interface required for accepting a name from
    the user when they come to our chat room. To do this, we will modify the `index.jade`
    file by adding the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is adding a new section for the `modal` overlay. This
    section has a backdrop `div` tag and then a `div` tag for the actual form. The
    look and feel of this will again be defined in the `style.css` file, so let''s
    update that too. Refer to the following code block while modifying the stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we refresh the UI, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving names to users](img/0786_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The username form
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, what we will want to do is when the user enters a name and clicks on
    the **Set Name** button, send the name to the server, store it there, and prefix
    it to every message sent by that user. First, we will change the document ready
    handler to attach an event handler to the **Set Name** button. For this, edit
    `public/javascripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we see a new socket.io API and concept, namely `socket.emit`.
    This is used to trigger custom events. The call for `emit` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We trigger a `set_name` event and pass on the value entered in the username
    box by the user. We also remove the send message event handler from the `socket.emit`
    declaration. We will come back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The events emitted on a socket on one side (server) will be handled on the
    other side of the socket (client). In our case, that is, in the previous code
    snippet, we trigger the `set_name` event on the client, so we will handle it on
    the server. To do this, we will edit `routes/sockets.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the practice of keeping it simple, socket.io uses the same `socket.on` API,
    which we used earlier to handle the `connection` or `message` events, to handle
    custom events. The data passed to the handler function will contain the data we
    had sent when we triggered the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to a new feature of socket.io, that is, attaching additional
    information to the socket for the session. This is achieved using the `socket.set`
    function. The call for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, `<name>` is the name of the key we want to set
    and `<value>` is the value we want to set. The call to `set` is asynchronous;
    it won't be blocked till the value has been set. To perform an action where you
    want to ensure that the value has been set, we can pass a callback to the `set`
    method. In the previous code, we are passing the `callback` function that will
    emit another `name_set` custom event, and will also send the welcome message.
    Like the `set_name` event, the `name_set` event will be handled on the other side
    of the socket, which in this case is the client.
  prefs: []
  type: TYPE_NORMAL
- en: This is great. Now that the name is set, let us put it to some real use by showing
    it with every message so that people in our chat room know who sent the message.
  prefs: []
  type: TYPE_NORMAL
- en: To get a value set on the socket, socket.io provides a `get` method. We will
    use this `get` method to get the username from the socket and append it to the
    previous message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us rework `public/javscripts/chat.js` to handle the `name_set` event and
    then start the actual communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we add two new lines of code to hide the overlay
    and to append the greeting to the `messages` area. Apart from this, we have also
    moved the code to handle the sending and receiving of messages to this handler,
    so that it is set up only after the user has set the name and avoids people from
    just hiding the overlay using Firebug or other similar tools. There is one last
    change in the message received handler; we need to check for the presence of a
    username in the incoming data and prefix it to the displayed message if it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the code in action, let''s restart our node server and refresh the browser.
    Once you enter the name, it will bring up the chat room and show the greeting
    with the name you just entered along with the welcome message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving names to users](img/0786_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Greeting with name
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our chat room in another browser window and sign in as **Friend** this
    time. Enter a message in the new message box and click **Send**. The message appears
    in the message area in both the browsers. Try it from the first chat room you
    have opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving names to users](img/0786_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chat with names
  prefs: []
  type: TYPE_NORMAL
- en: More on events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how we can use custom events over a socket.
    The interesting thing is that just like your messages, events can also be broadcast.
    Let us see how we can use an event broadcast to announce the entry of a participant
    in our chat room.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the first thing we will do is start emitting a new `user_entered`
    event from the server, with the name of the user in the data once the user has
    joined the chat. Let us change our `routes/socket.js` file to do this. We will
    add our code to broadcast the `user_entered` event once the username is set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To send a broadcast to all the clients connected on this socket, we use the
    `emit` method, but on `socket.broadcast` rather than on `socket` itself. The signature
    of the method is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `user_entered` event will be sent to all the connected clients, so
    we will need to add an event handler in the client `chat.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding an event handler for the `user_entered` event and then
    displaying the message to the user. Let us start our server once again and log
    in to our chat room:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More on events](img/0786_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first user's chat room
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open another browser window and log in with a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More on events](img/0786_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second user's chat room
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, in the first user's window, we will see the entrance message
    for both **Friend001** and **Friend002**, and for **Friend002** in the second
    user's (**Friend001**) window.
  prefs: []
  type: TYPE_NORMAL
- en: Working with namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we won't be adding any new functionality to our chat room,
    but instead we will just use a feature of socket.io to make our application design
    better and our code easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We are sending different messages between the client and the server and differentiating
    them by `type`. Wouldn't it be better that we send different messages on different
    messaging channels? Our current approach also doesn't play well and may cause
    conflicts when our application or module is part of a larger system. But then
    there are questions, what will be the cost of opening multiple connections? What
    will be the effect on performance?
  prefs: []
  type: TYPE_NORMAL
- en: This is where namespaces come to the rescue. A namespace provides a way to multiply
    a socket.io connection, so that we get different channels for different types
    of messages without adding a big overhead to the system and its performance. Let
    us see how we can use namespaces in our chat system.
  prefs: []
  type: TYPE_NORMAL
- en: In our chat application, we have two different types of messages or events being
    sent. These are infrastructural, such as setting the name and welcome messages,
    and communication between the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let us go ahead and create two namespaces, namely `chat_com` and `chat_infra`.
    We will send the communication messages (user messages) on `chat_com` and the
    infrastructural messages (welcome, user entry, and so on) on `chat_infra`. For
    this, let us first edit the `socket.js` file, which is on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding code, most of the code remains the same, apart
    from the highlighted snippets and some code reorganization.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing here is separating the messages and events into two code blocks
    corresponding to their namespaces. We use the `io.of` method to create a new namespace.
    Upon creation of the namespace, it can be used as any socket's object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are creating two namespaces and adding a `connection` event
    handler to both of them. One for `chat_infra`, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And another for `chat_com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection is established, we will get a `socket` object in the `connection`
    event handler, which we will use just as we did earlier. In case of `chat_infra`,
    we add all the messaging and events that are not part of the user-to-user communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, we are moving the `set_name` handler, the event emitter for `name_set`,
    messaging for `serverMessage`, and the event broadcaster for `user_entered` to
    the `chat_infra` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This leaves only the standard `User` messaging components on the `chat_com`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how this affects our client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and the most important thing we see in the previous code is that
    we are connecting two sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In fact, socket.io will establish a single socket connection and multiplex the
    two namespaces over it. But establishing these two connections will give us the
    ability to handle the `chat_infra` and `chat_com` namespaces' messages or events
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we are adding the handlers that correspond to
    the emitters for `chat_infra` that we added on the server. The `name_set` handler
    will be on the `chat_infra` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also do the same for the `user_entered` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the `on` handler to listen for the messages on `chat_infra`; this
    will receive all the server messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also emit the `set_name` event on `chat_infra`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `chat_com` namespace, we send the user message, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will attach the handler to receive the user messages relayed from
    the server by using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand namespaces and have made use of them to clean up our
    design and code, let us go ahead and add some new features.
  prefs: []
  type: TYPE_NORMAL
- en: Rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will use another multiplexing feature of socket.io, called
    **rooms**. And we will use it to do just what the name says, create rooms. A chat
    room will be very noisy and confusing if everyone in the network is chatting in
    the same room. So as the first step, let''s move our chat away from the landing
    page of our website to `/chatroom`. For this, we should move our code from `index.jade`
    to `chatroom.jade` and put the following code in `index.jade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we will create a landing page with a welcome message and a link
    to go to the chat room. Let''s also add the following styles for the landing page
    in `style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our landing page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooms](img/0786_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Start now** link will send you to the chat room, but there is nothing
    there yet. So let us modify our `routes/index.js` file to serve `chatroom`. Add
    the following snippet to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also have to add the mapping to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a landing page, we are ready to add multiple rooms. We will
    now add support for the chat room page so that it can accept a `room` parameter
    and will connect to that room when requested. So the call to connect to enter
    the chat room will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For this we need to edit our `chat.js` client script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing is to parse the URL query to get the room name, here is how
    this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the preceding code, we are creating a regex to parse out the value
    between `room=` and `&` or to the end of the content. In the next line, we check
    if a room name was provided and once the user has entered the name, we will join
    the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'To join the room, we emit the `join_room` event with `roomName` as a parameter.
    This event will be handled on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since we will use the room only to restrict the broadcast messages (others are
    anyhow sent only to the recipient's socket), this is all we need to do on the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will edit the `sockets.js` file on our server to handle the `join_room`
    event on `chat_infra` and to change the broadcasts to send messages in the room
    they are meant for. Let us take a look at the changes in `sockets.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So this brings in some minor structural changes. Since we will need to refer
    `chatCom` in `chatInfra`, we add them both to the current object, which is also
    stored as itself, so that they are accessible in the closures. In the `chat_infra`
    connection handler, we register a new event handler for `join_room`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the handler, we are receiving the `room` object, which will in turn have
    the name of the room to join. Next we connect the `chat_infra` socket to the room.
    This is done using the `join` method of the `socket` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `join` method takes a name string for the room. The room will be created
    if not present, else the socket will be connected to an existing room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once our client joins the room, it will get all the messages intended
    for the specific room in the `chat_infra` namespace. But, this will not be useful
    until we also join the room in the `chat_com` namespace. For this, we will need
    to obtain the `socket` object, corresponding to the current `socket` object in
    the `chat_com` namespace and then call the same `join` method on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the corresponding `socket` object on `chat_com`, we fetch it using the
    current `socket` object''s ID (as it will be similar) from the `sockets` array
    in the `chatCom` namespace object. The next line simply calls the `join` method
    on it. Now both have joined the room in both the namespaces. But when we receive
    the messages in the `chat_com` namespace, we will need the name of the room this
    socket is connected to. For this, we will set the `room` property on the `comSocket`
    object to the room it is connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all is set up, we will announce in the room that the user has joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did earlier, we still use `broadcast.emit`, but instead of calling it
    on the socket, we restrict it to be sent only in the room, using `in(room.name)`.
    Another change we make will be that of broadcasting the user messages again by
    restricting them to the room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can open the chat room by going to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this in two browser windows and log in with different names. Open another
    chat room in another browser window using the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The messages and alerts sent only in the room `test001` will be visible in
    the first two browsers, while the one connected to `test002` will not be able
    to see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooms](img/0786_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User one connected to the room test001
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second user connected to the room `test001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooms](img/0786_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User two connected to the room test001
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in the following screenshot, the third user is shown connected to the
    room `test002`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooms](img/0786_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User three connected to the room test002
  prefs: []
  type: TYPE_NORMAL
- en: Listing the rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have support for creating multiple rooms, let us go ahead and add
    a page to list, join, and create new rooms. We will begin by adding a Jade view
    named `rooms.jade` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This view has an input box to accept a new room name and a `div` tag to add
    the list of existing rooms. We are also adding scripts for `socket.io.js` and
    a new script file for our client-side code for listing rooms, namely `rooms.js`.
    Next, create the `rooms.js` script file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are connecting based on the `chat_infra` namespace,
    requesting the chat rooms on it, and rendering them in the view. Let us take a
    quick look at an important step happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the first thing we do after connecting is emit
    an event to `get_rooms`. This will request the list of rooms from the server.
    Next, we set a listener to receive the list of rooms and render them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the handler, as shown in the following code block, we are looping over the
    map of rooms and number of users in them and appending it to the room list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the code to create a new room. To create a new room, all we
    need to do is redirect to the chat room, with the name for the new room in the
    URL parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a `get_rooms` handler on the server to return the list
    of the rooms. For this, we will add the handler on the `chat_infra` namespace
    in `sockets.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the list of all the rooms using `io.sockets.manager` and then we
    can build the map expected by our client by looping over the list. In our case,
    we filter to get rooms only from `chat_infra` as they will also be created in
    `chat_com`, and we don''t want duplicates. Once we have the map, we will emit
    it as `rooms_list`. Following this we will need to add the entry to our `routes/index.js`
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the mapping in `app.js` to server rooms at `/rooms`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let us add some CSS styling for our new room''s page in `style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to `/rooms` and create a few rooms, and then when you open the room''s page
    in a new browser, you''ll see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the rooms](img/0786_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List of rooms on our chat server
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have support for multiple rooms, but it is very clumsy to enter a nickname
    every time we enter a room. Let us modify our system to accept the nickname once
    when entering the system and use it in all the rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, let us start by modifying the landing page to add an input box to
    accept a nickname and add a JavaScript file to add the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the preceding code, we are adding a script entry to add `landing.js`
    and replacing the **Start now** button with the field to enter a name and a **Login**
    button. Next, let us take a look at `landing.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we are attaching a `click` handler to the `startchat`
    button. In the handler, we are adding the nickname entered by the user to the
    cookie and redirecting the user to `/rooms`. We will be reading this cookie information
    while connecting the socket and then setting it on the socket. Before this cookie
    information can be accessed in the socket connection, we need to lay down some
    ground work to enable cookies in the Express.js application. For this, edit the
    `app.js` code by referring to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to add `connect` as a dependency in the `package.json` file
    and the `require` keyword in `app.js`. The `connect` keyword is used to create
    a session store; in this case, an in-memory session store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We also enable the `cookieParser` middleware and the `session` module in the
    express application. Express'' `cookieParser` middleware will take a `secret`
    parameter, which will be used to encrypt the cookies. The express'' `session`
    module is initialized along with passing it the key (`express.sid` is the key
    for a session) and a store where the session should be maintained. In the following
    code, we are passing it an in-memory store, which we created in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'One important point to note about the previous code is the order of adding
    these two middleware components. These should be added after adding the `bodyParser`
    middleware and before adding the `router` middleware. If you open the browser
    and browse to the landing page now, you can see the cookie with the `express.sid`
    key in the browser''s debugging tools under the **Cookies** tab. If you enter
    a name and click the **Enter** button, you will again see a new cookie, named
    after your nickname, being set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change in the preceding code block introduces us to a new feature
    in socket.io; this change is shown in the following highlighted code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we are setting an `authorization` method for the socket.
    This method will get two parameters, the data that contains all the HTTP request
    information and the `accept` method callback. The `authorization` method is called
    when a socket.io connection is requested but before it is established.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this method for actually performing an authorization, but in our
    case we will just use it to get the nickname from the cookies, as this is the
    only socket.io method that will have the HTTP data available with it.
  prefs: []
  type: TYPE_NORMAL
- en: We are reading the cookie headers from the HTTP data and are parsing it using
    the `cookie` module's `parse` method. From the cookie, we are extracting the `sessionID`
    value and the nickname and setting it to the `data` object. This object is available
    on the socket as the `handshake` property. Finally, we will call the `accept`
    callback, which accepts two parameters, first a message and another a Boolean
    variable, indicating whether the authorization was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will remove the `set_name` handler, as this handler need not be called because
    we already have the name with us. We will move the logic from the `set_name` handler
    to the `join_room` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `join_room` handler, we will fetch the nickname from the `socket.handshake`
    map and set it as a property on the socket. On setting the `nickname` property,
    we will still trigger the `name_set` event so as to keep the changes on the client
    to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As the `join_room` handler is the initializer for the room on the server, we
    will take it out of the `name_set` handler and directly call it during the page
    load. The rest of the code remains as is.
  prefs: []
  type: TYPE_NORMAL
- en: To try this code, you will have to open two different browsers or browsers in
    different incognito sessions as the cookies/sessions will be shared for the same
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to set data for a session, how to work with namespaces
    and rooms, and how to integrate with the express sessions. Here we have completed
    a good and working chat system. It will be a nice exercise for you to build more
    functionality in this, based on the concepts we learned here. Some interesting
    features to build can be user exist alert, user list for the rooms, private chats,
    and so on. In the next chapter, we will take a look at the socket.io protocol
    and understand its workings.
  prefs: []
  type: TYPE_NORMAL
