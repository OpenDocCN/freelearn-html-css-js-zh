<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Messaging"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Messaging</h1></div></div></div><p>The previous chapter suggested an architecture that allows your entire application to be divided into subapplications and modules. Subapplications are just separate parts of your application with functionality that is entirely separate from each other.</p><p>The goal when designing your modules and subapplications is to produce an entire system that is integrated but also loosely coupled, and this is where a very well-known technique enters the scene: messaging. The concept of messaging, like the divide and conquer method, has been around for a long time and developers use these types of tools and patterns every day. This pattern tries to provide a way for the components to talk to each other through messages, thus allowing modules to subscribe and publish events on a common message bus.</p><p>The topics that will be covered in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the event aggregator</li><li class="listitem" style="list-style-type: disc">Using the event aggregator of <code class="literal">Marionette.js</code></li><li class="listitem" style="list-style-type: disc">Making applications more extensive with the event aggregator</li><li class="listitem" style="list-style-type: disc">Getting started with <code class="literal">Commands</code></li><li class="listitem" style="list-style-type: disc">Setting up the <code class="literal">RequestResponse</code> object</li></ul></div><div class="section" title="Understanding the event aggregator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Understanding the event aggregator</h1></div></div></div><p>According to <span class="emphasis"><em>Martin Fowler</em></span>, an <a id="id133" class="indexterm"/>Event Aggregator does the following:</p><div class="blockquote"><blockquote class="blockquote"><p>"Channels events from multiple objects into a single object to simplify registration for clients." </p></blockquote></div><p>One of the most useful patterns of modular, scalable, and complex JavaScript applications is the event aggregation. The event aggregator functionality is in a container for events that allow publishers and subscribers of these events to have a channel of communication; however, at the same time, it allows them to work independently without the need for code references between them, so they can be updated or removed without affecting the others. Having said that, note how this decoupling is useful in your modularized applications because new subapps and modules can be added to just make use of your current architecture. In our composite application design, the event aggregator is a powerful way to implement communication among <code class="literal">Marionette.js</code> objects and we will see how we can integrate that in our current code.</p><p>The following is a graphical <a id="id134" class="indexterm"/>explanation of the event aggregator:</p><div class="mediaobject"><img src="graphics/4252OS_06_01.jpg" alt="Understanding the event aggregator"/></div></div></div>
<div class="section" title="Using the event aggregator of Marionette.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Using the event aggregator of Marionette.js</h1></div></div></div><p>The Marionette implementation of the <a id="id135" class="indexterm"/>event aggregator pattern made its way out <a id="id136" class="indexterm"/>of the Marionette core build as it can be found now in a separate distributable file called <code class="literal">backbone.wreqr.js</code>. <a id="id137" class="indexterm"/>This implementation extends from the <code class="literal">backbone.events</code> object. The <a id="id138" class="indexterm"/>following is an example of how to instantiate an event aggregator:</p><div class="informalexample"><pre class="programlisting">var vent = new Backbone.Wreqr.EventAggregator();</pre></div><p>You can start adding listeners that will react to the events triggered:</p><div class="informalexample"><pre class="programlisting">vent.on("do something", function(){
  console.log("im logging a message");
});</pre></div><p>Now, you have a listener that will be expecting an event to be triggered.</p><p>Let's trigger the <code class="literal">do something</code> method:</p><div class="informalexample"><pre class="programlisting">vent.trigger("do something");</pre></div><p>And that's all you need to log the message. Ok, but how can we do this at the application level, the <code class="literal">Marionette. An application</code> object comes with an instance of the <code class="literal">Backbone.Wreqr.EventAggregator</code>. <a id="id139" class="indexterm"/>So by instantiating a Marionette application object, you can start registering listeners to events without the need of instantiating the <code class="literal">EventAggregator</code> object.</p><div class="informalexample"><pre class="programlisting">var myApp = new Backbone.Marionette.Application();</pre></div><p>The following is an example of how to register a listener to an event at the application level:</p><div class="informalexample"><pre class="programlisting">myApp.vent.on("helloWorld", function(){
  alert("Hello World");
});</pre></div><p>The event publisher can now raise the <a id="id140" class="indexterm"/>event anywhere inside the application with the following code:</p><div class="informalexample"><pre class="programlisting">myApp.vent.trigger("helloWorld"); </pre></div><p>As you can see, we don't have to ask the <a id="id141" class="indexterm"/>application to do some work. In this case, to show an alert, we should tell the application object that we need to be notified when work will execute <code class="literal">MyApp.vent.trigger("helloWorld ")</code>, which will display the message.</p><div class="section" title="Making applications more extensive with an event aggregator"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec20"/>Making applications more extensive with an event aggregator</h2></div></div></div><p>To make this pattern <a id="id142" class="indexterm"/>easy to understand, we can use the metaphor of the shopping cart app. The user selects an item to be purchased from the book view. The order view needs to be notified when a new product is added in order to display it and calculate the total.</p><p>For example, we have multiple ways to complete this functionality and the obvious one is to have the order view reference in the book view, so we can either call methods or raise events. But then, we will have, for example, a much coupled design where you cannot delete the order view without affecting the book view. So now, it is time to bring the event aggregator to our application and solve this problem.</p><p>We need a central object that manages the events and the subscribers for those events. For this example, we will use a controller. With this controller and the event aggregator in place, the views will be decoupled from each other. This means that the book view will not contain a reference to the order's view and can be changed without design problems.</p><p>The following is the code for <a id="id143" class="indexterm"/>adding the controller:</p><div class="informalexample"><pre class="programlisting">var cartApp.Controller = App.Controller.extend({
        initialize: function (options) {
            var self = this;
            App.vent.on("itemAdded", function (model) {
                self.addProduct(model);
            });
        },
        addProduct: function (model) {
        //call orders view
        }
});</pre></div><p>When the controller is initialized, we register the listener for the item added. It's expecting to receive parameters from the publisher event and then call the local function. The next step is to create the view that is raising the event.</p><p>The following is the code for adding the view:</p><div class="informalexample"><pre class="programlisting">CartApp.BookItemView = Backbone.Marionette.ItemView.extend({
        template: "#catalogRow",
        tagName: "tr",
        events: {
            'click .btn-primary': 'addItem',
        },

        addItem: function () {
            if (this.$('input').val() &gt; 0) {
               this.model.set({ qty: this.$('input').).).val() });
            App.vent.trigger("itemAdded", this.model);
          }
        },
    });</pre></div><p>This contains a view with a declared event ; this event is to be called from a button located in the view when the <code class="literal">addItem</code> <a id="id144" class="indexterm"/>function is executed. It also raised the <code class="literal">App.vent.trigger("itemAdded", this.model)</code> event; this event is going to be handled by the central object, that is, the controller, and call the order view. Pretty easy right? In this way, we do not have the order view reference here that allows both the views to evolve independently.</p><p>The following is a graphical explanation of the code that we just explained. As you can see, we have the central object, that is, the controller; it contains listeners that will raise the event to refresh the order view after the button is clicked in the book view. You can also update multiple modules <a id="id145" class="indexterm"/>according to your business flow.</p><div class="mediaobject"><img src="graphics/4252OS_06_02.jpg" alt="Making applications more extensive with an event aggregator"/></div><p>This design also allows the controller to have multiple views or modules that listens to the event and responds accordingly. The event aggregator is a powerful pattern with the ability to send messages between modules, allowing applications to be much more decoupled from each other.</p></div></div>
<div class="section" title="Getting started with Commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Getting started with Commands</h1></div></div></div><p>While building an application <a id="id146" class="indexterm"/>using the plain Backbone, you will just have four components: the model, collection, view, and router. By now, we have reviewed some of the objects that Marionette adds, such as the controller and the application, and of course the different kinds of views. Each of these objects aim to reduce the boilerplate and facilitate the process of structuring your application to accomplish the concerned separation in the code, as not everything belongs to the views or the router. We now know that the controller is a perfect place to orchestrate our views, but what about the code snippets that does not belong to a view? It definitely does not make sense to put that code in the router or in the model as it is meant to be used across all applications; for those scenarios, Marionette has the <code class="literal">Commands</code> component.</p><p>In order to instantiate it, we just need the following line:</p><div class="informalexample"><pre class="programlisting">var commands = new Backbone.Wreqr.Commands();</pre></div><p>As you can see, it is also part of the <code class="literal">Wreqr</code> <a id="id147" class="indexterm"/>object, so you can use it by itself. Now, we need to set handlers that will perform the actions once you call them through the execute keyword.</p><div class="informalexample"><pre class="programlisting">  
commands.setHandler("logMessage", function(){
  console.log("Im logging an important message");
});</pre></div><p>The <code class="literal">setHandler</code> function <a id="id148" class="indexterm"/>takes the name of the command and the function that it will execute.</p><p>The following line of code exemplifies the execution of a command using the name of the command as the parameter for the <code class="literal">execute</code> function:</p><div class="informalexample"><pre class="programlisting">commands.execute("logMessage");</pre></div><p>And that's all you need to do in order to set a command and execute it. It's good to know that you can pass parameters to these commands in the same way as in the event aggregator.</p><p>In the following example, we will pass the message to be logged:</p><div class="informalexample"><pre class="programlisting">var commands = new Backbone.Wreqr.Commands();
commands.setHandler("logMessage", function(message){
  console.log(message);
});
commands.execute("logMessage","I am the message to be logged ");</pre></div><p>As you can see, the functions receive the message passed on the execute call. This parameter, of course, can be whatever object you need to pass to the handler.</p><p>Let's now use a command in the BookStore application that we are building, but we are not going to instantiate the <code class="literal">Wrerq</code> <a id="id149" class="indexterm"/>component because the Marionette application object already has an instance of it. So, you can set the handlers of the commands to the application object.</p><p>The following code demonstrates how to set a handler to the application object:</p><div class="informalexample"><pre class="programlisting">var App = new Marionette.Application();

App.commands.setHandler("deleteLocalStorage", function(){
  // code todelete the local storage of the application
});
App.execute("deleteLocalStorage");</pre></div><p>Note that you can call <code class="literal">App.command.execute</code> or just <code class="literal">App.execute</code> plus the name of the command and the result will be the same.</p><p>The handler created in the previous <a id="id150" class="indexterm"/>code is to delete the stored values in the local storage of the browser to remove old entries from previous visits to the site. This code does not belong to any view or controller because the responsibility of those objects differs from what this code is doing. We consider cleaning the local storage of the browser to prevent old and invalid entries in the code that belong to the application level, and having a command for that is very handy.</p><p>We can execute it from any part of the application, but the code is well placed in order to keep your concerns separate. We are sure you will find scenarios in which it makes sense to use commands while using Backbone and Marionette.</p><p>Finally, if you want to remove a handler, you can do it using the following code line:</p><div class="informalexample"><pre class="programlisting">App.commands.removeHandler("deleteLocalStorage");</pre></div><p>For removing all the registered handlers at once, use the instruction <code class="literal">App.commands.removeAllHandlers()</code>.</p></div>
<div class="section" title="Setting up the RequestResponse object"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Setting up the RequestResponse object</h1></div></div></div><p>Finally, the last part of the <code class="literal">Wreqr</code> object is the <code class="literal">RequestResponse</code>, which in our opinion is definitely a nice addition to the <a id="id151" class="indexterm"/>Backbone development. We just saw how we can make different components work together with the help of events in order to communicate each other. We also learned that not all the code belongs to a view or router of the controller, and for those cases, the Marionette commands are definitely a good option in order to keep our concerns separate. Similar to <code class="literal">Commands</code>, the <code class="literal">RequestResponse</code> object can help us split more responsibilities of the code in an application.</p><p>The <code class="literal">RequestResponse</code> object conceptually works in the same way as events and <code class="literal">Commands</code>, where an object fires a call and the other object responds to it. The difference with <code class="literal">Commands</code> is that, in this case, a response is returned to the caller.</p><p>To set up a <code class="literal">RequestResponse</code> object, we need the following line of code:</p><div class="informalexample"><pre class="programlisting">var reqres = new Backbone.Wreqr.RequestResponse();</pre></div><p>The setup of a handler is also similar <a id="id152" class="indexterm"/>to the commands handler as we can see in the following code snippet:</p><div class="informalexample"><pre class="programlisting">reqres.setHandler("getUserName", function(userId){
  //code to get the user name goes here
  return Username;  ///this will be the response
});</pre></div><p>In order to get that response value, we need to put in a request as follows:</p><div class="informalexample"><pre class="programlisting">var username = reqres.request("getUserName", userId);</pre></div><p>In the previous example, we requested a username and the handler, with the name <code class="literal">getUserName</code>, is just a function that will return that value for us. Also, note that you can pass parameters to this request.</p><p>We consider the <code class="literal">RequestResponse</code> <a id="id153" class="indexterm"/>object very useful to separate concerns, get the value from the server, filter those values, and perform a data manipulation task again; these are not responsibilities of the other components of Backbone or of Marionette reviewed so far. Think of <code class="literal">RequestRepsonse</code> as a service layer that will call the server and return a collection or models in a single place. Instead of doing this at the view level, your views should display the data passed to them. But they will be doing too much by also being in charge of retrieving this data from the server, and what if your API changes? You would need to change that server call in all the views or controllers where you made the calls.</p><p>Using the <code class="literal">RequestResponse</code> object will give you the ability to perform this synchronization with the server in one place and call it from different places, always getting the same return. But above everything, it allows you to decouple your application and keep the responsibility and duties of the other components short and meaningful.</p><p>Let's see an example of this, but again, we will <a id="id154" class="indexterm"/>use the default instance of <code class="literal">Wreqr</code>, which is in the application object of Marionette:</p><div class="informalexample"><pre class="programlisting"> App.reqres.setHandler("GetBooksByCategory", function(category){
  //code to fetch the books by category goes here.
  return collection;
 });</pre></div><p>Inside the method of a controller, we can call the handler by performing a request and passing the collection to the view, as demonstrated in the following code snippet:</p><div class="informalexample"><pre class="programlisting">     var BooksController = Marionette.Controller.extend({
      
      initialize: function(options){
          this.region = options.region;
      },

      showBooksinCategory: function(category){
       var books = App.request("GetBooksByCategory ", category); 
       this.region.show(new CategoryView({collection:books}));
      }
    });</pre></div><p>The benefit of this is that the controller <a id="id155" class="indexterm"/>acted as a mediator between the view and the <code class="literal">RequestResponse</code> object, while the view is responsible for getting the data removed because the controller passes the collection to it.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we learned how to decouple our application with the help of the <code class="literal">Wreqr</code> object while splitting the responsibilities between the different subcomponents such as the <code class="literal">event aggregator</code>, <code class="literal">Commands</code>, and <code class="literal">RequestRespone</code>.</p><p>In the next chapter, we will learn how to make these components work in single files and keep our file structure organized with the help of <code class="literal">Require.js</code>.</p></div></body></html>