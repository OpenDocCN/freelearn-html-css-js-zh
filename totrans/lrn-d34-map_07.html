<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Testing</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we will cover several topics that will assist you in the long-term maintenance of your D3 code base. </span><span class="koboSpan" id="kobo.2.2">The goal is to create a foundation to build reusable assets that can be easily unit tested while leveraging popular tools and techniques already established in the JavaScript community.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Unit testing is important in any software development project, especially in a D3 code base. </span><span class="koboSpan" id="kobo.3.2">Typically, these projects involve a lot of code that applies analytics or manipulates data structures. </span><span class="koboSpan" id="kobo.3.3">For these types of problems, unit testing can help in the following ways:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.4.1">Reduce bugs</span></strong><span class="koboSpan" id="kobo.5.1">: An automated test suite will allow the developer to break down and test individual components. </span><span class="koboSpan" id="kobo.5.2">These tests will be run constantly throughout the development cycle, validating that future features do not break the older working code.</span></li>
<li><strong><span class="koboSpan" id="kobo.6.1">Document accurately</span></strong><span class="koboSpan" id="kobo.7.1">: Often, tests are written in a human-readable way; this precisely describes the problem they are testing against. </span><span class="koboSpan" id="kobo.7.2">An example of the code provides much better documentation than a long paragraph.</span></li>
<li><strong><span class="koboSpan" id="kobo.8.1">Allow refactoring</span></strong><span class="koboSpan" id="kobo.9.1">: The developer can change code semantics and design with confidence, knowing that the inputs and outputs are still tracked and validated.</span></li>
<li><strong><span class="koboSpan" id="kobo.10.1">Make development faster</span></strong><span class="koboSpan" id="kobo.11.1">: Most developers spend time validating their work as they write. </span><span class="koboSpan" id="kobo.11.2">We've seen developers tirelessly refresh browsers, check console logs, and inspect DOM elements as they go. </span><span class="koboSpan" id="kobo.11.3">Instead of performing these manual actions over and over again, simply wrap them up in a framework that does the work for you.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">This chapter will explore a Bootstrap project that we like to use when starting a new visualization development. </span><span class="koboSpan" id="kobo.12.2">The concepts covered in the project include:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Project structure</span></li>
<li><span class="koboSpan" id="kobo.14.1">Code organization and reusable assets</span></li>
<li><span class="koboSpan" id="kobo.15.1">Unit testing</span></li>
<li><span class="koboSpan" id="kobo.16.1">A resilient code base</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Code organization and reusable assets</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The foundation of our way of writing reusable and testable D3 code is from Mike Bostock's blog article, </span><em><span class="koboSpan" id="kobo.3.1">Towards Reusable Charts</span></em><span class="koboSpan" id="kobo.4.1">, at </span><a href="http://bost.ocks.org/mike/chart/"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">http://bost.ocks.org/mike/chart/</span></span></a><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">At its core, it sets out to implement charts as closures with </span><kbd><span class="koboSpan" id="kobo.7.1">getter</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">setter</span></kbd><span class="koboSpan" id="kobo.10.1"> methods. </span><span class="koboSpan" id="kobo.10.2">This makes the code more readable and simple for testing. </span><span class="koboSpan" id="kobo.10.3">It is actually a great idea to read this article before continuing, as we can take some of our career experiences and extend these concepts a little further. </span><span class="koboSpan" id="kobo.10.4">The project structure is organized to achieve several goals.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Project structure</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Bootstrap project contains the following files and directories:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="172" width="158" src="assets/d05ec2e4-9081-4607-b672-5a1358f582a9.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">The project works out of the box with example code already in place. </span><span class="koboSpan" id="kobo.4.2">To see this in action, we will launch the example. </span><span class="koboSpan" id="kobo.4.3">From the example Bootstrap code provided, first, install all the dependencies (note that you only have to execute this command once):</span></p>
<pre><span class="koboSpan" id="kobo.5.1">npm install</span></pre>
<p><span class="koboSpan" id="kobo.6.1">Then, to see the visualization, execute  the following:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">node node_modules/http-server/bin/http-server  </span></pre>
<p><span class="koboSpan" id="kobo.8.1">Next, open the browser to </span><kbd><span class="koboSpan" id="kobo.9.1">http://localhost:8080</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">You should see three bars changing based on random data in a series of tests. </span><span class="koboSpan" id="kobo.10.3">Note that if you have the previous examples already open, you will have to kill that process in order to run this one, as both of them use the same port.</span></p>
<p><span class="koboSpan" id="kobo.11.1">To see the unit tests working, just execute the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.12.1">node_modules/karma/bin/karma start  </span></strong></pre>
<p><span class="koboSpan" id="kobo.13.1">You should see a summary of five unit tests running in the terminal, and a continuous running process monitoring your project:</span></p>
<pre><strong><span class="koboSpan" id="kobo.14.1">INFO [karma]: Karma v0.12.21 server started at </span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">http://localhost:9876/ 
INFO [launcher]: Starting browser Chrome 
INFO [Chrome 37.0.2062 (Mac OS X 10.9.5)]: Connected on socket </span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">goMqmrnZkxyz9nlpQHem with id 16699326Chrome 37.0.2062 (Mac OS X 10.9.5): Executed 5 of 5 SUCCESS </span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">(0.018 secs / 0.013 secs)</span></strong></pre>
<p><span class="koboSpan" id="kobo.18.1">We will explain how to write unit tests for the project later in this chapter. </span><span class="koboSpan" id="kobo.18.2">For a quick peek at what tests are running, look at </span><kbd><span class="koboSpan" id="kobo.19.1">spec/viz_spec.js</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">If you change any of the methods in this file, you will notice that the test runner will detect that a change has been made in the code and re-execute the tests! </span><span class="koboSpan" id="kobo.21.2">This provides a fantastic feedback loop to the developer as you continue to enhance your work.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Exploring the code directory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we will cover each file in detail and explain its importance in the overall package:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.3.1">index.html</span></kbd><span class="koboSpan" id="kobo.4.1">: This file is the starting point of the visualization and will launch automatically when you point your browser to </span><kbd><span class="koboSpan" id="kobo.5.1">http://localhost:8080</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">You will notice that the file contains many of the points already covered in the book in terms of loading up the proper assets. </span><span class="koboSpan" id="kobo.6.3">As we walk through the </span><kbd><span class="koboSpan" id="kobo.7.1">index.html</span></kbd><span class="koboSpan" id="kobo.8.1"> file, we will identify the other directories and files used in the project.</span></li>
<li><kbd><span class="koboSpan" id="kobo.9.1">main.css</span></kbd><span class="koboSpan" id="kobo.10.1">: The </span><kbd><span class="koboSpan" id="kobo.11.1">main.css</span></kbd><span class="koboSpan" id="kobo.12.1"> file is used to apply specific CSS styling to</span><br/><span class="koboSpan" id="kobo.13.1">
your visualization:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.14.1">&lt;link rel="stylesheet" type="text/css" href="main.css"&gt; </span></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.15.1">vendor</span></kbd><span class="koboSpan" id="kobo.16.1">: This directory contains all the external libraries that we need to use in the visualization and is loaded at the bottom of the </span><kbd><span class="koboSpan" id="kobo.17.1">index.html</span></kbd><span class="koboSpan" id="kobo.18.1"> file:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.19.1">&lt;script src="vendor/d3.min.js"&gt;&lt;/script&gt; 
&lt;script src="vendor/topojson.v1.min.js"&gt;&lt;/script&gt; </span></pre>
<ul>
<li class="packt_nosymbol"><span class="koboSpan" id="kobo.20.1">We like to keep these to a minimum so that we have as few dependencies on the outside world as possible. </span><span class="koboSpan" id="kobo.20.2">In this case, we are only using the core D3 library and TopoJSON to help us with the GeoJSON encoding.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.21.1">scripts</span></kbd><span class="koboSpan" id="kobo.22.1">: This is another directory; there are some new additions to the files we are loading in order to create the visualization:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">&lt;!-- A base function for setting up the SVG and container --&gt; 
&lt;script src="scripts/base.js"&gt;&lt;/script&gt; 
 
&lt;!-- The main visualization code --&gt; 
&lt;script src="scripts/viz.js"&gt;&lt;/script&gt; </span></pre>
<ul>
<li class="packt_nosymbol"><span class="koboSpan" id="kobo.24.1">The </span><kbd><span class="koboSpan" id="kobo.25.1">base.js</span></kbd><span class="koboSpan" id="kobo.26.1"> script contains some common D3 patterns that are reused in many examples (such as containing the visualization in a chart area </span><kbd><span class="koboSpan" id="kobo.27.1">&lt;g&gt;</span></kbd><span class="koboSpan" id="kobo.28.1"> with a predefined margin object, common methods to calculate height and width based on this margin object, and a handy utility to find the existing container and binding data). </span><span class="koboSpan" id="kobo.28.2">The </span><kbd><span class="koboSpan" id="kobo.29.1">base.js</span></kbd><span class="koboSpan" id="kobo.30.1"> script is also an excellent location to keep the reusable code.</span></li>
<li class="packt_nosymbol"><span class="koboSpan" id="kobo.31.1">The </span><kbd><span class="koboSpan" id="kobo.32.1">viz.js</span></kbd><span class="koboSpan" id="kobo.33.1"> script is an example that leverages many of the concepts in </span><em><span class="koboSpan" id="kobo.34.1">Towards Reusable Charts</span></em><span class="koboSpan" id="kobo.35.1"> with some inheritance gained from </span><kbd><span class="koboSpan" id="kobo.36.1">base.js</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">The </span><kbd><span class="koboSpan" id="kobo.38.1">viz.js</span></kbd><span class="koboSpan" id="kobo.39.1"> script is the workhorse of the project and where most of the visualization code will reside.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.40.1">factories</span></kbd><span class="koboSpan" id="kobo.41.1">: This too is a directory. </span><span class="koboSpan" id="kobo.41.2">In order to show our work in the browser, we need a script to generate some data, select the element in the DOM, and initiate the visualization call. </span><span class="koboSpan" id="kobo.41.3">These scripts are organized in the </span><kbd><span class="koboSpan" id="kobo.42.1">factories</span></kbd><span class="koboSpan" id="kobo.43.1"> directory. </span><span class="koboSpan" id="kobo.43.2">An example of this can be viewed in the </span><kbd><span class="koboSpan" id="kobo.44.1">viz_factory.js</span></kbd><span class="koboSpan" id="kobo.45.1"> file:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.46.1">&lt;!-- The script acts as a proxy to call the visualization </span><br/><span class="koboSpan" id="kobo.47.1"> and draw it with sample data --&gt; 
&lt;script src="factories/viz_factory.js"&gt;&lt;/script&gt; </span></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.48.1">spec</span></kbd><span class="koboSpan" id="kobo.49.1">: The tests you write to validate the methods in the visualization code go here. </span><span class="koboSpan" id="kobo.49.2">A detailed example will be provided later in this chapter.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Other administrative files</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Two additional files that assist with the operation of the Bootstrap project are as follows; these files rarely require any modification:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.3.1">karma.conf.js</span></kbd><span class="koboSpan" id="kobo.4.1">: This is used to set up the unit test runs</span></li>
<li><kbd><span class="koboSpan" id="kobo.5.1">package.json</span></kbd><span class="koboSpan" id="kobo.6.1">: This describes which npm packages to install</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Writing testable code</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are dozens of factors to consider when creating visualizations. </span><span class="koboSpan" id="kobo.2.2">Every design will have its own set of unique requirements and configuration capabilities to consider. </span><span class="koboSpan" id="kobo.2.3">If you build on the reusable pattern outlined by Mike Bostock, you will have a great framework to start with.</span></p>
<p><span class="koboSpan" id="kobo.3.1">When working with data visualizations, we will have some form of data manipulation or logic that must be applied to incoming data. </span><span class="koboSpan" id="kobo.3.2">There are two notable best practices we can leverage to test and validate these operations. </span><span class="koboSpan" id="kobo.3.3">They are explained in the following sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Keeping methods/functions small</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Small functions mean low cyclomatic complexity. </span><span class="koboSpan" id="kobo.2.2">This means there are fewer logic branches in each function and, therefore, fewer things to test. </span><span class="koboSpan" id="kobo.2.3">If we test each simple function thoroughly and independently, then there will be fewer chances of things going wrong when we compose them together into larger complex computations. </span><span class="koboSpan" id="kobo.2.4">A good guideline is to try and keep methods at around 10 lines of code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Preventing side effects</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This basically means that each small function should not save some state outside itself. </span><span class="koboSpan" id="kobo.2.2">Try to limit the use of global variables as much as possible and think of each function as  the following process:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Data arrives.</span></li>
<li><span class="koboSpan" id="kobo.4.1">Perform some operations on the data.</span></li>
<li><span class="koboSpan" id="kobo.5.1">Return results.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.6.1">This way we can easily test each function independently, without worrying about the effect it has on the global state of the program.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">An example with viz.js</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To see this in practice, let's take a look at the </span><kbd><span class="koboSpan" id="kobo.3.1">scripts/viz.js</span></kbd><span class="koboSpan" id="kobo.4.1"> program as a template for creating testable code for the data manipulation functions in the visualization. </span><span class="koboSpan" id="kobo.4.2">For this example, we will create a set of simple bars that are based on the profit of an arbitrary dataset. </span><span class="koboSpan" id="kobo.4.3">We are given the sales and cost in the data; however, we need to determine the profit for the visualization by subtracting the sales from the cost. </span><span class="koboSpan" id="kobo.4.4">In this contrived example, we need a few small helper functions, which are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">A function to take the original dataset and return a new dataset with the profit calculated</span></li>
<li><span class="koboSpan" id="kobo.6.1">A function to retrieve an array of unique categories to apply to an ordinal scale</span></li>
<li><span class="koboSpan" id="kobo.7.1">A function to determine the maximum profit value in order to build the upper bound of our input domain</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">If we create these functions with the best practices outlined earlier and expose them externally, we can test them in isolation and independently.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's take a tour of the script to see how it all works together:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">if (d3.charts === null || typeof(d3.charts) !== 'object') </span><br/><span class="koboSpan" id="kobo.11.1"> { d3.charts = {}; }</span></pre>
<p><span class="koboSpan" id="kobo.12.1">Here, we will define the namespace for the chart. </span><span class="koboSpan" id="kobo.12.2">In this example, our chart can be instantiated with </span><kbd><span class="koboSpan" id="kobo.13.1">d3.charts.viz</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">If the </span><kbd><span class="koboSpan" id="kobo.15.1">d3</span></kbd><span class="koboSpan" id="kobo.16.1"> object with the charts property does not exist, or if it is not of the </span><kbd><span class="koboSpan" id="kobo.17.1">type</span></kbd><span class="koboSpan" id="kobo.18.1"> object, create it, using classical functional inheritance to leverage common patterns from a </span><kbd><span class="koboSpan" id="kobo.19.1">base</span></kbd><span class="koboSpan" id="kobo.20.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">d3.charts.viz = function () { 
  // Functional inheritance of common areas 
  var my = d3.ext.base(); </span></pre>
<p><span class="koboSpan" id="kobo.22.1">A handy function (see </span><kbd><span class="koboSpan" id="kobo.23.1">base.js</span></kbd><span class="koboSpan" id="kobo.24.1">) to quickly assign </span><kbd><span class="koboSpan" id="kobo.25.1">getters/setters</span></kbd><span class="koboSpan" id="kobo.26.1"> to the closure following the pattern in </span><em><span class="koboSpan" id="kobo.27.1">Towards Reusable Charts</span></em><span class="koboSpan" id="kobo.28.1"> is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">  // Define getter/setter style accessors.. 
  </span><span class="koboSpan" id="kobo.29.2">// defaults assigned 
  my.accessor('example', true); </span></pre>
<p><span class="koboSpan" id="kobo.30.1">We use the </span><kbd><span class="koboSpan" id="kobo.31.1">svg</span></kbd><span class="koboSpan" id="kobo.32.1"> variable at this level of scope to maintain state when quickly appending selectors. </span><span class="koboSpan" id="kobo.32.2">The </span><kbd><span class="koboSpan" id="kobo.33.1">void 0</span></kbd><span class="koboSpan" id="kobo.34.1"> is a safer way to initialize the variable as undefined:</span></p>
<pre><span class="koboSpan" id="kobo.35.1">  // Data for Global Scope 
  var svg = void 0, 
      chart = void 0; </span></pre>
<p><span class="koboSpan" id="kobo.36.1">Define the D3 instance functions that will be used throughout the visualization:</span></p>
<pre><span class="koboSpan" id="kobo.37.1">  // Declare D3 functions, also in instance scope 
  var x = d3.scale.linear(), 
      y = d3.scale.ordinal(); </span></pre>
<p><span class="koboSpan" id="kobo.38.1">The following function represents the main interface to the outside world. </span><span class="koboSpan" id="kobo.38.2">There is also a set of setup functions commonly seen in D3 visualizations. </span><span class="koboSpan" id="kobo.38.3">The SVG container is set up in a way that can easily look for existing SVG containers in the selector and rebind the data. </span><span class="koboSpan" id="kobo.38.4">This makes it much easier to redraw when making subsequent calls with new data:</span></p>
<pre><span class="koboSpan" id="kobo.39.1">  my.draw = function(selection) { 
    selection.each(function(data) { 
      // code in base/scripts.js 
      // resuable way of dealing with margins 
      svg = my.setupSVG(this); 
      chart = my.setupChart(svg); 
 
      // Create the visualization 
      my.chart(data); 
    }); 
  }; 
 
  // main method for drawing the viz 
  my.chart = function(data) { 
    var chartData = my.profit(data); 
 
    x.domain([0, my.profitMax(chartData)]) 
        .range([0,my.w()]); 
    y.domain(my.categories(chartData)) 
        .rangeRoundBands([0, my.h()], 0.2); 
 
    var boxes = chart.selectAll('.box').data(chartData); 
 
    // Enter 
    boxes.enter().append('rect') 
        .attr('class', 'box') 
        .attr('fill', 'steelblue'); 
 
    // Update 
    boxes.transition().duration(1000) 
        .attr('x', 0) 
        .attr('y', function(d) { return y(d.category) }) 
        .attr('width', function(d) {  return x(d.profit) }) 
        .attr('height', y.rangeBand()) 
 
    // Exit 
    boxes.exit().remove(); 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.40.1">Notice that the </span><kbd><span class="koboSpan" id="kobo.41.1">chart</span></kbd><span class="koboSpan" id="kobo.42.1"> function relies on several helper functions (shown in the following lines of code) to work with the data. </span><span class="koboSpan" id="kobo.42.2">It is also written in such a way that we can take advantage of the enter/update/exit pattern:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">  // Example function to create profit. 
  </span><span class="koboSpan" id="kobo.43.2">my.profit = function(data) { 
    return data.map(function(d) { 
      d.profit = parseFloat(d.sales) - parseFloat(d.cost); 
      return d; 
    }); 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.44.1">This function is used to create a new data structure that has profit assigned. </span><span class="koboSpan" id="kobo.44.2">Note that it takes one data array in as a parameter and returns a newly constructed array with the profit attribute added. </span><span class="koboSpan" id="kobo.44.3">This function is now exposed externally with </span><kbd><span class="koboSpan" id="kobo.45.1">viz().profit(data)</span></kbd><span class="koboSpan" id="kobo.46.1"> and can be easily tested. </span><span class="koboSpan" id="kobo.46.2">It does not change any of the outside global variables. </span><span class="koboSpan" id="kobo.46.3">It is just data in and new data out:</span></p>
<pre><span class="koboSpan" id="kobo.47.1">  my.categories = function(data) { 
    return data.map(function(d) { 
      return d.category; 
    }); 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.48.1">This is the exact same pattern as </span><kbd><span class="koboSpan" id="kobo.49.1">my.profit(data)</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">We will take the data structure in as input and return a new data structure, that is, an array of all the categories. </span><span class="koboSpan" id="kobo.50.3">In the preceding lines of code, you saw that this is leveraged to create the input domain.</span></p>
<pre><span class="koboSpan" id="kobo.51.1">  my.profitMax = function(data) { 
    return d3.max(data, function(d) { return d.profit; }); 
  }; </span></pre>
<p><span class="koboSpan" id="kobo.52.1">Once again, a simple function to take data in, compute the max, and return that maximum value. </span><span class="koboSpan" id="kobo.52.2">It is very easy to test and verify with </span><kbd><span class="koboSpan" id="kobo.53.1">d3.charts.viz().profitMax(data)</span></kbd><span class="koboSpan" id="kobo.54.1">?</span></p>
<pre><span class="koboSpan" id="kobo.55.1">   return my; 
  }; </span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Unit testing</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now that we have a code base written in a testable way, let's automate those tests so that we do not have to perform them manually and can continue to code and refactor with ease.</span></p>
<p><span class="koboSpan" id="kobo.3.1">If you look at the </span><kbd><span class="koboSpan" id="kobo.4.1">spec/viz_spec.js</span></kbd><span class="koboSpan" id="kobo.5.1"> file, you will note some common patterns when unit testing. </span><span class="koboSpan" id="kobo.5.2">The following code is written with a JavaScript unit-testing framework called Jasmine and leverages Karma to execute the tests. </span><span class="koboSpan" id="kobo.5.3">You can learn more about the Jasmine syntax, assertions, and other features at </span><a href="http://jasmine.github.io/1.3/introduction.html"><span class="URLPACKT"><span class="koboSpan" id="kobo.6.1">http://jasmine.github.io/1.3/introduction.html</span></span></a><span class="koboSpan" id="kobo.7.1">.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The Bootstrap project has everything you need to start testing quickly.</span></p>
<p><span class="koboSpan" id="kobo.9.1">The first step is to start our Karma test runner with this line of code:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">node_modules/karma/bin/karma start </span></pre>
<p><span class="koboSpan" id="kobo.11.1">This runner will watch every edit of the </span><kbd><span class="koboSpan" id="kobo.12.1">viz.js</span></kbd><span class="koboSpan" id="kobo.13.1"> file or the </span><kbd><span class="koboSpan" id="kobo.14.1">viz_spec.js</span></kbd><span class="koboSpan" id="kobo.15.1"> file. </span><span class="koboSpan" id="kobo.15.2">If any changes are detected, it will automatically rerun every test suite and provide the output on the console. </span><span class="koboSpan" id="kobo.15.3">If all the tests pass, then the output will be all green. </span><span class="koboSpan" id="kobo.15.4">If something fails, you will receive a red warning message:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">'use strict'; 
 
describe('Visualization: Stacked', function () { 
  var viz; 
 
  var data = [ 
    {"category": "gold",  "cost": "10",  "sales": "60"}, 
    {"category": "white", "cost": "20",  "sales": "30"}, 
    {"category": "black", "cost": "100", "sales": "140"} 
  ]; </span></pre>
<p><span class="koboSpan" id="kobo.17.1">Create some test data to test your D3 data manipulation functions. </span><span class="koboSpan" id="kobo.17.2">The preceding </span><kbd><span class="koboSpan" id="kobo.18.1">describe</span></kbd><span class="koboSpan" id="kobo.19.1"> syntax defines the test harness you are about to execute:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">  beforeEach(function() { 
    viz = d3.charts.viz() 
        .height(600) 
        .width(900) 
        .margin({top: 10, right: 10, bottom: 10, left: 10}); 
  }); </span></pre>
<p><span class="koboSpan" id="kobo.21.1">Before every test run, create a new instance of the D3 visualization with some default setters:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">  it ('sets the profit', function() { 
    var profits = viz.profit(data); 
    expect(profits.length).toBe(3); 
    expect(profits[0].profit).toBe(50) 
  }); </span></pre>
<p><span class="koboSpan" id="kobo.23.1">This is our first test case! </span><span class="koboSpan" id="kobo.23.2">In this test, we asserted that we are getting a new array from our test data, but with an additional profit attribute. </span><span class="koboSpan" id="kobo.23.3">Remember that we created the function to have no side effects and to be a small unit of work. </span><span class="koboSpan" id="kobo.23.4">We will reap the fruits of our labor with this easy-to-test method. </span><span class="koboSpan" id="kobo.23.5">Just as we did earlier, we will test the list of categories now:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">  it ('returns a list of all categories', function() { 
    var categories = viz.categories(data); 
    expect(categories.length).toBe(3); 
    expect(categories).toEqual([ 'gold', 'white', 'black' ]); 
  }); </span></pre>
<p><span class="koboSpan" id="kobo.25.1">Calculate the maximum profit, as follows:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">  it ('calculates the profit max', function() { 
    var profits = viz.profit(data); 
    expect(viz.profitMax(profits)).toEqual(50); 
  }); </span></pre>
<p><span class="koboSpan" id="kobo.27.1">The following are additional example tests to validate that the </span><kbd><span class="koboSpan" id="kobo.28.1">height</span></kbd><span class="koboSpan" id="kobo.29.1">/</span><kbd><span class="koboSpan" id="kobo.30.1">width</span></kbd><span class="koboSpan" id="kobo.31.1">, bearing in mind the margins, is working properly from our </span><kbd><span class="koboSpan" id="kobo.32.1">base.js</span></kbd><span class="koboSpan" id="kobo.33.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">  it ('calculates the height of the chart box', function() { 
    expect(viz.h()).toBe(580); 
    viz.height(700); // change the height 
    viz.margin({top: 20, right: 10, bottom: 10, left: 10}) 
    expect(viz.h()).toBe(670); 
  }); 
 
  it ('calculates the width of the chart box', function() { 
    expect(viz.w()).toBe(880); 
    viz.height(700); // change the height 
    viz.margin({top: 10, right: 10, bottom: 10, left: 20}) 
    expect(viz.w()).toBe(870); 
  }); </span></pre>
<p><span class="koboSpan" id="kobo.35.1">As an experiment, try adding new test cases or editing the existing one. </span><span class="koboSpan" id="kobo.35.2">Watch the test runner report different results.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating resilient visualization code</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We want to make sure that our visualization can react to changing data, with minimal effort from the program that calls our code. </span><span class="koboSpan" id="kobo.2.2">One way to test different permutations of data and ensure that the visualization reacts accordingly is to randomly create example data, call the visualization code a number of times, and witness the result. </span><span class="koboSpan" id="kobo.2.3">These operations are handled in the </span><kbd><span class="koboSpan" id="kobo.3.1">factories</span></kbd><span class="koboSpan" id="kobo.4.1"> directory. </span><span class="koboSpan" id="kobo.4.2">Let's take a look at the </span><kbd><span class="koboSpan" id="kobo.5.1">viz_factory.js</span></kbd><span class="koboSpan" id="kobo.6.1"> file as an example:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">(function() { 
    var viz = d3.charts.viz(); </span></pre>
<p><span class="koboSpan" id="kobo.8.1">Create a variable to store our function with </span><kbd><span class="koboSpan" id="kobo.9.1">getters</span></kbd><span class="koboSpan" id="kobo.10.1"> and </span><kbd><span class="koboSpan" id="kobo.11.1">setters</span></kbd><span class="koboSpan" id="kobo.12.1"> as closures. </span><span class="koboSpan" id="kobo.12.2">In this example, we will use an anonymous function as a wrapper to execute the code. </span><span class="koboSpan" id="kobo.12.3">This prevents conflicts with other JavaScript code and ensures that our visualization will work properly in a protected context:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">    var rand = function() { 
      return Math.floor((Math.random() * 10) + 1) 
    }; </span></pre>
<p><span class="koboSpan" id="kobo.14.1">A simple helper function that generates a random number between 1 and 10 is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">    var data = function() { 
      return [1,2,3].map(function(d,i) { 
        var cost = rand(); 
        var sales = rand(); 
 
        return { 
          category: 'category-'+i, 
          cost: cost, 
          sales: cost + sales 
        }; 
      }); 
    }; </span></pre>
<p><span class="koboSpan" id="kobo.16.1">Generate a fake dataset based on random numbers:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    d3.select("#chart").datum(data()).call(viz.draw); </span></pre>
<p><span class="koboSpan" id="kobo.18.1">Draw the visualization for the first time using these lines of code:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">      var id = setInterval(function() { 
        var d = data(); 
        console.log('data:', d); 
        d3.select("#chart").datum(d).call(viz.draw); 
      }, 2000); 
      setTimeout(function() { 
      clearInterval(id); 
      }, 10000); </span></pre>
<p><span class="koboSpan" id="kobo.20.1">Set a timer for 10 seconds and bind new data to the visualization on iteration. </span><span class="koboSpan" id="kobo.20.2">The expected behavior is that the visualization will redraw itself on each call. </span><span class="koboSpan" id="kobo.20.3">Notice how simple it is to pass new data to the visualization. </span><span class="koboSpan" id="kobo.20.4">It is a simple selector with a new dataset. </span><span class="koboSpan" id="kobo.20.5">We have constructed the reusable visualization code in such a way that it knows how to react appropriately.</span></p>
<p><span class="koboSpan" id="kobo.21.1">To see the results in action, simply launch </span><kbd><span class="koboSpan" id="kobo.22.1">http-server</span></kbd><span class="koboSpan" id="kobo.23.1">, as follows:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">node_modules/http-server/bin/http-server  </span></pre>
<p><span class="koboSpan" id="kobo.25.1">Now, visit </span><kbd><span class="koboSpan" id="kobo.26.1">http://localhost:8080</span></kbd><span class="koboSpan" id="kobo.27.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Adding a new test case</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">What happens if we change the number of datasets in the array? </span><span class="koboSpan" id="kobo.2.2">To test this, let's add a new helper function (called </span><kbd><span class="koboSpan" id="kobo.3.1">set()</span></kbd><span class="koboSpan" id="kobo.4.1">) to randomly generate a new set of data with a random number of elements between 1 and 10:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    var set = function() { 
      var k = rand(); 
      var d = []; 
      for (var i = 1; i &lt; k; i++) { 
        d.push[i]; 
      }; 
      return d; 
    }; </span></pre>
<p><span class="koboSpan" id="kobo.6.1">Modify the </span><kbd><span class="koboSpan" id="kobo.7.1">data</span></kbd><span class="koboSpan" id="kobo.8.1"> function slightly. </span><span class="koboSpan" id="kobo.8.2">We will print to the console to validate that it is working properly:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    var data = function() { 
      var d = set(); 
      console.log('d', d); 
      return d.map(function(d,i) { 
        var cost = rand(); 
        var sales = rand(); 
 
        return { 
          category: 'category-'+i, 
          cost: cost, 
          sales: cost + sales 
        }; 
      }); 
    }; </span></pre>
<p><span class="koboSpan" id="kobo.10.1">Now, if we look at </span><kbd><span class="koboSpan" id="kobo.11.1">http://localhost:8080</span></kbd><span class="koboSpan" id="kobo.12.1"> again, we can see that the visualization is working properly even with a random amount of data.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we described the techniques to help test your D3 code base and to keep it healthy over the lifespan of your project. </span><span class="koboSpan" id="kobo.2.2">We also went step by step through a Bootstrap project to help you get started with these examples, and we took a look at a methodology for structuring your work.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Our recommendations are based on many years of experience and many projects delivered using D3. </span><span class="koboSpan" id="kobo.3.2">We strongly recommend that you follow good software patterns and focus on tests; this will allow you to perfect your craft. </span><span class="koboSpan" id="kobo.3.3">Quality is in your hands now. </span></p>


            </article>

            
        </section>
    </body></html>