<html><head></head><body>
        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>In this chapter, we will cover several topics that will assist you in the long-term maintenance of your D3 code base. The goal is to create a foundation to build reusable assets that can be easily unit tested while leveraging popular tools and techniques already established in the JavaScript community.</p>
<p>Unit testing is important in any software development project, especially in a D3 code base. Typically, these projects involve a lot of code that applies analytics or manipulates data structures. For these types of problems, unit testing can help in the following ways:</p>
<ul>
<li><strong>Reduce bugs</strong>: An automated test suite will allow the developer to break down and test individual components. These tests will be run constantly throughout the development cycle, validating that future features do not break the older working code.</li>
<li><strong>Document accurately</strong>: Often, tests are written in a human-readable way; this precisely describes the problem they are testing against. An example of the code provides much better documentation than a long paragraph.</li>
<li><strong>Allow refactoring</strong>: The developer can change code semantics and design with confidence, knowing that the inputs and outputs are still tracked and validated.</li>
<li><strong>Make development faster</strong>: Most developers spend time validating their work as they write. We've seen developers tirelessly refresh browsers, check console logs, and inspect DOM elements as they go. Instead of performing these manual actions over and over again, simply wrap them up in a framework that does the work for you.</li>
</ul>
<p>This chapter will explore a Bootstrap project that we like to use when starting a new visualization development. The concepts covered in the project include:</p>
<ul>
<li>Project structure</li>
<li>Code organization and reusable assets</li>
<li>Unit testing</li>
<li>A resilient code base</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Code organization and reusable assets</h1>
                
            
            
                
<p>The foundation of our way of writing reusable and testable D3 code is from Mike Bostock's blog article, <em>Towards Reusable Charts</em>, at <a href="http://bost.ocks.org/mike/chart/">http://bost.ocks.org/mike/chart/</a>. At its core, it sets out to implement charts as closures with <kbd>getter</kbd> and <kbd>setter</kbd> methods. This makes the code more readable and simple for testing. It is actually a great idea to read this article before continuing, as we can take some of our career experiences and extend these concepts a little further. The project structure is organized to achieve several goals.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project structure</h1>
                
            
            
                
<p>The Bootstrap project contains the following files and directories:</p>
<div><img height="172" width="158" src="img/d05ec2e4-9081-4607-b672-5a1358f582a9.png"/></div>
<p>The project works out of the box with example code already in place. To see this in action, we will launch the example. From the example Bootstrap code provided, first, install all the dependencies (note that you only have to execute this command once):</p>
<pre>npm install</pre>
<p>Then, to see the visualization, execute  the following:</p>
<pre>node node_modules/http-server/bin/http-server  </pre>
<p>Next, open the browser to <kbd>http://localhost:8080</kbd>. You should see three bars changing based on random data in a series of tests. Note that if you have the previous examples already open, you will have to kill that process in order to run this one, as both of them use the same port.</p>
<p>To see the unit tests working, just execute the following:</p>
<pre><strong>node_modules/karma/bin/karma start  </strong></pre>
<p>You should see a summary of five unit tests running in the terminal, and a continuous running process monitoring your project:</p>
<pre><strong>INFO [karma]: Karma v0.12.21 server started at </strong><br/><strong>http://localhost:9876/ 
INFO [launcher]: Starting browser Chrome 
INFO [Chrome 37.0.2062 (Mac OS X 10.9.5)]: Connected on socket </strong><br/><strong>goMqmrnZkxyz9nlpQHem with id 16699326Chrome 37.0.2062 (Mac OS X 10.9.5): Executed 5 of 5 SUCCESS </strong><br/><strong>(0.018 secs / 0.013 secs)</strong></pre>
<p>We will explain how to write unit tests for the project later in this chapter. For a quick peek at what tests are running, look at <kbd>spec/viz_spec.js</kbd>.</p>
<p>If you change any of the methods in this file, you will notice that the test runner will detect that a change has been made in the code and re-execute the tests! This provides a fantastic feedback loop to the developer as you continue to enhance your work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the code directory</h1>
                
            
            
                
<p>In this section, we will cover each file in detail and explain its importance in the overall package:</p>
<ul>
<li><kbd>index.html</kbd>: This file is the starting point of the visualization and will launch automatically when you point your browser to <kbd>http://localhost:8080</kbd>. You will notice that the file contains many of the points already covered in the book in terms of loading up the proper assets. As we walk through the <kbd>index.html</kbd> file, we will identify the other directories and files used in the project.</li>
<li><kbd>main.css</kbd>: The <kbd>main.css</kbd> file is used to apply specific CSS styling to<br/>
your visualization:</li>
</ul>
<pre style="padding-left: 60px">&lt;link rel="stylesheet" type="text/css" href="main.css"&gt; </pre>
<ul>
<li><kbd>vendor</kbd>: This directory contains all the external libraries that we need to use in the visualization and is loaded at the bottom of the <kbd>index.html</kbd> file:</li>
</ul>
<pre style="padding-left: 60px">&lt;script src="img/d3.min.js"&gt;&lt;/script&gt; 
&lt;script src="img/topojson.v1.min.js"&gt;&lt;/script&gt; </pre>
<ul>
<li class="packt_nosymbol">We like to keep these to a minimum so that we have as few dependencies on the outside world as possible. In this case, we are only using the core D3 library and TopoJSON to help us with the GeoJSON encoding.</li>
</ul>
<ul>
<li><kbd>scripts</kbd>: This is another directory; there are some new additions to the files we are loading in order to create the visualization:</li>
</ul>
<pre style="padding-left: 60px">&lt;!-- A base function for setting up the SVG and container --&gt; 
&lt;script src="img/base.js"&gt;&lt;/script&gt; 
 
&lt;!-- The main visualization code --&gt; 
&lt;script src="img/viz.js"&gt;&lt;/script&gt; </pre>
<ul>
<li class="packt_nosymbol">The <kbd>base.js</kbd> script contains some common D3 patterns that are reused in many examples (such as containing the visualization in a chart area <kbd>&lt;g&gt;</kbd> with a predefined margin object, common methods to calculate height and width based on this margin object, and a handy utility to find the existing container and binding data). The <kbd>base.js</kbd> script is also an excellent location to keep the reusable code.</li>
<li class="packt_nosymbol">The <kbd>viz.js</kbd> script is an example that leverages many of the concepts in <em>Towards Reusable Charts</em> with some inheritance gained from <kbd>base.js</kbd>. The <kbd>viz.js</kbd> script is the workhorse of the project and where most of the visualization code will reside.</li>
</ul>
<ul>
<li><kbd>factories</kbd>: This too is a directory. In order to show our work in the browser, we need a script to generate some data, select the element in the DOM, and initiate the visualization call. These scripts are organized in the <kbd>factories</kbd> directory. An example of this can be viewed in the <kbd>viz_factory.js</kbd> file:</li>
</ul>
<pre style="padding-left: 60px">&lt;!-- The script acts as a proxy to call the visualization <br/> and draw it with sample data --&gt; 
&lt;script src="img/viz_factory.js"&gt;&lt;/script&gt; </pre>
<ul>
<li><kbd>spec</kbd>: The tests you write to validate the methods in the visualization code go here. A detailed example will be provided later in this chapter.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Other administrative files</h1>
                
            
            
                
<p>Two additional files that assist with the operation of the Bootstrap project are as follows; these files rarely require any modification:</p>
<ul>
<li><kbd>karma.conf.js</kbd>: This is used to set up the unit test runs</li>
<li><kbd>package.json</kbd>: This describes which npm packages to install</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing testable code</h1>
                
            
            
                
<p>There are dozens of factors to consider when creating visualizations. Every design will have its own set of unique requirements and configuration capabilities to consider. If you build on the reusable pattern outlined by Mike Bostock, you will have a great framework to start with.</p>
<p>When working with data visualizations, we will have some form of data manipulation or logic that must be applied to incoming data. There are two notable best practices we can leverage to test and validate these operations. They are explained in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Keeping methods/functions small</h1>
                
            
            
                
<p>Small functions mean low cyclomatic complexity. This means there are fewer logic branches in each function and, therefore, fewer things to test. If we test each simple function thoroughly and independently, then there will be fewer chances of things going wrong when we compose them together into larger complex computations. A good guideline is to try and keep methods at around 10 lines of code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing side effects</h1>
                
            
            
                
<p>This basically means that each small function should not save some state outside itself. Try to limit the use of global variables as much as possible and think of each function as  the following process:</p>
<ol>
<li>Data arrives.</li>
<li>Perform some operations on the data.</li>
<li>Return results.</li>
</ol>
<p>This way we can easily test each function independently, without worrying about the effect it has on the global state of the program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An example with viz.js</h1>
                
            
            
                
<p>To see this in practice, let's take a look at the <kbd>scripts/viz.js</kbd> program as a template for creating testable code for the data manipulation functions in the visualization. For this example, we will create a set of simple bars that are based on the profit of an arbitrary dataset. We are given the sales and cost in the data; however, we need to determine the profit for the visualization by subtracting the sales from the cost. In this contrived example, we need a few small helper functions, which are as follows:</p>
<ul>
<li>A function to take the original dataset and return a new dataset with the profit calculated</li>
<li>A function to retrieve an array of unique categories to apply to an ordinal scale</li>
<li>A function to determine the maximum profit value in order to build the upper bound of our input domain</li>
</ul>
<p>If we create these functions with the best practices outlined earlier and expose them externally, we can test them in isolation and independently.</p>
<p>Let's take a tour of the script to see how it all works together:</p>
<pre>if (d3.charts === null || typeof(d3.charts) !== 'object') <br/> { d3.charts = {}; }</pre>
<p>Here, we will define the namespace for the chart. In this example, our chart can be instantiated with <kbd>d3.charts.viz</kbd>. If the <kbd>d3</kbd> object with the charts property does not exist, or if it is not of the <kbd>type</kbd> object, create it, using classical functional inheritance to leverage common patterns from a <kbd>base</kbd> function:</p>
<pre>d3.charts.viz = function () { 
  // Functional inheritance of common areas 
  var my = d3.ext.base(); </pre>
<p>A handy function (see <kbd>base.js</kbd>) to quickly assign <kbd>getters/setters</kbd> to the closure following the pattern in <em>Towards Reusable Charts</em> is as follows:</p>
<pre>  // Define getter/setter style accessors.. 
  // defaults assigned 
  my.accessor('example', true); </pre>
<p>We use the <kbd>svg</kbd> variable at this level of scope to maintain state when quickly appending selectors. The <kbd>void 0</kbd> is a safer way to initialize the variable as undefined:</p>
<pre>  // Data for Global Scope 
  var svg = void 0, 
      chart = void 0; </pre>
<p>Define the D3 instance functions that will be used throughout the visualization:</p>
<pre>  // Declare D3 functions, also in instance scope 
  var x = d3.scale.linear(), 
      y = d3.scale.ordinal(); </pre>
<p>The following function represents the main interface to the outside world. There is also a set of setup functions commonly seen in D3 visualizations. The SVG container is set up in a way that can easily look for existing SVG containers in the selector and rebind the data. This makes it much easier to redraw when making subsequent calls with new data:</p>
<pre>  my.draw = function(selection) { 
    selection.each(function(data) { 
      // code in base/scripts.js 
      // resuable way of dealing with margins 
      svg = my.setupSVG(this); 
      chart = my.setupChart(svg); 
 
      // Create the visualization 
      my.chart(data); 
    }); 
  }; 
 
  // main method for drawing the viz 
  my.chart = function(data) { 
    var chartData = my.profit(data); 
 
    x.domain([0, my.profitMax(chartData)]) 
        .range([0,my.w()]); 
    y.domain(my.categories(chartData)) 
        .rangeRoundBands([0, my.h()], 0.2); 
 
    var boxes = chart.selectAll('.box').data(chartData); 
 
    // Enter 
    boxes.enter().append('rect') 
        .attr('class', 'box') 
        .attr('fill', 'steelblue'); 
 
    // Update 
    boxes.transition().duration(1000) 
        .attr('x', 0) 
        .attr('y', function(d) { return y(d.category) }) 
        .attr('width', function(d) {  return x(d.profit) }) 
        .attr('height', y.rangeBand()) 
 
    // Exit 
    boxes.exit().remove(); 
  }; </pre>
<p>Notice that the <kbd>chart</kbd> function relies on several helper functions (shown in the following lines of code) to work with the data. It is also written in such a way that we can take advantage of the enter/update/exit pattern:</p>
<pre>  // Example function to create profit. 
  my.profit = function(data) { 
    return data.map(function(d) { 
      d.profit = parseFloat(d.sales) - parseFloat(d.cost); 
      return d; 
    }); 
  }; </pre>
<p>This function is used to create a new data structure that has profit assigned. Note that it takes one data array in as a parameter and returns a newly constructed array with the profit attribute added. This function is now exposed externally with <kbd>viz().profit(data)</kbd> and can be easily tested. It does not change any of the outside global variables. It is just data in and new data out:</p>
<pre>  my.categories = function(data) { 
    return data.map(function(d) { 
      return d.category; 
    }); 
  }; </pre>
<p>This is the exact same pattern as <kbd>my.profit(data)</kbd>. We will take the data structure in as input and return a new data structure, that is, an array of all the categories. In the preceding lines of code, you saw that this is leveraged to create the input domain.</p>
<pre>  my.profitMax = function(data) { 
    return d3.max(data, function(d) { return d.profit; }); 
  }; </pre>
<p>Once again, a simple function to take data in, compute the max, and return that maximum value. It is very easy to test and verify with <kbd>d3.charts.viz().profitMax(data)</kbd>?</p>
<pre>   return my; 
  }; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit testing</h1>
                
            
            
                
<p>Now that we have a code base written in a testable way, let's automate those tests so that we do not have to perform them manually and can continue to code and refactor with ease.</p>
<p>If you look at the <kbd>spec/viz_spec.js</kbd> file, you will note some common patterns when unit testing. The following code is written with a JavaScript unit-testing framework called Jasmine and leverages Karma to execute the tests. You can learn more about the Jasmine syntax, assertions, and other features at <a href="http://jasmine.github.io/1.3/introduction.html">http://jasmine.github.io/1.3/introduction.html</a>.</p>
<p>The Bootstrap project has everything you need to start testing quickly.</p>
<p>The first step is to start our Karma test runner with this line of code:</p>
<pre>node_modules/karma/bin/karma start </pre>
<p>This runner will watch every edit of the <kbd>viz.js</kbd> file or the <kbd>viz_spec.js</kbd> file. If any changes are detected, it will automatically rerun every test suite and provide the output on the console. If all the tests pass, then the output will be all green. If something fails, you will receive a red warning message:</p>
<pre>'use strict'; 
 
describe('Visualization: Stacked', function () { 
  var viz; 
 
  var data = [ 
    {"category": "gold",  "cost": "10",  "sales": "60"}, 
    {"category": "white", "cost": "20",  "sales": "30"}, 
    {"category": "black", "cost": "100", "sales": "140"} 
  ]; </pre>
<p>Create some test data to test your D3 data manipulation functions. The preceding <kbd>describe</kbd> syntax defines the test harness you are about to execute:</p>
<pre>  beforeEach(function() { 
    viz = d3.charts.viz() 
        .height(600) 
        .width(900) 
        .margin({top: 10, right: 10, bottom: 10, left: 10}); 
  }); </pre>
<p>Before every test run, create a new instance of the D3 visualization with some default setters:</p>
<pre>  it ('sets the profit', function() { 
    var profits = viz.profit(data); 
    expect(profits.length).toBe(3); 
    expect(profits[0].profit).toBe(50) 
  }); </pre>
<p>This is our first test case! In this test, we asserted that we are getting a new array from our test data, but with an additional profit attribute. Remember that we created the function to have no side effects and to be a small unit of work. We will reap the fruits of our labor with this easy-to-test method. Just as we did earlier, we will test the list of categories now:</p>
<pre>  it ('returns a list of all categories', function() { 
    var categories = viz.categories(data); 
    expect(categories.length).toBe(3); 
    expect(categories).toEqual([ 'gold', 'white', 'black' ]); 
  }); </pre>
<p>Calculate the maximum profit, as follows:</p>
<pre>  it ('calculates the profit max', function() { 
    var profits = viz.profit(data); 
    expect(viz.profitMax(profits)).toEqual(50); 
  }); </pre>
<p>The following are additional example tests to validate that the <kbd>height</kbd>/<kbd>width</kbd>, bearing in mind the margins, is working properly from our <kbd>base.js</kbd> function:</p>
<pre>  it ('calculates the height of the chart box', function() { 
    expect(viz.h()).toBe(580); 
    viz.height(700); // change the height 
    viz.margin({top: 20, right: 10, bottom: 10, left: 10}) 
    expect(viz.h()).toBe(670); 
  }); 
 
  it ('calculates the width of the chart box', function() { 
    expect(viz.w()).toBe(880); 
    viz.height(700); // change the height 
    viz.margin({top: 10, right: 10, bottom: 10, left: 20}) 
    expect(viz.w()).toBe(870); 
  }); </pre>
<p>As an experiment, try adding new test cases or editing the existing one. Watch the test runner report different results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating resilient visualization code</h1>
                
            
            
                
<p>We want to make sure that our visualization can react to changing data, with minimal effort from the program that calls our code. One way to test different permutations of data and ensure that the visualization reacts accordingly is to randomly create example data, call the visualization code a number of times, and witness the result. These operations are handled in the <kbd>factories</kbd> directory. Let's take a look at the <kbd>viz_factory.js</kbd> file as an example:</p>
<pre>(function() { 
    var viz = d3.charts.viz(); </pre>
<p>Create a variable to store our function with <kbd>getters</kbd> and <kbd>setters</kbd> as closures. In this example, we will use an anonymous function as a wrapper to execute the code. This prevents conflicts with other JavaScript code and ensures that our visualization will work properly in a protected context:</p>
<pre>    var rand = function() { 
      return Math.floor((Math.random() * 10) + 1) 
    }; </pre>
<p>A simple helper function that generates a random number between 1 and 10 is as follows:</p>
<pre>    var data = function() { 
      return [1,2,3].map(function(d,i) { 
        var cost = rand(); 
        var sales = rand(); 
 
        return { 
          category: 'category-'+i, 
          cost: cost, 
          sales: cost + sales 
        }; 
      }); 
    }; </pre>
<p>Generate a fake dataset based on random numbers:</p>
<pre>    d3.select("#chart").datum(data()).call(viz.draw); </pre>
<p>Draw the visualization for the first time using these lines of code:</p>
<pre>      var id = setInterval(function() { 
        var d = data(); 
        console.log('data:', d); 
        d3.select("#chart").datum(d).call(viz.draw); 
      }, 2000); 
      setTimeout(function() { 
      clearInterval(id); 
      }, 10000); </pre>
<p>Set a timer for 10 seconds and bind new data to the visualization on iteration. The expected behavior is that the visualization will redraw itself on each call. Notice how simple it is to pass new data to the visualization. It is a simple selector with a new dataset. We have constructed the reusable visualization code in such a way that it knows how to react appropriately.</p>
<p>To see the results in action, simply launch <kbd>http-server</kbd>, as follows:</p>
<pre>node_modules/http-server/bin/http-server  </pre>
<p>Now, visit <kbd>http://localhost:8080</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a new test case</h1>
                
            
            
                
<p>What happens if we change the number of datasets in the array? To test this, let's add a new helper function (called <kbd>set()</kbd>) to randomly generate a new set of data with a random number of elements between 1 and 10:</p>
<pre>    var set = function() { 
      var k = rand(); 
      var d = []; 
      for (var i = 1; i &lt; k; i++) { 
        d.push[i]; 
      }; 
      return d; 
    }; </pre>
<p>Modify the <kbd>data</kbd> function slightly. We will print to the console to validate that it is working properly:</p>
<pre>    var data = function() { 
      var d = set(); 
      console.log('d', d); 
      return d.map(function(d,i) { 
        var cost = rand(); 
        var sales = rand(); 
 
        return { 
          category: 'category-'+i, 
          cost: cost, 
          sales: cost + sales 
        }; 
      }); 
    }; </pre>
<p>Now, if we look at <kbd>http://localhost:8080</kbd> again, we can see that the visualization is working properly even with a random amount of data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we described the techniques to help test your D3 code base and to keep it healthy over the lifespan of your project. We also went step by step through a Bootstrap project to help you get started with these examples, and we took a look at a methodology for structuring your work.</p>
<p>Our recommendations are based on many years of experience and many projects delivered using D3. We strongly recommend that you follow good software patterns and focus on tests; this will allow you to perfect your craft. Quality is in your hands now. </p>


            

            
        
    </body></html>