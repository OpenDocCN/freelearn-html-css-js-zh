- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CI/CD Pipeline for Your Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) and **continuous delivery/deployment**
    (**CD**) are fundamental practices in modern software development, forming the
    backbone of efficient DevOps workflows. Together, they automate and streamline
    the processes of integrating code changes, testing, and deploying applications,
    ensuring that software is always in a deployable state.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: One of the modern software development requirements for developers is to at
    least understand and have essential skills for building pipelines and working
    with different automation systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about understanding and applying CI/CD to your microservices.
    Developing these fundamental DevOps skills will help you stay aligned with modern
    development practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of CI/CD processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Azure Cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with GitHub actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need any previous experience of CI/CD to cover and understand the
    current chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of CI/CD processes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI and CD are essential practices in Node.js microservice development to streamline
    both the development and release processes. CI automates the integration of code
    changes into the main branch, ensuring each update is tested and validated through
    automated testing. This reduces the risk of integration issues and helps maintain
    code quality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In the CD pipeline, every successful build from CI is automatically deployed
    to production or staging environments. This automation significantly reduces the
    time between development and release, allowing teams to quickly iterate on features
    and address issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is the practice of frequently integrating code changes into a shared repository.
    This process is typically automated, with code being merged and tested multiple
    times a day. The main goals of CI are to detect integration issues early, reduce
    the chances of bugs reaching production, and ensure that new code is always compatible
    with the existing code base.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we commit our code changes frequently (often several times a
    day) to a shared repository. This reduces the chances of conflicts and integration
    issues. When we have automated systems such as CI, after every commit, an automated
    build process is triggered. The code is compiled, and necessary dependencies are
    resolved. This ensures that the code base remains in a buildable state at all
    times. A successful build is an indication that the code base is in a healthy
    state and can proceed to the next steps, such as testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests are executed after the build process. These tests can include
    unit tests, integration tests, and sometimes even end-to-end tests. The goal is
    to catch any bugs or issues early in the development cycle. If the build or tests
    fail, developers receive immediate feedback. This allows them to address issues
    quickly before they become bigger problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Every time a new code change is committed, an automated build process is triggered.
    This process compiles the code, resolves dependencies, and packages the application
    if necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每次提交新的代码更改时，都会触发一个自动构建过程。此过程编译代码，解决依赖关系，并在必要时打包应用程序。
- en: CI encourages the use of a single shared repository, which acts as the *single
    source of truth* for the project. This repository contains the most up-to-date
    and stable version of the code base, ensuring that all team members are working
    from the same foundation. This practice especially helps in maintaining consistency
    across the team.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CI鼓励使用单个共享仓库，该仓库作为项目的*单一事实来源*。此仓库包含代码库的最新和稳定版本，确保所有团队成员都从相同的基础工作。这种做法特别有助于在团队中保持一致性。
- en: 'Now, let’s try to cover the benefits of CI:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试涵盖CI的好处：
- en: '**Early bug detection**: By integrating code changes frequently and running
    automated tests with each integration, CI allows teams to detect bugs and issues
    early in the development process. This early detection reduces the cost and complexity
    of fixing bugs.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期错误检测**：通过频繁集成代码更改并运行每次集成时的自动化测试，持续集成（CI）使团队能够在开发过程中早期发现错误和问题。这种早期检测减少了修复错误的成本和复杂性。'
- en: '**Reduced integration conflicts**: Frequent integration of code changes means
    that conflicts are detected and resolved quickly.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少集成冲突**：频繁集成代码更改意味着冲突可以快速检测和解决。'
- en: '**Faster development cycles**: Automated builds and tests free up developer
    time by eliminating the need for manual testing and build processes. This leads
    to faster development cycles and quicker delivery of new features and bug fixes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加快开发周期**：自动化构建和测试通过消除手动测试和构建过程的需求，为开发者节省时间。这导致开发周期加快，新功能和错误修复的交付更快。'
- en: '**Improved code quality**: Automated testing as part of CI ensures that only
    code that passes a predefined set of tests is integrated into the mainline. This
    improves the overall quality and stability of the code base.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：作为CI一部分的自动化测试确保只有通过预定义测试集的代码才能集成到主线中。这提高了代码库的整体质量和稳定性。'
- en: '**Enhanced collaboration**: CI encourages collaboration among team members
    by making it easier to integrate and share code. This fosters a culture of transparency
    and collective ownership of the code base.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强协作**：CI通过简化代码集成和共享，鼓励团队成员之间的协作。这促进了透明度和代码库集体所有权的文化。'
- en: '**Continuous feedback**: Continuous feedback loops provide developers with
    immediate information about the impact of their changes. This helps in maintaining
    high code quality and reduces the time spent on debugging and troubleshooting.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续反馈**：持续的反馈循环为开发者提供有关其更改影响的信息。这有助于保持高代码质量，并减少调试和故障排除所花费的时间。'
- en: 'A CI workflow helps the team to catch bugs early, reduce integration challenges,
    and improve collaboration among team members. By automating the process of testing
    and building, CI ensures that the code base remains stable and ready for further
    development or deployment, promoting a faster and more reliable release cycle.
    Here is how it works:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CI工作流程帮助团队早期捕捉错误，减少集成挑战，并改善团队成员之间的协作。通过自动化测试和构建的过程，CI确保代码库保持稳定，并准备好进一步的开发或部署，促进更快和更可靠的发布周期。以下是它是如何工作的：
- en: '**Developer makes changes**: Step one is about making changes. A developer
    writes new code or modifies existing code on their local machine. Once the changes
    are complete, they commit the changes to the **version control system** (**VCS**),
    such as Git.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开发者进行更改**：第一步是进行更改。开发者在其本地机器上编写新代码或修改现有代码。一旦更改完成，他们将更改提交到**版本控制系统**（**VCS**），例如Git。'
- en: '**Code is pushed to the repository**: The developer pushes the committed changes
    to the shared repository. This triggers the CI process.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码推送到仓库**：开发者将提交的更改推送到共享仓库。这触发了CI过程。'
- en: '**CI server detects changes**: A CI server (e.g., Jenkins, Travis CI, CircleCI,
    or GitHub Actions) monitors the repository for new changes. When a change is detected,
    the CI server automatically triggers a build process.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CI服务器检测更改**：CI服务器（例如Jenkins、Travis CI、CircleCI或GitHub Actions）监控仓库以查找新更改。当检测到更改时，CI服务器自动触发构建过程。'
- en: '**Build is automated**: The CI server pulls the latest code and initiates the
    build process. This involves compiling the code, resolving dependencies, and creating
    build artifacts if necessary. Tools such as Maven, Gradle, and Ant are used to
    automate the build process, manage dependencies, and compile the code.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing is automated**: After a successful build, the CI server runs automated
    tests. These tests can include unit tests, integration tests, and other types
    of tests specific to the project. If the tests pass, the CI process continues.
    If any test fails, the process is halted, and the developer is notified of the
    failure. JUnit, NUnit, Mocha, Jest, and Selenium are examples of testing frameworks
    used to write and execute automated tests.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feedback is given to developers**: The CI server provides feedback to the
    developer, typically through notifications or a web interface. If the build or
    tests fail, the feedback includes details about the failure, helping the developer
    to quickly identify and fix the issue.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Changes are merged to mainline**: Once the build and tests pass, the changes
    are merged into the mainline or master branch of the repository. This branch always
    represents the latest stable version of the code.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Builds are deployed**: In some cases, successful builds might be automatically
    deployed to a staging environment for further testing. This can be part of a CD
    pipeline.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI workflow is designed to automate the integration of code changes, ensuring
    that new updates are quickly tested and validated before being merged into the
    mainline. By following this structured process, teams can catch issues early,
    reduce integration headaches, and deliver high-quality code more efficiently.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Several tools and platforms play an important role in implementing CI in software
    development projects. These tools ensure that code integration, building, and
    testing processes are automated and efficient. VCSs such as Git and Subversion,
    manage and track changes in the code base, while CI servers such as Jenkins and
    GitHub Actions automate the build and test process. Build tools such as Maven
    and Gradle handle dependencies and compilation, and testing frameworks such as
    Mocha and Jest enable automated testing, ensuring code quality at every stage
    of development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CD
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD is a software engineering practice that enables teams to develop and release
    software in shorter, more frequent cycles, ensuring it can be deployed at any
    moment with confidence. As an evolution of CI, CD emphasizes not just building
    and testing code but also automating the deployment process to production environments,
    allowing for faster and more reliable releases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the core principles of CD:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated testing**: Every change goes through an automated testing process
    to ensure that it is production-ready.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated deployment**: The deployment process is automated, reducing the
    risks and errors associated with manual deployments.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental updates**: Software is released in small, manageable chunks rather
    than large, monolithic updates.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment parity**: The testing, staging, and production environments are
    kept as similar as possible to avoid unexpected issues during deployment.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous feedback**: Constant monitoring and feedback from the production
    environment allow for quick detection and resolution of issues.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is great, but how do we apply it to our Node.js microservices? Applying
    CD to a Node.js microservice architecture involves several steps.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Integrating CI/CD into microservices
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integrating CI/CD into microservices ensures seamless, automated deployment
    and testing of independent services, enabling faster development cycles and consistent,
    reliable updates. This approach enhances scalability and agility by streamlining
    the release process across distributed microservice architectures. Here is how
    we can integrate it in terms of Node.js microservices:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to set up CI. You can use a CI tool such as **GitHub Actions**,
    **Jenkins**, or another tool to automate the process of building, testing, and
    packaging your Node.js microservices. Make sure that your CI pipeline runs unit
    tests, integration tests, and static code analysis on every commit.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Docker to containerize each Node.js microservice. This ensures that the
    service runs consistently across different environments. Define a Docker file
    for each microservice to specify the dependencies, environment variables, and
    startup commands.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is writing automated tests for each microservice, covering unit
    tests, integration tests, and end-to-end tests. Use a test framework such as **Mocha**,
    **Jest**, or **Supertest** to write and run your tests.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, ensure your CI pipeline runs these tests on every code change.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second huge step is to set up a CD pipeline. Extend your CI pipeline to
    deploy your microservices to a staging environment automatically. This can be
    done using the previously mentioned tools such as GitHub Actions, Jenkins, or
    other tools. Use a deployment tool such as **Kubernetes**, **Docker Swarm**, or
    **AWS ECS** (**Elastic Container Service**) to manage your containers in the staging
    and production environments.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate the deployment process by defining scripts that push the Docker images
    to a container registry (such as Docker Hub or AWS ECR) and update the services
    in the staging environment.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your local, testing, staging, and production environments are as
    similar as possible. This reduces the chances of environment-specific bugs.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To manage different configurations for each environment, don’t forget to use
    environment variables.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement monitoring and logging for your microservices using tools such as
    Prometheus, Grafana, ELK Stack, or Datadog. Set up alerts to notify your team
    of any issues in the production environment.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use deployment strategies such as canary releases or blue-green deployments
    to minimize the risk when deploying new versions of your microservices. This allows
    you to test new versions with a small percentage of users before rolling them
    out to the entire user base.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the performance and logs of your services in production. Gather feedback
    from users and automatically roll back if a deployment causes issues.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuously iterate on your processes and tools to improve your CD pipeline.
    By following these steps, you can effectively implement CD in your Node.js microservice
    development process, allowing for faster, safer, and more reliable deployments.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CI and CD are closely related concepts in modern software development, but they
    focus on different stages of the software development life cycle. Here’s how they
    differ.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of CI is integrating code changes from multiple developers into
    a shared repository, multiple times a day. It also ensures that the code is always
    in a deployable state by catching integration issues early. Hence, a CI pipeline
    focuses on integrating and testing code. It includes stages such as code linting,
    unit tests, integration tests, and sometimes code coverage reports.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, CD builds on CI by automating the delivery of code changes
    to various environments, such as staging and production, after they pass the CI
    pipeline. The primary goal of CD is to then ensure that code is always ready to
    be released to production, and releases can happen frequently and reliably. A
    CD pipeline extends the CI pipeline to include steps for deploying the code to
    various environments. This can include deployment scripts, environment configuration,
    and automated rollback mechanisms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In essence, CI is the foundation, and CD extends it to cover the deployment
    aspect, allowing for continuous delivery of new features and updates to end users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Working with Azure Cloud
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **cloud** refers to a network of remote servers hosted on the internet,
    which are used to store, manage, and process data, rather than relying on a local
    server or personal computer. It allows businesses and individuals to access computing
    resources on-demand, such as storage, computing power, databases, and more, from
    anywhere in the world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Azure is Microsoft‘s cloud computing platform, providing a wide range of services
    such as virtual machines, databases, AI tools, and more. It enables developers
    and businesses to build, deploy, and manage applications through a global network
    of Microsoft-managed data centers. Azure offers flexibility, scalability, and
    cost-effectiveness, making it suitable for everything from small startups to large
    enterprises.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Using **Azure cloud** provides several advantages, including seamless integration
    with Microsoft‘s ecosystem, high availability, and robust security features. It
    also supports hybrid cloud environments, allowing businesses to connect their
    on-premises infrastructure with the cloud. Azure’s global presence ensures low
    latency and compliance with regional regulations. Additionally, it offers advanced
    analytics, AI, and machine learning services, empowering businesses to innovate
    and stay competitive in the digital age.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To make our example as simple as possible, we will work on the `Account` microservice
    from [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074). We will begin by obtaining
    all the resources necessary for our example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Our `Account` service stores data in the Postgres database. We will deploy our
    application to Azure, but you can use any cloud infrastructure you want.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an **Azure Resource Group** to deploy our application.
    We can do that with the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a Postgres resource to store data on Azure. Go to [http://portal.azure.com](http://portal.azure.com)
    and register to get a free account if you haven’t registered yet. Using a free
    subscription, you can get $200 of free credit toward Azure products and services,
    plus twelve months of popular free services.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to set up Azure resources using the Azure portal and create
    a resource group:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the Azure portal.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left sidebar, select **Resource Groups**.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create**.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the necessary details, such as the subscription, resource group name,
    and region, then click **Review + create** (*Figure 13**.1*):'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1: Creating a resource group in Azure](img/B09148_13_001.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Creating a resource group in Azure'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create an App Service plan:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `App Service plans` in the search bar and select
    the top result.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create**.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your subscription, select the resource group you just created, and enter
    a name for your App Service plan.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Operating System**, select **Linux**.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a pricing tier (e.g., **B1** for a basic plan).
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Review +** **create**.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an App Service plan in Azure is an essential step when deploying web
    apps, APIs, and other workloads using Azure App Services. The App Service plan
    defines the underlying infrastructure that powers your web app, API, or function
    app. It determines how your application is hosted, including the amount of CPU
    (processing power), memory (RAM), storage (disk space), and networking capacity
    it uses.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By creating an App Service plan, you specify the resources and capacity needed
    to run your application, ensuring it has the necessary performance to handle the
    expected load. It directly influences the cost of running your application in
    Azure by giving the following two options:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pricing tier**: The plan you choose determines the pricing tier, which affects
    the cost based on the resources allocated. Azure offers various pricing tiers,
    from free and shared tiers for small apps to premium tiers for high-performance,
    production-grade apps.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling options**: An App Service plan also defines the scaling options for
    your application. You can scale up (increase the size of the instance) or scale
    out (increase the number of instances) based on your application’s needs. Different
    pricing tiers offer different scaling capabilities.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 13**.2* shows how to create an App Service plan in Azure:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.2: Creating an App Service Plan in Azure](img/B09148_13_002.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Creating an App Service Plan in Azure'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is creating a web app:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `App Services` and select the top result.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** and select **Web App**.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your subscription, select your resource group, and enter a name for your
    web app. Make sure you have selected a unique name for your web app.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Publish**, select **Code**.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Runtime stack**, select **Node 20 LTS**. (Select the node version
    you think is better for your needs).
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Operating System**, choose **Linux**.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Region**, select the region closest to you or your users.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **App Service Plan**, select the plan you created earlier.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Review + create** and then **Create**. See *Figure 13**.3*:'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3: Creating a web app in Azure](img/B09148_13_003.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Creating a web app in Azure'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create an Azure Cosmos DB for the MongoDB API:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `Azure Cosmos DB` and select **Create**.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure will ask you to select the type of resource, which will either be a requesting
    **unit database account** or **vCore cluster**. vCore Cluster is a recommended
    resource by Microsoft.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **API**, choose **Azure Cosmos DB** **for MongoDB**.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your **Subscription**, **Resource Group**, **Account Name**, and other
    necessary details.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Review + create** and then **Create**:'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4: Selecting Azure Cosmos DB for MongoDB](img/B09148_13_004.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Selecting Azure Cosmos DB for MongoDB'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the Azure Cosmos DB account creation page in the following figure:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The Azure Cosmos DB account creation page](img/B09148_13_005.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The Azure Cosmos DB account creation page'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us obtain a MongoDB connection string:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Cosmos DB account is created, go to the **Overview** page.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Connection String** under the **Settings** section.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the eye icon.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy **Primary** **Connection String**:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.6:\uFEFF Connection string page in Azure](img/B09148_13_006.jpg)"
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Connection string page in Azure'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We’re done with resource obtaining. It is time for configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s configure the Azure web app to use MongoDB. For that, navigate to
    your web app:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, go to `MONGODB_URL`) and **Value** (paste the MongoDB connection
    string you copied earlier).
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** and then **Save**.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, it’s time to prepare your Node.js application. Ensure your Node.js
    application is set up to read the MongoDB connection string from environment variables.
    Here are the steps to achieve it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `src/config/config.js` file and change the `createConfig` function
    like so:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run our Node.js application, it automatically connects to a port number
    equal to `3001` (depending on what you encoded in the `.env` file). We updated
    the `.env` file by default to use `PORT=443`. Here is what it looks like:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also applied minor changes to the `src/index.js` file to support the `winston`
    library and to use the port from the process:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you might guess, for both previous examples, we used `process.env`. Using
    `process.env.PORT` and `process.env.MONGODB_URL` in Node.js applications is a
    best practice for managing environment-specific configurations.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Node.js applications often need to run in different environments (development,
    testing, staging, production), each with its own set of configurations. Using
    environment variables allows you to customize behavior based on the environment
    without changing the code. Now, let’s take a closer look at the environment variables
    used in our code:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`process.env.PORT` is used to define the port number on which the Node.js application
    will listen for incoming requests. By using an environment variable for the port,
    you can easily run the application on different ports depending on the environment.
    For example, in a development environment, you might want to run it on port `3000`,
    while in production, the application might need to run on a port assigned by a
    hosting provider (e.g., Azure, Heroku). Cloud providers often assign dynamic ports
    to applications. By using `process.env.PORT`, your application can adapt to whatever
    port is assigned at runtime.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.env.MONGODB_URL`, on the other hand, is used to define the connection
    string for your MongoDB database. Storing sensitive information such as database
    connection strings in environment variables keeps them out of your source code,
    which is a security best practice. This prevents accidental exposure in VCSs (e.g.,
    Git). Different environments may use different databases or database servers.
    For example, a development environment might use a local MongoDB instance, while
    production uses a managed MongoDB service such as MongoDB Atlas. By using `process.env.MONGODB_URL`,
    you can easily switch between these without changing your code.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After successful deployment, Azure should run your application. That is why
    you need to update the `package.json` file to have the `start` script, like the
    following:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But how about the package installation process? As you know, we don’t publish
    `node_modules`, but it should be on the server to run your application properly.
    To handle node module installation and execute the start command from `package.json`,
    you can follow the following steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Go to **App Services** from the Azure portal.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your web app.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Settings**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Configuration**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **General Settings**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `npm install &&` `npm start`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.7:\uFEFF Startup command for an Azure web app](img/B09148_13_007.jpg)"
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Startup command for an Azure web app'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not the only option for running Node.js applications properly
    but for this example, it is more than enough.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Now, everything is ready. We can implement our pipeline using GitHub Actions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Working with GitHub Actions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub Actions** is a powerful feature of GitHub that allows you to automate,
    customize, and execute software development workflows directly in your GitHub
    repository. It’s designed to help you build, test, and deploy your code right
    from GitHub. GitHub Actions is a tool that helps you automate tasks within your
    software development life cycle. For our case, we’ll create a workflow that automatically
    deploys your Node.js microservice to Azure whenever you push changes to the main
    branch.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an account if you haven’t yet. After account creation, create
    a repository that will store your source code. Next, let’s look at some key features
    of GitHub Actions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation of workflows**: GitHub Actions enables you to automate tasks such
    as running tests, building applications, deploying to cloud services, and more
    whenever specific events occur in your repository (e.g., a push to a branch, a
    pull request, or the creation of an issue). You can also use GitHub Actions to
    run linting tools or static analysis on your code, ensuring that code quality
    standards are maintained.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.github/workflows/` directory of your repository. These files describe the
    automated processes you want to run.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven**: Actions can be triggered by various GitHub events, such as
    pushes, pull requests, issue creation, or on a scheduled basis. This flexibility
    allows you to create workflows that are finely tuned to your development process.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in CI/CD**: GitHub Actions provides built-in support for CI and CD.
    You can use it to automatically test your code and deploy it to production or
    a cloud service such as AWS, Azure, or Heroku after every commit.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable actions**: You can reuse actions created by the community or share
    your own actions across projects. GitHub has a marketplace where you can find
    actions for various tasks such as setting up languages, deploying to cloud services,
    and more.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets management**: You can securely manage and use sensitive information
    such as API keys, tokens, and other credentials in your workflows without exposing
    them in your code.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling tasks**: You can use GitHub Actions to run scripts or maintenance
    tasks, such as nightly builds or database backups, on a schedule.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions integrates seamlessly with other GitHub features, such as *Issues*,
    *Pull Requests*, and *Packages*, making it easy to create workflows that encompass
    the full development life cycle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at Secrets in GitHub Actions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Secrets
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Secrets** in GitHub Actions are encrypted environment variables that you
    use in your workflows. They are stored securely and can be accessed within your
    workflows without exposing sensitive information.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To securely pass your Azure credentials (such as the publish profile) to GitHub
    Actions, you need to add them as **Secrets**. Here is how you can do it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal and navigate to your web app.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the web app’s **Overview** page, look for the **Get Publish Profile** button
    and download the publish profile file. It’s an XML file that contains the credentials
    your GitHub Actions workflow will use to deploy the app. Don’t forget to change
    **Platform settings** from your Azure web app’s **Settings-Configuration** tab.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you do it, you will be able to download the publish profile (*Figure 13**.8*).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the `<web_app_name>.PublishSettings` (it is `account-microservice-webapp.PublishSettings`
    in our case).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing an Azure publish profile to GitHub Actions is essential for automating
    the deployment of your application to Azure. The publish profile contains credentials
    that GitHub Actions uses to authenticate and authorize the deployment to your
    Azure resources. This ensures that only authorized processes can deploy your application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: It also includes all the necessary settings for deploying your application to
    a specific Azure App Service or other resources. It simplifies the configuration,
    avoiding manually defining all the deployment details in your workflow.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a publish profile in GitHub Actions allows you to securely store and
    manage the credentials as secrets within your GitHub repository. This prevents
    exposing sensitive information in your workflow files. Here is what platform settings
    should look like to download the publish profile:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.8:\uFEFF Platform settings to download the publish profile](img/B09148_13_008.jpg)"
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Platform settings to download the publish profile'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create Secrets in GitHub:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Go to your GitHub repository.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Settings** | **Secrets** | **Actions**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following secrets:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AZURE_WEBAPP_PUBLISH_PROFILE`: The entire contents of the publish profile
    from Azure (*Figure 13.9*).'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONGODB_URL`: At this point, you should paste the MongoDB connection string
    that you copied earlier. If you have not yet retrieved it, please do so now before
    continuing. Here is how we can do it:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure 13.9:\uFEFF Adding the Azure web app’s publish profile](img/B09148_13_009.jpg)"
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Adding the Azure web app’s publish profile'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Using Secrets is crucial because it prevents sensitive data from being exposed
    in your repository’s code or logs. Only authorized workflows can access these
    secrets.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We have now provided all the secret information to GitHub, so let’s focus on
    building a simple pipeline using GitHub Actions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Building a pipeline
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While GitHub Actions doesn’t explicitly use the term **pipeline** in its documentation,
    a pipeline is a broader concept that represents the sequence of processes that
    code goes through from development to production. In many CI/CD tools, a pipeline
    typically consists of multiple stages (such as build, test, and deploy) that are
    executed in a specific order.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: A `.github/workflows/` directory of a repository. Workflows are triggered by
    events, such as pushes to the repository, pull requests, or scheduled events.
    Each workflow can have multiple jobs that run in parallel or sequentially, and
    each job can have multiple steps that execute commands or actions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A workflow is defined in a `.yml` file. Here is how we define it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: To create this file, you should open your web browser and go to your GitHub
    repository. Inside your repository, click on the **Add file** button, then choose
    **Create** **new file**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `.github/workflows/azure-deploy.yml`. This will create the necessary
    directory structure and file. Commit the `azure-deploy.yml` file and push it to
    your GitHub repository.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `azure-deploy.yml` file consists of multiple steps. For a more complete
    example, check our GitHub repository (`Ch13/.github/workflows/azure-deploy.yml`).
    Here is our first step:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The GitHub Actions workflow file, named `CI/CD Pipeline`, is set up to automatically
    trigger whenever there is a push to the `main` branch of the repository. This
    means that any changes committed and pushed to the `main` branch will activate
    the defined workflow. The `on: push:` section specifies the event that starts
    the workflow – in this case, a push event to the `main` branch. This setup is
    commonly used for CI/CD, ensuring that updates to the `main` branch automatically
    go through the build, test, and deployment processes defined in the workflow.'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s continue by discussing the next lines in our workflow file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This part of the GitHub Actions workflow defines a job named `security-scan`,
    which is responsible for running a security scan on your code base. The job will
    execute on the latest version of Ubuntu, as specified by `runs-on: ubuntu-latest`.'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within this job, several steps are outlined. The first step, `Checkout code`,
    uses the `actions/checkout@v3` action to clone the repository’s code into the
    workflow’s environment. Next, the `Set up Node.js` step sets up Node.js version
    20 in the environment using the `actions/setup-node@v3` action. After the environment
    is ready, the `Install dependencies` step runs `npm install` to install all required
    Node.js packages. Finally, the `Run npm audit` step executes the `npm audit --audit-level=high`
    command, which checks for security vulnerabilities in the installed packages,
    focusing on those with a high severity level. This job ensures that your application
    is scanned for critical security issues as part of the CI/CD pipeline.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code of the GitHub Actions workflow defines a job called `check-dependencies`,
    which is designed to check whether any dependencies in your project are outdated.
    The job will run on the latest version of Ubuntu, as indicated by `runs-on: ubuntu-latest`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `needs: security-scan` line specifies that this job will only run after
    the `security-scan` job has successfully completed. This creates a dependency
    between the two jobs, ensuring that the security scan must pass before checking
    for outdated dependencies.'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The job contains several steps. First, the `Checkout code` step uses the `actions/checkout@v3`
    action to clone the repository’s code into the environment. Then, the `Install
    dependencies` step runs `npm install` to install all the necessary Node.js packages
    for the project. Finally, the `Check for outdated dependencies` step runs `npm
    outdated`, which lists any dependencies that have newer versions available. This
    job helps maintain the health of your project by ensuring that you are aware of
    any outdated packages that might need updating.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following part of the GitHub Actions workflow defines a job named `test`,
    which is responsible for running tests on your code base. The job runs on the
    latest version of Ubuntu, as specified by `runs-on: ubuntu-latest`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `needs: check-dependencies` line indicates that this job will only start
    after the `check-dependencies` job has successfully completed. This ensures that
    all dependencies are up-to-date before tests are run, which is important for ensuring
    consistency and reliability in your testing process.'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The job consists of several steps. First, the `Checkout code` step uses the
    `actions/checkout@v3` action to clone the repository’s code into the workflow
    environment. Then, the `Set up Node.js` step configures Node.js version 20 in
    the environment using the `actions/setup-node@v3` action. Following this, the
    `Install dependencies` step runs `npm install` to install the necessary packages
    for the project. Finally, the `Run tests` step executes the `npm test` command,
    which runs the test suite defined in your project. This job ensures that your
    code is tested in a controlled environment, catching any issues before changes
    are merged or deployed.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following part of the workflow is responsible for deploying your application
    to the Azure web app after the tests have been completed. The job runs on an Ubuntu-based
    virtual machine provided by GitHub Actions. Before deployment, the workflow checks
    out the latest version of your code to ensure that the most recent changes are
    included:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In preparation for deployment, the workflow cleans up unnecessary files and
    directories, such as the `.git` folder (which contains the repository’s Git history),
    the `.github` folder (used for GitHub-specific configurations), and other temporary
    or internal folders that aren’t needed in the deployed application. This cleanup
    helps reduce the deployment package size and eliminates any files that aren’t
    required for the application to run.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the workflow uses the `azure/webapps-deploy@v3` action to deploy the
    application to the specified Azure web app. The `app-name` configuration is set
    to match the site name in your Azure publish profile, and the `publish-profile`
    secret contains the necessary credentials. The package to be deployed is set to
    the entire workspace, ensuring that the cleaned-up code is what gets deployed.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you push your changes, GitHub Actions will automatically trigger the workflow.
    Monitor the deployment process in the **Actions** tab of your GitHub repository:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.10:\uFEFF GitHub Actions workflow](img/B09148_13_010.jpg)"
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: GitHub Actions workflow'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what success deployment logs look like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once deployment succeeds, you can check the deployed files using a simple FTPS
    connection. To connect to your server using an FTP client, you can use any FTP
    client tools you want. We use FileZilla, which is free and easy to use. You can
    download it from [https://filezilla-project.org/](https://filezilla-project.org/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To find FTP credentials for your server, follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **App Services**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find your web app.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Got to **Deployment** | **Deployment Center**
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **FTPS credentials** tab. See *Figure 13**.11*:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.11:\uFEFF FTPS credentials tab for an Azure web app](img/B09148_13_011.jpg)"
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: FTPS credentials tab for an Azure web app'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use these credentials to connect to the server. Here is what it
    looks like after connecting and navigating to the `wwwroot` folder:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.12:\uFEFF FTP view of the deployed repository](img/B09148_13_012.jpg)"
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: FTP view of the deployed repository'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to test whether things are working or not. As you might guess,
    after investigating the Account microservice’s source code, we added a simple
    middleware to `app.js`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just go to the Azure portal, select your web app, and in the **Overview** section,
    you will find the default domain:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.13:\uFEFF Domains section for an Azure web app](img/B09148_13_013.jpg)"
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Domains section for an Azure web app'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any browser and type `<Default_domain>/welcome` as the URL:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.14:\uFEFF Welcome page for the deployed Node.js application](img/B09148_13_014.jpg)"
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Welcome page for the deployed Node.js application'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether it is possible to connect to MongoDB and create account information,
    follow these steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** button to create a new tab.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<default_domain>/v1/accounts` template (it is `https://account-microservice-webapp.azurewebsites.net/v1/accounts`
    for us).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Body** section and select **raw** | **Json**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste your payload to create an account and click **Send**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what it looks like for us:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.15:\uFEFF Creating an account using Postman](img/B09148_13_015.jpg)"
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Creating an account using Postman'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether it is possible to retrieve account information, follow these
    steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** button to create a new tab.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<default_domain>/v1/accounts` template (it is `https://account-microservice-webapp.azurewebsites.net/v1/accounts`
    for us).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Send**.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what it looks like for us:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.16:\uFEFF Retrieving account information](img/B09148_13_016.jpg)"
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Retrieving account information'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the process of deploying an application to Azure
    and testing its functionalities. We walked through how to verify that everything
    is working as expected using Postman, ensuring your application is ready for production
    environments. Now you have a solid understanding of how to deploy and validate
    your microservice in the cloud.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on a comprehensive exploration of CI/CD processes,
    emphasizing their critical role in modern software development. We began by understanding
    the fundamentals of CI and CD and how they streamline the process of integrating
    and deploying code changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Our journey continued with an in-depth look at working with Azure Cloud, where
    we discussed how to leverage its robust infrastructure for deploying and managing
    applications. We then delved into GitHub Actions, a powerful tool for automating
    workflows, enabling us to build, test, and deploy our code efficiently.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Most of the chapter was dedicated to building a CI/CD pipeline. We walked through
    the steps necessary to create a seamless and automated pipeline, ensuring that
    our applications are always in a state ready for deployment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have covered everything you need to start building microservices
    with JavaScript. From designing the basic structure to deploying and monitoring
    your services, each chapter has given you practical steps and knowledge to help
    you create flexible and efficient applications. Now, you’re ready to take on real
    projects using microservices, which can make your systems easier to scale, update,
    and manage.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that microservices are not a silver bullet. The best design
    depends on many factors, including the size of your project, team structure, and
    business needs. As you continue learning and practicing, stay curious and keep
    in mind that technology is always changing. Enjoy your journey in the world of
    microservices!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住微服务并非万能良药。最佳设计取决于许多因素，包括您项目的规模、团队结构和业务需求。随着您继续学习和实践，保持好奇心，并牢记技术总是在变化。享受您在微服务世界中的旅程吧！
- en: Keep going and may you code for a lifetime. Until we meet again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前行，愿您终身编码。直到我们再次相遇。
