- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CI/CD Pipeline for Your Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) and **continuous delivery/deployment**
    (**CD**) are fundamental practices in modern software development, forming the
    backbone of efficient DevOps workflows. Together, they automate and streamline
    the processes of integrating code changes, testing, and deploying applications,
    ensuring that software is always in a deployable state.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the modern software development requirements for developers is to at
    least understand and have essential skills for building pipelines and working
    with different automation systems.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about understanding and applying CI/CD to your microservices.
    Developing these fundamental DevOps skills will help you stay aligned with modern
    development practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of CI/CD processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Azure Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with GitHub actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need any previous experience of CI/CD to cover and understand the
    current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of CI/CD processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI and CD are essential practices in Node.js microservice development to streamline
    both the development and release processes. CI automates the integration of code
    changes into the main branch, ensuring each update is tested and validated through
    automated testing. This reduces the risk of integration issues and helps maintain
    code quality.
  prefs: []
  type: TYPE_NORMAL
- en: In the CD pipeline, every successful build from CI is automatically deployed
    to production or staging environments. This automation significantly reduces the
    time between development and release, allowing teams to quickly iterate on features
    and address issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is the practice of frequently integrating code changes into a shared repository.
    This process is typically automated, with code being merged and tested multiple
    times a day. The main goals of CI are to detect integration issues early, reduce
    the chances of bugs reaching production, and ensure that new code is always compatible
    with the existing code base.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we commit our code changes frequently (often several times a
    day) to a shared repository. This reduces the chances of conflicts and integration
    issues. When we have automated systems such as CI, after every commit, an automated
    build process is triggered. The code is compiled, and necessary dependencies are
    resolved. This ensures that the code base remains in a buildable state at all
    times. A successful build is an indication that the code base is in a healthy
    state and can proceed to the next steps, such as testing.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests are executed after the build process. These tests can include
    unit tests, integration tests, and sometimes even end-to-end tests. The goal is
    to catch any bugs or issues early in the development cycle. If the build or tests
    fail, developers receive immediate feedback. This allows them to address issues
    quickly before they become bigger problems.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a new code change is committed, an automated build process is triggered.
    This process compiles the code, resolves dependencies, and packages the application
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: CI encourages the use of a single shared repository, which acts as the *single
    source of truth* for the project. This repository contains the most up-to-date
    and stable version of the code base, ensuring that all team members are working
    from the same foundation. This practice especially helps in maintaining consistency
    across the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to cover the benefits of CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early bug detection**: By integrating code changes frequently and running
    automated tests with each integration, CI allows teams to detect bugs and issues
    early in the development process. This early detection reduces the cost and complexity
    of fixing bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced integration conflicts**: Frequent integration of code changes means
    that conflicts are detected and resolved quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster development cycles**: Automated builds and tests free up developer
    time by eliminating the need for manual testing and build processes. This leads
    to faster development cycles and quicker delivery of new features and bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved code quality**: Automated testing as part of CI ensures that only
    code that passes a predefined set of tests is integrated into the mainline. This
    improves the overall quality and stability of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced collaboration**: CI encourages collaboration among team members
    by making it easier to integrate and share code. This fosters a culture of transparency
    and collective ownership of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous feedback**: Continuous feedback loops provide developers with
    immediate information about the impact of their changes. This helps in maintaining
    high code quality and reduces the time spent on debugging and troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A CI workflow helps the team to catch bugs early, reduce integration challenges,
    and improve collaboration among team members. By automating the process of testing
    and building, CI ensures that the code base remains stable and ready for further
    development or deployment, promoting a faster and more reliable release cycle.
    Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer makes changes**: Step one is about making changes. A developer
    writes new code or modifies existing code on their local machine. Once the changes
    are complete, they commit the changes to the **version control system** (**VCS**),
    such as Git.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code is pushed to the repository**: The developer pushes the committed changes
    to the shared repository. This triggers the CI process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CI server detects changes**: A CI server (e.g., Jenkins, Travis CI, CircleCI,
    or GitHub Actions) monitors the repository for new changes. When a change is detected,
    the CI server automatically triggers a build process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build is automated**: The CI server pulls the latest code and initiates the
    build process. This involves compiling the code, resolving dependencies, and creating
    build artifacts if necessary. Tools such as Maven, Gradle, and Ant are used to
    automate the build process, manage dependencies, and compile the code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing is automated**: After a successful build, the CI server runs automated
    tests. These tests can include unit tests, integration tests, and other types
    of tests specific to the project. If the tests pass, the CI process continues.
    If any test fails, the process is halted, and the developer is notified of the
    failure. JUnit, NUnit, Mocha, Jest, and Selenium are examples of testing frameworks
    used to write and execute automated tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feedback is given to developers**: The CI server provides feedback to the
    developer, typically through notifications or a web interface. If the build or
    tests fail, the feedback includes details about the failure, helping the developer
    to quickly identify and fix the issue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Changes are merged to mainline**: Once the build and tests pass, the changes
    are merged into the mainline or master branch of the repository. This branch always
    represents the latest stable version of the code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Builds are deployed**: In some cases, successful builds might be automatically
    deployed to a staging environment for further testing. This can be part of a CD
    pipeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI workflow is designed to automate the integration of code changes, ensuring
    that new updates are quickly tested and validated before being merged into the
    mainline. By following this structured process, teams can catch issues early,
    reduce integration headaches, and deliver high-quality code more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Several tools and platforms play an important role in implementing CI in software
    development projects. These tools ensure that code integration, building, and
    testing processes are automated and efficient. VCSs such as Git and Subversion,
    manage and track changes in the code base, while CI servers such as Jenkins and
    GitHub Actions automate the build and test process. Build tools such as Maven
    and Gradle handle dependencies and compilation, and testing frameworks such as
    Mocha and Jest enable automated testing, ensuring code quality at every stage
    of development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD is a software engineering practice that enables teams to develop and release
    software in shorter, more frequent cycles, ensuring it can be deployed at any
    moment with confidence. As an evolution of CI, CD emphasizes not just building
    and testing code but also automating the deployment process to production environments,
    allowing for faster and more reliable releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the core principles of CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated testing**: Every change goes through an automated testing process
    to ensure that it is production-ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated deployment**: The deployment process is automated, reducing the
    risks and errors associated with manual deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental updates**: Software is released in small, manageable chunks rather
    than large, monolithic updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment parity**: The testing, staging, and production environments are
    kept as similar as possible to avoid unexpected issues during deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous feedback**: Constant monitoring and feedback from the production
    environment allow for quick detection and resolution of issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is great, but how do we apply it to our Node.js microservices? Applying
    CD to a Node.js microservice architecture involves several steps.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating CI/CD into microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integrating CI/CD into microservices ensures seamless, automated deployment
    and testing of independent services, enabling faster development cycles and consistent,
    reliable updates. This approach enhances scalability and agility by streamlining
    the release process across distributed microservice architectures. Here is how
    we can integrate it in terms of Node.js microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to set up CI. You can use a CI tool such as **GitHub Actions**,
    **Jenkins**, or another tool to automate the process of building, testing, and
    packaging your Node.js microservices. Make sure that your CI pipeline runs unit
    tests, integration tests, and static code analysis on every commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Docker to containerize each Node.js microservice. This ensures that the
    service runs consistently across different environments. Define a Docker file
    for each microservice to specify the dependencies, environment variables, and
    startup commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is writing automated tests for each microservice, covering unit
    tests, integration tests, and end-to-end tests. Use a test framework such as **Mocha**,
    **Jest**, or **Supertest** to write and run your tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, ensure your CI pipeline runs these tests on every code change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second huge step is to set up a CD pipeline. Extend your CI pipeline to
    deploy your microservices to a staging environment automatically. This can be
    done using the previously mentioned tools such as GitHub Actions, Jenkins, or
    other tools. Use a deployment tool such as **Kubernetes**, **Docker Swarm**, or
    **AWS ECS** (**Elastic Container Service**) to manage your containers in the staging
    and production environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate the deployment process by defining scripts that push the Docker images
    to a container registry (such as Docker Hub or AWS ECR) and update the services
    in the staging environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your local, testing, staging, and production environments are as
    similar as possible. This reduces the chances of environment-specific bugs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To manage different configurations for each environment, don’t forget to use
    environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement monitoring and logging for your microservices using tools such as
    Prometheus, Grafana, ELK Stack, or Datadog. Set up alerts to notify your team
    of any issues in the production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use deployment strategies such as canary releases or blue-green deployments
    to minimize the risk when deploying new versions of your microservices. This allows
    you to test new versions with a small percentage of users before rolling them
    out to the entire user base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the performance and logs of your services in production. Gather feedback
    from users and automatically roll back if a deployment causes issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuously iterate on your processes and tools to improve your CD pipeline.
    By following these steps, you can effectively implement CD in your Node.js microservice
    development process, allowing for faster, safer, and more reliable deployments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CI and CD are closely related concepts in modern software development, but they
    focus on different stages of the software development life cycle. Here’s how they
    differ.
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of CI is integrating code changes from multiple developers into
    a shared repository, multiple times a day. It also ensures that the code is always
    in a deployable state by catching integration issues early. Hence, a CI pipeline
    focuses on integrating and testing code. It includes stages such as code linting,
    unit tests, integration tests, and sometimes code coverage reports.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, CD builds on CI by automating the delivery of code changes
    to various environments, such as staging and production, after they pass the CI
    pipeline. The primary goal of CD is to then ensure that code is always ready to
    be released to production, and releases can happen frequently and reliably. A
    CD pipeline extends the CI pipeline to include steps for deploying the code to
    various environments. This can include deployment scripts, environment configuration,
    and automated rollback mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, CI is the foundation, and CD extends it to cover the deployment
    aspect, allowing for continuous delivery of new features and updates to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Azure Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **cloud** refers to a network of remote servers hosted on the internet,
    which are used to store, manage, and process data, rather than relying on a local
    server or personal computer. It allows businesses and individuals to access computing
    resources on-demand, such as storage, computing power, databases, and more, from
    anywhere in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Azure is Microsoft‘s cloud computing platform, providing a wide range of services
    such as virtual machines, databases, AI tools, and more. It enables developers
    and businesses to build, deploy, and manage applications through a global network
    of Microsoft-managed data centers. Azure offers flexibility, scalability, and
    cost-effectiveness, making it suitable for everything from small startups to large
    enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Using **Azure cloud** provides several advantages, including seamless integration
    with Microsoft‘s ecosystem, high availability, and robust security features. It
    also supports hybrid cloud environments, allowing businesses to connect their
    on-premises infrastructure with the cloud. Azure’s global presence ensures low
    latency and compliance with regional regulations. Additionally, it offers advanced
    analytics, AI, and machine learning services, empowering businesses to innovate
    and stay competitive in the digital age.
  prefs: []
  type: TYPE_NORMAL
- en: To make our example as simple as possible, we will work on the `Account` microservice
    from [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074). We will begin by obtaining
    all the resources necessary for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Account` service stores data in the Postgres database. We will deploy our
    application to Azure, but you can use any cloud infrastructure you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an **Azure Resource Group** to deploy our application.
    We can do that with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a Postgres resource to store data on Azure. Go to [http://portal.azure.com](http://portal.azure.com)
    and register to get a free account if you haven’t registered yet. Using a free
    subscription, you can get $200 of free credit toward Azure products and services,
    plus twelve months of popular free services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to set up Azure resources using the Azure portal and create
    a resource group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the Azure portal.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left sidebar, select **Resource Groups**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the necessary details, such as the subscription, resource group name,
    and region, then click **Review + create** (*Figure 13**.1*):'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1: Creating a resource group in Azure](img/B09148_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Creating a resource group in Azure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create an App Service plan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `App Service plans` in the search bar and select
    the top result.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your subscription, select the resource group you just created, and enter
    a name for your App Service plan.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Operating System**, select **Linux**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a pricing tier (e.g., **B1** for a basic plan).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Review +** **create**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an App Service plan in Azure is an essential step when deploying web
    apps, APIs, and other workloads using Azure App Services. The App Service plan
    defines the underlying infrastructure that powers your web app, API, or function
    app. It determines how your application is hosted, including the amount of CPU
    (processing power), memory (RAM), storage (disk space), and networking capacity
    it uses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By creating an App Service plan, you specify the resources and capacity needed
    to run your application, ensuring it has the necessary performance to handle the
    expected load. It directly influences the cost of running your application in
    Azure by giving the following two options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pricing tier**: The plan you choose determines the pricing tier, which affects
    the cost based on the resources allocated. Azure offers various pricing tiers,
    from free and shared tiers for small apps to premium tiers for high-performance,
    production-grade apps.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling options**: An App Service plan also defines the scaling options for
    your application. You can scale up (increase the size of the instance) or scale
    out (increase the number of instances) based on your application’s needs. Different
    pricing tiers offer different scaling capabilities.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 13**.2* shows how to create an App Service plan in Azure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.2: Creating an App Service Plan in Azure](img/B09148_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Creating an App Service Plan in Azure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is creating a web app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `App Services` and select the top result.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** and select **Web App**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your subscription, select your resource group, and enter a name for your
    web app. Make sure you have selected a unique name for your web app.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Publish**, select **Code**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Runtime stack**, select **Node 20 LTS**. (Select the node version
    you think is better for your needs).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Operating System**, choose **Linux**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Region**, select the region closest to you or your users.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **App Service Plan**, select the plan you created earlier.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Review + create** and then **Create**. See *Figure 13**.3*:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3: Creating a web app in Azure](img/B09148_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Creating a web app in Azure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create an Azure Cosmos DB for the MongoDB API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, search for `Azure Cosmos DB` and select **Create**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure will ask you to select the type of resource, which will either be a requesting
    **unit database account** or **vCore cluster**. vCore Cluster is a recommended
    resource by Microsoft.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **API**, choose **Azure Cosmos DB** **for MongoDB**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your **Subscription**, **Resource Group**, **Account Name**, and other
    necessary details.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Review + create** and then **Create**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4: Selecting Azure Cosmos DB for MongoDB](img/B09148_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Selecting Azure Cosmos DB for MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the Azure Cosmos DB account creation page in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The Azure Cosmos DB account creation page](img/B09148_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The Azure Cosmos DB account creation page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us obtain a MongoDB connection string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Cosmos DB account is created, go to the **Overview** page.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Connection String** under the **Settings** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the eye icon.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy **Primary** **Connection String**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.6:\uFEFF Connection string page in Azure](img/B09148_13_006.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Connection string page in Azure'
  prefs: []
  type: TYPE_NORMAL
- en: We’re done with resource obtaining. It is time for configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s configure the Azure web app to use MongoDB. For that, navigate to
    your web app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal, go to `MONGODB_URL`) and **Value** (paste the MongoDB connection
    string you copied earlier).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** and then **Save**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, it’s time to prepare your Node.js application. Ensure your Node.js
    application is set up to read the MongoDB connection string from environment variables.
    Here are the steps to achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `src/config/config.js` file and change the `createConfig` function
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run our Node.js application, it automatically connects to a port number
    equal to `3001` (depending on what you encoded in the `.env` file). We updated
    the `.env` file by default to use `PORT=443`. Here is what it looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also applied minor changes to the `src/index.js` file to support the `winston`
    library and to use the port from the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you might guess, for both previous examples, we used `process.env`. Using
    `process.env.PORT` and `process.env.MONGODB_URL` in Node.js applications is a
    best practice for managing environment-specific configurations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Node.js applications often need to run in different environments (development,
    testing, staging, production), each with its own set of configurations. Using
    environment variables allows you to customize behavior based on the environment
    without changing the code. Now, let’s take a closer look at the environment variables
    used in our code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`process.env.PORT` is used to define the port number on which the Node.js application
    will listen for incoming requests. By using an environment variable for the port,
    you can easily run the application on different ports depending on the environment.
    For example, in a development environment, you might want to run it on port `3000`,
    while in production, the application might need to run on a port assigned by a
    hosting provider (e.g., Azure, Heroku). Cloud providers often assign dynamic ports
    to applications. By using `process.env.PORT`, your application can adapt to whatever
    port is assigned at runtime.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.env.MONGODB_URL`, on the other hand, is used to define the connection
    string for your MongoDB database. Storing sensitive information such as database
    connection strings in environment variables keeps them out of your source code,
    which is a security best practice. This prevents accidental exposure in VCSs (e.g.,
    Git). Different environments may use different databases or database servers.
    For example, a development environment might use a local MongoDB instance, while
    production uses a managed MongoDB service such as MongoDB Atlas. By using `process.env.MONGODB_URL`,
    you can easily switch between these without changing your code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After successful deployment, Azure should run your application. That is why
    you need to update the `package.json` file to have the `start` script, like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But how about the package installation process? As you know, we don’t publish
    `node_modules`, but it should be on the server to run your application properly.
    To handle node module installation and execute the start command from `package.json`,
    you can follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **App Services** from the Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **General Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `npm install &&` `npm start`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.7:\uFEFF Startup command for an Azure web app](img/B09148_13_007.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Startup command for an Azure web app'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not the only option for running Node.js applications properly
    but for this example, it is more than enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now, everything is ready. We can implement our pipeline using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub Actions** is a powerful feature of GitHub that allows you to automate,
    customize, and execute software development workflows directly in your GitHub
    repository. It’s designed to help you build, test, and deploy your code right
    from GitHub. GitHub Actions is a tool that helps you automate tasks within your
    software development life cycle. For our case, we’ll create a workflow that automatically
    deploys your Node.js microservice to Azure whenever you push changes to the main
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an account if you haven’t yet. After account creation, create
    a repository that will store your source code. Next, let’s look at some key features
    of GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation of workflows**: GitHub Actions enables you to automate tasks such
    as running tests, building applications, deploying to cloud services, and more
    whenever specific events occur in your repository (e.g., a push to a branch, a
    pull request, or the creation of an issue). You can also use GitHub Actions to
    run linting tools or static analysis on your code, ensuring that code quality
    standards are maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.github/workflows/` directory of your repository. These files describe the
    automated processes you want to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven**: Actions can be triggered by various GitHub events, such as
    pushes, pull requests, issue creation, or on a scheduled basis. This flexibility
    allows you to create workflows that are finely tuned to your development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in CI/CD**: GitHub Actions provides built-in support for CI and CD.
    You can use it to automatically test your code and deploy it to production or
    a cloud service such as AWS, Azure, or Heroku after every commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable actions**: You can reuse actions created by the community or share
    your own actions across projects. GitHub has a marketplace where you can find
    actions for various tasks such as setting up languages, deploying to cloud services,
    and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets management**: You can securely manage and use sensitive information
    such as API keys, tokens, and other credentials in your workflows without exposing
    them in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling tasks**: You can use GitHub Actions to run scripts or maintenance
    tasks, such as nightly builds or database backups, on a schedule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions integrates seamlessly with other GitHub features, such as *Issues*,
    *Pull Requests*, and *Packages*, making it easy to create workflows that encompass
    the full development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at Secrets in GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Secrets** in GitHub Actions are encrypted environment variables that you
    use in your workflows. They are stored securely and can be accessed within your
    workflows without exposing sensitive information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To securely pass your Azure credentials (such as the publish profile) to GitHub
    Actions, you need to add them as **Secrets**. Here is how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal and navigate to your web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the web app’s **Overview** page, look for the **Get Publish Profile** button
    and download the publish profile file. It’s an XML file that contains the credentials
    your GitHub Actions workflow will use to deploy the app. Don’t forget to change
    **Platform settings** from your Azure web app’s **Settings-Configuration** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you do it, you will be able to download the publish profile (*Figure 13**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the `<web_app_name>.PublishSettings` (it is `account-microservice-webapp.PublishSettings`
    in our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing an Azure publish profile to GitHub Actions is essential for automating
    the deployment of your application to Azure. The publish profile contains credentials
    that GitHub Actions uses to authenticate and authorize the deployment to your
    Azure resources. This ensures that only authorized processes can deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: It also includes all the necessary settings for deploying your application to
    a specific Azure App Service or other resources. It simplifies the configuration,
    avoiding manually defining all the deployment details in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a publish profile in GitHub Actions allows you to securely store and
    manage the credentials as secrets within your GitHub repository. This prevents
    exposing sensitive information in your workflow files. Here is what platform settings
    should look like to download the publish profile:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.8:\uFEFF Platform settings to download the publish profile](img/B09148_13_008.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Platform settings to download the publish profile'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create Secrets in GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Settings** | **Secrets** | **Actions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following secrets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AZURE_WEBAPP_PUBLISH_PROFILE`: The entire contents of the publish profile
    from Azure (*Figure 13.9*).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONGODB_URL`: At this point, you should paste the MongoDB connection string
    that you copied earlier. If you have not yet retrieved it, please do so now before
    continuing. Here is how we can do it:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure 13.9:\uFEFF Adding the Azure web app’s publish profile](img/B09148_13_009.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Adding the Azure web app’s publish profile'
  prefs: []
  type: TYPE_NORMAL
- en: Using Secrets is crucial because it prevents sensitive data from being exposed
    in your repository’s code or logs. Only authorized workflows can access these
    secrets.
  prefs: []
  type: TYPE_NORMAL
- en: We have now provided all the secret information to GitHub, so let’s focus on
    building a simple pipeline using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While GitHub Actions doesn’t explicitly use the term **pipeline** in its documentation,
    a pipeline is a broader concept that represents the sequence of processes that
    code goes through from development to production. In many CI/CD tools, a pipeline
    typically consists of multiple stages (such as build, test, and deploy) that are
    executed in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: A `.github/workflows/` directory of a repository. Workflows are triggered by
    events, such as pushes to the repository, pull requests, or scheduled events.
    Each workflow can have multiple jobs that run in parallel or sequentially, and
    each job can have multiple steps that execute commands or actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workflow is defined in a `.yml` file. Here is how we define it:'
  prefs: []
  type: TYPE_NORMAL
- en: To create this file, you should open your web browser and go to your GitHub
    repository. Inside your repository, click on the **Add file** button, then choose
    **Create** **new file**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `.github/workflows/azure-deploy.yml`. This will create the necessary
    directory structure and file. Commit the `azure-deploy.yml` file and push it to
    your GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `azure-deploy.yml` file consists of multiple steps. For a more complete
    example, check our GitHub repository (`Ch13/.github/workflows/azure-deploy.yml`).
    Here is our first step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The GitHub Actions workflow file, named `CI/CD Pipeline`, is set up to automatically
    trigger whenever there is a push to the `main` branch of the repository. This
    means that any changes committed and pushed to the `main` branch will activate
    the defined workflow. The `on: push:` section specifies the event that starts
    the workflow – in this case, a push event to the `main` branch. This setup is
    commonly used for CI/CD, ensuring that updates to the `main` branch automatically
    go through the build, test, and deployment processes defined in the workflow.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s continue by discussing the next lines in our workflow file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This part of the GitHub Actions workflow defines a job named `security-scan`,
    which is responsible for running a security scan on your code base. The job will
    execute on the latest version of Ubuntu, as specified by `runs-on: ubuntu-latest`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within this job, several steps are outlined. The first step, `Checkout code`,
    uses the `actions/checkout@v3` action to clone the repository’s code into the
    workflow’s environment. Next, the `Set up Node.js` step sets up Node.js version
    20 in the environment using the `actions/setup-node@v3` action. After the environment
    is ready, the `Install dependencies` step runs `npm install` to install all required
    Node.js packages. Finally, the `Run npm audit` step executes the `npm audit --audit-level=high`
    command, which checks for security vulnerabilities in the installed packages,
    focusing on those with a high severity level. This job ensures that your application
    is scanned for critical security issues as part of the CI/CD pipeline.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code of the GitHub Actions workflow defines a job called `check-dependencies`,
    which is designed to check whether any dependencies in your project are outdated.
    The job will run on the latest version of Ubuntu, as indicated by `runs-on: ubuntu-latest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `needs: security-scan` line specifies that this job will only run after
    the `security-scan` job has successfully completed. This creates a dependency
    between the two jobs, ensuring that the security scan must pass before checking
    for outdated dependencies.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The job contains several steps. First, the `Checkout code` step uses the `actions/checkout@v3`
    action to clone the repository’s code into the environment. Then, the `Install
    dependencies` step runs `npm install` to install all the necessary Node.js packages
    for the project. Finally, the `Check for outdated dependencies` step runs `npm
    outdated`, which lists any dependencies that have newer versions available. This
    job helps maintain the health of your project by ensuring that you are aware of
    any outdated packages that might need updating.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following part of the GitHub Actions workflow defines a job named `test`,
    which is responsible for running tests on your code base. The job runs on the
    latest version of Ubuntu, as specified by `runs-on: ubuntu-latest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `needs: check-dependencies` line indicates that this job will only start
    after the `check-dependencies` job has successfully completed. This ensures that
    all dependencies are up-to-date before tests are run, which is important for ensuring
    consistency and reliability in your testing process.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The job consists of several steps. First, the `Checkout code` step uses the
    `actions/checkout@v3` action to clone the repository’s code into the workflow
    environment. Then, the `Set up Node.js` step configures Node.js version 20 in
    the environment using the `actions/setup-node@v3` action. Following this, the
    `Install dependencies` step runs `npm install` to install the necessary packages
    for the project. Finally, the `Run tests` step executes the `npm test` command,
    which runs the test suite defined in your project. This job ensures that your
    code is tested in a controlled environment, catching any issues before changes
    are merged or deployed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following part of the workflow is responsible for deploying your application
    to the Azure web app after the tests have been completed. The job runs on an Ubuntu-based
    virtual machine provided by GitHub Actions. Before deployment, the workflow checks
    out the latest version of your code to ensure that the most recent changes are
    included:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In preparation for deployment, the workflow cleans up unnecessary files and
    directories, such as the `.git` folder (which contains the repository’s Git history),
    the `.github` folder (used for GitHub-specific configurations), and other temporary
    or internal folders that aren’t needed in the deployed application. This cleanup
    helps reduce the deployment package size and eliminates any files that aren’t
    required for the application to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the workflow uses the `azure/webapps-deploy@v3` action to deploy the
    application to the specified Azure web app. The `app-name` configuration is set
    to match the site name in your Azure publish profile, and the `publish-profile`
    secret contains the necessary credentials. The package to be deployed is set to
    the entire workspace, ensuring that the cleaned-up code is what gets deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you push your changes, GitHub Actions will automatically trigger the workflow.
    Monitor the deployment process in the **Actions** tab of your GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.10:\uFEFF GitHub Actions workflow](img/B09148_13_010.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: GitHub Actions workflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what success deployment logs look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once deployment succeeds, you can check the deployed files using a simple FTPS
    connection. To connect to your server using an FTP client, you can use any FTP
    client tools you want. We use FileZilla, which is free and easy to use. You can
    download it from [https://filezilla-project.org/](https://filezilla-project.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To find FTP credentials for your server, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **App Services**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find your web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Got to **Deployment** | **Deployment Center**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **FTPS credentials** tab. See *Figure 13**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.11:\uFEFF FTPS credentials tab for an Azure web app](img/B09148_13_011.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: FTPS credentials tab for an Azure web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use these credentials to connect to the server. Here is what it
    looks like after connecting and navigating to the `wwwroot` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.12:\uFEFF FTP view of the deployed repository](img/B09148_13_012.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: FTP view of the deployed repository'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to test whether things are working or not. As you might guess,
    after investigating the Account microservice’s source code, we added a simple
    middleware to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just go to the Azure portal, select your web app, and in the **Overview** section,
    you will find the default domain:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.13:\uFEFF Domains section for an Azure web app](img/B09148_13_013.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Domains section for an Azure web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any browser and type `<Default_domain>/welcome` as the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.14:\uFEFF Welcome page for the deployed Node.js application](img/B09148_13_014.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Welcome page for the deployed Node.js application'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether it is possible to connect to MongoDB and create account information,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** button to create a new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<default_domain>/v1/accounts` template (it is `https://account-microservice-webapp.azurewebsites.net/v1/accounts`
    for us).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Body** section and select **raw** | **Json**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste your payload to create an account and click **Send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what it looks like for us:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.15:\uFEFF Creating an account using Postman](img/B09148_13_015.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Creating an account using Postman'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether it is possible to retrieve account information, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** button to create a new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `<default_domain>/v1/accounts` template (it is `https://account-microservice-webapp.azurewebsites.net/v1/accounts`
    for us).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Send**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what it looks like for us:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.16:\uFEFF Retrieving account information](img/B09148_13_016.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Retrieving account information'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the process of deploying an application to Azure
    and testing its functionalities. We walked through how to verify that everything
    is working as expected using Postman, ensuring your application is ready for production
    environments. Now you have a solid understanding of how to deploy and validate
    your microservice in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on a comprehensive exploration of CI/CD processes,
    emphasizing their critical role in modern software development. We began by understanding
    the fundamentals of CI and CD and how they streamline the process of integrating
    and deploying code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey continued with an in-depth look at working with Azure Cloud, where
    we discussed how to leverage its robust infrastructure for deploying and managing
    applications. We then delved into GitHub Actions, a powerful tool for automating
    workflows, enabling us to build, test, and deploy our code efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the chapter was dedicated to building a CI/CD pipeline. We walked through
    the steps necessary to create a seamless and automated pipeline, ensuring that
    our applications are always in a state ready for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have covered everything you need to start building microservices
    with JavaScript. From designing the basic structure to deploying and monitoring
    your services, each chapter has given you practical steps and knowledge to help
    you create flexible and efficient applications. Now, you’re ready to take on real
    projects using microservices, which can make your systems easier to scale, update,
    and manage.
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that microservices are not a silver bullet. The best design
    depends on many factors, including the size of your project, team structure, and
    business needs. As you continue learning and practicing, stay curious and keep
    in mind that technology is always changing. Enjoy your journey in the world of
    microservices!
  prefs: []
  type: TYPE_NORMAL
- en: Keep going and may you code for a lifetime. Until we meet again.
  prefs: []
  type: TYPE_NORMAL
