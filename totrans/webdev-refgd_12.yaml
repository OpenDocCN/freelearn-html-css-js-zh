- en: Chapter 12. Server-side JavaScript – NodeJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is a relatively new server platform that is built on JavaScript. One
    of the main features of Node is that it is a non-blocking server. This means that
    resource-intensive tasks will not tie up the server. Node.js can then handle many
    concurrent connections. It can also handle real-time communications more easily
    than a blocking server.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main uses of Node.js is as a web server. This is a perfect task as
    serving web pages usually involves reading files and connecting to a database.
    It is able to serve more clients while either of these two actions are executing.
    This is very different compared to a blocking server. A blocking server would
    have to wait for all the resources to return before it could respond to more requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this reference will only be Node.js specific; we will not cover any
    frameworks or libraries in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular frameworks are useful and should be utilized whenever possible,
    but our focus will only be on functions and modules that are included with Node.js.
    There will be no coverage of **Express** (arguably, the most used Node.js framework).
    Most importantly, we will cover the building blocks of Node.js that Express and
    its dependencies are built on.
  prefs: []
  type: TYPE_NORMAL
- en: A great book that covers frameworks and more is *Building Scalable Apps with
    Redis and Node.js* by Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following groups of references will be described, accompanied
    with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File and process management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OS (operating system)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: REPL (Read Eval Print Loop)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Utilities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Crypto
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Console
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Npm (Node Package Manager)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Net modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: createServer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: net.Server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IncomingMessage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ServerResponse
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: clientRequest
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File and process management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our overview of Node.js with the basics. This will include loading
    modules, managing processes, handling files and paths, and **REPL** (**Read Eval
    Print Loop**). These are things that virtually any Node.js project will need.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js is a modular system. Much of the functionality of Node.js is contained
    in modules that must be loaded at runtime. This makes the knowledge of loading
    and building modules a core requirement to using Node. Here are the references
    you can use for your Node modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modules.export`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: require()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This loads the module at the given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The return value will be an object. The properties of this object will vary,
    depending on what is loaded. We will cover `module.exports` next, which is what
    module designers and even you can use to set the value of this return value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `require()` function is used to load the module at a path, where the path
    can be a core module (a module packaged with Node.js), directory, file, or module
    (a project that you or someone else has built). As a result, it is very versatile.
    The `require()` function will try to resolve the passed-in path in this order:
    the core module, the directory or file if the path begins with "./", "/", "../",
    and then the module, take a look at the following description for more information.
    You then need to check the require function in different locations for all of
    this to work:'
  prefs: []
  type: TYPE_NORMAL
- en: You will first look for a core module. The core modules can be viewed in the
    source of Node.js under the lib directory. We will cover the most prolifically
    used modules in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, require would load the path as a file if the string begins with "./" ,"/",
    or "../". These are current directory, root directory, and parent directory, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the filename is not found, require will then try appending `.js`, `.json`,
    or `.node`. This means that the `require (./data/models)` function and `require
    (./data/models,js)` will load the same file. If require does not find a file,
    then it will try to load the path as a directory. This means it will look for
    either an `index.js` file or the main property inside `package.json`. Require
    will then either use `index.js` or `package.json` to load as a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the path does not start with "./", "/", or "../" and it is not a
    core module, require will search for a `node_modules` folder. The first directory
    will be the `current` directory. After that, each directory will be a parent directory,
    all the way up to the `root` directory. In addition to this, require will also
    search the paths in the `NODE_PATH` environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a quick summary, here is the order that require will use:'
  prefs: []
  type: TYPE_NORMAL
- en: Core module (no relative path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File module (relative path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folder module (relative path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `node_modules` module (no relative path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how the require function is used to load core modules,
    files, or modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the comment, this example will load the HTTP core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows you how to load a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This one will load a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this one will load a module.
  prefs: []
  type: TYPE_NORMAL
- en: Every Node.js project will use require many times, so knowing how and where
    it will load is important.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple example that demonstrates require and how it works with `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the file that will be loaded with require, `requireTest.js`, and it
    will be loaded from a relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to load this value in a Node.js script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: module.exports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `module.exports` property is a convenience property used in a module to
    expose the functionality of the module outside the scope of the current file.
  prefs: []
  type: TYPE_NORMAL
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `module.exports` property is the return value from the module. This can
    seem misleading though. We will not return `module.exports`. It is the object
    or properties set at `module.exports` that are available from this module.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `module.exports` property is the link from the current file into the scope
    of the calling file. Any variables defined in the current file will not be in
    the scope of file that calls it. To make the variables available, you must either
    set them as the value of `module.exports` or as properties of `module.exports`.
    This functionality is the mechanism that Node.js uses with require. Exports can
    be set to any type: string, integer, function, object, and many others. Functions
    allow us to either pass in values or create a `constructor()` function. Objects
    can be created and then used to overwrite the exports object or can be added to
    the exports object as properties. We have all of JavaScript''s function- and object-creation
    tricks at our disposal.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A quick note is that require will cache output. This means consecutive calls
    to the same module will return the same instance of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of the `constructor()` function being used are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows an object to be passed in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This allows the export function to be executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `foo` property will be used in the following two examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The OS module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are the most important functions and properties of the `os` module. The
    `os` module allows you to get information from the operating system. This is important
    as we may need to know the hostname or how many CPUs are currently available.
  prefs: []
  type: TYPE_NORMAL
- en: All the functions that we will look at now assume that `var os = require('os')`
    is already in the file.
  prefs: []
  type: TYPE_NORMAL
- en: hostname()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will return the hostname of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An example of how the `os.hostname()` function is used is shown here. In this
    case, it will return the hostname of the current computer used. It will not return
    the domain suffix of the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: cpus()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will return the number of CPUs of the current device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will get an array of objects that map to each CPU. The objects will have
    the model, speed, and times:'
  prefs: []
  type: TYPE_NORMAL
- en: Model and speed are the processor model and speed of the CPU, respectively.
    Note that, most of the time, model and speed will not be relevant to our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Times has the breakdown of how many milliseconds the CPU has spent in `user`,
    `nice`, `sys`, `idle`, and `irq`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information can be used, most of the time, to find out how many CPUs the
    machine has. It is good to know this information, as Node.js is single threaded
    and we can launch multiple processes in a cluster for each CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of getting the number of CPUs on a computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: networkInterfaces()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets a list of network interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will be an object that contains all the network interfaces. Each property
    maps to an interface and it will have an array of all the IP addresses (IPv4 and
    IPv6).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, this is how you can get the object that has all the interfaces
    for a computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The process module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Process is an object that allows us to get access to events on the process.
    We can also get access to `stdin`, `stdout`, and `stderr`. These are global objects
    that will be available in any file or context.
  prefs: []
  type: TYPE_NORMAL
- en: stdout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stdout` object is a writable stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the stream that will connect to `stdout`. Note that streams will be
    covered later in this chapter under Utilites. If we are running Node.js as a console
    application, this is where we could write to `stdout` if needed. Most streams
    in Node are non-blocking, but writes to stdout and stderr are blocking.
  prefs: []
  type: TYPE_NORMAL
- en: We also can use `stdout` to find out whether Node.js is running in TTY. We can
    access `process.stdout.isTTY`. This is a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: The example here will show us how to write a message to the `stdout` stream.
    By default, this will be sent to the `process.stdout.write` console. This will
    write to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: stderr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stderr` object is a writable stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is similar to `stdout`, with the key difference being it writes to `stderr`.
    This is very useful for console applications as we can write to the console what
    is happening.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, this writes to the `stderr` stream. By default this will write
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: stdin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a readable stream that maps to `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This maps to the standard stream, `stdin`, in the same way `stdout` and `stderr`
    map to the `stderr` streams. The difference is that the `stdin` object is readable,
    while the others are writable. Anything that is piped into this process can be
    read out using `process.stdin`. To read from a readable stream, we will have to
    listen for two possible events that let us know how we can retrieve data. The
    first is readable, and the other is data. We will cover this more in depth when
    we get to the stream section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, this example takes the data that is sent in through `stdin` and
    sends it to `stdout` using the readable event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: argv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is all the command-line arguments passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `argv` commands will be an array of all the arguments passed into this script.
    Arguments are split by spaces. This means that `debug=true` (which has no spaces)
    will be one argument, and `debug = true` (a space between each word) will be three.
    This is an important distinction to keep in mind if you want to pass values in
    arguments. Arguments `0` and `1` will always be the node and the path and filename
    of the current script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Signal events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Signal events allow you to listen for the standard POSIX signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All of the `POSIX` signals, except `SIGKILL` and `SIGSTOP`, can be listened
    for. In addition to these signals, you can also listen for some Windows signals.
    Here is the list of signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGUSR1`: This is a user-defined signal. In Node.js, it is usually used to
    start the debugger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM`: This is the signal to terminate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT`: This is the signal to interrupt. It is usually sent by pressing *Ctrl*
    + *C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGPIPE`: This lets a process know when it is trying to pipe to a nonexistent
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGHUP`: This is the signal that tells a process that the terminal it was
    running in has hung up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGBREAK`: This is non-POSIX and is used by Windows. It should be used in
    a manner similar to `SIGINT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGWINCH`: This is the signal to tell the process that the window has changed
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of listening for `SIGINT`, which recognizes that *Ctrl*
    + *C* was pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: process.env
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This object contains the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `process.env` object is a simple JavaScript object that contains all the
    environment variables. Each property will be a string.
  prefs: []
  type: TYPE_NORMAL
- en: A great place to put configuration settings is in the environment when building
    an extensible application. The `process.env` object can then be used to check
    whether the current environment is in production or even to just store the configuration
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of checking for environment and setting a value from the
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: kill
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will send a signal event to a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will send any of the signal events that are defined in the signal events
    section, which that we covered earlier. This is essentially running the `POSIX`
    kill command.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this kill command to send the current process a signal, using `process.pid`,
    or to send another process that we have a reference to the kill signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of killing the specific process ID `4634`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: pid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the current `pid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is the `pid` (process ID) of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of `process.kill` and `process.pid` used together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: cwd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example that set the `cwd` variable to the current working directory
    of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: File functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is not a true module, like the previous section on process. This
    section will focus on any of the functions or modules that allow us to read, write,
    or find files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: __filename
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of the current filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__filename` command returns the current filename. This can be different,
    depending on which file is being executed. A module that is being executed will
    return its filename instead of the main entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of logging the current filename to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: __dirname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a string of the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like `__filename`, this will return the currently executing file's directory.
    The `__dirname` command is used many times when a relative path needs to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the `__filename` and `__dirname` variables are available in any file being
    executed by Node.js. They are determined per file, so they are correct for each
    file that gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example assumes Express has been loaded as express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The file module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now look at a list of key functions in the file module. All of these
    functions just run the underlying `POSIX` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the commands we cover will have an asynchronous and synchronous version
    of each function. The synchronous function will be the same name, with Sync appended,
    for example, `open` and `openSync`. In a way, the asynchronous versions are more
    like Node.js, in that, they let the event loop process without holding up execution.
  prefs: []
  type: TYPE_NORMAL
- en: Each asynchronous function will need a callback function defined as the last
    parameter. This function will be in the form of `function(err, result)`. We will
    cover this when we get to handling errors. The quick takeaway is that the first
    parameter, `err`, will be `null` if no error occurred, or it will have the error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the current versions of Node.js, you need not use a callback function, but
    this will become an exception in v0.12.
  prefs: []
  type: TYPE_NORMAL
- en: The synchronous functions will not process anything in the event loop until
    the function returns. While this seems against the Node.js non-blocking paradigm,
    it makes sense in certain cases, for example, when a specific file must be opened
    before anything else can process. This means that the classic `try/catch` is needed
    to handle any exceptions or errors.
  prefs: []
  type: TYPE_NORMAL
- en: In almost every circumstance, the asynchronous version is the one that should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each example is under the assumption that the `fs` variable already exists.
    Here is the code that sets the `fs` variable to the `fs` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: stat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns `fs.Stats`, which is an object with information about the queried
    file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `stat` variable gets the the data that would be returned after running `stat()`
    on the operating system. The `stat` object is an instance of `fs.Stats`. This
    object gives us useful functions such as `isFile()` and `isDirectory()`. In addition
    to this, `fs.Stats` has many properties. We can see the modified time, access
    time, and file size.
  prefs: []
  type: TYPE_NORMAL
- en: There are more functions and properties, but these are the most likely used.
  prefs: []
  type: TYPE_NORMAL
- en: The `fs.lstat()` and `fs.fstat()` functions will both return an `fs.Stats` object
    when pointed to a file. The difference is that `lstat` will run against a link
    instead of following the link to the file or directory. The `fstat` runs against
    a file descriptor instead of a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that loads a file named `test.txt` in the same directory
    as the code file and logs the `fs.Stats` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: open
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a file descriptor of the path passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This will open a file in the path passed in. There are many flags that can
    be passed. They are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: Read only, errors when file does not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r+`: Read and write, errors when file does not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rs`: Read synchronous, here, "synchronous" only refers to the filesystem caching
    data and not synchronous such as `openSync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rs+`: Read and write synchronous'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wx`: Write, errors when file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w+`: Read and write, file is created or truncated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: Append, file is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ax`: Append, errors when file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`: Read and append, file is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ax+`: Read and append, errors when file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flags allow you to open, read, and write a file, whether it exists or not.
    This means that most of the time, a call to `fs.exists` is not required as one
    of the flags will give you the answer you need.
  prefs: []
  type: TYPE_NORMAL
- en: The mode parameter is the permissions that are used if a file is created. It
    defaults to `0666`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the callback returns a file descriptor. With this, data can be read
    or written using `fs.read` or `fs.write`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of opening the file `test.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: read
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This reads from a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `read()` function takes a lot of parameters to run. We need a file descriptor,
    which we get from open, a buffer, and the size of the file. In the example, we
    used `fs.stat` to get the file size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a full example of opening a file and reading from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: readFile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simplified version for reading a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `readFile()` function greatly simplifies the process of reading a file in
    Node.js. In the previous function, `fs.read`, we needed to set everything up before
    we tried to read the file. The `readFile()` function allows us to just pass a
    filename and get a buffer back of what is in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The `optional options` object takes a flag and an encoding property. The flag
    property is the same as the flag from `fs.open`, so any of them can be used. The
    encoding is used for the buffer that is returned in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how much easier it is to load a file with
    `readFile`. The example is also using the `optional options` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: close
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will close a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is important to close any files that we open in our scripts. If we get a
    file descriptor from `fs.open`, we will need to call `fs.close` on that file descriptor
    at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of closing a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This writes to a file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `write()` function takes a file descriptor and buffer to write to a file.
    Much like read, we have to pass in quite a few parameters to make this work.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are reading a file into a buffer and then writing
    that buffer back out to another file. The offset and length are both integers
    that we need to pass in. The position can be an integer, but it can also be `null`.
    `Null` will start writing at the current position in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like read, write can be complex. Here is a full example of reading from
    one file and writing to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: writeFile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simplified function to write to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Exactly like the difference between read and `readFile`, `writeFile` is a simplified
    version of write. We just pass in a filename and a string or buffer, and it will
    write the file.
  prefs: []
  type: TYPE_NORMAL
- en: The callback only returns an error when it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '`readFile` and `writeFile` seem like the best choices in most cases, and in
    fact, this is most likely true. The main thing that you give up using these functions
    is control. You can only read an entire file or write an entire file.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With read or write, you can read any portion and write any portion of a file.
    This is an important difference to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `writeFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: appendFile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function allows us to append a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`appendFile` exists because `writeFile` will only write an entire file. So,
    we need another function to add to a file. This is where giving up some control
    for ease comes in. If we were using a file descriptor and write, then we could
    choose to start writing at the end of the file. This is effectively appending
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `appendFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The path module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `path` module is separate from the file module. Path is concerned with fixing
    paths, whereas file is concerned with working with files and directories. Many
    times, these modules will be used together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions covered are the most used and most useful. You will most likely
    need to locate paths relative to your current project, and this is what the path
    module is for:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `path` module does not check for the existence of path modifications.
    It essentially only makes changes to the string value of a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the other modules, the example assumes that the path module has been
    loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: normalize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of the path with any oddities fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normalize will fix many problems associated with reading paths. A great example
    of this is the difference between Windows and Unix paths. Unix uses forward slashes,
    and Windows uses backslashes. Normalize will return the correct slashes based
    on the system it is executed on.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, normalize will also remove the current directory and parent
    directory shortcuts, (`.` and `..` respectively). It will also remove double slashes
    from a directory. It normalizes any paths passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using Unix slashes on a Windows system. This example
    will change all the slashes to backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of all the paths joined together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Join makes it easy to create a path from partial paths. This seems like something
    that can be done with concatenation, but it is easy to forget about path separators.
    Join will make sure that the path separators will all be in the correct spots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `join`. The example will take all the parameters and
    join them together with the correct slash for your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: resolve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns the string of the path based on the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This can be viewed as the cd command executed for each parameter. The paths
    passed in can be relative or full paths. A relative path will add to the returned
    path, and a full path will be used whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Relative paths, will return `/home/josh/test`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A full path will return `/home/brian/node`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: relative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns the difference between the `to` and `from` paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The path returned can be used with `cd` to change to the new directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will return `../../brian/node`, because you must go
    up two parent folders and over to `brian/node` to get from one to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: dirname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of the directory name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will return the directory that the current file is in. If the
    file was in the directory `/home/users/jjohanan/node`, then the example will return
    `/home/users/jjohanan/node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: basename
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of the final part of a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will either return the filename or directory depending on what path is
    passed in. The optional `ext` parameter will remove that portion from the return
    value if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples, one involving a file and the other a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will return `test`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return `josh`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: extname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a string of the extension of the path. If there is no extension,
    a blank string is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will return `.js`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This example will return a blank string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REPL stands for **Read Eval Print Loop**. What this means is that it is an interactive
    console. We can enter in a command (**Read**). The command will be executed (**Eval**).
    The output of the command will will be printed to the console (**Print**). Finally,
    we can do this as many times as we want (**Loop**). REPL is great to run a few
    lines of code to see what they will do.
  prefs: []
  type: TYPE_NORMAL
- en: node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This starts Node.js in the REPL mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main way REPL will be used is by calling it directly. This can be done by
    executing Node.js without a file to serve, by running just `node`. Once `node`
    has returned with a prompt, we can add commands and see what happens when we run
    them. This is perfect to test a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick example of logging in to the console; first run `node` to get
    a prompt and then run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Errors are a part of any development project. We must be able to handle errors
    in a graceful way. If we do not, then we are creating bad experiences for our
    users. Even worse, we could be opening up a vector for attack. A stack trace that
    gets sent to an end user can give out many details.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a special section that deals more with design patterns than with
    actual code reference. Node.js is an asynchronous event-driven platform. For the
    major part, most people have not worked on a platform like this and can make mistakes
    when handling errors. We feel that handling errors is very important.
  prefs: []
  type: TYPE_NORMAL
- en: The core of this information comes from Joyent, one the major forces behind
    `Node.js` today. You can find more information on Joyent at [https://www.joyent.com/developers/node/design/errors](https://www.joyent.com/developers/node/design/errors).
  prefs: []
  type: TYPE_NORMAL
- en: Types of errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Errors can be split into two types: **operational** and **programmer** errors.
    Operational errors are errors that occur during the operation of an application.
    A database server not being accessible is an example. These errors can be planned
    for and handled gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: Next is programmer errors, which are errors in the literal sense. For example,
    a piece of code is malformed or an unexpected condition has come up. These are
    very hard to plan for (if we had planned for them, then they wouldn't be errors!).
    These will almost always break the server, so we can come back through the logs
    to find what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Error design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know the two different types of errors, let''s look at the three
    ways of alerting an application that has an error. The three ways are throwing
    the error, asynchronous callback, and emitting an error event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pattern of throwing the error is built into JavaScript. This pattern
    is great for any synchronous code. If we are doing any synchronous operations
    and an error occurs, we should throw it. When handling a synchronous call, we
    should wrap the function call in a `try/catch` block. Here is an example with
    `JSON.parse`, which runs synchronously and throws an error when a non-JSON string
    is passed to it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next pattern is using an asynchronous callback. Many built-in Node functions
    do this already. The pattern is to use a callback that has the signature `function(error,
    result)`. The first parameter will either have an error or be null or undefined.
    We can implement this ourselves whenever we write an asynchronous function. If
    there is an error, return it in the callback as the first parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When handling errors like these, we must put an error check in every callback
    function. This is important, as not doing this can silently swallow errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A good example of this is asynchronous and synchronous `filesystem` module calls.
    For example, read takes a callback, and `readSync` should be wrapped in a `try/catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example callback and check for error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can emit an error event. This is used for asynchronous functions
    as well. Whether we implement a callback or event is a personal choice, but it
    should be clear which one is being used. It is also a best practice to just implement
    one. Many times, an event is used when there is a long running asynchronous process.
    Reading data from a network socket is an example. A socket does not always give
    the data in one simple pass, so events are set up. One of those events is an error
    event. To handle this, we just need to listen for that event. Here is an example
    of listening for the error event of a socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next group of modules, we will look at utilities. The functions chosen
    here are used across many different types of applications. We will cover everything
    from events and cryptology to buffers and npm.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are used in many built-in Node objects. This is because emitting and
    listening for events is the perfect way to let another function know when to start
    executing. This is especially true in the asynchronous world of Node.js. Anytime
    we use the `on` function of an object, it means that it has inherited from `EventEmitter`.
    All of the examples will assume that the events variable is already created as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: EventEmitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the parent class that can be inherited from to create a new `EventEmitter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Node.js has a fully featured event system that we can easily inherit from and
    implement. We do not need any extra frameworks or custom code. `EventEmitter`
    is the class to inherit from, and we will get every function in the rest of this
    section available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of setting up a custom the `EventEmitter` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'on'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function adds a listener for a specific event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `on` function has become the preferred naming convention to add listeners
    to events. As an example, jQuery uses the exact same function name for their event
    listeners. The `event` handler is a string name of the event that will be emitted.
    The `listenerFunction` parameter is what will be executed when the event is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: The `listenerFunction` parameter can be an anonymous function or a reference
    to a function. The preferred way of adding a listener is with a reference to a
    function. This will allow us to remove this specific listener at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example based on our new `MyEventEmitter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This works just like `on`, except it only executes once and then removes itself
    as a listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: removeListener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the function that is used to remove a listener from an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we are done listening for this event, we will want to remove our listener.
    This will help prevent memory leaks. If we added an anonymous function as the
    listener, then we cannot remove it as we do not have a reference to it. Using
    our previous example from `on`, we will remove the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: removeAllListeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function will remove every listener for all events or a specific event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is essentially the nuclear option to remove listeners. This is indiscriminate
    with listeners. The `removeAllListeners` parameter will even remove listeners
    we did not add. Use this as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example that removes all the listeners from this event is shown here. If
    the event was left blank, it would remove all listeners for all events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: setMaxListeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function sets the number of listeners before Node.js and warns about a
    possible memory leak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Node.js has a helpful warning when the number of listeners exceeds a threshold.
    The default value is `10`, so when you add the eleventh listener, Node.js will
    warn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule, this is true. If we keep adding listeners to an event, there
    is a great chance for a memory leak. However, there will be times when we will
    need more than `10` listeners on an event. This is where we use `setMaxListeners`.
    If we set the max listeners to zero, then we can add as many as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of setting the max listeners to `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: emit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how we fire off an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If we have extended an object to be an event emitter, then we will want to emit
    some events! This is the function to do that. It will execute all the event listeners
    that have attached themselves to this event based on `eventName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows a listener being added and then emitting an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Crypto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every modern application needs cryptography. A great example of Node.js using
    cryptography is with HTTPS. We will not explore the inner workings of HTTPS as
    there is a module (the https module) that does this for us. We will look at the
    cryptographic functions used to hash, store, and check passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way as the other modules, we will require the `crypto` module and
    have it available for use in our examples. Here is what we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: createHash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function will return a `crypto.Hash` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The algorithms that can be used will be different for each system as it relies
    on OpenSSL. We can find out the algorithms that crypto can use by calling `crypto.getHashes()`.
    This will return an array of strings that can then be passed into `createHash`
    as the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The return object from this function is a `crypto.Hash` object, which is covered
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that creates an MD5 hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The hash object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the object that is returned from `crypto.createHash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we get a reference to the Hash object that has been returned, you will
    see that it has two functions. The first is update, which allows us to add to
    the data that will be hashed. This can be called multiple times. This is important
    if we want to hash a stream input.
  prefs: []
  type: TYPE_NORMAL
- en: The next function is digest. This will return digest based on the algorithm
    the hash object was created with. The string encoding for this function can be
    hex, binary, or BASE64\.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a full example of reading data from a file and then calculating the
    MD5 hash of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use hashing for passwords. The next function we will cover is much more
    secure than a simple hash. A digest hash is great for checking if some data has
    changed, as the hashes will be different if even one bit is different. In addition
    to this, it can be used as a key or identifier. A great example is using it for
    a memory cache and using the hash as the key. If the data is the same, the key
    will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: pbkdf2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function will use HMAC-SHA1 multiple times to create a derived key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Return Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both `pbkdf2` and `pbkdf2Sync` will return a derived key as a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Pbkdf2** (**password-based key derivation function 2**) is designed for password
    storage. It is better than hashing because it is difficult. Hashing is designed
    to be a quick calculation. This is bad because modern CPUs can calculate thousands
    upon thousands of hashes a second. This makes cracking a hashed password easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Pbkdf2 fixes this using a work factor in iterations. The higher the iterations,
    the longer the calculation will take. Now, instead of calculating thousands a
    second, we can slow a CPU down to just a few a second. This is a significant decrease.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the parameters used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`password`: This is the string we want to create a derived key for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`salt`: This is a string that is combined with the password. Doing this ensures
    that the same password will not have the same hash if `salt` is different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterations`: This is the work factor that instructs the function how many
    times to repeat. This can be increased as CPUs become faster. Currently, at least
    10,000 should create a reasonably secure derived key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyLength`: This is the desired length of the returned derived key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of creating a derived key for the string `password` and
    `salt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: randomBytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns cryptographically strong pseudo-random data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Return type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A buffer is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Random data is needed for various functions. While no data can truly be random,
    there are varying levels of randomness. The `randomBytes` parameter is random
    enough to use for cryptographic functions. A perfect use of `randomBytes` is for
    a `salt` to be used in `pbkdf2`. The `salt` variable is combined with the password
    to create a different hash even if the passwords are the same.
  prefs: []
  type: TYPE_NORMAL
- en: This function can be executed asynchronously or synchronously. It depends on
    whether there is a callback, which it would then execute asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function to create a random `salt` for `pbkdf2`. If you compare this
    example to the previous one, you will see that this example outputs a unique string
    each time, while the previous one does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: pseudoRandomBytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns pseudo-random data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Return Type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A buffer is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This functions exactly like `randomBytes`, except it is not cryptographically
    strong. This means that we should not use it with any cryptographic functions
    such as `pbkdf2`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use it for anything else that requires randomness, a filename, or a cache
    key for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of executing this function asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js uses buffers internally for many things. We have seen this as we have
    had buffers returned for many functions. This is because anytime raw data or binary
    data needs to be stored, it will be stored in a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers have a few quirks about them that we must keep in mind. First, buffers
    store data, but to utilize the data held inside them, we must encode it. We will
    cover the encodings and how to do this in this section. Second, buffers cannot
    be resized. When they are created, we must give a length, and that will always
    be the length of that buffer. We can, of course, create a new buffer that is larger
    and then copy over the data. Finally, a buffer is a global. We do not need to
    have `var buffer = require('buffer')`. Also, it can be utilized in any file at
    any time.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The initialization function of a buffer is as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a buffer object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are three different ways to initialize a buffer. The first function uses
    an integer of the given size, the next one uses an array, and the final method
    can use just a string. The encoding is optional, as it defaults to UFT8.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates initializing using an array with the `hello` string
    in ASCII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the value at the specific index in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns the value at the index.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This works much like an array. Here is an example of getting the first index
    in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: toString
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns the buffer as a string based on the encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is most likely the function that you will use to get the data out of a
    buffer. The first parameter is encoding, which is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ASCII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF16LE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BASE64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the parameters are optional, so this means that they all have default values.
    Encoding is defaulted to UTF8, `start` is `0`, and `end` is the end of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of creating a buffer and retrieving the data out of it.
    It explicitly defines each of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: toJSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns the contents of the buffer as a JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns an array with the contents of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This will return contents of the buffer mapped to an array. This example is
    similar to the previous example, but with `toJSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: isBuffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a class method that will determine whether an object is a buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that this is a class method, so it can be executed without a new instance
    of buffer. Here is an example of using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code writes to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns an integer of the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function will write the string passed into the buffer. Much like the other
    buffer functions, there are many optional parameters that have defaults. The default
    offset is `0`, the length is `buffer.length – offset`, and the encoding is UTF8.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example writes to a buffer twice using the return value from the first
    write to append the second string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: byteLength
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function will get the length of a string in bytes based on the encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns an integer of the number of bytes needed.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffers cannot be resized after initializing, so we may need to know how big
    a string is beforehand. This is where `byteLength` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that determines the size of a string and then writes it
    to the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: readUInt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will get an unsigned integer at a certain spot in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns an unsigned integer of the size used, `8` for `readUInt8`.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Not all data stored in a buffer is exactly a byte. Sometimes, data will need
    to be read in 16-bit or 32-bit chunks. In addition to this, you can also specify
    whether the data is little endian or big endian, denoted by `LE` or `BE` in the
    function name, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The offset is which spot in the buffer to start at. The `noAssert` parameter
    will run validation if the offset size is in the buffer. By default, it is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of setting data and then reading the data out with `readUInt16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: writeUInt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This writes an unsigned integer to a buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the exact opposite of the `readUInt` function. Sometimes, we need to
    write data that is larger than one byte in length. These functions make it simple.
  prefs: []
  type: TYPE_NORMAL
- en: The `noAssert` parameter is optional, and it defaults to `false`. This will
    not run any validation on the value or offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of writing `UInt16` to the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that there are more read and write functions of this type for the buffer
    class. Instead of creating a very redundant section, I will list them. Remember
    that they work in the same fashion as the functions we have covered: `readInt8`,
    `readInt16LE`, `readInt16BE`, `readInt32LE`, `readInt32BE`, `readDoubleLE`, `readDoubleBE`,
    `readFloatLE`, and `readFloatBE`. There is a `write()` function that maps to each
    one of these as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is much like the console that is present in most modern browsers. The console
    essentially maps to `stdout` and `stderr`. This isn't a module, and each function
    is not very complex, so let's jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This writes to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is probably the most used console function. It is great for debugging,
    and the output can be combined with piping to write to a file for a history. The
    multiple parameters create a string-like function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using multiple parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: dir
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an alias for `util.inspect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many times, the output of `console.log` and `console.dir` will be similar. However,
    when trying to look at an object, `console.dir` should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: time and timeEnd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two functions are used together to mark the start and end of a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These two functions will always be used together. The `console.time` parameter
    will start a timer that can be stopped with `console.timeEnd` by passing the same
    label. When `timeEnd` is called, it will log the elapsed time between start and
    end in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses `setTimeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: trace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This logs to the console and includes a stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This works much like `console.log`. The first parameter can be treated like
    a formatted string, with the other parameters supplying the additional input.
    The main difference is that `console.trace` will include a stack trace when it
    logs to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: npm (Node Package Manager)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: npm is not a Node.js module like. We will look at some of npm's features and
    uses, as almost every Node.js project will use npm.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern platforms have a way of grouping together code that serves a function
    or purpose called packages. Node.js uses npm to track, update, pin, and install
    these packages.
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This initializes a node module by creating `package.json` in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An interactive console session will ask you quite a few questions and use the
    answers to build a `package.json` file for you. This is a great way to kick off
    a new module. This will not delete your current the `package.json` file or any
    of the current properties if the `package.json` file exists.
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the file that has all the information about your project.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is not a function or command, but it is the most important file in your
    project. It is what determines all the information about your project. Although
    technically, the only properties needed are name and version, there are many properties
    that can be set. If this file was created using npm in it, you will have quite
    a few already filled out. It would be tedious to list out all the possibilities.
    Here are just a few of the most useful: name, version, scripts, dependencies,
    devDependencies, authors, and license.'
  prefs: []
  type: TYPE_NORMAL
- en: The npm docs at [https://www.npmjs.org/doc/files/package.json.html](https://www.npmjs.org/doc/files/package.json.html)
    go through all the settings their uses.
  prefs: []
  type: TYPE_NORMAL
- en: install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the command to install a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the main way to install new packages and their dependencies. If `npm
    install` is called without any parameters, it will use `package.json` and install
    all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This command also allows you to install packages by executing it with the name
    of the package. This can be augmented by adding a version. If the version is omitted,
    it will install the newest version. In addition to this, you can use save flags
    that create a property in dependencies or devDependcies.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the entire list of what `npm install` can do, but it is the most
    used list.
  prefs: []
  type: TYPE_NORMAL
- en: update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will update a package to the newest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This command will update all the packages or a specific package to the newest
    version.
  prefs: []
  type: TYPE_NORMAL
- en: shrinkwrap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will explicitly define all the dependencies for a project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is different from the basic list of dependencies in `package.json`. Most
    packages have requirements of their own. When a package is installed, npm will
    go out and find the newest version that matches the dependency's specified version.
    This can lead to different versions of packages installed when run at different
    times. This is something that most developers want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: One way to combat this is to run `npm shrinkwrap`. It will create `npm-shrinkwrap.json`.
    This file will explicitly define the versions currently installed recursively
    for every package installed. This ensures that when you run `npm install` again,
    you will know what package versions will get installed.
  prefs: []
  type: TYPE_NORMAL
- en: run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will run an arbitrary command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `package.json` file has a property named scripts. This is an object that
    can have a list of commands that can be run by npm. These scripts can be anything
    that runs from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: There are three commands on npm that use these scripts objects. These are `npm
    test`, `npm start`, and `npm stop`. These commands map to test, start, and stop
    the scripts object, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example for a scripts object from `package.json` and the way to
    call it from `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stream is an interface that is used by many internal objects. Any time data
    needs to be read or written, it is most likely done through a stream. This fits
    with the Node.js asynchronous paradigm. If we are reading a large file from the
    filesystem, we would create a listener to tell us when each chunk of data is ready
    to be read. This does not change if that file is coming from the network, an HTTP
    request, or `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: We are only going to cover using a stream, in this book. The stream interface
    can be implemented with your own objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Streams can be readable, writable, or duplex (both). We will cover readable
    and writable streams separately.
  prefs: []
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is, of course, a stream that we can get data out of. A readable stream
    can be in one of the two different modes, flowing, or non-flowing. Which mode
    it is in depends on which events are listened for.
  prefs: []
  type: TYPE_NORMAL
- en: To put a stream in the flowing mode, you will just have to listen for the data
    event. Conversely, to put a stream in the non-flowing mode, you will have to listen
    for the readable event and then call the `stream.read()` function to retrieve
    data. The easiest way to understand the modes is to think about the data as a
    lot of chunks. In the flowing mode, every time a chunk is ready, the data event
    will fire, and you can read that chunk in the callback of the data event. In the
    non-flowing mode, the chunk will fire a readable event, and then, you will have
    to call read to get the chunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of events:'
  prefs: []
  type: TYPE_NORMAL
- en: readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: close
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are two examples, one that uses flowing and one that uses non-flowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: read
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use with a non-flowing readable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This returns either a string, buffer, or null. A string is returned if the encoding
    is set. A buffer is returned if the encoding is not set. Finally, null is returned
    when there is no data in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This reads from a stream. Most of the time, the optional parameter size is not
    needed and should be avoided. Only use this with a non-flowing stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that reads a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: setEncoding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This sets the encoding of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By default, a readable stream will output a buffer. This will set the encoding
    of the buffer, so a string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the opening example with `setEncoding` used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: resume and pause
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These functions pause and resume a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pause will stop a stream from emitting data events. If this is called on a non-flowing
    stream, it will be changed into a flowing stream and be paused. Resume will cause
    the stream to start emitting data events again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that pauses the stream for a few seconds before reading
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: pipe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This allows you to take the output of a readable stream and send it to the
    input of a writable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This returns the writable stream so that piping can be chained.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is exactly the same as piping output in a shell.
  prefs: []
  type: TYPE_NORMAL
- en: A great design paradigm is to pipe from a stream to another stream that transforms
    the stream and then pipe that to the output. For example, you want to send a file
    over the network. You would open the file as a readable stream, pass it to a duplex
    stream that would compress it, and pipe the output of the compression to a socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of piping output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: writable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the stream the data goes to. This is a little simpler as there are
    really only two functions that matter: write and end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the events and details of when they fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drain`: This fires when the internal buffer has written all the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish`: This fires when the stream has been ended and all the data has been
    written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This fires when an error occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that a stream can be given more data than it can write
    in a timely fashion. This is especially true when writing to a network stream.
    Because of this, the events `finish` and `drain` to let your program know that
    the data has been sent.
  prefs: []
  type: TYPE_NORMAL
- en: write
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This function writes to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This returns a Boolean value if the stream has written completely.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the main function of a writable stream. Data can be a buffer or string,
    encoding defaults to UTF8, and the callback is called when the current chunk of
    data has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'This will close the stream, and no more data can be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When you are done writing to a stream, the end function should be called on
    it. All the parameters are optional, a chunk is data that you can write before
    the stream ends, encoding will default to UTF8, and the callback will be attached
    to the finish event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to end a writable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The net module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net` module in Node.js allows us to create network connections. The connections
    that are created will be streams that we can write to and read from. This section
    will focus on just network connections and not HTTP. Node.js has a full HTTP module,
    and we will cover that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the functions assume that the `net` module has been loaded like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: createServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function will create a TCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a `net.Server` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function allows us to listen for connections. The returned object will
    be a `net.Server` object, and the connection listener will be passed to a `net.Socket`
    object. We will cover both of these objects shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that shows us how to listen and write to a socket.
    Each connection will have to be manually closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: net.Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now look at the `net.Server` object. All of the functions in the next
    section will need to a have a `Server` object created through `createServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `net.Server` parameter is an `EventEmitter` that will emit events. Here
    is a list of the events with the event argument if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection: `net.Socket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error: `Error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listening`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that uses all of the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: listen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This starts accepting connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a server does not get it to start listening to requests. We will have
    to give the listen function at least a port. The host is optional, as it will
    listen on all IPv4 addresses, and the backlog will be the queue of connections.
    Finally, the callback will be called when the server starts listening.
  prefs: []
  type: TYPE_NORMAL
- en: You may get `EADDRINUSE`. This just means that the port is already being used
    by another process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that defines all the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: close
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This closes the current server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will stop the server from creating new connections. This is important to
    remember because it will not close the current connections.
  prefs: []
  type: TYPE_NORMAL
- en: The callback is called when there are no more connections.
  prefs: []
  type: TYPE_NORMAL
- en: address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the port and address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will give you the port and IP address where this server is listening.
  prefs: []
  type: TYPE_NORMAL
- en: getConnections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the number of connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This does not give any information on each connection. It only returns the number.
    This is a great way to see whether there are any connections. The callback function
    will need to be in the form of *function(err, connections)*.
  prefs: []
  type: TYPE_NORMAL
- en: connect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This easily creates a connection to the specified address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a `net.Socket` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function does not do anything that you cannot do with a socket. It is a
    convenient function that returns a `net.Socket` object.
  prefs: []
  type: TYPE_NORMAL
- en: For the parameters, a port is required, the host will default to localhost,
    and `connectListener` will be added to the connect event of the newly formed `net.Socket`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will connect to a server we just created and send data
    every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: net.Socket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will be similar to the `net.Server` section. The `net.Socket` parameter
    is the object that is returned anytime a connection is made. It can also be used
    to create a new connection.
  prefs: []
  type: TYPE_NORMAL
- en: It is a readable and writable stream. This is the only way to send and receive
    data from a `net.Socket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of events along with details of when they fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect`: On connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: When data is received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: When the socket has ended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: When the socket has timed out from inactivity. The socket is still
    open at this point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drain`: When all the data in the write buffer has been sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Error`: On error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`: When the socket closes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As `net.Socket` is a readable stream, there is no read function. You will have
    to listen for the data event to the get the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using a socket to connect to a local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: connect
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This creates a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the function that actually creates a connection. Much like `net.connection`,
    the port is required, the host will default to localhost, and the listener just
    maps the function to the connection event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that connects locally and writes to the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: write
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This sends data out on the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The socket is buffered because it is very easy to queue up more data than can
    be sent over the network. This is done automatically by Node.js, but you should
    be aware of this, as buffering will use up memory as it is holding the data to
    be sent.
  prefs: []
  type: TYPE_NORMAL
- en: The encoding parameter will default to UTF8, but any of the encodings we have
    discussed can be used. The callback will be called once the data has been written
    over the socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with all of the parameters defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: end
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This starts the closing process of the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is effectively closing the socket. We cannot say for sure, but the reason
    could be that the server could send some data back, although the socket will close
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can send some data before the socket closes, and this is what the optional
    parameters are for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover the HTTP server module. Technically, you could write your HTTP
    server using the `net` module, but you do not have to.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these functions are very similar to the `net` module functions. This
    should make sense as HTTP, at its core, is a network server.
  prefs: []
  type: TYPE_NORMAL
- en: All of these functions and objects are also used with the HTTPS module. The
    only difference is that for the options of `createServer` and `https.request`,
    you can pass certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following examples assume that the module has been loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: createServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This creates an HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Return Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns an `http.Server` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like `net.createServer`, this is required to serve anything. The `requestListener`
    parameter is attached to the request event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that just logs to the console any time a request is
    made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: http.Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the server object that is returned from `http.createServer`. This is
    the object that will respond to all requests.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the functions and look at each event separately as the events
    are important to handling requests.
  prefs: []
  type: TYPE_NORMAL
- en: listen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This tells the server to listen on the supplied port, path, or file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although this function has three different ways to execute, you will most likely
    only use the network listener. In fact, the other two listeners are difficult,
    if not impossible, to even execute on Windows. Let's cover the last two quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The path listener will use a local socket server, and the file descriptor will
    need a handle. If this sounds foreign, it means you will use the other method.
  prefs: []
  type: TYPE_NORMAL
- en: The network listener requires that the port be used. The host will default to
    localhost if nothing is passed in. In all the functions, a callback will be attached
    to the listening event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of listening on a network port with all the parameters defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: close
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This closes the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will stop the server from listening. The callback will be attached to the
    close event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `http.Server` parameter is an `EventEmitter` object. The events are also
    where the majority of work will be done.
  prefs: []
  type: TYPE_NORMAL
- en: request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This event fires when a request comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you only listen to one event, this is the event to listen for. It has the
    `request` and the server's response. The `req` attribute will be `http.IncomingMessage`,
    and the `res` attribute will be `http.ServerResponse`. We will look at both of
    these objects in this section. In addition to this, `req` implements a readable
    stream interface, and `res` implements a writable stream interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of listening for a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: close
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This event fires when the server closes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: upgrade
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This event fires when the client sends an HTTP upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An upgrade request asks the web server to change protocols. If you are implementing
    another protocol other than HTTP you should listen and deal with this event. A
    great example of this is a `WebSocket` upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: The `req` attribute is the request, the socket will be a `net.Socket`, and `buffer`
    is a Buffer.
  prefs: []
  type: TYPE_NORMAL
- en: IncomingMessage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the request object when listening for the request event or from `http.clientRequest`.
    This is a readable stream.
  prefs: []
  type: TYPE_NORMAL
- en: headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The HTTP headers from the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, you will want to make decisions based on the information in the
    headers. Here is an example using headers to check for basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This gets the HTTP method of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This returns the method as a string in uppercase. Here is an example for `GET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: url
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the URL that was requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will be a string of the URL, including any query parameters. You can parse
    the string yourself or use Node's query string module and use the `parse` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that will serve any files in the current directory.
    Remember that this is only an example and does no error checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the data event from the readable stream interface.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you have an incoming message, most likely, you would want to know what is
    in the message. As it is a readable stream, we will need to listen for the data
    event to get all the data out. When the data is exhausted, the end event will
    fire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that creates listeners for the data and end event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: ServerResponse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the response that the HTTP server creates for the event request. Each
    request needs a response, and this is it. This implements a writable interface.
  prefs: []
  type: TYPE_NORMAL
- en: writeHead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will write the HTTP response header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This writes the header for the response. This needs to be called before `response.write`.
    If it is not, then the server will send it for you with the headers you have set.
  prefs: []
  type: TYPE_NORMAL
- en: '`statusCode` is the HTTP status code of the response. A `header` is an object
    with the name of the header as a property and the value as the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that writes the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: statusCode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sets the status code of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is used instead of `response.writeHead`. If this is called after `writeHead`
    has been executed, then it will not change the response header. It must be called
    instead of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses `statusCode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: setHeader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This writes a specific header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the same way that `statusCode` must be called instead of `writeHead`, `setHeader`
    must be called instead of `writeHead`. This can be called multiple times to set
    multiple headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `statusCode` and `setHeader` together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the function that writes the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `response.write` parameter is a writable stream, so this interface can
    be used. A chunk can be a buffer or string. The encoding is optional as it will
    default to UTF8\. Here is an example that writes a simple HTML page as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: end
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This ends the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `response` parameter is a writable stream, so we must end the stream when
    we are done writing. Data is any optional data that needs to be written, and encoding
    will default to UTF8\. All of the examples for response have used `res.end`. If
    you do not end the response, the browser will wait for a response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: http.request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This makes a request using HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns an `http.ClientRequest` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Node.js allows you to consume HTTP as well as serve it. The options object
    has many properties that can be set. Here is a list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socketPath`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`agent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every option is not required for each request. Most of the time, only `hostname`,
    `port`, `path`, and `method` are needed to make a request. The options parameter
    can also be a URL as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback will be attached to the response event. The request object is
    a writable stream so that data can be sent to the server. Here is an example that
    makes a request to Packt Publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: http.get
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the convenience method for a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Return value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a `http.ClientRequest` object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This works in a manner similar to `http.request`, except it automatically sends
    an empty request and calls the end function. If you are only making a `GET` request,
    this can save some boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that requests Packt Publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: http.clientRequest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the object that is returned from `http.request`.
  prefs: []
  type: TYPE_NORMAL
- en: write
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This writes to the server in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `http.clientRequest` attribute is a writable stream. It is writable as you
    may need to send data to the remote server, for example, when making a `POST`
    request.
  prefs: []
  type: TYPE_NORMAL
- en: This works like all the other writable streams, so data can be a buffer or string,
    and encoding will default to UTF8.
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This ends the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you are writing to a stream, you must end the stream with this function.
    Without doing this, the connection will stay and/or timeout. Data is optional
    and can be a buffer or string, while encoding will default to UTF8.
  prefs: []
  type: TYPE_NORMAL
- en: response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the response event. It lets you know that the remote server has responded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This event fires when the remote server responds. The response object in the
    callback will be `http.incomingMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: If no response handler is added, the server response will be discarded. If there
    is a response handler, then Node.js will start to buffer the response to memory.
    If you do not read it back out, you can cause the server to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example listener that reads the data from the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
