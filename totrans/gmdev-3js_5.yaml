- en: Chapter 5. Design and Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 设计与开发
- en: While other chapters have focused on the Three.js API and how to use it to build
    games, this chapter discusses how to make *good* games using Three.js and the
    Web as a platform. We'll use what we've learned so far as a foundation to explore
    game design concepts and development processes, investigate performance considerations,
    and introduce JavaScript-based game networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他章节已经关注了Three.js API及其如何用于构建游戏，但本章讨论了如何利用Three.js和Web平台制作**优秀的**游戏。我们将利用到目前为止所学的内容作为基础，来探索游戏设计概念和开发流程，研究性能考虑因素，并介绍基于JavaScript的游戏网络。
- en: Game design for the Web
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络游戏设计
- en: Building games based on WebGL that match or exceed console quality should be
    possible, and doing so is a worthy goal. Additionally, building games for the
    Web presents an opportunity to take advantage of features that aren't possible
    for desktop and console games, although there are also a few drawbacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基于WebGL构建的游戏，其质量可以与或超过游戏机，这是可能的，而且这样做是一个值得追求的目标。此外，为网络构建游戏也提供了一个利用桌面游戏和游戏机无法实现的功能的机会，尽管也存在一些缺点。
- en: For example, you can build mechanics around having game data in URLs. Beyond
    just indicating save/load points, URLs could encode pickups, locations, random
    seeds, or other information. Add sharing to the mix and suddenly you have the
    ability for users to e-mail or tweet a link to their friends and have them drop
    instantly into the same point in your game. Unlike console games, web games can
    build on viral dynamics, the ubiquity of browsers, and low barriers to entry to
    attract more users and introduce new gameplay. You might imagine collaborative
    puzzle games that require a certain number of players to be completed—a concept
    that wouldn't be reliable for an expensive console game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以围绕将游戏数据放在URL中构建机制。除了仅仅表示保存/加载点之外，URL还可以编码拾取物、位置、随机种子或其他信息。加入分享功能后，用户就可以通过电子邮件或推文将链接发送给朋友，并立即进入游戏中的相同位置。与游戏机游戏不同，网络游戏可以利用病毒式动态、浏览器的普遍性和低门槛来吸引更多用户并引入新的游戏玩法。你可以想象需要一定数量玩家才能完成的协作解谜游戏——这个概念对于昂贵的游戏机游戏来说可能并不可靠。
- en: At the same time, gamers who buy an expensive console game are probably more
    likely to put in some effort to get over an initial learning curve. Unless users
    pay for your game up front, it's important to be conscious of the fact that users
    can leave your game just as easily as they arrived. Gaming has always been about
    balancing difficulty with engagement; it's the same formula, but it's more important
    than ever to consider the amount of time between hitting your landing page and
    that first taste of sweet satisfaction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，购买昂贵游戏机的玩家可能更有可能付出努力来克服初始的学习曲线。除非用户预先为你的游戏付费，否则重要的是要意识到用户可以像他们到达时一样轻易地离开你的游戏。游戏始终是关于平衡难度和参与度的；这是一个相同的公式，但考虑从点击你的着陆页到第一次品尝甜蜜满足感之间的时间间隔比以往任何时候都更重要。
- en: Web-based games also benefit from a strong tradition of APIs and integrations.
    Of course console games can also use APIs, but by definition, web-based games
    can typically rely on players having an Internet connection, so you can imagine
    gameplay elements such as imagery from Google Earth, location names and tips based
    on Foursquare data, and AI characters who actively use social networks. In particular,
    you can easily integrate payment processing into your games, perhaps even superimposed
    over a cash register or ATM, and reasonably expect that many users will have access
    to a keyboard that will let them type in their credit card information more easily
    than they could with a joystick. This opens the door to non-traditional payment
    methods that don't require charging up-front for games, more akin to the way mobile
    games often make money from in-app sales.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web的游戏还受益于强大的API和集成传统。当然，游戏机游戏也可以使用API，但根据定义，基于Web的游戏通常可以依赖玩家拥有互联网连接，因此你可以想象游戏元素，如Google
    Earth的图像、基于Foursquare数据的位置名称和提示，以及积极使用社交网络的AI角色。特别是，你可以轻松地将支付处理集成到你的游戏中，可能甚至是在收银台或ATM机上叠加，并合理预期许多用户将能够通过键盘更容易地输入他们的信用卡信息，而不是使用游戏手柄。这为非传统支付方式打开了大门，这些支付方式不需要预先收费购买游戏，更类似于移动游戏通常从应用内销售中赚钱的方式。
- en: Additionally, webcam and microphone access is growing rapidly among laptop users,
    and Chrome and Firefox now support these peripherals with the WebRTC API. Potential
    uses of this technology go beyond simple chatting. Ambient sound could be detected
    and used to adjust the tempo of game music. With some machine vision or perhaps
    a Leap Motion device, users could interact directly with the game by waving their
    hands instead of manipulating a mouse. Imagine a game of Roller Coaster Tycoon
    where you could literally pick up visitors and fling them to the other side of
    your park! There are lots of other cool uses for machine vision as well. *John
    Carmack* (lead programmer of Doom and Quake among other iconic games) recently
    suggested running garbage collection when the user blinks. Research at MIT has
    shown that webcam video can be used to accurately identify visitors' heart rates,
    which could allow games to adjust their pace to match (or compensate for) users'
    excitement ([http://people.csail.mit.edu/mrub/vidmag/](http://people.csail.mit.edu/mrub/vidmag/)).
    And hand-tracking technology is already being used for 3D modeling, game development,
    and even rocket design.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，笔记本电脑用户对摄像头和麦克风的访问需求正在迅速增长，Chrome 和 Firefox 现在通过 WebRTC API 支持这些外围设备。这项技术的潜在用途远不止简单的聊天。环境声音可以被检测并用于调整游戏音乐的节奏。借助一些机器视觉或Leap
    Motion 设备，用户可以通过挥手直接与游戏互动，而不是操纵鼠标。想象一下一款《过山车大亨》游戏，你真的可以拿起游客并将他们扔到公园的另一边！机器视觉还有许多其他酷炫的应用。*约翰·卡马克*（多款标志性游戏如《毁灭战士》和《雷神之锤》的首席程序员）最近建议在用户眨眼时进行垃圾回收。麻省理工学院的研究表明，摄像头视频可以用来准确识别游客的心率，这可以让游戏调整它们的节奏以匹配（或补偿）用户的兴奋程度（[http://people.csail.mit.edu/mrub/vidmag/](http://people.csail.mit.edu/mrub/vidmag/））。而且，手部追踪技术已经被用于3D建模、游戏开发，甚至火箭设计。
- en: Other external devices such as the Oculus Rift augmented reality headset can
    be supported for deeper integration into your environment. (Three.js actually
    includes a controller for the Oculus Rift in the `examples/js/controls` folder).
    For example, mobile phones can be used as controllers for web games as described
    at [http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game](http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game)
    and [http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/](http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/).
    Experimental support for traditional USB game controllers exists in some browsers
    as well; one library to help with that is available at [http://www.gamepadjs.com/](http://www.gamepadjs.com/).
    Phones and tablets could even be used as an additional screen—perhaps for a minimap,
    inventory list, or rearview mirror.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其他外部设备，如Oculus Rift增强现实头盔，也可以得到支持，以便更深入地集成到你的环境中。（Three.js实际上在`examples/js/controls`文件夹中包含了一个Oculus
    Rift的控制器）。例如，手机可以用作网络游戏的控制器，正如在[http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game](http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game)和[http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/](http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/)中描述的那样。一些浏览器也提供了对传统USB游戏控制器的实验性支持；一个帮助实现这一点的库可以在[http://www.gamepadjs.com/](http://www.gamepadjs.com/)找到。手机和平板电脑甚至可以用作额外的屏幕——可能是用于小地图、物品清单或后视镜。
- en: That said, because the Web is universally available, consider what devices may
    be accessing your game and what constraints they may have. Varied screen sizes
    and resolutions are nothing new, but touch controls in particular can present
    challenges for 3D games. Still, applying traditional web development techniques
    to games can yield creative solutions. For instance, taking the approach of graceful
    degradation / progressive enhancement, mobile users could be delivered a spectator
    view or some other reduced version of the game. Alternatively, you could provide
    onscreen controls when keyboards and mice aren't available, perhaps with the HTML5
    Virtual Game Controller library ([https://github.com/austinhallock/html5-virtual-game-controller](https://github.com/austinhallock/html5-virtual-game-controller)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，鉴于网络普遍可用，考虑一下可能访问你的游戏的设备和它们可能面临的限制。不同的屏幕尺寸和分辨率并不新鲜，但触摸控制尤其可能给3D游戏带来挑战。尽管如此，将传统的网络开发技术应用于游戏可以产生创造性的解决方案。例如，采用优雅降级/渐进增强的方法，移动用户可以收到观众视角或其他简化的游戏版本。或者，当没有键盘和鼠标时，你可以提供屏幕上的控制，可能使用HTML5虚拟游戏控制器库([https://github.com/austinhallock/html5-virtual-game-controller](https://github.com/austinhallock/html5-virtual-game-controller))。
- en: 'One final point to think about: Three.js-driven games can integrate smoothly
    with existing websites. For example, most games need menus, and it''s much easier
    to create them in HTML than in 3D. Don''t feel like your entire application needs
    to display exclusively on the canvas. On the other hand, if you want to get creative,
    you can actually embed HTML inside your Three.js environment. You can read more
    about how to do this at [http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/](http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/)
    and [http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/](http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要思考：由Three.js驱动的游戏可以与现有网站无缝集成。例如，大多数游戏需要菜单，而在HTML中创建它们比在3D中要容易得多。不要觉得你的整个应用程序必须仅显示在画布上。另一方面，如果你想发挥创意，你实际上可以在Three.js环境中嵌入HTML。你可以在[http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/](http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/)和[http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/](http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/)了解更多关于如何做到这一点。
- en: Performance
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: In some ways, performance considerations for 3D games in browsers are pretty
    similar to those for consoles and desktop games. The biggest difference is that
    all resources must (at least initially) be streamed to the client instead of read
    from a disk. For complex 3D games with gigabytes of assets, overcoming this limitation
    for low-bandwidth clients can be a serious challenge.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，浏览器中3D游戏性能的考虑与控制台和桌面游戏非常相似。最大的区别是所有资源必须（至少最初）流式传输到客户端，而不是从磁盘读取。对于具有数十亿字节资产的复杂3D游戏，克服低带宽客户端的这一限制可能是一个严重的挑战。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'As legendary programmer *Donald Knuth* wrote:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如传奇程序员**唐纳德·克努特**所写：
- en: '"Premature optimization is the root of all evil."'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"过早优化是万恶之源。"'
- en: This section discusses best practices and suggestions to get great performance
    out of your game, but before expending significant effort, you should measure
    and test your application to see where the bottlenecks are and whether the effort
    is worthwhile.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了最佳实践和建议，以从你的游戏中获得出色的性能，但在投入大量精力之前，你应该测量和测试你的应用程序，以查看瓶颈在哪里，以及这些努力是否值得。
- en: Bandwidth/network constraints
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带宽/网络限制
- en: 'To combat bandwidth constraints, the first thing you should do is apply traditional
    optimizations which web developers have been using for years: compress the content
    your server sends with `gzip`, combine and minify JavaScript to minimize the number
    of requests the browser has to make to the server, optimize your images, enable
    the Keep-Alive header, serve assets from a limited number of domains, and use
    headers to leverage browser caching, among other techniques.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对带宽限制，你应该做的第一件事是应用传统的优化，这些优化是网络开发者多年来一直在使用的：使用`gzip`压缩服务器发送的内容，合并并压缩JavaScript以最小化浏览器需要向服务器发出的请求数量，优化你的图像，启用Keep-Alive头，从有限数量的域中提供资产，并使用头信息利用浏览器缓存，以及其他技术。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Optimizing websites in general is a particularly detailed topic, but this section
    mostly sticks to explaining optimizations specifically for games. If you are interested
    in learning more about **Web Performance Optimization** (**WPO**), start with
    these rules from Google and Yahoo!:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 优化网站通常是一个特别详细的话题，但本节主要专注于解释针对游戏的优化。如果您想了解更多关于 **Web 性能优化**（**WPO**）的信息，可以从 Google
    和 Yahoo! 的这些规则开始：
- en: '[https://developers.google.com/speed/docs/best-practices/rules_intro](https://developers.google.com/speed/docs/best-practices/rules_intro)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/speed/docs/best-practices/rules_intro](https://developers.google.com/speed/docs/best-practices/rules_intro)'
- en: '[http://developer.yahoo.com/performance/rules.html](http://developer.yahoo.com/performance/rules.html)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://developer.yahoo.com/performance/rules.html](http://developer.yahoo.com/performance/rules.html)'
- en: However, complex games won't be able to rely on browser caching for user return
    visits because browsers have limits on the maximum amount of memory cached resources
    can consume across all websites. Your game's resources will be pushed out of the
    cache as the user navigates other websites, and the cache size may be too small
    for all your resources anyway. As a result, the next place to look for optimizations
    is caching inside of your game in order to minimize the number of server requests
    that need to be made. This can be done in three ways. First, you can store resources
    in other caches. The IndexedDB API ([https://developer.mozilla.org/en-US/docs/IndexedDB](https://developer.mozilla.org/en-US/docs/IndexedDB))
    supports storing files, and the Web Storage API ([https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage))
    supports storing strings (including JSON, so you can store exported Three.js objects).
    Chrome also supports the FileSystem API ([http://www.html5rocks.com/en/tutorials/file/filesystem/](http://www.html5rocks.com/en/tutorials/file/filesystem/))
    which can manage a sandboxed local filesystem. Second, you can reduce the total
    number of resources you need by generating some of them on the client. For example,
    if you need similar textures in different colors, it might make sense to modify
    those textures dynamically on the client rather than ask the server for multiple
    images. Or, if you can describe the way a mesh should animate with a system of
    equations, you might consider manually animating it on the client instead of sending
    animation data. Third, you can make sure your code is structured in a way that
    allows reusing resources instead of requesting them repeatedly. For example, if
    two meshes use the same texture, you should try to load the texture once instead
    of twice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，复杂的游戏无法依赖于浏览器缓存来处理用户的回访，因为浏览器对缓存资源在整个网站中可以消耗的最大内存量有限。当用户浏览其他网站时，您的游戏资源可能会被推离缓存，而且缓存的大小可能对于所有资源来说也太小了。因此，下一个需要寻找优化的地方是在您的游戏内部进行缓存，以最小化需要发出的服务器请求数量。这可以通过三种方式实现。首先，您可以将资源存储在其他缓存中。IndexedDB
    API ([https://developer.mozilla.org/en-US/docs/IndexedDB](https://developer.mozilla.org/en-US/docs/IndexedDB))
    支持存储文件，而 Web Storage API ([https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage))
    支持存储字符串（包括 JSON，因此您可以存储导出的 Three.js 对象）。Chrome 还支持 FileSystem API ([http://www.html5rocks.com/en/tutorials/file/filesystem/](http://www.html5rocks.com/en/tutorials/file/filesystem/))，它可以管理一个沙盒化的本地文件系统。其次，您可以通过在客户端生成一些资源来减少您需要的资源总数。例如，如果您需要不同颜色的相似纹理，动态地在客户端修改这些纹理可能比请求服务器上的多个图像更有意义。或者，如果您可以用一个方程组来描述网格应该如何动画，您可能考虑在客户端手动动画它而不是发送动画数据。第三，您确保您的代码结构允许重用资源而不是反复请求它们。例如，如果两个网格使用相同的纹理，您应该尝试只加载一次纹理，而不是两次。
- en: Finally, you can use a binary format for imported meshes that has a higher compression
    ratio than standard text-based files in order to reduce the size of assets the
    server needs to send to the client. To do so, you should export your meshes to
    Wavefront OBJ / MTL files, and then use the converter script at `utils/converters/obj/convert_obj_three.py`
    to generate a file that the `THREE.BinaryLoader` can import. (Instructions for
    running the script are at the top of the file.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用比标准基于文本的文件具有更高压缩率的二进制格式来导入网格，以减少服务器需要发送到客户端的资产大小。为此，您应该将您的网格导出为 Wavefront
    OBJ / MTL 文件，然后使用 `utils/converters/obj/convert_obj_three.py` 中的转换脚本生成一个 `THREE.BinaryLoader`
    可以导入的文件。（运行脚本的说明在文件顶部。）
- en: In addition to reducing the total size of resources that need to be retrieved
    from a server, you can try to load as much data as possible while the user doesn't
    need to see it. For example, if players enter your game from a menu, you may be
    able to start loading while the player is navigating the menu rather than waiting
    until they click to start the game. You can also wait to load parts of your scene
    that won't be visible initially until after the player has entered the game, in
    order to let the player start playing as quickly as possible. For example, linear
    mission-based games can wait to load parts of the map until the player reaches
    certain checkpoints. Just make sure you have a fallback plan if resources are
    loading slowly and the player reaches your unloaded area too early. You might
    want to have a door that won't open until the resources are loaded. You could
    also just pause the game momentarily when the player is in a transitional location.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少从服务器检索的资源总大小外，你还可以在用户不需要看到它的情况下尽可能多地加载数据。例如，如果玩家从菜单进入你的游戏，你可以在玩家浏览菜单时开始加载，而不是等到他们点击开始游戏。你也可以等到玩家进入游戏后再加载场景中最初不可见的部分，以便让玩家尽可能快地开始游戏。例如，基于线性任务的游戏可以等到玩家到达某些检查点时再加载地图的部分。只是确保你有一个后备计划，以防资源加载缓慢且玩家过早地到达未加载的区域。你可能想要有一个门，直到资源加载完毕才打开。你也可以在玩家处于过渡位置时暂时暂停游戏。
- en: Level of detail
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细节级别
- en: 'Similarly, you can load low-poly meshes and low-resolution textures when the
    user starts playing the game and replace them with higher-detail assets during
    gameplay, either when the larger assets are loaded or when the user gets close
    enough to them to see the improved detail. The latter technique is called **Level-of-Detail**
    (**LOD**), and Three.js has built-in support for it using the `THREE.LOD` object.
    For example, we could modify the spinning shape example we built in [Chapter 1](ch01.html
    "Chapter 1. Hello, Three.js"), *Hello, Three.js*, to change the detail of our
    sphere depending on how close to it we are. First we need to change how we add
    the mesh to the scene:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当用户开始玩游戏时，你可以加载低多边形网格和低分辨率纹理，并在游戏过程中用更高细节的资产替换它们，无论是当加载较大资产时还是当用户足够接近它们以看到改进的细节时。后者技术称为**细节级别**（**LOD**），Three.js
    使用 `THREE.LOD` 对象内置了对它的支持。例如，我们可以修改我们在[第1章](ch01.html "第1章。你好，Three.js")中构建的旋转形状示例，根据我们离球体有多近来改变球体的细节。首先我们需要改变我们如何将网格添加到场景中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `LOD` object stores objects of different complexities along with the distances
    at which higher-detail versions should be used. To make the mesh change detail
    when the camera moves closer or farther away, we''ll update the `LOD` object in
    the animation loop:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOD` 对象存储不同复杂性的对象以及应使用更高细节版本的距离。为了使网格在相机靠近或远离时改变细节，我们将在动画循环中更新 `LOD` 对象：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We added a little bit of movement here so that we can see the detail change.
    Let''s move the camera so that we can see the movement better by setting `camera.position.z
    = 3000`. Now you should be able to see the detail change dynamically, as shown
    in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了一点点移动，这样我们就可以通过设置 `camera.position.z = 3000` 来更好地看到细节的变化。现在你应该能够看到细节的动态变化，如下面的截图所示：
- en: '![Level of detail](img/8539_05_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![细节级别](img/8539_05_01.jpg)'
- en: A sphere with increasing detail as the camera gets closer
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着相机靠近而细节增加的球体
- en: Rendering optimizations
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染优化
- en: Three.js has built-in support for other detail-related optimizations as well
    in order to make processing faster. **Culling**, the process of excluding hidden
    objects from rendering, is a common example. Three.js does **view frustum culling**
    based on bounding spheres, meaning it will avoid spending valuable compute time
    calculating visual information about objects that are off screen. It also does
    **backface culling** by default, which hides the back side of mesh faces. However,
    it doesn't do **occlusion culling**, meaning it doesn't know not to render an
    object that is in front of the camera but obscured by another object that is closer
    to the camera. The implication of these optimizations is that large meshes should
    often be split into several smaller ones to reduce computation if only part of
    the large mesh is on the screen, and you don't get any benefits by default from
    having short viewable distances. This simple change might be sufficient for top-down
    games where few objects are obscured by other objects. Other games, such as first-person
    shooters where buildings or terrain can block long view distances, may need to
    compensate in other ways. For example, if you have really large or detailed worlds,
    you may want to work on manual occlusion culling. Game engines typically do this
    using a technique called **depth testing**, but a simpler approach that can work
    for enclosed layouts (such as the insides of buildings) is to create invisible
    cubes encompassing different zones in the world based on view distances and then
    toggle the visibility of meshes inside those zones when the player gets close
    enough.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 还内置了对其他与细节相关的优化支持，以便使处理更快。**剔除**，即从渲染中排除隐藏对象的过程，是一个常见的例子。Three.js 基于边界球体进行**视锥剔除**，这意味着它会避免花费宝贵的计算时间来计算屏幕外对象的视觉信息。它还默认进行**背面剔除**，隐藏网格面的背面。然而，它不进行**遮挡剔除**，这意味着它不知道不要渲染一个位于相机前方但被更靠近相机的另一个对象遮挡的对象。这些优化的含义是，大型网格通常应该分成几个较小的网格，如果只有大型网格的一部分在屏幕上，就可以减少计算量，并且默认情况下，缩短可视距离不会带来任何好处。这种简单的改变可能对于顶部视角游戏就足够了，在这种游戏中，很少有对象被其他对象遮挡。其他游戏，如第一人称射击游戏，其中建筑物或地形可能会阻挡长距离的视野，可能需要以其他方式补偿。例如，如果你有非常大的或详细的场景，你可能需要手动进行遮挡剔除。游戏引擎通常使用一种称为**深度测试**的技术来完成这项工作，但对于封闭布局（如建筑物的内部）来说，一个更简单的方法是根据视距创建包含世界不同区域的不可见立方体，然后在玩家足够接近时切换这些区域内部网格的可见性。
- en: 'We''ve already discussed the advantages of merging geometry in [Chapter 2](ch02.html
    "Chapter 2. Building a World"), *Building a World*, but you can get additional
    performance benefit out of transforming static geometry into `BufferGeometry`.
    `BufferGeometry` typically renders faster than standard `Geometry` because it
    uses a data structure that is closer to what will get passed to the GPU instead
    of one that is easy for humans to understand. As a result, it is harder to manipulate,
    but it works well if you know your geometry won''t change. The easiest way to
    use `BufferGeometry` is to convert from existing `Geometry` using the utility
    in `examples/js/BufferGeometryUtils.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](ch02.html "第2章。构建世界")中讨论了合并几何体的优势，*构建世界*，但你还可以通过将静态几何体转换为 `BufferGeometry`
    来获得额外的性能提升。`BufferGeometry` 通常比标准 `Geometry` 渲染更快，因为它使用的数据结构更接近将被传递给 GPU 的数据结构，而不是人类容易理解的数据结构。因此，它更难操作，但如果你知道你的几何体不会改变，它工作得很好。使用
    `BufferGeometry` 的最简单方法是使用 `examples/js/BufferGeometryUtils.js` 中的实用工具从现有的 `Geometry`
    转换。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use the result with meshes the same way you would use normal geometry.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用结果与网格相同的方式使用正常几何体。
- en: 'Another powerful optimization is changing the resolution of the canvas. Assuming
    `renderer` and `camera` are globals, you can use this function to do so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种强大的优化是改变画布的分辨率。假设 `renderer` 和 `camera` 是全局变量，你可以使用此函数来做到这一点：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can use this function by calling `resize(0.5)`, for example, which will
    allow the renderer to paint only `0.5*0.5 = 25%` of the pixels it would paint
    at full resolution, even though the canvas will take up the same amount of space
    on the screen. (The `scale` parameter is always relative to the canvas' original
    size.) This works because canvases are basically just images. In the same way
    that you can style an image to be larger in CSS without changing its actual size,
    you can style a canvas to be larger too. In our `resize` function, we first reduce
    the actual size of the canvas by changing its `width` and `height` attributes,
    then scale it back up using the CSS width and height styles. The result is that
    the canvas takes up the same amount of screen space that it did originally, but
    each actual pixel is displayed larger. This significantly reduces the amount of
    computation required to render a scene, although the scene will be blurrier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`resize(0.5)`这样的函数来使用此功能，这将允许渲染器只绘制`0.5*0.5 = 25%`的像素，即使画布在屏幕上占据相同的空间。（`scale`参数始终相对于画布的原始大小。）这是因为画布基本上只是图像。就像你可以在CSS中通过不改变其实际大小来调整图像的大小一样，你也可以调整画布的大小。在我们的`resize`函数中，我们首先通过改变其`width`和`height`属性来减小画布的实际大小，然后使用CSS的宽度和高度样式将其放回原来的大小。结果是，画布占据的屏幕空间与原来相同，但每个实际像素显示得更大。这显著减少了渲染场景所需的计算量，尽管场景会变得模糊。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Changing the resolution of the canvas affects how you need to compute where
    the user clicks. You should track the canvas'' current scale and adjust the screen-space
    vector in our click method from [Chapter 3](ch03.html "Chapter 3. Exploring and
    Interacting"), *Exploring and Interacting*, accordingly:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 改变画布的分辨率会影响你需要计算用户点击位置的方式。你应该跟踪画布的当前缩放比例，并相应地调整第3章中点击方法中的屏幕空间向量，*探索和交互*：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Techniques that compromise visual detail in favor of speed are especially useful
    when combined with frame-rate testing. If the frame rate dips below a certain
    threshold for more than a given percent of the time in a certain testing period,
    you may want to reduce your game's detail. (You should figure out what your bottleneck
    is before implementing this approach. If your frame rates are low because your
    physics loop takes a long time to run, reducing visual detail may not help much.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了速度而牺牲视觉细节的技术在结合帧率测试时特别有用。如果在某个测试期间，帧率低于某个特定阈值的时间超过给定百分比，你可能想要降低游戏的细节级别。（在实施此方法之前，你应该找出你的瓶颈是什么。如果你的帧率低是因为你的物理循环运行时间过长，降低视觉细节可能帮助不大。）
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If physics is your bottleneck, you can run your physics at a lower frame rate
    than your rendering as discussed in [Chapter 3](ch03.html "Chapter 3. Exploring
    and Interacting"), *Exploring and Interacting*. You may also want to consider
    using the Web Worker API ([https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers))
    to execute JavaScript code in parallel. This can allow calculating movement and
    collision without blocking the rendering. The Physi.js library introduced in [Chapter
    3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and Interacting*,
    does this automatically.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物理是你的瓶颈，你可以按照第3章中讨论的，以低于渲染的帧率运行你的物理，第3章：探索和交互。你也可能想要考虑使用Web Worker API（[https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers)）来并行执行JavaScript代码。这可以允许在不阻塞渲染的情况下计算运动和碰撞。在第3章中引入的Physi.js库，*探索和交互*，会自动执行此操作。
- en: Battery life and GPU memory
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电池续航和GPU内存
- en: 'Although bandwidth/network speed and processing time are the factors that usually
    affect the performance of Three.js games the most, battery life and memory constraints
    may also come into play. For hardcore games, you may be able to assume the user
    is plugged in, but more casual games should be aware that more processing typically
    equates to more battery drain. On the memory front, the question is less about
    storage space and more about the graphics card having a limited amount of embedded
    memory with which it can perform fast computations. The main thing you can do
    to limit how much of the GPU''s onboard memory you consume is to use compressed
    textures. (Normally, images such as JPGs and PNGs are decompressed before being
    sent to the GPU, but compressed textures use a special format that allows the
    GPU to hold them in embedded memory in a compressed state. Since the compression
    only matters for the GPU, it doesn''t actually save network bandwidth.) Three.js
    supports compressed textures in DDS format. You can import DDS textures into Three.js
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管带宽/网络速度和处理器时间通常是影响Three.js游戏性能的最主要因素，但电池寿命和内存限制也可能发挥作用。对于硬核游戏，你可能可以假设用户已经插上电源，但更休闲的游戏应该意识到更多的处理通常意味着更多的电池消耗。在内存方面，问题更多是关于存储空间，而不是图形卡有限的嵌入式内存，它可以进行快速计算。你可以通过使用压缩纹理来限制你消耗的GPU板载内存量。通常，图像（如JPG和PNG）在发送到GPU之前会被解压缩，但压缩纹理使用一种特殊的格式，允许GPU以压缩状态将它们保存在嵌入式内存中。由于压缩只对GPU有影响，实际上并不节省网络带宽。Three.js支持DDS格式的压缩纹理。你可以这样将DDS纹理导入到Three.js中：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resulting `texture` value can be treated the same way normal images are
    treated; you can use it as the value for the `map` property of materials, for
    example, and Three.js will automatically know how to handle it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`texture`值可以像处理普通图像一样处理；例如，你可以将其用作材质的`map`属性的值，Three.js将自动知道如何处理它。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To create DDS images, you can use a plugin for Gimp ([https://code.google.com/p/gimp-dds/](https://code.google.com/p/gimp-dds/))
    or Photoshop ([https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop](https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建DDS图像，你可以使用Gimp的插件([https://code.google.com/p/gimp-dds/](https://code.google.com/p/gimp-dds/))或Photoshop([https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop](https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop))。
- en: Performance-measuring tools
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测量工具
- en: Finally, there are a number of useful tools for measuring JavaScript performance.
    Conveniently, the original author of Three.js has written a library called Stats.js
    ([https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js)) for
    tracking frame rates, the most crucial performance statistic for games. For comprehensive
    tracing, Google's Web Tracing Framework ([http://google.github.io/tracing-framework/index.html](http://google.github.io/tracing-framework/index.html))
    is hard to beat, and it even has an example for tracing a WebGL game. You can
    also easily get some statistics about onscreen geometry with the RenderStats library
    from *Jerome Etienne* ([https://github.com/jeromeetienne/threex.rendererstats](https://github.com/jeromeetienne/threex.rendererstats)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些非常有用的工具可以用来测量JavaScript的性能。方便的是，Three.js的原始作者编写了一个名为Stats.js的库([https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js))，用于跟踪帧率，这是游戏中最关键的性能统计指标。对于全面的跟踪，Google的Web
    Tracing Framework([http://google.github.io/tracing-framework/index.html](http://google.github.io/tracing-framework/index.html))难以匹敌，它甚至提供了一个跟踪WebGL游戏的示例。你还可以使用来自*Jerome
    Etienne*的RenderStats库([https://github.com/jeromeetienne/threex.rendererstats](https://github.com/jeromeetienne/threex.rendererstats))轻松获取一些关于屏幕几何形状的统计数据。
- en: For brute-force debugging, you may also want to try the console-extras library,
    which makes it easier to log information about things that happen in the main
    game loop without dumping thousands of messages ([https://github.com/unconed/console-extras.js](https://github.com/unconed/console-extras.js)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于暴力调试，你可能还想要尝试console-extras库，它使得在不输出数千条消息的情况下记录主游戏循环中发生的事情变得更加容易([https://github.com/unconed/console-extras.js](https://github.com/unconed/console-extras.js))。
- en: Networking and multiplayer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和多人游戏
- en: Game networking is hard because the goal of networking is to keep game state
    in sync across multiple devices, but network latency prevents devices from communicating
    fast enough to keep that state from being occasionally inconsistent. Additionally,
    floating point rounding errors create indeterminate results across devices for
    the same set of input (this is where the timing and movement techniques discussed
    in [Chapter 3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and
    Interacting* come into play, since small differences in precision can result in
    huge differences over time). As a result, networking code becomes a process of
    reconciling differences.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏网络很困难，因为网络的目标是在多个设备上保持游戏状态同步，但网络延迟阻止了设备以足够的速度进行通信以保持该状态偶尔不一致。此外，浮点舍入误差会在同一组输入（这是[第3章](ch03.html
    "第3章。探索和交互")中讨论的计时和移动技术发挥作用的地方，*探索和交互*），因为精度的小差异可能导致随时间产生巨大的差异）。因此，网络代码成为协调差异的过程。
- en: There are basically two different approaches to networking depending on the
    requirements of the game. RTS and turn-based games usually use an approach called
    **lock-step**, which is a peer-to-peer model in which each computer in a match
    sends its commands to all the other computers in the match. The main strength
    of this model is that only a small amount of data (the players' commands) needs
    to be sent over the network, so it is useful when the game state is huge (for
    example, when there are thousands of units in a map). However, running a game
    in lock-step depends on all players having an identical copy of the game state,
    which is a great idea in theory but is difficult to maintain for several reasons.
    First, although the JavaScript specification states that floating point calculations
    should be deterministic, in practice there may be subtle differences across implementations
    that could prevent clients from being in sync.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据游戏的需求，基本上有两种不同的网络方法。实时战略（RTS）和回合制游戏通常使用一种称为**锁步**的方法，这是一种对等模型，其中每台参与比赛的个人电脑都会将其命令发送给比赛中的其他所有电脑。这种模型的主要优势是只需要发送少量数据（玩家的命令）到网络上，因此当游戏状态非常大时（例如，当地图上有成千上万的单位时）非常有用。然而，在锁步模式下运行游戏依赖于所有玩家拥有游戏状态的相同副本，这在理论上是伟大的想法，但出于几个原因难以维持。首先，尽管JavaScript规范声明浮点计算应该是确定的，但在实践中，不同实现之间可能存在细微的差异，这可能导致客户端无法同步。
- en: Second, all clients will see the game run at the speed of the most-latent client
    because commands from each player must be collected before advancing in order
    to ensure synchronicity. As a result, extra precautions must be taken to keep
    clients from cheating by pretending to have higher latency and waiting for the
    other computers' commands before making a decision. The latency issue also creates
    trouble when one machine is taking a particularly long time to return a command.
    In such a situation, the game may have to drop that player. Since the reason for
    using lock-step is that the entire game state is too large to transfer over the
    network while maintaining synchronicity, it may not be feasible for a player to
    join (or re-join) after a game has already started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，所有客户端都将看到游戏以最延迟客户端的速度运行，因为必须收集每个玩家的命令才能前进以确保同步。因此，必须采取额外预防措施，以防止客户端通过假装具有更高的延迟并在做出决定之前等待其他电脑的命令来作弊。当一台机器需要特别长的时间来返回命令时，延迟问题也会造成麻烦。在这种情况下，游戏可能不得不放弃那个玩家。由于使用锁步的原因是整个游戏状态太大，无法在网络中传输同时保持同步，因此玩家在游戏开始后可能无法加入（或重新加入）。
- en: 'The other approach to game networking is a client-server prediction model ,
    which usually works like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏网络的其他方法是客户端-服务器预测模型，通常工作方式如下：
- en: The client triggers some input (such as pressing a key or moving the mouse)
    that changes the game state.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端触发一些输入（例如按下键或移动鼠标）以改变游戏状态。
- en: The client input is sent to the server.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端输入被发送到服务器。
- en: Optionally, the server forwards the input to the other clients.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，服务器将输入转发给其他客户端。
- en: The server processes the inputs it receives from all players, reconciles them,
    and produces a new, authoritative description of the game's state at a specific
    time.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器处理从所有玩家接收到的输入，进行协调，并在特定时间生成游戏状态的新的、权威的描述。
- en: If the server forwarded other clients' inputs, the clients receive those inputs
    and continue updating the local game state by predicting what the server thinks
    the state should be.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器转发了其他客户端的输入，客户端会接收到这些输入，并通过预测服务器认为状态应该是什么来继续更新本地游戏状态。
- en: The server periodically sends the latest complete description of the authoritative
    game state to each client.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器定期向每个客户端发送权威游戏状态的最新完整描述。
- en: The client adjusts its state to sync with the server's official state.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端调整其状态以与服务器官方状态同步。
- en: The main difference here compared to lock-step is that clients can advance the
    game independently, and the entire game state can be sent from the server to ensure
    each player sees something pretty close to what the others see. This is a better
    model for action games like FPSs or games with many players like MMOs because
    players generally experience less dramatic latency effects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与锁步相比，这里的主要区别是客户端可以独立推进游戏，整个游戏状态可以从服务器发送，以确保每个玩家看到的内容与其他人看到的内容非常接近。这对于像FPS或像大型多人在线游戏这样的多人游戏来说是一个更好的模型，因为玩家通常经历的延迟效应不那么剧烈。
- en: To reduce the lag that gamers can feel, we design the client-server communication
    to be asynchronous because waiting for the new game state from the server can
    take a long time due to network latency. Since we try to keep running the game
    locally while we wait for the server, we need to adjust the client when we do
    finally get an authoritative update from the server. Adjusting the client can
    be tricky, though. First of all, by the time we get a response from the server,
    the state it sends us will be in the past. To deal with this, we'll need to keep
    track of all player input since the last time we got an official server update,
    rewind the game to the newly received authoritative game state, and then replay
    any more recent input on top of that. The result will be our latest guess of what
    the server thinks the game state should be at the current time, which will likely
    be slightly different than what we've actually been showing the player. We could
    just snap the current game state to our ideal game state, but that would make
    the game seem jittery since things might spontaneously teleport. Instead, if the
    differences between states are small enough, clients should interpolate between
    their current state and their projected ideal state. If we drift too far away,
    we can snap back to the server state, but otherwise we'll lag a few frames in
    order to ensure smoothness. Snapping happens most often with complex physics interactions
    or when players collide.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少玩家可能感受到的延迟，我们设计客户端-服务器通信为异步的，因为从服务器获取新的游戏状态可能因为网络延迟而花费很长时间。由于我们试图在等待服务器的同时本地运行游戏，当我们最终从服务器获得权威更新时，我们需要调整客户端。调整客户端可能很棘手。首先，当我们从服务器获得响应时，它发送给我们的状态将是过去的。为了处理这个问题，我们需要记录自上次我们获得官方服务器更新以来的所有玩家输入，将游戏回滚到新接收到的权威游戏状态，然后在此基础上重新播放任何更近期的输入。结果将是我们对服务器认为当前时间游戏状态应该是什么的最新猜测，这可能会与我们实际上向玩家展示的内容略有不同。我们本可以将当前游戏状态瞬间切换到理想的游戏状态，但这会使游戏看起来抖动，因为事物可能会突然传送。相反，如果状态之间的差异足够小，客户端应该在当前状态和预期的理想状态之间进行插值。如果我们偏离得太远，我们可以切换回服务器状态，但否则我们会在几帧内滞后，以确保平滑性。切换通常发生在复杂的物理交互或玩家碰撞时。
- en: Ideally, we'd like to just send players' inputs to the clients because they're
    smaller than the full game state (so they take up fewer network packets). This
    might be the only sane way to handle MMO games with potentially thousands of players.
    However, this can cause drifting over time due to floating point rounding error,
    so it may not be accurate enough to be the only solution for intense action games
    like first-person shooters. As a compromise, inputs can be sent frequently and
    the full game state sent only periodically; then clients can use the inputs to
    predict how the game should progress.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们只想将玩家的输入发送到客户端，因为它们比完整游戏状态小（因此占用的网络数据包更少）。这可能是有数千名玩家的大型多人在线游戏的唯一合理处理方式。然而，这可能会因为浮点数舍入误差而随着时间的推移产生漂移，所以这可能不足以成为像第一人称射击游戏这样紧张动作游戏的唯一解决方案。作为折衷方案，输入可以频繁发送，而完整游戏状态只定期发送；然后客户端可以使用输入来预测游戏应该如何进展。
- en: Of course, not all physics is driven by user input. If your game has gameplay-affecting
    nature-driven physics such as wind or avalanches, you may need to have the server
    simulate the physics without client prediction, and clients will just have to
    deal with some latency. On the other hand, you can simulate some physics entirely
    on the client. For example, it doesn't really matter if the clouds in the sky
    are in exactly the same position on each client since they're typically just decorative.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有物理现象都是由用户输入驱动的。如果你的游戏具有受自然驱动的游戏玩法物理特性，例如风或雪崩，你可能需要服务器在没有客户端预测的情况下模拟物理现象，而客户端只需处理一些延迟。另一方面，你可以在客户端完全模拟一些物理现象。例如，天空中的云彩在各个客户端上是否完全处于相同的位置并不重要，因为它们通常只是装饰性的。
- en: The game state tracked by the server usually includes, at a minimum, the position
    and velocity of all movable actors, a unique identifier for the version of the
    state, and a timestamp. The server does not need to send a full scene export to
    every client since that would be too expensive. However, the server does need
    to simulate the full scene in order to accurately update the game state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器跟踪的游戏状态通常至少包括所有可移动角色的位置和速度、状态的唯一标识符以及时间戳。服务器不需要向每个客户端发送完整的场景导出，因为这会非常昂贵。然而，服务器确实需要模拟整个场景，以便准确更新游戏状态。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on lock-step, check out [http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/](http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/)
    and [http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/](http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于锁步的信息，请查看[http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/](http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/)和[http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/](http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/)。
- en: For more information about client-server prediction, check out [http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/](http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于客户端-服务器预测的信息，请查看[http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/](http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/)。
- en: To learn about interpolating between authoritative and client states, see [http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914](http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解关于在权威状态和客户端状态之间进行插值的信息，请参阅[http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914](http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914)。
- en: There is a great Google Tech Talk by *Rob Hawkes* on HTML5 multiplayer game
    development with many tips about overcoming common pitfalls. You can watch it
    at [https://www.youtube.com/watch?v=zj1qTrpuXJ8](https://www.youtube.com/watch?v=zj1qTrpuXJ8).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rob Hawkes有一个关于使用HTML5进行多人游戏开发的精彩Google技术演讲，其中包含许多关于克服常见陷阱的建议。您可以在[https://www.youtube.com/watch?v=zj1qTrpuXJ8](https://www.youtube.com/watch?v=zj1qTrpuXJ8)观看。
- en: Technologies
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术
- en: The Web Sockets API ([https://developer.mozilla.org/en-US/docs/WebSockets](https://developer.mozilla.org/en-US/docs/WebSockets))
    is the most practical way to maintain a fast connection with a game server in
    JavaScript, and the easiest way to use web sockets is to use node.js ([http://nodejs.org/](http://nodejs.org/))
    on the server with the socket.io library ([http://socket.io/](http://socket.io/)).
    Node.js allows JavaScript to be a first-class server-side language, so you can
    write your game code once and worry less about differences between the server-side
    and client-side simulations. It's also mentally easier to write both the server-side
    and client-side code in a single language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Web Sockets API ([https://developer.mozilla.org/en-US/docs/WebSockets](https://developer.mozilla.org/en-US/docs/WebSockets))
    是在JavaScript中与游戏服务器保持快速连接的最实用方式，使用Web Sockets的最简单方法是使用服务器上的node.js ([http://nodejs.org/](http://nodejs.org/))
    和socket.io库 ([http://socket.io/](http://socket.io/))。Node.js允许JavaScript成为一等的服务器端语言，因此您可以一次编写游戏代码，并减少对服务器端和客户端模拟之间差异的担忧。在单一语言中编写服务器端和客户端代码在心理上也要容易得多。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Web sockets are the best we can do at the moment because JavaScript doesn't
    have as much control over how it accesses the Internet as desktop and console
    games do, for security reasons. Web sockets are actually reasonably good, but
    they are based on **TCP**, which is a common way to access the Internet that ensures
    reliability but occasionally causes delays. Many desktop and console games that
    use client-server prediction use **UDP** to access the Internet instead, which
    serves the same purpose as TCP but compromises data-integrity guarantees in favor
    of minimal delays.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Web sockets 是我们目前能做的最好的选择，因为 JavaScript 在访问互联网方面没有桌面和控制台游戏那么多的控制权，这是出于安全考虑。Web
    sockets 实际上相当不错，但它们基于 **TCP**，这是一种常见的互联网访问方式，确保了可靠性但偶尔会造成延迟。许多使用客户端-服务器预测的桌面和控制台游戏使用
    **UDP** 来访问互联网，它服务于与 TCP 相同的目的，但为了最小化延迟而牺牲了数据完整性保证。
- en: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) is a good example of a
    networked game framework using Three.js. If you are building a Minecraft-style
    game, it is a great place to start. For more information and code examples on
    writing game networking code in JavaScript with Socket.io and Node.js, there is
    a good article at [http://buildnewgames.com/real-time-multiplayer/](http://buildnewgames.com/real-time-multiplayer/).
    It uses a 2D game as an example, but everything applies cleanly to 3D games as
    well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) 是一个使用 Three.js 的网络游戏框架的好例子。如果你正在构建类似
    Minecraft 的游戏，这是一个很好的起点。有关使用 Socket.io 和 Node.js 在 JavaScript 中编写游戏网络代码的更多信息及代码示例，可以在
    [http://buildnewgames.com/real-time-multiplayer/](http://buildnewgames.com/real-time-multiplayer/)
    找到。它以二维游戏为例，但所有内容都同样适用于三维游戏。
- en: Anticheating
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反作弊
- en: 'Stopping cheaters in multiplayer games is a hard problem in general, and it''s
    particularly difficult in JavaScript for three reasons. One, it''s very difficult
    to detect whether client input is automated or their display has changed illegally;
    two, JavaScript code is relatively hard to obfuscate and validate without significant
    performance penalties; and three, cheating programs can directly and easily override
    your client code. As a result, anticheating efforts typically focus on moving
    as much logic as possible from the client to the server, detecting unusual patterns
    of client activity, minimizing the benefits of cheating, and perhaps creating
    just enough annoying barriers to cheating that some aspiring cheaters give up.
    Common methods include:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中阻止作弊者是一个一般性的难题，在 JavaScript 中尤其困难，原因有三。一是很难检测客户端输入是否自动化或他们的显示是否非法更改；二是
    JavaScript 代码相对难以混淆和验证，而不会带来显著的性能损失；三是作弊程序可以直接且容易地覆盖你的客户端代码。因此，反作弊努力通常集中在尽可能将逻辑从客户端移动到服务器，检测客户端活动的异常模式，最小化作弊的好处，并可能创建足够的烦人障碍，让一些有抱负的作弊者放弃。常见的方法包括：
- en: Only letting the client send whitelisted inputs to the server, not arbitrary
    values; this allows a trusted computer (the server) to do important calculations
    and avoids letting cheaters make illegal requests such as `addPoints(1000000)`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许客户端向服务器发送白名单内的输入，而不是任意值；这允许受信任的计算机（服务器）执行重要计算，并避免让作弊者发出非法请求，例如`addPoints(1000000)`
- en: Tracking how long the user plays the game; if a user plays for 48 hours straight,
    they're worth investigating
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪用户玩游戏的时间长度；如果用户连续玩48小时，那么值得调查
- en: Tracking the amount of time that passes between user actions; if a user clicks
    on the same part of the screen every 10 minutes (suspiciously accurate) or 16
    milliseconds (suspiciously fast), they might be automating their behavior
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪用户操作之间经过的时间；如果用户每隔10分钟（可疑地准确）或16毫秒（可疑地快）点击屏幕的同一部分，他们可能正在自动化他们的行为
- en: Reporting snapping, the behavior in first-person shooters of instantly turning
    to shoot at a target as soon as there is nothing in the way, even when that target
    wasn't onscreen, and never missing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告“快速瞄准”，这是第一人称射击游戏中的一种行为，即当没有任何障碍物时，立即转向射击目标，即使目标不在屏幕上，也永远不会错过
- en: Making debugging harder, for example by disabling console logging (`console
    = {}`) and wrapping your entire client-side code in a closure to prevent any global
    variables from being easily available to cheaters' scripts
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使调试更困难，例如通过禁用控制台日志记录（`console = {}`）并将整个客户端代码包裹在一个闭包中，以防止任何全局变量轻易被作弊者的脚本访问
- en: Making it easy for users to report abuse
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户更容易报告滥用行为
- en: This is certainly not an exhaustive list, and it's very difficult to stop cheaters
    entirely, but these suggestions are a reasonable place to start.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然不是一份详尽的清单，而且完全阻止作弊者是非常困难的，但这些建议是一个合理的起点。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's generally considered poor form to prevent client-side cheating in single-player
    modes, except when it comes to artifacts that other players can see, such as high
    scores.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为在单玩家模式中防止客户端作弊是不好的做法，除非是其他玩家可以看到的物品，例如高分。
- en: Development processes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发流程
- en: Whether you're an individual who builds games as a hobby or a developer for
    a large game publisher, you can benefit from following a number of best practices
    adopted from JavaScript development for the Web and game development on other
    platforms. You can also build Three.js-based games without deviating too far from
    your favorite game development processes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是作为爱好构建游戏的个人还是大型游戏出版商的开发者，你都可以从遵循从Web JavaScript开发和在其他平台上的游戏开发中吸取的一些最佳实践中受益。你还可以在不偏离你喜欢的游戏开发流程的情况下构建基于Three.js的游戏。
- en: JavaScript best practices
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript最佳实践
- en: 'In previous chapters, we haven''t been very concerned with the high-level structure
    of our code. We wrote some examples as single HTML files, and we split the FPS
    and CTF projects into separate files, but for polished games we should be more
    careful, especially when working with teams. General coding lessons apply:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们并没有非常关注我们代码的高级结构。我们编写了一些作为单个HTML文件的示例，并将FPS和CTF项目拆分为单独的文件，但对于精炼的游戏，我们应该更加小心，尤其是在与团队合作时。一般的编码课程适用：
- en: Keep assets in folders by file type/purpose. For example, at a high level you
    might have folders such as `css`, `js`, `images`, `models`, and `sounds`. Within
    the `js` folder, organize JavaScript files by purpose; keep library, source, and
    production code separate.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据文件类型/目的将资源放在文件夹中。例如，在较高层次上，你可能会有`css`、`js`、`images`、`models`和`sounds`这样的文件夹。在`js`文件夹中，根据目的组织JavaScript文件；将库、源代码和生成代码分开。
- en: Avoid putting code that directly handles user input event listeners in class
    constructors, because that makes them harder to reuse and extend.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在类构造函数中放置直接处理用户输入事件监听器的代码，因为这会使它们更难重用和扩展。
- en: Use separate files for configuration/constants that you can fiddle with to adjust
    how the game *feels*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单独的文件来配置/常量，你可以调整这些文件来改变游戏的感觉。
- en: Detect features instead of browsers, since different browser versions support
    different features and some features can be toggled on or off in browser settings.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测特性而不是浏览器，因为不同的浏览器版本支持不同的特性，某些特性可以在浏览器设置中打开或关闭。
- en: Avoid using `setTimeout` and `setInterval` for timers in the animation loop
    because having a lot of separate timers can cause performance issues. Instead,
    check how much time has passed in your animation loop, for example, using `Date.now()`
    or `THREE.Clock`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在动画循环中使用`setTimeout`和`setInterval`作为计时器，因为有很多单独的计时器可能会导致性能问题。相反，检查动画循环中经过的时间，例如使用`Date.now()`或`THREE.Clock`。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your game can pause, make sure you're not including time elapsed while paused.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的游戏可以暂停，确保你不会包含暂停期间的时间流逝。
- en: Though it may feel natural to write the entire application in JavaScript, try
    to avoid creating new DOM in JavaScript. Doing so is slow, and there's a reason
    HTML and CSS exist. (Also, don't be afraid to use HTML and CSS; sometimes that's
    a much easier solution than, say, writing a custom shader.)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然将整个应用程序用JavaScript编写可能感觉很自然，但尽量避免在JavaScript中创建新的DOM。这样做很慢，而且HTML和CSS存在是有原因的。（此外，不要害怕使用HTML和CSS；有时这比编写自定义着色器要简单得多。）
- en: Use a style guide. Which one you choose is not especially important, but maintaining
    a consistent style helps avoid silly mistakes that are otherwise vulnerable to
    JavaScript's dynamic typing and expressive syntax.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式指南。你选择哪个并不特别重要，但保持一致的样式有助于避免那些在其他情况下容易受到JavaScript动态类型和表达性语法影响的愚蠢错误。
- en: JavaScript's prototypal inheritance tends to feel strange to developers used
    to classical object-oriented programming. The main advantages are that it's dynamic
    (you can add new properties to prototypes and objects after they're created);
    there is no *diamond problem* (you never have ambiguities due to multiple ancestors);
    and it's simpler to just do what you want without rigid structures. We've seen
    that Three.js uses an inheritance pattern; you can also use OOP patterns in your
    code, and it helps to be aware of JavaScript's strengths in this regard instead
    of fighting with its weaknesses.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于习惯于经典面向对象编程的开发者来说，JavaScript的原型继承往往感觉有些奇怪。主要优势在于它是动态的（您可以在创建后向原型和对象添加新属性）；没有*菱形问题*（您永远不会因为多个祖先而出现歧义）；并且在没有僵化结构的情况下简单地做您想做的事情要简单得多。我们已经看到Three.js使用了一个继承模式；您也可以在代码中使用面向对象模式，了解JavaScript在这方面而不是与其弱点作斗争的优势会有所帮助。
- en: Using Grunt ([http://gruntjs.com/](http://gruntjs.com/)) is strongly recommended
    to simplify your publishing and testing workflow because it helps minimize the
    amount of time between making a change and testing it in action. Grunt is a command-line
    tool that executes predetermined tasks, so you can use it to easily perform other
    publishing steps. For example, production code should be minified, concatenated,
    and checked for syntax errors, which Grunt can do using the UglifyJS and JSHint
    projects. If your project is open source, big enough, or has enough people to
    need separate documentation, JSDuck ([https://github.com/senchalabs/jsduck](https://github.com/senchalabs/jsduck))
    is a useful tool to automatically generate it from code comments (and Grunt supports
    it too). You can find a great tutorial on getting started with Grunt at [http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/](http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈推荐使用Grunt ([http://gruntjs.com/](http://gruntjs.com/))来简化您的发布和测试工作流程，因为它有助于最小化从做出更改到在实际操作中测试它之间的时间。Grunt是一个命令行工具，执行预定义的任务，因此您可以轻松地执行其他发布步骤。例如，生产代码应该被压缩、连接，并检查语法错误，Grunt可以使用UglifyJS和JSHint项目来完成这些任务。如果您的项目是开源的、足够大，或者有足够的人需要单独的文档，JSDuck
    ([https://github.com/senchalabs/jsduck](https://github.com/senchalabs/jsduck))是一个有用的工具，可以从代码注释中自动生成它（Grunt也支持它）。您可以在[http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/](http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/)找到关于如何开始使用Grunt的精彩教程。
- en: Existing workflows and level development
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现有的工作流程和关卡开发
- en: Few changes should be needed to studios' existing game development pipelines
    in order to produce Three.js-based games. Some programmers may not even need to
    learn JavaScript if they're not already familiar with it since many languages
    compile to JavaScript. Existing processes can be maintained for testing and producing
    as well as for developing pitches, concepts, storyboards, models, textures, sounds,
    and other resources. The biggest challenge is in assembling those resources—building
    levels into Three.js scenes. There aren't amazing tools yet for designing levels
    for Three.js games that need them, partly because Three.js is a graphics library
    and games have a lot of custom requirements that are hard to generalize well for
    a single tool. Level editors tend to be tied pretty closely to the game engine
    and the classes it provides.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作基于Three.js的游戏，工作室现有的游戏开发流程可能不需要太多更改。一些程序员可能甚至不需要学习JavaScript，如果他们已经熟悉它，因为许多语言编译成JavaScript。现有的流程可以保持不变，用于测试和生成，以及开发提案、概念、分镜脚本、模型、纹理、声音和其他资源。最大的挑战在于组装这些资源——将关卡构建到Three.js场景中。目前还没有为需要它们的Three.js游戏设计关卡的优秀工具，部分原因是因为Three.js是一个图形库，而游戏有很多难以很好地为单个工具概括的自定义要求。关卡编辑器通常与游戏引擎及其提供的类紧密相关。
- en: The original Three.js author has created a scene editor that you can try at
    [http://mrdoob.github.io/three.js/editor/](http://mrdoob.github.io/three.js/editor/).
    It is useful for small projects, but quickly becomes unwieldy for big ones (especially
    when multiple people need to work on a project at the same time). Also, the scene
    editor can't handle custom objects such as spawn points, so if you use it, at
    least part of each level will need to be defined in custom code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Three.js作者创建了一个场景编辑器，您可以在[http://mrdoob.github.io/three.js/editor/](http://mrdoob.github.io/three.js/editor/)尝试使用。这对于小型项目很有用，但对于大型项目来说很快就会变得难以控制（尤其是在多人同时在一个项目上工作时）。此外，场景编辑器无法处理自定义对象，如出生点，因此如果您使用它，至少每个级别的部分将需要使用自定义代码来定义。
- en: As a result, if you need to create many levels or you need to do so visually,
    you will probably need to build your own scene layout tool. There are a few ways
    you could do this. First, the Three.js scene editor is part of the Three.js project
    (in the `editor` folder), so you could start with that and edit it. Second, you
    could try writing an exporter for an existing level development tool or a converter
    for its save files, then writing a custom Three.js loader. Third, you could try
    writing your own tool from scratch. The good news on that front is that once you've
    written one, you can use it again in other projects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你需要创建多层结构或者需要以可视化的方式创建，你可能需要构建自己的场景布局工具。你可以通过几种方式来实现这一点。首先，Three.js 场景编辑器是
    Three.js 项目的一部分（位于 `editor` 文件夹中），所以你可以从这里开始并对其进行编辑。其次，你可以尝试为现有的级别开发工具编写导出器或为其保存文件编写转换器，然后编写自定义的
    Three.js 加载器。第三，你可以尝试从头开始编写自己的工具。好消息是，一旦你编写了一个，你就可以在其他项目中再次使用它。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Clearly, writing reusable components is helpful if you''re going to build more
    than one Three.js project. Before writing your own components, you may want to
    check out two Three.js helper libraries by *Jerome Etienne*: an extension system
    called **tQuery** and a series of utilities called **THREEx**, available at [http://jeromeetienne.github.io/tquery/](http://jeromeetienne.github.io/tquery/)
    and [http://jeromeetienne.github.io/threex/](http://jeromeetienne.github.io/threex/),
    respectively.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你打算构建多个 Three.js 项目，编写可重用组件是有帮助的。在编写自己的组件之前，你可能想查看由 *Jerome Etienne* 开发的两个
    Three.js 辅助库：一个名为 **tQuery** 的扩展系统，以及一系列称为 **THREEx** 的实用工具，分别可在 [http://jeromeetienne.github.io/tquery/](http://jeromeetienne.github.io/tquery/)
    和 [http://jeromeetienne.github.io/threex/](http://jeromeetienne.github.io/threex/)
    找到。
- en: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) is a good example of a
    game engine with its own level editor. It also has a bunch of modules (including
    a multiplayer module) that you can plug in. It's designed for Minecraft-style
    games, but you might be able to use it as a starting point for other large-scale
    projects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) 是一个拥有自己级别编辑器的游戏引擎的好例子。它还包含许多模块（包括一个多人模块），你可以将其插入。它专为类似
    Minecraft 的游戏设计，但你可能也能将其作为其他大型项目的起点。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about designing and developing high-quality games
    for the Web. We covered aspects of game design and development that are unique
    to the Web, and how Three.js supports them; important performance considerations;
    and basic client-server and lock-step networking.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了设计和开发高质量网页游戏。我们涵盖了游戏设计和开发中独特的网络方面，以及 Three.js 如何支持这些方面；重要的性能考虑因素；以及基本的客户端-服务器和同步网络。
- en: You are now prepared to embrace the next generation of gaming. Congratulations!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经准备好拥抱下一代游戏了。恭喜你！
