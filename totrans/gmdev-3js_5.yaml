- en: Chapter 5. Design and Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While other chapters have focused on the Three.js API and how to use it to build
    games, this chapter discusses how to make *good* games using Three.js and the
    Web as a platform. We'll use what we've learned so far as a foundation to explore
    game design concepts and development processes, investigate performance considerations,
    and introduce JavaScript-based game networking.
  prefs: []
  type: TYPE_NORMAL
- en: Game design for the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building games based on WebGL that match or exceed console quality should be
    possible, and doing so is a worthy goal. Additionally, building games for the
    Web presents an opportunity to take advantage of features that aren't possible
    for desktop and console games, although there are also a few drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can build mechanics around having game data in URLs. Beyond
    just indicating save/load points, URLs could encode pickups, locations, random
    seeds, or other information. Add sharing to the mix and suddenly you have the
    ability for users to e-mail or tweet a link to their friends and have them drop
    instantly into the same point in your game. Unlike console games, web games can
    build on viral dynamics, the ubiquity of browsers, and low barriers to entry to
    attract more users and introduce new gameplay. You might imagine collaborative
    puzzle games that require a certain number of players to be completed—a concept
    that wouldn't be reliable for an expensive console game.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, gamers who buy an expensive console game are probably more
    likely to put in some effort to get over an initial learning curve. Unless users
    pay for your game up front, it's important to be conscious of the fact that users
    can leave your game just as easily as they arrived. Gaming has always been about
    balancing difficulty with engagement; it's the same formula, but it's more important
    than ever to consider the amount of time between hitting your landing page and
    that first taste of sweet satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Web-based games also benefit from a strong tradition of APIs and integrations.
    Of course console games can also use APIs, but by definition, web-based games
    can typically rely on players having an Internet connection, so you can imagine
    gameplay elements such as imagery from Google Earth, location names and tips based
    on Foursquare data, and AI characters who actively use social networks. In particular,
    you can easily integrate payment processing into your games, perhaps even superimposed
    over a cash register or ATM, and reasonably expect that many users will have access
    to a keyboard that will let them type in their credit card information more easily
    than they could with a joystick. This opens the door to non-traditional payment
    methods that don't require charging up-front for games, more akin to the way mobile
    games often make money from in-app sales.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, webcam and microphone access is growing rapidly among laptop users,
    and Chrome and Firefox now support these peripherals with the WebRTC API. Potential
    uses of this technology go beyond simple chatting. Ambient sound could be detected
    and used to adjust the tempo of game music. With some machine vision or perhaps
    a Leap Motion device, users could interact directly with the game by waving their
    hands instead of manipulating a mouse. Imagine a game of Roller Coaster Tycoon
    where you could literally pick up visitors and fling them to the other side of
    your park! There are lots of other cool uses for machine vision as well. *John
    Carmack* (lead programmer of Doom and Quake among other iconic games) recently
    suggested running garbage collection when the user blinks. Research at MIT has
    shown that webcam video can be used to accurately identify visitors' heart rates,
    which could allow games to adjust their pace to match (or compensate for) users'
    excitement ([http://people.csail.mit.edu/mrub/vidmag/](http://people.csail.mit.edu/mrub/vidmag/)).
    And hand-tracking technology is already being used for 3D modeling, game development,
    and even rocket design.
  prefs: []
  type: TYPE_NORMAL
- en: Other external devices such as the Oculus Rift augmented reality headset can
    be supported for deeper integration into your environment. (Three.js actually
    includes a controller for the Oculus Rift in the `examples/js/controls` folder).
    For example, mobile phones can be used as controllers for web games as described
    at [http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game](http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game)
    and [http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/](http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/).
    Experimental support for traditional USB game controllers exists in some browsers
    as well; one library to help with that is available at [http://www.gamepadjs.com/](http://www.gamepadjs.com/).
    Phones and tablets could even be used as an additional screen—perhaps for a minimap,
    inventory list, or rearview mirror.
  prefs: []
  type: TYPE_NORMAL
- en: That said, because the Web is universally available, consider what devices may
    be accessing your game and what constraints they may have. Varied screen sizes
    and resolutions are nothing new, but touch controls in particular can present
    challenges for 3D games. Still, applying traditional web development techniques
    to games can yield creative solutions. For instance, taking the approach of graceful
    degradation / progressive enhancement, mobile users could be delivered a spectator
    view or some other reduced version of the game. Alternatively, you could provide
    onscreen controls when keyboards and mice aren't available, perhaps with the HTML5
    Virtual Game Controller library ([https://github.com/austinhallock/html5-virtual-game-controller](https://github.com/austinhallock/html5-virtual-game-controller)).
  prefs: []
  type: TYPE_NORMAL
- en: 'One final point to think about: Three.js-driven games can integrate smoothly
    with existing websites. For example, most games need menus, and it''s much easier
    to create them in HTML than in 3D. Don''t feel like your entire application needs
    to display exclusively on the canvas. On the other hand, if you want to get creative,
    you can actually embed HTML inside your Three.js environment. You can read more
    about how to do this at [http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/](http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/)
    and [http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/](http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/).'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some ways, performance considerations for 3D games in browsers are pretty
    similar to those for consoles and desktop games. The biggest difference is that
    all resources must (at least initially) be streamed to the client instead of read
    from a disk. For complex 3D games with gigabytes of assets, overcoming this limitation
    for low-bandwidth clients can be a serious challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As legendary programmer *Donald Knuth* wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Premature optimization is the root of all evil."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section discusses best practices and suggestions to get great performance
    out of your game, but before expending significant effort, you should measure
    and test your application to see where the bottlenecks are and whether the effort
    is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth/network constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To combat bandwidth constraints, the first thing you should do is apply traditional
    optimizations which web developers have been using for years: compress the content
    your server sends with `gzip`, combine and minify JavaScript to minimize the number
    of requests the browser has to make to the server, optimize your images, enable
    the Keep-Alive header, serve assets from a limited number of domains, and use
    headers to leverage browser caching, among other techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Optimizing websites in general is a particularly detailed topic, but this section
    mostly sticks to explaining optimizations specifically for games. If you are interested
    in learning more about **Web Performance Optimization** (**WPO**), start with
    these rules from Google and Yahoo!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/speed/docs/best-practices/rules_intro](https://developers.google.com/speed/docs/best-practices/rules_intro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://developer.yahoo.com/performance/rules.html](http://developer.yahoo.com/performance/rules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, complex games won't be able to rely on browser caching for user return
    visits because browsers have limits on the maximum amount of memory cached resources
    can consume across all websites. Your game's resources will be pushed out of the
    cache as the user navigates other websites, and the cache size may be too small
    for all your resources anyway. As a result, the next place to look for optimizations
    is caching inside of your game in order to minimize the number of server requests
    that need to be made. This can be done in three ways. First, you can store resources
    in other caches. The IndexedDB API ([https://developer.mozilla.org/en-US/docs/IndexedDB](https://developer.mozilla.org/en-US/docs/IndexedDB))
    supports storing files, and the Web Storage API ([https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage))
    supports storing strings (including JSON, so you can store exported Three.js objects).
    Chrome also supports the FileSystem API ([http://www.html5rocks.com/en/tutorials/file/filesystem/](http://www.html5rocks.com/en/tutorials/file/filesystem/))
    which can manage a sandboxed local filesystem. Second, you can reduce the total
    number of resources you need by generating some of them on the client. For example,
    if you need similar textures in different colors, it might make sense to modify
    those textures dynamically on the client rather than ask the server for multiple
    images. Or, if you can describe the way a mesh should animate with a system of
    equations, you might consider manually animating it on the client instead of sending
    animation data. Third, you can make sure your code is structured in a way that
    allows reusing resources instead of requesting them repeatedly. For example, if
    two meshes use the same texture, you should try to load the texture once instead
    of twice.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use a binary format for imported meshes that has a higher compression
    ratio than standard text-based files in order to reduce the size of assets the
    server needs to send to the client. To do so, you should export your meshes to
    Wavefront OBJ / MTL files, and then use the converter script at `utils/converters/obj/convert_obj_three.py`
    to generate a file that the `THREE.BinaryLoader` can import. (Instructions for
    running the script are at the top of the file.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reducing the total size of resources that need to be retrieved
    from a server, you can try to load as much data as possible while the user doesn't
    need to see it. For example, if players enter your game from a menu, you may be
    able to start loading while the player is navigating the menu rather than waiting
    until they click to start the game. You can also wait to load parts of your scene
    that won't be visible initially until after the player has entered the game, in
    order to let the player start playing as quickly as possible. For example, linear
    mission-based games can wait to load parts of the map until the player reaches
    certain checkpoints. Just make sure you have a fallback plan if resources are
    loading slowly and the player reaches your unloaded area too early. You might
    want to have a door that won't open until the resources are loaded. You could
    also just pause the game momentarily when the player is in a transitional location.
  prefs: []
  type: TYPE_NORMAL
- en: Level of detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, you can load low-poly meshes and low-resolution textures when the
    user starts playing the game and replace them with higher-detail assets during
    gameplay, either when the larger assets are loaded or when the user gets close
    enough to them to see the improved detail. The latter technique is called **Level-of-Detail**
    (**LOD**), and Three.js has built-in support for it using the `THREE.LOD` object.
    For example, we could modify the spinning shape example we built in [Chapter 1](ch01.html
    "Chapter 1. Hello, Three.js"), *Hello, Three.js*, to change the detail of our
    sphere depending on how close to it we are. First we need to change how we add
    the mesh to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LOD` object stores objects of different complexities along with the distances
    at which higher-detail versions should be used. To make the mesh change detail
    when the camera moves closer or farther away, we''ll update the `LOD` object in
    the animation loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a little bit of movement here so that we can see the detail change.
    Let''s move the camera so that we can see the movement better by setting `camera.position.z
    = 3000`. Now you should be able to see the detail change dynamically, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Level of detail](img/8539_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A sphere with increasing detail as the camera gets closer
  prefs: []
  type: TYPE_NORMAL
- en: Rendering optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js has built-in support for other detail-related optimizations as well
    in order to make processing faster. **Culling**, the process of excluding hidden
    objects from rendering, is a common example. Three.js does **view frustum culling**
    based on bounding spheres, meaning it will avoid spending valuable compute time
    calculating visual information about objects that are off screen. It also does
    **backface culling** by default, which hides the back side of mesh faces. However,
    it doesn't do **occlusion culling**, meaning it doesn't know not to render an
    object that is in front of the camera but obscured by another object that is closer
    to the camera. The implication of these optimizations is that large meshes should
    often be split into several smaller ones to reduce computation if only part of
    the large mesh is on the screen, and you don't get any benefits by default from
    having short viewable distances. This simple change might be sufficient for top-down
    games where few objects are obscured by other objects. Other games, such as first-person
    shooters where buildings or terrain can block long view distances, may need to
    compensate in other ways. For example, if you have really large or detailed worlds,
    you may want to work on manual occlusion culling. Game engines typically do this
    using a technique called **depth testing**, but a simpler approach that can work
    for enclosed layouts (such as the insides of buildings) is to create invisible
    cubes encompassing different zones in the world based on view distances and then
    toggle the visibility of meshes inside those zones when the player gets close
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already discussed the advantages of merging geometry in [Chapter 2](ch02.html
    "Chapter 2. Building a World"), *Building a World*, but you can get additional
    performance benefit out of transforming static geometry into `BufferGeometry`.
    `BufferGeometry` typically renders faster than standard `Geometry` because it
    uses a data structure that is closer to what will get passed to the GPU instead
    of one that is easy for humans to understand. As a result, it is harder to manipulate,
    but it works well if you know your geometry won''t change. The easiest way to
    use `BufferGeometry` is to convert from existing `Geometry` using the utility
    in `examples/js/BufferGeometryUtils.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can use the result with meshes the same way you would use normal geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another powerful optimization is changing the resolution of the canvas. Assuming
    `renderer` and `camera` are globals, you can use this function to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can use this function by calling `resize(0.5)`, for example, which will
    allow the renderer to paint only `0.5*0.5 = 25%` of the pixels it would paint
    at full resolution, even though the canvas will take up the same amount of space
    on the screen. (The `scale` parameter is always relative to the canvas' original
    size.) This works because canvases are basically just images. In the same way
    that you can style an image to be larger in CSS without changing its actual size,
    you can style a canvas to be larger too. In our `resize` function, we first reduce
    the actual size of the canvas by changing its `width` and `height` attributes,
    then scale it back up using the CSS width and height styles. The result is that
    the canvas takes up the same amount of screen space that it did originally, but
    each actual pixel is displayed larger. This significantly reduces the amount of
    computation required to render a scene, although the scene will be blurrier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Changing the resolution of the canvas affects how you need to compute where
    the user clicks. You should track the canvas'' current scale and adjust the screen-space
    vector in our click method from [Chapter 3](ch03.html "Chapter 3. Exploring and
    Interacting"), *Exploring and Interacting*, accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Techniques that compromise visual detail in favor of speed are especially useful
    when combined with frame-rate testing. If the frame rate dips below a certain
    threshold for more than a given percent of the time in a certain testing period,
    you may want to reduce your game's detail. (You should figure out what your bottleneck
    is before implementing this approach. If your frame rates are low because your
    physics loop takes a long time to run, reducing visual detail may not help much.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If physics is your bottleneck, you can run your physics at a lower frame rate
    than your rendering as discussed in [Chapter 3](ch03.html "Chapter 3. Exploring
    and Interacting"), *Exploring and Interacting*. You may also want to consider
    using the Web Worker API ([https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers))
    to execute JavaScript code in parallel. This can allow calculating movement and
    collision without blocking the rendering. The Physi.js library introduced in [Chapter
    3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and Interacting*,
    does this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Battery life and GPU memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although bandwidth/network speed and processing time are the factors that usually
    affect the performance of Three.js games the most, battery life and memory constraints
    may also come into play. For hardcore games, you may be able to assume the user
    is plugged in, but more casual games should be aware that more processing typically
    equates to more battery drain. On the memory front, the question is less about
    storage space and more about the graphics card having a limited amount of embedded
    memory with which it can perform fast computations. The main thing you can do
    to limit how much of the GPU''s onboard memory you consume is to use compressed
    textures. (Normally, images such as JPGs and PNGs are decompressed before being
    sent to the GPU, but compressed textures use a special format that allows the
    GPU to hold them in embedded memory in a compressed state. Since the compression
    only matters for the GPU, it doesn''t actually save network bandwidth.) Three.js
    supports compressed textures in DDS format. You can import DDS textures into Three.js
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `texture` value can be treated the same way normal images are
    treated; you can use it as the value for the `map` property of materials, for
    example, and Three.js will automatically know how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create DDS images, you can use a plugin for Gimp ([https://code.google.com/p/gimp-dds/](https://code.google.com/p/gimp-dds/))
    or Photoshop ([https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop](https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop)).
  prefs: []
  type: TYPE_NORMAL
- en: Performance-measuring tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, there are a number of useful tools for measuring JavaScript performance.
    Conveniently, the original author of Three.js has written a library called Stats.js
    ([https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js)) for
    tracking frame rates, the most crucial performance statistic for games. For comprehensive
    tracing, Google's Web Tracing Framework ([http://google.github.io/tracing-framework/index.html](http://google.github.io/tracing-framework/index.html))
    is hard to beat, and it even has an example for tracing a WebGL game. You can
    also easily get some statistics about onscreen geometry with the RenderStats library
    from *Jerome Etienne* ([https://github.com/jeromeetienne/threex.rendererstats](https://github.com/jeromeetienne/threex.rendererstats)).
  prefs: []
  type: TYPE_NORMAL
- en: For brute-force debugging, you may also want to try the console-extras library,
    which makes it easier to log information about things that happen in the main
    game loop without dumping thousands of messages ([https://github.com/unconed/console-extras.js](https://github.com/unconed/console-extras.js)).
  prefs: []
  type: TYPE_NORMAL
- en: Networking and multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game networking is hard because the goal of networking is to keep game state
    in sync across multiple devices, but network latency prevents devices from communicating
    fast enough to keep that state from being occasionally inconsistent. Additionally,
    floating point rounding errors create indeterminate results across devices for
    the same set of input (this is where the timing and movement techniques discussed
    in [Chapter 3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and
    Interacting* come into play, since small differences in precision can result in
    huge differences over time). As a result, networking code becomes a process of
    reconciling differences.
  prefs: []
  type: TYPE_NORMAL
- en: There are basically two different approaches to networking depending on the
    requirements of the game. RTS and turn-based games usually use an approach called
    **lock-step**, which is a peer-to-peer model in which each computer in a match
    sends its commands to all the other computers in the match. The main strength
    of this model is that only a small amount of data (the players' commands) needs
    to be sent over the network, so it is useful when the game state is huge (for
    example, when there are thousands of units in a map). However, running a game
    in lock-step depends on all players having an identical copy of the game state,
    which is a great idea in theory but is difficult to maintain for several reasons.
    First, although the JavaScript specification states that floating point calculations
    should be deterministic, in practice there may be subtle differences across implementations
    that could prevent clients from being in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Second, all clients will see the game run at the speed of the most-latent client
    because commands from each player must be collected before advancing in order
    to ensure synchronicity. As a result, extra precautions must be taken to keep
    clients from cheating by pretending to have higher latency and waiting for the
    other computers' commands before making a decision. The latency issue also creates
    trouble when one machine is taking a particularly long time to return a command.
    In such a situation, the game may have to drop that player. Since the reason for
    using lock-step is that the entire game state is too large to transfer over the
    network while maintaining synchronicity, it may not be feasible for a player to
    join (or re-join) after a game has already started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other approach to game networking is a client-server prediction model ,
    which usually works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The client triggers some input (such as pressing a key or moving the mouse)
    that changes the game state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client input is sent to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, the server forwards the input to the other clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server processes the inputs it receives from all players, reconciles them,
    and produces a new, authoritative description of the game's state at a specific
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the server forwarded other clients' inputs, the clients receive those inputs
    and continue updating the local game state by predicting what the server thinks
    the state should be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server periodically sends the latest complete description of the authoritative
    game state to each client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client adjusts its state to sync with the server's official state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main difference here compared to lock-step is that clients can advance the
    game independently, and the entire game state can be sent from the server to ensure
    each player sees something pretty close to what the others see. This is a better
    model for action games like FPSs or games with many players like MMOs because
    players generally experience less dramatic latency effects.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the lag that gamers can feel, we design the client-server communication
    to be asynchronous because waiting for the new game state from the server can
    take a long time due to network latency. Since we try to keep running the game
    locally while we wait for the server, we need to adjust the client when we do
    finally get an authoritative update from the server. Adjusting the client can
    be tricky, though. First of all, by the time we get a response from the server,
    the state it sends us will be in the past. To deal with this, we'll need to keep
    track of all player input since the last time we got an official server update,
    rewind the game to the newly received authoritative game state, and then replay
    any more recent input on top of that. The result will be our latest guess of what
    the server thinks the game state should be at the current time, which will likely
    be slightly different than what we've actually been showing the player. We could
    just snap the current game state to our ideal game state, but that would make
    the game seem jittery since things might spontaneously teleport. Instead, if the
    differences between states are small enough, clients should interpolate between
    their current state and their projected ideal state. If we drift too far away,
    we can snap back to the server state, but otherwise we'll lag a few frames in
    order to ensure smoothness. Snapping happens most often with complex physics interactions
    or when players collide.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd like to just send players' inputs to the clients because they're
    smaller than the full game state (so they take up fewer network packets). This
    might be the only sane way to handle MMO games with potentially thousands of players.
    However, this can cause drifting over time due to floating point rounding error,
    so it may not be accurate enough to be the only solution for intense action games
    like first-person shooters. As a compromise, inputs can be sent frequently and
    the full game state sent only periodically; then clients can use the inputs to
    predict how the game should progress.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not all physics is driven by user input. If your game has gameplay-affecting
    nature-driven physics such as wind or avalanches, you may need to have the server
    simulate the physics without client prediction, and clients will just have to
    deal with some latency. On the other hand, you can simulate some physics entirely
    on the client. For example, it doesn't really matter if the clouds in the sky
    are in exactly the same position on each client since they're typically just decorative.
  prefs: []
  type: TYPE_NORMAL
- en: The game state tracked by the server usually includes, at a minimum, the position
    and velocity of all movable actors, a unique identifier for the version of the
    state, and a timestamp. The server does not need to send a full scene export to
    every client since that would be too expensive. However, the server does need
    to simulate the full scene in order to accurately update the game state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on lock-step, check out [http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/](http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/)
    and [http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/](http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about client-server prediction, check out [http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/](http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/).
  prefs: []
  type: TYPE_NORMAL
- en: To learn about interpolating between authoritative and client states, see [http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914](http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914).
  prefs: []
  type: TYPE_NORMAL
- en: There is a great Google Tech Talk by *Rob Hawkes* on HTML5 multiplayer game
    development with many tips about overcoming common pitfalls. You can watch it
    at [https://www.youtube.com/watch?v=zj1qTrpuXJ8](https://www.youtube.com/watch?v=zj1qTrpuXJ8).
  prefs: []
  type: TYPE_NORMAL
- en: Technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Web Sockets API ([https://developer.mozilla.org/en-US/docs/WebSockets](https://developer.mozilla.org/en-US/docs/WebSockets))
    is the most practical way to maintain a fast connection with a game server in
    JavaScript, and the easiest way to use web sockets is to use node.js ([http://nodejs.org/](http://nodejs.org/))
    on the server with the socket.io library ([http://socket.io/](http://socket.io/)).
    Node.js allows JavaScript to be a first-class server-side language, so you can
    write your game code once and worry less about differences between the server-side
    and client-side simulations. It's also mentally easier to write both the server-side
    and client-side code in a single language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web sockets are the best we can do at the moment because JavaScript doesn't
    have as much control over how it accesses the Internet as desktop and console
    games do, for security reasons. Web sockets are actually reasonably good, but
    they are based on **TCP**, which is a common way to access the Internet that ensures
    reliability but occasionally causes delays. Many desktop and console games that
    use client-server prediction use **UDP** to access the Internet instead, which
    serves the same purpose as TCP but compromises data-integrity guarantees in favor
    of minimal delays.
  prefs: []
  type: TYPE_NORMAL
- en: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) is a good example of a
    networked game framework using Three.js. If you are building a Minecraft-style
    game, it is a great place to start. For more information and code examples on
    writing game networking code in JavaScript with Socket.io and Node.js, there is
    a good article at [http://buildnewgames.com/real-time-multiplayer/](http://buildnewgames.com/real-time-multiplayer/).
    It uses a 2D game as an example, but everything applies cleanly to 3D games as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Anticheating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stopping cheaters in multiplayer games is a hard problem in general, and it''s
    particularly difficult in JavaScript for three reasons. One, it''s very difficult
    to detect whether client input is automated or their display has changed illegally;
    two, JavaScript code is relatively hard to obfuscate and validate without significant
    performance penalties; and three, cheating programs can directly and easily override
    your client code. As a result, anticheating efforts typically focus on moving
    as much logic as possible from the client to the server, detecting unusual patterns
    of client activity, minimizing the benefits of cheating, and perhaps creating
    just enough annoying barriers to cheating that some aspiring cheaters give up.
    Common methods include:'
  prefs: []
  type: TYPE_NORMAL
- en: Only letting the client send whitelisted inputs to the server, not arbitrary
    values; this allows a trusted computer (the server) to do important calculations
    and avoids letting cheaters make illegal requests such as `addPoints(1000000)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking how long the user plays the game; if a user plays for 48 hours straight,
    they're worth investigating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the amount of time that passes between user actions; if a user clicks
    on the same part of the screen every 10 minutes (suspiciously accurate) or 16
    milliseconds (suspiciously fast), they might be automating their behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting snapping, the behavior in first-person shooters of instantly turning
    to shoot at a target as soon as there is nothing in the way, even when that target
    wasn't onscreen, and never missing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making debugging harder, for example by disabling console logging (`console
    = {}`) and wrapping your entire client-side code in a closure to prevent any global
    variables from being easily available to cheaters' scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it easy for users to report abuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is certainly not an exhaustive list, and it's very difficult to stop cheaters
    entirely, but these suggestions are a reasonable place to start.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's generally considered poor form to prevent client-side cheating in single-player
    modes, except when it comes to artifacts that other players can see, such as high
    scores.
  prefs: []
  type: TYPE_NORMAL
- en: Development processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you're an individual who builds games as a hobby or a developer for
    a large game publisher, you can benefit from following a number of best practices
    adopted from JavaScript development for the Web and game development on other
    platforms. You can also build Three.js-based games without deviating too far from
    your favorite game development processes.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, we haven''t been very concerned with the high-level structure
    of our code. We wrote some examples as single HTML files, and we split the FPS
    and CTF projects into separate files, but for polished games we should be more
    careful, especially when working with teams. General coding lessons apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep assets in folders by file type/purpose. For example, at a high level you
    might have folders such as `css`, `js`, `images`, `models`, and `sounds`. Within
    the `js` folder, organize JavaScript files by purpose; keep library, source, and
    production code separate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid putting code that directly handles user input event listeners in class
    constructors, because that makes them harder to reuse and extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use separate files for configuration/constants that you can fiddle with to adjust
    how the game *feels*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect features instead of browsers, since different browser versions support
    different features and some features can be toggled on or off in browser settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using `setTimeout` and `setInterval` for timers in the animation loop
    because having a lot of separate timers can cause performance issues. Instead,
    check how much time has passed in your animation loop, for example, using `Date.now()`
    or `THREE.Clock`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If your game can pause, make sure you're not including time elapsed while paused.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Though it may feel natural to write the entire application in JavaScript, try
    to avoid creating new DOM in JavaScript. Doing so is slow, and there's a reason
    HTML and CSS exist. (Also, don't be afraid to use HTML and CSS; sometimes that's
    a much easier solution than, say, writing a custom shader.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a style guide. Which one you choose is not especially important, but maintaining
    a consistent style helps avoid silly mistakes that are otherwise vulnerable to
    JavaScript's dynamic typing and expressive syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript's prototypal inheritance tends to feel strange to developers used
    to classical object-oriented programming. The main advantages are that it's dynamic
    (you can add new properties to prototypes and objects after they're created);
    there is no *diamond problem* (you never have ambiguities due to multiple ancestors);
    and it's simpler to just do what you want without rigid structures. We've seen
    that Three.js uses an inheritance pattern; you can also use OOP patterns in your
    code, and it helps to be aware of JavaScript's strengths in this regard instead
    of fighting with its weaknesses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Grunt ([http://gruntjs.com/](http://gruntjs.com/)) is strongly recommended
    to simplify your publishing and testing workflow because it helps minimize the
    amount of time between making a change and testing it in action. Grunt is a command-line
    tool that executes predetermined tasks, so you can use it to easily perform other
    publishing steps. For example, production code should be minified, concatenated,
    and checked for syntax errors, which Grunt can do using the UglifyJS and JSHint
    projects. If your project is open source, big enough, or has enough people to
    need separate documentation, JSDuck ([https://github.com/senchalabs/jsduck](https://github.com/senchalabs/jsduck))
    is a useful tool to automatically generate it from code comments (and Grunt supports
    it too). You can find a great tutorial on getting started with Grunt at [http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/](http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/).
  prefs: []
  type: TYPE_NORMAL
- en: Existing workflows and level development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Few changes should be needed to studios' existing game development pipelines
    in order to produce Three.js-based games. Some programmers may not even need to
    learn JavaScript if they're not already familiar with it since many languages
    compile to JavaScript. Existing processes can be maintained for testing and producing
    as well as for developing pitches, concepts, storyboards, models, textures, sounds,
    and other resources. The biggest challenge is in assembling those resources—building
    levels into Three.js scenes. There aren't amazing tools yet for designing levels
    for Three.js games that need them, partly because Three.js is a graphics library
    and games have a lot of custom requirements that are hard to generalize well for
    a single tool. Level editors tend to be tied pretty closely to the game engine
    and the classes it provides.
  prefs: []
  type: TYPE_NORMAL
- en: The original Three.js author has created a scene editor that you can try at
    [http://mrdoob.github.io/three.js/editor/](http://mrdoob.github.io/three.js/editor/).
    It is useful for small projects, but quickly becomes unwieldy for big ones (especially
    when multiple people need to work on a project at the same time). Also, the scene
    editor can't handle custom objects such as spawn points, so if you use it, at
    least part of each level will need to be defined in custom code.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, if you need to create many levels or you need to do so visually,
    you will probably need to build your own scene layout tool. There are a few ways
    you could do this. First, the Three.js scene editor is part of the Three.js project
    (in the `editor` folder), so you could start with that and edit it. Second, you
    could try writing an exporter for an existing level development tool or a converter
    for its save files, then writing a custom Three.js loader. Third, you could try
    writing your own tool from scratch. The good news on that front is that once you've
    written one, you can use it again in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clearly, writing reusable components is helpful if you''re going to build more
    than one Three.js project. Before writing your own components, you may want to
    check out two Three.js helper libraries by *Jerome Etienne*: an extension system
    called **tQuery** and a series of utilities called **THREEx**, available at [http://jeromeetienne.github.io/tquery/](http://jeromeetienne.github.io/tquery/)
    and [http://jeromeetienne.github.io/threex/](http://jeromeetienne.github.io/threex/),
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Voxel.js ([http://voxeljs.com/](http://voxeljs.com/)) is a good example of a
    game engine with its own level editor. It also has a bunch of modules (including
    a multiplayer module) that you can plug in. It's designed for Minecraft-style
    games, but you might be able to use it as a starting point for other large-scale
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about designing and developing high-quality games
    for the Web. We covered aspects of game design and development that are unique
    to the Web, and how Three.js supports them; important performance considerations;
    and basic client-server and lock-step networking.
  prefs: []
  type: TYPE_NORMAL
- en: You are now prepared to embrace the next generation of gaming. Congratulations!
  prefs: []
  type: TYPE_NORMAL
