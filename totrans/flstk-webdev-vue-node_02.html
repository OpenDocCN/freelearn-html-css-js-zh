<html><head></head><body>
        

                            
                    <h1 class="header-title">Building an Express Application</h1>
                
            
            
                
<p>Express.js is a Node.js web application framework. Express.js makes it easier to use Node.js and leverages its power. In this chapter, we will be creating an application using solely Express.js. Express.js is also a <kbd>node</kbd> package. We can use an application generator tool, which lets us create a skeleton of an express app easily, or we can simply create one ourselves from scratch.</p>
<p>In the previous chapter, we learned about what <kbd>npm</kbd> is, what a package is, and how to install a package.  In this chapter, we will cover the following elements:</p>
<ul>
<li>What Node.js is and what it can do</li>
<li>The benefits it adds</li>
<li>The basic programming of Node.js</li>
<li>Node.js core and custom modules</li>
<li>An introduction to Express.js</li>
<li>Creation of an application using Express.js</li>
<li>Routes in Express.js</li>
<li>MVC architecture: what it is and what value it adds when implemented in an application</li>
<li>File naming conventions for the application</li>
<li>Folder reorganization to incorporate MVC</li>
<li>View creation for the Express.js application</li>
</ul>
<p>There are a lot of <kbd>npm</kbd> packages out there that can let us create a skeleton for an Express.js application. One such package is <kbd>express-generator</kbd>. This lets us scaffold the whole application in seconds. It will create all the necessary files and folders in a modular structure. It generates the file structures in such a way that is very easy to understand. The only thing that we need to do is to define the template views and the routes. </p>
<p>We can modify this structure as per our needs and requirements as well. This is very handy when we are on a tight deadline and want to build an application in a day or so. The process is extremely simple.</p>
<div><kbd>express-generator</kbd> is only one of many tools that are available to create a scaffold or a modular structure of an express application. Each generator tool may have its own way of building the file structure as per their standard which can be easily customized.</div>
<p>If you are a beginner and want to understand how the folder structure works, I recommend you build the application from scratch. We will be discussing this further in this chapter.</p>
<p>To get started, first we need to learn more about Node.js before diving into Express.js.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to Node.js</h1>
                
            
            
                
<p>Node.js is a JavaScript runtime build on a JavaScript engine. It is an open source framework used for server-side management. Node.js is lightweight and efficient and runs on various platforms, such as Windows, Linux, and macOS.</p>
<p>Node.js was created by Ryan Dahl in 2009. JavaScript used to be used mostly for client-side scripting, but Node.js enables JavaScript to be used on the server side as well. The invention of Node.js introduced the use of a single programming language in web applications. Node.js brings with it a lot of benefits, some of which are as follows:</p>
<ul>
<li><strong>Event-driven programming</strong>: It means changing the state of an object from one to another. Node.js uses event-driven programming, which means it uses a user's interactive actions, such as mouse clicks, and key presses, to change the state of objects.</li>
<li><strong>Non-blocking I/O</strong>: The non-blocking I/O, or non-synchronous I/O, means an asynchronous I/O. A synchronous process waits until the current running process is completed and, hence, blocks the process. On the other hand, the asynchronous process does not need to wait for that process to finish, which makes it fast and reliable as well.</li>
<li><strong>Single threading</strong>: Single threading means that JavaScript runs in only a single event loop. Since an asynchronous process allows us to have multiple processes concurrently, it may seem like all these processes run in their own specific thread. But Node.js handles asynchronous a little differently. The event loop in Node.js triggers the next callback function that is scheduled for execution after the corresponding event has occurred.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Node.js</h1>
                
            
            
                
<p>Before diving into Node.js programming, let's first look into some fundamentals of Node.js. Node.js runs on the JavaScript V8 engine. The JavaScript V8 engine was built by <em>The Chromium Project</em> for Google Chrome and Chromium web browsers. It is an open source project written in C++. This engine is used for both client- and server-side web applications with JavaScript. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js programming</h1>
                
            
            
                
<p>Let's start by running a <kbd>node</kbd> process. Open the Terminal and type this command:</p>
<pre><strong>$ node</strong></pre>
<p>This will start a new <kbd>node</kbd> process. We can write normal JavaScript here.</p>
<p>So, for example, we can write in the new Node shell the following JavaScript command:</p>
<pre><strong>&gt; var a = 1;</strong></pre>
<p>It returns <kbd>1</kbd> when we type <kbd>a</kbd> and press enter. </p>
<p>We can also run a file with the <kbd>.js</kbd> extension in a <kbd>node</kbd> process. Let's create a folder called <kbd>tutorial</kbd> in the root directory with the command <kbd>mkdir tutorial</kbd> and create a file inside it called <kbd>tutorial.js</kbd>.</p>
<p>Now, in the Terminal, let's go into that directory with the following command:</p>
<pre><strong>$ cd tutorial<br/></strong><strong>$ node tutorial.js</strong></pre>
<p>We should see something similar to the following:</p>
<div><img src="img/db7d6f63-3df3-4fd9-842e-fc4f6177ef4b.png" style="width:27.83em;height:3.67em;"/></div>
<p>This does not return anything because we haven't written anything for <kbd>tutorial.js</kbd> yet.</p>
<p>Now, let's add some code to the <kbd>tutorial.js</kbd>:</p>
<pre><strong>console.log('Hello World');</strong></pre>
<p>Now, run the file with this command:</p>
<pre><strong>$ node tutorial.js</strong></pre>
<p>We will see an output that says <kbd>Hello World</kbd>. This is how we execute files in Node.js.</p>
<p>Other than running on the V8 engine and executing JavaScript codes in a web browser, Node.js also provides a server running environment. This is the most powerful feature of Node.js. Node.js provides an HTTP module of itself that enables a non-blocking HTTP implementation. Let's build a simple web server to understand this.</p>
<p>On the same file, in <kbd>tutorial.js</kbd>, overwrite the file with the following code:</p>
<div><div><pre class="programlisting"><strong>const http = require('http');</strong><br/><br/><strong>http.createServer(function (req, res) {</strong><br/><strong>  res.writeHead(200, { 'Content-Type': 'text/plain' });</strong><br/><strong>  res.end('Hello World\n');</strong><br/><strong>}).listen(8080, '127.0.0.1');</strong><br/><br/><strong>console.log('Server running at http://127.0.0.1:8080/');</strong></pre></div>
</div>
<p>Here, the  <kbd>var http = require('http');</kbd> code requires the HTTP module into our application. It means that now we can access the functions defined in the HTTP library via the <kbd>http</kbd> variable. Now we need to create a web server. The preceding code tells Node.js to run the web server in the 8080 port. The <kbd>function</kbd> parameter in the <kbd>createServer</kbd> method takes two arguments, <kbd>req</kbd> and <kbd>res</kbd>, which are the short form of request and response respectively. The first thing that we need to do inside that function is to set the HTTP header. This is basically defining what type of response we want from that request. Then, we define what we want to get in the response by using <kbd>res.send</kbd>. Finally, we ask the web server to listen to port 8080. </p>
<p>When we run this code with <kbd>$ node tutorial.js</kbd>, the output looks like this:</p>
<div><img src="img/154a4a5f-59e2-4837-b2c7-7962c1eb24ed.png" style="width:25.50em;height:4.42em;"/></div>
<p>When we type that URL in our browser, we should be able to see this:</p>
<div><img src="img/d553340f-ee2f-4961-af8b-28c4b6269826.png"/></div>
<p>That's how Node.js works as a server program.</p>
<p>To exit the <kbd>node</kbd> console, press <em>Ctrl</em> <em>+</em> <em>C</em> twice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js modules</h1>
                
            
            
                
<p>A Node.js module is just a plain JavaScript file that consists of reusable code. Every module has its own specific functionality. We can think of it as a library.</p>
<p>For example, if we want to segregate all our user-related activities in our application, we create a module for it, which will handle all the data libraries about the users.</p>
<p>The way we use a module in Node.js is via <kbd>require</kbd>. The example we just showed you about creating a web server is also a Node.js module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Node.js core modules</h1>
                
            
            
                
<p>There are two types of modules in Node.js. The core modules are the modules that are built in Node.js. They come in while we install Node.js. These are also called built-in modules. There are a lot of core modules in Node.js:</p>
<ul>
<li>Debugger</li>
<li>Filesystem</li>
<li>HTTP</li>
<li>Path</li>
<li>Process</li>
<li>Events</li>
</ul>
<p>If you want to look into more details about each of the core modules, you can visit the documentation at: <br/>
<a href="https://nodejs.org/api/">https://nodejs.org/api/.</a><a href="https://nodejs.org/api/"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom modules</h1>
                
            
            
                
<p>These are the modules we create ourselves on top of Node.js. Since Node.js has a very large ecosystem, there are tons of different modules out there to grab for free according to our needs. We can build one ourselves or just use someone else's module. This is another aspect in which Node.js is powerful. It gives us the flexibility of using the modules from the community or we can build them by ourselves.</p>
<p>We can view the list of all existing available modules at <a href="https://www.npmjs.com/browse/depended">https://www.npmjs.com/browse/depended</a>:<a href="https://www.npmjs.com/browse/depended"/></p>
<div><img src="img/72db803d-bbff-45a8-8283-f529bfecf3a4.png" style="width:36.83em;height:30.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Express.js </h1>
                
            
            
                
<p>Express.js is a minimalist server-side web framework for Node.js. It is built on top of Node.js to make it easy to manage the Node.js server. The most important strength of Express.js is that it makes the routing very, very easy. The robust API that it provides is very easy to configure. It is easy to receive requests from the frontend and easy to connect to the database. Express.js is also the most popular web framework for Node.js. It uses the <strong>Model View Controller</strong> (<strong>MVC</strong>) design pattern, which we will be discussing later on in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Express.js</h1>
                
            
            
                
<p>We have already covered how to install <kbd>node</kbd> modules via <kbd>npm</kbd>. Similarly, we can install Express.js via NPM using this command:</p>
<pre><strong>$ npm install express</strong></pre>
<p>This is an easy way to install <kbd>node</kbd> modules. But, while building an application, we're going to need lots of different kinds of modules. We will also want to share these modules across our multiple applications. Hence, to make a module available globally, we will have to install it globally. For that, <kbd>npm</kbd> provides the option of adding <kbd>-g</kbd> when installing <kbd>node</kbd> modules. So, now we can use:</p>
<pre><strong>$ npm install -g express</strong></pre>
<p>This will install Express.js globally, which allows us to use the <kbd>express</kbd> command across multiple applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Express.js application</h1>
                
            
            
                
<p>Now that we have installed Express.js, let's get started creating an application using Express.js. </p>
<p>We will name our application <kbd>express_app</kbd>.  Building an outline of an express application is very simple using the <kbd>express</kbd> command. We can simply use:</p>
<pre><strong>$ express express_app</strong></pre>
<p>The output is as follows:</p>
<div><img src="img/5ed5de2e-8500-4b09-bdeb-7eb0ee523acf.png"/></div>
<p>The command creates a lot of files and folders in our application. Let's have a quick look at these:</p>
<ul>
<li><kbd>package.json</kbd>: This file contains a list of all the <kbd>node</kbd> packages that we have installed in the application and an introduction to the application.</li>
<li><kbd>app.js</kbd>: This file is the main entry page for an express application. The web server code resides in this file.</li>
<li><kbd>public</kbd>: We can use this folder to insert our assets such as images, stylesheets, or custom JavaScript code.</li>
<li><kbd>views</kbd>: This folder contains all of our view files that are going to be rendered in the browser. It has the main layout file (which contains the basic HTML templating for a view file), an <kbd>index.jade</kbd> file (which extends the layout file and only has the content that is changeable or dynamic), and an <kbd>error.jade</kbd> file (which displays when we need to display some sort of error messaging to our frontend).</li>
<li><kbd>routes</kbd>: This folder has a whole list of all the routes that we will be building access different pages of the application. We will discuss more on this in further sections.</li>
<li><kbd>bin</kbd>: This folder contains the executable files for Node.js.</li>
</ul>
<p>So, these are the basic things that we need to know. Now, use your favorite text editor to work on the application and let's get started. Now, if we look at <kbd>package.json</kbd>, there are certain packages that we did not install but that are listed in the dependencies:</p>
<div><img src="img/e44f9b6c-a3d5-47be-b601-fb8687b29f77.png" style="width:42.75em;height:27.17em;"/></div>
<p>This is because these are the Express.js dependencies for any application. This means, when we create an application using the <kbd>express</kbd> command, it will automatically install all the dependencies that it needs. For example, the dependencies listed in the preceding <kbd>package.json</kbd> file do the following things:</p>
<ul>
<li><strong>body-parser</strong>: This is used to parse the parameters of the body that we provide when making an HTTP request</li>
<li><strong>debug</strong>: This is a JavaScript utility package that provides pretty formatting to what <kbd>console.log</kbd> returns
<p>We can install or remove packages via the <kbd>package.json</kbd> file as well. Just add or remove the name of the package in the <kbd>package.json</kbd> file to install or remove it. Then run <kbd>$ npm install</kbd>.</p>
</li>
<li><strong>express</strong>: This is a Node.js JavaScript framework and is used for building scalable web applications on top of Node.js.</li>
<li><strong>jade</strong>: As mentioned previously, this is the default templating engine for Node.js. We should have seen a warning while creating the application with the <kbd>express</kbd> command, saying The default view engine will not be jade in future releases. This is because <kbd>jade</kbd> is going to be replaced by <kbd>pug</kbd>; <kbd>jade</kbd> was copyrighted by a company and the name was later changed to <kbd>pug</kbd>. </li>
</ul>
<p style="padding-left: 60px">The express generator uses the outdated <kbd>jade</kbd> templating engine. To change the templating engine, run the following steps:</p>
<ol>
<li>In the <kbd>package.json</kbd> file, remove the <kbd>"jade": "~1.11.0"</kbd>, line and run:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd express_app<br/>$ npm install</strong></pre>
<ol start="2">
<li>Now, to install the new <kbd>pug</kbd> templating engine, run:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ npm install pug --save</strong></pre>
<ol start="3">
<li>If we look into the <kbd>package.json</kbd> file, we should see a line similar to this:<br/>
<kbd>"pug": "^2.0.0-rc.4"</kbd>.</li>
</ol>
<p> </p>
<ol start="4">
<li>Rename the files in the <kbd>views</kbd> folder:
<ul>
<li><kbd>error.jade</kbd> to <kbd>error.pug</kbd></li>
<li><kbd>index.jade</kbd> to <kbd>index.pug</kbd></li>
<li><kbd>layout.jade</kbd> to <kbd>layout.pug</kbd></li>
</ul>
</li>
<li>Finally, in <kbd>app.js</kbd>, remove the line which says:</li>
</ol>
<pre style="padding-left: 60px"><strong>app.set('view engine', 'jade');</strong></pre>
<ol start="6">
<li>Add the following line to use <kbd>pug</kbd> as the view engine:</li>
</ol>
<pre style="padding-left: 60px"><strong>app.set('view engine', 'pug');</strong></pre>
<ul>
<li><strong>morgan</strong>: This is middleware for logging the HTTP requests</li>
<li class="mce-root"><strong>serve-favicon</strong>: This is for displaying a favicon in the browser to identify our application</li>
</ul>
<p>It's not necessary to have all these dependencies for our application. They come from installing Express.js. Just dig around for what you want and then add or remove the packages as per your application needs.</p>
<p>For now, we will leave it as it is. The <kbd>express</kbd> command just adds the dependencies to our <kbd>package.json</kbd> file and creates a skeleton for our application. In order to actually install these modules and packages listed in the <kbd>package.json</kbd> file, we need to run:</p>
<pre><strong>$ npm install</strong></pre>
<p>This command will actually install all the dependencies. Now, if we look into the folder structure, we can see a new folder is being added called <kbd>node_modules</kbd>. This is the place where all of the packages that we installed within that application reside.</p>
<p>Now, the first thing that we want to do is to set up a web server. For that, add the following line in the <kbd>app.js</kbd> file:</p>
<pre>// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get('env') === 'development' ? err : {};<br/><br/>  // render the error page<br/>  res.status(err.status || 500);<br/>  res.render('error');<br/>});<br/><br/><strong>app.listen(3000, function() { console.log('listening on 3000') })</strong><br/><br/>module.exports = app;<br/></pre>
<p>Now, run the following command:</p>
<pre><strong>$ node app.js</strong></pre>
<p>This will spin up our application server. Now, when we go to the <kbd>http://localhost:3000/</kbd> URL, we should be able to get this:</p>
<div><img src="img/e5dbd016-ed59-4dbf-8aeb-ba560d247a0b.png" style="width:53.33em;height:12.50em;"/></div>
<p>That's it. We have successfully created an Express application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Express router</h1>
                
            
            
                
<p>Let's move on to the Express router. As mentioned earlier in the chapter, one of the most important aspects of Express.js is that it provides easy routing for the application. Routing is the definition of the URL for an application. If we look at <kbd>app.js</kbd>, we will see a section such as:</p>
<pre>...<br/>app.use('/', index);<br/>app.use('/users', users);<br/>...</pre>
<p>This means that when we access a web page, and when a request is made to the home page, the express router redirects it to a router called <kbd>index.</kbd> Now, look at <kbd>routes/index.js</kbd>, which has the following code:</p>
<pre>var express = require('express');<br/>var router = express.Router();<br/><br/>/* GET home page. */<br/>router.get('/', function(req, res, next) {<br/>  res.render('index', { title: 'Express' });<br/>});<br/><br/>module.exports = router;</pre>
<p>This means that when we access the home page, it renders a page called <kbd>index</kbd> that resides inside <kbd>views/index.pug</kbd> and passes a parameter for the <kbd>title</kbd> to be displayed on the page. Now, look at the <kbd>index.pug</kbd> file in the views folder, which has the following code:</p>
<pre>extends layout<br/><br/>block content<br/>  h1= title<br/>  p Welcome to #{title}</pre>
<p>This means it uses the layout from the <kbd>layout.pug</kbd> file and displays an <kbd>h1</kbd> title as well as a paragraph that renders the title that we passed from the route file. Hence, the output is as follows:</p>
<div><img src="img/79f3e138-a5bb-4c1b-81e3-bde7992002d1.png"/></div>
<p>Pretty simple and straightforward, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Request object</h1>
                
            
            
                
<p>A request object is an object that contains the information about the HTTP request. The properties of the request are:</p>
<ul>
<li><strong>query: </strong>This contains information about the parsed query strings. Accessed via <kbd>req.query</kbd>.</li>
<li><strong>params: </strong>This contains information about the parsed routing parameter. Accessed via <kbd>req.params</kbd>.</li>
<li><strong>body: </strong>This contains information about the parsed request body. Accessed via <kbd>req.body</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Response object</h1>
                
            
            
                
<p>After receiving the <kbd>request</kbd> on <kbd>req</kbd> variable, the <kbd>res</kbd> object is something that we send back as the <kbd>response</kbd> we want. </p>
<p>The properties of the response are:</p>
<ul>
<li><strong>send: </strong>This is used for sending a response to the views. Accessed via <kbd>res.send</kbd>. It takes two parameters, the status code, and the response body.</li>
<li><strong>status: </strong>If we want to send the success or failure of the application, <kbd>res.status</kbd> is used. This is the HTTP status code.</li>
<li><strong>redirect: </strong><kbd>res.redirect</kbd> is used when we want to redirect to a certain page rather than sending responses in other formats.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to MVC</h1>
                
            
            
                
<p>The MVC model is essential when building applications regardless of any programming languages. The MVC architecture makes it easy to organize our application's structure and separate out logic parts and view parts. We can incorporate this MVC structure at any time, even if we have completed half of our application. The best time to implement it is at the start of any application. </p>
<p>As the name suggests, there are three parts to it:</p>
<ul>
<li><strong>Model: </strong>All of the application's business logic resides under these <kbd>models</kbd>. These deal with the database. They handle all the logic parts of the application.</li>
<li><strong>View: </strong>Everything that the browser renders—what users see—is handled by these view files. It deals with whatever we send to the client.</li>
<li><strong>Controller: </strong><kbd>Controllers</kbd> basically connect these <kbd>models</kbd> and views. It is responsible to take the logical calculations done in <kbd>models</kbd> to the <kbd>views</kbd> sections:</li>
</ul>
<div><img src="img/ed9038d2-b132-4c49-abd4-ca54af97f786.png" style="width:21.50em;height:17.17em;"/></div>
<p>It is not necessary to implement the MVC platform in the application we build. The JavaScript is pattern agnostic, which means we can create our own folder structure. Unlike other programming languages, we can choose whatever structure is easiest for us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why MVC?</h1>
                
            
            
                
<p>There are a lot of benefits that are added when we implement an MVC architecture into our application:</p>
<ul>
<li>Clear segregation of business logic and views. This separation allows us to reuse the business logic throughout the whole application.</li>
<li>The development process becomes faster. This is obvious since the parts are clearly separated out. We can just add our views to our views folder and add logic inside the <kbd>models</kbd> folder.</li>
<li>It is easy to modify existing code. This is very handy when multiple developers are working on the same project. Anyone can pick up the application from anywhere and start making changes to it.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the folder structure to incorporate MVC</h1>
                
            
            
                
<p>Now that we know enough about MVC, let's modify the folder structure of the application we created, called <kbd>express_app</kbd>. First of all, we need to create these three folders in the root directory. There is already a views folders so we can skip that. Let's go ahead and create <kbd>models</kbd> and <kbd>controllers</kbd> folders.</p>
<p>After that, in our <kbd>app.js</kbd>, we need to include our controller files. To do that, we first have to introduce a new package called filesystem. This module makes it easy to perform operations related to files, such as reading/writing to the file.<br/>
<br/>
So, to add this package to our application, run:</p>
<pre><strong>$ npm install file-system --save<br/></strong></pre>
<p>This <kbd>--save</kbd> argument is used when we want a <kbd>node</kbd> module to only be installed within our application. Also, after installation, this package will be automatically included in our <kbd>package.json</kbd>.</p>
<div><img src="img/e78d5486-a74d-46e8-8cba-51a0992af1e4.png" style="width:36.42em;height:23.83em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Now, we will need to require this module and use it to include all of our files that reside in the controller. For that, add these lines of code in our <kbd>app.js</kbd>. Make sure you add these lines before our web server running code:</p>
<pre>var index = require('./routes/index');<br/>var users = require('./routes/users');<br/><br/>var app = express();<br/><br/><strong>// Require file system module</strong><br/><strong>var fs = require('file-system');</strong><br/><br/><strong>// Include controllers</strong><br/><strong>fs.readdirSync('controllers').forEach(function (file) {</strong><br/><strong>  if(file.substr(-3) == '.js') {</strong><br/><strong>    const route = require('./controllers/' + file)</strong><br/><strong>    route.controller(app)</strong><br/><strong>  }</strong><br/><strong>})</strong><br/><br/>// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'pug');</pre>
<p>Let's move ahead with adding a route to our controller. Let's create a folder in the root of the application called <kbd>controllers</kbd> and add an <kbd>index.js</kbd> file to the <kbd>controllers</kbd> folder and paste the following code:</p>
<pre><strong>module.exports.controller = (app) =&gt; {</strong><br/><strong>  // get homepage</strong><br/><strong>  app.get('/', (req, res) =&gt; {</strong><br/><strong>    res.render('index', { title: 'Express' });</strong><br/><strong>  })</strong><br/><strong>}</strong></pre>
<p>Now, all of our routes will be handled by the controller files, which means we don't need the codes in <kbd>app.js</kbd> that control the routing. Hence, we can remove these lines from the file:</p>
<pre><strong>var index = require('./routes/index');</strong><br/><strong>var users = require('./routes/users');</strong><br/><br/><strong>app.use('/', index);</strong><br/><strong>app.use('/users', users);</strong></pre>
<p>Actually, we don't need that <kbd>routes</kbd> folder any longer. Let's also remove the <kbd>routes</kbd> folder.</p>
<p>Similarly, let's add a new route that controls all the user-related operations. For that, add a new file to the <kbd>controllers</kbd> folder called <kbd>users.js</kbd> and paste the following code inside it:</p>
<pre><strong>module.exports.controller = (app) =&gt; {</strong><br/><strong>  // get users page</strong><br/><strong>  app.get('/users', (req, res) =&gt; {</strong><br/><strong>    res.render('index', { title: 'Users' });</strong><br/><strong>  })</strong><br/><strong>}</strong></pre>
<p>Now, let's restart our node server for the app with:</p>
<pre><strong>$ node app.js</strong></pre>
<p>With this, when we visit <kbd>http://localhost:3000/users</kbd>, we will be able to see the following:</p>
<div><img src="img/f1e95c69-0473-449b-952c-2451add9a98e.png"/></div>
<p>We have successfully set up a <kbd>controllers</kbd> and <kbd>views</kbd> part of the MVC architecture. We will cover more on <kbd>models</kbd> part in further sections.</p>
<p>In the previous chapter, we talked about GitHub and how to use it for making code history by making small commits. Don't forget to set up a repo and continuously push code to GitHub. </p>
<p>The npm packages are stored in the <kbd>node_modules</kbd> directory, which we should not push to GitHub. To ignore such files, we can add a file called <kbd>.gitignore</kbd> and specify the files we do not want to push to GitHub.</p>
<p>Let's create a file within our application as well, called <kbd>.gitignore</kbd>, and add the following content:</p>
<pre><strong>node_modules/</strong></pre>
<p class="mce-root">This way, when we install any packages, it will not show up as the code difference while making commits to GitHub.</p>
<p class="mce-root">We are having to restart our <kbd>node</kbd> server every time we make some changes to our code which is very time-consuming. To ease this process, <kbd>node</kbd> provides a package called <kbd>nodemon</kbd>, which automatically restarts the server every time we make changes to the code. </p>
<p>To install the package, run:</p>
<pre><strong>$ npm install nodemon --save</strong></pre>
<p>To run the server, use the following command:</p>
<pre><strong>$ nodemon app.js</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">File naming conventions</h1>
                
            
            
                
<p>When developing an application, we need to follow a certain convention to name the files. As we go on building the application, we will have a whole lot of files, which can get messy. MVC allows for having parallel naming conventions across different folders, which can lead to the same filenames inside different folders.</p>
<p>We can work on such filenames as well if that is what we find to be easy and maintainable. Otherwise, we can just append the type of filename to each file, as  in the following example; for a controller file to handle the user-related activities, we can leave it as <kbd>controllers/users.js</kbd>, or we can rename it to <kbd>controllers/users_controller.js</kbd>. We will be using <kbd>controllers/users</kbd> for our application.</p>
<p>The same goes for <kbd>models</kbd>, <kbd>services</kbd>, or any other folders that need to be shared among different areas throughout the application. For this application, we will be using the following naming convention:</p>
<div><img src="img/2ecb07df-3666-4060-b1af-b197789c09df.png" style="width:38.92em;height:23.42em;"/></div>
<p>Remember, there is no official naming convention in Node.js. We can definitely customize the way we find simpler. We will discuss more about creating <kbd>models</kbd> in further chapters. That will require us to create a connection with Mongo, which we will describe in further chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating view files for the Express.js application</h1>
                
            
            
                
<p>We learned about how to create <kbd>controllers</kbd> in the last section. In this section, we will talk about how to add and customize view files. If you remember, we have this code in <kbd>controllers/users.js</kbd>:</p>
<pre>module.exports.controller = (app) =&gt; {<br/>  // get users page<br/>  app.get('/users', (req, res) =&gt; {<br/>    res.render('index', { title: 'Users' });<br/>  })<br/>}</pre>
<p>Let's change a line that renders the <kbd>index</kbd> file to this:</p>
<pre>module.exports.controller = (app) =&gt; {<br/>  // get users page<br/>  app.get('/users', (req, res) =&gt; {<br/>    <strong>res.render('users', { title: 'Users' });</strong><br/>  })<br/>}</pre>
<p>This means that the controller wants to load the <kbd>users</kbd> file, which is in the <kbd>views</kbd> folder. Let's go ahead and create a <kbd>users.pug</kbd> file in the <kbd>views</kbd> folder.</p>
<p>After creating the file, paste in the following code; this is the same code as in the <kbd>index.pug</kbd> file in our <kbd>views</kbd> folder:</p>
<pre><strong>extends layout</strong><br/><br/><strong>block content</strong><br/><strong>  h1= title</strong><br/><strong>  p Welcome to #{title}</strong></pre>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Now, if we used <kbd>nodemon</kbd>, we don't have to restart our server; just reload the browser with the location <kbd>http://localhost:3000/users</kbd>. This should render  the following: </p>
<div><img src="img/bd386ef4-752b-4a54-9206-abf4b85a3bd4.png"/></div>
<p>Now that we know how to connect <kbd>controllers</kbd> and <kbd>views</kbd> and how to create view files, let's get a little bit more information on the code of the file.</p>
<p>The first line says:</p>
<pre>extends layout</pre>
<p>What this means is that it is asking to extend the views that are already in the <kbd>layout.pug</kbd> file. Now, look at <kbd>layout.pug</kbd>:</p>
<pre>doctype html<br/>html<br/>  head<br/>    title= title<br/>    link(rel='stylesheet', href='/stylesheets/style.css')<br/>  body<br/>    block content</pre>
<p>This is a simple HTML file with <kbd>doctype</kbd>, <kbd>HTML</kbd>, <kbd>head</kbd>, and <kbd>body</kbd> tags. Inside the <kbd>body</kbd> tag, it says to block content, which means it yields the content from any other files that are written under this <kbd>block content</kbd> statement. If we look at <kbd>users.jade</kbd>, we can see that the content is written under the block content statement. Now, this is very useful because we don't have to repeat the entire HTML tags in every view file that we create. </p>
<p>Also, if we look at <kbd>users.js</kbd> inside the controller, there's a line that says:</p>
<pre>res.render('users', { title: 'Users' });</pre>
<p>The render method has two parameters: the view that it wants to load and the variables that it wants to pass to that view. In this example, <kbd>Users</kbd> is passed to the title variable. And in <kbd>users.jade</kbd> in the <kbd>views</kbd> folder, we have:</p>
<pre>block content<br/>  h1= title<br/>  p Welcome to #{title}</pre>
<p>This renders that variable inside both the <kbd>h1</kbd> tag and the <kbd>p</kbd> tag. This way, we can pass any content that we want from <kbd>controllers</kbd> to views. Let's add a new variable called <kbd>description</kbd> to the <kbd>render</kbd> method in the <kbd>users.js</kbd> controller:</p>
<pre>module.exports.controller = (app) =&gt; {<br/>  // get homepage<br/>  app.get('/users', (req, res) =&gt; {<br/>    res.render('users', { title: 'Users', <strong>description: 'This is the description of all the users'</strong> });<br/>  })<br/>}</pre>
<p>Also, let's make a place where this would be rendered in <kbd>users.pug</kbd>:</p>
<pre>extends layout<br/><br/>block content<br/>  h1= title<br/>  p Welcome to #{title}<br/>  <strong>p #{description}</strong></pre>
<p>If we reload the browser, we'll get:</p>
<div><img src="img/cbaf19b7-8457-426c-b195-65b17ac8dd2b.png"/></div>
<p>That's how we create the views for an express application. Now, go ahead and add views as you wish for our application.</p>
<p>Always make sure that you commit and push the changes into GitHub. The smaller the commit, the more maintainable the code is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned what Node.js is and what Express.js is. We learned how to create an application using Express.js and learned about the MVC architecture.</p>
<p>In the next chapter, we will talk about MongoDB and its queries. We will also talk about using Mongoose for fast development and Mongoose queries and validations.</p>


            

            
        
    </body></html>