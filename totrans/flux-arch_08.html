<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Information Lifecycle</h1></div></div></div><p>Any information system has a lifecycle. Individual components in these systems have their own lifecycles as well. Cumulatively, these can be easy to deal with or overwhelmingly difficult. In frontend JavaScript architectures, the tendency is toward the latter. The reason is simple, the lifecycles that our components go through, fundamentally alter the flow of information over time in ways that are close to impossible to predict.</p><p>This chapter is about the information life cycle in Flux architectures. Flux is different from other architectures in that it puts emphasis on scaling information instead of on JavaScript components. We'll begin exploring this theme with a look at the difficulties we've faced for years, using the typical component lifecycles found in modern JavaScript frameworks. Then, we'll contrast this approach with that of Flux, where high-level components are relatively static.</p><p>Next, we'll jump into the concept of scaling information and how this leads to more sane architectures that are much easier to maintain than alternative approaches. We'll close the chapter with a discussion on inactive stores—stores that aren't actively serving a view with data. Let's get to it.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Component life cycle difficulties</h1></div></div></div><p>One aspect of <a id="id271" class="indexterm"/>scaling a frontend architecture is cleaning up unused resources. This frees memory for new resources that get created as the user interacts with <a id="id272" class="indexterm"/>the application. JavaScript is garbage-collected, meaning that once an object doesn't have any references to it, it's eligible for collection the next time the collector runs. This gets us partway there; in that, there's no need to manually allocate/de-allocate memory. However, we have a whole other category of scaling issues, and they're all related to the lifecycle of components.</p><p>In this section, we'll talk about the scenarios where we want to reclaim unused resources and how this generally happens in frontend architectures. Then, we'll look at the challenges that component dependencies present, in the context of lifecycle management. Finally, we'll look at memory leak scenarios. Even with the best tools in place, there's always the possibility <a id="id273" class="indexterm"/>that our code has done something to circumvent memory management.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec96"/>Reclaiming unused resources</h2></div></div></div><p>Something that <a id="id274" class="indexterm"/>happens a lot throughout the course of an application, is that new resources are created while old resources are destroyed. This is in response to user interactivity—as they traverse the features of the application, new components get created in order to present new information. Much of this creation and destruction of JavaScript objects and DOM elements is transparent to us—the tools we employ can take care of this for us. The following diagram captures the idea of a component that frees internal resources as it changes state:</p><div><img src="img/B05419_08_01.jpg" alt="Reclaiming unused resources"/></div><p>The key lies with the lifecycle of our components. Depending on the framework that's responsible for managing this lifecycle, different things can happen at different times. For instance, your component is instantiated and stored when it's parent component is created. When your component is rendered, it inserts new DOM elements and keeps a reference to them. Finally, when the component's parent is destroyed, our component is instructed to remove its DOM elements and release any references to them. This is an oversimplified work-flow, but the general idea is the same no matter how many moving parts there are. The job of the tools we use is to handle the lifecycle of our components in a way that reclaims unused components.</p><p>Why is reclaiming unused components so important? The fundamental limitation we face is that memory is finite, and we're trying to build a robust application that scales well. Removing components from memory when they're no longer needed, makes room for new components to be created when they're needed. So, what's the big deal if we're using a framework that has well-defined lifecycles for our components and handles a lot of the messy details for us?</p><p>One limiting factor to this approach is that with a complex application that has lots of moving parts, the framework is constantly creating and destroying objects. This inevitably leads to the garbage collector getting invoked frequently, causing pauses in the main JavaScript execution thread. In the worst case, this can lead to pauses in the user experience due to <a id="id275" class="indexterm"/>unresponsive user events. The other potential pitfall of automatically managed component lifecycles is that the framework doesn't always know what we're thinking, and this can lead to hidden dependencies that end up breaking the flow of the component create/destroy lifecycle.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec97"/>Hidden dependencies</h2></div></div></div><p>Patterns that <a id="id276" class="indexterm"/>define the lifecycle of a particular type of component are a good thing—provided that our components abide by their lifecycle one hundred percent of the time. This rarely works out because we're trying to build something unique that solves a problem for our users, not a piece of software that plays nice with a <a id="id277" class="indexterm"/>framework just for the sake of it. The biggest risk here is that we'll accidentally prevent the framework from properly freeing resources by introducing dependencies. These dependencies might make perfect sense in the context of our application, but as far as the framework is concerned, it doesn't know about them, and this breaks in unpredictable ways. Take a look at the following diagram:</p><div><img src="img/B05419_08_02.jpg" alt="Hidden dependencies"/></div><p>The actual scenarios we face will be a little more nuanced than the scenario depicted here. The general theme is that frameworks that manage lifecycles are unforgiving. All it takes is a dependency in the wrong place to completely invalidate everything that the framework is doing for the application. However, this is the cost/benefit of having lifecycles for architectural components in the first place. The benefit being that we need to reclaim components to make way for new ones, and if a framework can automate this arduous task for <a id="id278" class="indexterm"/>us, all the better. The risk is that any time <a id="id279" class="indexterm"/>things are created and destroyed, there's a chance that this isn't done properly, leading to memory leaks.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec98"/>Memory leaks</h2></div></div></div><p>When our code is <a id="id280" class="indexterm"/>constantly creating and destroying objects, the JavaScript garbage collector thrashes, and we experience performance hiccups. However, this is a minor problem compared to leaky JavaScript components that are never fully garbage-collected. This tends to happen when our application code has ideas that don't quite fit with those of the framework that manages the lifecycle of our components. Obviously memory leaks are a huge scalability issue and one that want to avoid at all costs.</p><p>So what we have are two related scalability issues with regard to the lifecycle of components in our architecture. First, we don't want to constantly create and destroy objects because this has garbage-collection pausing problems. Second, we don't want to leak memory by introducing hidden dependencies that the framework isn't aware of, breaking the intended lifecycle. As we'll see in the following section, Flux architectures help with both aspects of component lifecycle issues. There isn't a lot of creation/destruction of components in a Flux architecture. This reduces the probability of introducing logic that breaks the lifecycle of a given component. Later in the chapter, we'll see how Flux focuses <a id="id281" class="indexterm"/>on information rather than JavaScript components to achieve scale.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Flux structures are static</h1></div></div></div><p>Given that the <a id="id282" class="indexterm"/>need to constantly create and destroy objects presents an opportunity for scaling issues, it seems that we should create and destroy as little as possible. It turns out that Flux architectures are different in this area in that much of the component infrastructure is static.</p><p>In this section, we'll look at what sets Flux apart from other architectures in this regard, starting with the singleton pattern that's used by many modules. Then, we'll compare the traditional MVC model approach to Flux stores. Lastly, we'll take a look at static view components and see if this is an idea worth pursuing in order to achieve scale.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Singleton pattern</h2></div></div></div><p>As you've probably <a id="id283" class="indexterm"/>noticed by now, most of the modules we've worked with so far in this book have exported a single instance. The dispatcher exposes a single instance of the <code class="literal">Dispatcher</code> class from the Facebook Flux package. This is the singleton pattern in action.</p><p>The basic idea is that there's only one instance of a class, creating more is never necessary because the first instance is all we'll ever need. This bodes well with the scaling issues we've discussed in this chapter, where constant creation and destruction makes our code vulnerable to errors. These errors ultimately prevent the application from scaling, due to memory leaks or performance problems.</p><p>Instead, Flux architectures tend to assemble the plumbing between the components at startup time, and this pluming stays in place permanently. Think about the physical plumbing where you live, it sits idle when it's not being used. However, the cost of tearing out the physical plumbing to reclaim the space, and the cost of replacing it when needed simply doesn't add up. The overhead of having static plumbing structures within our walls isn't a scaling bottleneck in our day-to-day lives.</p><p>So while we can avoid some of the creation and destruction of objects by following the singleton pattern, there are tradeoffs. For example, the single pattern isn't necessarily a good pattern. At least not in all our modules where everything is a class, and yet, everything is only instantiated once. Let's look at a store module and see if we can implement something that doesn't actually require a store. First, let's implement a typical store module which exports a singleton class instance for comparison:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { MY_ACTION } from '../actions/my-action';

// A typical Flux store class. This module
// exports a singleton instance of it.
class SingletonStore extends EventEmitter {
  constructor() {
    super();

    this.state = {
      pending: true
    };

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {
        case MY_ACTION:
          this.state.pending = false;
          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new SingletonStore();</pre></div><p>There's only a handful of properties that the outside world requires from this module. It needs the state, so other components can read it. It needs the identifier of dispatcher registration, so other components can depend on it using <code class="literal">waitFor()</code>. And, it needs the <code class="literal">EventEmitter</code>, so <a id="id284" class="indexterm"/>other components can listen for store state changes. Let's now implement a store that doesn't actually require instantiating a new class:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { MY_ACTION } from '../actions/my-action';

// Exports the state of this store...
export var state = {
  pending: true
};

// Exports the "id" of the dispatcher registration
// so that other stores can depend on this module.
export var id = dispatcher.register((e) =&gt; {
  switch(e.type) {
    case MY_ACTION:
      state.pending = false;
      emitter.emit('change', state);
      break;
    }
});

// We need to create a new "EventEmitter" here
// since there's no class to extend it.
const emitter = new EventEmitter();

// Exports the minimal interface that views
// require to listen/unlisten to stores.
export const on = emitter.on.bind(emitter);
export const off = emitter.removeListener.bind(emitter);</pre></div><p>As you can see, we're exporting the bare necessities that allow other components to treat this module as a store. And it is indeed a store, it's simply structured differently. Instead of exporting a singleton class instance, which has the essential store interface, we're directly exporting the pieces of the interface. Is there any fundamental advantage to either approach? No, there's not. If you prefer classes and the ability to extend a base class, then stick with the singleton pattern. If you feel that classes are ugly and unnecessary, stick with the module approach.</p><p>At the end of the day, the architectural result is the same. The store simply exists. There's no need to create and destroy the store as the user interacts with the application. There's nothing preventing us from doing this—setting up and tearing down stores as the state of the application changes. But as we'll see later in the chapter, there's really no advantage to doing this, just as there's no advantage to tearing your walls apart when the sink isn't running.</p><p>Let's see these two stores in <a id="id285" class="indexterm"/>action. Aside from how they're imported, they're indistinguishable:</p><div><pre class="programlisting">import { myAction } from './actions/my-action';
import singletonStore from './stores/singleton-store';

// Note that "moduleStore" is a module, with everything
// that it exports, not a class instance.
import * as moduleStore from './stores/module-store';

// Registers a "change" callback with the singleton
// store...
singletonStore.on('change', (state) =&gt; {
  console.log('singleton', state.pending);
});

// Registers a "change" callback with the module
// store. Not that it looks and feels exactly
// like a class instance.
moduleStore.on('change', (state) =&gt; {
  console.log('module', state.pending);
});

// Triggers the "MY_ACTION" action.
myAction();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Comparison to models</h2></div></div></div><p>Remember the idea that <a id="id286" class="indexterm"/>stores represent features at the top-level of our application? Well, top-level features generally aren't created and destroyed constantly throughout the lifetime of the application. Models on the other hand, our friends from the family of MV* architectures, often represent more fine-grained data domains. And because of this, they need to pop in and out of existence.</p><p>For example, suppose we're on the search page of an application, and there's a bunch of results displayed. The individual results are likely models, representative of some structure returned by the API. The view that renders the search results probably knows how to display these modules. When the results change or the user navigates to another part of the application, the models are inevitably destroyed. This is part of the whole lifecycle discussion we had earlier in the chapter. It's not a simple deletion—there's cleanup steps that need to be performed.</p><p>With Flux stores, we don't have the same level of complexity. There's views that listen to a given store, but that's it. When the state of a store changes, like when some search result data is deleted from the store state, the views are notified. It's then up to the view to reflect this changed data by re-rendering the UI. With Flux, the cleanup is a simple deletion problem, both from the point of view of the DOM and of the store. The fact that we're not blowing away entire stores while the user interacts with the application means that there's less chance for our architectural components to fall out of sync with one another.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Static views</h2></div></div></div><p>Since views are the <a id="id287" class="indexterm"/>components responsible for rendering information that the <a id="id288" class="indexterm"/>user can see, it would make sense that the view is cleaned up when the user isn't looking at it, right? Well, not necessarily. Revisiting the plumbing analogy, when we leave the kitchen, we turn the tap in the sink off. We don't get a toolbox and start ripping out pipes. The notion that views in a Flux architecture can be static is in fact viable. It's the water we need to turn off in order to scale, not the plumbing.</p><p>Let's look at some views that are created at startup and never destroyed as the user interacts with the application. First, we'll implement a class-based static view:</p><div><pre class="programlisting">import myStore from '../stores/my-store';

class ClassView {
  constructor() {

    // The "container" DOM element for this view.
    this.container =
      document.getElementById('class-view');

    // Render the new state when "myStore" changes.
    myStore.on('change', (state) =&gt; {
      this.render(state);
    });
  }

  render({ classContent } = myStore.state) {

    // Sets the content of the container element.
    // This is done by reducing the "classContent"
    // array to a single string. If it's empty,
    // any existing DOM elements are removed from
    // the container.
    this.container.innerHTML = classContent.reduce(
      (x, y) =&gt; `&lt;strong&gt;${x + y}&lt;/strong&gt;`, '');
  }
}

export default new ClassView();</pre></div><p>This looks like your typical class that you would find in a Flux architecture. It's instantiated within the <a id="id289" class="indexterm"/>module and exported. The content itself is rendered <a id="id290" class="indexterm"/>by reducing an array to a <code class="literal">&lt;strong&gt;</code> tag. We'll see why we're rendering such a tag like this when we look at the store. But first, let's look at another static view that takes the form of a function:</p><div><pre class="programlisting">import React from 'react';

// Renders the view content using a functional
// React component.
export default ({content}) =&gt; (
  &lt;strong&gt;{content}&lt;/strong&gt;
);</pre></div><p>This is the functional style of React components that you were introduced to in the previous chapter. As you can see, there's nothing much to it, as React takes care of a lot of the heavy lifting for us. Now let's take a look at the store that both of these views relies on for information:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { SHOW_CLASS, SHOW_FUNCTION } from '../actions/show';

class MyStore extends EventEmitter {
  constructor() {
    super();

    // The two content properties of this store's state
    // empty arrays, meaning empty content.
    this.state = {
      classContent: [],
      functionContent: []
    };

    this.id = dispatcher.register((e) =&gt; {
      let {state} = this;

      switch(e.type) {

        // If the "SHOW_CLASS" action was dispatched,
        // the "classContent" state gets a single item
        // array and the "functionContent" state gets
        // and empty array.
        case SHOW_CLASS:
          Object.assign(state, {
            classContent: [ 'Class View' ],
            functionContent: []
          });

          this.emit('change', state);
          break;

        // If the "SHOW_FUNCTION" action was dispatched,
        // the "functionContent" state gets a single item
        // array and the "classContent" state gets an
        // empty array.
        case SHOW_FUNCTION:
          Object.assign(state, {
            classContent: [],
            functionContent: [ 'Function View' ]
          });

          this.emit('change', state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>You can see that both actions—<code class="literal">SHOW_CLASS</code> and <code class="literal">SHOW_FUNCTION</code>—are processed the same way. One action sets a piece of state while deleting another. Let's discuss this approach here for a moment. The <code class="literal">classContent</code> and <code class="literal">functionContent</code> state properties both use single-item arrays for a string value. Both of our views iterate over these arrays—using <code class="literal">map()</code> and <code class="literal">reduce()</code>. The reason we're doing it this way is to keep logic out of the views. The <a id="id291" class="indexterm"/>business logic that operates on stores should stay in the store. However, views need to know what to display and what to remove. By always iterating <a id="id292" class="indexterm"/>over a collection, like an array, the content generation is consistent and logic-free. Let's see how both of these views are used in <code class="literal">main.js</code>:</p><div><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

import { showClass, showFunction } from './actions/show';
import myStore from './stores/my-store';
import classView from './views/class';
import FunctionView from './views/function';

// The DOM element used by our "FunctionView"
// component.
var functionContainer = document
  .getElementById('function-view');

// Utility to render the "FunctionView" React
// component. Called by the store "change"
// handler and to perform the initial rendering.
function renderFunction(state) {
  render(
    &lt;FunctionView
      content={state.functionContent}/&gt;,
    functionContainer
  );
}

// Sets up the "change" handler for "FunctionView"...
myStore.on('change', renderFunction);

// Perform the initial rendering of both views...
classView.render();
renderFunction(myStore.state);

// Dispatch the "SHOW_CLASS" action.
showClass();

// Wait one second, then dispatch the "SHOW_FUNCTION"
// action.
setTimeout(() =&gt; {
  showFunction();
}, 1000);</pre></div><p>The <code class="literal">classView</code> is straightforward to use. It's imported and rendered. The store state handling is encapsulated within the <code class="literal">view</code> module. The <code class="literal">FunctionView</code> React component on the other hand, needs to be <a id="id293" class="indexterm"/>set up with a handler function that's called when <code class="literal">myStore</code> changes state. Technically, this isn't a static view, because it's a function that's called whenever <code class="literal">React.render()</code> is called. However, in the context of Flux, it does behave <a id="id294" class="indexterm"/>a lot like a static view, because it's the React rendering system that handles the creation and destruction of view components—our code isn't creating or destroying anything—only passing components to <code class="literal">render()</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Scaling information</h1></div></div></div><p>As you've seen so far <a id="id295" class="indexterm"/>in this chapter, Flux doesn't try to scale things that don't need to be scaled. For example, stores and views are often created just once during startup. Trying to clean these components repeatedly as the application changes state over time is simply error-prone. It's scaling the information that Flows through our Flux components that will knock our system over if we're not careful.</p><p>We'll start this section off with a look at how our Flux architectures can scale well on their own, without massive amounts of data entering the system. This also serves to illustrate the idea that these are in fact two separate problems—scaling the infrastructure of our Flux components versus scaling the volume of data that our architecture is able to process. Then, we'll discuss <a id="id296" class="indexterm"/>the topic of designing our user interfaces for less information, to make the design process of scalable components straightforward. We'll explore the role of Flux actions when it comes time to scale our system up to the next level.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>What scales well?</h2></div></div></div><p>As our application grows, it needs to <a id="id297" class="indexterm"/>scale in response to things like new feature requests, and growing datasets. The question is, which of these scaling issues is most deserving of our attention? It should be the issue with the highest potential to topple our system. Generally speaking, this has more to do with the input data than it does with the configuration of our Flux components. For instance, there's a potential scaling issue if we're processing input data in polynomial time instead of logarithmic time.</p><p>This is why our Flux architecture doesn't need to concern itself with lifecycles and maintaining the plumbing between components the same way other architectures do. Will having a lot of components occupy more memory than they need to and is this expensive in terms of performance? Sure, this is always a consideration—we don't want to have more components then we <a id="id298" class="indexterm"/>need. In practice, this type of overhead is hardly noticeable by users. Let's take look at the impact a large component infrastructure has on performance. First, the view:</p><div><pre class="programlisting">// A really simple view...
export default class MyView {
  constructor(store) {

    // Do nothing except verify that there's
    // a "result" state property.
    store.on('change', ({ result }) =&gt; {
      console.assert(
        Number.isInteger(result),
        'MyView'
      );
    });
  }
}</pre></div><p>There's nothing much to this view because there doesn't need to be. We're not testing the rendering performance of the view itself—we're testing the scalability of the architecture. So all that's required is that the view exists and can listen to a store. We're passing the store instance in through the constructor because we're creating several instances of this view that listen to different stores, as we'll see here in a moment. Let's look at the store code next:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { MY_ACTION } from '../actions/my-action';

// We're exporting the store class instead of
// an instance from this module because the
// main module will create a bunch of them.
export default class MyStore extends EventEmitter {
  constructor() {
    super();

    // The EventEmitter thinks we're leaking memory
    // there's too many listeners. This circumvents
    // the limitation.
    this.setMaxListeners(5000);

    this.state = {};

    this.id = dispatcher.register((e) =&gt; {
      let {state} = this;

      // Perform some basic arithmetic before emitting
      // the "change" event with the "result" state
      // property.
      switch(e.type) {
        case MY_ACTION:
          state.result = 100000 * e.payload;
          this.emit('change', state);
          break;
      }
    });
  }
}</pre></div><p>This is a pretty basic store that does a pretty basic calculation when <code class="literal">MY_ACTION</code> is dispatched. Again, this is <a id="id299" class="indexterm"/>intentional. Now let's see how these components can scale in a Flux architecture without much data:</p><div><pre class="programlisting">import MyStore from './stores/my-store';
import MyView from './views/my-view';
import { myAction } from './actions/my-action';

// Holds onto our store and view references...
var stores = [];
var views = [];

// How many items to create and actions to
// dispatch...
var storeCount = 100;
var viewCount = 1000;
var actionCount = 10;

// Setup our Flux infrastructure. This establishes
// all the relevant store listeners and view
// listeners. They all stay active throughout the
// lifetime of the application.
console.time('startup');
for (let i = 0; i &lt; storeCount; i++) {
  let store = new MyStore();
  stores.push(store);

  for (let i = 0; i &lt; viewCount; i++) {
    views.push(new MyView(store));
  }
}
console.timeEnd('startup')
// → startup: 26.286ms

console.log('stores', stores.length);
console.log('views', views.length);
console.log('actions', actionCount);
// →
// stores 100
// views 100000
// actions 10

// Dispatches the actions. This is where we either
// succeed or fail at scaling the architecture.
console.time('dispatch');
for (let i = 0; i &lt; actionCount; i++) {
  myAction();
}
console.timeEnd('dispatch');
// → dispatch: 443.929ms</pre></div><p>We're measuring the startup <a id="id300" class="indexterm"/>cost of creating these components and setting up their listeners, because this will typically add to the startup cost of a Flux application. But as we can see here, getting all these components ready is inconsequential in terms of user experience. The big test comes when the actions are dispatched.</p><p>This setup causes one million view render calls to happen, and it takes about half a second. This is the plumbing <a id="id301" class="indexterm"/>in the wall of our application, and it really doesn't benefit us to tear it down and set it all back up again later. This aspect of the architecture scales well. It's the data that enters the system, and the logic that operates on it that's the real scaling challenge. If we have to run this same test again with an action payload of a 1000 item array that was sorted by the store, we might have a problem.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>We'll address more fine-grained performance testing scenarios in <a class="link" href="ch13.html" title="Chapter 13. Testing and Performance">Chapter 13</a>, <em>Testing and Benchmarking</em>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Minimal information required</h2></div></div></div><p>As you just saw, the <a id="id302" class="indexterm"/>notion that Flux components and their connections can be statically-defined is valid. At least, in terms of scaling challenges, having static plumbing in place isn't going to be the thing that knocks our system down when we try to scale it. It's the data that flows into the system, and the means by which we transform it into information for the user. This is the thing that's very difficult to scale, and so, it's best that we do as little of it as possible.</p><p>It may sound trivially obvious at first, but having less information to display scales well. This can easily be overlooked because we're out to build features, not to measure the volume of information output from our views. Sometimes, this is the most effective way, or possibly the only way, to fix scaling problems.</p><p>When we're designing a Flux architecture for our application, we have to keep information scalability in mind. Often, the best angle to look at the problem is from the UI itself. If there's a way that we can axe certain things, in an effort to reduce clutter, we also reduce the amount of information that views need to generate. Potentially, we can remove an entire data flow from our application simply by changing what the user sees. Lean user interfaces scale well.</p><p>Something else to be on the lookout for is information that leaks out of store components. By this, I mean information that a store generates for no real purpose. This could have been something that used to be relevant to how the view worked, but when the feature changed, we forgot to take out the relevant information. Or, it could simply be an oversight in the design—we're generating information that the view doesn't actually need, and its been this way from day one. These problems are difficult to spot, but easy to fix. The only foolproof approach is to periodically audit our views to ensure that they're consuming the information that they need and nothing more.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Actions that scale</h2></div></div></div><p>Actions are the <a id="id303" class="indexterm"/>gatekeepers of any data that wants to enter our Flux system—if it's not an action payload, then it's not data that we care about. Action creator functions aren't problematic to scale, as they don't do much. The most complex aspect of an action creator function is managing asynchronous behavior, if necessary. But this isn't a fundamental scaling problem, every JavaScript application has asynchronous components. There's two fundamental ways that actions can thwart our scaling efforts.</p><p>The first is having too many <a id="id304" class="indexterm"/>actions. This means that there's more opportunity for programmer error due to all the possibilities. It becomes less obvious which action creator should be used in which context. The same problem can happen when there are few actions and too many action creator parameters. This directly inhibits our ability to get the right data into the stores of our application.</p><p>The second way that actions can stumble when we try to scale our system is that the action creator functions are doing too much. For example, an action creator function might try to filter out some of the API response data in an effort to slim down the data that's handed off to the stores through the dispatcher. This is hugely problematic, because it violates the Flux rule that all state and all logic that changes state belongs in stores.</p><p>It's understandable how something like this can happen though, when under pressure to scale an application, the most obvious place to fix data problems is at the source. In this case, the source is the handler of the AJAX response. The better way to handle this is to tweak the API itself and have the action creator function supply the appropriate parameters to get the <a id="id305" class="indexterm"/>smaller set of data. When state transformations <a id="id306" class="indexterm"/>move outside of stores in the frontend, we reduce the likelihood of scaling successfully because we increase the likelihood of other issues taking place.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Inactive stores</h1></div></div></div><p>In the previous section, we <a id="id307" class="indexterm"/>explored the idea that we can have a relatively static component infrastructure in our Flux architecture. This isn't something that causes concerns about scalability. Rather, it's the large amounts of data that's held in our stores. In this final section, we'll cover some scenarios in which we have a store with lots of data as its state, and we don't want our application to become memory-bloated.</p><p>The first approach involves deleting the data from the store, freeing resources. We can take this approach a step further by adding heuristics to our store logic that determines that nothing has changed and there's no need to touch the DOM by emitting a change event. Finally, we'll talk about some of the side-effects caused by deleting store data and how to deal with them.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Deleting store data</h2></div></div></div><p>Something we have to <a id="id308" class="indexterm"/>think long and hard about with our Flux components is how data that enters the system will eventually exit the system. If we only put data in without taking any of it out, we've got a problem. In fact, this activity is fundamental to Flux architectures, because removing data from store states is also how we remove other data structures, such as DOM nodes and event handler functions.</p><p>Earlier in the chapter, we saw that by emptying an array, we could tell the view to remove UI elements. This is essentially how we scale Flux applications—by removing the data that has potential to cause scaling headaches. Imagine a store that had a collection with thousands of items in it. This collection would not only be expensive to process as is, but it also has the potential to grow much larger.</p><p>The simple solution is to empty this collection out when it's no longer needed. Let's revisit this approach. First, here's what the view looks like:</p><div><pre class="programlisting">import React from 'react';
import { hideAll, hideOdd } from '../actions/hide';

// The view function, renders a button
// that deletes store data by dispatching
// the "HIDE_ALL" action, and renders a list
// of items. The hide odds button only deletes
// some store data by dispatching the "HIDE_ODD"
// action.
export default ({ items }) =&gt; (
  &lt;div&gt;
    &lt;button onClick={hideAll}&gt;Hide All&lt;/button&gt;
    &lt;button onClick={hideOdd}&gt;Hide Odd&lt;/button&gt;
    &lt;ul&gt;
      {items.map(item =&gt;
        &lt;li key={item}&gt;{item}&lt;/li&gt;
      )}
    &lt;/ul&gt;
  &lt;/div&gt;
);</pre></div><p>A couple of buttons <a id="id309" class="indexterm"/>and a list of items—pretty simple. When a button is clicked, it calls an action creator function. Let's turn our attention to the store now:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { HIDE_ALL, HIDE_ODD } from '../actions/hide';

class MyStore extends EventEmitter {
  constructor() {
    super();

    // The initial state is an "items" array
    // of 100 numbers.
    this.state = {
      items: new Array(100)
        .fill(null)
        .map((x, y) =&gt; y)
    };

    this.id = dispatcher.register((e) =&gt; {
      let { state } = this;

      switch(e.type) {

        // When the "HIDE_ALL" action is dispatched,
        // the "items" state is reset back to
        // an empty array.
        case HIDE:
          state.items = []
          this.emit('change', state);
          break;

        // When the "HIDE_ODD" action is dispatched,
        // the "items" state is filtered to include
        // only even numbers.
        case HIDE_ODD:
          state.items = state.items.filter(
            x =&gt; !(x % 2));
          this.emit('change', state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>The <code class="literal">HIDE_ALL</code> action simply deletes all the items by assigning an empty array. This is exactly what we're after—deleting data when it's no longer needed. This is the real scaling challenge, cleaning up data that has the potential to be big and expensive to process. The <a id="id310" class="indexterm"/>
<code class="literal">HIDE_ODD</code> action is a variation that filters out even numbers. Lastly, let's see how this all comes together in <code class="literal">main.js</code>:</p><div><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

import myStore from './stores/my-store';
import MyView from './views/my-view';

// The DOM container for the React view...
var container = document.getElementById('my-view');

// Renders the functional "MyView" React
// component.
function renderView(state) {
  render(
    &lt;MyView
      items={state.items}/&gt;,
    container
  );
}

// Re-render the React component when the store
// state changes.
myStore.on('change', renderView);

// Perform the initial render.
renderView(myStore.state);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Optimizing inactive stores</h2></div></div></div><p>One potential scaling issue <a id="id311" class="indexterm"/>with the setup we've used in the preceding example is that the view itself performs some expensive computation. For example, we can't rule out the possibility that even with an empty array as the supplied information to render, the view has some implementation issues. This is problematic in a Flux architecture, because actions are always being dispatched to stores, which in turn notify views that are listening to them. So it's important that views are fast.</p><p>This is where React fits really well into Flux. React components are meant to be re-rendered in a top–down fashion, from the root component all the way down to the leaves. It's able to do this efficiently because of the virtual DOM it uses under the hood to compute patches that are then applied to the real DOM. This eliminates many performance issues because issuing a lot of DOM API calls is a performance bottleneck. On the other hand, it would be slightly naive to assume that the store will be publishing changes to an efficient React component.</p><p>Stores are responsible for emitting change events when the time is right. Therefore, we could determine within the store that when a given action is dispatched, there's no need to emit a change event. This would involve some sort of heuristic that would determine that the view is already <a id="id312" class="indexterm"/>displaying the appropriate information given the state of the store, and that emitting a change event now would be of no value. By doing this, we could avoid any performance challenges in the view. The problem with this approach is that we're building up complexity in our store. It's probably better that we emit change events consistently and deal with views that are doing things inefficiently. Or if we're not using React as the view layer yet, perhaps this is an argument in favor of doing so.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>In the next chapter, we'll look at implementing advanced change detection heuristics in our view components.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Keeping store data</h2></div></div></div><p>In this chapter, you've <a id="id313" class="indexterm"/>seen how to remove data from stores in a way that scales well. If the user has moved from one part of the user interface to another, then we likely want to delete any store data that's no longer needed in this new section. The idea is that rather than take out all of our JavaScript components, we focus on the data in our stores, the aspect of our application that's the most difficult to scale. However, there's a potential problem with this approach that we need to consider.</p><p>What happens if another store depends on the data that we've just removed? For example, the user is on a page that's driven by state from store A. They then move on to another page, which is driven by store B, which depends on store A. But we've just deleted the state inside of store A—isn't this going to be a problem for store B?</p><p>This isn't a common case—the majority of our stores won't have any dependencies, and we should be safe to delete unused data. However, we need to come up with a game plan for stores that do have dependencies. Let's walk through an example and start with the views. First, we have the radio button view, which is a simple control that allows the user to toggle from a list of <a id="id314" class="indexterm"/>users to a list of groups:</p><div><pre class="programlisting">import React from 'react';
import { id } from '../util';
import { showUsers, showGroups } from '../actions/show';

// This react view displays the two radio
// buttons that determine which list to display.
// Note that they're both using "map()" even
// though it's a single item array. This is to
// keep the logic in the store and out of the view.
export default ({ users, groups }) =&gt; (
  &lt;div&gt;
    {users.map(user =&gt;
      &lt;label key={id.next()}&gt;
        {user.label}
        &lt;input
          type="radio"
          name="display"
          checked={user.checked}
          onChange={showUsers}
        /&gt;
      &lt;/label&gt;
    )}
    {groups.map(group =&gt;
      &lt;label key={id.next()}&gt;
        {group.label}
        &lt;input
          type="radio"
          name="display"
          checked={group.checked}
          onChange={showGroups}
        /&gt;
      &lt;/label&gt;
    )}
  &lt;/div&gt;
);</pre></div><p>The change event for both radio buttons is hooked up to an action creator function, which affects the display of our two <a id="id315" class="indexterm"/>other views—we'll look at these next, starting with the user list view:</p><div><pre class="programlisting">import React from 'react';

// A simple React view that displays a list of
// users.
export default ({ users }) =&gt; (
  &lt;ul&gt;
    {users.map(({ name, groupName }) =&gt;
      &lt;li key={name}&gt;{name} ({groupName})&lt;/li&gt;
    )}
  &lt;/ul&gt;
);</pre></div><p>Pretty straightforward, and you can see that there's a group dependency here, as we're displaying the group <a id="id316" class="indexterm"/>that the user belongs to. We'll dig into that dependency momentarily, but for now, let's look at the group list view:</p><div><pre class="programlisting">import React from 'react';

// A simple React view that displays a list
// of groups...
export default ({ groups }) =&gt; (
  &lt;ul&gt;
    {groups.map(group =&gt;
      &lt;li key={group}&gt;{group}&lt;/li&gt;
    )}
  &lt;/ul&gt;
);</pre></div><p>Now, let's take a look at the stores that drive these views, starting with the radio button store:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';

import { SHOW_USERS, SHOW_GROUPS } from '../actions/show';

class Radio extends EventEmitter {
  constructor() {
    super();

    // This store represents radio buttons for
    // the "users" and "groups" display. Each
    // is represented as an array so that we can
    // easily take the take the button out of
    // the view by emptying the array.
    this.state = {
      users: [{
        label: 'Users',
        checked: true
      }],
      groups: [{
        label: 'Groups',
        checked: false
      }]
    };

    this.id = dispatcher.register((e) =&gt; {

      // Easy access to the state properties
      // we need in this handler. See the two
      // getter methods below.
      let { users, groups } = this;

      switch(e.type) {

        // Mark the "users" display as "checked".
        case SHOW_USERS:
          users.checked = true;
          groups.checked = false;

          this.emit('change', this.state);
          break;

        // Mark the "groups" display as "checked".
        case SHOW_GROUPS:
          users.checked = false;
          groups.checked = true;

          this.emit('change', this.state);
          break;
      }
    });
  }

  // A shortcut for easy access to the "users" state.
  get users() {
    return this.state.users[0]
  }

  // A shortcut for easy access to the "groups" state.
  get groups() {
    return this.state.groups[0]
  }
}

export default new Radio();</pre></div><p>You can see here that we're using the single-item array technique once again. This is why we have the <code class="literal">map()</code> call in the view that uses this store's data. The idea is that to hide one of these buttons, we can do it right here in the store by setting it to an empty collection—keeping logic out of the <a id="id317" class="indexterm"/>view. Notice that we've set up some basic getter functions to make dealing with these single-item arrays easier as well. Now let's check out the groups store:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { SHOW_GROUPS } from '../actions/show';

class Groups extends EventEmitter {
  constructor() {
    super();

    // The default "_group" state is an array of group
    // names.
    this.state = {
      _groups: [
        'Group 1',
        'Group 2'
      ]
    };

    // The "groups" state is what's actually used
    // by views and is an empty array by default
    // because nothing is displayed by default.
    this.state.groups = [];

    this.id = dispatcher.register((e) =&gt; {
      let { state } = this;

      switch(e.type) {

        // The "SHOW_GROUPS" action will map the
        // "_groups" state to the "groups" state
        // so that the view has something to display.
        case SHOW_GROUPS:
          state.groups = state._groups.map(x =&gt; x);
          this.emit('change', state);
          break;

        // By default, the "groups" state is emptied,
        // which clears out the view's elements. The
        // "_groups" state, however, remains intact.
        default:
          state.groups = [];
          this.emit('change', state);
          break;
      }
    });
  }
}

export default new Groups();</pre></div><p>This store has two pieces of state—<code class="literal">_groups</code> and <code class="literal">groups</code>. Yes, they're basically the same thing. The difference is that the view depends on <code class="literal">groups</code>, not on <code class="literal">_groups</code>. The <code class="literal">Groups</code> store is able to compute the <a id="id318" class="indexterm"/>groups state based on <code class="literal">_groups</code>. This means that we can safely delete the <code class="literal">groups</code> state to update the view rendering while the <code class="literal">_groups</code> state isn't touched. Other stores can depend on this store now, without risk of any data disappearing. Let's take a look at the users store now:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import groups from './groups';
import { SHOW_USERS } from '../actions/show';

class Users extends EventEmitter {
  constructor() {
    super();

    // The default state of the "_users" state is
    // an array of user objects with references to
    // groups from another store.
    this.state = {
      _users: [
        { name: 'User 1', group: 1 },
        { name: 'User 2', group: 0 },
        { name: 'User 3', group: 1 }
      ]
    };

    // Sets the "users" state array, the state
    // that's actually used by views. See
    // "mapUsers()" below.
    this.mapUsers();

    this.id = dispatcher.register((e) =&gt; {
      let { state } = this;

      switch(e.type) {

        // If we're showing users, we need to "waitFor()"
        // the "groups" store because we depend on it.
        // Then we can use "mapUsers()" again.
        case SHOW_USERS:
          dispatcher.waitFor([ groups.id ]);

          this.mapUsers();

          this.emit('change', state);
          break;

        // The default action is to empty out
        // the "users" state so that the view
        // will delete the UI elements. However, the
        // "_users" state remains, so that other stores
        // that depend on this one can still access
        // the data.
        default:
          state.users = [];
          this.emit('change', state);
          break;
      }
    });
  }

  // Maps the "_users" state to the "users" state.
  // The idea being that the "users" array can be
  // emptied to update view displays while the "_users"
  // array remains intact for other stores to use.
  mapUsers() {
    this.state.users = this.state._users.map(user =&gt;
      Object.assign({
        groupName: groups.state._groups[user.group]
      }, user)
    );
  }
}

export default new Users();</pre></div><p>You can see that the <code class="literal">Users</code> store is able to depend on the <code class="literal">_groups</code> state from the <code class="literal">Groups</code> store in order to build the state that's needed by the user list view. This store follows the same pattern as the <code class="literal">Groups</code> store in that it has a <code class="literal">_users</code> state and a <code class="literal">users</code> state. This allows for other views to <a id="id319" class="indexterm"/>depend on <code class="literal">_users</code> if necessary, and we can still wipe the <code class="literal">users</code> state to clear the UI. However, if it turns out that nothing is dependent on this store, we can revert the pattern so that there's only one piece of state that's deleted when no longer required by the current view. Lastly, let's take a look at the <code class="literal">main.js</code> module and see how this all fits together:</p><div><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

import radio from './stores/radio';
import users from './stores/users';
import groups from './stores/groups';

import Radio from './views/radio';
import Users from './views/users';
import Groups from './views/groups';

// The container DOM element...
var container = document.getElementById('app');

// Renders the React components. The state for the
// Flux stores are passed in as props.
function renderApp(
  radioState=radio.state,
  usersState=users.state,
  groupsState=groups.state
) {
  render(
    &lt;div&gt;
      &lt;Radio
        users={radioState.users}
        groups={radioState.groups}/&gt;
      &lt;Users
        users={usersState.users}/&gt;
      &lt;Groups
        groups={groupsState.groups}/&gt;
    &lt;/div&gt;,
    container
  );
}

// Renders the app with the new "radio" state.
radio.on('change', (state) =&gt; {
  renderApp(state, users.state, groups.state);
});

// Renders the app with the new "users" state.
users.on('change', (state) =&gt; {
  renderApp(radio.state, state, groups.state);
});

// Renders the app with the new "groups" state.
groups.on('change', (state) =&gt; {
  renderApp(radio.state, users.state, state);
});

// Initial app rendering...
renderApp();</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Summary</h1></div></div></div><p>The focus of scaling a Flux architecture is on the information that stores produce, rather than the various components. This chapter started with a discussion on the common practices of other architectures that involve the constant creation and destruction of JavaScript components. This is done to free resources, but it comes at a cost—the potential for error. Next, we looked at the relatively static nature of Flux architectures, where components have a long life. They don't have to constantly create and destroy components, which means that there's less potential for issues.</p><p>Next, we covered the concept of scaling information. We did so by demonstrating that our JavaScript components and the connections between them were the least of our worries when it comes to scaling the architecture. The real challenge comes when there's a lot of data to process, and the data that enters the system is likely to grow much faster than the number of JavaScript components we have.</p><p>We closed the chapter with some examples of how to deal with unused store data. This is ultimately the most important aspect of scaling a Flux architecture since it gives the browser back unused resources. In the next chapter, we'll tackle the topic of immutable stores. This is something we've alluded to throughout the book, and we'll give it some focused attention now.</p></div></body></html>