<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making Types That Can Slot into Any Other Type</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw how to express types for values that have the potential to be one of several different things at runtime. At certain times in the last chapter, and throughout the book so far, we came up against types that Reason marked as <em>to be filled in later</em>. In this chapter, we will cover these types more in more detail, specifically the following topics:</p>
<ul>
<li>Reason's generic type inference</li>
<li>What<span> are</span> type parameters?</li>
<li>Common parameterized types such as lists, options, and arrays</li>
<li>Adding parameters to sum and product types</li>
<li>Type inference restrictions on parameterized mutable types</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference and generic types</h1>
                </header>
            
            <article>
                
<p>Let's look at a few interesting examples of Reason's type inference and how it decides what types need to be <em>filled in later</em>, as illustrated in the following snippet:</p>
<pre>/* src/Ch06/Ch06_GenericInference.re */<br/><span class="underline">let</span> <em>triple</em>(<em>x</em>) = (<em>x</em>, <em>x</em>, <em>x</em>); /* (1) */<br/><span class="underline">let</span> <em>wrap</em>(<em>x</em>) = `<em>wrap</em>(<em>x</em>); /* (2) */<br/><span class="underline">let</span> <em>makeObj</em>(<em>x</em>) = {<span class="underline">as</span> _; <span class="underline">pub</span> <em>x</em> = <em>x</em>}; /* (3) */<br/><span class="underline">let</span> <em>greet</em>(<em>x</em>) = <em>print_endline</em>({j|Hello, $<em>x</em>!|j}); /* (4) */</pre>
<p class="mce-root"/>
<p>These examples all have something in common: the compiler doesn't have quite enough information to infer their <em>concrete</em> types. Instead, it infers what it can about their general shape but leaves some parts as <em>generic</em>. We can observe the following:</p>
<ol>
<li>In (1), the type is inferred as <kbd>'a =&gt; ('a, 'a, 'a)</kbd>.</li>
<li>In (2), the type is inferred as <kbd>'a =&gt; [&gt; `wrap('a)]</kbd>.</li>
<li>In (3), the type is inferred as <kbd>'a =&gt; {. x: 'a}</kbd>.</li>
<li>In (4), the type is inferred as <kbd>'a =&gt; unit</kbd>.</li>
</ol>
<p>In each of these cases, the compiler infers some of the types as <kbd>'a</kbd>, or in other words, <em>I don't know yet</em>. Let's look at the first case, the <kbd>triple</kbd> function, to try to understand why.</p>
<p>In <kbd>triple</kbd>, the function parameter is <kbd>x</kbd> and the function body is <kbd>(x, x, x)</kbd>. Given these two facts, the compiler tries to infer (that is, narrow down) the type of <kbd>triple</kbd> by working its way up from each part of the function parameter and body. Let's look at what we can infer from each part of <kbd>triple</kbd>:</p>
<ul>
<li>From the <span><kbd>x</kbd> </span>parameter: Nothing, so we mark its type as (a generic type) <kbd>'a</kbd></li>
<li>From the body, <kbd>(x, x, x)</kbd>: We already marked the type of <kbd>x</kbd> as <kbd>'a</kbd>, so we mark the type of the body as <kbd>('a, 'a, 'a)</kbd>, that is, a tuple type consisting of three elements all of the same type</li>
<li>From the overall function: We marked the parameter as type <kbd>'a</kbd>, and the body as type <kbd>('a, 'a, 'a)</kbd>, so we infer the function as a whole to have type <kbd>'a =&gt; ('a, 'a, 'a)</kbd></li>
</ul>
<p>Notice that, if anything, this seems like a process of elimination, or a process of solving a Sudoku puzzle. We narrow down the types as much as we can based on what we know until we can't narrow them down any further. This is the same inference and unification process we're familiar with from previous chapters where we encountered various type errors, but with generic types we see a new dimension to the type system.</p>
<div class="packt_infobox">Reason's type inference process is a famous one, known as <strong>Hindley-Milner (H-M)</strong> type inference<em>;</em> it's a mathematics-specific way of examining any given expression to try to deduce the most general type that will fit the expression. We won't delve into the theory here, but we will cover the practicalities of working with H-M type inference.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>By examining the type inference process for <kbd>triple</kbd>, we can see how the inference works for <kbd>wrap</kbd>, <kbd>makeObj</kbd>, and <kbd>greet</kbd>. The key point to understand is that each of these functions has a body expression that doesn't use any specific property of its input parameter; instead, the body composes the input parameter inside a larger expression that uses the value in a generic way that doesn't expose any information about the type itself. For example, imagine being given some object (you don't know what) and immediately putting it inside a box; you still don't know what the object is, you just know you now have a box that contains some object. This is how generic type inference works for structural types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The special case of interpolation</h1>
                </header>
            
            <article>
                
<p>Out of the functions we've mentioned, <kbd>greet</kbd> is a bit special because type inference doesn't work in quite the same way as it does for the others. For the first three functions, inference arrives at a generic type because the parameters are used in structurally-typed expressions. For <kbd>greet</kbd> though, the <span><kbd>x</kbd> </span>parameter  is interpolated into a string; however, strings aren't structurally typed! What's going on is that string interpolation is a special escape hatch provided by the BuckleScript compiler that allows you to turn any value into a string, but only when targeting JavaScript.</p>
<p>The key point here is turning any value into a string. We can think of this behavior as a function, <kbd>'a =&gt; string</kbd>. Since we then print the string with <kbd>print_endline</kbd>, the final result type is <kbd>unit</kbd>; so the overall type is <kbd>'a =&gt; unit</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type parameters</h1>
                </header>
            
            <article>
                
<p>We've seen that type checking goes through an algorithmic process of working out the most general possible type of any given expression, and when the expression is structurally typed, such as <kbd>let pair(x) = (x, x)</kbd>, it can infer types that are parameterized (such as <kbd>'a =&gt; ('a, 'a)</kbd>) because it doesn't know, or doesn't need to know, exactly what they are.</p>
<p>A <strong>type parameter</strong> is an as-yet-unknown type that will be specified later in use. Reason supports type parameters on all types, including nominal types. This gives record and variant types a new dimension (literally) of data modeling power. Let's now explore a few of the most basic but also important parameterized data types in Reason.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The list – modeling more than one</h1>
                </header>
            
            <article>
                
<p>We've already seen how to model a list of person records in <a href="d3723975-7a3c-4369-84fe-272b67870234.xhtml">Chapter 5</a>, <em>Putting Alternative Values in Types,</em> but that data structure was limited to holding only values of person records. Ideally, we want a data structure that can hold values of <em>any</em> type, so that we don't have to re-implement the type and its operations for every possible element type. We can accomplish this by parameterizing the list type by the element type, as follows:</p>
<pre>/* src/Ch06/Ch06_List.re */<br/><span class="underline">type</span> <strong>list</strong>(<strong>'a</strong>) = <em>Cons</em>(<strong>'a</strong>, <strong>list</strong>(<strong>'a</strong>)) | <em>Empty</em>; /* (1) */<br/><br/>/* (2) */<br/><span class="underline">let</span> <em>people</em> = <em>Ch04_RecordLiterals</em>.(<em>Cons</em>(<em>bob</em>, <em>Cons</em>(<em>jim</em>, <em>Cons</em>(<em>tom</em>, <em>Empty</em>))));<br/><br/>/* (3) */<br/><span class="underline">let</span> <em>greetOne</em>({<em>Ch04_RecordLiterals.id</em>, <em>name</em>}) = <em>print_endline</em>(<br/> {j|Hello, $<em>name</em> with ID $<em>id</em>!|j});<br/><br/><span class="underline">let</span> <span class="underline">rec</span> <em>greetAll</em>(<em>people</em>) = <span class="underline">switch</span> (<em>people</em>) {<br/>| <em>Cons</em>(<em>person</em>, <em>people</em>) =&gt; { /* (4) */<br/> <em>greetOne</em>(<em>person</em>);<br/> <em>greetAll</em>(<em>people</em>)<br/> }<br/>| <em>Empty</em> =&gt; () /* (5) */<br/>};</pre>
<p>The previous example shows how to generically hold objects of any given type, as well as do something specific with them. It is explained as follows:</p>
<ol>
<li>Here, we parameterize a nominal type (a variant type to be precise), <kbd>list</kbd>, with an explicit type parameter, <kbd>'a</kbd> (pronounced 'alpha'). Here we have only one, but types can have multiple type parameters. The syntax for declaring type parameters is <kbd>type typeName('param1, 'param2, ..., 'paramN)</kbd>. Note that type parameters must always start with the tick (<kbd>'</kbd>) character to distinguish them from regular types. Type parameters are also known as type variables.</li>
<li>We construct a list made up of <kbd>person</kbd> records we defined in a previous module. The compiler can infer its type to be <kbd>list(Ch04_RecordLiterals.person)</kbd>, because we slotted in the person type at the exact places where we declared the type parameter, <kbd>'a</kbd>.</li>
<li>We define how to greet a single person. This operation doesn't make use of type parameters in any way, but it is a building block for a later operation that does.</li>
</ol>
<ol start="4">
<li>Inside <kbd>greetAll</kbd>, we have an interesting pattern match on <kbd>people</kbd>. With the <kbd>Cons(person, people)</kbd> and <kbd>Empty</kbd> branches, the compiler infers that <kbd>people</kbd> has type <kbd>list('a)</kbd>, and with <kbd>greetOne(person)</kbd>, it infers that <kbd>'a = person</kbd>; overall the function has the type <kbd>list(person) =&gt; unit</kbd>.</li>
<li>
<p>When we reach the end of the list, we don't want to do anything else, so we just return <kbd>()</kbd>. </p>
</li>
</ol>
<p>Now that we've seen how to build and operate on a polymorphic data type, let's look at Reason's built-in implementation of the <kbd>list</kbd> type. The built-in implementation works in much the same way as the one mentioned earlier, except Reason provides some nice syntactic sugar to make it easier to work with lists. Let's take a look at the following snippet:</p>
<pre>/* src/Ch06/Ch06_ReasonList.re */<br/><span class="underline">let</span> <em>people</em> = <em>Ch04_RecordLiterals</em>.[<em>bob</em>, <em>jim</em>, <em>tom</em>]; /* (1) */<br/><br/><span class="underline">let</span> <span class="underline">rec</span> <em>greetAll</em>(<em>people</em>) = <span class="underline">switch</span> (<em>people</em>) {<br/>| [<em>person</em>, ...<em>people</em>] =&gt; { /* (2) */<br/>    <em>Ch06_List.greetOne</em>(<em>person</em>); /* (3) */<br/>    <em>greetAll</em>(<em>people</em>)<br/>  }<br/>| [] =&gt; () /* (4) */<br/>};</pre>
<p>First of all, notice that we got rid of the type declaration, since the Reason <kbd>list('a)</kbd> type is already built in and accessible from every module. To be precise, it's defined in the <kbd>Pervasives</kbd> module, whose contents are by default accessible from every module.</p>
<ol>
<li>We use the list construction syntactic sugar, which is <kbd>[elem1, elem2, ... elemN]</kbd>, to construct a list that is essentially like our previous one <kbd>Cons(elem1, Cons(elem2, ... Cons(elemN, Empty) ... ))</kbd>. The brackets-and-commas syntax is flatter and easier to understand.</li>
<li>Pattern matching on a list now looks like <kbd>[elem, ...restElems]</kbd> to bind to the first element and the list of remaining elements. The <kbd>...</kbd> is called the <strong>spread operator</strong> and is designed to look like JavaScript's array spread feature, which works similarly.</li>
<li>We reuse the <kbd>greetOne</kbd> function we already defined since it doesn't depend on the specific list type—it just greets a single person.</li>
<li>The empty list pattern now looks like <kbd>[]</kbd> instead of <kbd>Empty</kbd>.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Notice how succinct the list syntax is overall. It's designed for everyday use because lists are one of the most important data types in Reason, and in functional programming in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The option – modeling either none or one</h1>
                </header>
            
            <article>
                
<p>In a similar way to <kbd>list('a)</kbd>, the <kbd>Pervasives</kbd> module also provides a data type, <kbd>option('a)</kbd>. This time let's look at its real definition, because there's no syntactic sugar for it, as follows:</p>
<pre><span class="underline">type</span> <strong>option</strong>(<strong>'a</strong>) = <em>Some</em>(<strong>'a</strong>) | <em>None</em>;</pre>
<p>In some ways, this is a simpler data type than the list. Its real utility comes from the meaning we give to the variant cases:</p>
<ul>
<li><kbd>Some('a)</kbd>: Represents a value that is present and that is known</li>
<li><kbd>None</kbd>: Represents a value that is absent and is unknown</li>
</ul>
<p class="mce-root"/>
<p>In Reason, and some other languages, there is no concept of a null value, so this option type is used to represent that a value is present or absent. Whenever we'd use null, we can use options instead, with the benefit that optionality<em> </em>(the property that some value may be present or not) is captured in the type system, instead of behind the scenes. Because the <kbd>option</kbd> type is a variant, the compiler helps us to handle possible missing values through exhaustivity checking. There's no danger of forgetting to handle a null value and crashing at runtime.</p>
<p>Present and absent may still be somewhat vague concepts, so the following code is a more concrete example where we try to find a matching value in a list:</p>
<pre>/* src/Ch06/Ch06_Option.re */<br/><span class="underline">let</span> <span class="underline">rec</span> <em>tryFind</em>(<em>needle</em>, <em>haystack</em>) = <span class="underline">switch</span> (<em>haystack</em>) { /* (1) */<br/>| [<em>item</em>, ...<em>_items</em>] <span class="underline">when</span> <em>needle</em>(<em>item</em>) =&gt; <em>Some</em>(<em>item</em>) /* (2) */<br/>| [<em>_item</em>, ...<em>items</em>] =&gt; <em>tryFind</em>(<em>needle</em>, <em>items</em>) /* (3) */<br/>| [] =&gt; <em>None</em> /* (4) */<br/>};<br/><br/><span class="underline">let</span> <em>optionallyGreet</em>(<em>person</em>) = <span class="underline">switch</span> (<em>person</em>) { /* (5) */<br/>| <em>Some</em>(<em>person</em>) =&gt; <em>Ch06_List.greetOne</em>(<em>person</em>)<br/>| <em>None</em> =&gt; <em>print_endline</em>("No such person!")<br/>};<br/><br/><span class="underline">let</span> <em>idEq1</em>({<em>Ch04_RecordLiterals.id</em>}) = <em>id</em> == 1; /* (6) */<br/><span class="underline">let</span> <em>idEq4</em>({<em>Ch04_RecordLiterals.id</em>}) = <em>id</em> == 4;<br/><br/><em>optionallyGreet</em>(<em>tryFind</em>(<em>idEq1</em>, <em>Ch06_ReasonList.people</em>)); /* (7) */<br/><em>optionallyGreet</em>(<em>tryFind</em>(<em>idEq4</em>, <em>Ch06_ReasonList.people</em>));</pre>
<p>In this example, we define how to find an item in a list and safely handle the case of a missing item:</p>
<ol>
<li>We pass in a list to search (called <kbd>haystack</kbd>) and a tester function (called <kbd>needle</kbd>) that tells us if we've found the value we're looking for. Since <kbd>haystack</kbd> is a list, we can pattern match on it.</li>
<li>The first pattern looks at the first element of the list to see if it's the one we want, as determined by <kbd>needle</kbd>. We don't want to bind the rest of the elements, so we prefix the <kbd>_items</kbd> name with an underscore to tell Reason to ignore it. Notice that we're using the <kbd>when</kbd> clause here, as introduced in <a href="d3723975-7a3c-4369-84fe-272b67870234.xhtml">Chapter 5</a>, <em>Putting Alternative Values in Types</em>. This is equivalent to using an <kbd>if</kbd> expression inside the body of the branch, but is slightly more succinct. If the first element matches the needle, we put it inside a <kbd>Some</kbd> constructor and evaluate it.</li>
<li>In the second pattern, we match against the remaining list of items after ignoring the first item, and recursively try to find the element we want in that. But this branch is only reached if the first branch doesn't match, meaning that the element wasn't the first item in the list. The branch itself evaluates to the result of <kbd>tryFind</kbd>, meaning either <kbd>Some(person)</kbd> or <kbd>None</kbd>.</li>
<li>In the final branch, we must handle the other possible state of the <kbd>haystack</kbd> list: being empty. If it is, we either started with an empty list or ended up with one by recursion. In either case, we didn't find the element we wanted in the list, so we return <kbd>None</kbd>, which in this case means not found<em>.</em></li>
<li>Here, we describe how to greet a person who may or may not be there. The compiler forces handling both <kbd>Some(person)</kbd> and <kbd>None</kbd> cases—we can't forget to handle a missing value.</li>
<li>We define two different <kbd>needle</kbd> functions, which test whether a given person's record has the ID 1 or 4.</li>
<li>Here's the payoff: we can optionally greet a person, but only if we found the person with the given ID in our <kbd>people</kbd> list. We can run the following output script to see what happens:</li>
</ol>
<pre><strong>$ node src/Ch06/Ch06_Option.bs.js</strong> <br/>Hello, Bob with ID 1!<br/>No such person!</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As expected, we find and greet the person (<kbd>Bob</kbd>) with <kbd>ID 1</kbd>, but not the one with <kbd>ID 4</kbd> because there is no such person.</p>
<div class="packt_infobox">In the output JavaScript, BuckleScript again converts the tail-recursive <kbd>tryFind</kbd> function into a simple imperative loop.</div>
<p>Here, we see two sides of using the <kbd>option</kbd> type: we may need to represent the presence or absence of a value during the normal course of our operation, and if we use a variant type such as <kbd>option</kbd>, we get the benefit of its exhaustivity checking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutable parameterized types – ref and array</h1>
                </header>
            
            <article>
                
<p>Reason also provides two important parameterized types that allow their values to be mutated in place. This mutability brings efficiency gains for certain types of algorithms, but generally needs to be used carefully because, as we'll see, it may be a source of bugs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing a reference to a value</h1>
                </header>
            
            <article>
                
<p>We've already seen an example of mutability, in the <em>Mutable record fields</em> <span>section </span>of <a href="ba37505a-f222-4238-a13c-259160ca582d.xhtml">Chapter 4</a>, <em>Grouping Values Together in Types</em>. Sometimes, we need to manage just one or two mutable values, and we might not want to go through the ceremony of declaring a new record type with mutable fields. For these situations, we can take advantage of the built-in <kbd>ref</kbd> type. The <kbd>ref</kbd> type essentially gives us a box, a ref, that lets us swap values in and out. The values themselves need not be mutable, just the box itself:</p>
<pre><span class="underline">type</span> <strong>ref</strong>(<strong>'a</strong>) = {<span class="underline">mutable</span> <em>contents</em>: <strong>'a</strong>}; /* (1) */<br/><span class="underline">let</span> <em>ref</em>: <strong>'a</strong> =&gt; <strong>ref</strong>(<strong>'a</strong>); /* (2) */<br/><span class="underline">let</span> (:=): (<strong>ref</strong>(<strong>'a</strong>), <strong>'a</strong>) =&gt; <strong>unit</strong>; /* (3) */<br/><span class="underline">let</span> (^): <strong>ref</strong>(<strong>'a</strong>) =&gt; <strong>'a</strong>; /* (4) */<br/><span class="underline">let</span> <em>incr</em>: <strong>ref</strong>(<strong>int</strong>) =&gt; <strong>unit</strong>; /* (5) */<br/><span class="underline">let</span> <em>decr</em>: <strong>ref</strong>(<strong>int</strong>) =&gt; <strong>unit</strong>;</pre>
<p>The previous code listing shows the complete API of the <kbd>ref</kbd> type, explained as follows:</p>
<ol>
<li>It's implemented as a record type with just a single mutable record field, but this field is parameterized by a type parameter, <kbd>'a</kbd>, letting us reuse it for any type.</li>
<li>We can use the <kbd>ref</kbd> function to box a value of any type and put it inside a ref: <kbd>let count = ref(0);</kbd>.</li>
</ol>
<ol start="3">
<li>The assignment operator <kbd>(:=)</kbd> is implemented as a function and can be used in the infix position: <kbd>count := 1;</kbd>.</li>
<li>The dereference operator, <kbd>(^)</kbd>, is also implemented as a function, but Reason allows us to use it in postfix position: <kbd>let countVal = count^;</kbd>.</li>
<li><kbd>incr</kbd> and <kbd>decr</kbd> are convenience functions for incrementing and decrementing integers, as we often need to update counts.</li>
</ol>
<p>The huge benefit of using the <kbd>ref</kbd> type to manage mutation is that mutability is captured at the type level. We can tell from looking at any type signature that contains <kbd>ref(something)</kbd> that something of the <kbd>something</kbd> type is changing. By contrast, when we're using a mutable record field directly, we have no type-level indication of mutability, just the record definition itself.</p>
<p>Let's look at an example of using a <kbd>ref</kbd>: redefining the <kbd>tryGreet</kbd> function to use a more imperative style of walking through its input list and trying to find the required item. We'll need three refs: the remaining portion of the haystack list, whether we should stop searching or not, and an optional found item. As long as we haven't found the item yet, we'll keep searching, but as soon as we find it, we'll return it:</p>
<pre>/* src/Ch06/Ch06_Ref.re */<br/><span class="underline">let</span> <em>tryFind</em>(<em>needle</em>, <em>haystack</em>) = {<br/>  <span class="underline">let</span> <em>currHaystack</em> = <em>ref</em>(<em>haystack</em>);<br/>  <span class="underline">let</span> <em>stop</em> = <em>ref</em>(<em>false</em>);<br/>  <span class="underline">let</span> <em>currItem</em> = <em>ref</em>(<em>None</em>);<br/><br/>  <span class="underline">while</span> (!(<em>stop</em>^)) { /* (1) */<br/>    <span class="underline">switch</span> (<em>currHaystack</em>^) { /* (2) */<br/>    | [<em>item</em>, ...<em>_items</em>] <span class="underline">when</span> <em>needle</em>(<em>item</em>) =&gt; { /* (3) */<br/>        <em>stop</em> := <em>true</em>;<br/>        <em>currItem</em> := <em>Some</em>(<em>item</em>)<br/>      }<br/>    | [<em>_item</em>, ...<em>items</em>] =&gt; <em>currHaystack</em> := <em>items</em> /* (4) */<br/>    | [] =&gt; <em>stop</em> := <em>true</em> /* (5) */<br/>    };<br/>  };<br/><br/>  <em>currItem</em>^ /* (6) */<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the previous example, we use Reason's imperative features (mutation and looping), explained as follows:</p>
<ol>
<li>We continuously loop until we explicitly say we should stop. Notice that an imperative <kbd>while</kbd> loop looks exactly as we might expect from other imperative languages such as JavaScript.</li>
<li>Pattern matching on the input <kbd>haystack list</kbd> is still the most convenient way to walk through it item by item, so we keep doing that here.</li>
<li>If we find the item we're looking for, we need to make sure that we set the stop indicator to <kbd>true</kbd>, and also set the found item so we can return it later.</li>
<li>If we haven't found it yet but the list isn't empty, set the current haystack to be the remainder of the list.</li>
<li>If the list is empty, we obviously haven't found the item, so we need to stop.</li>
<li>Whatever we've found (or haven't) so far, we finally need to dereference and return it.</li>
</ol>
<p>The first thing to notice about this imperative version is that it's more verbose. Keeping track of the mutable state involves some ceremony at the code level. It's not that imperative style in Reason is especially cumbersome; it would look much the same in any imperative language. It's just that functional style with recursion is, in general, more succinct because the recursive call effectively keeps track of the current state so we don't have to.</p>
<p>The second thing to note is that we've preserved the same function signature (<kbd>('a =&gt; bool, list('a)) =&gt; option('a)</kbd>) for this implementation, just without recursion. If we needed to, we could swap out this implementation for the recursive one, and our client code wouldn't need a recompilation to use it. This is a property of many static type systems: if we preserve type signatures, we can freely swap out implementations. Reason's type system in particular uses signatures to decide whether entire modules are compatible. This helps us pinpoint compatibility issues early, at build time, rather than find an incompatibility when running the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing an array of values</h1>
                </header>
            
            <article>
                
<p>Sometimes, we need to efficiently manage and change many values of the same type. Reason provides the <kbd>array</kbd> type to help with this. We can think of an array as a single contiguous line of boxes of the same size, each of which can hold a value of the same type. Formally, it's a polymorphic type, as follows:</p>
<pre><span class="underline">type</span> <strong>array</strong>(<strong>'a</strong>);</pre>
<p class="mce-root"/>
<p>The <kbd>array</kbd> data structure is characteristically <span>similar </span>to what you might have seen in other languages, in which:</p>
<ul>
<li>It allows random access to its elements</li>
<li>It doesn't allow recursive traversal of elements like <kbd>list</kbd> does with the spread (<kbd>[item, ...items]</kbd>) operation</li>
</ul>
<p>However, it does allow basic pattern matching on its elements. The following is an example of its use:</p>
<pre>/* src/Ch06/Ch06_Array.re */<br/><span class="underline">let</span> <em>empty</em> = [||]; /* (1) */<br/><span class="underline">let</span> <em>singleton</em> = [|1|];<br/><span class="underline">let</span> <em>multi</em> = [|<em>false</em>, <em>true</em>, <em>true</em>|];<br/><br/><em>multi</em>[1] = <em>false</em>; /* (2) */<br/>Js.log(<em>multi</em>[1]); /* (3) */</pre>
<p>In the previous example, we see the following simple use of arrays:</p>
<ol>
<li>We can create an empty array, as well as arrays with one or more elements. The array delimiters are <kbd>[|</kbd> and <kbd>|]</kbd> and are used to distinguish them from lists which are more frequently used in Reason.</li>
<li>We can assign to any valid index in the array (assigning to an out-of-bounds index will cause a runtime exception).</li>
<li>We can read the value at any valid index (reading from an out-of-bounds index will also cause a runtime exception).</li>
</ol>
<p>For arrays, the concept of indexing is important, as we can see here. Index-based random access is constant-time, but in return we have to take care to access only valid indexes.</p>
<p>To get a better sense of how arrays are useful, let's try to implement a tic-tac-toe board using an array and a couple of functions that update and check the board, as follows:</p>
<pre>/* src/Ch06/Ch06_TicTacToe.re */<br/><br/>/* Each slot on the board can be taken by X or O, or it can be empty. */<br/><span class="underline">type</span> <strong>slot</strong> = <em>X</em> | <em>O</em> | <em>Empty</em>;<br/><br/><span class="underline">let</span> <em>newBoard</em>() = <em>Array.make</em>(9, <em>Empty</em>); /* (1) */<br/><br/>/* Coords are as follows on the board:<br/>   1 2 3<br/>   4 5 6<br/>   7 8 9 */<br/><span class="underline">let</span> <em>play</em>(<em>player</em>, <em>coord</em>, <em>board</em>) = <em>board</em>[<em>coord</em> - 1] = <em>player</em>; /* (2) */<br/><br/><span class="underline">let</span> <em>xWon</em>(<em>board</em>) = <span class="underline">switch</span> (<em>board</em>) {<br/>| [|<em>X</em>, <em>X</em>, <em>X</em>, /* (3) */<br/>    _, _, _,<br/>    _, _, _|]<br/>| [|_, _, _, /* (4) */<br/>    <em>X</em>, <em>X</em>, <em>X</em>,<br/>    _, _, _|]<br/>| [|_, _, _,<br/>    _, _, _,<br/>    <em>X</em>, <em>X</em>, <em>X</em>|]<br/>| [|<em>X</em>, _, _,<br/>    <em>X</em>, _, _,<br/>    <em>X</em>, _, _|]<br/>| [|_, <em>X</em>, _,<br/>    _, <em>X</em>, _,<br/>    _, <em>X</em>, _|]<br/>| [|_, _, <em>X</em>,<br/>    _, _, <em>X</em>,<br/>    _, _, <em>X</em>|]<br/>| [|<em>X</em>, _, _,<br/>    _, <em>X</em>, _,<br/>    _, _, <em>X</em>|]<br/>| [|_, _, <em>X</em>,<br/>    _, <em>X</em>, _,<br/>    <em>X</em>, _, _|] =&gt; <em>true</em> /* (5) */<br/>| _ =&gt; <em>false</em> /* (6) */<br/>};</pre>
<p>This is an interesting example of designing an array so we can pattern match it literally, explained as follows:</p>
<ol>
<li>We can create a new game board by creating a new array filled with <kbd>Empty</kbd> slots, using the <kbd>Array.make</kbd> library function. This function gives us an array of the required length and is filled with a single value in all the indexes.</li>
<li>Since we accept a one-indexed board coordinate, we convert it to a zero-indexed array index by simply subtracting one.</li>
<li>We can pattern match against the exact structure of the array. In this case, our nine-element array can look exactly like a tic-tac-toe board if we break it up into three rows purely for presentation.</li>
<li>We can use <kbd>or</kbd> patterns to capture all the cases in which player X wins.</li>
<li>Return <kbd>true</kbd> for all of them.</li>
<li>Otherwise, we return <kbd>false</kbd>.</li>
</ol>
<p>In this case, the fact that we can easily set any position on the board when a player makes a move suits the random-access capability of an array. Setting random positions in a list would be an inefficient operation by comparison because the only way to do that is to traverse each element of the list and then perform several list-breaking and joining operations until we create the final output list.</p>
<p>In general, an array is very useful when we need to perform frequent updates over multiple elements. Common scenarios are pixel buffers and manually managed memory regions. Fortunately, Reason makes these scenarios relatively easy to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutation and type inference restrictions</h1>
                </header>
            
            <article>
                
<p>In general, the compiler happily infers all sorts of types for us, but it does have some limitations. Sometimes, we need to give it a little nudge to help it get to the correct inference result, for example. The main case we need to be aware of is called <strong>value restriction.</strong> Va<span>lue restriction basically means that mutable values can't be generic, the compiler must know their types fully. The following is an example error you will get if you uncomment the code in the file <kbd>src/Ch06/Ch06_ValueRestrictionError.re</kbd>:</span></p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  src/Ch06/Ch06_ValueRestrictionError.re 2:17-24<br/>  <br/>  1 │ /* src/Ch06/Ch06_ValueRestrictionError.re */<br/>  2 │ let optionArr = <strong>[|None|]</strong>;<br/>  3 │ let optionRef = ref(None);<br/>  <br/>  This expression's type contains type variables that can't be generalized:<br/>  <strong>array(option('_a))</strong><br/>  <br/>  This happens when the type system senses there's a mutation/side-effect, in combination with a polymorphic value.<br/>  Using or annotating that value usually solves it. More info:<br/>  https://realworldocaml.org/v1/en/html/imperative-programming-1.html#side-effects-and-weak-polymorphism</pre>
<p>Notice the inferred type for <kbd>optionArr: array(option('_a))</kbd>. The underscore prefix in front of the type variable name is the compiler's way of saying that it ran into the value restriction. A type variable named <kbd>'_a</kbd> is called a <strong>weak type variable</strong> (in the sense that its actual type might change later).</p>
<p class="mce-root"/>
<p>Having a type that might change after it's inferred at compilation is a bad idea. For example, let's think about what would happen if the compiler inferred the type as <kbd>array(option('a))</kbd>. Later in the code, we could set that index to <kbd>Some(1)</kbd>, then later still we could set it to <kbd>Some(false)</kbd>. This would defeat the type system entirely and leave us uncertain of what the exact type is at any point in the code. The compiler designers decided to prevent this from happening. This is just one of the type soundness decisions that they've made over the years to prevent runtime type errors from creeping into programs.</p>
<p>As a valid code, we could precise the type using <kbd>array(option(string))</kbd>, as you can see in the alternative code file (<kbd>src/Ch06/Ch06_ValueRestrictionErrorFixed.re</kbd>) which compiles correctly. It's code is as follows:</p>
<pre>/* src/Ch06/Ch06_ValueRestrictionErrorFixed.re */<br/>let optionArr: array(option(string)) = [|None|];<br/>let optionRef: ref(option(string)) = ref(None);</pre>
<p>Let's look at another value restriction error. Again, uncomment the code in the file <kbd>src/Ch06/Ch06_ValueRestrictionOtherError.re</kbd>, and you will get a compilation error as follows:</p>
<pre><strong>(Output from bsb -w)</strong><br/>We've found a bug for you!<br/>  src/Ch06/Ch06_ValueRestrictionOtherError.re 5:15-28<br/>  <br/>  1 │ /* src/Ch06/Ch06_ValueRestrictionOtherError.re */<br/>  2 │ let pair(x) = (x, x);<br/>  3 │ let pairAll = <strong>List.map(pair)</strong>;<br/>  <br/>  This expression's type contains type variables that can't be generalized:<br/>  <strong>list('_a) =&gt; list(('_a, '_a))</strong><br/>  <br/>  This happens when the type system senses there's a mutation/side-effect, in combination with a polymorphic value.<br/>  Using or annotating that value usually solves it. More info:<br/>  https://realworldocaml.org/v1/en/html/imperative-programming-1.html#side-effects-and-weak-polymorphism</pre>
<p>This one is slightly trickier as there's no obvious mutation. The <kbd>pairAll</kbd> function is supposed to convert a list of items into a list of pairs (2-tuples) of those items. The problem is that the <kbd>pair</kbd> function is generic; the compiler can't figure out if it might be mutating anything. If we'd had a monomorphic (that is, not generic) function instead, such as <kbd>let pair(x) = (x + 1, x - 1);</kbd>, then the compiler would be able to figure out that the inputs and outputs are just <kbd>int</kbd> and there's no mutation involved.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>However, there is another way to solve this particular error; remember that it's called the <em>value</em> restriction. In other words, only values are restricted like this. If we expand <kbd>pairAll</kbd> into an explicit function, then the error goes away, shown as follows:</p>
<pre><span class="underline">let</span> <em>pairAll</em>(<em>list</em>) = <em>List.map</em>(<em>pair</em>, <em>list</em>);</pre>
<p>Our fixed code can be found in <kbd>src/Ch06/Ch06_ValueRestrictionErrorFixed.re</kbd>.</p>
<p>This funny solution convinces the compiler that yes, this is really a function, so the value restriction doesn't apply.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Forcing a difference with phantom types</h1>
                </header>
            
            <article>
                
<p>Because we can declare types that can slot in <em>any</em> type parameters, that includes type parameters that the types don't actually use. These are called phantom type parameters, or more informally <strong>phantom types.</strong></p>
<p>A common use case for phantom types is in a kind of type-safe <strong>builder pattern.</strong> (The builder pattern is a piece of code that helps us to construct an object according to specific rules.) For example, we might want to construct syntactically valid SQL statements. One way to do that is to have a validator function that takes an input SQL statement and decides whether it follows SQL syntax rules or not at runtime. This function might try to parse the input statement and build an expression tree. If the tree can be built, the statement is valid. Otherwise, it's invalid.</p>
<p>Another way to approach this is to provide a set of functions that statically enforce that only syntactically valid statements can be created. The magic part of this is that we can tell the compiler exactly what the type parameter should be when it's not actually used in the type body. There's nothing in the type definition to contradict what we say, so the compiler must accept it.</p>
<p>The following is a simplified example:</p>
<pre>/* src/Ch06/Ch06_PhantomTypes.re */<br/><br/><span class="underline">module</span> <em>Sql</em>: {<br/>  <span class="underline">type</span> <strong>column</strong> = <strong>string</strong>; /* (1) */<br/>  <span class="underline">type</span> <strong>table</strong> = <strong>string</strong>;<br/>  <span class="underline">type</span> <strong>t</strong>(<strong>'a</strong>); /* (2) */<br/><br/>  <span class="underline">let</span> <em>select</em>: <strong>list</strong>(<strong>column</strong>) =&gt; <strong>t</strong>([`<em>select</em>]); /* (3) */<br/>  <span class="underline">let</span> <em>from</em>: (<strong>table</strong>, <strong>t</strong>([`<em>select</em>])) =&gt; <strong>t</strong>([`<em>ok</em>]);<br/>  <span class="underline">let</span> <em>print</em>: <strong>t</strong>([`<em>ok</em>]) =&gt; <strong>string</strong>;<br/>} = {<br/>  <span class="underline">type</span> <strong>column</strong> = <strong>string</strong>;<br/>  <span class="underline">type</span> <strong>table</strong> = <strong>string</strong>;<br/>  <span class="underline">type</span> <strong>t</strong>(<strong>'a</strong>) = <strong>string</strong>;<br/><br/>  <span class="underline">let</span> <em>select</em>(<em>columns</em>) = { /* (4) */<br/>    <span class="underline">let</span> <em>commalist</em> = <em>String.concat</em>(", ", <em>columns</em>);<br/>    {j|select $<em>commalist</em>|j}<br/>  };<br/><br/>  <span class="underline">let</span> <em>from</em>(<em>table</em>, <em>t</em>) = {j|$<em>t</em> from $<em>table</em>|j};<br/>  <span class="underline">let</span> <em>print</em>(<em>t</em>) = <em>t</em>; /* (5) */<br/>};<br/><br/><span class="underline">let</span> <em>sql</em> = <em>Sql</em>.(<em>select</em>(["name"]) |&gt; <em>from</em>("employees") |&gt; <em>print</em>); /* (6) */<br/>Js.log(<em>sql</em>);</pre>
<p class="mce-root"/>
<p>For the sake of simplicity, we're dealing with only the <kbd>select</kbd> and <kbd>from</kbd> clauses in this SQL builder module, explained as follows:</p>
<p class="mce-root"/>
<ol>
<li>We alias a couple of types to serve as documentation.</li>
<li>This is the type with the phantom type parameter; to the module consumer, it looks like a normal parameterized type. Internally, it doesn't contain, or otherwise use, any values of its parameter type.</li>
<li>This function is the entry point into the build: it takes a column list and returns a partially constructed SQL statement. We can't do anything with this returned value except feed it into the next function, <kbd>from</kbd>. Notice that the type parameters are literally the types of polymorphic variants named appropriately; they just act as tags.</li>
<li>The implementations of <kbd>select</kbd> and <kbd>from</kbd> are very simple: they just build normal strings in the form of syntactically valid SQL statements. The most interesting thing about them is that their types are enforced to take parameters such that they can only be called in a particular order: <kbd>select</kbd>, <kbd>from</kbd>, <kbd>print</kbd>.</li>
<li>The <kbd>print</kbd> function is strikingly simple in that it just returns the built string. We can examine that and then pass it into an SQL engine to run.</li>
<li>We build a syntactically valid SQL statement by calling the functions in the right order, enforced by the type system, and we then output them to the terminal. Note that the <kbd>|&gt;</kbd> operator is called <strong>pipe-forward</strong>, and it's used to feed the output of one function as the input of the next one. We'll cover common operators in the next chapter.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following code is the error we would have gotten if we'd tried to print an invalid SQL statement:</p>
<pre><strong>(Output from bsb -w)</strong><br/>We've found a bug for you!<br/>  src/Ch06/Ch06_PhantomTypes.re 25:36-40<br/>  <br/>  23 │ };<br/>  24 │ <br/>  <strong>25</strong> │ let sql = Sql.(select(["name"]) |&gt; <strong>print</strong>); /* (6) */<br/>  26 │ Js.log(sql);<br/>  <br/>  This has type:<br/>    <strong>Sql.t([ `ok ]) =&gt; string</strong><br/>  But somewhere wanted:<br/>    Sql.t([ `select ]) =&gt; 'a<br/>  These two variant types have no intersection</pre>
<p>This type error is saying that the <kbd>print</kbd> function expects a complete <kbd>ok</kbd> SQL statement, but has received only a <kbd>select</kbd> clause. The type parameters, working together with the module's functions, ensure that the SQL is constructed in the right way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we delved into Reason's parameterized types, learning about type parameters and how they expand types to become generic, some common parameterized types that we use in Reason, the compiler's restrictions on using parameterized types and mutation together, and how to force the same underlying type to look different to the compiler using phantom type parameters.</p>
<p>We also saw some instances of passing in functions as arguments to other functions, for example, <kbd>tryFind</kbd> and <kbd>List.map</kbd>. In the next chapter, we'll thoroughly cover functions and how Reason lets us treat them as first-class objects that we can pass around to allow our code to behave flexibly.</p>


            </article>

            
        </section>
    </body></html>