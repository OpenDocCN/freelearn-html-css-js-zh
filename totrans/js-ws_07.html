<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer171">
			</div>
		</div>
		<div class="Content" id="_idContainer172">
			<h1 id="_idParaDest-294"><a id="_idTextAnchor331"/>7. Popping the Hood</h1>
		</div>
		<div class="Content" id="_idContainer194">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to differentiate between single-threaded and multi-threaded execution; describe JavaScript's execution process; show how the call stack and memory heap interact with the other elements of the runtime; write code that works in tandem with JavaScript's garbage collection process; and debug memory-related issues in the browser.</p>
			<p class="callout">In this chapter, we'll look at how JavaScript is executed in the browser and how it manages important system resources such as memory.</p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor332"/>Introduction</h1>
			<p>In the previous two chapters, you learned about some of the core concepts of JavaScript, were introduced to the ideas of the <strong class="source-inline">event</strong> loop, and looked at how JavaScript handles the process of <strong class="bold">memory management</strong>. In this chapter, we'll look at those aspects of the language in more detail and learn how we can write code that works in concert with some underlying features of JavaScript. </p>
			<p>It is common for developers to get quite far in their careers without having a solid understanding of some of the core concepts underlying (and surrounding) JavaScript. Indeed, it's quite possible to be a successful developer who writes solid, commercially viable applications, without ever fully grasping the topics that are covered in this chapter.</p>
			<p>So, why should we learn about the inner workings of JavaScript? Can't we just write our code and let JavaScript handle the nitty-gritty? Well, the problem with that approach is that, sometimes, things don't quite go according to plan, and we need to be able to understand what's happening under the hood in order to rewrite the part of our code that is making the application buggy or less performant. Imagine you're a rally driver. You can drive your car along the track with just a rudimentary level of knowledge of how to drive a car. This skill level may get you to the finish line, but it definitely won't have you winning any races. </p>
			<p>To set yourself apart from other drivers, you need to increase your skill and experience levels. Sure, simply practicing the skill will help you improve over time, and allow you to intuit a lot of what's happening behind the scenes – this is true for driving a car and programming computers with JavaScript – but having a deeper understanding of the actual processes involved will allow you to plan and make decisions with confidence so that you know specifically what parts of the system you want to control.</p>
			<p>To give you a more concrete programming example, imagine you're testing a co-worker's code and you can't understand why a page seems to take so long to load, why it becomes unresponsive during a certain operation, or why the application takes up excessive system resources. These kinds of performance issues don't necessarily break an application, and they may not even be noticeable to every user. But they do affect the software's usability and the user experience, which has knock-on effects on things such as SEO page ranking and a site's popularity with its end users. Understanding what's going on under the hood can help you write better code and debug code faster, making your life as a developer easier, and making for smoother user experience and more successful applications.</p>
			<p>Arming yourself with the knowledge covered in this chapter means that the code you write will make the best use of the JavaScript programming language and its runtime environments.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor333"/>JavaScript Execution and the Event Loop</h1>
			<p>JavaScript is a single-threaded language, meaning it lines up all of its operations in a single thread and executes them one at a time. Many other languages are multi-threaded, that is, they are able to execute more than one thread of operations at a time. There are pros and cons to each method of execution, mostly revolving around efficiency versus complexity, but we won't look at these in-depth here. As we'll see in a moment, JavaScript's call stack processes operations one at a time, on a last in, first out (LIFO) basis.</p>
			<p>LIFO describes a process of adding and removing elements from a data structure – in this case, from a stack. As the name suggests, the last thing that's added is the first thing taken away – much like stacking books on a desk.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor334"/>The JavaScript Runtime</h2>
			<p>A runtime environment is an application that allows the software to be run on a system. It's the bridge between the software being run and the system on which it is being run and provides access to system resources such as memory and filesystem, and to runtime and environment variables. In the case of JavaScript, the runtime is often – but not always – the browser.</p>
			<p>There are different implementations of the JavaScript runtime, and the exact way they handle executions differs between each. Each one makes use of optimization, which can make real-life processes differ from those described here.</p>
			<p>However, from a theoretical standpoint, a JavaScript runtime can be usefully broken down into several key components and processes:</p>
			<ul>
				<li>The JavaScript engine</li>
				<li>Environ<a id="_idTextAnchor335"/>ment/Browser APIs</li>
				<li>The Message Queue/Callback Queue</li>
				<li>The <strong class="source-inline">event</strong> loop</li>
			</ul>
			<p>The JavaScript runtime environment and execution broken down into these key components can be displayed as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer173">
					<img alt="Figure 7.1: An overview of the JavaScript runtime&#13;&#10;" src="image/C14377_07_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: An overview of the JavaScript runtime</p>
			<p>Let's look at each of these in turn to get a better understanding of their functionality.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor336"/>JavaScript Engine</h2>
			<p>A JavaScript engine is a piece of software that runs JavaScript code, turning the high-level JavaScript source code into low-level machine code via the process of <strong class="bold">compilation</strong>. A common JavaScript engine is Google's V8 engine, which is found in the Chrome browser as well as in <strong class="source-inline">Node.js</strong> (used in server-side JavaScript execution) among other places. V8, like most modern browsers, uses a <strong class="bold">Just-In-Time compilation</strong> process to execute JavaScript code, meaning that the code is compiled at runtime and not ahead of time, like with older compilation processes.</p>
			<p>The two elements of a JavaScript engine that we're concerned with here are the <strong class="bold">memory heap</strong> and the <strong class="bold">call stack</strong>, both of which will be explained shortly. Note that the preceding diagram shows the event loop as being separate from the JavaScript engine as it's generally expected that the JavaScript runtime will implement and manage the event loop. However, many JavaScript engines implement their own event loop process, which can be used as a fallback for the runtime environment.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">By default, Node runs on the V8 JavaScript engine. However, alternate implementations of Node using different engines are being worked on. <strong class="bold">Node-ChakraCore</strong>, which uses Microsoft's ChakraCore JavaScript engine, is one such project and is under active development. Another is <strong class="bold">SpiderNode</strong>, although the development of this project has stalled at the time of writing.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor337"/>Environment APIs</h2>
			<p>Often called Web APIs or Browser APIs in the context of a browser, these are the interfaces that are made available to JavaScript by the environment in which it is being run. For example, the browser gives access to the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), <strong class="source-inline">LocalStorage</strong>, and methods such as <strong class="source-inline">setTimeout()</strong> and <strong class="source-inline">setInterval()</strong>, which we've covered in previous chapters. JavaScript running outside of a browser will have different needs, and therefore the runtime will expose different interfaces for it to use. Node.js is a popular server-side JavaScript runtime environment, which we will cover later on in this book. It usually wouldn't make much sense for Node.js to have a Document Object Model (DOM), so instead, Node provides APIs that are more relevant to server-side code such as the <strong class="source-inline">FileSystem</strong> API for performing <strong class="bold">CRUD</strong> ( create, read, update and delete) operations on the <strong class="source-inline">filesystem</strong>.</p>
			<p>As we'll see shortly, environment APIs are a crucial component of JavaScript's ability to run <strong class="bold">asynchronous operations</strong>.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor338"/>Message Queue</h2>
			<p>The message queue (also known as the <strong class="bold">callback queue</strong> or task queue) is simply a list of messages with corresponding functions that are due to be executed. Callback functions are added to the message queue at the appropriate time, for example, when a <strong class="source-inline">setTimeout</strong> function's delay time has expired, or when an event occurs and there is a corresponding event listener, such as when a user clicks on a button and the button has a click event listener attached to it. These operations occur in a <strong class="bold">first in, first out</strong>(<strong class="bold">FIFO</strong>) sequence, much like the queue you find at a supermarket checkout. The message queue doesn't actually execute the functions itself – it's simply a place to keep them on hold until the call stack has finished doing what it's doing. The time at which the operation is executed is decided by the event loop.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor339"/>Event Loop</h2>
			<p>The event loop is the process by which messages are added from the message queue to the call stack. The event loop watches the call stack and the message queue, and if the call stack is empty, then the oldest message from the message queue (the first in) will be pushed onto the stack for execution. Only when all the function calls on the stack have returned will subsequent messages (function calls) be pushed onto the stack.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor340"/>Call Stack</h2>
			<p>The call stack keeps track of JavaScript's function invocations. When a function is called, a <strong class="bold">stack frame</strong>, consisting of the function's name (or 'anonymous," for anonymous functions), and a reference to the function caller's address, is pushed onto the top of the stack. If this function calls another function, then a new frame for the second function is pushed to the top of the stack, on top of the previous frame. When the function returns – either explicitly or implicitly – the function's corresponding stack frame is popped off the call stack, and code execution carries on from where it was before the function call. Unlike the message queue, the call stack processes frames in a LIFO sequence: stack frames are added to and taken from, the top of the stack, much like stacking books on a desk. When the call stack is empty, the event loop will decide whether to push messages from the message queue or to allow new stack frames to be added to the call stack for subsequent function calls.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor341"/>Memory Heap</h2>
			<p>The memory heap is an unsorted area of memory that the JavaScript engine uses to dynamically read and write objects at runtime. We will look at memory management in JavaScript in detail later in this chapter.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor342"/>Event Loop in Action</h2>
			<p>This section explains the code we will use to demonstrate the event loop in action and also provide a brief precursor regarding how asynchronous code is executed.</p>
			<p>In your browser's JavaScript console or your code editor of choice, the three simple function declarations are as follows:</p>
			<p class="source-code">function firstCall() {</p>
			<p class="source-code">  console.log('I'm logged first!!");</p>
			<p class="source-code">  secondCall();</p>
			<p class="source-code">}</p>
			<p class="source-code">function secondCall() {</p>
			<p class="source-code">  console.log('I'm second...");</p>
			<p class="source-code">  thirdCall();</p>
			<p class="source-code">}</p>
			<p class="source-code">function thirdCall() {</p>
			<p class="source-code">  console.log('I'm last.");</p>
			<p class="source-code">}</p>
			<p class="source-code">firstCall();</p>
			<p>In this simple code snippet, we are declaring three functions and then calling the first of the three. The <strong class="source-inline">firstCall</strong> function logs the <strong class="source-inline">'I'm logged first"</strong> string in the console, and then calls the next function, <strong class="source-inline">secondCall()</strong>. This function logs the <strong class="source-inline">'I'm second..."</strong> string, and subsequently calls the third of our functions, <strong class="source-inline">thirdCall()</strong>. <strong class="source-inline">thirdCall()</strong> simply logs the <strong class="source-inline">'I'm last."</strong> string</p>
			<p>What do you expect to see in the console when we run this code? Hopefully, it's quite obvious that we will see the following logged:</p>
			<p class="source-code">&gt;I'm logged first!!</p>
			<p class="source-code">&gt;I'm second...</p>
			<p class="source-code">&gt;I'm last.</p>
			<p class="source-code">&gt;undefined</p>
			<p>In this case, each function invocation is added to the call stack, executed in turn, and then popped off the top of the stack. Therefore, we get the strings from the three functions logged in their correct order. You can see the stack frames for each of the function invocations in the following screenshot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer174">
					<img alt="Figure 7.2: Demonstrating the sequence of execution in the call stack&#13;&#10;" src="image/C14377_07_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: Demonstrating the sequence of execution in the call stack</p>
			<p>Now, let's make a small change to our code by adding a <strong class="source-inline">setTimout()</strong> function in the second function block. So, let's take a look at what the three strings will be logged in this time if you write and run the code:</p>
			<p class="source-code">function firstCall() {</p>
			<p class="source-code">  console.log('I'm logged first!!");</p>
			<p class="source-code">  secondCall();</p>
			<p class="source-code">}</p>
			<p class="source-code">function secondCall() {</p>
			<p class="source-code">  setTimeout(function() {</p>
			<p class="source-code">    console.log('I'm second...");</p>
			<p class="source-code">  }, 0);</p>
			<p class="source-code">  thirdCall();</p>
			<p class="source-code">}</p>
			<p class="source-code">function thirdCall() {</p>
			<p class="source-code">  console.log('I'm last.");</p>
			<p class="source-code">}</p>
			<p class="source-code">firstCall();</p>
			<p>Logic dictates that the order of our console logs will remain the same – after all, the <strong class="source-inline">setTimeout</strong> delay is <strong class="source-inline">0</strong> milliseconds, so it will execute on the console log straight away, right? </p>
			<p>However, we find that the order has changed:</p>
			<p class="source-code">&gt;I'm logged first!!</p>
			<p class="source-code">&gt;I'm last.</p>
			<p class="source-code">&gt;undefined</p>
			<p class="source-code">&gt;I'm second...</p>
			<p>So, what do you think is going on here? We will go through the source code line by line and see how the JavaScript runtime is handling each function.</p>
			<p>First of all, the <strong class="source-inline">firstCall()</strong> function is invoked and a new stack frame is pushed to the top of the call stack of this function invocation. The function contains a call to the <strong class="source-inline">log()</strong> method of the console object, with an argument of the string type with the value <strong class="source-inline">'I'm logged first!!"</strong>. This is highlighted in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer175">
					<img alt="Figure 7.3: Demonstrating the call stack after calling firstCall()&#13;&#10;" src="image/C14377_07_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Demonstrating the call stack after calling firstCall()</p>
			<p>The <strong class="source-inline">'I'm logged first!!"</strong> string is logged to the console, the <strong class="source-inline">secondCall()</strong> function is invoked, and a new stack frame is pushed onto the top of the stack for <strong class="source-inline">secondCall()</strong>. Here is where things are different from the original code snippet. This function contains a call to the <strong class="source-inline">setTimeout()</strong> function, which is a part of the browser's API, so this function is taken outside of the main JavaScript execution thread for now. The <strong class="source-inline">setTimeout()</strong> function is called with a delay of 0 milliseconds, after which a message is passed to the message queue with a reference to the <strong class="source-inline">console.log()</strong> call contained within the <strong class="source-inline">secondCall()</strong> function. Now, this message sits in the message queue, waiting patiently to be dealt with by the <strong class="source-inline">event</strong> loop:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer176">
					<img alt="Figure 7.4: Demonstrating the setTimeout() method being assigned to the message queue&#13;&#10;" src="image/C14377_07_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: Demonstrating the setTimeout() method being assigned to the message queue</p>
			<p>Now, let's look at how the <strong class="source-inline">secondCall()</strong> function calls <strong class="source-inline">thirdCall()</strong>. Another new stack frame is pushed onto the call stack for this function invocation. It calls <strong class="source-inline">console.log()</strong> with the <strong class="source-inline">'I'm last."</strong> string, which is printed to the console:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer177">
					<img alt="Figure 7.5: The end of the final function call&#13;&#10;" src="image/C14377_07_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: The end of the final function call</p>
			<p>At this point, <strong class="source-inline">thirdCall()</strong> has no other operations to execute, so it implicitly returns the value <strong class="source-inline">undefined</strong> back to <strong class="source-inline">secondCall()</strong>, and the stack frame for <strong class="source-inline">thirdCall()</strong> is popped off the call stack. Then<strong class="source-inline"> secondCall()</strong> returns <strong class="source-inline">undefined</strong> to <strong class="source-inline">firstCall()</strong>, and the stack frame for <strong class="source-inline">secondCall()</strong> is popped off the stack. Next, the stack frame for <strong class="source-inline">firstCall()</strong> is popped off the stack, and <strong class="source-inline">undefined</strong> is returned back to the main process:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer178">
					<img alt="Figure 7.6: Showing the empty call stack after the functions have returned&#13;&#10;" src="image/C14377_07_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: Showing the empty call stack after the functions have returned</p>
			<p>Now, we can see that the only remaining frame on the call stack is the anonymous main process and that no other functions are being called by the main process. The event loop sees that the call stack is available and that there is a message waiting in the message queue, so it pushes a new stack frame for the callback function referenced in the pending message. This callback function is our remaining <strong class="source-inline">console.log()</strong> call, with the <strong class="source-inline">'I'm second…"</strong>: string:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer179">
					<img alt="Figure 7.7: Showing the console.log stack frame&#13;&#10;" src="image/C14377_07_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7: Showing the console.log stack frame</p>
			<p>The final <strong class="source-inline">console.log</strong> call is executed, with the string being printed to the console, and the stack frame is then popped off the call stack, again leaving only the anonymous main process left on the stack. </p>
			<p>This demonstrates how, despite JavaScript being single-threaded, it's possible to continue executing code while a previously invoked function is waiting to be completed. There are many other functions and APIs built into the browser besides <strong class="source-inline">setTimeout</strong>, and we will look at more of these in the next chapter.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor343"/>Exercise 7.01: Working with the Event Loop</h2>
			<p>Let's take a look at how we can apply this knowledge to a more realistic (albeit simple) application. The goal of this exercise is to illustrate how the <strong class="source-inline">event</strong> loop can produce some unexpected behavior in our applications and also to see how we can work with the <strong class="source-inline">event</strong> loop to give useful functionality to our apps. Let's get started:</p>
			<ol>
				<li>We'll have an HTML file with two <strong class="source-inline">&lt;div&gt;</strong> elements in the body with IDs of <strong class="source-inline">status</strong> and <strong class="source-inline">result</strong>. The purpose of the application is going to be to run a function and display the result in the <strong class="source-inline">result</strong> div. We know that our function will take a not-insignificant amount of time to run, so we will also incorporate a status feature so as to keep the user aware of what's happening in the application. For this example, our main function will be an arbitrary calculation that takes a few seconds to complete. In real life, this could be any kind of complex calculation, or a function for fetching data from an external source, such as a database or an API. Load the <strong class="source-inline">index.html</strong> file:<p class="source-code">&lt;!-- index.html --&gt;</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;script src='event-loop.js'&gt;&lt;/script&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;span id='status'&gt;&lt;/span&gt;</p><p class="source-code">    &lt;span id='result'&gt;&lt;/span&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>In a separate JavaScript file, called <strong class="source-inline">event-loop.js</strong>, we'll write a collection of functions to make up our application. First, we're adding an event listener to the window object so that the rest of the code won't run until the DOM's content has loaded (<strong class="source-inline">DOMContentLoaded</strong> is triggered when the browser completes the DOM tree structure, not including any style sheets or images):<p class="source-code">// event-loop.js</p><p class="source-code">document.addEventListener('DOMContentLoaded', () =&gt; {</p></li>
				<li>After this, we are assigning our two <strong class="source-inline">&lt;span&gt;</strong> elements with the IDs of <strong class="source-inline">status</strong> and <strong class="source-inline">result</strong> to two aptly named variables:<p class="source-code">  let statusSpan = document.getElementById('status');</p><p class="source-code">  let resultSpan = document.getElementById('result');</p></li>
				<li>Next, we are defining two functions, <strong class="source-inline">showStatus()</strong> and <strong class="source-inline">doCalculation()</strong>. The <strong class="source-inline">showStatus()</strong> function takes in an argument of <strong class="source-inline">statusText</strong>, which will be set to the <strong class="source-inline">innerText</strong> property of <strong class="source-inline">statusSpan</strong>, thereby displaying whatever text we pass to <strong class="source-inline">showStatus()</strong> on the page:<p class="source-code">  let showStatus = (statusText) =&gt; {</p><p class="source-code">    statusSpan.innerText = statusText;</p><p class="source-code">  };</p></li>
				<li>The other function, <strong class="source-inline">doCalculation()</strong>, runs our calculation and then sets the result to the <strong class="source-inline">innerText</strong> property of the <strong class="source-inline">resultSpan</strong> variable:<p class="source-code">  let doCalculation = () =&gt; {</p><p class="source-code">    let result = 0;</p><p class="source-code">    for(var i = 0; i&lt; 10000000000; i++) {</p><p class="source-code">      result = result + i;</p><p class="source-code">    };</p><p class="source-code">    resultSpan.innerText = `The result is ${result}`;</p><p class="source-code">  };</p><p class="source-code">});</p></li>
				<li>So, to join these together, we could call the functions at the end of the <strong class="source-inline">DOMContentLoaded</strong> callback function like this:<p class="source-code">showStatus('Calculation running, please wait... Maybe for quite a while...');</p><p class="source-code">doCalculation();</p><p class="source-code">showStatus('Calculation finished, here is the result:');</p></li>
				<li>Try running this code and see whether it works as we expect. Not very good, is it? When we first open the page, it loads for a while and then displays the <strong class="source-inline">Calculation finished</strong> status and the result. But we never see the <strong class="source-inline">Calculation running</strong> status:<div class="IMG---Figure" id="_idContainer180"><img alt="Figure 7.8: The output from the first version of the application&#13;&#10;" src="image/C14377_07_08.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.8: The output from the first version of the application</p>
			<p>Why is it, then, that don't we get to see the first status? When we update the DOM by doing something such as setting the <strong class="source-inline">innerText</strong> property of a DOM node, the DOM tree itself is updated, and then the browser repaints the render tree to the browser window. These are two separate steps, and the repaint step happens after the current call stack has finished. So, with our new knowledge of the event loop, we should be able to see what's happening. When we call <strong class="source-inline">showStatus()</strong> for the first time, the DOM is updated, but the browser doesn't redraw the page yet. Then, <strong class="source-inline">doCalculation()</strong> is called, and the execution thread is blocked until the calculation has finished. The <strong class="source-inline">showStatus()</strong> function is called a second time with the <strong class="source-inline">Calculation finished</strong> string, and at this point, the browser repaints the render tree with the <strong class="source-inline">Calculation finished</strong> string that we passed to the second call of <strong class="source-inline">showStatus()</strong>.</p>
			<p>To get our application to work more in line with our specifications, have a go at this yourself before checking out the solution:</p>
			<p class="source-code">showStatus('Calculation running, please wait... Maybe for quite a while...');</p>
			<p class="source-code">setTimeout(() =&gt; {</p>
			<p class="source-code">  doCalculation();</p>
			<p class="source-code">  showStatus('Calculation finished, here is the result:');</p>
			<p class="source-code">},0);</p>
			<p>By adding the call to <strong class="source-inline">doCalculation()</strong> and the second call to <strong class="source-inline">showStatus()</strong> to a <strong class="source-inline">setTimout()</strong> function, the call stack is emptied after the first <strong class="source-inline">showStatus()</strong> function executes, at which point the browser repaints the page, displaying the <strong class="source-inline">Calculation running</strong> string as expected. This is a much better implementation since it keeps the user informed of what the application is doing:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer181">
					<img alt="Figure 7.9: Showing the status while the calculation is running&#13;&#10;" src="image/C14377_07_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: Showing the status while the calculation is running</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor344"/>Stack Overflow</h2>
			<p>The call stack is an example of a data type called – you guessed it – a stack. You can think of a stack simply as a container of objects (stack frames, representing functions and arguments, in the case of a call stack). There's a limit to the number of frames a call stack can hold. We'll now look at what happens when the call stack gets full, a common problem that developers face, and what's known as a stack overflow. (In the V8 JavaScript engine, it has a different name, but the theory is the same.) </p>
			<p>This can happen, for example, when developers are trying to write a recursive function but fail to code in a base case and/or a termination condition, at which point the recursion should stop. It can be tricky – especially for new developers – to account for every edge case that may bypass these points.</p>
			<p>Let's take a look at a simple example of a stack overflow first, after which we'll explore a more true-to-life example.</p>
			<p>Given the following code, let's take a look at what will happen in the JavaScript engine when we call the <strong class="source-inline">callMe()</strong> function:</p>
			<p class="source-code">function callMe() {</p>
			<p class="source-code">  nowCallMe();</p>
			<p class="source-code">}</p>
			<p class="source-code">function nowCallMe() {</p>
			<p class="source-code">  callMe();</p>
			<p class="source-code">}</p>
			<p>It should be fairly obvious what will happen with this code, but still, let's look through a few steps of the process on the call stack.</p>
			<p>When we call <strong class="source-inline">callMe()</strong>, a new stack frame is added to the call stack for that invocation:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer182">
					<img alt="Figure 7.10: The first stack frame is added to the call stack&#13;&#10;" src="image/C14377_07_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10: The first stack frame is added to the call stack</p>
			<p>Inside <strong class="source-inline">callMe()</strong>, the other function, <strong class="source-inline">nowCallMe()</strong>, is called, adding a stack frame for that function invocation to the stack. <strong class="source-inline">nowCallMe()</strong> in turn calls <strong class="source-inline">callMe()</strong>, adding a new stack frame to the call stack, and on and on it goes, with both functions calling each other in turn, and a new stack frame is added to the stack every time. In this scenario, the JavaScript execution thread has nowhere else to go – there is no condition in the code that will cause the thread to move on from this loop:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer183">
					<img alt="Figure 7.11: The call stack is filling with stack frames&#13;&#10;" src="image/C14377_07_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11: The call stack is filling with stack frames</p>
			<p>This loop will continue to add stack frames to the call stack until the stack's limit is reached. In the V8 implementation of the JavaScript engine, the limit for the number of frames in the stack is often somewhere around 16,000, although it can be higher or lower, depending on the content of each frame, the variables being used, and other factors. (At the end of this chapter, we'll write a function to calculate the stack limit for different JavaScript engines and environments.) If this limit is exceeded, the engine throws a stack overflow error, referred to by V8 as <strong class="source-inline">Maximum call stack size exceeded</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer184">
					<img alt="Figure 7.12: Stack overflow error&#13;&#10;" src="image/C14377_07_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12: Stack overflow error</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's possible to change the call stack size limit in the V8 JavaScript engine. To do so, simply launch the environment – be it Node, Chrome, or another implementation – with the <strong class="source-inline">stack-size=[value]</strong> flag. Bear in mind, though, that this should only be used for debugging or for experimentation – you certainly don't want to write code with the expectation that it will be run with anything other than the default call stack size.</p>
			<p>Now, let's take a look at a more real-life example, and later see how we can fix it:</p>
			<p class="source-code">function countdownByTwo(num) {</p>
			<p class="source-code">  if (num === 0) return console.log(num);</p>
			<p class="source-code">  console.log(num);</p>
			<p class="source-code">  countdownByTwo(num - 2);</p>
			<p class="source-code">}</p>
			<p>This function is an example of <strong class="bold">recursion</strong>, which we'll look at in more detail later on in this book. It may not be immediately obvious what this function is doing, so let's break it down into steps.</p>
			<p>The function takes in a number and calls itself recursively, subtracting 2 from the <strong class="source-inline">num</strong> argument for each call. Let's say we call it with the argument of <strong class="source-inline">10</strong>, like so:</p>
			<p class="source-code">countdownByTwo(10);</p>
			<p>The function first checks to see whether <strong class="source-inline">num</strong> is equal to <strong class="source-inline">0</strong>, and if it is, it will return a console log with the value of <strong class="source-inline">0</strong>, and this function's execution will finish (this line is our termination condition). Right now, <strong class="source-inline">num</strong> is equal to <strong class="source-inline">10</strong>, so this <strong class="source-inline">if</strong> statement is <strong class="source-inline">false</strong>, and the execution proceeds to the next line.</p>
			<p>The next line logs the value of <strong class="source-inline">num</strong> to the console and then proceeds to the next line.</p>
			<p>Now, the function calls itself again, with the value of <strong class="source-inline">num</strong> <strong class="source-inline">minus 2</strong> – so <strong class="source-inline">8</strong>, in our case. This continues.</p>
			<p>By calling the preceding function with the argument of <strong class="source-inline">10</strong>, we'll see the numbers <strong class="source-inline">10</strong>, <strong class="source-inline">8</strong>, <strong class="source-inline">6</strong>, <strong class="source-inline">4</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">0</strong> are logged to the console, as expected. </p>
			<p>But what happens if we call the function with an odd number? Try calling the same function with <strong class="source-inline">11</strong> as the input. You'll see that our termination condition of <strong class="source-inline">num=== 0</strong> never occurs since <strong class="source-inline">num</strong> goes from <strong class="source-inline">1</strong> to <strong class="source-inline">-1</strong>.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor345"/>Exercise 7.02: Stack Overflow</h2>
			<p>The goal of this exercise is to rewrite the stack overflow function so that it accounts for as many other inputs as it can. Think about all the possible arguments this function could be called with, and how the function will handle each one. Let's get started:</p>
			<ol>
				<li value="1">Let's go through a few possible inputs to make sure we're accounting for all eventualities, thereby minimizing the risk of an error occurring. Here are some of the edge cases we need to be careful of:<ul><li>The <strong class="source-inline">num</strong> input is odd.</li><li>The input is 0.</li><li>This input is less than 0.</li><li>The input is null or is not of a <strong class="source-inline">number</strong> type.</li></ul></li>
				<li>For now, let's assume that we want the function to return whenever the input is not a number or is a negative number, and if it's 0, then we want the function to log 0 to the console and return. Write the function as follows:<p class="source-code">function countdownByTwo(num) {</p><p class="source-code">  if (typeof num !== 'number' || num&lt; 0) return;</p><p class="source-code">  console.log(num);</p><p class="source-code">  countdownByTwo(num - 2);</p><p class="source-code">}</p><p>Here, we've added a termination condition using the <strong class="source-inline">typeof</strong> operator to determine whether the input, <strong class="source-inline">num</strong>, is a number as expected. We will return <strong class="source-inline">undefined</strong> if it's not of a <strong class="source-inline">number</strong> type or if it's a number less than <strong class="source-inline">0</strong>. If <strong class="source-inline">num</strong> is a number, and it's greater than or equal to <strong class="source-inline">0</strong>, then the function will log the value of <strong class="source-inline">num</strong> and call itself again with <strong class="source-inline">num</strong> <strong class="source-inline">–2</strong>, and so the cycle repeats.</p></li>
				<li>By making these changes to the function, we are accounting for the initial input of an odd number, which would have bypassed our termination condition in the original function. We're also accounting for inputs where <strong class="source-inline">num</strong> is not of type <strong class="source-inline">number</strong>; say, a string or an object. But there are also some less obvious edge cases we need to be aware of. Let's see what happens when we call a function like this:<p class="source-code">countdownByTwo('bananas' * 2)</p><p>It turns out that multiplying <strong class="source-inline">bananas</strong> by <strong class="source-inline">2</strong> doesn't make any sense: JavaScript cannot coerce the result to a numerical value, and therefore it results in a value of <strong class="source-inline">NaN</strong>. </p><p>And what does this mean for our function? To answer that question, we need to establish what data type the <strong class="source-inline">NaN</strong> property is. You'd be forgiven for assuming that running <strong class="source-inline">typeof</strong> <strong class="source-inline">NaN</strong> would return something – anything – other than <strong class="source-inline">number</strong>, but you'd be wrong. As we saw in the previous chapter, <strong class="source-inline">NaN</strong> is a property of the <strong class="source-inline">Number</strong> object and is indeed of the <strong class="source-inline">number</strong> type. This results in yet another stack overflow, with the function logging <strong class="source-inline">NaN</strong> repeatedly until the maximum call stack size is reached. </p></li>
				<li>A similar problem would also occur when calling the function with Infinity, so it's clear that we need to add another check in our <strong class="source-inline">isFinite()</strong> function that returns true if its input is a finite and legal number to handle these edge cases:<p class="source-code">function countdownByTwo(num) {</p><p class="source-code">  if (typeof num !== 'number' || num&lt; 0 || !isFinite(num)) return;</p><p class="source-code">  console.log(num);</p><p class="source-code">  countdownByTwo(num - 2);</p><p class="source-code">}</p></li>
				<li>This function is used so that we can remove the <strong class="source-inline">typeof</strong> operator check. Now, we have a fairly robust set of termination cases for this function. There may still be other checks we would want to implement, such as limiting the size of the number that the function will count down from. For example, if we wanted to make sure the input is less than <strong class="source-inline">10,000</strong>, we could amend our <strong class="source-inline">if</strong> statement to the following:<p class="source-code">if (num&lt; 0 || num&gt; 10000 || !isFinite(num)) return;</p></li>
			</ol>
			<p>This results in the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer185">
					<img alt="Figure 7.13: Outputs from various inputs to countdownByTwo()&#13;&#10;" src="image/C14377_07_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13: Outputs from various inputs to countdownByTwo()</p>
			<p>In this exercise, we've seen a basic example of how we may inadvertently write code that works poorly with the JavaScript engine, and that we should handle as many different edge cases that our code may be presented with as possible.</p>
			<p>So far in this chapter, we've looked at the JavaScript runtime, what it is conceptually, and the processes and components it comprises. We've looked at the JavaScript engine in detail – particularly the V8 implementation – and how its call stack and memory heap interact with the other elements of the runtime.</p>
			<p>We've also looked at a common call stack error that developers face, and at the ways, we can ensure our code doesn't reach the maximum call stack size.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor346"/>Memory Management</h1>
			<p>We'll now move our attention to another core aspect of a computer's hardware – its memory. Memory management is an important, but often overlooked, aspect of developing software in JavaScript. Memory management simply refers to the allocation, use, and deallocation of system memory for the various data structures that make up our programs.</p>
			<p>There are two main approaches that are used by different programming languages to handle memory management: <strong class="bold">explicit allocation and deallocation</strong> and <strong class="bold">automatic allocation and deallocation</strong>. When writing software in an explicit memory management language, such as C-like languages, it's the software developer's job to tell the compiler when to allocate memory and how much to allocate to the software at any given stage. The developer also has to decide when that memory is no longer needed and explicitly tell the compiler to deallocate it. This increases the workload for the developer and can lead to frustrating bugs being introduced.</p>
			<p>Automatic memory management, on the other hand, removes the need for developers to explicitly allocate and deallocate memory, which, for the most part, makes the developer's job easier. The compiler requests memory from the operating system in two main stages: static allocation at compilation time and dynamic allocation at runtime. Modern JavaScript engines use <strong class="bold">Just-in-Time compilation</strong>, which makes use of more than one compiler – a baseline compiler – and one or more optimization compilers, which recompile and cache parts of the code so that it's more efficient. This forms a continuous loop of compilation, optimization, and decompilation/recompilation. The result of this is that JavaScript code is compiled and recompiled continuously at runtime, somewhat blurring the static and dynamic memory allocation stages.</p>
			<p>The memory allocation step is basically straightforward: the JavaScript engine identifies the amount of memory it needs and requests it from the operating system. Memory is then read from and written to as required by the program. The final stage of memory management, that is, deallocation, is the stage we need to focus on here. </p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor347"/>The Garbage Collector</h2>
			<p>JavaScript engines have an additional application called a garbage collector, which deals with the automatic deallocation of memory at runtime. The garbage collector uses a process called mark-and-sweep to identify objects that are no longer needed and remove them from memory. It does this by starting at a root object – for example, the global window object – and traversing each object that is referenced by the root. It then checks all child and grandchild objects referenced by those objects, and thus maps out all the objects that are reachable from the root. Anything that is cut off from this map, thus being unreachable by the root object, is marked for deletion and subsequently removed from memory:</p>
			<p class="source-code">let cat = {</p>
			<p class="source-code">  name: 'Professor Meow"</p>
			<p class="source-code">}</p>
			<p>Let's look at the following diagram:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer186">
					<img alt="Figure 7.14: References between objects&#13;&#10;" src="image/C14377_07_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14: References between objects</p>
			<p>In this simple case, the root object has a reference to the <strong class="source-inline">cat</strong> object, and the <strong class="source-inline">cat</strong> object has a reference to its <strong class="source-inline">name</strong> property, which is a string with the <strong class="source-inline">Professor Meow</strong> value. The garbage collector will see these references and will mark the <strong class="source-inline">cat</strong> object and its <strong class="source-inline">name</strong> property as reachable, and they will not be collected.</p>
			<p>If we now reassign <strong class="source-inline">cat</strong> to <strong class="source-inline">null</strong>, we will have removed the reference chain between the root object and the <strong class="source-inline">name</strong> property of <strong class="source-inline">cat</strong>:</p>
			<p class="source-code">cat = null; </p>
			<p>Let's look at the following diagram:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer187">
					<img alt="Figure 7.15: The reference is lost, and the memory is freed&#13;&#10;" src="image/C14377_07_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15: The reference is lost, and the memory is freed</p>
			<p>The <strong class="source-inline">cat</strong> object remains property of the global object, with a value of <strong class="source-inline">null</strong>, but any properties of <strong class="source-inline">cat</strong> that are not also referenced by another object linked to the root are removed from memory by the garbage collector.</p>
			<p>We can expand on this example to show how referencing an object from more than one other object can preserve its place in memory:</p>
			<p class="source-code">let mammal = {</p>
			<p class="source-code">  hasTeeth: true,</p>
			<p class="source-code">  furry: true</p>
			<p class="source-code">}</p>
			<p class="source-code">let cat = {</p>
			<p class="source-code">  name: 'Professor Meow",</p>
			<p class="source-code">  class: mammal</p>
			<p class="source-code">}</p>
			<p class="source-code">let dog = {</p>
			<p class="source-code">  name: 'Captain Woof",</p>
			<p class="source-code">  class: mammal</p>
			<p class="source-code">}</p>
			<p>Let's look at the following diagram:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer188">
					<img alt="Figure 7.16: Multiple references to the same object&#13;&#10;" src="image/C14377_07_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16: Multiple references to the same object</p>
			<p>The <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">mammal</strong> objects are all properties of the global object (the <strong class="source-inline">root</strong>, in garbage collector speak), and the <strong class="source-inline">cat</strong> and <strong class="source-inline">dog</strong> objects reference the <strong class="source-inline">mammal</strong> object through their <strong class="bold">class</strong> property.</p>
			<p>If we now reassign the <strong class="source-inline">mammal</strong> object to <strong class="source-inline">null</strong>, and once again the <strong class="source-inline">cat</strong> object to <strong class="source-inline">null</strong>, the reference from the <strong class="source-inline">global</strong> object to the <strong class="source-inline">mammal</strong> object via the <strong class="source-inline">cat</strong> object will be broken, as will its direct reference. However, since we have another reference to the <strong class="source-inline">mammal</strong> object via the <strong class="source-inline">dog</strong> object, the <strong class="source-inline">mammal</strong> object is still 'reachable" from the <strong class="source-inline">global</strong> object and is not collected by the garbage collector.</p>
			<p>You can see that, by inadvertently maintaining object references, you can make a program take up more memory than it needs. This is especially troubling for large datasets.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor348"/>Memory Leaks</h2>
			<p>Garbage collection is a handy process for us developers since it reduces the workload that comes with manually managing memory. But it's a double-edged sword; garbage collection happens automatically – we have no way of triggering the garbage collection process, nor do we know when the JavaScript engine will decide to do a garbage collection run – so it's easy for us to forget all about the potential pitfalls of memory management. But garbage collection is not a perfect process, or at least it doesn't always behave as we may expect it to. It will often fail to free up memory which, in actuality, is no longer needed. This is not a bug or mistake in the garbage collection process, it's just a symptom of a problem: the question of whether an object will be needed again later on during execution can only be answered with certainty by the developer. </p>
			<p>When a piece of memory is allocated but maintains a link to the root object, even after it's no longer needed in the program, it will never be freed and will remain allocated, thereby taking up system memory until the software's execution ends. This is a memory leak, and it's not hard to imagine that they can become big issues with large objects, or frequent reoccurrences. It's not always obvious when our application is suffering from a memory leak, especially if we're developing our applications on a powerful machine, so it's important to avoid the common mistakes and to keep an eye on our application's memory usage.</p>
			<p>Let's look at a few common memory leak scenarios and look at how we can avoid them.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor349"/>Event Listeners</h2>
			<p>One of the most common ways in which memory leaks occur comes from event listeners. Consider the following code:</p>
			<p class="source-code">document.getElementById('scrollable').addEventListener('scroll', function() {</p>
			<p class="source-code">  console.log('I've been scrolled!")</p>
			<p class="source-code">})</p>
			<p>It's quite common to see event listeners being added with an anonymous callback function, and it will work as expected (as long as there is an element with an ID of <strong class="source-inline">scrollable</strong>). However, by using an anonymous function, we are unable to remove the event listener at a later date should we need to, meaning that once this event listener is added, it will remain in place for the entirety of the program's execution, and, depending on the function, could be adding objects to memory every time it's called. To tackle this, let's declare a named function and then pass that function to the event listener:</p>
			<p class="source-code">let scrollHandler = function () {</p>
			<p class="source-code">  console.log('I've been scrolled!")</p>
			<p class="source-code">}</p>
			<p class="source-code">document.getElementById('scrollable').addEventListener('click', scrollHandler)</p>
			<p>Now that we have the handler function instead of an anonymous function, we can make use of the <strong class="source-inline">removeEventListener</strong> method if we want to remove the event listener later on in our program:</p>
			<p class="source-code">document.getElementById('scrollable').removeEventListener('scroll', scrollHandler)</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor350"/>Detached DOM Nodes</h2>
			<p>Any reference to a DOM node that's made by JavaScript will prevent that node's memory allocation from being freed, even if the node is subsequently removed from the DOM.</p>
			<p>For example, let's say we have an array of image sources that we want to add to the DOM. It would make sense to store the parent DOM node in a variable and add the images via this variable reference:</p>
			<p class="source-code">let imageParent = document.getElementById('image-wrapper');</p>
			<p class="source-code">imageSources.forEach(imgSrc =&gt; {</p>
			<p class="source-code">  let tempImg = document.createElement('img');</p>
			<p class="source-code">  tempImg.src = imgSrc;</p>
			<p class="source-code">  imageParent.appendChild(tempImg);</p>
			<p class="source-code">});</p>
			<p>So, now, we have all of the images attached to the DOM, but we have also created an additional reference to the image parent element; there is one reference in the DOM tree, and one via the JavaScript variable, that is, <strong class="source-inline">imageParent</strong>. Let's say that, later on in the program, we need to remove the image parent element:</p>
			<p class="source-code">document.body.removeChild(imageParent);</p>
			<p>This would remove the DOM node with the ID of <strong class="source-inline">image-wrapper</strong> from the DOM tree, but the variable, along with all its appended child <strong class="source-inline">img</strong> elements, is still referenced by the <strong class="source-inline">imageParent</strong> variable, and will still occupy memory, never to be collected by the garbage collector.</p>
			<p>The simple solution in this situation is to reassign the <strong class="source-inline">imageParent</strong> variable an <strong class="source-inline">undefined</strong> value after removing <strong class="source-inline">imageParent</strong> from the DOM.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor351"/>Global Variables</h2>
			<p>Since the mark-and-sweep algorithm looks for all the references connected to the roots of the memory object graph, any variables of the global object (the <strong class="source-inline">window</strong> object, in browser-based JavaScript, or the <strong class="source-inline">global</strong> object, in Node.js), will always be referenced and will therefore never be collected by the garbage collector.</p>
			<p>It's good practice to avoid declaring variables on the global object wherever possible, in other words, don't pollute the global namespace. There are a few good reasons for avoiding this, one of which is to avoid the resulting memory leaks.</p>
			<p>It's fairly obvious when variables are explicitly declared on the global object, but there are a couple of situations that can lead to unexpected global variables:</p>
			<p class="source-code">function makeGlobalCat() {</p>
			<p class="source-code">  cat = 'I'm a cat"</p>
			<p class="source-code">}</p>
			<p class="source-code">makeGlobalCat();</p>
			<p>This function creates an undeclared variable called <strong class="source-inline">cat</strong> that will implicitly be a property of the <strong class="source-inline">global</strong> object, even though it was created inside the function:</p>
			<p class="source-code">function makeGlobalDog() {</p>
			<p class="source-code">  this.dog = 'I'm a dog"</p>
			<p class="source-code">}</p>
			<p class="source-code">makeGlobalDog();</p>
			<p>Likewise, using the <strong class="source-inline">this</strong> keyword will create a global variable. You can declare a variable with <strong class="source-inline">var</strong>, <strong class="source-inline">let</strong>, or <strong class="source-inline">const</strong> inside a function, and it will have a function-level scope of that function, instead of having global scope, like it would with an undeclared variable. It's also a good idea to use the <strong class="source-inline">use strict</strong> statement at the top of your JavaScript files, which will result in an error being thrown if you try to create an undeclared variable.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor352"/>Identifying Memory Leaks</h2>
			<p>Despite our best efforts, memory leaks can creep into our code. They're often not obvious because the amount of memory they consume can be small, and they may grow relatively slowly, meaning they may not impact an application's performance unless they're kept running over many hours or days. And even when you find that you have a memory leak, it can be tricky to find the root cause.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor353"/>Exercise 7.03: Identifying Memory Leaks</h2>
			<p>Let's take a simple example and see how Chrome's developer tools can help us identify that we have a memory leak. Let's get started.</p>
			<ol>
				<li value="1">Open a new tab in Chrome, open <strong class="source-inline">Menu</strong> &gt; <strong class="source-inline">More Tools</strong> &gt; <strong class="source-inline">Developer tools</strong>, and go to the <strong class="source-inline">Sources</strong> tab:<div class="IMG---Figure" id="_idContainer189"><img alt="Figure 7.17: An empty code snippet&#13;&#10;" src="image/C14377_07_17.jpg"/></div><p class="figure-caption">Figure 7.17: An empty code snippet</p></li>
				<li>Click <strong class="source-inline">'+ New snippet'</strong> at the top left of this window and add the following code to set up our memory leak: First of all, we are creating a new DOM element of the <strong class="source-inline">div</strong> type and assigning it to a variable called <strong class="source-inline">imageWrappe</strong>r:<p class="source-code">// Create a div element</p><p class="source-code">let imageWrapper = document.createElement('div');</p><p class="callout-heading">Note</p><p class="callout">Every modern browser has its own set of developer tools. However, for dealing with memory leaks, Chrome's developer tools are the most useful.</p></li>
				<li>Next, we declare three functions that simulate some user interaction with our page. The first function, <strong class="source-inline">loadImages()</strong>, creates 50 new image elements and adds a data property to them of a string containing <strong class="source-inline">1,024 b</strong> characters. This is analogous to loading images and adding them to <strong class="source-inline">imageWrapper</strong>:<p class="source-code">function loadImages() {</p><p class="source-code">  for (let i = 0; I &lt; 50; +i) {</p><p class="source-code">    let img = document.createElement('img');</p><p class="source-code">    img.data = new Array(1024).join('b');</p><p class="source-code">    imageWrapper.appendChild(img);</p><p class="source-code">  } // Add 50 child images to the 'imageWrapper'</p><p class="source-code">}</p></li>
				<li>The next function, <strong class="source-inline">add()</strong>, simply adds the <strong class="source-inline">imageWrapper</strong> element to the end of the document body, and our third function <strong class="source-inline">remove()</strong> will be used to remove that image wrapper.<p class="source-code">function add() {</p><p class="source-code">  document.body.appendChild(imageWrapper);</p><p class="source-code">} // Add the 'imageWrapper' div to the end of body</p><p class="source-code">function remove() {</p><p class="source-code">  document.body.removeChild(imageWrapper);</p><p class="source-code">} // Remove the 'imageWrapper' div from the body</p></li>
				<li>Now, let's write one last function to tie these three together:<p class="source-code">function process() {</p><p class="source-code">  for (let i=0;i&lt;1000;i++) {</p><p class="source-code">    loadImages();</p><p class="source-code">    add();</p><p class="source-code">    remove();</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>This last function simulates adding and removing the image wrapper multiple times, thus loading 50 new images to it each time. A real-world example may be that we have a gallery of images and the user is clicking the '<strong class="source-inline">next</strong>" button to load the next set of images (in our scenario, they'd be clicking it 1,000 times!). Clearly, this would be a rather poor implementation of such a feature, but our aim here is to demonstrate how memory leaks can occur in a simple way. Your final code snippet should look something like this:<div class="IMG---Figure" id="_idContainer190"><img alt="Figure 7.18: Code snippet with all the process() code&#13;&#10;" src="image/C14377_07_18.jpg"/></div><p class="figure-caption">Figure 7.18: Code snippet with all the process() code</p></li>
				<li>Now, click the <strong class="source-inline">run snippet</strong> button to execute the code.</li>
				<li>Next, we will go to the performance tab of the dev tools and have a look at what's happening in the memory heap as we add and remove our images. From the performance tab, click the record button to start recording a performance profile. While it's recording, in the console, call the <strong class="source-inline">process()</strong> function, say, three times, and then hit the <strong class="source-inline">stop</strong> button. You should now see a screen that looks something like this:<div class="IMG---Figure" id="_idContainer191"><img alt="Figure 7.19: Memory heap of the performance tab of the developer tools&#13;&#10;" src="image/C14377_07_19.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.19: Memory heap of the performance tab of the developer tools</p>
			<p>This is the performance profile we have just recorded. It can tell us lots of information about the system resources that are being used by our application over the duration of the recording. The blue line here shows us how much of JavaScript's memory heap is being used over time. In an application without memory leaks, we would expect the memory usage to repeatedly go up with memory allocation and back down again to a base level with memory deallocation, giving us a <strong class="bold">sawtooth graph</strong>. In our case, though, it's only going in one direction – up. This is a sure sign that we have a memory leak in our code. The garbage collector is unable to determine that the <strong class="source-inline">images</strong> we've loaded are no longer needed after each call of <strong class="source-inline">process()</strong>, and so they stay in the memory heap. If you notice a real-life application becoming less performant over time, or using higher than expected system resources, then this is a good place to come to check for a memory leak. </p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor354"/>Exercise 7.04: Fixing the Memory Leak</h2>
			<p>Now that we've established that we have a memory leak – as shown by the JavaScript memory heap graph in the preceding screenshot – our next task is to fix our code so that it no longer contains the leak. Given what you know of the garbage collector and the reason for our leak, try to implement a fix for the previous code so that the garbage collector can see when our objects are no longer needed. After each function call, record a performance profile to see whether the garbage collector is able to free up the memory. What you're looking for is that the blue heap-memory allocation line goes up with memory allocation, but then comes back down again at regular intervals, showing that the memory is being deallocated. This is a sign of a garbage collector being able to deallocate the memory after each execution of the <strong class="source-inline">process()</strong> function. Let's get started:</p>
			<ol>
				<li value="1">Write a function and add it to the existing three functions that are called in the <strong class="source-inline">process</strong>:<p class="source-code">function resetImageWrapper() {</p><p class="source-code">  imageWrapper = document.createElement('div');</p><p class="source-code">}</p><p>Here, we've added one more function that is called <strong class="source-inline">resetImageWrapper()</strong>, which resets the <strong class="source-inline">imageWrapper</strong> object to an empty <strong class="source-inline">div</strong> element and added the function to our <strong class="source-inline">process()</strong> function's <strong class="source-inline">for…loop</strong>. Now, each time a set of images is removed from the DOM, its reference in JavaScript is also removed, and it can be marked by the garbage collector for deletion. </p></li>
				<li>The next step is to call this new function each time we process our images, so we will add it to our main <strong class="source-inline">process()</strong> function:<p class="source-code">function process() {</p><p class="source-code">  for (let i = 0; i&lt; 1000; i++) {</p><p class="source-code">    loadImages();</p><p class="source-code">    add();</p><p class="source-code">    remove();</p><p class="source-code">    resetImageWrapper();</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Once again, we'll run the performance profiler. Go to the dev tools, then to the <strong class="source-inline">Performance</strong> tab, and click the record button to begin a performance profile recording. Then, call the <strong class="source-inline">process()</strong> function a few times and take a look at the memory heap usage:<div class="IMG---Figure" id="_idContainer192"><img alt="Figure 7.20: Memory heap usage&#13;&#10;" src="image/C14377_07_20.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.20: Memory heap usage</p>
			<p class="callout-heading">Note </p>
			<p class="callout">As you probably noticed, the problem with our code was that we were storing references to each image element, and, therefore, the contents of its data attribute, inside the <strong class="source-inline">imageWrapper</strong> variable. The simple solution to this problem is to reassign the <strong class="source-inline">imageWrapper</strong> variable each time we remove it from the DOM.</p>
			<p>This is a much healthier memory heap profile. After each of the three <strong class="source-inline">process()</strong> function calls, the garbage collector could see that the images were no longer referenced by either the DOM or by JavaScript, and the space they were allocated in memory was freed up and given back to the memory pool.</p>
			<p>In this section, we've covered the two main techniques for dealing with memory management in different programming languages – manual and automatic – and looked at the browser's garbage collector processes. We then looked at the major con of automatic memory management and modern browsers' garbage collection algorithms, namely memory leaks, in more detail. Finally, we had an overview of one of the techniques we can use to identify when our application has such a leak.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor355"/>Activity 7.01: Finding out the Number of Stack Frames</h2>
			<p>Earlier in this chapter, we learned about JavaScript's call stack and saw that it's possible to generate an error if too many stack frames are added to the stack. Each implementation of a JavaScript engine can have a different limit regarding the size of the stack. In this activity, we'll write a function that will tell us when the maximum number of stack frames has been reached in the stack before the stack overflow error is triggered. </p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Add a function that calls itself repeatedly, causing the stack overflow.</li>
				<li>Keep count of the number of times the function calls itself. (This is like counting the number of stack frames getting pushed to the call stack.)</li>
				<li>Display the final number after the stack overflow error has occurred. Remember that no new functions can be called after a stack overflow error! <p>The output of this activity will be as follows:</p><div class="IMG---Figure" id="_idContainer193"><img alt="Figure 7.21: Showing the number of stack frames pushed before a stack overflow was triggered&#13;&#10;" src="image/C14377_07_21.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.21: Showing the number of stack frames pushed before a stack overflow was triggered</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 731.</p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor356"/>Summary</h1>
			<p>In this chapter, we have seen how the blocks of code many people think of as just 'JavaScript" can actually be broken down into separate components: the JavaScript engine, consisting of the call stack, memory heap, and the garbage collector (as well as other important components not covered by this chapter); and the JavaScript runtime environment, such as a browser, or Node.js, which contains the JavaScript engine, and gives the engine access to additional functions and interfaces, such as <strong class="source-inline">setTimeout()</strong> or a filesystem interface.</p>
			<p>We also looked at how JavaScript manages memory allocation and deallocation, and how even though it is managed automatically, it's important for developers to bear the processes involved in mind in order to write code that enables the garbage collector to work correctly.</p>
			<p>In the next chapter, we will look at different aspects of the environment API in more detail so that we can learn about some of the less commonly used features we can find in the browser and in Node.js.</p>
		</div>
	</body></html>