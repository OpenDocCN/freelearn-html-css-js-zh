- en: Chapter 8. Managing Data Using MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is the database for the MEAN stack, and we have already explored some
    of its more basic features. It is an extremely powerful, scalable, NoSQL database
    that has gained wide popularity for big data and web applications. It happens
    to be open source and supported on a wide variety of operating systems and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB can be accessed using the MongoDB shell, a command-line interface that
    uses JavaScript-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore MongoDB in greater depth and begin to incorporate
    it into our SPA. You will explore the various CRUD operations in the MongoDB shell,
    as well as using a Node.js plugin to access a database inside your single page
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commanding MongoDB using the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating MongoDB into the SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the NoSQL database model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is one of a number of NoSQL databases. Currently, it happens to be the
    most popular NoSQL database in use, according to statistics gathered by those
    who watch databases. SQL-based, relational databases have served us well for decades,
    so what's the big deal with NoSQL?
  prefs: []
  type: TYPE_NORMAL
- en: Defining NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is often referred to as a NoSQL database. NoSQL is a popular buzzword
    that applies to MongoDB and several other database engines. But what does it mean?
  prefs: []
  type: TYPE_NORMAL
- en: First, there is no standard definition by some governing body defining what
    NoSQL means. The term was first used in 1998 by Carlo Strozzi to describe an open
    source relational database that did not have an SQL interface. However, today
    the term is used differently. NoSQL databases tend to have two defining features.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name might imply, most NoSQL databases do not use SQL to access the database.
    There are some NoSQL databases, however, that allow languages that are SQL-like
    or derived from SQL. Therefore, some take NoSQL to mean *not only SQL*.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB databases are normally accessed through JavaScript-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Non-relational
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NoSQL databases do not use the relational model, where data is stored in structured
    tables of columns or rows. In the case of MongoDB, data is stored as documents
    in collections.
  prefs: []
  type: TYPE_NORMAL
- en: In relational databases, data is stored in tables, much like a table in a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB, and other NoSQL databases, are designed to be distributed to work well
    in clusters. This makes hosting NoSQL databases in the cloud among numerous servers
    easier and provides for security, backup, performance, and scaling.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB supports sharding. Sharding is a process where portions of the database
    are hosted on different servers. This can make MongoDB extremely fast and highly
    scalable.
  prefs: []
  type: TYPE_NORMAL
- en: While it's beyond the scope of this book, the distributed nature of MongoDB
    makes it appealing for big data projects. Certainly, it makes MongoDB a compelling
    solution for web applications, which is its most popular use currently.
  prefs: []
  type: TYPE_NORMAL
- en: Features of MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mongo has a number of features you should be aware of that make it different
    from other databases. They are explained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Document model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of models used by NoSQL databases. Some of these include
    the graph model, key-value model, object model, and others. These other models
    are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB uses the document model. Data is stored in collections of documents
    in a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a MongoDB document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, documents in MongoDB are a form of JSON. In this case, the document
    even contains a subdocument, the address.
  prefs: []
  type: TYPE_NORMAL
- en: The database itself binary encodes the documents and stores them in a form referred
    to as BSON. Not to worry, though, you will not have to be concerned about encoding
    or decoding any of the data yourself, that is all handled behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main differences between JSON and BSON is that BSON supports a number
    of data types not supported by JSON. This includes binary data, regular expressions,
    symbols, dates, and so on. For example, a date may be represented in JSON output
    as a simple string. However, storing a date as date type in BSON allows efficient
    date comparisons and operations as part of queries or insertions.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, this is not something you'll need to worry about. MongoDB
    will seamlessly convert the data into usable JSON. However, when we get to Mongoose,
    data validation will be an important feature that will be handled by middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Schemaless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the features of MongoDB, and some other NoSQL databases, is that it doesn't
    have a fixed schema.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, documents are stored in groups called *collections*. Documents stored
    in a collection should be related conceptually, but there is no restriction in
    the database software itself that enforces this. This is in stark contrast to
    databases where schemas strictly define the data which can be entered into a table.
  prefs: []
  type: TYPE_NORMAL
- en: There is a danger here that random documents can be placed into any collection
    making the organization of the collections meaningless. You could insert a document
    reflecting data for a car into a collection called pets, but this wouldn't make
    much sense and could render the data in that collection difficult to query meaningfully.
  prefs: []
  type: TYPE_NORMAL
- en: It bears some thought.
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB is an open source database. A number of various licenses apply to the
    server itself, the drivers, tools, and the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Complete licensing information for MongoDB is available at [https://www.mongodb.org/licensing](https://www.mongodb.org/licensing).
  prefs: []
  type: TYPE_NORMAL
- en: Why use MongoDB?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many choices of databases you could use to build a single page web
    application. For example, MySQL is a popular database for web applications overall.
    Why would you want to choose MongoDB over something like MySQL?
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, almost any database will do the job, but there are certain features
    in MongoDB that make it particularly attractive for use in SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Well supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB enjoys wide support on a number of operating systems and platforms.
    MongoDB has downloads and installers for Windows, multiple flavors of Linux, Mac,
    and Solaris.
  prefs: []
  type: TYPE_NORMAL
- en: One of the popular ways to run MongoDB in the cloud is on a **Platform as a
    Service** (**PaaS**). PaaS is a service, normally provided by a vendor such as
    Amazon, that allows developers to build web applications in the cloud without
    the hassle of managing infrastructure. MongoDB maintains a list of supported platforms
    at [https://docs.mongodb.org/ecosystem/platforms/](https://docs.mongodb.org/ecosystem/platforms/).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is supported in many popular languages. A quick visit to MongoDB's drivers
    page at [https://docs.mongodb.org/ecosystem/drivers/](https://docs.mongodb.org/ecosystem/drivers/)
    shows that, as of the time of writing this book, MongoDB has supported drivers
    for C, C++, C#, Java, Node.js, Perl, PHP, Python, Motor, Ruby, and Scala. Additionally,
    community-supported drivers for Go and Erlang, undoubtedly, may will be on the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Data model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because MongoDB's data model is based on JSON, it is ideal for use in web applications.
    JSON output can be consumed directly through frontend JavaScript and JavaScript
    frameworks such as AngularJs and others.
  prefs: []
  type: TYPE_NORMAL
- en: Because JSON is an object-oriented data format, the data works well with languages
    that are object-oriented themselves. The data structures can be modeled in the
    software you're writing very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Popularity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a developer, the popularity of the tools you are using is relatively important.
    For one thing, unpopular frameworks don't get the attention from development communities
    that popular ones get. Using a popular open source tool ensures that there is
    active development going on.
  prefs: []
  type: TYPE_NORMAL
- en: This extends to things such as books and learning resources, platform availability,
    and language support.
  prefs: []
  type: TYPE_NORMAL
- en: Popularity can also be an indication of quality or, at least, the quality of
    fit for popular types of applications. MongoDB has become very popular in **Big
    Data** circles, where unstructured data is the bread and butter or day-to-day
    operation. However, MongoDB really shines when it comes to some of the most popular
    types of web applications - such as CMS and geo-spatial data.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is extremely popular. According to the 2015 press release from MongoDB
    ([https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking](https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking)),
    MongoDB has surpassed PostgreSQL as the fourth most popular database. As of the
    press release, it was the only non-relational database in the top five. According
    to the same release, MongoDB has grown over 160% in popularity over the previous
    2 years.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is being used more and more in much wider places than many other databases.
    All indications are that it is going to be around, and be supported on all of
    the most popular platforms, for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Commanding MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB comes with an interactive shell, which we have already used briefly
    in the previous chapter. To refresh your memory, after starting the MongoDB daemon
    by typing `mongod`, you access the shell in a separate terminal window by typing
    `mongo`.
  prefs: []
  type: TYPE_NORMAL
- en: Primarily, you will be accessing MongoDB using native code in your application.
    However, understanding the MongoDB shell is invaluable to using it. There will
    be times when you want to access the shell directly, particularly for debugging.
    You may also need to manage a MongoDB instance in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: You should have a good grasp of the MongoDB shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important things you can do in the MongoDB shell is to manage
    your databases. Getting *meta* information out of MongoDB is most easily accomplished
    using shell commands. The following are some of the basic commands you can use
    in the MongoDB shell to get information.
  prefs: []
  type: TYPE_NORMAL
- en: '`help` - This will output a list of basic commands available in the MongoDB
    shell. For help with methods that operate on a database, you will use the `db.help()`
    method. Typing help into the MongoDB shell outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.help()`: Help on db methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.mycoll.help()`: Help on collection methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sh.help()`: Sharding helpers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rs.help()`: Replica set helpers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help admin`: Administrative help'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help connect`: Connecting to a db help'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help keys`: Key shortcuts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help misc`: Misc things to know'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help mr`: Mapreduce'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show dbs`: Show database names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show collection`s: Show collections in current database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show users`: Show users in current database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show profile`: Show most recent system.profile entries with time *s>= 1 m*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show logs`: Show accessible logger names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show log [name]`: Prints out last segment of log in memory; `global` is default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use <db_name>`: Set current database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.foo.find()`: List objects in the `foo` collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.foo.find( { a : 1 } )`: List objects in foo where a == 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it`: Result of the last line evaluated; use to further iterate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBQuery.shellBatchSize = x`: Set default number of items to display on shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit`: Quit Mongo shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the most important commands for gathering info from a database are the
    commands that begin with `show`. For example, `showdbs` will give you a list of
    the currently accessible database names on the system. `showcollections` will
    list the collections in the current database.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that isn't listed here is a method for retrieving the database on
    which you are currently operating. To do that, simply type `db` and the shell
    will output the name of the current database.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and updating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last chapter, we inserted some records using the insert method. You're
    going to do that a little differently here so that you can set up and load some
    data into your `giftapp` database, one that we created in the last chapter for
    the SPA you're building.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use two methods to insert data that you haven't used yet. One
    will be to execute a JavaScript file in the MongoDB shell which will set up and
    execute commands. We'll use this to insert some documents. The other method we'll
    use is a bulk operation that will allow us to set up some data and then execute
    and bulk insert it.
  prefs: []
  type: TYPE_NORMAL
- en: Running scripts in the MongoDB shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MongoDB shell allows you to load and execute JavaScript files. In your
    `giftapp` directory, create a new folder called `scripts` and create a JavaScript
    file called `db-init.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `db=db.getSiblingDB('giftapp'),` tells the MongoDB shell which
    database to work with in case you haven't already selected the `giftapp` database
    in some way. We need to use this method because the `use` command isn't valid
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you create two objects, `user1` and `user2`, using JavaScript object literal
    notations. These objects represent user data for the users' `Mark Smith` and `Sally
    Jones`. You then create an array called users that contains the two user objects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we invoke the `insert` method on the users collection and pass it the
    users array. If there is no users collection in the `giftapp` database, one will
    be created when we execute this script.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when an array is passed to the insert method, MongoDB will insert
    each document separately. This is a powerful feature allowing for easy and efficient
    multiple document inserts.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we can load and execute this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command-line in a terminal not running the MongoDB shell, navigate
    to the directory where the script is stored and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, there won''t be any really useful output to tell you that the
    inserts were completed. If you start the MongoDB shell, or use a terminal where
    it''s already running, you can verify by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The count method returns the number of documents in a collection. Here, there
    are two. We've already explored the find method. Here we invoke find with no arguments,
    which returns all the documents in the collection. You can see that `Mark` and
    `Sally` are now documents stored separately in the users collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this script multiple times, it will create numerous `Mark` and `Sally`
    documents. If you want to clean out the collection and start over, you can use
    the drop method and verify using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I promised you a second method of running scripts, and we''ll get to that.
    Let''s make a small modification to the script first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We added a variable called `now` that contains a new `Date` object. Creating
    a `Date` object in this way sets the date and time in the object to the current
    date and time. Next, we add a field called `created` to `Mark` and `Sally`, and
    give it the value of now, our date object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal running the MongoDB shell, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the load method to run the script, passing it the path to the script.
    We see that the two users have been added to the collection, and the find method
    retrieves their documents.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the created field on `Mark` and `Sally` documents you'll see
    something new. The `Date` may look a little different. Internally, MongoDB stores
    dates as a 64-bit integer representing the number of milliseconds since January
    1st, 1970\. Negative numbers are used to represent dates before that.
  prefs: []
  type: TYPE_NORMAL
- en: Storing dates and times as integers likes this, instead of strings, allows things
    such as date calculations and comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, MongoDB outputs dates in a somewhat usable and readable format.
    We will explore displaying dates in a more human friendly way in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running bulk operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to insert multiple documents into a MongoDB collection in a single
    pass is to use MongoDB's `Bulk` API. This allows us to set up a list of ordered
    or unordered operations and then run them all when we choose to execute We can
    experiment with this using the MongoDB shell commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we opened up an unordered bulk operation on users and assigned
    it to the variable called `bulk`. We could also have made that an ordered operation,
    but we don't currently care about the order in which the inserts are executed.
  prefs: []
  type: TYPE_NORMAL
- en: We then add two `insert` commands to the bulk operation, one for `John Smith`,
    and another for `Jane Smothers`. We can then call execute on the `bulk` operation.
    The returned value tells us that there were no errors and that two documents were
    inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at our collection now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I added the `pretty` method to the end of the `find` method in order to tidy
    up our output and make it a bit more readable. As you can see, `John` and `Jane`
    have been added to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: Finding, modifying, and removing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queries are how we search for and return data out of our database. We've been
    using queries all along every time we have used the `find` method. We know that
    find, on its own, will return every single document in a collection. That's not
    exactly useful.
  prefs: []
  type: TYPE_NORMAL
- en: Specific results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, we want to query a collection and return specific results. We want
    only those states that export peanuts, or we want a list of customers who live
    in France.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify that we want documents where a specific field matches a specific
    value, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I''ve called the find operation and passed it an object with a single
    field: `lastname`. This is called the criteria. The value of that field is `Smith`.
    As you can see this returned the record for `John Smith`. For more than one field,
    you would separate the fields by commas.'
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute, shouldn't I also see the document for `Mark Smith`? If you look
    carefully, the documents for `Mark Smith` and `Sally Jones` camelcase `firstName`
    and `lastName`. That is, the `N` is a capital letter. Therefore, MongoDB doesn't
    see this as the same field.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good illustration of one of the dangers of schemaless databases, and
    something to keep in mind. We will fix this in the section on updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to get documents for users with `lastName` fields matching
    `Smith` or `Jones`. There are a couple of ways you could write this query, but
    the best way when comparing the same field is to use the `$in` operator, as shown
    in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Query operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB comes with a number of operators that all begin with the dollar sign.
    They are used for modifying and comparing within query criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of types of query operators that include comparison operators
    such as `$eq`: equal to, `$gt`: greater than, and `$lte`: less than or equal to.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This would return all documents in the `users` collection that had a `payrate`
    field with a value greater than `45`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical operators include `$or`, `$and`, `$not`, and `$nor`. Each of these
    behaves like you''d expect if you''re used to logical operators. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This query returns all documents that have a `firstName` field equal to `Steve`
    and a `lastName` field equal to `Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB includes two element operators: `$exists`: to check if a field exists,
    and `$type`: to check the type of a specified file. Take a look at the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This query returns all documents in the `users` collection that have a `car`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB includes a number of other operators. These include things such as `regex`
    matching and geospatial comparison. There are also operators comparing arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For a more complete list of operators, see the MongoDB documentation on operators
    at [https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/).
  prefs: []
  type: TYPE_NORMAL
- en: Projections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered projections briefly in the previous chapter but, to refresh your
    memory, a projection specifies the fields returned in a query. We don't always
    want all of the fields in the documents that we return, so a projection lets us
    limit the data to the fields we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Projections will be the second argument to the find method, as shown in the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We specified that we wanted all documents in the collection by passing an empty
    object as the first argument to find. Then, we used a projection to tell MongoDB
    that we wanted to see the `email` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that the `_id` field is returned in the results. This is a default.
    To suppress that, we give it a value of `0` in the find in the projection as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this query, `email` is included, while `_id` is excluded.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a number of projection operators. You can find the details for
    those in the MongoDB documentation at [https://docs.mongodb.org/v3.0/reference/operator/query/](https://docs.mongodb.org/v3.0/reference/operator/query/).
  prefs: []
  type: TYPE_NORMAL
- en: Query modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, query modifiers are used to modify the data coming back
    from a query. This includes doing things such as sorting, or returning a maximum
    number of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of modifiers in Mongo DB (I prefer the first). Take a look
    at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me illustrate with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I am selecting all documents in the users collection. I am returning
    only the `email` field (and suppressing the `_id` field). I am then sorting by
    ascending order by `email`. If we wanted to sort the documents by the `email`
    field in descending order, we would make the value in the modifier `-1`, as shown
    in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Modifying data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To modify MongoDB documents, you generally use the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do a find just to display the document for `Jane Smothers`. We want
    to change the e-mail address of `Jane`, so we use the `update` method. The first
    argument to the `update` method is the same criteria used in the find method to
    select a document or set of documents. The second argument is the instruction
    for the update.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've used the `$set` operator to change the e-mail address. If there
    wasn't an `email` field in the document, the `$set` operator would create a new
    field.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that update, by default, will only update a single document.
    To update multiple documents, you set a multi option as part of a third option
    to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our users collection to make the fields for `firstname` and `lastname`
    into camelcase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to the `update` method uses the `$exists` operator to select
    any documents without the camelcase `lastname` field. The second argument uses
    the `$rename` operator to change both `firstname` and `lastname` field names to
    camelcase. The final argument sets the multi option to `true`, telling MongoDB
    to update all of the matched documents.
  prefs: []
  type: TYPE_NORMAL
- en: The result shows us that two documents were matched and two documents were updated.
    Running the `find` method shows us that all documents now have the same field
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, if the query part of the `update` method doesn''t match any documents,
    MongoDB doesn''t do anything. We can tell MongoDB to create a new document if
    none are matched using the `upsert` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we select documents where an `email` field matches `johnny5@fbz22.com`.
    As we know, there are no documents matching this query. The second argument to
    `update` lists the data we want to change. Finally, we set the `upsert` option
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The write result shows us that no documents were matched or modified, but that
    a single document was upserted.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking find shows us that the record for `Johnny Fiverton` has been added.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we did not use the `$set` operator this time around.
    If the second argument in update uses no operators, MongoDB will replace the entire
    document with the data in the second argument. This is something to be careful
    of; use `$set` when you don't want to replace the entire documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of `update` operators is available in the MongoDB documentation: [https://docs.mongodb.org/v3.0/reference/operator/update/](https://docs.mongodb.org/v3.0/reference/operator/update/).'
  prefs: []
  type: TYPE_NORMAL
- en: Removing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have covered the: create, read, and update components of CRUD (create,
    read, update, delete). The remaining part is deleting documents. For deletion,
    MongoDB has the `remove` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Remove` has a somewhat familiar signature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And it's goodbye `Johnny`.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably surmise that the first argument to remove is the query. Here,
    we have selected all documents with an `email` field matching `johnny5@zfb22.com`.
    In this case, there is only one. The write result tells us that the number of
    documents removed is one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution: by default, remove will delete all matched documents. If
    the query is an empty object, remove will delete everything in the collection.
    The indexes, however, will stay intact. To ensure that you are only removing a
    single document, you set the `justOne` parameter, the second optional argument
    to remove, to `1,` as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This would remove a single `Smith` from our users collection.
  prefs: []
  type: TYPE_NORMAL
- en: The cursor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In MongoDB, the result of invoking `db.collection.find()` is actually a `cursor`.
    A `cursor` is a pointer to the results of a query. In the MongoDB shell, if you
    do not assign a `cursor` to a variable, the cursor is automatically iterated and
    output. This is what we have been doing so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a variable called `cursor` and assign to it the `cursor` returned
    by the `find` method. We then manually iterate the `cursor` simply by typing its
    name and hitting *Enter*. Typing the `cursor` name again and hitting *Enter* does
    nothing because the `cursor` has already been iterated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This, in itself, isn''t very useful, but we can do all kinds of things with
    the cursor. For example, if we wanted to put all of our documents into an array
    we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB offers a ton of built-in cursor methods. Documentation for MongoDB
    JavaScript cursor methods can be found at: [https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods](https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating MongoDB into the SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All this command-line stuff is great, but we need to start incorporating our
    MongoDB database into our SPA. In a future chapter, we will introduce the `mongoose`
    plugin for node, which will allow us to do data modeling, and which will perform
    a lot of heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we're going to add a connection to MongoDB into our SPA in a simple
    way, which will highlight how to incorporate our database and display some dynamic
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the NPM modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this chapter, we need two modules to connect and easily access our MongoDB
    database inside our Express application. Those modules are `mongodb` and `monk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, navigate to your `giftapp` directory and type the following
    (remember to lead with `sudo` if you''re on a Mac or Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependencies section of your `package.json` file should now look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Adding MongoDB into the main application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to make our MongoDB database accessible inside the main application.
    We''re going to add a few lines to our `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the first highlighted section, we load the `mongodb` and `monk` modules using
    the require method. We then instantiate the database connection by invoking `monk`
    and assigning the connection to the variable `db`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write a small piece of middleware. Note that it's important that this
    middleware shows up before the routing middleware. The middleware attaches the
    database connection to the request object and then passes it on to the next middleware
    by invoking the next function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s get some data out of your database and displayed onto the browser.
    For that, we need to add a new route. Open up your `routes/users.js` file and
    we''ll add a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will cover Express routing in depth in a later chapter, but what we've done
    here is create a new router for the `/show` path after `/users`. We've aliased
    the database from the request object and set the collection we're interested in
    using the monk `get` method.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `monk` find method on the collection, passing an empty query.
    We know from our command-line experiments that an empty query should return all
    records in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The last argument to find here is a `callback` function, which is executed when
    the query returns. The first argument to this function receives an error if the
    query results in an error. The second argument receives the documents returned
    from the query.
  prefs: []
  type: TYPE_NORMAL
- en: We check to make sure there's no error, and if there isn't, we output the documents
    using the response object's `json` function. As the name implies, the output is
    returned to the browser as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that your MongoDB daemon is still running, or restart it in a terminal
    window. In another terminal window, navigate to your `giftapp` directory and type
    `npm start` to start up your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigating to `localhost:3000/users/show` in your browser will display something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's not pretty, but it is an array that contains all of our documents in JSON
    format. We could already consume this as a web service, but let's do something
    a little prettier with it.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data in a page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s format our data and put it into an HTML page to make it a little nicer
    to look at. Inside your `views` folder, create a new folder called `users`. Inside
    there, create a new file called `show.ejs` with the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've created an embedded JavaScript document here that takes a collection of
    items called `users`. We iterate over that using the `forEach` function, assigning
    each instance to a variable called `user`.
  prefs: []
  type: TYPE_NORMAL
- en: For each pass through we create a table row. That table row contains table data
    elements for the user's first name, last name, and e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: This alone won't work; we have to query the database and pass the data to the
    page. To do that we need to change up the route we just created to render this
    template and pass the docs we retrieve to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes to the `users` router file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The only real change here is that we've commented out the line that sent the
    results as JSON back to the browser using the response's `json` method. Instead,
    we use the response's render function to choose the `users/show.ejs` template,
    and pass the retrieved docs as a property called `users`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you restart the `giftapp` server and navigate to `localhost:3000/users/show`,
    you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying data in a page](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how using Express with MongoDB gives us a lot of ease and flexibility
    in sending data to the browser. It's a simple thing to send JSON formatted data,
    and it is also simple to render pages dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: As we continue to build our SPA, we will rely more on building out web services
    which will return JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB database performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topics such as replication and sharding are beyond the scope of this book. However,
    there are a number of things developers can do to optimize the performance of
    your MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, we'll talk about cover indexing and tuning queries for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many database systems, adding an `index` in a field when appropriate can
    speed up querying. Queries are optimized when performed on indexed fields. MongoDB
    is no different.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to indexes is that they add some extra time to write operations.
    They also take up extra space in the database. It makes sense to index wisely.
    When considering adding indexes, you want to think about whether you expect more
    read than write operations. This would be a plus for adding additional indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an index to our user collection. We''ll say that we want to frequently
    look up our users by their last names. It makes sense to add an `index` on the
    `lastname` field, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We use the collection's `createIndex` method command passing it an object containing
    a single field. That field has the key of `lastname` with a value of `1`. This
    tells MongoDB that we want to create an index where we store the `lastname` fields
    in the collection in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, this creates a list of all the last names in ascending order, with
    pointers to the documents. Read operations keyed to the `lastname` field are efficient
    because the MongoDB engine doesn't have to search through every single document
    in the collection to find matching values, it can just search the list of last
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Write operations will be slightly slower, because they will also have to update
    the `index`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web application performance can be impacted by slow data read operations. Optimizing
    database operations can help in scaling operations, but also in perceived performance,
    enhancing user satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways developers can significantly impact performance is by optimizing
    queries. The main methods for reducing the amount of time taken for queries revolve
    around reducing the amount of data returned and by using indexes to make the lookup
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using limit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `limit()` method, when added to a query, limits the number of records returned
    in the query. Limiting the number of records returned means less data transfer
    and thus faster performance and less use of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We've added the `limit` function here to find with no query, giving it an argument
    of 2\. This tells MongoDB to return two documents, which you can see here.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can still add the `pretty()` function onto the end by chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Using projections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already discussed projections as a way to limit the number of fields
    returned per document. Projections are another tool that reduce data transfer,
    as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this query, we've added a projection to show `email` and suppress `_id`.
    We've kept the `limit` function. The result is two documents each containing only
    the `email` field.
  prefs: []
  type: TYPE_NORMAL
- en: Using hint()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `hint()` function forces MongoDB to use a particular `index` for a
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, we created an `index` on the `lastname` field of the `users`
    collection earlier. However, this isn''t going to help us, since we changed our
    documents to use the camelCased field name `lastName`. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that both `_id` and `lastname` are indexes. Let''s drop `lastname`
    and add `lastName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can execute our query ensuring we use the `lastName` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you'd like to get into the nitty-gritty of a query, you can use the `explain()`
    method tacked onto a query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To make sense of the output, consult the MongoDB documentation at [https://docs.mongodb.org/v3.0/reference/explain-results/](https://docs.mongodb.org/v3.0/reference/explain-results/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a flexible and scalable NoSQL database. It's non-relational, maintaining
    its records as documents in collections as opposed to rows in tables. MongoDB
    is schemaless; its collections are flexible and do not enforce a particular data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB documents are stored as binary encoded JSON, or BSON. The object-oriented
    nature of its documents makes MongoDB well suited for use with object-oriented
    languages such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As with all databases, MongoDB offers CRUD operations. Operations on MongoDB
    are carried out using JavaScript-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing MongoDB performance as a developer involves reducing the amount of
    data returned by queries and using indexes well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will begin handling web requests for your SPA using
    the Express web application framework.
  prefs: []
  type: TYPE_NORMAL
