<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Creating Your First 3D Scene with Three.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Creating Your First 3D Scene with Three.js</h1></div></div></div><p>Modern browsers are slowly getting more powerful features that can be accessed directly from JavaScript. You can easily add video and audio with the new HTML5 tags and create interactive components through the use of the HTML5 canvas. Together with HTML5, modern browsers also started supporting WebGL. With WebGL, you can directly make use of the processing resources of your graphics card and create high-performance 2D and 3D computer graphics. Programming<a id="id0" class="indexterm"/> WebGL directly from JavaScript to create and animate 3D scenes is a very complex and error-prone process. Three.js is a library that makes this a lot easier. The following list shows some of the things that Three.js makes easy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating simple and complex 3D geometries</li><li class="listitem" style="list-style-type: disc">Animating and moving objects through a 3D scene</li><li class="listitem" style="list-style-type: disc">Applying textures and materials to your objects</li><li class="listitem" style="list-style-type: disc">Making use of different light sources to illuminate the scene</li><li class="listitem" style="list-style-type: disc">Loading objects from 3D-modeling software</li><li class="listitem" style="list-style-type: disc">Adding advanced postprocessing effects to your 3D scene</li><li class="listitem" style="list-style-type: disc">Working with your own custom shaders</li><li class="listitem" style="list-style-type: disc">Creating point clouds</li></ul></div><p>With a couple of lines of JavaScript, you can create anything, from simple 3D models to photorealistic real-time scenes, as shown in the following screenshot (see it yourself by opening <a class="ulink" href="http://www.vill.ee/eye/">http://www.vill.ee/eye/</a> in your browser):</p><div class="mediaobject"><img src="graphics/2215OS_01_01.jpg" alt="Creating Your First 3D Scene with Three.js"/></div><p>In this chapter, we'll directly dive into Three.js and create a couple of examples that show you how Three.js works, and which you can use to play around with. We won't dive into all the technical details yet; that's something you'll learn in the following chapters. In this chapter, we'll cover the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tools required to work with Three.js</li><li class="listitem" style="list-style-type: disc">Downloading the source code and examples used in this book</li><li class="listitem" style="list-style-type: disc">Creating your first Three.js scene</li><li class="listitem" style="list-style-type: disc">Improving the first scene with materials, lights, and animations</li><li class="listitem" style="list-style-type: disc">Introducing a couple of helper libraries for statistics and controlling the scene</li></ul></div><p>We'll start this book with a short introduction to Three.js and then quickly move on to the first examples and code samples. Before we get started, let's quickly look at the most important browsers out there and their support for WebGL.</p><p>At the time of writing this, WebGL works with the following desktop browsers:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Browser</p>
</th><th style="text-align: left" valign="bottom">
<p>Support</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Mozilla Firefox</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id1" class="indexterm"/> browser has supported WebGL since version 4.0.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Google Chrome</p>
</td><td style="text-align: left" valign="top">
<p>This browser has supported WebGL since version 9.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Safari</p>
</td><td style="text-align: left" valign="top">
<p>Safari Version 5.1 and newer installed on Mac OS X Mountain Lion, Lion, or Snow Leopard supports WebGL. Make sure you enable WebGL in Safari. You can do this by going to <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Advanced</strong></span> and checking <span class="strong"><strong>Show develop menu in menu bar</strong></span>. After that, go to <span class="strong"><strong>Develop</strong></span> | <span class="strong"><strong>Enable WebGL</strong></span>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Opera</p>
</td><td style="text-align: left" valign="top">
<p>This browser has supported WebGL since version 12.00. You still have to enable this by opening <span class="strong"><strong>opera:config</strong></span> and setting the values of <span class="strong"><strong>WebGL</strong></span> and <span class="strong"><strong>Enable Hardware Acceleration</strong></span> to <code class="literal">1</code>. After that, restart the browser.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Internet Explorer</p>
</td><td style="text-align: left" valign="top">
<p>Internet Explorer<a id="id2" class="indexterm"/> was for a long time the only major player that didn't support WebGL. Starting with IE11, Microsoft has added WebGL support. </p>
</td></tr></tbody></table></div><p>Basically, Three.js runs on any of the modern browsers except older versions of IE. So, if you want to use an older version of IE, you've got to take an additional step. For IE 10 and older, there is the <span class="emphasis"><em>iewebgl</em></span> plugin, which you can get from <a class="ulink" href="https://github.com/iewebgl/iewebgl">https://github.com/iewebgl/iewebgl</a>. This<a id="id3" class="indexterm"/> plugin is installed inside IE 10 and older versions and enables WebGL support for those browsers.</p><p>It is also possible to run Three.js on mobile devices; the support for WebGL and the performance you'll get will vary, but both are quickly improving:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device</p>
</th><th style="text-align: left" valign="bottom">
<p>Support</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Android</p>
</td><td style="text-align: left" valign="top">
<p>The native browser for Android doesn't have WebGL support and is generally also lacking in support for modern HTML5 features. If you want to use WebGL on Android, you can use the latest Chrome, Firefox, or Opera mobile versions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>IOS</p>
</td><td style="text-align: left" valign="top">
<p>With IOS 8, there is also support for WebGL on IOS devices. IOS Safari version 8 has great WebGL support.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Windows mobile</p>
</td><td style="text-align: left" valign="top">
<p>Windows mobile supports WebGL since version 8.1.</p>
</td></tr></tbody></table></div><p>With WebGL, you can create interactive 3D visualizations that run very well on desktops and on mobile devices.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>In this book, we'll focus mostly on the WebGL-based renderer provided by Three.js. There is, however, also a CSS 3D-based renderer, which provides an easy API to create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach is that this standard is supported on almost all mobile and desktop browsers and allows you to render HTML elements in a 3D space. We'll show how to use the CSS 3D browser in <a class="link" href="ch07.html" title="Chapter 7. Particles, Sprites, and the Point Cloud">Chapter 7</a>, <span class="emphasis"><em>Particles, Sprites, and the Point Cloud</em></span>.</p></div></div><p>In this first chapter, you'll directly create your first 3D scene and will be able to run this in any of the previously<a id="id4" class="indexterm"/> mentioned browsers. We won't introduce too many complex Three.js features yet, but at the end of this chapter, you'll have created the Three.js scene you can see in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_01_02.jpg" alt="Creating Your First 3D Scene with Three.js"/></div><p>For this first scene, you'll learn about the basics of Three.js and also create your first animation. Before you start your work on this example, in the next couple of sections, we'll first look at the tools you need to easily work with Three.js and how you can download the examples shown in this book.</p><div class="section" title="Requirements to use Three.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Requirements to use Three.js</h1></div></div></div><p>Three.js is a<a id="id5" class="indexterm"/> JavaScript library, so all you need to create Three.js WebGL applications is a text editor and one of the supported browsers to render the results. I would like to recommend two JavaScript editors, which I've started using exclusively over the last couple of years:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WebStorm</strong></span>: This editor from the JetBrains guides has great support for editing JavaScript. It supports <a id="id6" class="indexterm"/>code completion, automatic deployment, and JavaScript debugging<a id="id7" class="indexterm"/> directly from the editor. Besides this, WebStorm has excellent GitHub (and other version<a id="id8" class="indexterm"/> control systems) support. You can download a trial edition from <a class="ulink" href="http://www.jetbrains.com/webstorm/">http://www.jetbrains.com/webstorm/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Notepad++</strong></span>: Notepad++ is a general-purpose editor that supports code highlighting for a wide <a id="id9" class="indexterm"/>range of<a id="id10" class="indexterm"/> programming languages. It can easily lay out and format JavaScript. Note<a id="id11" class="indexterm"/> that Notepad++ is only for Windows. You can download Notepad++ from <a class="ulink" href="http://notepad-plus-plus.org/">http://notepad-plus-plus.org/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sublime Text Editor</strong></span>: Sublime is a great editor that has a very good support to edit JavaScript. Besides this, it<a id="id12" class="indexterm"/> provides <a id="id13" class="indexterm"/>many very helpful selections (such as multiple-line select) and edit options that, once you get used to them, provide a really good JavaScript-editing environment. Sublime can also be tested for <a id="id14" class="indexterm"/>free and can be downloaded from <a class="ulink" href="http://www.sublimetext.com/">http://www.sublimetext.com/</a>.</li></ul></div><p>Even if you don't use any of these editors, there are a lot of editors available, open source and commercial, which you can use to edit JavaScript and create your Three.js projects. An interesting project <a id="id15" class="indexterm"/>you might want to look at is <a class="ulink" href="http://c9.io">http://c9.io</a>. This is a cloud-based JavaScript editor that can be connected to a GitHub account. This way, you can directly access all the source code and examples from this book and experiment with them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Besides these text-based editors that you can use to edit and experiment with the sources from this book, Three.js currently also provides an online editor itself.</p><p>With this editor, which you can find at <a class="ulink" href="http://threejs.org/editor/">http://threejs.org/editor/</a>, you can create Three.js scenes using a graphical approach.</p></div></div><p>I mentioned that most modern web browsers support WebGL and can be used to run Three.js examples. I usually run my code in Chrome. The reason is that most often, Chrome has the best support and performance for WebGL and it has a really great JavaScript debugger. With this debugger, which is shown in the following screenshot, you can quickly pinpoint problems, for instance, using breakpoints and console output. This is exemplified in the following screenshot. Throughout this book, I'll give you pointers on debugger usage and other debugging tips and tricks.</p><div class="mediaobject"><img src="graphics/2215OS_01_03.jpg" alt="Requirements to use Three.js"/></div><p>That's enough for <a id="id16" class="indexterm"/>an introduction to Three.js for now; let's get the source code and start with the first scene.</p></div></div>
<div class="section" title="Getting the source code"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting the source code</h1></div></div></div><p>All the code for this<a id="id17" class="indexterm"/> book can be accessed from GitHub (<a class="ulink" href="https://github.com/">https://github.com/</a>). GitHub is an online Git-based repository that you can use to store, access, and version source code. There are a couple of ways that you can get the sources for yourself:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clone the Git repository</li><li class="listitem" style="list-style-type: disc">Download and extract the archive</li></ul></div><p>In the following two paragraphs, we'll explore these options in a bit more detail.</p><div class="section" title="Using Git to clone the repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Using Git to clone the repository</h2></div></div></div><p>Git is an open source<a id="id18" class="indexterm"/> distributed version control <a id="id19" class="indexterm"/>system that I used to create and version all the examples in this book. For this, I used GitHub, a free, online Git repository. You can browse<a id="id20" class="indexterm"/> this repository by <a class="ulink" href="https://github.com/josdirksen/learning-threejs">https://github.com/josdirksen/learning-threejs</a>.</p><p>To get all the examples, you can clone this repository using the <a id="id21" class="indexterm"/>
<code class="literal">git</code> command-line tool. To do this, you first need to download <a id="id22" class="indexterm"/>a Git client for your operating system. For most modern operating systems, a client can be downloaded from <a class="ulink" href="http://git-scm.com">http://git-scm.com</a>, or you can use the one provided by GitHub itself (for Mac and Windows). After installing Git, you<a id="id23" class="indexterm"/> can use this to get a <span class="emphasis"><em>clone</em></span> of this book's repository. Open a command prompt and go to the directory where you want to download the sources. In that directory, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># git clone https://github.com/josdirksen/learning-threejs</strong></span>
</pre></div><p>This will start downloading all the examples, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_01_04.jpg" alt="Using Git to clone the repository"/></div><p>The <code class="literal">learning-three.js</code> directory will now contain all the examples that are used throughout this book.</p></div><div class="section" title="Downloading and extracting the archive"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Downloading and extracting the archive</h2></div></div></div><p>If you <a id="id24" class="indexterm"/>don't want to use Git to download the sources directly from GitHub, you <a id="id25" class="indexterm"/>can also download an archive. Open <a class="ulink" href="https://github.com/josdirksen/learning-threejs">https://github.com/josdirksen/learning-threejs</a> in a browser and click on the <span class="strong"><strong>Download ZIP</strong></span> button on the right-hand side, as follows:</p><div class="mediaobject"><img src="graphics/2215OS_01_05.jpg" alt="Downloading and extracting the archive"/></div><p>Extract this to a directory of your choice, and you'll have all the examples available.</p></div><div class="section" title="Testing the examples"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Testing the examples</h2></div></div></div><p>Now that you've downloaded or cloned the source code, let's do a quick check to see whether everything is <a id="id26" class="indexterm"/>working and make you familiar with the directory structure. The code and examples are organized per chapter. There are two different ways of viewing examples. You can either open the extracted or cloned folder in a browser directly and look at and run a specific example, or you can install a local web server. This first approach will work for most of the basic examples, but when we start loading external resources, such as models or texture images, just opening the HTML file isn't enough. In this case, we need a local web server to make sure the external resources are loaded correctly. In the following section, we explain a couple of different ways you can set up a simple local web server for testing. If you can't set up a local web server but use Chrome or Firefox, we also provide an explanation on how to disable certain security features so that you can even test without a local web server.</p><p>Setting up a local web server is very easy depending on what you've already got installed. In here, we list a couple of examples on how to do this. There are many different ways to do this depending on what you've already got installed on your system.</p><div class="section" title="Python-based web servers should work on most Unix/Mac systems"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Python-based web servers should work on most Unix/Mac systems</h3></div></div></div><p>Most Unix/Linux/Mac systems<a id="id27" class="indexterm"/> already have Python installed. On those systems, you can very easily start a local web server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> &gt; python -m SimpleHTTPServer</strong></span>
<span class="strong"><strong> Serving HTTP on 0.0.0.0 port 8000 ...</strong></span>
</pre></div><p>Do this in the directory where you checked out / downloaded the source code.</p></div><div class="section" title="Npm-based web server if you've worked with Node.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Npm-based web server if you've worked with Node.js</h3></div></div></div><p>If you've already done <a id="id28" class="indexterm"/>some work with Node.js, there is good chance you've got npm installed. With npm, you have two<a id="id29" class="indexterm"/> simple options to set up a quick local web server for testing. The first options uses the <code class="literal">http-server</code> module, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> &gt; npm install -g http-server</strong></span>
<span class="strong"><strong> &gt; http-server</strong></span>
<span class="strong"><strong>Starting up http-server, serving ./ on port: 8080</strong></span>
<span class="strong"><strong>Hit CTRL-C to stop the server</strong></span>
</pre></div><p>Alternatively, you can also use the <code class="literal">simple-http-server</code> option, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; npm install -g simple-http-server</strong></span>
<span class="strong"><strong>&gt; nserver</strong></span>
<span class="strong"><strong>simple-http-server Now Serving: /Users/jos/git/Physijs at http://localhost:8000/</strong></span>
</pre></div><p>A disadvantage of this second approach, however, is that it doesn't automatically show directory listings, whereas the first approach does.</p></div><div class="section" title="Portable version Mongoose for Mac and/or Windows"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Portable version Mongoose for Mac and/or Windows</h3></div></div></div><p>If you haven't got Python or npm installed, there is a simple, portable web server, named Mongoose, that you<a id="id30" class="indexterm"/> can use. First, download the binaries for your specific platform from <a class="ulink" href="https://code.google.com/p/mongoose/downloads/list">https://code.google.com/p/mongoose/downloads/list</a>. If you are using Windows, copy it to<a id="id31" class="indexterm"/> the directory containing the examples and double-click on the executable to start a web browser serving the directory it is started in.</p><p>For other operating systems, you must also copy the executable to the target directory, but instead of double-clicking on the executable, you have to launch it from the command line. In both cases, a local web server will be started on port <code class="literal">8080</code>. The following screenshot encapsulates the discussion in this paragraph:</p><div class="mediaobject"><img src="graphics/2215OS_01_06.jpg" alt="Portable version Mongoose for Mac and/or Windows"/></div><p>By just clicking on a chapter, we can show and access all the examples for that specific chapter. If I discuss an example in this book, I'll refer to the specific name and folder so that you can directly<a id="id32" class="indexterm"/> test and play around with the code.</p></div><div class="section" title="Disabling security exceptions in Firefox and Chrome"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Disabling security exceptions in Firefox and Chrome</h3></div></div></div><p>If you use Chrome to run the<a id="id33" class="indexterm"/> examples, there is a way to disable some security settings so that you can use Chrome to view the examples <a id="id34" class="indexterm"/>without requiring a web server. To do this, you have to start Chrome in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For Windows, you call the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>chrome.exe --disable-web-security</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">On Linux, do the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>google-chrome --disable-web-security</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">And on Mac OS, you disable the settings by starting Chrome like this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>open -a Google\ Chrome --args --disable-web-security</strong></span>
</pre></div></li></ul></div><p>When you start Chrome this way, you can access all the examples directly from the local filesystem.</p><p>For Firefox users, we <a id="id35" class="indexterm"/>need to take a couple of different steps. Open Firefox and, in the URL bar, type <code class="literal">about:config</code>. This<a id="id36" class="indexterm"/> is what you'll see:</p><div class="mediaobject"><img src="graphics/2215OS_01_07.jpg" alt="Disabling security exceptions in Firefox and Chrome"/></div><p>On this screen, click on the <span class="strong"><strong>I'll be careful, I promise!</strong></span> button. This will show you all the available properties you can use to fine-tune Firefox. In the search box on this screen, type in <code class="literal">security.fileuri.strict_origin_policy</code> and change its value to <code class="literal">false</code> just as we did in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_01_08.jpg" alt="Disabling security exceptions in Firefox and Chrome"/></div><p>At this point, you can also use Firefox to directly run the examples provided in this book.</p><p>Now that you've either got<a id="id37" class="indexterm"/> a web server<a id="id38" class="indexterm"/> installed, or disabled the necessary security settings, it is time to start creating our first Three.js scene.</p></div></div></div>
<div class="section" title="Creating the HTML skeleton"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating the HTML skeleton</h1></div></div></div><p>The first thing we need to do is create an <a id="id39" class="indexterm"/>empty skeleton page that we can use as the base for all our examples, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;

&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Example 01.01 - Basic skeleton&lt;/title&gt;
    &lt;script src="../libs/three.js"&gt;&lt;/script&gt;
    &lt;style&gt;
      body{
        /* set margin to 0 and overflow to hidden, to use the complete page */

        margin: 0;
        overflow: hidden;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;!-- Div which will hold the Output --&gt;
    &lt;div id="WebGL-output"&gt;
    &lt;/div&gt;

    &lt;!-- Javascript code that runs our Three.js examples --&gt;
    &lt;script&gt;

      // once everything is loaded, we run our Three.js stuff.
      function init() {
        // here we'll put the Three.js stuff
      };
      window.onload = init;

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>As you can see from this listing, the skeleton is a very simple HTML page, with only a couple of elements. In the <code class="literal">&lt;head&gt;</code> element, we load the external JavaScript libraries that we'll use for the examples. For all the examples, we'll at least need to load the Three.js library, <code class="literal">three.js</code>. In the <code class="literal">&lt;head&gt;</code> element, we also add a couple of lines of CSS. These style elements remove any scrollbars when we create a full-page Three.js scene. In the <code class="literal">&lt;body&gt;</code> element of this page, you can see a single <code class="literal">&lt;div&gt;</code> element. When we write our Three.js code, we'll <a id="id40" class="indexterm"/>point the output of the Three.js renderer to that element. At the bottom of this page, you can already see a bit of JavaScript. By assigning the <code class="literal">init</code> function to the <code class="literal">window.onload</code> property, we make sure that this function gets called when the HTML document has finished loading. In the <code class="literal">init</code> function, we'll<a id="id41" class="indexterm"/> insert all the Three.js specific JavaScript.</p><p>Three.js comes in two versions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Three.min.js</strong></span>: This is the library you'd normally use when deploying Three.js sites on the<a id="id42" class="indexterm"/> Internet. This is a minified version of Three.js, created using <a id="id43" class="indexterm"/><span class="strong"><strong>UglifyJS</strong></span>, which is a quarter size of the normal<a id="id44" class="indexterm"/> Three.js library. All the examples and code used in this book are based on<a id="id45" class="indexterm"/> Three.js <span class="strong"><strong>r69</strong></span>, which was released in October 2014.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Three.js</strong></span>: This is the normal Three.js library. We use this library in our examples since it makes<a id="id46" class="indexterm"/> debugging much easier when <a id="id47" class="indexterm"/>you can read and understand the Three.js source code.</li></ul></div><p>If we view this page in our browser, the results aren't very shocking. As you'd expect, all you see is an empty page.</p><p>In the next section, you'll learn how to add the first couple of 3D objects and render those to the <code class="literal">&lt;div&gt;</code> element we<a id="id48" class="indexterm"/> defined in our HTML skeleton.</p></div>
<div class="section" title="Rendering and viewing a 3D object"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Rendering and viewing a 3D object</h1></div></div></div><p>In this step, you'll create your <a id="id49" class="indexterm"/>first scene and add a couple of objects and a camera. Our first example will<a id="id50" class="indexterm"/> contain the following objects:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Object</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Plane</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a two-dimensional rectangle that serves as our ground area. In the second screenshot of this chapter, this is rendered as the gray rectangle in the middle of the scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Cube</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a three-dimensional cube, which we'll render in red.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Sphere</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a three-dimensional sphere, which we'll render in blue.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Camera</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The camera determines what you'll see in the output.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Axes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These are the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes. This is a helpful debugging tool to see where the objects are rendered in 3D space. The <span class="emphasis"><em>x</em></span> axis is colored red, the <span class="emphasis"><em>y</em></span> axis is colored green, and the <span class="emphasis"><em>z</em></span> axis is colored blue.</p>
</td></tr></tbody></table></div><p>I'll first show you how this looks in code (the source with comments can be found in <code class="literal">chapter-01/02-first-scene.html</code>), and then I'll explain what's happening:</p><div class="informalexample"><pre class="programlisting">function init() {
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(45, window.innerWidth /window.innerHeight, 0.1, 1000);

  var renderer = new THREE.WebGLRenderer();
  renderer.setClearColorHex(0xEEEEEE);
  renderer.setSize(window.innerWidth, window.innerHeight);

  var axes = new THREE.AxisHelper(20);
  scene.add(axes);

  var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1);
  var planeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc});
  var plane = new THREE.Mesh(planeGeometry, planeMaterial);

  plane.rotation.x = -0.5 * Math.PI;
  plane.position.x = 15
  plane.position.y = 0
  plane.position.z = 0

  scene.add(plane);

  var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
  var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});
  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

  cube.position.x = -4;
  cube.position.y = 3;
  cube.position.z = 0;

  scene.add(cube);

  var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
  var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff, wireframe: true});
  var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

  sphere.position.x = 20;
  sphere.position.y = 4;
  sphere.position.z = 2;

  scene.add(sphere);

  camera.position.x = -30;
  camera.position.y = 40;
  camera.position.z = 30;
  camera.lookAt(scene.position);

  document.getElementById("WebGL-output")
    .appendChild(renderer.domElement);
    renderer.render(scene, camera);
};
window.onload = init;</pre></div><p>If we open this example<a id="id51" class="indexterm"/> in the browser, we see something that resembles what <a id="id52" class="indexterm"/>we're aiming at (see the screenshot at the beginning of this chapter), but it is still a long way off, as follows:</p><div class="mediaobject"><img src="graphics/2215OS_01_09.jpg" alt="Rendering and viewing a 3D object"/></div><p>Before we start making this more beautiful, I'll first walk you through the code a step at a time so that you<a id="id53" class="indexterm"/> understand what the code does:</p><div class="informalexample"><pre class="programlisting">var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
var renderer = new THREE.WebGLRenderer();
renderer.setClearColorHex()
renderer.setClearColor(new THREE.Color(0xEEEEEE));
renderer.setSize(window.innerWidth, window.innerHeight);</pre></div><p>At the top of the example, we define <code class="literal">scene</code>, <code class="literal">camera</code>, and <code class="literal">renderer</code>. The <code class="literal">scene</code> object is a container that is used to store and keep track of all the objects we want to render and all the lights we want to use. Without a <code class="literal">THREE.Scene</code> object, Three.js isn't able to render anything. More information on the <code class="literal">THREE.Scene</code> object can be found in the next chapter. The sphere and the cube<a id="id54" class="indexterm"/> we want to render will be added to scene later on in the example. In this first fragment, we also create a <code class="literal">camera</code> object. The <code class="literal">camera</code> object defines what we'll see when we render a scene. In <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <span class="emphasis"><em>Basic Components That Make Up a Three.js Scene</em></span>, you learn more about the arguments you can pass in to the <code class="literal">camera</code> object. Next we define <code class="literal">renderer</code>. The <code class="literal">renderer</code> object is responsible for calculating what the <code class="literal">scene </code>object will look like in the browser based on the <code class="literal">camera</code> object's angle. We create <code class="literal">WebGLRenderer</code> that uses your graphics card to render the scene in this example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>If you look through the source code and the documentation of Three.js (which you can find at <a class="ulink" href="http://threejs.org/">http://threejs.org/</a>), you'll <a id="id55" class="indexterm"/>notice that there are different renderers available besides the WebGL-based one. There is a canvas-based renderer and even an SVG-based one. Even though they work and can render simple scenes, I wouldn't recommend using them. They're very CPU-intensive and lack features such as good material support and shadows.</p></div></div><p>Here, we set the background color of <code class="literal">renderer</code> to almost white (<code class="literal">new THREE.Color(0XEEEEEE)</code>) with the <code class="literal">setClearColor</code> function and tell <code class="literal">renderer</code> how large the scene needs to be rendered using the <code class="literal">setSize</code> function.</p><p>So far, we've got a<a id="id56" class="indexterm"/> basic empty scene, a renderer, and a camera. There is, however, nothing yet<a id="id57" class="indexterm"/> to render. The following code adds the helper axes and the plane:</p><div class="informalexample"><pre class="programlisting">  var axes = new THREE.AxisHelper( 20 );
  scene.add(axes);

  var planeGeometry = new THREE.PlaneGeometry(60,20);
  var planeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc});
  var plane = new THREE.Mesh(planeGeometry,planeMaterial);

  plane.rotation.x=-0.5*Math.PI;
  plane.position.x=15
  plane.position.y=0
  plane.position.z=0
  scene.add(plane);</pre></div><p>As you can see, we create an <code class="literal">axes</code> object and use the<a id="id58" class="indexterm"/> <code class="literal">scene.add</code> function to add these axes to our scene. Next, we create the plane. This is done in two steps. First, we define what the plane looks like using the new <code class="literal">THREE.PlaneGeometry(60,20)</code> code. In this case, it has a width of <code class="literal">60</code> and a height of <code class="literal">20</code>. We also need to tell Three.js what this plane looks like (for example, its color and its transparency). In Three.js, we do this by creating a material object. For this first example, we'll create a basic material (<code class="literal">THREE.MeshBasicMaterial</code>) with the color <code class="literal">0xcccccc</code>. Next, we combine these two into a <code class="literal">Mesh</code> object with the name <code class="literal">plane</code>. Before we add <code class="literal">plane</code> to the scene, we need to put it in the correct position; we do this by first rotating it 90 degrees around the x axis, and next, we define its position in the scene using the position properties. If you're already interested in the details of this, look at the <code class="literal">06-mesh-properties.html</code> example from the code folder of <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <span class="emphasis"><em>Basic Components That Make Up a Three.js Scene</em></span>, which shows and explains rotation and positioning. We then need to do is add <code class="literal">plane</code> to <code class="literal">scene</code>, just like we did with <code class="literal">axes</code>.</p><p>The <code class="literal">cube</code> and <code class="literal">sphere</code> objects are added in the same manner, but with the <code class="literal">wireframe</code> property set to <code class="literal">true</code>, which<a id="id59" class="indexterm"/> tells Three.js to render a wireframe and not a solid object. Now, let's move<a id="id60" class="indexterm"/> on to the final part of this example:</p><div class="informalexample"><pre class="programlisting">  camera.position.x = -30;
  camera.position.y = 40;
  camera.position.z = 30;
  camera.lookAt(scene.position);

  document.getElementById("WebGL-output")
    .appendChild(renderer.domElement);
    renderer.render(scene, camera);</pre></div><p>At this point, all the elements we want to render are added to the scene at the correct positions. I've already mentioned that the camera defines what will be rendered. In this piece of code, we position the camera using the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> position attributes to hover above our scene. To make sure the camera is looking at our objects, we use<a id="id61" class="indexterm"/> the <code class="literal">lookAt</code> function to point it at the center of our scene, which is located at position (0, 0, 0) by default. All that is left to do is append the output from the renderer to the <code class="literal">&lt;div&gt;</code> element of our HTML skeleton. We use standard JavaScript to select the correct output element and append it to our <code class="literal">div</code> element with the <code class="literal">appendChild</code> function. Finally, we tell <code class="literal">renderer</code> to render <code class="literal">scene</code> using the <code class="literal">camera</code> object provided.</p><p>In the next couple of sections, we'll make this scene more pretty by adding lights, shadows, more materials, and even animations.</p></div>
<div class="section" title="Adding materials, lights, and shadows"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Adding materials, lights, and shadows</h1></div></div></div><p>Adding new materials and lights in Three.js is very simple and is done in pretty much the same way as we <a id="id62" class="indexterm"/>explained in<a id="id63" class="indexterm"/> the previous section. We start by adding a light source to<a id="id64" class="indexterm"/> the scene (for the complete source look at <code class="literal">03-materials-light.html</code>), as follows:</p><div class="informalexample"><pre class="programlisting">  var spotLight = new THREE.SpotLight( 0xffffff );
  spotLight.position.set( -40, 60, -10 );
  scene.add( spotLight );</pre></div><p>
<code class="literal">THREE.SpotLight</code> illuminates our scene from its position (<code class="literal">spotLight.position.set( -40, 60, -10 )</code>). If we render<a id="id65" class="indexterm"/> the scene this time, however, you won't see any difference from the previous one. The reason is that different materials respond differently to light. The basic material we used in the previous example (<code class="literal">THREE.MeshBasicMaterial</code>) doesn't do anything with the light sources in the scene. They just render the object in the specified color. So, we have to change the materials for <code class="literal">plane</code>, <code class="literal">sphere</code>, and <code class="literal">cube</code> to the following:</p><div class="informalexample"><pre class="programlisting">var planeGeometry = new THREE.PlaneGeometry(60,20);
var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
var plane = new THREE.Mesh(planeGeometry, planeMaterial);
...
var cubeGeometry = new THREE.BoxGeometry(4,4,4);
var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
...
var sphereGeometry = new THREE.SphereGeometry(4,20,20);
var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);</pre></div><p>In this piece of code, we <a id="id66" class="indexterm"/>changed the materials for our objects to <code class="literal">MeshLambertMaterial</code>. This<a id="id67" class="indexterm"/> material and <code class="literal">MeshPhongMaterial</code> are<a id="id68" class="indexterm"/> the materials Three.js provides that take light sources into account when rendered.</p><p>The result, shown in the following screenshot, however, still isn't what we're looking for:</p><div class="mediaobject"><img src="graphics/2215OS_01_10.jpg" alt="Adding materials, lights, and shadows"/></div><p>We're getting there, and cube and <a id="id69" class="indexterm"/>sphere are looking a lot better. What is still missing, though, are the shadows.</p><p>Rendering shadows takes a lot of computing power, and for that reason, shadows are disabled by default in <a id="id70" class="indexterm"/>Three.js. Enabling them, though, is very easy. For shadows, we<a id="id71" class="indexterm"/> have to change the source in a couple of places, as follows:</p><div class="informalexample"><pre class="programlisting">renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMapEnabled = true;</pre></div><p>The first change we need to make is tell <code class="literal">renderer</code> that we want shadows. You do this by setting the <code class="literal">shadowMapEnabled</code> property to <code class="literal">true</code>. If you look at the result from this change, you won't notice anything different yet. That is because we need to explicitly define which objects cast shadows and which objects receive shadows. In our example, we want the sphere and the cube to cast shadows on the ground plane. You do this by setting the corresponding properties on those objects:</p><div class="informalexample"><pre class="programlisting">plane.receiveShadow = true;
...
cube.castShadow = true;
...
sphere.castShadow = true;</pre></div><p>Now, there is just one more thing to do to get the shadows. We need to define which light sources in our scene will cause shadows. Not all the lights can cast shadows, and you'll learn more about that in the next chapter, but <code class="literal">THREE.SpotLight</code>, which we used in this example, can. We only need to set the correct property, as shown in the following line of code, and the shadows <a id="id72" class="indexterm"/>will finally be rendered:</p><div class="informalexample"><pre class="programlisting">spotLight.castShadow = true;</pre></div><p>And with this, we <a id="id73" class="indexterm"/>get a scene complete with shadows from our light source, as follows:</p><div class="mediaobject"><img src="graphics/2215OS_01_11.jpg" alt="Adding materials, lights, and shadows"/></div><p>The last feature that we'll <a id="id74" class="indexterm"/>add to this first scene is some simple animation. In <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <span class="emphasis"><em>Animations and Moving the Camera</em></span>, you'll learn more advanced animation options.</p></div>
<div class="section" title="Expanding your first scene with animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Expanding your first scene with animations</h1></div></div></div><p>If we want to animate the scene, the first thing that we need to do is find some way to re-render the scene at a specific<a id="id75" class="indexterm"/> interval. Before HTML5 and the related JavaScript APIs came along, the way to do this was using the <code class="literal">setInterval(function,interval)</code> function. With <code class="literal">setInterval</code>, we could specify a function that, for instance, would be called every 100 milliseconds. The problem with this function is that it doesn't take<a id="id76" class="indexterm"/> into account what is happening in the browser. If you were browsing another tab, this function would still be fired every couple of milliseconds. Besides that, <code class="literal">setInterval</code> isn't synchronized with the redrawing of the screen. This can lead to higher CPU usage and bad performance.</p><div class="section" title="Introducing requestAnimationFrame"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Introducing requestAnimationFrame</h2></div></div></div><p>Modern browsers luckily have<a id="id77" class="indexterm"/> a solution for that with the <code class="literal">requestAnimationFrame</code> function. With <code class="literal">requestAnimationFrame</code>, you can specify a function that is called at an interval defined by the browser. You do any drawing you need to do in the <a id="id78" class="indexterm"/>supplied function, and the browser will make sure it is painted as smoothly and efficiently as possible. Using this is really simple (the complete source can be found in the <code class="literal">04-materials-light-animation.html</code> file), you just create a function that handles the rendering:</p><div class="informalexample"><pre class="programlisting">function renderScene() {
  requestAnimationFrame(renderScene);
  renderer.render(scene, camera);
}</pre></div><p>In this <code class="literal">renderScene</code> function, we call <code class="literal">requestAnimationFrame</code> again, to keep the animation going. The only thing we need to change in the code is that instead of calling <code class="literal">renderer.render</code> after we've created the complete scene, we call the <code class="literal">renderScene</code> function once to kick off the animation:</p><div class="informalexample"><pre class="programlisting">...
document.getElementById("WebGL-output")
  .appendChild(renderer.domElement);
renderScene();</pre></div><p>If you run this, you won't see any changes yet compared to the previous example because we haven't animated anything yet. Before we add the animation, though, I want to introduce a small helper library that gives us information about the frame rate the animation is running at. This library, from the same author as Three.js, renders a small graph that shows us the frames per second we're getting for this animation.</p><p>To add these statistics, we first need to include the library in the <code class="literal">&lt;head&gt;</code> element of the HTML, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="../libs/stats.js"&gt;&lt;/script&gt;</pre></div><p>And we add a <code class="literal">&lt;div&gt;</code> element that will be used as output for the statistics graph, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div id="Stats-output"&gt;&lt;/div&gt;</pre></div><p>The only thing left to do is initialize the statistics and add them to this <code class="literal">&lt;div&gt;</code> element, as follows:</p><div class="informalexample"><pre class="programlisting">function initStats() {
  var stats = new Stats();
  stats.setMode(0);
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.left = '0px';
  stats.domElement.style.top = '0px';
  document.getElementById("Stats-output")
    .appendChild( stats.domElement );
     return stats;
}</pre></div><p>This function initializes the<a id="id79" class="indexterm"/> statistics. The interesting part is the <code class="literal">setMode</code> function. If we set it to <code class="literal">0</code>, we'll <a id="id80" class="indexterm"/>measure frames per second (fps), and if we set this to <code class="literal">1</code>, we can measure rendering time. For this example, we're interested in fps, so <code class="literal">0</code> it is. At the beginning of our <code class="literal">init()</code> function, we'll call this function, and we've got <code class="literal">stats</code> enabled, as follows:</p><div class="informalexample"><pre class="programlisting">function init(){

  var stats = initStats();
  ...
}</pre></div><p>The only thing left to do is tell the <code class="literal">stats</code> object when we're in a new rendering cycle. We do this by adding a call to the <code class="literal">stats.update</code> function in our <code class="literal">renderScene</code> function, as follows.</p><div class="informalexample"><pre class="programlisting">function renderScene() {
  stats.update();
  ...
  requestAnimationFrame(renderScene);
  renderer.render(scene, camera);
}</pre></div><p>If you run the code with these additions, you'll see the statistics in the upper-left corner, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_01_12.jpg" alt="Introducing requestAnimationFrame"/></div></div><div class="section" title="Animating the cube"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Animating the cube</h2></div></div></div><p>With <code class="literal">requestAnimationFrame</code> and the statistics configured, we've got a place to put our animation code. In this <a id="id81" class="indexterm"/>section, we'll expand the <code class="literal">renderScene</code> function <a id="id82" class="indexterm"/>with code that will rotate our red cube around all of its axes. Let's start by showing you the code:</p><div class="informalexample"><pre class="programlisting">function renderScene() {
  ...
  cube.rotation.x += 0.02;
  cube.rotation.y += 0.02;
  cube.rotation.z += 0.02;
  ...
  requestAnimationFrame(renderScene);
  renderer.render(scene, camera);
}</pre></div><p>That looks simple, right? What we do is that we increase the <code class="literal">rotation</code> property of each of the axes with 0.02 every time the <code class="literal">renderScene</code> function is called, which shows up as a cube smoothly rotating around all if its axes. Bouncing the blue ball isn't much harder.</p></div><div class="section" title="Bouncing the ball"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Bouncing the ball</h2></div></div></div><p>To bounce the ball, we once<a id="id83" class="indexterm"/> again add a couple of lines of code to our <code class="literal">renderScene</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">  var step=0;
  function renderScene() {
    ...
    step+=0.04;
    sphere.position.x = 20+( 10*(Math.cos(step)));
    sphere.position.y = 2 +( 10*Math.abs(Math.sin(step)));
    ...
    requestAnimationFrame(renderScene);
    renderer.render(scene, camera);
  }</pre></div><p>With the cube, we changed the <code class="literal">rotation</code> property; for the sphere, we're going to change its <code class="literal">position</code> property in the scene. We want the sphere to bounce from one point in the scene to another with a nice, smooth curve. This is shown in the following figure:</p><div class="mediaobject"><img src="graphics/2215OS_01_13.jpg" alt="Bouncing the ball"/></div><p>For this, we need to<a id="id84" class="indexterm"/> change its position on the <span class="emphasis"><em>x</em></span> axis and its position on the <span class="emphasis"><em>y</em></span> axis. The <code class="literal">Math.cos</code> and <code class="literal">Math.sin</code> functions help us in creating a smooth trajectory using the step variable. I won't go into the details of how this works here. For now, all you need to know is that <code class="literal">step+=0.04</code> defines the speed of the bouncing sphere. In <a class="link" href="ch08.html" title="Chapter 8. Creating and Loading Advanced Meshes and Geometries">Chapter 8</a>, <span class="emphasis"><em>Creating and Loading Advanced Meshes and Geometries</em></span>, we'll look in much more detail how these functions can be used for animation, and I'll explain everything. Here's how the ball looks in the middle of a bounce:</p><div class="mediaobject"><img src="graphics/2215OS_01_14.jpg" alt="Bouncing the ball"/></div><p>Before wrapping up this chapter, I want to add one more element to our basic scene. When working with 3D scenes, animations, colors, and properties like that, it often requires a bit of experimenting to get the correct color or speed. It would be very easy if you could just have<a id="id85" class="indexterm"/> a simple GUI that allows you to change these kinds of properties on the fly. Luckily, there is!</p></div></div>
<div class="section" title="Using dat.GUI to make experimenting easier"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Using dat.GUI to make experimenting easier</h1></div></div></div><p>A couple of employees from Google created a<a id="id86" class="indexterm"/> library called <span class="strong"><strong>dat.GUI</strong></span> (you can find the documentation online at <a class="ulink" href="http://code.google.com/p/dat-gui/">http://code.google.com/p/dat-gui/</a>), which allows you to very easily create a simple user interface component that can change variables in your code. In this last part<a id="id87" class="indexterm"/> of this chapter, we'll use dat.GUI to add a user interface to our example that allows us to change the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Control the speed of the bouncing ball</li><li class="listitem" style="list-style-type: disc">Control the rotation of the cube</li></ul></div><p>Just like we had to do for the statistics, we first add this library to the <code class="literal">&lt;head&gt;</code> element of our HTML page, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="../libs/dat.gui.js"&gt;&lt;/script&gt;</pre></div><p>The next thing we need to configure is a JavaScript object that will hold the properties we want to change using dat.GUI. In the main part of our JavaScript code, we add the following JavaScript object, as follows:</p><div class="informalexample"><pre class="programlisting">var controls = new function() {
  this.rotationSpeed = 0.02;
  this.bouncingSpeed = 0.03;
}</pre></div><p>In this JavaScript object, we define two properties—<code class="literal">this.rotationSpeed</code> and <code class="literal">this.bouncingSpeed</code>—and their default values. Next, we pass this object into a new dat.GUI object and define the range for these two properties, as follows:</p><div class="informalexample"><pre class="programlisting">var gui = new dat.GUI();
gui.add(controls, 'rotationSpeed', 0, 0.5);
gui.add(controls, 'bouncingSpeed', 0, 0.5);</pre></div><p>The <code class="literal">rotationSpeed</code> and <code class="literal">bouncingSpeed</code> properties are both set to a range of <code class="literal">0</code> to <code class="literal">0.5</code>. All we need to do <a id="id88" class="indexterm"/>now is make sure that in our <code class="literal">renderScene</code> loop, we reference these two properties directly so that when we make changes through the dat.GUI user interface, it immediately affects the rotation and bounce speed of our objects, as follows:</p><div class="informalexample"><pre class="programlisting">function renderScene() {
  ...
  cube.rotation.x += controls.rotationSpeed;
  cube.rotation.y += controls.rotationSpeed;
  cube.rotation.z += controls.rotationSpeed;
  step += controls.bouncingSpeed;
  sphere.position.x = 20 +(10 * (Math.cos(step)));
  sphere.position.y = 2 +(10 * Math.abs(Math.sin(step)));
  ...
}</pre></div><p>Now, when you run this example (<code class="literal">05-control-gui.html</code>), you'll see a simple user interface that you can use to control the bouncing and rotation speeds. A screenshot of the bouncing ball and the rotating cube is shown here:</p><div class="mediaobject"><img src="graphics/2215OS_01_15.jpg" alt="Using dat.GUI to make experimenting easier"/></div><p>If you've looked at the examples in your browser, you might have noticed that when you change the size of your<a id="id89" class="indexterm"/> browser, the scene doesn't automatically scale. In the next section, we'll add this as a final feature for this chapter.</p></div>
<div class="section" title="Automatically resize the output when browser size changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Automatically resize the output when browser size changes</h1></div></div></div><p>Changing the camera when the browser is resized can be done pretty simply. The first thing we need to do is<a id="id90" class="indexterm"/> register an event listener like this:</p><div class="informalexample"><pre class="programlisting">window.addEventListener('resize', onResize, false);</pre></div><p>Now, whenever the browser window is resized, the <code class="literal">onResize</code> function, which we'll specify next, is called. In this <code class="literal">onResize</code> function, we need to update the camera and renderer, as follows:</p><div class="informalexample"><pre class="programlisting">function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}</pre></div><p>For the camera, we need to update the <code class="literal">aspect</code> property, which holds the aspect ratio of the screen, and for the <code class="literal">renderer</code>, we need to change its size. The final step is to move the variable <a id="id91" class="indexterm"/>definitions for <code class="literal">camera</code>, <code class="literal">renderer</code>, and <code class="literal">scene</code> outside of the <code class="literal">init()</code> function so that we can access them from different functions (like the <code class="literal">onResize</code> function), as follows:</p><div class="informalexample"><pre class="programlisting">var camera;
var scene;
var renderer;

function init() {
  ...
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer();
  ...
}</pre></div><p>To see this effect in action, open the <code class="literal">06-screen-size-change.html</code> example and resize your browser window.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>That's it for the first chapter. In this chapter, we showed you how to set up your development environment, how to get the code, and how to get started with the examples provided with this book. You further learned that to render a scene with Three.js, you first have to create a <code class="literal">THREE.Scene</code> object, add a camera, a light, and the objects that you want to render. We also showed you how you can expand this basic scene by adding shadows and animations. Lastly, we added a couple of helper libraries. We used dat.GUI, which allows you to quickly create control user interfaces, and we added <code class="literal">stats.js</code>, which provided feedback on the frame rate at which your scene is rendered.</p><p>In the next chapter, we'll expand on the example we created here. You'll learn more about the most important building blocks that you can use in Three.js.</p></div></body></html>