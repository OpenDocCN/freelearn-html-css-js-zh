<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Classes and Modules</h1></div></div></div><p>In this chapter, we will explore some of the most interesting features introduced in ES6. JavaScript is a prototype-based language and supports prototypical inheritance. In the previous chapter, we discussed the prototype property of an object and how prototypical inheritance works in JavaScript. ES6 brings in classes. If you are coming from traditional object-oriented languages such as Java, you will immediately relate to the well-known concepts of classes. However, they are not the same in JavaScript. Classes in JavaScript are a syntactic sugar over the prototypical inheritance we discussed in the last chapter.</p><p>In this chapter, we will take a detailed look at ES6 classes and modules - these are welcome changes to this edition of JavaScript and make <strong>Object Oriented Programming</strong> (<strong>OOP</strong>) and inheritance significantly easier.</p><p>If you are coming from a traditional object-oriented language, prototypical inheritance may feel a bit out of place for you. ES6 classes offer a more traditional syntax for you to get familiarized with prototypical inheritance in JavaScript.</p><p>Before we try and delve deeper into classes, let me show you why you should use the ES6 classes syntax over the prototypical inheritance syntax of ES5.</p><p>In this snippet, I am creating a class hierarchy of <code class="literal">Person</code>, <code class="literal">Employee</code>, and <code class="literal">Engineer</code>, pretty straightforward. First, we will see the ES5 prototypical inheritance, which is written as follows:</p><pre class="programlisting">    var Person = function(firstname) { &#13;
        if (!(this instanceof Person)) { &#13;
            throw new Error("Person is a constructor"); &#13;
        } &#13;
        this.firstname = firstname; &#13;
    }; &#13;
 &#13;
    Person.prototype.giveBirth = function() { &#13;
        // ...we give birth to the person &#13;
    }; &#13;
 &#13;
    var Employee = function(firstname, lastname, job) { &#13;
        if (!(this instanceof Employee)) { &#13;
            throw new Error("Employee is a constructor"); &#13;
        } &#13;
        Person.call(this, firstname); &#13;
        this.job = job; &#13;
    };  &#13;
    Employee.prototype = Object.create(Person.prototype); &#13;
    Employee.prototype.constructor = Employee; &#13;
    Employee.prototype.startJob = function() { &#13;
        // ...Employee starts job &#13;
    }; &#13;
 &#13;
    var Engineer = function(firstname, lastname, job, department) { &#13;
        if (!(this instanceof Engineer)) { &#13;
            throw new Error("Engineer is a constructor"); &#13;
        } &#13;
        Employee.call(this, firstname, lastname, job); &#13;
        this.department = department; &#13;
    }; &#13;
    Engineer.prototype = Object.create(Employee.prototype); &#13;
    Engineer.prototype.constructor = Engineer; &#13;
    Engineer.prototype.startWorking = function() { &#13;
        // ...Engineer starts working &#13;
    }; &#13;
</pre><p>Now let's look at the equivalent code using the ES6 classes syntax:</p><pre class="programlisting">    class Person { &#13;
        constructor(firstname) { &#13;
            this.firsnamet = firstname; &#13;
        } &#13;
        giveBirth() { &#13;
            // ... a person is born &#13;
        } &#13;
    } &#13;
 &#13;
    class Employee extends Person { &#13;
        constructor(firstname, lastname, job) { &#13;
            super(firstname); &#13;
            this.lastname = lastname; &#13;
            this.position = position; &#13;
        } &#13;
 &#13;
         startJob() { &#13;
            // ...Employee starts job &#13;
        } &#13;
    } &#13;
 &#13;
    class Engineer extends Employee { &#13;
        constructor(firstname, lastname, job, department) { &#13;
            super(firstname, lastname, job); &#13;
            this.department = department; &#13;
        } &#13;
 &#13;
        startWorking() { &#13;
            // ...Engineer starts working &#13;
        } &#13;
    } &#13;
</pre><p>If you observe the two preceding code snippets, it will be obvious to you that the second example is pretty neat. If you already know Java or C#, you will feel right at home. However, one important thing to remember is that classes do not introduce any new object-oriented inheritance model to the language, but bring in a much nicer way to create objects and handle inheritance.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Defining classes</h1></div></div></div><p>Under the hood, classes are special functions. Just like you can define functions using function expressions and declarations, you can define classes as well. One way to define classes is using class declaration.</p><p>You can use the <code class="literal">class</code> keyword and the name of the class. This syntax is very similar to that of Java or C#:</p><pre class="programlisting">    class Car { &#13;
      constructor(model, year){ &#13;
        this.model = model; &#13;
        this.year = year; &#13;
      } &#13;
    } &#13;
    console.log(typeof Car); //"function" &#13;
</pre><p>To establish the fact that classes are a special function, if we get the <code class="literal">typeof</code> the <code class="literal">Car</code> class, we will get a function.</p><p>There is an important distinction between classes and normal functions. While normal functions are hoisted, classes are not. A normal function is available immediately when you enter a scope in which it is declared; this is called <strong>hoisting</strong>, which means that a normal function can be declared anywhere in the scope, and it will be available. However, classes are not hoisted; they are available only after they are declared. For a normal function, you can say:</p><pre class="programlisting">    normalFunction();   //use first &#13;
    function normalFunction() {}  //declare later &#13;
</pre><p>However, you cannot use the class before declaring it, for example:</p><pre class="programlisting">    var ford = new Car(); //Reference Error &#13;
    class Car {} &#13;
</pre><p>The other way to define a class is to use a class expression. A class expression, like a function expression, may or may not have a name.</p><p>The following example shows an anonymous class expression:</p><pre class="programlisting">    const Car = class { &#13;
      constructor(model, year){ &#13;
        this.model = model; &#13;
        this.year = year; &#13;
      } &#13;
    } &#13;
</pre><p>If you name the class expression, the name is local to the class's body and not available outside:</p><pre class="programlisting">    const NamedCar = class Car{ &#13;
      constructor(model, year){ &#13;
        this.model = model; &#13;
        this.year = year; &#13;
      } &#13;
      getName() { &#13;
          return Car.name; &#13;
      } &#13;
    } &#13;
    const ford = new NamedCar(); &#13;
    console.log(ford.getName()); // Car &#13;
    console.log(ford.name); // ReferenceError: name is not defined &#13;
</pre><p>As you can see, here, we will give a name to the <code class="literal">Car</code> class. This name is available within the body of the class, but when we try to access it outside the class, we get a reference error.</p><p>You cannot use commas while separating members of a class. Semicolons are valid though. This is funny as ES6 ignores semicolons and there is a raging debate about using semicolons in ES6. Consider the following code snippet as an example:</p><pre class="programlisting">    class NoCommas { &#13;
      method1(){} &#13;
      member1;  //This is ignored and can be used to &#13;
        separate class members &#13;
      member2,  //This is an error &#13;
      method2(){} &#13;
    } &#13;
</pre><p>Once defined, we can use classes via a <code class="literal">new</code> keyword and not a function call; here's the example:</p><pre class="programlisting">    class Car { &#13;
      constructor(model, year){ &#13;
        this.model = model; &#13;
        this.year = year; &#13;
      } &#13;
    } &#13;
    const fiesta = new Car('Fiesta','2010'); &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch08lvl2sec97"/>Constructor</h2></div></div></div><p>We have used the <code class="literal">constructor</code> function in the examples so far. A constructor is a special method used to create and initialize an object created with the class. You can have only one constructor in a class. Constructors are a bit different from the normal constructor functions. Unlike normal constructors, a class constructor can call its parent class constructor via <code class="literal">super()</code>. We will discuss this in detail when we look at inheritance.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec98"/>Prototype methods</h2></div></div></div><p>Prototype methods are prototype properties of the class, and they are inherited by instances of the class.</p><p>Prototype methods can also have <code class="literal">getter</code> and <code class="literal">setter</code> methods. The syntax of getters and setters is the same as ES5:</p><pre class="programlisting">    class Car { &#13;
      constructor(model, year){ &#13;
        this.model = model; &#13;
        this.year = year; &#13;
      } &#13;
      get model(){ &#13;
        return this.model &#13;
      } &#13;
   &#13;
      calculateCurrentValue(){ &#13;
        return "7000" &#13;
      } &#13;
    } &#13;
    const fiesta = new Car('Fiesta','2010') &#13;
    console.log(fiesta.model) &#13;
</pre><p>Similarly, computed properties are also supported. You can define the name of the method using the expression. The expression needs to be put inside square brackets. We discussed this shorthand syntax in earlier chapters. The following are all equivalent:</p><pre class="programlisting">    class CarOne { &#13;
        driveCar() {} &#13;
    } &#13;
    class CarTwo { &#13;
        ['drive'+'Car']() {} &#13;
    } &#13;
    const methodName = 'driveCar'; &#13;
    class CarThree { &#13;
        [methodName]() {} &#13;
    } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Static methods</h2></div></div></div><p>Static methods are associated with the class and not with an instance of that class (object). In other words, you can only reach a static method using the name of the class. Static methods are invoked without instantiating the class and they cannot be called on an instance of a class. Static methods are popular in creating utility or helper methods. Consider the following piece of code:</p><pre class="programlisting">    class Logger { &#13;
      static log(level, message) { &#13;
        console.log(`${level} : ${message}`) &#13;
      } &#13;
    } &#13;
    //Invoke static methods on the Class &#13;
    Logger.log("ERROR","The end is near") //"ERROR : The end is near" &#13;
 &#13;
    //Not on instance &#13;
    const logger = new Logger("ERROR") &#13;
    logger.log("The end is near")     //logger.log is not a function &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Static properties</h2></div></div></div><p>You may ask-well, we have static methods, what about static properties? In the hurry of getting ES6 ready, they did not add static properties. They will be added in future iterations of the language.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Generator methods</h2></div></div></div><p>We discussed hugely useful generator functions a few chapters back. You can add generator functions as part of class, and they are called generator methods. A generator method is useful because you can define their key as <code class="literal">Symbol.iterator</code>. The following example shows how generator methods can be defined inside a class:</p><pre class="programlisting">    class iterableArg { &#13;
        constructor(...args) { &#13;
            this.args = args; &#13;
        } &#13;
        * [Symbol.iterator]() { &#13;
            for (const arg of this.args) { &#13;
                yield arg; &#13;
            } &#13;
        } &#13;
    } &#13;
 &#13;
    for (const x of new iterableArg('ES6', 'wins')) { &#13;
        console.log(x); &#13;
    } &#13;
 &#13;
    //ES6 &#13;
    //wins &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Subclassing</h1></div></div></div><p>So far, we discussed how to declare classes and the types of members classes can support. A major use of a class is to serve as a template to create other subclasses. When you create a child class from a class, you derive properties of the parent class and extend the parent class by adding more features of its own.</p><p>Let's look at the following de facto example of inheritance:</p><pre class="programlisting">    class Animal {  &#13;
      constructor(name) { &#13;
        this.name = name; &#13;
      } &#13;
        speak() { &#13;
        console.log(this.name + ' generic noise'); &#13;
      } &#13;
    } &#13;
    class Cat extends Animal { &#13;
      speak() { &#13;
        console.log(this.name + ' says Meow.'); &#13;
      } &#13;
    } &#13;
    var c = new Cat('Grace');  &#13;
    c.speak();//"Grace says Meow." &#13;
</pre><p>Here, <code class="literal">Animal</code> is the base class and the <code class="literal">Cat</code> class is derived from the class <code class="literal">Animal</code>. The extend clause allows you to create a subclass of an existing class. This example demonstrates the syntax of subclassing. Let's enhance this example a bit more by writing the following code:</p><pre class="programlisting">    class Animal {  &#13;
      constructor(name) { &#13;
        this.name = name; &#13;
      } &#13;
      speak() { &#13;
        console.log(this.name + ' generic noise'); &#13;
      } &#13;
    } &#13;
    class Cat extends Animal { &#13;
      speak() { &#13;
        console.log(this.name + ' says Meow.'); &#13;
      } &#13;
   } &#13;
    class Lion extends Cat { &#13;
      speak() { &#13;
        super.speak(); &#13;
        console.log(this.name + ' Roars....'); &#13;
      } &#13;
    } &#13;
    var l = new Lion('Lenny');  &#13;
    l.speak(); &#13;
    //"Lenny says Meow." &#13;
    //"Lenny Roar...." &#13;
</pre><p>Here, we are using the <code class="literal">super</code> keyword to call functions from the parent class. The following are the three ways in which the <code class="literal">super</code> keyword can be used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can use <code class="literal">super (&lt;params&gt;)</code> as a function call to invoke the constructor of the parent class</li><li class="listitem" style="list-style-type: disc">You can use <code class="literal">super.&lt;parentClassMethod&gt;</code> to access the parent class methods</li><li class="listitem" style="list-style-type: disc">You can use <code class="literal">super.&lt;parentClassProp&gt;</code> to access the parent class properties</li></ul></div><p>In the derive class constructor, you must call the <code class="literal">super()</code> method before you can use,  <code class="literal">this</code> keyword; for example, the following piece of code will fail:</p><pre class="programlisting">    class Base {} &#13;
    class Derive extends Base { &#13;
      constructor(name){ &#13;
        this.name = name; //'this' is not allowed before super() &#13;
      } &#13;
    } &#13;
</pre><p>You can't implicitly leave a derived constructor with a <code class="literal">super()</code> method as an error:</p><pre class="programlisting">    class Base {} &#13;
    class Derive extends Base { &#13;
      constructor(){  //missing super() call in constructor &#13;
      } &#13;
    } &#13;
</pre><p>If you don't provide a constructor for the base class, the following constructor is used:</p><pre class="programlisting">    constructor() {} &#13;
</pre><p>For the derived classes, the default constructor is as follows:</p><pre class="programlisting">    constructor(...args){ &#13;
      super(...args); &#13;
    } &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Mixins</h2></div></div></div><p>JavaScript supports only single inheritance. At most, a class can have one superclass. This is limiting when you want to create class hierarchies but also want to inherit tool methods from different sources.</p><p>Let's say we have a scenario where we have a <code class="literal">Person</code> class, and we create a subclass, <code class="literal">Employee</code>:</p><pre class="programlisting">    class Person {} &#13;
    class Employee extends Person{} &#13;
</pre><p>We also want to inherit functions from two utility classes, <code class="literal">BackgroundCheck</code>-this class does employee background checks-and <code class="literal">Onboard</code>-this class handles employee onboarding processes, such as printing badges and so on:</p><pre class="programlisting">    class BackgroundCheck { &#13;
      check() {} &#13;
    } &#13;
    class Onboard { &#13;
      printBadge() { } &#13;
    } &#13;
</pre><p>Both <code class="literal">BackgroundCheck</code> and <code class="literal">Onboard</code> classes are templates, and their functionality will be used multiple times. Such templates (abstract subclasses) are called mixins.</p><p>As multiple inheritance is not possible in JavaScript, we will employ a different technique to achieve this. A popular way of implementing mixins in ES6 is to write a function with a superclass as an input and a subclass extending that superclass as the output, for example:</p><pre class="programlisting">    class Person {} &#13;
    const BackgroundCheck = Tools =&gt; class extends Tools { &#13;
      check() {} &#13;
    }; &#13;
    const Onboard = Tools =&gt; class extends Tools { &#13;
      printBadge() {} &#13;
    }; &#13;
    class Employee extends BackgroundCheck(Onboard(Person)){  &#13;
    } &#13;
</pre><p>This essentially means that <code class="literal">Employee</code> is a subclass of <code class="literal">BackgroundCheck</code>, which in turn is a subclass of <code class="literal">Onboard</code>, which in turn is a subclass of <code class="literal">Person</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Modules</h1></div></div></div><p>JavaScript modules are not new. In fact, there were have been libraries that support modules for some time now. ES6, however, offers built-in modules. Traditionally, JavaScript's major use was on browsers, where most of the JavaScript code was either embedded or small enough to manage without much trouble. Things have changed. JavaScript projects are now on a massive scale. Without an efficient system of spreading the code into files and directories, managing code becomes a nightmare.</p><p>ES6 modules are files. One module per file and one file per module. There is no module keyword. Whatever code you write in the module file is local to the module unless you export it. You may have a bunch of functions in a module, and you want to export only a few of them. You can export module functionality in a couple of ways.</p><p>The first way is to use the <code class="literal">export</code> keyword. You can export any top-level <code class="literal">function</code>, <code class="literal">class</code>, <code class="literal">var</code>, <code class="literal">let</code>, or <code class="literal">const</code>.</p><p>The following example shows a module inside <code class="literal">server.js</code> where we export a <code class="literal">function</code>, a <code class="literal">class</code>, and a <code class="literal">const</code>. We don't export the <code class="literal">processConfig()</code> function, and any file importing this module won't be able to access the unexported function:</p><pre class="programlisting">    //----------------server.js--------------------- &#13;
    export const port = 8080; &#13;
    export function startServer() { &#13;
      //...start server &#13;
    } &#13;
    export class Config { &#13;
      //... &#13;
    } &#13;
    function processConfig() { &#13;
      //... &#13;
    } &#13;
</pre><p>Any code that has access to <code class="literal">server.js</code> can import the exported functionality:</p><pre class="programlisting">    //--------------app.js---------------------------- &#13;
    import {Config, startServer} from 'server' &#13;
    startServer(port); &#13;
</pre><p>In this case, another JavaScript file is importing <code class="literal">Config</code> and <code class="literal">startServer</code> from the <code class="literal">server</code> module (with the corresponding JavaScript file <code class="literal">server.js</code>, we drop the file extension).</p><p>You can also import everything that was exported from the module:</p><pre class="programlisting">    import * from 'server' &#13;
</pre><p>If you have only one thing to export, you can use the default export syntax. Consider the following piece of code as an example:</p><pre class="programlisting">    //----------------server.js--------------------- &#13;
    export default class { &#13;
      //... &#13;
    } &#13;
    //--------------app.js---------------------------- &#13;
    import Server from 'server'; &#13;
    const s = new Server(); &#13;
</pre><p>In this example, we will keep the class anonymous as we can use the module name itself as the reference outside.</p><p>Before ES6 modules, external libraries supported several approaches to modules. They established fairly good guidelines/styles for ES6 to follow. The following style is followed by ES6:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modules are singletons. A module is imported only once, even if you try to import it several times in your code.</li><li class="listitem" style="list-style-type: disc">Variable, functions, and other type of declarations are local to the module. Only declarations marked with <code class="literal">export</code> are available outside the module for <code class="literal">import</code>.</li><li class="listitem" style="list-style-type: disc">Modules can import from other modules. The following are the three options for referring to other modules:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can use relative paths <code class="literal">("../lib/server");</code> these paths are resolved relatively to the file importing the module. For example, if you are importing the module from <code class="literal">&lt;project_path&gt;/src/app.js</code>, and the module file is located at <code class="literal">&lt;project_path&gt;/lib/server.js</code>, you will need to provide a path relative to the <code class="literal">app.js</code> - <code class="literal">../lib/server</code> in this case.</li><li class="listitem" style="list-style-type: disc">Absolute paths can also point to the module file directly.</li><li class="listitem" style="list-style-type: disc">You can drop the file <code class="literal">.js</code> extension while importing the module.</li></ul></div><p>
</p></li></ul></div><p>Before we go into more details of the ES6 module system, we need to understand how ES5 supported them via external libraries. ES5 has two non-compatible module systems, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>CommonJS</strong>: This is the dominant standard as Node.js adopted it</li><li class="listitem" style="list-style-type: disc"><strong>AMD </strong>(<strong>Asynchronous Module Definition</strong>): This is slightly more complicated than CommonJS and designed for asynchronous module loading, and targeted toward browsers</li></ul></div><p>ES6 modules were aimed to be easy to use for engineers coming from any of these systems.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Export lists</h2></div></div></div><p>Instead of tagging each exported function or class from your module with the <code class="literal">export</code> keyword, you can write a single list of all the things you want to export from the module, which are as follows:</p><pre class="programlisting">    export {port, startServer, Config}; &#13;
    const port = 8080; &#13;
    function startServer() { &#13;
      //...start server &#13;
    } &#13;
    class Config { &#13;
      //... &#13;
    } &#13;
    function processConfig() { &#13;
      //... &#13;
    } &#13;
</pre><p>The first line of the module is the list of exports. You can have multiple <code class="literal">export</code> lists in the module file and the list can appear anywhere in the file. You can also have a mix of <code class="literal">export</code> list and <code class="literal">export</code> declarations in the same module file, but you can <code class="literal">export</code> one name only once.</p><p>In a large project, there are cases when you encounter name conflicts. Suppose you import two modules, and both of them export a function with the same name. In such cases, you can rename the imports as follows:</p><pre class="programlisting">    import {trunc as StringLib} from "../lib/string.js" &#13;
    import {trunc as MathLib} from "../lib/math.js" &#13;
</pre><p>Here, both the imported modules exported a name, <code class="literal">trunc</code>, and hence created a conflict of names. We can alias them to resolve this conflict.</p><p>You can do the renaming while exporting as well, which is as follows:</p><pre class="programlisting">    function v() {} &#13;
    function v2() {} &#13;
    export { &#13;
      v as functionV(), &#13;
      v2 as functionV2(), &#13;
      v2 as functionLatest() &#13;
    } &#13;
</pre><p>If you are already using ES5 module systems, ES6 modules may look redundant. However, it was very important for the language to have support for such an important feature. ES6 module syntax is also standardized and more compact than the other alternatives.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Summary</h1></div></div></div><p>In this chapter, we focused on understanding ES6 classes. ES6 classes give formal support to the common JavaScript pattern of simulating class-like inheritance hierarchies using functions and prototypes. They are syntactic sugaring over prototype-based OO, offering a convenient declarative form for class patterns which encourage interoperability. ES6 classes offer a much nicer, cleaner, and clearer syntax for creating these objects and dealing with inheritance. ES6 classes provide support for constructors, instance and static methods, (prototype-based) inheritance, and super calls.</p><p>So far, JavaScript lacked one of the most basic features - modules. Before ES6, we wrote modules using either CommonJS or AMD. ES6 brings modules into JavaScript officially. In this chapter, we took a detailed look at how modules are used in ES6.</p><p>The next chapter focuses on another interesting addition to ES6 - proxies and promises.</p></div></body></html>