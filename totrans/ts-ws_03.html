<html><head></head><body>
		<div>
			<div id="_idContainer036" class="Content">
			</div>
		</div>
		<div id="_idContainer037" class="Content">
			<h1 id="_idParaDest-46">2. <a id="_idTextAnchor057"/>Declaration Files</h1>
		</div>
		<div id="_idContainer056" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter gets you started with declaration files in TypeScript. You will learn how to work with declaration files, including how to build your own declaration files from scratch, and then work with types in external libraries. By the end of this chapter, you will be able to create declaration files from scratch, implement common development patterns for creating declaration files, and produce type checking when working with third-party NPM code libraries.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor058"/>Introduction</h1>
			<p>In this chapter, you will learn about TypeScript declaration files. Declaration files give you the ability to give TypeScript more information about how a function or class is structured.</p>
			<p>Why is it important to understand how declaration files work? Technically, declaration files speak directly to the core motivations for why TypeScript is becoming so popular. One of the common rationales for using TypeScript is because it guides developers through the application process. Let's walk through a real-world example as a case study.</p>
			<p>In pure JavaScript, if we start working with a code library that we've never used before that formats dates, such as <strong class="bold">Moment JS</strong>, we would have to start by looking through the documentation in order to know what type of data we can pass to the Moment JS functions. When working with a new library, it is tedious work to figure out requirements, such as how many function arguments are required for each function and what data type each argument needs to be.</p>
			<p>With the declaration files, however, TypeScript informs the text editor of the requirements for every function that a library has. So, instead of having to rely solely on documentation and Google searches, the text editor itself informs the developer how to work with each function. For example, the text editor, with the help of TypeScript, would inform us that the Moment JS format function takes in zero to one arguments, and the optional argument needs to be a string. And declaration files make all of this possible.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor059"/>Declaration Files </h1>
			<p>Anytime we're asked to write additional boilerplate code, our first question is: why is it important to do this? With that in mind, before we walk through creating and managing declaration files, let's first analyze the role of declaration files in the development process.</p>
			<p>The entire reason why we use TypeScript in the first place is to give our applications a specified structure based on types. Declaration files extend this functionality by allowing us to define the shape of our programs.</p>
			<p>In this section, we will walk through two ways to work with declaration files. The first approach will be to create  our own declaration files from scratch. This is a great place to start since it provides insight into how the declaration process works. In the second part, we will see how we can integrate types into third-party NPM libraries. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Declaration files are not a new concept in the programming world. The same principle has been used for decades in older programming languages such as Java, C, and C++.</p>
			<p>Before we get into this chapter's example project, let's look at the core elements that comprise a declaration file in TypeScript. Consider the following code, which assigns a string value to a variable:</p>
			<p class="source-code">firstName = "Kristine";</p>
			<p>The preceding code in TypeScript will generate a compiler warning that says <strong class="source-inline">Cannot find name 'firstName'</strong>, which can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B14508_02_01.jpg" alt="Figure 2.1: Compiler error when TypeScript cannot find a variable declaration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1: Compiler error when TypeScript cannot find a variable declaration</p>
			<p>This error is shown because whenever we attempt to assign a value to a variable, TypeScript looks for where a variable name is defined. We can fix this by utilizing the <strong class="source-inline">declare</strong> keyword. The following code will correct the error that we encountered in the previous case:</p>
			<p class="source-code">declare let firstName: string;</p>
			<p class="source-code">firstName = "Kristine";</p>
			<p>As you can see in the following screenshot, the compiler warning disappeared with the use of the <strong class="source-inline">declare</strong> keyword:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B14508_02_02.jpg" alt="Figure 2.2: Example of a variable being defined in TypeScript&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2: Example of a variable being defined in TypeScript</p>
			<p>Now, that may not seem like a big deal, because we could accomplish the same goal by simply defining a <strong class="source-inline">let</strong> variable, such as the following:</p>
			<p class="source-code">let firstName: string;</p>
			<p class="source-code">firstName = "Kristine"</p>
			<p>The preceding code would not generate an error when viewed in the Visual Studio Code editor.</p>
			<p>So, what is the point of using <strong class="source-inline">declare</strong>? As we build out complex modules, the declare process allows us to describe the complete shape of our modules in a way that cannot be done by simply defining a variable. Now that you know the role of declaration files along with the basic syntax, let's walk through the full workflow of creating a declaration file from scratch in the following exercise.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor060"/>Exercise 2.01: Creating a Declaration File from Scratch</h2>
			<p>In this exercise, we'll create a declaration file from scratch. We'll declare file conventions, import, and then use declared files. Consider that you are developing a web app that requires users to register themselves with credentials such as email, user roles, and passwords. The data types of these credentials will be stated in the declaration file that we'll be creating. A user won't be allowed to log in if they fail to enter the correct credentials.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/bBzat">https://packt.link/bBzat</a>.</p>
			<p>Perform the following steps to implement this exercise:</p>
			<ol>
				<li>Open the Visual Studio Code editor.</li>
				<li>Create a new directory and then create a file named <strong class="source-inline">user.ts</strong>. </li>
				<li>Start the TypeScript compiler and have it watch for changes to the file with the following terminal compile command:<p class="source-code">tsc user.ts ––watch</p><p>The following screenshot shows how the command appears inside the terminal:</p><div id="_idContainer040" class="IMG---Figure"><img src="image/B14508_02_03.jpg" alt="Figure 2.3: Running the TypeScript compiler with the watch flag&#13;&#10;"/></div><p class="figure-caption">Figure 2.3: Running the TypeScript compiler with the watch flag</p><p>It's fine to leave this file empty for now. We'll start building out our implementation shortly. Now let's create our declaration file.</p></li>
				<li>Create a directory called <strong class="source-inline">types/</strong> at the root of our program and then create a file inside it called <strong class="source-inline">AuthTypes.d.ts</strong>.<p>Our project's directory should now look like this:</p><div id="_idContainer041" class="IMG---Figure"><img src="image/B14508_02_04.jpg" alt="Figure 2.4: AuthTypes file structure&#13;&#10;"/></div><p class="figure-caption">Figure 2.4: AuthTypes file structure</p><p class="callout-heading">Note</p><p class="callout">Traditionally, declaration files are kept in their own directory called <strong class="source-inline">types/</strong> and are then imported by the modules that they are defining. It's also the standard convention to use the file extension of <strong class="source-inline">.d.ts</strong> instead of <strong class="source-inline">.ts</strong> for your declaration files.</p></li>
				<li>Within the new declaration file, define the shape of our <strong class="source-inline">AuthTypes</strong> module. Use the <strong class="source-inline">declare</strong> keyword at the top of the file. This tells TypeScript that we are about to describe how the <strong class="source-inline">AuthTypes</strong> module should be structured:<p class="source-code">declare module "AuthTypes" {</p><p class="source-code">    export interface User {</p><p class="source-code">        email: string;</p><p class="source-code">        roles: Array&lt;string&gt;;</p><p class="source-code">    }</p><p class="source-code">}</p><p>In the preceding code, another bit of syntax that might be different than what you're used to writing is that we wrap the module name in quotation marks. When we implement the program, you'll see that if we remove the quotation marks, we won't be able to import the module. Inside the module, we can place any number of exports that we want the module to have. One of the most important concepts to keep in mind is that declaration files do not have any implementation code; they simply describe the types and structure for the elements used in the module. The following screenshot gives a visual representation of the code:</p><div id="_idContainer042" class="IMG---Figure"><img src="image/B14508_02_05.jpg" alt="Figure 2.5: AuthTypes interface&#13;&#10;"/></div><p class="figure-caption">Figure 2.5: AuthTypes interface</p><p>The compiler messages suggest that the import should happen successfully as there have not been any errors up to this point.</p><p>In this step, we're exporting a user interface that defines two data points: email and roles. As far as the data types are concerned, the <strong class="source-inline">email</strong> attribute needs to be a string, and <strong class="source-inline">roles</strong> needs to be an array filled with strings. Such type definitions will ensure that anyone using this module will be informed immediately if they attempt to use the incorrect data structure. </p><p>Now that we have defined the <strong class="source-inline">AuthTypes</strong> module, we need to import it into our TypeScript file so that we can use it. We're going to use the reference import process to bring the file into our program. </p></li>
				<li>Go to the <strong class="source-inline">user.ts</strong> file and add the following two lines of code:<p class="source-code">/// &lt;reference path = "./types/AuthTypes.d.ts" /&gt;</p><p class="source-code">import auth = require("AuthTypes");</p><p>The code in the editor will look something like this:</p><div id="_idContainer043" class="IMG---Figure"><img src="image/B14508_02_06.jpg" alt="Figure 2.6: Importing a declaration file&#13;&#10;"/></div><p class="figure-caption">Figure 2.6: Importing a declaration file</p><p>The first line in the preceding code will make <strong class="source-inline">AuthTypes.d.ts</strong> available to our program, and the second line imports the module itself. Obviously, you can use any variable name for the import statement that you prefer. In this code, we're importing the <strong class="source-inline">AuthTypes</strong> module and storing it in the <strong class="source-inline">auth</strong> keyword. </p><p>With our module imported, we can now start building the implementation for our program. We'll start out by defining a variable and assigning it to our user interface type that we defined in the declaration files. </p></li>
				<li>Add the following code to the <strong class="source-inline">user.ts</strong> file:<p class="source-code">let jon: auth.User;</p><p>The updated code of <strong class="source-inline">user.ts</strong> file will look something like this:</p><p class="source-code">/// &lt;reference path = "./types/AuthTypes.d.ts" /&gt;</p><p class="source-code">import auth = require("AuthTypes");</p><p class="source-code">let jon: auth.User;</p><p>What we've done here is quite impressive. We've essentially created our own type/interface in a separate file, imported it, and told the TypeScript compiler that our new variable is going to be of the <strong class="source-inline">User</strong> type.</p></li>
				<li>Add the actual values of <strong class="source-inline">email</strong> and <strong class="source-inline">roles</strong> for the <strong class="source-inline">jon</strong> variable with the help of the following code:<p class="source-code">jon = {</p><p class="source-code">    email: "jon@snow.com",</p><p class="source-code">    roles: ["admin"]</p><p class="source-code">};</p><p>With the required shape in place, the program compiles properly, and you can perform any tasks that you need to do. </p></li>
				<li>Create another <strong class="source-inline">User</strong> and see how we can work with optional attributes. Add the following code to add details of the user <strong class="source-inline">alice</strong>:<p class="source-code">let alice: auth.User;</p><p class="source-code">alice = {</p><p class="source-code">    email: "alice@snow.com",</p><p class="source-code">    roles: ["super_admin"]</p><p class="source-code">};</p><p>Now, let's imagine that we sometimes keep track of how a user found our application. Not all users will have this attribute though, so we'll need to make it optional without breaking the other user accounts. You can mark an attribute as optional by adding a question mark before the colon. </p></li>
				<li>Add a <strong class="source-inline">source</strong> attribute to the declaration file:<p class="source-code">declare module "AuthTypes" {</p><p class="source-code">    export interface User {</p><p class="source-code">        email: string;</p><p class="source-code">        roles: Array&lt;string&gt;;</p><p class="source-code">        source?: string;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Update our <strong class="source-inline">alice</strong> user with a <strong class="source-inline">source</strong> value of <strong class="source-inline">facebook</strong>: <p class="source-code">/// &lt;reference path = "./types/AuthTypes.d.ts" /&gt;</p><p class="source-code">import auth = require("AuthTypes");</p><p class="source-code">let jon: auth.User;</p><p class="source-code">jon = {</p><p class="source-code">    email: "jon@snow.com",</p><p class="source-code">    roles: ["admin"]</p><p class="source-code">};</p><p class="source-code">let alice: auth.User;</p><p class="source-code">alice = {</p><p class="source-code">    email: "alice@snow.com",</p><p class="source-code">    roles: ["super_admin"],</p><p class="source-code">    source: "facebook"</p><p class="source-code">}</p><p>Notice that the <strong class="source-inline">jon</strong> variable still works perfectly fine, even without the <strong class="source-inline">source</strong> value. This helps us to build flexible interfaces for our programs that define both optional and required data points.</p></li>
				<li>Open the terminal and run the following command to generate a JavaScript file:<p class="source-code">tsc user.ts</p><p>Let's now look at the generated <strong class="source-inline">user.js</strong> file, which can be seen in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B14508_02_07.jpg" alt="Figure 2.7: Declaration file rules not added to the generated JavaScript code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7: Declaration file rules not added to the generated JavaScript code</p>
			<p>Well, that's interesting. There is literally not a single mention of the declaration file in the generated JavaScript code. This brings up a very important piece of knowledge to know when it comes to declaration files and TypeScript in general: declaration files are used solely for the benefit of the developer and are only utilized by the IDE.</p>
			<p>Declaration files are completely bypassed when it comes to what is rendered in the program. And with this in mind, hopefully the goal of declaration files is becoming clearer. The better your declaration files are, the easier it will be for the IDE to understand your program and for yourself and other developers to work with your code.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor061"/>Exceptions</h2>
			<p>Let's see what happens when we don't follow the rules of our interface. Remember in the previous exercise that our interface required two data elements (<strong class="source-inline">email</strong> and <strong class="source-inline">roles</strong>) and that they need to be of the <strong class="source-inline">string</strong> and <strong class="source-inline">Array&lt;string&gt;</strong> types. So, watch what happens when we don't implement the proper data type with the following code:</p>
			<p class="source-code">jon = {</p>
			<p class="source-code">    email: 123</p>
			<p class="source-code">}</p>
			<p>This will generate the following compiler error, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B14508_02_08.jpg" alt="Figure 2.8: TypeScript showing the required data types for an object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8: TypeScript showing the required data types for an object</p>
			<p>That is incredibly helpful. Imagine that you are working with a library that you've never used before. If you were using vanilla JavaScript, this implementation would silently fail and would force you to dig through the library's source code to see what structure it required.</p>
			<p>This compiler error makes sense, and in a real-life application, such as a <strong class="bold">React</strong> or an <strong class="bold">Angular</strong> app, the application wouldn't even load until the issue was fixed. If we update the data structure to match the declaration file for <strong class="source-inline">AuthTypes</strong> with the following code:</p>
			<p class="source-code">jon = {</p>
			<p class="source-code">    email: "jon@snow.com"</p>
			<p class="source-code">}</p>
			<p>We can see that the compiler will move the error message up to the <strong class="source-inline">jon</strong> variable name. If you hover over it, or look at the terminal output, you'll see the error shown in the following screenshot:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B14508_02_09.jpg" alt="Figure 2.9: TypeScript showing the required attributes for an object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9: TypeScript showing the required attributes for an object</p>
			<p>This is an incredibly useful functionality. If you're new to development, this may not seem like a very big deal. However, this type of information is the exact reason why TypeScript continues to grow in popularity. Error messages such as this instantly provide the information that we need in order to fix the bug and work with the program. In the preceding screenshot, the message is telling us that the program won't compile as we are missing a required value, namely, <strong class="source-inline">roles</strong>.</p>
			<p>Now that we have built out our own declaration file from scratch, it's time to move on and see how declaration files are utilized by other libraries.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor062"/>Third-Party Code Libraries</h1>
			<p>Depending on the types of applications that you build, you may never need to build your own declaration files. However, if you're using TypeScript and working with third-party modules, you will need to understand how declaration files work because you will then be able to work seamlessly with external libraries.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor063"/>DefinitelyTyped</h2>
			<p>Let's jump back in time for a moment. When TypeScript was originally developed, there was quite a bit of excitement around the idea of integrating types into JavaScript applications. However, developers began to get frustrated, because even though they were building their programs with types, every time that they imported an external library, such as lodash, they were forced to write code with no type signatures and little to no IDE guidance.</p>
			<p>Essentially, this meant that each time we were to call a function from an external library, we didn't have a high level of assurance that we were working with it properly.</p>
			<p>Thankfully, the open source community had the answer, and the DefinitelyTyped library was created. DefinitelyTyped is a very large repository that contains literally thousands of declaration files for JavaScript code libraries. This means that libraries such as <strong class="source-inline">react</strong>, <strong class="source-inline">lodash</strong>, and pretty much every other popular library has a full set of declaration files that we can use in our TypeScript programs.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on DefinitelyTyped, visit <a href="https://definitelytyped.org">https://definitelytyped.org</a>.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor064"/>Analyzing an External Declaration File</h2>
			<p>Before we learn how to import and use types with external libraries, let's peek into what they look like:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B14508_02_10.jpg" alt="Figure 2.10: Example of how DefinitelyTyped uses declaration files&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10: Example of how DefinitelyTyped uses declaration files</p>
			<p>In the preceding screenshot, if you look at the <strong class="source-inline">lodash</strong> declaration file for the array data structure, you'll see that a single declaration file is over 2,000 lines long. That can be a little intimidating to look at, so let's try to simplify it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">lodash</strong> is a utility library that provides functionality for working with objects, strings, arrays, and suchlike. The <strong class="source-inline">lodash</strong> library's declaration file for the array data structure, as shown in the preceding screenshot, can be found here: <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts">https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts</a>.</p>
			<p>You'll be pleased to know that the elements in the preceding declaration file are exactly what we built out in <em class="italic">Exercise 1.01:</em> <em class="italic">Creating a Declaration File from Scratch</em>. It starts by declaring a <strong class="source-inline">module</strong> instance, and from that point, it lists out interfaces for each of the elements that utilize the array data structure. In fact, if you dissect the code, you'll see that <strong class="source-inline">lodash</strong> provides three interfaces for each of the functions in the library. You don't have to know what these do; however, it is helpful to realize that you can provide as many interfaces as needed when you're building your own code libraries.</p>
			<p>Let's now look at the interface for the <strong class="source-inline">last</strong> function:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B14508_02_11.jpg" alt="Figure 2.11: How lodash implements interfaces&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 2.11: How lodash implements interfaces</p>
			<p>This is a good function to look at, because we'll use it when we get to the example for this section. You can see that the majority of the interface is actually a comment. If you've never seen this syntax before, it is using JSDoc syntax. This is very helpful, because IDEs such as Visual Studio Code will pull the comment, parameters, and return type directly into the IntelliSense interface. This means that when we start typing the <strong class="source-inline">last</strong> function when working with <strong class="source-inline">lodash</strong>, the IDE will automatically pull in the comment data so we can easily read how to use the function.</p>
			<p>After that, the declaration is pretty basic. It simply describes the shape of the last function, specifically, that it takes a list of values as the argument and then returns either <strong class="source-inline">T</strong> or <strong class="source-inline">undefined</strong>. Don't worry about all the references to <strong class="source-inline">T</strong>; you'll learn about what this represents in <em class="italic">Chapter 8</em>, <em class="italic">Generics</em>. For now, just know that it means that it is returning a value.</p>
			<p>Following the same pattern from when we created the declaration file from scratch, in the next section, let's create a new TypeScript project and walk through a practical example of why types are needed. </p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor065"/>Exercise 2.02: Creating Types with External Libraries</h2>
			<p>In this exercise, we'll install types and integrate our types with external libraries. We will also be exploring a scenario wherein we'll check how the function behaves when the wrong type of parameter is passed to it. You'll need to start with an empty directory for this exercise. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/k7Wbt">https://packt.link/k7Wbt</a>.</p>
			<p>Perform the following steps to implement this exercise: </p>
			<ol>
				<li value="1">Open the Visual Studio Code editor.</li>
				<li>Create an empty directory on your computer and run the following command to create a new NPM project:<p class="source-code">npm init -y</p><p>The preceding code will generate a <strong class="source-inline">package.json</strong> file.</p></li>
				<li>To install the Lodash library, open the terminal and type the following command:<p class="source-code">npm i lodash</p><p>The preceding command installs the Lodash library. The <strong class="source-inline">package.json</strong> file should now look something like this, with <strong class="source-inline">lodash</strong> installed in the dependencies list:</p><div id="_idContainer049" class="IMG---Figure"><img src="image/B14508_02_12.jpg" alt="Figure 2.12: The generated package.json file&#13;&#10;"/></div><p class="figure-caption">Figure 2.12: The generated package.json file</p></li>
				<li>Create a file in that directory named <strong class="source-inline">lodash_examples.ts</strong>, start the TypeScript compiler, and have it watch for changes. Inside of the new <strong class="source-inline">.ts</strong> file, add the following code:<p class="source-code">import _ = require("lodash");</p><p class="source-code">const nums = [1, 2, 3];</p><p class="source-code">console.log(_.last(nums));</p></li>
				<li>Run the preceding program in the terminal by writing the following commands:<p class="source-code">tsc lodash_examples.ts</p><p class="source-code">node lodash_examples.js</p><p>The console generates an output of <strong class="source-inline">3</strong>, as you can see in the following screenshot:</p><div id="_idContainer050" class="IMG---Figure"><img src="image/B14508_02_13.jpg" alt="Figure 2.13: Running the generated lodash_example.js program&#13;&#10;"/></div><p class="figure-caption">Figure 2.13: Running the generated lodash_example.js program</p></li>
				<li>Create another variable named <strong class="source-inline">number</strong> and assign it the value <strong class="source-inline">10</strong>. We'll then pass this number as an argument to the Lodash library's <strong class="source-inline">_.last()</strong> function. Write the following code to do this:<p class="source-code">import _ = require("lodash");</p><p class="source-code">//const nums = [1, 2, 3];</p><p class="source-code">//console.log(_.last(nums));</p><p class="source-code">const number = 10;</p><p class="source-code">console.log(_.last(number));</p><p>Since we've looked at the declaration file, we know that the last function expects an array or some type of list. However, for now, let's pretend that we don't have that information, and this is the first time that we're working with the Lodash library.</p><p class="callout-heading">Note</p><p class="callout">The Lodash library's <strong class="source-inline">last</strong> function also works with strings because it views the string of characters like a collection of characters. For example, <strong class="source-inline">_.last("hey")</strong> will return <strong class="source-inline">"y"</strong> since it's the last character in the string.</p></li>
				<li>Run the preceding program in the terminal by writing the following commands:<p class="source-code">tsc lodash_examples.ts</p><p class="source-code">node lodash_examples.js</p><p>The following output is generated when the preceding commands are executed:</p><div id="_idContainer051" class="IMG---Figure"><img src="image/B14508_02_14.jpg" alt="Figure 2.14: What happens when the wrong argument is passed to the last function&#13;&#10;"/></div><p class="figure-caption">Figure 2.14: What happens when the wrong argument is passed to the last function</p><p>In such a small program, this may seem like a trivial issue. However, in a large system, getting an undefined value while expecting an actual value can be time-consuming, as we have to spend more time on debugging.</p><p>In order to fix this issue, let's leverage the DefinitelyTyped repository and bring in the <strong class="source-inline">lodash</strong> types. If you hover over the <strong class="source-inline">import</strong> statement at the top of the file, you'll even see the following warning and recommendation, as shown in the following screenshot:</p><div id="_idContainer052" class="IMG---Figure"><img src="image/B14508_02_15.jpg" alt="Figure 2.15: TypeScript recommending to install Lodash types from DefinitelyTyped&#13;&#10;"/></div><p class="figure-caption">Figure 2.15: TypeScript recommending to install Lodash types from DefinitelyTyped</p><p>That's quite helpful. The warning itself is showing us how we can install the types for the library. </p></li>
				<li>Follow the recommendation and run the following command in the terminal to install <strong class="source-inline">lodash</strong> types:<p class="source-code">npm install @types/lodash</p><p class="callout-heading">Note</p><p class="callout">Any time that you see an <strong class="source-inline">install</strong> command that starts with <strong class="source-inline">@types/</strong>, that means that NPM is going to pull from the DefinitelyTyped repository. </p><p>If you run that command, the warning in the <strong class="source-inline">import</strong> statement should go away automatically. But even more importantly, you should now see that the IDE is now complaining about the line of code where we're trying to pass a number to the <strong class="source-inline">last</strong> function. If you hover over the word <strong class="source-inline">number</strong>, you should see the error shown in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B14508_02_16.jpg" alt="Figure 2.16: IntelliSense revealing the correct type to use with the last function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16: IntelliSense revealing the correct type to use with the last function</p>
			<p>From the preceding screenshot, it is clear that the <strong class="source-inline">last</strong> function won't take any argument of the <strong class="source-inline">number</strong> type. It accepts either an array or a list as an argument. So, let's imagine that we're building a real-world application, and we try to use the <strong class="source-inline">last</strong> function. If we were using vanilla JavaScript, we wouldn't realize our error until we, or even a user, encountered the error while running the program. However, by leveraging TypeScript and DefinitelyTyped, the program won't even compile if we attempt to use a function in the incorrect manner.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor066"/>Development Workflow with DefinitelyTyped</h2>
			<p>Now that you've seen how to install and work with types, we will walk through a full development workflow so that you can observe the benefits of working with types. Without the integration of types into external libraries, we are forced to either have prior knowledge of the library or dig through the documentation to discover the proper usage.</p>
			<p>However, with types, we're going to see how much more streamlined the process is when it comes to working with libraries such as <strong class="source-inline">lodash</strong>. Let's solve an exercise in the next section to get a proper understanding of this.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor067"/>Exercise 2.03: Creating a Baseball Lineup Card Application</h2>
			<p>In this exercise, we'll create a baseball lineup application, wherein we have an array of player names that we'll be retrieving from an API, and then we have a constant variable in the application called <strong class="source-inline">lineupOrder</strong>. Our lineup card application needs to pair the names from the API with <strong class="source-inline">lineupOrder</strong>:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/01spI">https://packt.link/01spI</a>.</p>
			<ol>
				<li value="1">Open the Visual Studio Code editor.</li>
				<li>Create a file named <strong class="source-inline">lodash_newexamples.ts</strong> and add the following code, wherein we have an array variable, <strong class="source-inline">playerNames</strong>, and a list, <strong class="source-inline">lineupOrder</strong>:<p class="source-code">import _ = require("lodash");</p><p class="source-code">const playerNames = [</p><p class="source-code">    "Springer",</p><p class="source-code">    "Bregman",</p><p class="source-code">    "Altuve",</p><p class="source-code">    "Correa",</p><p class="source-code">    "Brantley",</p><p class="source-code">    "White",</p><p class="source-code">    "Gonzalez",</p><p class="source-code">    "Kemp",</p><p class="source-code">    "Reddick"</p><p class="source-code">];</p><p class="source-code">const lineupOrder = [1, 2, 3, 4, 5, 6, 7, 8, 9]; </p><p>This is a perfect situation for using the <strong class="source-inline">zip</strong> function from the Lodash library. Let's imagine that we've heard about the <strong class="source-inline">zip</strong> function, but aren't quite aware of how to use it yet. Start by writing the following code in the same file:</p><p class="source-code">_.zip()</p></li>
				<li>Once you've typed the preceding code, place the cursor in between the parentheses. You'll get some guidance on how to use the function straight from DefinitelyTyped, as shown in the following screenshot:<div id="_idContainer054" class="IMG---Figure"><img src="image/B14508_02_17.jpg" alt="Figure 2.17: IntelliSense guidance on how to use the zip function in lodash&#13;&#10;"/></div><p class="figure-caption">Figure 2.17: IntelliSense guidance on how to use the zip function in lodash</p><p class="callout-heading">Note</p><p class="callout">From the preceding screenshot, we can see that the <strong class="source-inline">zip</strong> function takes two arguments. Both arguments need to be <strong class="source-inline">ArrayLike</strong>, which means they need to function as a type of collection. Also, the function groups the elements together and returns the grouped collection. Thus, without having to dig through the <strong class="source-inline">lodash</strong> documentation, we were able to leverage the type definition as we were building the program. It gives us the guidance we need while working with the function.</p><p>Let's now test it out. We know that the <strong class="source-inline">zip</strong> function takes in two arrays. So, let's provide it with the <strong class="source-inline">playerNames</strong> and <strong class="source-inline">lineupOrder</strong> arrays. </p></li>
				<li>Add the following code to provide the <strong class="source-inline">zip</strong> function with two arrays, <strong class="source-inline">playerNames</strong> and <strong class="source-inline">lineupOrder</strong>:<p class="source-code">console.log(_.zip(lineupOrder, playerNames));</p><p>If you run the preceding code, you'll see that the <strong class="source-inline">zip</strong> function does exactly what it said it would do. It groups the elements and returns the exact data structure that we needed. The rendered lineup card would look something like that shown in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B14508_02_18.jpg" alt="Figure 2.18: Running the zip function properly from lodash&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18: Running the zip function properly from lodash</p>
			<p>In completing this process, you can see how DefinitelyTyped allows you to extend types directly into third-party libraries so that you can get type guidance in your programs.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor068"/>Activity 2.01: Building a Heat Map Declaration File</h2>
			<p>In this activity, you will build a TypeScript application named <strong class="source-inline">heat map log system</strong> for tracking baseball pitch data and ensuring data integrity. You will utilize a TypeScript declaration file to build the type system for the program. From that point, you will import the Lodash library and will add type checking to the program by implementing type definitions from DefinitelyTyped.</p>
			<p>The steps are as follows:</p>
			<ol>
				<li value="1">Visit the following GitHub repository and download the activity project containing the specs and configuration elements: https://packt.link/vnj1R.</li>
				<li>Create a file called <strong class="source-inline">heat_map_data.ts</strong>.</li>
				<li>Run the TypeScript compiler on the file and watch for changes.</li>
				<li>Create a declaration file and define a module called <strong class="source-inline">HeatMapTypes</strong> and export the interface named <strong class="source-inline">Pitcher</strong>.</li>
				<li>Define three attributes for the <strong class="source-inline">Pitcher</strong> module: <strong class="source-inline">batterHotZones</strong>, <strong class="source-inline">pitcherHotZones</strong>, and <strong class="source-inline">coordinateMap</strong>.</li>
				<li>The data structures should be the same for all three attributes, <strong class="source-inline">Array&lt;Array&lt;number&gt;&gt;</strong>, but <strong class="source-inline">coordinateMap</strong> should be optional.</li>
				<li>Then, import the declaration files into the <strong class="source-inline">heat_map_data.ts</strong> file. Then, create and export a <strong class="source-inline">let</strong> variable called <strong class="source-inline">data</strong> and assign it to the <strong class="source-inline">Pitcher</strong> type.</li>
				<li>Add values that adhere to the declaration rules, ensuring that one of the nested arrays is identical in the <strong class="source-inline">batterHotZones</strong> and <strong class="source-inline">pitcherHotZones</strong> attributes.</li>
				<li>Create a new function called <strong class="source-inline">findMatch</strong> that takes in both the <strong class="source-inline">batterHotZones</strong> and <strong class="source-inline">pitcherHotZones</strong> arrays and utilize the <strong class="source-inline">lodash</strong> function, <strong class="source-inline">intersectionWith</strong>, to return the identical nested array. You will need to import the Lodash library, which was installed when you initially ran <strong class="source-inline">npm install</strong>. Finally, store the value of <strong class="source-inline">findMatch</strong> in the <strong class="source-inline">coordinateMap</strong> attribute that was defined in the declaration file.<p>The expected output of this activity will be a nested array that looks similar to this:</p><p class="source-code">[[10.2, -5], [3, 2]]</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor391">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor069"/>Summary</h1>
			<p>In this chapter, we've walked through how to utilize declaration files in TypeScript. We've analyzed how declaration files can assist the IDE in guiding how programs should be structured. We've seen examples of structuring the declaration files. Importing declaration files into TypeScript files assists in the development life cycle. We learned to assign objects to custom types that were defined in the declaration files. It injects typed guidance into the IDE's IntelliSense process. We also learned about DefinitelyTyped and how it can be leveraged to layer on types for third-party libraries and work with them like typed programs. </p>
			<p>With all this knowledge of declaration files, in the next chapter, we'll be taking a deep dive into working with functions in TypeScript. We'll be defining a function using types, building a suite of functions in a module, building a class of functions to perform a specific task, and exploring unit testing.</p>
		</div>
	</body></html>