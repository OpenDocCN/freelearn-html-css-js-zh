<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with the Camera</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making the camera follow an object</li><li class="listitem" style="list-style-type: disc">Zooming the camera to an object</li><li class="listitem" style="list-style-type: disc">Using a perspective camera</li><li class="listitem" style="list-style-type: disc">Using an orthographic camera</li><li class="listitem" style="list-style-type: disc">Creating a 2D overlay</li><li class="listitem" style="list-style-type: disc">Rotating the camera around a scene</li><li class="listitem" style="list-style-type: disc">Matching the rendered view to a resized browser</li><li class="listitem" style="list-style-type: disc">Converting world coordinates to screen coordinates</li><li class="listitem" style="list-style-type: disc">Selecting an object in the scene</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Introduction</h1></div></div></div><p>One of the most important objects in Three.js is the camera. With the camera, you define what part of the scene will be rendered and how the information will be projected on the screen. In this chapter, we'll show you a number of recipes that will allow you to add more complex camera functionality to your Three.js applications.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Making the camera follow an object</h1></div></div></div><p>When <a id="id223" class="indexterm"/>you are creating games or visualizations with many moving objects, you might want to have the camera follow an object around. Normally, when you create a camera, it points to a single position and shows you the scene that falls within its field of view. In this recipe, we'll explain how you can create a camera that can follow any of your objects around.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec125"/>Getting ready</h2></div></div></div><p>This recipe only makes use of core Three.js functions, so there isn't any need to include external <a id="id224" class="indexterm"/>JavaScript libraries in your source code. If you want to see the final result of this recipe, you can open <code class="literal">03.01-camera-follow-object.html</code> in your browser, and you'll see something similar to what is shown in the following screenshot:</p><div><img src="img/1182OS_03_01.jpg" alt="Getting ready"/></div><p>In this example, you can see that the camera is focused on the sphere. As the sphere moves across the scene, the camera moves around to stay focused on the position of the sphere.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec126"/>How to do it...</h2></div></div></div><p>For this recipe, we only need to take three simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the object that we want to follow. For this recipe, we create a simple <code class="literal">THREE.SphereGeometry</code> object and add it to the scene like this:<div><pre class="programlisting">  var sphereGeometry = new THREE.SphereGeometry(1.5,20,20);
  var matProps = {
    specular: '#a9fcff',
    color: '#00abb1',
    emissive: '#006063',
    shininess: 10
  }
  var sphereMaterial = new
  THREE.MeshPhongMaterial(matProps);
  var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphereMesh.name = 'sphere';
  scene.add(sphereMesh);</pre></div><p>As you can see in this short code snippet, we don't need to do anything special with the object we want to follow.</p></li><li class="listitem">The <a id="id225" class="indexterm"/>next step is that we need a camera that renders the scene and stays focused on the object we want to follow. The following JavaScript creates and positions this camera:<div><pre class="programlisting">  // create a camera, which defines where we're looking at.
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  // position and point the camera to the center of the scene
  camera.position.x = 15;
  camera.position.y = 6;
  camera.position.z = 15;</pre></div><p>This is a standard <code class="literal">THREE.PerspectiveCamera</code> object, which we also use in most of the other examples in this chapter. Once again, no special configuration is required.</p></li><li class="listitem">For the final step, we define the render loop that will render the scene and also point the camera in the right direction for this recipe:<div><pre class="programlisting">  function render() {
    var sphere = scene.getObjectByName('sphere');
    renderer.render(scene, camera);
<strong>    camera.lookAt(sphere.position);</strong>
    step += 0.02;
    sphere.position.x = 0 + (10 * (Math.cos(step)));
    sphere.position.y = 0.75 * Math.PI / 2 + (6 * Math.abs(Math.sin(step)));
    requestAnimationFrame(render);
  }</pre></div></li></ol></div><p>In the <code class="literal">render</code> function, we use the <code class="literal">camera.lookAt</code> function to point the camera to the <code class="literal">position</code> function of the sphere. As we do this in every frame that we render, it will look like camera is exactly following the position of sphere.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec127"/>How it works...</h2></div></div></div><p>
<code class="literal">THREE.PerspectiveCamera</code> extends from the <code class="literal">THREE.Object3D</code> object. <code class="literal">THREE.Object3D</code> provides the <code class="literal">lookAt</code> function. When this function is called with the target position to look at, Three.js creates a transformation matrix (<code class="literal">THREE.Matrix4</code>) that aligns <a id="id226" class="indexterm"/>the position of the <code class="literal">THREE.Object3D</code> object with the target's position. In the case of the camera, the result is that the target object is followed around the scene by the camera and is rendered in the middle of the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec128"/>There's more…</h2></div></div></div><p>In this recipe, we use the <code class="literal">lookAt</code> function to point a camera to a specific object. You can apply this same recipe for all the Three.js objects that extend from Object3D. For instance, you can use this to make sure <code class="literal">THREE.SpotLight</code> always illuminates a specific object. Or, if you're creating animations, you could use this effect to make sure one character is always looking at the face of a different character.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec129"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As the <code class="literal">lookAt</code> function uses matrix transformations to point one object to another, you could also do this without making use of the <code class="literal">lookAt</code> function. For this, you'll have to create a transformation matrix yourself. We've explained how to do this in the <em>Applying matrix transformations</em> recipe, which you can find in <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <em>Geometries and Meshes</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Zooming the camera to an object</h1></div></div></div><p>Usually, when <a id="id227" class="indexterm"/>you position a camera in your scene, you <a id="id228" class="indexterm"/>might move it around a bit or let it focus on different objects. In this recipe, we'll show you how you can zoom in to an object so that it almost fills the rendered view.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec130"/>Getting ready</h2></div></div></div><p>To zoom in, we use the standard functionality from the <code class="literal">THREE.PerspectiveCamera</code> object. We've provided an example that demonstrates the result you'll get at the end of this recipe. To experiment with this example, open <code class="literal">03.02-zoom-camera-to-object.html</code> in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_03_02.jpg" alt="Getting ready"/></div><p>Initially, you'll<a id="id229" class="indexterm"/> see a small rotating cube in the center of the<a id="id230" class="indexterm"/> scene. If you click on the <code class="literal">updateCamera</code> button in the menu in the top-right section, the camera will update and show you the rotating cube fullscreen like this:</p><div><img src="img/1182OS_03_03.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec131"/>How to do it...</h2></div></div></div><p>To<a id="id231" class="indexterm"/> zoom the camera to an object, we need to take the following <a id="id232" class="indexterm"/>steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create and position the camera that we use to zoom in:<div><pre class="programlisting">  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  // position and point the camera to the center of the scene
  camera.position.x = 15;
  camera.position.y = 15;
  camera.position.z = 15;
  camera.lookAt(scene.position);</pre></div><p>As you can see, this is a standard <code class="literal">THREE.PerspectiveCamera</code> object, to which we give a position and add to the scene.</p></li><li class="listitem">To zoom in with the camera, we first need to determine the distance from the camera to the object and its height:<div><pre class="programlisting">  // create an helper
  var helper = new THREE.BoundingBoxHelper(cube);
  helper.update();
  // get the bounding sphere
  var boundingSphere = helper.box.getBoundingSphere();
  // calculate the distance from the center of the sphere
  // and subtract the radius to get the real distance.
  var center = boundingSphere.center;
  var radius = boundingSphere.radius;
  var distance = center.distanceTo(camera.position) - radius;
  var realHeight = Math.abs(helper.box.max.y - helper.box.min.y);</pre></div><p>In the previous code snippet, we used <code class="literal">THREE.BoundingBoxHelper</code> to determine the <code class="literal">realHeight</code> function of cube and its distance to the camera. </p></li><li class="listitem">With<a id="id233" class="indexterm"/> this information, we can determine the field <a id="id234" class="indexterm"/>of view (<code class="literal">fov</code>) for the camera so that it only shows the cube:<div><pre class="programlisting">  var fov = 2 * Math.atan(realHeight * control.correctForDepth / (2 * distance)) * (180 / Math.PI);</pre></div><p>What you can see in this code fragment is that we use one additional value, which is <code class="literal">control.correctForDepth</code>, to calculate the field of view. This value, which is set in the menu in the top-right section in the example, increases the resulting field of view slightly. We do this because in this calculation, we assume that the camera is facing the object straight on. If the camera isn't looking straight at the object, we need to compensate for this offset.</p></li><li class="listitem">Now that we've got the field of view for the camera, we can assign this value to the <code class="literal">camera.fov</code> property:<div><pre class="programlisting">  camera.fov = fov;
  camera.updateProjectionMatrix();</pre></div><p>As Three.js caches the <code class="literal">fov</code> property of the camera, we need to inform Three.js that the camera configuration has some changes. We do this with the <code class="literal">updateProjectionMatrix</code> function.</p></li></ol></div><p>At this point, the camera is completely zoomed in on the object.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec132"/>How it works...</h2></div></div></div><p>To <a id="id235" class="indexterm"/>understand how this works, we need to understand what<a id="id236" class="indexterm"/> the field of view property of a <code class="literal">THREE.PerspectiveCamera</code> object does. The following figure shows you the field of view property:</p><div><img src="img/1182OS_03_04.jpg" alt="How it works..."/></div><p>As you can see in this figure, there is a separate horizontal and vertical field of view. Three.js only allows you to set the vertical one, and the horizontal field of view is determined based on the aspect ratio you define on a camera. When you look at this figure, you can also directly see how this recipe works. By changing the field of view, we shrink the near and far planes and limit what is being rendered, and this way, we can zoom in.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec133"/>There's more…</h2></div></div></div><p>There is an alternative way of zooming in besides the one shown here. Instead of changing the <code class="literal">fov</code> property of the camera, we can also move the camera closer to the object. In the latest version of Three.js, a <code class="literal">zoom</code> property is introduced; you can also use this property to zoom in on a scene, but you can't use it directly to zoom in on a single object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Using a perspective camera</h1></div></div></div><p>Three.js <a id="id237" class="indexterm"/>provides two cameras: a camera that renders the scene with a perspective projection (as we see images in the real world) and a camera that renders the scene with an orthogonal projection (fake 3D often used in games; for more information on this type of camera, check out the upcoming <em>Using an orthographic camera</em> recipe). In this recipe, we'll look at the first of these two cameras and explain how you can use the perspective camera in your own scene.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec134"/>Getting ready</h2></div></div></div><p>Working with the properties of a camera can be a bit confusing at times. To help you better understand the steps or this recipe, we've created a simple page that shows you the effect each of the camera properties has. Open up <code class="literal">03.03-use-an-perspective-camera.html</code> in the browser, and you'll see something like this:</p><div><img src="img/1182OS_03_05.jpg" alt="Getting ready"/></div><p>With the last four properties available in the menu in the top-right section, you can set the properties of <code class="literal">THREE.PerspectiveCamera</code>, which is used to render this scene, and see the effect <a id="id238" class="indexterm"/>of each property immediately.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec135"/>How to do it...</h2></div></div></div><p>In this recipe, we set up each of the camera properties separately. These properties can also be passed in with the constructor of <code class="literal">THREE.PerspectiveCamera</code>. In the <em>There's more…</em> section of this recipe, we'll show you how to do this.</p><p>To set up <code class="literal">THREE.PerspectiveCamera</code> completely, we need to perform a couple of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is instantiate the camera:<div><pre class="programlisting">  camera = new THREE.PerspectiveCamera();</pre></div><p>This creates the camera instance, which we configure in the upcoming steps.</p></li><li class="listitem">Now that we've got a camera, we first need to define the aspect ratio between the width of the viewport and the height:<div><pre class="programlisting">  camera.aspect = window.innerWidth / window.innerHeight;</pre></div><p>In our recipe, we use the full width and height of the browser, so we specify the aspect ratio for the camera based on the <code class="literal">window.innerWidth</code> and <code class="literal">window.innerHeight</code> properties. If we use a <code class="literal">div</code> element with a fixed width and height, you should use the ratio between these values as the <code class="literal">aspect</code> function for the camera.</p></li><li class="listitem">The next two properties we need to define are the <code class="literal">near</code> and <code class="literal">far</code> properties:<div><pre class="programlisting">  camera.near = 0.1;
  camera.far = 1000;</pre></div><p>These two properties define the area of the scene that this camera will render. With these two values, the camera will render the scene starting from a distance of <code class="literal">0.1</code> to a distance of <code class="literal">1000</code> from the position of the camera.</p></li><li class="listitem">The last of the properties that can be defined is the (vertical) field of view:<div><pre class="programlisting">  camera.fov = 45;</pre></div><p>This property defines, in degrees, the area that the camera <em>sees</em>. For instance, humans have a horizontal field of view of 120 degrees, while in video games, often a field of view of around 90 or 100 degrees is used.</p></li><li class="listitem">Whenever <a id="id239" class="indexterm"/>you update one of these four properties of the camera, you have to inform Three.js about such a change. You do this by adding the following line:<div><pre class="programlisting">  camera.updateProjectionMatrix();</pre></div></li><li class="listitem">Now, all that is left to do is position the camera and add it to the scene:<div><pre class="programlisting">  camera.position.x = 15;
  camera.position.y = 16;
  camera.position.z = 13;
  scene.add(camera);</pre></div></li></ol></div><p>At this point, we can use this camera with any of the available renderers to render a scene like this: <code class="literal">renderer.render(scene, camera)</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec136"/>How it works...</h2></div></div></div><p>The best way to understand how these properties affect what is rendered on screen is by looking at the following figure, which shows you these properties:</p><div><img src="img/1182OS_03_06.jpg" alt="How it works..."/></div><p>The position of <strong>Near plane</strong> in<a id="id240" class="indexterm"/> this figure is based on the <code class="literal">near</code> property of the camera. <strong>Far plane</strong> is based on the <code class="literal">far</code> property and the <em>fov</em> shown in the figure corresponds to the <code class="literal">fov</code> property. With the <code class="literal">fov</code> property, you define the vertical field of view. The horizontal field <a id="id241" class="indexterm"/>of view is based on the <a id="id242" class="indexterm"/>aspect ratio, which you define with the <code class="literal">aspect</code> property on the camera.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec137"/>There's more…</h2></div></div></div><p>In this recipe, we set each of the properties separately. <code class="literal">THREE.PerspectiveCamera</code> also provides a constructor that you can use to set all these properties in one statement:</p><div><pre class="programlisting">  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);</pre></div><p>Also remember that <code class="literal">THREE.PerspectiveCamera</code> extends from the standard Three.js <code class="literal">THREE.Object3D</code> object. This means that this camera can be rotated and moved around just like any other object.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec138"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <em>Zooming the camera to an object</em> recipe, we used the <code class="literal">fov</code> property of the camera to zoom in on an object, and in the <em>Using an orthographic camera</em> recipe, we will show you the second of the two cameras provided by Three.js, which is <code class="literal">THREE.OrthographicCamera</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Using an orthographic camera</h1></div></div></div><p>In<a id="id243" class="indexterm"/> most cases, you'll use <code class="literal">THREE.PerspectiveCamera</code> to render your scene. With such a camera, the result is a scene with a realistic-looking perspective. Three.js provides an alternative camera with <code class="literal">THREE.OrthographicCamera</code>. This camera uses an orthographic projection to render the scene. With this type of projection, all objects have the same size regardless of their distance to the camera. This is in contrast to <code class="literal">THREE.PerspectiveCamera</code>, where objects that are further away from the camera appear smaller. This was used often for fake 3D in games such <a id="id244" class="indexterm"/>as the Sims or older versions of SimCity (image taken from <a class="ulink" href="http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg">http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg</a>).</p><div><img src="img/1182OS_03_07.jpg" alt="Using an orthographic camera"/></div><p>In <a id="id245" class="indexterm"/>this recipe, we'll show you how to configure <code class="literal">THREE.OrthographicCamera</code> so that you can create this fake 3D effect for your own scenes.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec139"/>Getting ready</h2></div></div></div><p>For this recipe, the only object from Three.js we use is <code class="literal">THREE.OrthographicCamera</code>. This camera is available in the standard Three.js distribution, so there is no need to include any external JavaScript files. We've provided an example that shows the Three.Orthographic Camera in action. You can use this camera to better understand the properties you can use to configure the camera. If you open <code class="literal">03.04-use-an-orthographic-camera.html</code>, you can see a number of cubes that are rendered with <code class="literal">THREE.OrthographicCamera</code>. With the menu in the top-right section, you can tune the configuration of the camera.</p><div><img src="img/1182OS_03_08.jpg" alt="Getting ready"/></div><p>Now, let's look at the steps you need to take to set up this camera.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec140"/>How to do it...</h2></div></div></div><p>To<a id="id246" class="indexterm"/> set up an orthographic camera in Three.js, we need to perform a couple of very simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the camera instance:<div><pre class="programlisting">  camera = new THREE.OrthographicCamera();</pre></div><p>This creates <code class="literal">THREE.OrthographicCamera</code>, which is configured with some default values.</p></li><li class="listitem">The next step is to define the boundaries for this camera:<div><pre class="programlisting">  camera.left = window.innerWidth / -2;
  camera.right =  window.innerWidth / 2;
  camera.top = window.innerHeight / 2;
  camera.bottom = window.innerHeight / - 2;</pre></div><p>This defines the area that is rendered by this camera. In the <em>There's more…</em> section of this recipe, we'll explain how this works.</p></li><li class="listitem">Finally, we <a id="id247" class="indexterm"/>have to set the <code class="literal">near</code> and <code class="literal">far</code> properties of the camera. These properties define which distance from the camera is rendered:<div><pre class="programlisting">  camera.near = 0.1;
  camera.far = 1500;</pre></div></li><li class="listitem">When we don't pass in the arguments in the constructor, we have to inform Three.js that we changed the camera's parameter. For this, we have to add the following line:<div><pre class="programlisting">  camera.updateProjectionMatrix();</pre></div></li><li class="listitem">The final step is to position and align the camera:<div><pre class="programlisting">  camera.position.x = -500;
  camera.position.y = 200;
  camera.position.z = 300;
  camera.lookAt(scene.position);</pre></div></li><li class="listitem">Now, we can just use this camera like any other camera and render a scene like this:<div><pre class="programlisting">  renderer.render(scene, camera);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec141"/>How it works...</h2></div></div></div><p>The easiest way to understand how this camera works is by looking at the following figure:</p><div><img src="img/1182OS_03_09.jpg" alt="How it works..."/></div><p>The<a id="id248" class="indexterm"/> box you see in this figure is the area an orthographic camera renders. In this figure, you can also see the <code class="literal">left</code>, <code class="literal">right</code>, <code class="literal">top</code>, and <code class="literal">bottom</code> properties we defined on the camera, which define the boundaries of this box. The final two properties, which are <code class="literal">near</code> and <code class="literal">far</code>, are used to define the near plane and the far plane. With these six properties, we can define the complete box that is rendered with <code class="literal">THREE.OrthographicCamera</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec142"/>There's more…</h2></div></div></div><p>We can also configure <code class="literal">THREE.OrthographicCamera</code> by passing in these arguments in the constructor:</p><div><pre class="programlisting">  camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0.1, 1500);</pre></div><p>An added advantage is that this way, you don't need to explicitly call <code class="literal">camera.updateProjectionMatrix()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec143"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Three.js provides two types of camera. If you want to use <code class="literal">THREE.PerspectiveCamera</code> instead, look at the <em>Using a perspective camera</em> recipe, where the steps that you need to take to create and configure a perspective camera are explained.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec48"/>Creating a 2D overlay</h1></div></div></div><p>In most<a id="id249" class="indexterm"/> recipes, we only focus on the 3D aspect of Three.js. We show recipes that explain how 3D objects and scenes are rendered, how they can be viewed with different cameras, and how you can change how they look through materials. When you are creating games, you usually also have a 2D layer on top of your 3D scene. You can use this to show health bars, 2D maps, inventory, and much more. In this recipe, we'll show you how to create a 2D overlay using <code class="literal">THREE.OrthogonalCamera</code> and <code class="literal">THREE.PerspectiveCamera</code> together.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec144"/>Getting ready</h2></div></div></div><p>For this recipe, we require an image that we will use as an overlay. To demonstrate this recipe, we create a simple image that looks like this:</p><div><img src="img/1182OS_03_10.jpg" alt="Getting ready"/></div><p>In this recipe, we'll combine this static image with a 3D scene to create the scene that can be seen<a id="id250" class="indexterm"/> by opening the <code class="literal">03.05-create-an-hud-overview.html</code> example in your browser:</p><div><img src="img/1182OS_03_11.jpg" alt="Getting ready"/></div><p>In this example, you can see that we've got a 3D rotating scene with a static 2D overlay on top of it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec145"/>How to do it...</h2></div></div></div><p>Let's look at the steps you need to take:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's start with creating the 2D overlay. The overlay we use in this recipe is the one with a fixed width and height (800 by 600). So, before we create the cameras, let's first create the <code class="literal">div</code> variable that serves as container for the rendered scene:<div><pre class="programlisting">  container = document.createElement( 'div' );
  container.setAttribute(
    "style","width:800px; height:600px");
  document.body.appendChild( container );</pre></div></li><li class="listitem">Next, let's<a id="id251" class="indexterm"/> create the camera that we use to render the overlay. For this, we require <code class="literal">THREE.OrthographicCamera</code>:<div><pre class="programlisting">  orthoCamera = new THREE.OrthographicCamera( 
    WIDTH / - 2, WIDTH / 2,     HEIGHT / 2, HEIGHT / - 2, - 500, 1000 );
  orthoCamera.position.x = 0;
  orthoCamera.position.y = 0;
  orthoCamera.position.z = 0;</pre></div><p>The <code class="literal">WIDTH</code> and <code class="literal">HEIGHT</code> properties are defined as constants with values of 800 and 600. This code fragment creates and positions a standard <code class="literal">THREE.OrthographicCamera</code> object.</p></li><li class="listitem">For the 2D overlay, we create a separate scene where we put the 2D elements:<div><pre class="programlisting">  orthoScene = new THREE.Scene();</pre></div></li><li class="listitem">The only thing we want to add to the 2D scene is the overlay image we showed in the <em>Getting ready</em> section of this recipe. As it's a 2D image, we'll use a <code class="literal">THREE.Sprite</code> object:<div><pre class="programlisting">  var spriteMaterial = new THREE.SpriteMaterial({map: THREE.ImageUtils.loadTexture("../assets/overlay/overlay.png")});
  var sprite = new THREE.Sprite(spriteMaterial);
  sprite.position.set(0,0,10);
  sprite.scale.set(HEIGHT,WIDTH,1);
  orthoScene.add(sprite);</pre></div><p>
<code class="literal">THREE.Sprite</code> is always rendered in the same size (1 by 1 pixels) regardless of its distance to the camera. To make the sprite fullscreen, we scale the <em>x</em> axis with 800 (<code class="literal">WIDTH</code>) and the <em>y</em> axis with 600 (<code class="literal">HEIGHT</code>). With <code class="literal">THREE.SpriteMaterial</code>, which we used in the previous code fragment, we point to the overlay image so that it is shown when we add <code class="literal">THREE.Sprite</code> to the scene.</p></li><li class="listitem">At this point, we've got <code class="literal">THREE.OrthogonalCamera</code> and <code class="literal">THREE.Scene</code>, which show you the overlay as an 800 by 600 image. The next step is to create the 3D screen on which we want to apply this overlay. You don't have to do anything special here; you can create a 3D scene by defining <code class="literal">THREE.PerspectiveCamera</code> and <code class="literal">THREE.Scene</code> and adding some lights and objects. For this recipe, we assume you've got a camera and a scene with the following names:<div><pre class="programlisting">  persCamera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 2100 );
  persScene = new THREE.Scene();</pre></div></li><li class="listitem">Before<a id="id252" class="indexterm"/> we move to the render loop where we define that we want to render the 2D scene as an overlay, we need to configure an additional property on the renderer:<div><pre class="programlisting">  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor( 0xf0f0f0 );
  renderer.setSize( 800, 600 );
<strong>  renderer.autoClear = false;</strong>
  container.appendChild( renderer.domElement );</pre></div><p>On <code class="literal">THREE.WebGLRenderer</code>, we set the <code class="literal">autoclear</code> property to <code class="literal">false</code>. This means that the screen isn't automatically cleared before renderer renders a scene.</p></li><li class="listitem">The final step is to alter the render loop. We first want to render the 3D scene, and without clearing the 3D-rendered output, render the overlay on the top:<div><pre class="programlisting">  function render() {
    renderer.clear();
    renderer.render( persScene, persCamera );
    renderer.clearDepth();
    renderer.render( orthoScene, orthoCamera );
  }</pre></div><p>The first thing we do in the render loop is clear the current output by calling the <code class="literal">clear</code> function on the renderer. We need to do this, as we disabled <code class="literal">autoclear</code> on renderer. Now, we render the 3D scene, and before we render the 2D overlay, we call the <code class="literal">clearDepth</code> function on the renderer. This makes sure the 2D overlay is rendered completely on top and won't intersect at places with the 3D scene. So finally, we render the 2D overlay by passing in <code class="literal">orthoScene</code> and <code class="literal">orthoCamera</code>.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec146"/>How it works...</h2></div></div></div><p>How this recipe works is actually very simple. We can use the same renderer to render multiple scenes with multiple different cameras in the same render loop. This way, we can position various render results on top of each other. With a <code class="literal">THREE.OrthoGraphic</code> camera and <code class="literal">THREE.Sprite</code>, it is easy to position an object at absolute positions on screen. By scaling it to the required size and applying a texture, we can display images using a<a id="id253" class="indexterm"/> renderer. This output, combined with a regular 3D result, allows you to create these kinds of overlays.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec147"/>See also</h2></div></div></div><p>There are a couple of recipes that use an orthographic camera and more advanced tricks to compose the final rendering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this chapter, we explored how to set up <code class="literal">THREE.OrthographicCamera</code> in the <em>Using an orthographic camera</em> recipe.</li><li class="listitem" style="list-style-type: disc">In <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <em>Materials and Textures</em>, we'll show how you can use an HTML5 canvas and a HTML5 video as an input to a texture in the <em>Using HTML canvas as a texture</em> and <em>Using an HTML video as a texture</em> recipes.</li><li class="listitem" style="list-style-type: disc">In <a class="link" href="ch06.html" title="Chapter 6. Point Clouds and Postprocessing">chapter 6</a>, <em>Point Clouds and Postprocessing</em>, we show you how to set up a more complex rendering pipeline in the <em>Setting up a postprocessing pipeline</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec49"/>Rotating the camera around a scene</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <em>Geometries and Meshes</em>, we already showed you a number of recipes that explained<a id="id254" class="indexterm"/> how to rotate objects. In this recipe, we'll show you how to rotate the camera around a scene while the camera will keep looking at the center of the scene.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec148"/>Getting ready</h2></div></div></div><p>For this recipe, we'll use the standard <code class="literal">THREE.PerspectiveCamera</code> object, which we rotate around a simple scene. To see the final result, open the <code class="literal">03.08-rotate-camera-around-scene-y-axis.html</code> example in your browser.</p><div><img src="img/1182OS_03_12.jpg" alt="Getting ready"/></div><p>On this<a id="id255" class="indexterm"/> web page, you can see that the camera rotates around the scene while the floor, box, and lights stay at the same position.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec149"/>How to do it...</h2></div></div></div><p>To accomplish this, we only need to perform a couple of very simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create <code class="literal">THREE.PerspectiveCamera</code> and position it somewhere in the scene:<div><pre class="programlisting">  // create a camera, which defines where we're looking at.
  camera = new THREE.PerspectiveCamera(45,window.innerWidth / window.innerHeight, 0.1, 1000);
  // position and point the camera to the center of the scene
  camera.position.x = 15;
  camera.position.y = 16;
  camera.position.z = 13;
  camera.lookAt(scene.position);</pre></div></li><li class="listitem">To <a id="id256" class="indexterm"/>rotate the camera, we recalculate its position in the render loop as follows:<div><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    var x = camera.position.x;
    var z = camera.position.z;
    camera.position.x = x * Math.cos(control.rotSpeed) + z * Math.sin(control.rotSpeed);
    camera.position.z = z * Math.cos(control.rotSpeed) – x * Math.sin(control.rotSpeed);
    camera.lookAt(scene.position);
    requestAnimationFrame(render);
  }</pre></div><p>In this render function, we update the <code class="literal">camera.position.x</code> and <code class="literal">camera.position.z</code> variables, and by calling <code class="literal">camera.lookAt(scene.position)</code>, we make sure we keep looking at the center of the scene.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec150"/>How it works...</h2></div></div></div><p>What we do here is some basic vector math. We execute a very small rotation of the camera using a rotation matrix. However, instead of the 3D and 4D matrices we used in other recipes, we just use a 2D matrix this time (represented with the two calculations in the <strong>render</strong> loop). After the rotation, we just need to make sure the camera is still looking at the correct position, so we use the <code class="literal">lookAt</code> function (which once again, internally uses matrix calculations to determine how to align the camera to the scene).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec151"/>There's more…</h2></div></div></div><p>In this recipe, we rotated around the scene's <em>y</em> axis. This results in a very smooth animation where the camera circles around the scene. We could, of course, also apply this to the other axes. We provided an example that you can view in the sources provided with this book. If you open <code class="literal">03.08-rotate-camera-around-scene-x-axis.html</code> in your browser, the camera rotates around the <em>x</em> axis instead of the <em>y</em> axis. </p><p>The only change you have to make is change the calculations in the render loop:</p><div><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    var z = camera.position.z;
    var y = camera.position.y;
<strong>    camera.position.y = y * Math.cos(control.rotSpeed) + z * Math.sin(control.rotSpeed);</strong>
<strong>    camera.position.z = z * Math.cos(control.rotSpeed) – y * Math.sin(control.rotSpeed);</strong>
    camera.lookAt(scene.position);
    requestAnimationFrame(render);
  }</pre></div><p>When <a id="id257" class="indexterm"/>you look at this example in your browser, you might notice something strange. At a certain point, it'll look like the camera jumps around. The reason is that the camera tries to stay the right-side up, so it quickly changes orientation when it is at the top or bottom of its rotation.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec152"/>See also</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <em>Geometries and Meshes</em>, we already discussed some rotation-related recipes. If you want to learn more about rotation or the matrix calculations required for it, look at the following recipes from <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>,<em> Geometries and Meshes</em>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Rotating an object around its own axis</em></li><li class="listitem" style="list-style-type: disc"><em>Rotating an object around a point in space</em></li><li class="listitem" style="list-style-type: disc"><em>Applying matrix transformations</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec50"/>Matching the rendered view to a resized browser</h1></div></div></div><p>When <a id="id258" class="indexterm"/>you define a camera in Three.js, you<a id="id259" class="indexterm"/> need to define the aspect ratio; for a renderer, you need to define its output size. Normally, you do this once when you set up your initial scene. This works great until the user resizes their browser. In this case, the aspect ratio for the camera will probably change, as will the output size for the renderer. In this recipe, we'll show you the steps you need to take to react to changes to the screen size.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec153"/>Getting ready</h2></div></div></div><p>As with every recipe, we provide an example that you can use to test and experiment with for this recipe as well. Open <code class="literal">03.06-change-the-camera-on-screen-resize.html</code> in your browser and make the screen very small.</p><div><img src="img/1182OS_03_13.jpg" alt="Getting ready"/></div><p>What<a id="id260" class="indexterm"/> you see is that the same amount<a id="id261" class="indexterm"/> of information is shown in the scene—only rendered smaller. When you now increase the screen size again, you'll see that Three.js always uses the complete available space.</p><div><img src="img/1182OS_03_14.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec154"/>How to do it...</h2></div></div></div><p>In<a id="id262" class="indexterm"/> this recipe, we'll add a resize handler to<a id="id263" class="indexterm"/> the web page, which reacts to resize events. Adding this handler only takes a couple of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to add is the function that we call when the resize event occurs. The following code fragment shows you the <code class="literal">onResize</code> function that we will call in the next step:<div><pre class="programlisting">  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }</pre></div><p>In this code snippet, we first recalculate the aspect ratio for the camera based on the new width and height. As Three.js caches certain aspects of the camera, we have to call the <code class="literal">updateProjectionMatrix()</code> function next to make sure the new aspect ratio is used. We also change the size for the renderer to the new width and height, so the complete screen space is used.</p></li><li class="listitem">Now<a id="id264" class="indexterm"/> that we've got our update function, we need to define an event listener:<div><pre class="programlisting">  window.addEventListener('resize', onResize, false);</pre></div><p>As you can see, we add an event listener for the <code class="literal">resize</code> event. So whenever the screen is resized, the provided function, which is <code class="literal">onResize</code>, will be called.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec155"/>How it works...</h2></div></div></div><p>Whenever<a id="id265" class="indexterm"/> something happens within a browser (a button is clicked on, the mouse is moved, the window is resized, and so on), browsers will throw an event. From JavaScript, you can register listeners to these events so that you can respond to them. In this recipe, we use the <code class="literal">resize</code> event to listen to any change in the window size. For more information on this event, you can look at the excellent <a id="id266" class="indexterm"/>documentation Mozilla provides at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Events/resize">https://developer.mozilla.org/en-US/docs/Web/Events/resize</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec51"/>Converting world coordinates to screen coordinates</h1></div></div></div><p>If you <a id="id267" class="indexterm"/>are creating a game that<a id="id268" class="indexterm"/> provides a 2D interface on top of a 3D world, for instance, as shown in the <em>Creating a 2D overlay</em> recipe, you might want to know how the 3D coordinates map to your 2D overlay. If you know the 2D coordinates, you can add all kinds of visual effects to the 2D overlay, such as tracking the code or letting the 2D overlay interact with the objects in the 3D scene.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec156"/>Getting ready</h2></div></div></div><p>You<a id="id269" class="indexterm"/> don't need to perform any steps<a id="id270" class="indexterm"/> to get ready for this recipe. In this recipe, we can use the <code class="literal">THREE.Projector</code> object available in Three.js to determine the correct coordinates. You can view the result from this recipe in action by opening <code class="literal">03.07-convert-world-coordintate-to-screen-coordinates.html</code> in your browser as shown in the following screenshot:</p><div><img src="img/1182OS_03_15.jpg" alt="Getting ready"/></div><p>The box appears at random positions when you open this example. When you click on the <strong>calculateScreenCoordinate</strong> button in the menu in the top-right section, the <em>x</em> and <em>y</em> coordinates of the center of the box will be shown.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec157"/>How to do it...</h2></div></div></div><p>To convert world coordinates to screen coordinates, we use a couple of internal Three.js objects:</p><div><ol class="orderedlist arabic"><li class="listitem">The first object we need is <code class="literal">THREE.Projector</code>:<div><pre class="programlisting">  var projector = new THREE.Projector();</pre></div></li><li class="listitem">Next, we use this projector to project the position of the cube onto the camera:<div><pre class="programlisting">var vector = new THREE.Vector3();
  projector.projectVector(
    vector.setFromMatrixPosition( object.matrixWorld ),
    camera );</pre></div><p>The <code class="literal">vector</code> variable will now contain the position of the object as it is seen by the <code class="literal">camera</code> object.</p></li><li class="listitem">When<a id="id271" class="indexterm"/> you project<a id="id272" class="indexterm"/> a vector, as we did in step two, the resulting <em>x</em> and <em>y</em> values range from -1 to 1. So in this final step, we convert these values to the current screen width and height:<div><pre class="programlisting">  var width = window.innerWidth;
  var height = window.innerHeight;
  var widthHalf = width / 2;
  var heightHalf = height / 2;
  vector.x = ( vector.x * widthHalf ) + widthHalf;
  vector.y = - ( vector.y * heightHalf ) + heightHalf;</pre></div><p>At this point, the <code class="literal">vector</code> variable will contain the screen coordinates of the center of <code class="literal">object</code>. You can now use these coordinates with standard JavaScript, HTML, and CSS to add effects.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec158"/>How it works...</h2></div></div></div><p>In this recipe, we use the same effect that Three.js uses to render the scene. When you render a scene, the objects are projected onto a camera, which determines what area needs to be rendered and where the objects appear. With the projector class, we can perform this projection for a single vector. The result is the position of this vector in two dimensions based on the used camera.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec159"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this recipe, we converted world coordinates to screen coordinates. This is actually rather easy, as we've got all the information (in three dimensions) to correctly determine the coordinates (in two dimensions). In the <em>Selecting an object in the scene</em> recipe, we convert a screen coordinate to a world coordinate, which is harder to do, as we don't have any depth information we can use.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec52"/>Selecting an object in the scene</h1></div></div></div><p>A <a id="id273" class="indexterm"/>common requirement for Three.js applications is to interact <a id="id274" class="indexterm"/>with the scene. You might create a shooter where you want to use the mouse for aiming or an RPG where you need to interact with your environment. In this recipe, we'll show you how you can use the mouse to select objects that are rendered on screen.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec160"/>Getting ready</h2></div></div></div><p>To apply this effect, we'll need a scene where we can select some objects. For this recipe, we've provided an example, which is <code class="literal">03.10-select-an-object-in-the-scene.html</code>. If you open this file in your browser, you'll see a number of objects moving around the scene.</p><div><img src="img/1182OS_03_16.jpg" alt="Getting ready"/></div><p>You can use your mouse to select any of the objects on screen. The first time you click on them, they'll become transparent, and the next time, they'll become solid again.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec161"/>How to do it...</h2></div></div></div><p>We'll need <a id="id275" class="indexterm"/>to work through a couple of steps for this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">The first <a id="id276" class="indexterm"/>thing we need to do is set up the mouse listener. We want to fire a JavaScript function each time the mouse button is clicked on. To do this, we register the following listener:<div><pre class="programlisting">  document.addEventListener('mousedown', onDocumentMouseDown, false);</pre></div><p>This will tell the browser to fire the <code class="literal">onDocumentMouseDown</code> button whenever a <code class="literal">mousedown</code> event is detected.</p></li><li class="listitem">Next, we define the <code class="literal">onMouseDown</code> function as follows:<div><pre class="programlisting">function onDocumentMouseDown(event) { ... }</pre></div><p>This function will be called when you push the left mouse button. In the upcoming steps, we'll show you what to put into this function to detect which object is selected.</p></li><li class="listitem">The first thing we need to do is convert the <em>x</em> and <em>y</em> coordinates of the mouse click to a position that <code class="literal">THREE.PerspectiveCamera</code> can understand:<div><pre class="programlisting">var projector = new THREE.Projector();
  var vector = new THREE.Vector3(
    (event.clientX / window.innerWidth) * 2 - 1,
    -(event.clientY / window.innerHeight) * 2 + 1,
    0.5);
  projector.unprojectVector(vector, camera);
</pre></div><p>At this point, vector will contain the <em>x</em> and <em>y</em> coordinates in coordinates the camera and Three.js understands.</p></li><li class="listitem">Now we can use another Three.js object, which is <code class="literal">THREE.Raycaster</code>, to determine which objects in our scene might be located at the position we clicked on:<div><pre class="programlisting">  var raycaster = new THREE.Raycaster(camera.position,vector.sub(camera.position).normalize());
  var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);</pre></div><p>Here, we first create <code class="literal">THREE.Raycaster</code> and use the <code class="literal">intersectObjects</code> function to determine whether <code class="literal">sphere</code>, <code class="literal">cylinder</code>, or <code class="literal">cube</code> are selected. If an object is selected, it will be stored in the <code class="literal">intersects</code> array.</p></li><li class="listitem">Now we can process the <code class="literal">intersects</code> array. The first element will be the element closest to the camera, and in this recipe, this is the one we're interested in:<div><pre class="programlisting">  if (intersects.length &gt; 0) {
    intersects[0].object.material.transparent = true;
    if (intersects[0].object.material.opacity === 0.5) {
      intersects[0].object.material.opacity = 1;
    } else {
      intersects[0].object.material.opacity = 0.5;
    }
  }</pre></div><p>In this recipe, we just switch the opacity of an object whenever it is clicked on.</p></li></ol></div><p>That's it. With<a id="id277" class="indexterm"/> this setup, you can select objects using your mouse.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec162"/>How it works...</h2></div></div></div><p>This recipe <a id="id278" class="indexterm"/>works by using <code class="literal">THREE.RayCaster</code>. With <code class="literal">THREE.RayCaster</code>, as the name implies, you shoot out a ray into the scene. The path of this ray is based on the properties of the camera, the position of the camera, and the objects provided to the <code class="literal">intersectObjects</code> function. For each of the provided objects, Three.js determines whether a ray cast using <code class="literal">THREE.RayCaster</code> can hit the specified object.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec163"/>There's more</h2></div></div></div><p>An interesting effect that can be added, and that better visualizes what is happening, is rendering the ray that is cast by <code class="literal">THREE.RayCaster</code>. You can very easily do this by just adding the following to step 5 of this recipe:</p><div><pre class="programlisting">  var points = [];
  points.push(new THREE.Vector3(camera.position.x, camera.position.y - 0.2, camera.position.z));
  points.push(intersects[0].point);
  var mat = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    transparent: true,
    opacity: 0.6
  });
  var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 60, 0.001);
  var tube = new THREE.Mesh(tubeGeometry, mat);
  scene.add(tube);</pre></div><p>There's nothing too special in this code fragment. We just draw a line from the position of the camera (with a small offset to the <em>y</em> axis, or else we don't see anything) to the position where the <a id="id279" class="indexterm"/>ray intersects. The result, which you can also see in the<a id="id280" class="indexterm"/> example discussed in the <em>Getting ready</em> section of this recipe, looks something like this:</p><div><img src="img/1182OS_03_17.jpg" alt="There's more"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec164"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this recipe, we convert a 2D coordinate into a 3D one. In the <em>Converting world coordinates to screen coordinates</em> recipe, we explain how to do the opposite.</li></ul></div></div></div></body></html>