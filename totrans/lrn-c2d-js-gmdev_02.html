<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Adding Interactivity &#x2013; The Making of a Concentration Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Adding Interactivity – The Making of a Concentration Game</h1></div></div></div><p>By definition, a game is interactive in some way. Players have to be <span class="emphasis"><em>part</em></span> of it by doing things. The simplest form of interactivity is clicking or touching tiles in the game.</p><p>A Concentration <a id="id46" class="indexterm"/>game is simple to explain, but it will cover some new and important concepts, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating multiple instances of game assets</li><li class="listitem" style="list-style-type: disc">Extending classes to improve its capabilities. Actually, there are no classes in JavaScript, but they are emulated using variables and prototypes</li><li class="listitem" style="list-style-type: disc">Adding gradients</li><li class="listitem" style="list-style-type: disc">Making assets react to clicks and touches</li><li class="listitem" style="list-style-type: disc">Changing sprite images on the fly</li><li class="listitem" style="list-style-type: disc">Adding text labels</li><li class="listitem" style="list-style-type: disc">Removing sprites from the game</li></ul></div><p>By the end of the chapter, you will be able to create a full Concentration game using space for customization.</p><p>As the project created in the previous chapter is more than just a Hello World game and rather acts as a blueprint for all your future projects, you'll start building our Concentration game out of the previously finished project.</p><div class="section" title="Creating multiple instances of game assets"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Creating multiple instances of game assets</h1></div></div></div><p>The first <a id="id47" class="indexterm"/>thing you have to do in the making <a id="id48" class="indexterm"/>of a Concentration game is draw the tiles that you will use in the game. Here are the pictures used for the covered tiles and the eight different tiles that could be potentially matched, all saved in the <code class="literal">assets</code> folder, as explained in the previous chapter:</p><div class="mediaobject"><img src="graphics/0072OS_02_01.jpg" alt="Creating multiple instances of game assets"/></div><p>Each tile is a 64 x 64 <code class="literal">PNG</code> file, where the covered tile is called <code class="literal">cover.png</code>, while the tile to be matched is named with a progressive number from 0 to 7: <span class="strong"><strong>tile_0</strong></span>, <span class="strong"><strong>tile_1</strong></span>, until <span class="strong"><strong>tile_7</strong></span>. This is because the actual board tile values will be stored in an array whose values will range from 0 to 7, and it will be easy to assign value 0 to <span class="strong"><strong>tile_0</strong></span>, value 1 to <span class="strong"><strong>tile_1</strong></span>, and so on.</p><p>With <a id="id49" class="indexterm"/>these nine files in the assets folder, you are ready to load them, thanks to the <code class="literal">loadassets.js</code> file located in the <code class="literal">src</code> folder of our project:</p><div class="informalexample"><pre class="programlisting">var gameResources = ["assets/cover.png",
  "assets/tile_0.png",
  "assets/tile_1.png",
  "assets/tile_2.png",
  "assets/tile_3.png",
  "assets/tile_4.png",
  "assets/tile_5.png",
  "assets/tile_6.png",
  "assets/tile_7.png"
];
</pre></div><p>The images are loaded in the same way as in the previous chapter; you then place all the 16 covered tiles.</p><p>This is the <a id="id50" class="indexterm"/>content of <code class="literal">gamescript.js</code>, which is basically the same you used in the previous chapter, except sprite creation is inside a <code class="literal">for</code> loop that will be executed 16 times:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});

var game = cc.Layer.extend({
  init:function () {
    this._super();
    for(i=0;i&lt;16;i++){
      var tile = cc.Sprite.create("assets/cover.png");
      this.addChild(tile,0);
      tile.setPosition(49+i%4*74,400-Math.floor(i/4)*74);
    }
  }
});</pre></div><p>The <a id="id51" class="indexterm"/>strange numbers in the <code class="literal">setPosition</code> method places the group of 64 x 64 tiles in a 4 x 4 grid on the stage. You can use some math to change the tiles' position the way you prefer.</p><p>Test the <a id="id52" class="indexterm"/>game and this is what you will see on the screen:</p><div class="mediaobject"><img src="graphics/0072OS_02_02.jpg" alt="Creating multiple instances of game assets"/></div><p>This is a <a id="id53" class="indexterm"/>nice grid of covered tiles, but the <a id="id54" class="indexterm"/>background is poor. It's time to work on it a bit more.</p></div></div>
<div class="section" title="Adding a gradient background"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Adding a gradient background</h1></div></div></div><p>A quick <a id="id55" class="indexterm"/>and easy way to improve the <a id="id56" class="indexterm"/>background is to add a gradient. Most of the skies and sceneries you see in the background of your favorite games are just gradients.</p><p>You are going to add a gradient layer conveniently called <code class="literal">gradient</code> to the game simply by adding these two lines to <code class="literal">gamescript.js</code>:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  // same as before
});

var game = cc.Layer.extend({
  init:function () {
    this._super();
    <span class="strong"><strong>var gradient = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));</strong></span>
<span class="strong"><strong>    this.addChild(gradient);</strong></span>
    for(i=0;i&lt;16;i++){
      var tile = cc.Sprite.create("assets/cover.png");
      this.addChild(tile,0);
      tile.setPosition(49+i%4*74,400-Math.floor(i/4)*74);
    }
  }
});</pre></div><p>Gradient layer creation is made by the <code class="literal">cc.LayerGradient.create</code> method, which requires <a id="id57" class="indexterm"/>both the start and end gradient color in an <span class="strong"><strong>RGBA</strong></span> (<span class="strong"><strong>Red, Green, Blue, Alpha</strong></span>) format.</p><p>There are two things you need to notice about the lines that were added:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The gradient layer should be added before tiles, so tiles will be placed in front of the background because you can play with the depth of the layers to dynamically adjust layers in Z-order, but that's not the case.</li><li class="listitem">Gradient colors can be specified both in decimal (from 0 to 255) and hexadecimal (from 0 x 00 to 0 x FF) values.</li></ol></div><p>Now, test the <a id="id58" class="indexterm"/>game again and you should see a nice black to blue background.</p><div class="mediaobject"><img src="graphics/0072OS_02_03.jpg" alt="Adding a gradient background"/></div><p>At this time, you <a id="id59" class="indexterm"/>have 16 tiles placed on a beautiful gradient background. Now, it's time to let the player have the ability to pick some of them up.</p><p>Unfortunately, sprites are just images and can't be picked.</p></div>
<div class="section" title="Extending the Sprite class beyond its capabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Extending the Sprite class beyond its capabilities</h1></div></div></div><p>When <a id="id60" class="indexterm"/>I say <span class="emphasis"><em>sometimes</em></span>, I mean <span class="emphasis"><em>most of the time</em></span> the <a id="id61" class="indexterm"/>default Cocos2d-JS classes do not let you do everything you need to do with them.</p><p>Although this might seem like a limit of Cocos2d-JS, it's one of its best features. You are provided with a basic set of classes you can extend the way you need to, meaning you can add new capabilities.</p><p>So, what does it really mean to extend a class? Imagine a real-world example: you're entering a bike shop and buying a mountain bike. Your mountain bike is a class; with this class, you can do everything you can actually do with a mountain bike, namely pedal and steer.</p><p>Unfortunately, you are a bit lazy and don't want to pedal all the time, so you buy a little motor and add it to your mountain bike. Now, you can still do everything you usually did with your bike, but you can also rest your legs, turn on the motor, and let it pedal on your behalf.</p><p>You just extended the mountain bike, created a motorized mountain bike, which is basically still a bike and inherits all its features with some new ones.</p><p>To <a id="id62" class="indexterm"/>extend the <code class="literal">Sprite</code> class <a id="id63" class="indexterm"/>and make it capable of doing all the stuff you need in order to make your Concentration game, you have to add some lines to <code class="literal">gamescript.js</code>:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    // same as before
  }
});

var game = cc.Layer.extend({
  init:function () {
    this._super();
    var gradient = cc.LayerGradient.create(cc.c4b(0,0,0,255), cc.c4b(0x46,0x82,0xB4,255));
    this.addChild(gradient);
    for(i=0;i&lt;16;i++){
      <span class="strong"><strong>var tile = new MemoryTile();</strong></span>
      this.addChild(tile,0);
      tile.setPosition(49+i%4*74,400-Math.floor(i/4)*74);
    }
  }
}); 
<span class="strong"><strong>var MemoryTile = cc.Sprite.extend({</strong></span>
<span class="strong"><strong>  ctor:function() {</strong></span>
<span class="strong"><strong>    this._super();</strong></span>
<span class="strong"><strong>    this.initWithFile("assets/cover.png");</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>});</strong></span>
</pre></div><p>If you test the game at this time, you will see the same background gradient with the 4 x 4 grid of covered tiles. Let's see what has changed.</p><p>Firstly, the tile creation is not made anymore with the following code:</p><div class="informalexample"><pre class="programlisting">var tile = cc.Sprite.create("assets/cover.png");</pre></div><p>Instead, it's been replaced with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var tile = new MemoryTile();</strong></span>
</pre></div><p>Now, you aren't creating the Sprite itself, but a new type called <code class="literal">MemoryTile</code>, which will extend the <code class="literal">Sprite</code> class.</p><p>This is <a id="id64" class="indexterm"/>how you declare that you are extending a class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>v</strong></span>ar <span class="strong"><strong>M</strong></span>emoryTile = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/cover.png");
  }
})</pre></div><p>Here, the <code class="literal">MemoryTile</code> variable is declared as an extension of the <code class="literal">Sprite</code> class.</p><p>The <code class="literal">ctor</code> method is <a id="id65" class="indexterm"/>the constructor, basically the stuff being executed as soon as the variable is created. In this case, <code class="literal">initWithFile</code> assigns the same cover image you assigned before with the old way of placing tiles.</p><p>You might argue that four lines of code are being used to do what could be done with just a single line of code, and that's true, but this is the little price you pay to add new functionalities to Cocos2d-JS built-in classes.</p><p>Now, you have a new class that extends Sprite. Let's add interactivity to it.</p></div>
<div class="section" title="Making assets react to clicks and touches"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Making assets react to clicks and touches</h1></div></div></div><p>There are <a id="id66" class="indexterm"/>two ways to pick a tile, irrespective of whether you are playing with a touch or mouse-driven device. You can tap on a tile or you can click on it.</p><div class="section" title="Picking a tile as an initial attempt"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Picking a tile as an initial attempt</h2></div></div></div><p>No matter <a id="id67" class="indexterm"/>the way you use <a id="id68" class="indexterm"/>Cocos2d-JS, all in all you are creating cross-platform games. You have to tell Cocos2d-JS you are going to let the user touch or click on some tiles, so the <code class="literal">MemoryTile</code> class will change this way:</p><div class="informalexample"><pre class="programlisting">var MemoryTile  = cc.Sprite.extend({
  ctor:function() {
    this._super();
    this.initWithFile("assets/cover.png");
    <span class="strong"><strong>cc.eventManager.addListener(listener.clone(), this);</strong></span>
  }
})</pre></div><p>What just happened? You just added an event listener to the event manager. The event manager is the entity that triggers events fired by the game or by the player. The <code class="literal">addListener</code> method adds a listener to the event manager, but you don't have a listener at the moment. Let's create one:</p><div class="informalexample"><pre class="programlisting">var listener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    var target = event.getCurrentTarget();
    var location = target.convertToNodeSpace(touch.getLocation());
    var targetSize = target.getContentSize();
    var targetRectangle = cc.rect(0, 0, targetSize.width, targetSize.height);
    if (cc.rectContainsPoint(targetRectangle, location)) {
      console.log("I picked a tile!!");
    }
  }
})</pre></div><p>This is the basic listener. You will find yourself using it in most of your projects, so let's take a closer look at it:</p><div class="informalexample"><pre class="programlisting">var listener = cc.EventListener.create({</pre></div><p>This is how you create a listener with a <code class="literal">cc.EventListener.create</code> method. You named it <code class="literal">listener</code> to match the previous call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cc.eventManager.addListener(listener.clone(), this);</strong></span>
</pre></div><p>Then, you modified the <code class="literal">MemoryTile</code> class:</p><div class="informalexample"><pre class="programlisting">event: cc.EventListener.TOUCH_ONE_BY_ONE,</pre></div><p>Here, you specify the type of event: <code class="literal">cc.EventListener.TOUCH_ONE_BY_ONE</code> tells the game that you are waiting for touches, but only one at a time. Note that the game talks about touches, but the game will also work with a mouse. This is the true power Cocos2d-JS brings when dealing with cross-platform development.</p><div class="informalexample"><pre class="programlisting">swallowTouches: true,</pre></div><p>This will basically ignore all touches when there's one active touch:</p><div class="informalexample"><pre class="programlisting">onTouchBegan: function (touch, event) {</pre></div><p>Now, things start to get serious as you are ready to trigger when the touch or mouse click begins:</p><div class="informalexample"><pre class="programlisting">var target = event.getCurrentTarget();</pre></div><p>The <code class="literal">getCurrentTarget</code> method returns the current click target:</p><div class="informalexample"><pre class="programlisting">var location = target.convertToNodeSpace(touch.getLocation());</pre></div><p>By calling the <code class="literal">touch.getLocation</code> method, you will have the coordinates of the touch or click <a id="id69" class="indexterm"/>inside the game, while the <code class="literal">convertToNodeSpace</code> method will convert such coordinates into the coordinates <a id="id70" class="indexterm"/>relative to the tile itself. This way, the <code class="literal">location</code> variable will contain the coordinates of the touch or click that is relative to the tile:</p><div class="informalexample"><pre class="programlisting">var targetSize = target.getContentSize();</pre></div><p>The <code class="literal">getContentSize</code> function only returns the width and height of the target, in this case the tile:</p><div class="informalexample"><pre class="programlisting">var targetRectangle = cc.rect(0, 0, targetSize.width, targetSize.height);</pre></div><p>Now, you define a rectangle with the same size of the tile with the <code class="literal">cc.rect</code> method. This will allow us to know whether the click or touch action was inside this rectangle. A certain tile has been clicked:</p><div class="informalexample"><pre class="programlisting">if (cc.rectContainsPoint(targetRectangle, location)) {</pre></div><p>Also, this is how you determine whether a point is inside a rectangle, so you can say that the tile has been clicked.</p><p>So, basically:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Each tile detects a <code class="literal">touch</code> or <code class="literal">click</code> action, which can be inside or outside the tile itself.</li><li class="listitem">You get touch/click coordinates relative to the tile.</li><li class="listitem">You see whether these coordinates are inside the tile.</li><li class="listitem">You can say which tile has been clicked, if any.</li></ol></div><p>Are you ready to click tiles? Run the game and click on a tile, and you will see.</p><p>
<span class="strong"><strong>I picked a tile!!</strong></span>
</p><p>Yes, it works! Let me just show you this line again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cc.eventManager.addListener(listener.clone(), this);</strong></span>
</pre></div><p>Did you notice the <code class="literal">clone()</code> method when you first wrote it? You used the <code class="literal">clone</code> method because an event listener can be added only once. The <code class="literal">addListener</code> method sets a registration <a id="id71" class="indexterm"/>flag on the event listener, and <a id="id72" class="indexterm"/>it won't add the event listener again if the flag is already set. In other words, you will be able to check for clicks or touches only on the first tile you assigned the listener to.</p><p>Using <code class="literal">clone</code>, you basically duplicate the listener, so each tile will have its own listener up and running.</p></div></div>
<div class="section" title="Changing sprite images on the fly"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Changing sprite images on the fly</h1></div></div></div><p>Let's <a id="id73" class="indexterm"/>now find out how to change sprite images.</p><div class="section" title="Showing the tile picture"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Showing the tile picture</h2></div></div></div><p>Once a <a id="id74" class="indexterm"/>tile is picked, it has to show its picture. Pictures are just a graphical representation of a tile value, which you initially store in an array called <code class="literal">gameArray</code> declared at the very beginning of a <code class="literal">gamescript.js</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var gameArray = [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7];</strong></span>
vargameScene = cc.Scene.extend({
  onEnter:function () {
    // same as before
  }
});</pre></div><p>Then, once you create a new tile, you can assign it a custom attribute called <code class="literal">pictureValue</code> with the value of the <span class="emphasis"><em>i-th</em></span> element of <code class="literal">gameArray</code>:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    var gradient = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));
    this.addChild(gradient);
    for(i=0;i&lt;16;i++){
      var tile = new MemoryTile();
      <span class="strong"><strong>tile.pictureValue = gameArray[i];</strong></span>
      this.addChild(tile,0);
      tile.setPosition(49+i%4*74,400-Math.floor(i/4)*74);
    }
  }
});</pre></div><p>Also, once the <a id="id75" class="indexterm"/>tile is picked, you can again use the <code class="literal">initWithFile()</code> method to assign it another image according to its value:</p><div class="informalexample"><pre class="programlisting">var listener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    var target = event.getCurrentTarget();
    var location = target.convertToNodeSpace(touch.getLocation());
    var targetSize = target.getContentSize();
    var targetRectangle = cc.rect(0, 0, targetSize.width, targetSize.height);
    if (cc.rectContainsPoint(targetRectangle, location)) {
      <span class="strong"><strong>target.initWithFile("assets/tile_"+target.pictureValue+".png");</strong></span>
    }
  }
}</pre></div><p>Now, it should be clear why the tile images files were numbered from 0 to 7. This is because they will match the tile values assigned by the <code class="literal">gameArray</code> elements.</p><p>Run the game and start picking tiles; see how they uncover showing their actual picture:</p><div class="mediaobject"><img src="graphics/0072OS_02_04.jpg" alt="Showing the tile picture"/></div><p>Now, add some game logic that will allow you to pick only two tiles, then remove them from the game if they match, or cover them again.</p><p>You need <a id="id76" class="indexterm"/>another array called <code class="literal">pickedTiles</code>:</p><div class="informalexample"><pre class="programlisting">Var gameArray = [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7];
<span class="strong"><strong>var pickedTiles = [];</strong></span>
</pre></div><p>Then, you need to add a couple of lines to our <code class="literal">listener</code> variable:</p><div class="informalexample"><pre class="programlisting">  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan: function (touch, event) {
    <span class="strong"><strong>if(pickedTiles.length&lt;2){</strong></span>
      var target = event.getCurrentTarget();
      var location = target.convertToNodeSpace(touch.getLocation());
      var targetSize = target.getContentSize();
      var targetRectangle = cc.rect(0, 0, targetSize.width, targetSize.height);
      if (cc.rectContainsPoint(targetRectangle, location)) {
        <span class="strong"><strong>if(pickedTiles.indexOf(target)==-1){</strong></span>
          target.initWithFile("assets/tile_"+target.pictureValue+".png";
          <span class="strong"><strong>pickedTiles.push(target);</strong></span>
          <span class="strong"><strong>if(pickedTiles.length==2){</strong></span>
            <span class="strong"><strong>checkTiles();</strong></span>
          <span class="strong"><strong>}</strong></span>
        <span class="strong"><strong>}</strong></span>
      <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>}</strong></span>
  <span class="strong"><strong>}</strong></span>
})</pre></div><p>Once the <code class="literal">pickedTiles</code> array contains two tiles, which prevents the player from picking the same tile <a id="id77" class="indexterm"/>twice, then the <code class="literal">checkTiles</code> function is called.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>I am not explaining much of the code at this step because there's nothing related to Cocos2d-JS; it's just good old JavaScript logic.</p></div></div><div class="informalexample"><pre class="programlisting">function checkTiles(){
var listener = cc.EventListener.create({
  function checkTiles(){
    var pause = setTimeout(function(){
      if(pickedTiles[0].pictureValue!=pickedTiles[1].pictureValue){
        pickedTiles[0].initWithFile("assets/cover.png");
        pickedTiles[1].initWithFile("assets/cover.png");
      }
      else{
        gameLayer.removeChild(pickedTiles[0]);
        gameLayer.removeChild(pickedTiles[1]);
      }
      pickedTiles = [];
    },2000);
  }</pre></div><p>Basically, <code class="literal">checkTiles</code> waits two seconds, giving some time to the player to memorize the picked tiles, and then again covers tiles if they do not match by simply changing their image to a covered tile again, or removes them from the game with the <code class="literal">removeChild</code> method.</p><p>In both cases, the player will be allowed to pick new tiles by emptying a <code class="literal">pickedTiles</code> array.</p><p>Test the game <a id="id78" class="indexterm"/>and make some matches to see the tiles being removed from the game.</p><div class="mediaobject"><img src="graphics/0072OS_02_05.jpg" alt="Showing the tile picture"/></div><p>Congratulations! You created your first Cocos2d-JS working game. Now, let's add some finishing touches.</p></div></div>
<div class="section" title="Shuffling the tiles and adding the score"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Shuffling the tiles and adding the score</h1></div></div></div><p>You should <a id="id79" class="indexterm"/>have noticed the game isn't that hard, since <a id="id80" class="indexterm"/>you are just matching tiles that are one next to each other. The first tile matches the second tile, the third tile matches the fourth, and so on.</p><p>First, you need to shuffle the tiles, then you will add the score to the game. Players love to compete for high scores.</p><p>You start by adding two new variables <code class="literal">scoreText</code> and <code class="literal">moves</code>, which will handle the text showing the score and count the number of moves (picks) the player did:</p><div class="informalexample"><pre class="programlisting">Var gameArray = [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7];
<span class="strong"><strong>var</strong></span> pickedTiles = [];
<span class="strong"><strong>var scoreText;</strong></span>
<span class="strong"><strong>var moves=0;</strong></span>
</pre></div><p>Then, you need to shuffle <code class="literal">gameArray</code>. Shuffling arrays with a true randomization is beyond the scope of this book, so for this game, you are going to use a basic shuffle function you can find at <a class="ulink" href="http://jsfromhell.com/array/shuffle">http://jsfromhell.com/array/shuffle</a>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var shuffle = function(v){</strong></span>
<span class="strong"><strong>for(var j, x, i = v.length; i; j = parseInt(Math.random() * i),x = v[--i], v[i] = v[j], v[j] = x);</strong></span>
<span class="strong"><strong>return v;</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>Then <code class="literal">gameArray</code> <a id="id81" class="indexterm"/>is shuffled at the beginning of the game:</p><div class="informalexample"><pre class="programlisting">vargameScene = cc.Scene.extend({
  onEnter:function () {
    <span class="strong"><strong>gameArray = shuffle(gameArray);</strong></span>
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});</pre></div><p>To add the score <a id="id82" class="indexterm"/>text to the game, you need a label. Here is how you can create a text label called <code class="literal">scoreText</code>, which contains the text <code class="literal">Moves: 0</code> with a 32 pixel Arial font:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    var gradient = cc.LayerGradient.create(cc.color(0,0,0,255), cc.color(0x46,0x82,0xB4,255));
    this.addChild(gradient);
    <span class="strong"><strong>scoreText = cc.LabelTTF.create("Moves: 0","Arial","32",cc.TEXT_ALIGNMENT_CENTER);</strong></span>
    <span class="strong"><strong>this.addChild(scoreText);</strong></span>
    <span class="strong"><strong>scoreText.setPosition(90,50);</strong></span>
    for(i=0;i&lt;16;i++){
      var tile = new MemoryTile();
      tile.pictureValue = gameArray[i];
      this.addChild(tile,0);
      tile.setPosition(49+i%4*74,400-Math.floor(i/4)*74);
    }
  }
});</pre></div><p>Finally, once <a id="id83" class="indexterm"/>you check for tile matches, it's easy to increase the <a id="id84" class="indexterm"/>number of moves and update the <code class="literal">scoreText</code> text label with a <code class="literal">setString</code> method:</p><div class="informalexample"><pre class="programlisting">function checkTiles(){
  <span class="strong"><strong>moves++;</strong></span>
  <span class="strong"><strong>scoreText.setString("Moves: "+moves);</strong></span>
  var pause = setTimeout(function(){
    if(pickedTiles[0].pictureValue!=pickedTiles[1].pictureValue){
      pickedTiles[0].initWithFile("assets/cover.png");
      pickedTiles[1].initWithFile("assets/cover.png");
    }
    else{
      gameLayer.removeChild(pickedTiles[0]);
      gameLayer.removeChild(pickedTiles[1]);
    }
    pickedTiles = [];
  },2000);
}</pre></div><p>Test the script and you will be able to play a full game with a randomly generated board and the score text.</p><div class="mediaobject"><img src="graphics/0072OS_02_06.jpg" alt="Shuffling the tiles and adding the score"/></div><p>Now, you <a id="id85" class="indexterm"/>really do have a complete and polished <a id="id86" class="indexterm"/>game!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>By extending the Sprite class and adding a bit of interactivity, you created your own Concentration game. Now, you also know how to change Sprite images on the fly and deal with text labels.</p><p>Concentration is a great brain game. However, sometimes you want more action. To make it harder, you can try making your own 6 x 6 game rather than this easy 4 x 4 game. Head on to the next chapter and let's make things move! </p></div></body></html>