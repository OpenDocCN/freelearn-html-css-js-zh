- en: Making a Weather App in Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Chapter 7](db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml), *Making
    a Weather App in Elm*. In this chapter, we will make our Elm-powered weather app.
    The purpose of this app is to learn how to fetch information from JSON and use
    it in our app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of errors with `Result`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with optional values and nothingness using `Maybe`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding JSON strings using decoders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching remote data with the help of the HTTP package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a third-party API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Fetch information from the internet in JSON format
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have your Elm apps consume JSON data using decoders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how all the moving parts fit together to build a functioning app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, we will look at obtaining weather data from a third-party API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the weather data from a third-party API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for our weather app to even be possible, we will need to obtain weather
    data from somewhere. Luckily, there are plenty of weather-related APIs online,
    which makes this task a lot easier to accomplish.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a working app, we need to connect to a third-party data provider.
    In our case, the data provider we will use is Open Weather Map.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The information about the Open Weather Map's API is available at [https://openweathermap.org/api](https://openweathermap.org/api).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: To gain access to the API you need to obtain the APPID. The instructions on
    how to do that are available here, [http://openweathermap.org/appid](http://openweathermap.org/appid).
    Basically, all that is needed to obtain it is to create a new account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you have created your account, you will find your API key generated
    under the API keys tab. To access the data for a city, for example, Chicago, it''s
    enough to visit the following URL: `http://api.openweathermap.org/data/2.5/weather?q=chicago&APPID=abcdef1234567890`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the preceding URL is using the wrong APPID. Replace it with your
    own, and you should be good to go. Using the correct APPID in the preceding URL,
    your browser will show a JSON string like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just what we do with this string will be discussed later in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to build?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a very simple weather app, which will communicate with
    the outside world to fetch JSON-formatted weather data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Once we receive that weather data, we will then decode the JSON string into
    values that our app's model will be able to understand and work with, using decoders.
    Let's jump right in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Building our weather app
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by replacing the code in `Main.elm` with the bare-bones Elm code
    we have already been using in the previous chapters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s immediately improve our app by replacing `beginnerProgram` with `Html.Program`,
    since `beginnerProgram,` as explained in the previous chapter, has no means of
    working with side effects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's walk through the preceding code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We start off by describing the application model as a type alias called `Model`,
    and we set it to an empty record. Following the type alias, we introduce the `init`
    function, which holds the initial state of our app, and the initial command to
    run. With `Cmd.none`, we are basically saying to Elm runtime not to run any commands
    at this point. So, although we are not going to be requesting any commands to
    be run at this moment in our code, we cannot just omit them, we have to be explicit,
    and clearly state that we will not run any commands just yet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the change in the `init` function: the `init` function now takes the following
    two-tuple: `( Model, Cmd.none )`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `update` function, we are using a union type `Msg`, which can be
    only of `NoOp` value. Basically, whenever we want to assert that our app should
    not do anything with a message it receives, we can use `NoOp` as the value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function uses a `case of` expression. We pass two arguments to the
    `update` function: the `msg` and the `model`, and these arguments are used to
    update the `model` and return a command. Here, since we are receiving the `NoOp`
    message, the only thing that happens is: we just return the `model` as is. By
    using `Cmd.none` in the returned two-tuple, we are saying to the Elm runtime that
    it should not run any commands.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `subscriptions` function, all that we are doing is: we are saying to
    the Elm runtime that we do not want to subscribe to any events. Hence, we assign
    it the value of `Sub.none`. Finally, the `main` function gets assigned the `Html.program`
    where all of the above comes together.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll install the HTTP package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Installing the HTTP package
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the HTTP package, we need to point our console to the location of
    our `weather app` folder. Next, run the following command in the console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is what the console will return:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After confirming with `y`, the console will output the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Approving the plan by typing `y` will produce the following messages in the
    console:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s open the `elm-package.json` and verify that it looks as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we have successfully added the HTTP package to our project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for the HTTP package is available at [http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added all the necessary packages, we can continue building
    our app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Adding all the imports
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by adding all the imports that we need at the top of `Main.elm`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The linter will throw four identical warnings after you save your code with
    the preceding update. The only difference, in each of the warnings, is the module
    that is referenced. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is wonderful that the compiler encourages us to improve our code quality
    at the first possible opportunity, but for now, it is safe to ignore those warnings.
    We will soon add the code to our app that will resolve them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Conceptualizing the model
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will be changing up quite a lot of things in our app, at this point
    we can prevent several nagging errors by simply temporarily removing type annotations.
    To do that, simply remove type annotations from the following functions: `init`,
    `update`, `view`, `subscriptions`, and `main`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our updated model now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The building blocks of our model should be self-explanatory. Let''s then add
    the preceding code to `Main.elm`, and save the file. Our app compiles just fine,
    and everything works as it has. Let''s now update the `init` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What we did here is, we simply reflected the newly introduced changes to our
    model, in our `init` function. In the next section, we'll set up the `Msg` and
    the `update` functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Msg union type
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Msg` union type is pretty simple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are three possible messages that the `update` function can receive: `GetTemp`,
    `CityInput`, and `NewTemp`. The most peculiar of them is the third one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is some code there that we haven''t seen before.  The `NewTemp` value
    holds a `Result`.  That result can be an `Http.Error`, which means that something
    caused our HTTP request to fail. There can be a number of reasons: the URL does
    not exist, or the server did not respond, and so on. Another thing that can happen
    is: the request can succeed.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we'll get back the `String` as the result of making a successful
    HTTP request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Result and Maybe
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a good time to make a little digression and talk about `Result` and
    `Maybe` in some more detail. To deal with errors, Elm also has `Tasks`, but we
    will not discuss them at this time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Working with Result
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation for `Result` is available at: [http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result).
    We use `Result` whenever there are things that our code does that can potentially
    fail. Using `Result` allows us to deal better with errors in Elm. The `Result` definition
    says that it''s a union type that has two `type` constructors: `Ok` and `Err`. 
    Take a look at the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If an operation succeeds, the `Result` is `Ok`. Otherwise, the `Result` is `Err`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'To test drive `Result`, all that we need to do is run an operation that might
    fail. REPL is the perfect place for such a test. Thus, let''s point our browser
    to [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/) and run the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the preceding in the REPL, will return the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wonderful, we got back an `Ok` result from an operation that could have failed.
    Let''s do it again, for good measure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might think that the preceding would fail, but it is actually completely
    valid:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Great, we still got back an `Ok`.  This time, let''s use a string of letters,
    to make sure that the REPL can''t handle it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And indeed, the REPL doesn''t know how to deal with this input. However, instead
    of throwing an ugly exception, we get an elegant one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To drive the point home, in the preceding example, we ran an expression that
    could potentially fail, that is, we ran the  `Date.fromString` function. The `Date.fromString`
    function takes a parameter of type `String`, and returns a `Date`. In the preceding
    code snippet, we gave it the String with the value of `abc`, and it returned an
    `Err` as the `Result`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`Result` has its own module, and that is why the type definition reads `Result.Result`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at working with `Maybe`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Working with Maybe
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also a union type, `Maybe` is a way to deal with nothingness in Elm, or, put
    differently, with values that are optional, that is, which might, or might not
    exist. The official documentation, available at [http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe),
    gives the definition for the `Maybe` union type as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we discussed earlier in the book, using the letter  `a` in Elm is a convention,
    and it's a way to describe that the value used at that position can be anything.
    So the `a` in the preceding definition can be a `String`, an `Int`, or any other
    value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in Elm, `Maybe` can be only one of two things— `Just` anything, or `Nothing`.
    More specifically, `Maybe` can be either one of these:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`Just` a `String`, or `Just` an `Int`, or `Just` a `Float`..., or'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nothing`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now turn to Elm REPL at [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/)
    and see the `Maybe` type in practice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The REPL will return the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see, `Just 1` is a `Maybe number`. Let''s do another one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the preceding line will result in this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, let''s see a `Nothing` in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'REPL replies with the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since `Nothing` has no value, we are back to `Maybe a`. Elm guarantees require
    us to have an `a` here, even though `Nothing` is `Nothing`, and since it represents
    the absence of value it does not need a type for its value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'To destructure a `Maybe`, we can use the `case-of` expression. Let''s see an
    example of that using Ellie:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we are using a slightly altered version of the person
    example available at the official documentation for `Maybe`. The difference in
    the preceding code is that instead of an `Int`, we are using a `String` for the
    `age` entry in our record. That way, we can avoid making our code any more complex
    than it needs to be, and we still return a `String` from all the branches in our
    `case-of` expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will print out `42` upon compilation. Now, let''s change the app so
    that we are attempting to print Sue''s age. The only difference to be made is
    listed as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, upon compilation, the app will pattern-match the `Nothing` branch
    of the `case-of` expression in `main`, and that will result in the `"No age for
    this person"` message printed on the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Result and Maybe with Defaults
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Result` and `Maybe` are quite similar. If our operation succeeds, we get an
    `Ok a` with `Result`. When dealing with `Maybe`, we get `Just a` if a value is
    present.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'In case there was an error, for `Result` we get `Err error`. In case of no
    value in `Maybe`, we get `Nothing`. We have already looked at using `Result.withDefault`
    earlier in the book (in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml),
    *Preparing a Unit Conversion Website in Elm*). Let''s do a quick recap by running
    the following in Elm REPL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The REPL responds with the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s try using `Strings`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The REPL returns the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similar to `Result`, we can also use `withDefault` on `Maybe`. Run the following
    in the REPL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The REPL returns the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s do a couple more. First, let''s give it a default `String`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The REPL returns the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How about a default `Record`?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the preceding code in the REPL will produce the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next section, we will work on our `update` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Updating the update function
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `update` function will be a lot more complex. First, we need to cover all
    the preceding messages in our `update` function. We''ll do that by adding a `case-of`
    expression:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code snippet, we can see four possible cases for our `update`
    function. In case our `update` function receives the `GetTemp` message, it will
    return the two-tuple that has the `model` and the `getTemperature` value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If the `update` function receives the `NewTemp (Ok json)` message, that is,
    if we successfully receive a JSON string from a remote server, then we use a `let-in`
    expression to return the same `model`, updated with the `newTemperatureInfo`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The third pattern to match is the `NewTemp (Err _)`. This pattern will be matched
    in case we receive an error from the remote server, in which case we will just
    return the existing model - that is, `(model, Cmd.none)`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The last possible message that we can pattern-match for in the `update` function,
    is the `CityInput` message. If we get a `CityInput` message, we will take the
    `city` String that gets passed to it, and return the existing model, plus the
    new `city` String.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we ran our app now, the compiler would throw two errors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Cannot find variable `getTemperature`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot find variable `decodeTemperatureInfo`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, abstracting away complexity into separate variables is great to make
    it easier to reason about our app, but now we need to get into the actual implementation
    of `getTemperature` and `decodeTemperatureInfo`, in order to make our `update`
    function work. But before we can do that, we will need to look at decoders and
    encoders in greater detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Decoders and encoders
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parse data from JSON, Elm uses decoders. To do the opposite, Elm uses encoders.
    Using decoders and encoders, we can translate data from dynamically typed JSON,
    to statically typed Elm data structures, and vice versa.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s look at the `Json.Decode` package, available as part of the
    Elm language core. The official documentation for `Json.Decode` is available at:
    [http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode).
    The official documentation defines a decoder as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A value that knows how to decode JSON values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Decoding primitive values
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples of decoding primitive values, with the help of
    Elm REPL. To begin, let''s decode a simple `Int`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The REPL returns the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, we get back a `Result`, which is a sign of an action that can potentially
    fail. Let''s see how it fails, by providing a `Bool` to the preceding expression, instead
    of an `Int`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running the preceding code results in the REPL returning the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, let''s decode a JSON `float` into an Elm `Float`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The REPL returns the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How about decoding a JSON `string` into an Elm `String`?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This time, the REPL responds with the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Why is that error occuring? Because we need to provide escaped quotes as well,
    so as to make it work:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now the REPL is not complaining:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, let''s look at decoding a JSON boolean into an Elm `Bool`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The REPL returns the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s examine each of the decoders'' signatures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see in the preceding code snippet, `int` is a decoder for `Int`, `float`
    is a decoder for `Float`, `string` is a decoder for `String`, and `bool` is a
    decoder for `Bool`. Now that we understand how primitives are decoded from JSON
    into Elm, let's look at decoding a more complex JSON string, namely, the one that
    we got back from the API at the beginning of this chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a JSON string returned from the API
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s look at the JSON string that we got back from the API:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Obviously, we have formatted the JSON string so as to make it easier to read.
    The first thing to note is; we do not have to decode all of the preceding code.
    We can choose to decode only as much data as we need. So let's assume that the
    only piece of data that we are interested in is the second-to-last key-value pair,
    namely: `''name'':''Chicago''`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we decode it out of the preceding chunk of JSON? We''ll make a small
    Ellie app to see how this can be done:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding little app successfully decodes the JSON string provided. As
    we can see, we are decoding only the `name` key from our JSON object, whose value,
    based on the JSON object provided previously, is `Chicago`. The result of compiling
    the app in the Ellie editor is displayed on the screen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s see how we can improve on the preceding app. This time, we want to return
    not only the `name` key from our JSON object, but also the `id` key:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we compiled the app now, we''d get a slightly different result from what
    we had last time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'There are slight changes in the preceding app, which make it possible to extract
    two values, rather than just one, which we had in the previous version of our
    little JSON-decoding app. Let''s look at the changes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `WeatherData` type alias, we added an `id` of type `Int` to our `Record`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the decoders, we are using the `map2` function instead of the `map` function,
    and we are adding another JSON field, with the key of `id`, and the expected value
    of the JSON integer. Analog to what we have seen, in case we wanted to map over
    another value from our JSON object, we would need to use the `map3` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Decoding nested objects
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we want to get the country information from the returned JSON.
    The change that we need to make to our decoder is simple: instead of `field`,
    we will use `at`. While `field` uses a string, `at` uses a list of strings, which
    allows us to go into the structure of a nested object. Let''s update our Ellie
    app''s `weatherDataDecoder` so that it looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s also update the `WeatherData` type alias:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that in the preceding code snippet, we are keeping our flat `Record` structure,
    and it does not reflect the JSON object that we get the data from. That is perfectly
    fine. Upon compilation, the app will print the following result to the screen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we understand how decoders work, and after a bit of practice with decoders,
    it should be a lot easier to understand the code that we will see in the next
    section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Adding getTemperature and decodeTemperatureInfo
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `getTemperature` is a simple `let-in` expression, which will send a new
    request using `Http.send` and `Http.getString`, so as to obtain the weather data
    from a custom URL. The string of the custom URL to fetch the data from, depends
    on the `city` variable, that is, the value of the user input we get from the text
    input field of our app:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `decodeTemperatureInfo` is also a `let-in` expression, which, although
    possibly a bit scary-looking at first glance, is actually just a number of repetitions
    in trying to decode JSON data:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Basically, what''s happening in the preceding code is—we are decoding the JSON
    string we received from the remote server, step by step. At this point, saving
    and running our app, we would see exactly the same window as before: Everything
    will go here, this time using Html.program.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: That is a good sign. It means our app compiles successfully. It also means that
    there is more work to be done in the `view` and `main` functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Updating the view
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `view` function is there to give us the visual representation of our model.
    For our app to work, the `view` function needs to have an input field, the submit
    button, and several values to be populated upon contacting the remote server and
    decoding the JSON string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let's look at how the preceding code works. We start off with the wrapping `div`.
    Next, we have the `input` function, which will have the placeholder word `City`
    in the text input field. We also have a message that this `input` function will
    emit, and the message is of `CityInput` type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的代码是如何工作的。我们首先使用包裹`div`。接下来，我们有`input`函数，它将在文本输入字段中显示占位符单词`City`。我们还有一个消息，即这个`input`函数将发出一个`CityInput`类型的消息。
- en: 'Next, we have the `br` function, and then the `button` function, which will
    emit the `GetTemp` message `onClick`. The next significant function is the `div`
    function, which will have the string of `''''Name: ''''` plus the value of `model.temperatureInfo.name`.
    Similarly, we follow it up with other `div` functions that concatenate strings
    together based on the values contained inside the current `model`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们有`br`函数，然后是`button`函数，它将在`onClick`时发出`GetTemp`消息。下一个重要的函数是`div`函数，它将包含字符串`''''Name:
    ''''`和`model.temperatureInfo.name`的值。同样，我们接着使用其他`div`函数，这些函数根据当前`model`中包含的值拼接字符串。'
- en: Save everything and run your app. The result will be a fully working weather
    app that fetches a JSON string from a remote server and properly displays the
    result. To make the app fetch the data, it's enough to type a major city name
    into the input field, and click the button.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有内容并运行你的应用。结果将是一个完全工作的天气应用，它从远程服务器获取JSON字符串并正确显示结果。要使应用获取数据，只需在输入字段中输入一个主要城市名称，然后点击按钮。
- en: 'Before wrapping up this section, let''s look at the complete weather app code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们看看完整的天气应用代码：
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a lot of new concepts, and reinforced some
    that we have learned about in the previous chapters. We have looked at using `Result`
    and `Maybe` to deal with operations that might fail and to deal with possibly
    missing data. We looked at using decoders and mapping over them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了很多新概念，并加强了一些我们在前几章中学到的概念。我们探讨了使用`Result`和`Maybe`来处理可能失败的操作以及处理可能缺失的数据。我们探讨了使用解码器和映射。
- en: We also looked at using the `Http` package to get remote JSON data. Now that
    we have set up the basics of our weather app, we will discuss ways of improving
    it in the next chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了使用`Http`包获取远程JSON数据。现在我们已经设置了天气应用的基础，我们将在下一章讨论改进它的方法。
