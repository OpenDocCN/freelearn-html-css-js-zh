- en: Making a Weather App in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Chapter 7](db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml), *Making
    a Weather App in Elm*. In this chapter, we will make our Elm-powered weather app.
    The purpose of this app is to learn how to fetch information from JSON and use
    it in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of errors with `Result`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with optional values and nothingness using `Maybe`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding JSON strings using decoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching remote data with the help of the HTTP package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a third-party API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch information from the internet in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have your Elm apps consume JSON data using decoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how all the moving parts fit together to build a functioning app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, we will look at obtaining weather data from a third-party API.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the weather data from a third-party API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for our weather app to even be possible, we will need to obtain weather
    data from somewhere. Luckily, there are plenty of weather-related APIs online,
    which makes this task a lot easier to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a working app, we need to connect to a third-party data provider.
    In our case, the data provider we will use is Open Weather Map.
  prefs: []
  type: TYPE_NORMAL
- en: The information about the Open Weather Map's API is available at [https://openweathermap.org/api](https://openweathermap.org/api).
  prefs: []
  type: TYPE_NORMAL
- en: To gain access to the API you need to obtain the APPID. The instructions on
    how to do that are available here, [http://openweathermap.org/appid](http://openweathermap.org/appid).
    Basically, all that is needed to obtain it is to create a new account.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you have created your account, you will find your API key generated
    under the API keys tab. To access the data for a city, for example, Chicago, it''s
    enough to visit the following URL: `http://api.openweathermap.org/data/2.5/weather?q=chicago&APPID=abcdef1234567890`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the preceding URL is using the wrong APPID. Replace it with your
    own, and you should be good to go. Using the correct APPID in the preceding URL,
    your browser will show a JSON string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just what we do with this string will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a very simple weather app, which will communicate with
    the outside world to fetch JSON-formatted weather data.
  prefs: []
  type: TYPE_NORMAL
- en: Once we receive that weather data, we will then decode the JSON string into
    values that our app's model will be able to understand and work with, using decoders.
    Let's jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Building our weather app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by replacing the code in `Main.elm` with the bare-bones Elm code
    we have already been using in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s immediately improve our app by replacing `beginnerProgram` with `Html.Program`,
    since `beginnerProgram,` as explained in the previous chapter, has no means of
    working with side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by describing the application model as a type alias called `Model`,
    and we set it to an empty record. Following the type alias, we introduce the `init`
    function, which holds the initial state of our app, and the initial command to
    run. With `Cmd.none`, we are basically saying to Elm runtime not to run any commands
    at this point. So, although we are not going to be requesting any commands to
    be run at this moment in our code, we cannot just omit them, we have to be explicit,
    and clearly state that we will not run any commands just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the change in the `init` function: the `init` function now takes the following
    two-tuple: `( Model, Cmd.none )`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `update` function, we are using a union type `Msg`, which can be
    only of `NoOp` value. Basically, whenever we want to assert that our app should
    not do anything with a message it receives, we can use `NoOp` as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function uses a `case of` expression. We pass two arguments to the
    `update` function: the `msg` and the `model`, and these arguments are used to
    update the `model` and return a command. Here, since we are receiving the `NoOp`
    message, the only thing that happens is: we just return the `model` as is. By
    using `Cmd.none` in the returned two-tuple, we are saying to the Elm runtime that
    it should not run any commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `subscriptions` function, all that we are doing is: we are saying to
    the Elm runtime that we do not want to subscribe to any events. Hence, we assign
    it the value of `Sub.none`. Finally, the `main` function gets assigned the `Html.program`
    where all of the above comes together.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll install the HTTP package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the HTTP package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the HTTP package, we need to point our console to the location of
    our `weather app` folder. Next, run the following command in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the console will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After confirming with `y`, the console will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Approving the plan by typing `y` will produce the following messages in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s open the `elm-package.json` and verify that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have successfully added the HTTP package to our project.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for the HTTP package is available at [http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added all the necessary packages, we can continue building
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding all the imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by adding all the imports that we need at the top of `Main.elm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The linter will throw four identical warnings after you save your code with
    the preceding update. The only difference, in each of the warnings, is the module
    that is referenced. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is wonderful that the compiler encourages us to improve our code quality
    at the first possible opportunity, but for now, it is safe to ignore those warnings.
    We will soon add the code to our app that will resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptualizing the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will be changing up quite a lot of things in our app, at this point
    we can prevent several nagging errors by simply temporarily removing type annotations.
    To do that, simply remove type annotations from the following functions: `init`,
    `update`, `view`, `subscriptions`, and `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our updated model now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The building blocks of our model should be self-explanatory. Let''s then add
    the preceding code to `Main.elm`, and save the file. Our app compiles just fine,
    and everything works as it has. Let''s now update the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What we did here is, we simply reflected the newly introduced changes to our
    model, in our `init` function. In the next section, we'll set up the `Msg` and
    the `update` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Msg union type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Msg` union type is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three possible messages that the `update` function can receive: `GetTemp`,
    `CityInput`, and `NewTemp`. The most peculiar of them is the third one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is some code there that we haven''t seen before.  The `NewTemp` value
    holds a `Result`.  That result can be an `Http.Error`, which means that something
    caused our HTTP request to fail. There can be a number of reasons: the URL does
    not exist, or the server did not respond, and so on. Another thing that can happen
    is: the request can succeed.'
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we'll get back the `String` as the result of making a successful
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Result and Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a good time to make a little digression and talk about `Result` and
    `Maybe` in some more detail. To deal with errors, Elm also has `Tasks`, but we
    will not discuss them at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation for `Result` is available at: [http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result).
    We use `Result` whenever there are things that our code does that can potentially
    fail. Using `Result` allows us to deal better with errors in Elm. The `Result` definition
    says that it''s a union type that has two `type` constructors: `Ok` and `Err`. 
    Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If an operation succeeds, the `Result` is `Ok`. Otherwise, the `Result` is `Err`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test drive `Result`, all that we need to do is run an operation that might
    fail. REPL is the perfect place for such a test. Thus, let''s point our browser
    to [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/) and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding in the REPL, will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful, we got back an `Ok` result from an operation that could have failed.
    Let''s do it again, for good measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think that the preceding would fail, but it is actually completely
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we still got back an `Ok`.  This time, let''s use a string of letters,
    to make sure that the REPL can''t handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed, the REPL doesn''t know how to deal with this input. However, instead
    of throwing an ugly exception, we get an elegant one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To drive the point home, in the preceding example, we ran an expression that
    could potentially fail, that is, we ran the  `Date.fromString` function. The `Date.fromString`
    function takes a parameter of type `String`, and returns a `Date`. In the preceding
    code snippet, we gave it the String with the value of `abc`, and it returned an
    `Err` as the `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Result` has its own module, and that is why the type definition reads `Result.Result`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at working with `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also a union type, `Maybe` is a way to deal with nothingness in Elm, or, put
    differently, with values that are optional, that is, which might, or might not
    exist. The official documentation, available at [http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe),
    gives the definition for the `Maybe` union type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier in the book, using the letter  `a` in Elm is a convention,
    and it's a way to describe that the value used at that position can be anything.
    So the `a` in the preceding definition can be a `String`, an `Int`, or any other
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in Elm, `Maybe` can be only one of two things— `Just` anything, or `Nothing`.
    More specifically, `Maybe` can be either one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Just` a `String`, or `Just` an `Int`, or `Just` a `Float`..., or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nothing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now turn to Elm REPL at [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/)
    and see the `Maybe` type in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `Just 1` is a `Maybe number`. Let''s do another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding line will result in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see a `Nothing` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'REPL replies with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since `Nothing` has no value, we are back to `Maybe a`. Elm guarantees require
    us to have an `a` here, even though `Nothing` is `Nothing`, and since it represents
    the absence of value it does not need a type for its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To destructure a `Maybe`, we can use the `case-of` expression. Let''s see an
    example of that using Ellie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are using a slightly altered version of the person
    example available at the official documentation for `Maybe`. The difference in
    the preceding code is that instead of an `Int`, we are using a `String` for the
    `age` entry in our record. That way, we can avoid making our code any more complex
    than it needs to be, and we still return a `String` from all the branches in our
    `case-of` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will print out `42` upon compilation. Now, let''s change the app so
    that we are attempting to print Sue''s age. The only difference to be made is
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This time, upon compilation, the app will pattern-match the `Nothing` branch
    of the `case-of` expression in `main`, and that will result in the `"No age for
    this person"` message printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Result and Maybe with Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Result` and `Maybe` are quite similar. If our operation succeeds, we get an
    `Ok a` with `Result`. When dealing with `Maybe`, we get `Just a` if a value is
    present.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case there was an error, for `Result` we get `Err error`. In case of no
    value in `Maybe`, we get `Nothing`. We have already looked at using `Result.withDefault`
    earlier in the book (in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml),
    *Preparing a Unit Conversion Website in Elm*). Let''s do a quick recap by running
    the following in Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try using `Strings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `Result`, we can also use `withDefault` on `Maybe`. Run the following
    in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a couple more. First, let''s give it a default `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How about a default `Record`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code in the REPL will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will work on our `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the update function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `update` function will be a lot more complex. First, we need to cover all
    the preceding messages in our `update` function. We''ll do that by adding a `case-of`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we can see four possible cases for our `update`
    function. In case our `update` function receives the `GetTemp` message, it will
    return the two-tuple that has the `model` and the `getTemperature` value.
  prefs: []
  type: TYPE_NORMAL
- en: If the `update` function receives the `NewTemp (Ok json)` message, that is,
    if we successfully receive a JSON string from a remote server, then we use a `let-in`
    expression to return the same `model`, updated with the `newTemperatureInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: The third pattern to match is the `NewTemp (Err _)`. This pattern will be matched
    in case we receive an error from the remote server, in which case we will just
    return the existing model - that is, `(model, Cmd.none)`.
  prefs: []
  type: TYPE_NORMAL
- en: The last possible message that we can pattern-match for in the `update` function,
    is the `CityInput` message. If we get a `CityInput` message, we will take the
    `city` String that gets passed to it, and return the existing model, plus the
    new `city` String.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we ran our app now, the compiler would throw two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Cannot find variable `getTemperature`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot find variable `decodeTemperatureInfo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, abstracting away complexity into separate variables is great to make
    it easier to reason about our app, but now we need to get into the actual implementation
    of `getTemperature` and `decodeTemperatureInfo`, in order to make our `update`
    function work. But before we can do that, we will need to look at decoders and
    encoders in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Decoders and encoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parse data from JSON, Elm uses decoders. To do the opposite, Elm uses encoders.
    Using decoders and encoders, we can translate data from dynamically typed JSON,
    to statically typed Elm data structures, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s look at the `Json.Decode` package, available as part of the
    Elm language core. The official documentation for `Json.Decode` is available at:
    [http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode).
    The official documentation defines a decoder as:'
  prefs: []
  type: TYPE_NORMAL
- en: A value that knows how to decode JSON values.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding primitive values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples of decoding primitive values, with the help of
    Elm REPL. To begin, let''s decode a simple `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we get back a `Result`, which is a sign of an action that can potentially
    fail. Let''s see how it fails, by providing a `Bool` to the preceding expression, instead
    of an `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code results in the REPL returning the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s decode a JSON `float` into an Elm `Float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How about decoding a JSON `string` into an Elm `String`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the REPL responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that error occuring? Because we need to provide escaped quotes as well,
    so as to make it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the REPL is not complaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at decoding a JSON boolean into an Elm `Bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine each of the decoders'' signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, `int` is a decoder for `Int`, `float`
    is a decoder for `Float`, `string` is a decoder for `String`, and `bool` is a
    decoder for `Bool`. Now that we understand how primitives are decoded from JSON
    into Elm, let's look at decoding a more complex JSON string, namely, the one that
    we got back from the API at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a JSON string returned from the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s look at the JSON string that we got back from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we have formatted the JSON string so as to make it easier to read.
    The first thing to note is; we do not have to decode all of the preceding code.
    We can choose to decode only as much data as we need. So let's assume that the
    only piece of data that we are interested in is the second-to-last key-value pair,
    namely: `''name'':''Chicago''`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we decode it out of the preceding chunk of JSON? We''ll make a small
    Ellie app to see how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding little app successfully decodes the JSON string provided. As
    we can see, we are decoding only the `name` key from our JSON object, whose value,
    based on the JSON object provided previously, is `Chicago`. The result of compiling
    the app in the Ellie editor is displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we can improve on the preceding app. This time, we want to return
    not only the `name` key from our JSON object, but also the `id` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compiled the app now, we''d get a slightly different result from what
    we had last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'There are slight changes in the preceding app, which make it possible to extract
    two values, rather than just one, which we had in the previous version of our
    little JSON-decoding app. Let''s look at the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `WeatherData` type alias, we added an `id` of type `Int` to our `Record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the decoders, we are using the `map2` function instead of the `map` function,
    and we are adding another JSON field, with the key of `id`, and the expected value
    of the JSON integer. Analog to what we have seen, in case we wanted to map over
    another value from our JSON object, we would need to use the `map3` function.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding nested objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we want to get the country information from the returned JSON.
    The change that we need to make to our decoder is simple: instead of `field`,
    we will use `at`. While `field` uses a string, `at` uses a list of strings, which
    allows us to go into the structure of a nested object. Let''s update our Ellie
    app''s `weatherDataDecoder` so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also update the `WeatherData` type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code snippet, we are keeping our flat `Record` structure,
    and it does not reflect the JSON object that we get the data from. That is perfectly
    fine. Upon compilation, the app will print the following result to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how decoders work, and after a bit of practice with decoders,
    it should be a lot easier to understand the code that we will see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding getTemperature and decodeTemperatureInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `getTemperature` is a simple `let-in` expression, which will send a new
    request using `Http.send` and `Http.getString`, so as to obtain the weather data
    from a custom URL. The string of the custom URL to fetch the data from, depends
    on the `city` variable, that is, the value of the user input we get from the text
    input field of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decodeTemperatureInfo` is also a `let-in` expression, which, although
    possibly a bit scary-looking at first glance, is actually just a number of repetitions
    in trying to decode JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, what''s happening in the preceding code is—we are decoding the JSON
    string we received from the remote server, step by step. At this point, saving
    and running our app, we would see exactly the same window as before: Everything
    will go here, this time using Html.program.'
  prefs: []
  type: TYPE_NORMAL
- en: That is a good sign. It means our app compiles successfully. It also means that
    there is more work to be done in the `view` and `main` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `view` function is there to give us the visual representation of our model.
    For our app to work, the `view` function needs to have an input field, the submit
    button, and several values to be populated upon contacting the remote server and
    decoding the JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at how the preceding code works. We start off with the wrapping `div`.
    Next, we have the `input` function, which will have the placeholder word `City`
    in the text input field. We also have a message that this `input` function will
    emit, and the message is of `CityInput` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `br` function, and then the `button` function, which will
    emit the `GetTemp` message `onClick`. The next significant function is the `div`
    function, which will have the string of `''''Name: ''''` plus the value of `model.temperatureInfo.name`.
    Similarly, we follow it up with other `div` functions that concatenate strings
    together based on the values contained inside the current `model`.'
  prefs: []
  type: TYPE_NORMAL
- en: Save everything and run your app. The result will be a fully working weather
    app that fetches a JSON string from a remote server and properly displays the
    result. To make the app fetch the data, it's enough to type a major city name
    into the input field, and click the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before wrapping up this section, let''s look at the complete weather app code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a lot of new concepts, and reinforced some
    that we have learned about in the previous chapters. We have looked at using `Result`
    and `Maybe` to deal with operations that might fail and to deal with possibly
    missing data. We looked at using decoders and mapping over them.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at using the `Http` package to get remote JSON data. Now that
    we have set up the basics of our weather app, we will discuss ways of improving
    it in the next chapter.
  prefs: []
  type: TYPE_NORMAL
