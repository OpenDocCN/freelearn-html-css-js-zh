<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor116"/>9</h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Hooks and Error Handling</h1>
<p>While it can be incredibly useful to make API requests from any page, imagine the nuisance of attempting to authenticate a user for an external API on <em class="italic">every</em> page. It may be possible to create a custom helper that adds specific headers or cookies to every single request to assist with this. Fortunately for us, SvelteKit provides methods to manipulate Request and Response objects across the entirety of a framework. It does so with what are called <strong class="bold">hooks</strong>. These<a id="_idIndexMarker192"/> hooks can be incredibly powerful to manage data that flows in and out of our application. They can also be helpful for managing errors. Since our previous encounters with error handling have been so brief, we’ll examine error handling a little closer after covering hooks.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using Hooks</li>
<li>Error Handling</li>
</ul>
<p>As a practical example, we’ll build a simple interface allowing us to <em class="italic">star</em> the official SvelteKit repository on GitHub. You’ll have to authenticate your personal account, but if you don’t have an account on GitHub, fear not, as the concepts will be easy enough to follow along with. By the end of the exercise, we’ll have covered the hooks available to use within SvelteKit, as well as how they can be leveraged to assist in managing errors.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter09">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter09</a>.</p>
<p>An account on GitHub is necessary to build the example: <a href="https://github.com/signup">https://github.com/signup</a>.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Using Hooks</h1>
<p>Unlike other<a id="_idIndexMarker193"/> JS frameworks that shall not be named, SvelteKit keeps the list of hooks to remember short and simple. At the time of writing, there are only two types of hooks – <code>+page.server.js</code> runs only on the server and <code>+page.js</code> runs on either the server or the client. Both server and shared hooks are placed in the <code>src/</code> directory, either in <code>src/hooks.server.js</code> or <code>src/hooks.client.js</code>, depending on which environment we intend to run the hook on. We’ll break this section down into the following subsections:</p>
<ul>
<li>Server hooks</li>
<li>Shared hooks</li>
</ul>
<p>By the end of this section, you’ll be able to modify all incoming and outgoing requests to your SvelteKit applications.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Server hooks</h2>
<p>The hooks <a id="_idIndexMarker194"/>that can only be run on the server are <code>handleFetch()</code> and <code>handle()</code>. As we would expect, <code>handleFetch()</code> has the ability to <a id="_idIndexMarker195"/>manipulate requests made by SvelteKit’s included <code>fetch()</code> method, which can be called within <code>load()</code> or through actions. The other hook, <code>handle()</code>; can manipulate data as SvelteKit’s router receives requests. One way to think of this is that <code>handleFetch()</code> manipulates the data <em class="italic">leaving</em> an app and <code>handle()</code> manipulates data <em class="italic">coming into</em> it. As server hooks, both can be added to <code>src/hooks.server.js</code>.</p>
<p>To begin this chapter’s example to demonstrate how useful hooks can be, let’s set up a few things. Firstly, we’ll need a way to authenticate our personal account with GitHub. The manner in which we will achieve this is by<a id="_idIndexMarker196"/> sending a <strong class="bold">personal access token</strong> to the appropriate GitHub API endpoints. Once generated, this token can be added to the HTTP request headers. It’s very important to treat tokens just as we treat passwords, so we’ll import this token securely through environment variables, which will be discussed further in a later chapter.</p>
<p>To generate your token, visit <a href="https://github.com">https://github.com</a> and sign in. You can then navigate to your profile settings by clicking your profile image in the top-right corner and selecting <code>SvelteKit star repo</code>, an expiration date, and the full <em class="italic">repo</em> scope. Once done, click <strong class="bold">Generate Token</strong> and copy the value provided.</p>
<p>We can <a id="_idIndexMarker197"/>then open our SvelteKit project and, in the root folder <a id="_idIndexMarker198"/>of the project, create a <code>.env</code> file. In this file, we’ll add our token, like so:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.env</p>
<pre class="source-code">
GITHUB=YOUR_GITHUB_TOKEN_HERE</pre>
<p>You can then save and close the file. We’ll go into more details on how how to manage secrets in a later chapter, but for now, just know that we’ve given our token a name using which we can import it into our code.</p>
<p>Next, let’s create a new route and add it to <code>Nav.svelte</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Nav.svelte</p>
<pre class="source-code">
&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;
    ...
    &lt;li&gt;&lt;a href='/github'&gt;GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
<p>Again, this is a simple addition where we add markup for a link to our ever-growing list of links. Once we have added the markup for our new route to the navigation, we’ll create the appropriate <code>+page.svelte</code> file to render the route. This page will consist of a simple form, with buttons allowing us to <em class="italic">star</em> and <em class="italic">unstar</em> the SvelteKit repository on GitHub, as well as some text showing just how many stars the repository currently has:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/github/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { enhance } from '$app/forms';
  import { invalidate } from '$app/navigation';
  export let data;
  export let form;
  const reload = () =&gt; {
    invalidate('https://api.github.com/repos/');
  };
&lt;/script&gt;
{#if form &amp;&amp; form.message }
  {form.status}
  {form.message}
{/if}
&lt;p&gt;
  Stargazers on the official SvelteKit repo: {data.repo.stargazers_count}
&lt;/p&gt;
&lt;form method='POST' use:enhance&gt;
  &lt;button formaction='?/star' on:click={reload}&gt;Star&lt;/button&gt;
  &lt;button formaction='?/unstar' on:click={reload}&gt;Unstar&lt;/button&gt;
&lt;/form&gt;</pre>
<p>There is <a id="_idIndexMarker199"/>quite<a id="_idIndexMarker200"/> a lot going on here, but it’s nothing we haven’t seen yet. Starting at the end of the file, we can see that this page contains a <code>&lt;form&gt;</code> element consisting of two buttons. One button calls to the <code>/github?/star</code> action and the other to the <code>/github?/unstar</code> action. The form uses the <code>enhance</code> module, meaning requests are made in the background and do not trigger a page reload. Each button inside the form calls the function expression assigned to the constant <code>reload</code>. That anonymous function utilizes the <code>invalidate</code> module, which then forces any <code>load()</code> functions with <code>fetch()</code> methods calling the specified URL to be rerun. This is helpful, as the paragraph tag showing how many stars the repository has will then be updated <a id="_idIndexMarker201"/>accordingly. The final portion of code to <a id="_idIndexMarker202"/>make note of is the Svelte <code>{#if}</code> directive, which will alert us to the status of the request.</p>
<p>Once we have saved <code>+page.svelte</code>, we’ll need to move on to our <code>+page.server.js</code>, as it will contain the bulk of our logic. Importantly, it won’t contain any of the code related to authentication, as all of that will reside in the hook:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/github/+page.server.js</p>
<pre class="source-code">
const star_url = 'https://api.github.com/user/starred/sveltejs/kit';
export function load({ fetch }) {
  const repo = fetch( 'https://api.github.com/repos/sveltejs/kit' )
    .then( response =&gt; response.json() );
  return { repo };
}
export const actions = {
  star: async({ fetch }) =&gt; {
    const response = fetch(star_url, {
      method: 'PUT',
      headers: {
        'Content-Length': '0',
      }
    })
    .then(response =&gt; {
      const status = response.status;
      return {
        status: status,
        message: (status === 204 ? 'Success!' : 'Error')
      }
    });
    return response;
  },
  unstar: async({ fetch }) =&gt; {
    const response = fetch(star_url, {
      method: 'DELETE'
    })
    .then(response =&gt; {
      const status = response.status;
      return {
        status: status,
        message: (status === 204 ? 'Success!' : 'Error')
      }
    });
    return response;
  },
}</pre>
<p>There is a<a id="_idIndexMarker203"/> lot <a id="_idIndexMarker204"/>going on here, but again, it’s nothing we haven’t seen before. The very first line declares a constant <code>star_url</code> that can be referenced in our <code>fetch()</code> requests later on. This is the endpoint we will reach out to alert GitHub that we want to <em class="italic">star</em> or <em class="italic">unstar</em> the repository. The very next chunk of code creates a familiar <code>load()</code> function. This endpoint does not actually require authentication and will return general information about the specified repository.</p>
<p>From there, we<a id="_idIndexMarker205"/> can examine the two actions we’ve created – <em class="italic">star</em> and <em class="italic">unstar</em>. Both of these destructure the <code>fetch()</code> method bundled with SvelteKit. Both then use <code>fetch()</code> to make a request to the <code>star_url</code> endpoint but differ in the type of HTTP method they utilize, as per the GitHub API specifications. We’ve also added an extra header to the <em class="italic">star</em> request, as the official GitHub API documentation dictates that <code>Content-Body</code> should be set to <code>0</code> for this particular request. Both actions then return an object consisting of the request status and a message alerting us as to whether the request went through successfully, or whether an error was received.</p>
<p>At this<a id="_idIndexMarker207"/> point, we could navigate to <code>http://localhost/github</code> in our browser and view the number of stars on the official SvelteKit repository. However, attempting to star it will result in an error, as we won’t have the appropriate permissions with the GitHub API. To authenticate, we’ll need to provide our access token in the headers of our network requests. While we could do this in the <code>+page.server.js</code> file inside each of the actions, it would quickly become a hassle if we decided to build more routes that also required authentication with GitHub. For instance, what if we wanted to build functionality allowing us to read and react to comments on issues? Instead, we can use <code>handleFetch()</code> to catch all outgoing <code>fetch()</code> requests before they leave our application and authenticate in a single location. To do so, we’ll need to create <code>src/hooks.server.js</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks.server.js</p>
<pre class="source-code">
import { GITHUB } from '$env/static/private';
export async function handleFetch( { request, fetch  } ) {
  if (request.url.startsWith('https://api.github.com/')) {
    request.headers.set('Accept', 'application/vnd.github+json');
    request.headers.set('Authorization', 'Bearer ' + GITHUB);
    request.headers.set('X-GitHub-Api-Version', '2022-11-28');
  }
  return fetch(request);
}</pre>
<p>We begin<a id="_idIndexMarker208"/> by importing the personal access token we created earlier. Again, we’ll <a id="_idIndexMarker209"/>examine how this works in a later chapter, so for now, just acknowledge that we’ve imported the token saved to <code>.env</code>. We then create the function definition for <code>handleFetch()</code>. Fetch is an asynchronous API, so we need to specify that this function will also be <code>async</code>. We’ve then destructured the <code>RequestEvent</code> object to extract <code>request</code> and <code>fetch</code>. Within the hook, we check to see whether the requested URL is <a href="https://api.github.com/">https://api.github.com/</a>. If it is, we’ll then set the necessary <code>Accept</code>, <code>Authorization</code>, and <code>X-GitHub-Api-Version</code> headers. While <code>Accept</code> and <code>X-GitHub-Api-Version</code> are simple predetermined strings, the <code>Authorization</code> header value is the concatenated string <em class="italic">bearer</em>, as well as the imported personal access token.</p>
<p>We can now open <code>http://localhost/github</code> in our browser and click the <em class="italic">star</em> button. Because we’ve used <code>invalidate()</code> on the GitHub API URL, we should then observe the count increasing by one. The developers of SvelteKit have certainly earned our star, but if you’re uncomfortable with this simple act of charity, try clicking the <em class="italic">unstar</em> button and observing the change again.</p>
<p>It’s important to note that <code>handleFetch()</code> will only hook into the <code>fetch()</code> function provided by SvelteKit and not a standard <code>fetch()</code>. This can be observed by removing the destructured <code>fetch</code> parameter from the <em class="italic">star</em> and <em class="italic">unstar</em> actions in <code>src/routes/(app)/github/+page.server.js</code>. Then, attempting to star the repository will return an <em class="italic">unauthorized</em> error from the GitHub API, as the <code>handleFetch()</code> hook is not called unless we use the <code>fetch()</code> method provided with SvelteKit. This can also be observed by removing the destructured <code>fetch</code> from the <code>load()</code> function in <code>+page.server.js</code>. Provided you have not exceeded GitHub’s rate limits, the standard <code>fetch()</code> function will continue providing data because the endpoint called to does not require authentication. Because of this, it is strongly encouraged to use SvelteKit’s <code>fetch()</code> whenever possible.</p>
<p>As we can see, being able to manipulate requests leaving our application is quite powerful, but what about the requests coming into our platform? For that, we need to leverage <code>handle()</code>. For this example, we’ll demonstrate it by adding the <code>handle()</code> hook of <code>src/hooks.server.js</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks.server.js</p>
<pre class="source-code">
import { GITHUB } from '$env/static/private';
export async function handleFetch( { request, fetch  } ) {
  if (request.url.startsWith('https://api.github.com/')) {
    request.headers.set('Accept', 'application/vnd.github+json');
    request.headers.set('Authorization', 'Bearer ' + GITHUB);
    request.headers.set('X-GitHub-Api-Version', '2022-11-28');
  }
  return fetch(request);
}
export async function handle({ event, resolve }) {
  event.setHeaders({'X-NOT-FROM-GITHUB': 'our value'});
  const response = await resolve(event);
  response.headers.set('X-ANOTHER-HEADER', 'something else');
  return response;
}</pre>
<p>In this <a id="_idIndexMarker210"/>version, we’ve added the <code>handle()</code> function definition to the end of the file. This function accepts a <code>RequestEvent</code> object as well as a <code>resolve()</code> function. In <a id="_idIndexMarker211"/>our version, we’ve added a custom header that will be added to all requests within our application. That header is <code>X-NOT-FROM-GITHUB</code> and will contain the value <em class="italic">our value</em>. Once the header has been added to the <code>event</code> object, we complete the request by passing the event to <code>resolve()</code> and returning the promise. We’ve also added another method to demonstrate how you might go about modifying the headers after the request is made with <code>resolve()</code>. These headers can be observed by opening the browser on any page within our application, opening <strong class="bold">Developer Tools</strong>, navigating to the <strong class="bold">Network</strong> tab, and refreshing the page. Opening the very first request will show our custom headers and values in <strong class="bold">Response Headers</strong>.</p>
<p>Of course, we’re not <a id="_idIndexMarker212"/>limited to setting only headers. Headers were chosen simply for demonstration purposes. We can also set data that will be made available to us in <code>load()</code> and server pages by setting <code>event.locals</code> to the object of our choosing. We can even utilize <code>event.cookies</code> to modify cookie values. However, if we use SvelteKit’s included <code>fetch()</code> method, those cookies will automatically be passed within the application, so long as it lives at a domain that has permission to access the cookies. One final note to make is that both <code>handle()</code> and <code>handleFetch()</code> will run either on render or during the prerendering process. This is particularly important to remember if you’re attempting to generate a static site using <code>adapter-static</code>.</p>
<p>As we just <a id="_idIndexMarker213"/>demonstrated, server hooks can be a powerful tool to leverage when you need to customize request and response headers. While modifying header data is only one use case for them, the example we provided should highlight the many possible solutions they can address. Next, let’s take a look at the hooks available to us on the client as well as the server.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Shared hooks</h2>
<p>Having just<a id="_idIndexMarker214"/> covered <a id="_idIndexMarker215"/>the two hooks available in server environments, we now only have <code>handleError()</code> available to us in client environments. This hook is useful for capturing errors that weren’t thrown through the use of SvelteKit’s <code>error</code> module – that is, any critical application errors, or errors thrown using <code>throw new Error()</code>. It can be very useful to log application errors. It also allows us to control what users will see when they encounter a serious issue with an application. To demonstrate how a shared hook works, let’s add it to both <code>src/hooks.server.js</code> and <code>src/hooks.client.js</code>. In this example, we’ll log errors on the server to a file and errors on the client using <code>console.log()</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks.client.js</p>
<pre class="source-code">
export async function handleError({ error, event }) {
  console.log('client handled error' + error.message);
  console.log(event.url);
  return {message: 'Whoops, looks like you found an error! Sorry about that.'};
}</pre>
<p>In this<a id="_idIndexMarker216"/> example, we use <code>console.log()</code> to show various messages within the browser console. It would be nice if <code>handleError()</code> ran for every unexpected<a id="_idIndexMarker217"/> error within the client; however, that is not the case, as it only runs if an error is encountered during a client-side <code>load()</code> or while rendering on the client. As such, we’ll need to throw an error in another location to see it in action. To trigger this error, we’ll make a minor change to <code>src/routes/(site)/fetch/+page.js</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(site)/fetch/+page.js</p>
<pre class="source-code">
import { browser } from '$app/environment';
const key = 'DEMO_KEY'; // your API key here
export const prerender = true;
export function load() {
  if(browser) {
    throw new Error('in the browser');
  }
  const pic = fetch(`https://api.nasa.gov/planetary/apod?api_key=${key}`)
    .then(response =&gt; {
      console.log('got response');
      return response.json();
    });
  return {pic};
}</pre>
<p>The first change we make is importing the <code>browser</code> module from <code>$app/environment</code>. Once done, we check that the code being run is in the browser and then throw an error, leaving the rest of the code alone. When we navigate to the <code>/fetch</code> route in our application, we’ll see the messages output from <code>src/hooks.client.js</code>. With this hook, we can <a id="_idIndexMarker218"/>ensure that no sensitive data is output to the client during client-side errors. We can also tailor the message in the returned error object accordingly.</p>
<p>To <a id="_idIndexMarker219"/>demonstrate <code>handleError()</code> on the server, we can write the error messages to a log file, which can be easily read at a later time by developers or a daemon installed on the server:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks.server.js</p>
<pre class="source-code">
import { GITHUB } from '$env/static/private';
import fs from 'fs';
export async function handleFetch( { request, fetch  } ) {
  if (request.url.startsWith('https://api.github.com/')) {
    request.headers.set('Accept', 'application/vnd.github+json');
    request.headers.set('Authorization', 'Bearer ' + GITHUB);
    request.headers.set('X-GitHub-Api-Version', '2022-11-28');
  }
  return fetch(request);
}
export async function handle({ event, resolve }) {
  event.setHeaders({'X-NOT-FROM-GITHUB': 'our value'});
  const response = await resolve(event);
  response.headers.set('another', 'custom value');
  return response;
}
function today() {
  const current = new Date();
  return current.getDate() + "-" +
         current.getDay() + "-" +
         current.getFullYear() + " " +
         current.getHours() + ":" +
         current.getMinutes() + ":" +
         current.getSeconds();
}
export async function handleError({ error, event }) {
  const log = today() + ' ' + error.message + ' @ ' + event.request.url;
  fs.appendFile('./app.log', log + '\n', (err) =&gt; {
    if(err) {
      console.log(err);
    }
  });
  return {
    error: error.message
  };
}</pre>
<p>The<a id="_idIndexMarker220"/> first change<a id="_idIndexMarker221"/> in this example to note is that we’ve imported the <code>fs</code> module. This is a Node-specific module for accessing the filesystem. This is worth noting, as including it will prevent us from building our application for another environment. The next change to note is that we’ve added the <code>today()</code> function, which returns the current date and time as a string. Ideally, this function would live in a <code>utilities</code> folder, likely located in <code>src/lib/</code>, but for this demonstration, we can include it here. We’ve also added <code>handleError()</code> to the end of the file. It <a id="_idIndexMarker222"/>accepts an <code>error</code> object as well as an <code>event</code> object. We then concatenate the output from the <code>today()</code> function with the error message, as well as information about where the error occurred. This is all then written to our log file using <code>fs.appendFile()</code>. If an error is encountered while writing to the file, we’ll output it to the console. Finally, we return an object containing the error message.</p>
<p>To<a id="_idIndexMarker223"/> trigger <code>handleError()</code>, we can throw an error in one of our actions or <code>load()</code>. The precise location isn’t particularly important, but we can see our logging in action by adding <code>throw new Error('our custom error');</code> to <code>+page.server.js</code>. In fact, try throwing an error from various <code>load()</code> functions or actions we’ve created so far. You can even experiment with the data provided from the request. For example, it might be helpful to log various headers, such as the client User-Agent, as this information can be helpful when troubleshooting browser compatibility. Once you have thrown a few errors, open <code>app.log</code> in the root of the project directory and observe the output. This simple logging mechanism can be tailored to a project’s needs.</p>
<p>By leveraging <code>handleError()</code>, we can effortlessly bootstrap our own logging mechanism. We can also customize messages shown during errors on client-side rendering or <code>load()</code>, which is especially helpful if our application is a single-page app. Of course, <code>handleError()</code> is very helpful, but it’s only helpful for unexpected errors. How should we manage errors that we fully expect?</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/>Error Handling</h1>
<p>Oftentimes, pesky<a id="_idIndexMarker224"/> users attempt to access resources they’re not supposed to access. Or maybe they’re just users being users and not paying attention to where they’re clicking. In any case, we’ve all met at least one user like this. As developers, it is in our best interest to ensure our code gives those users meaningful messages when they inevitably encounter an error. For the sake of our sanity and future selves, we should discuss errors in SvelteKit.</p>
<p>All of the errors we just created with <code>handleError()</code> are considered <em class="italic">unexpected errors</em>. That is because we did not use SvelteKit’s error module. Errors created using this module are considered <em class="italic">expected errors</em>. By importing the module, we can send custom status codes and error messages to SvelteKit, which can then be captured and used by <code>+error.svelte</code> components. This gives us even greater control over how our messaging displays to users.</p>
<p>In <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, we briefly examined how the routing mechanism will interact with the closest <code>+error.svelte</code> template available. However, we didn’t really discuss the <code>error</code> module or how to use it. Firstly, it needs to be imported from <code>@sveltejs/kit</code>. Once imported, we can then throw the error with <code>throw error()</code> and pass the function two arguments. The first argument is an integer representing the HTTP status <a id="_idIndexMarker225"/>code classifying the error. For instance, a <code>401</code> code represents a <em class="italic">client unauthorized</em> error. The second argument passed to <code>error()</code> is an object containing a message property, with the message we would like conveyed.</p>
<p>To see an example, let’s make some modifications to our previous code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/github/+page.server.js</p>
<pre class="source-code">
import { error } from '@sveltejs/kit';
const star_url= 'https://api.github.com/user/starred/sveltejs/kit';
export function load({ fetch }) {
  throw error(401, {
    message: 'You don\'t have permission to see this!',
    id: crypto.randomUUID()
  });
  const repo = fetch( 'https://api.github.com/repos/sveltejs/kit' )
    .then( response =&gt; response.json() );
  return { repo };
}
export const actions = {
    // omitted for brevity
}</pre>
<p>In this example, we’ve imported the <code>error</code> module from <code>@sveltejs/kit</code>. Within the <code>load()</code> function, we then immediately throw an error using the module. For our error, we supply the <code>401</code> status code and an object with <code>message</code> properties, as well as a custom error <code>id</code>. Again, this can be helpful for reporting and logging errors because we can customize the <a id="_idIndexMarker226"/>error object with whatever information we’d like to provide. If we prefer not to create a whole object, we can instead provide a string with the error message or even just the HTTP status code! We’ll leave the rest of the code in this file unchanged.</p>
<p>Instead of building a traditional <code>try catch</code> statement around the error, we’ll let SvelteKit handle the catching by providing a customized <code>+</code><code>error.svelte</code> component:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/github/+error.server.js</p>
<pre class="source-code">
&lt;script&gt;
  import { page } from '$app/stores';
&lt;/script&gt;
{$page.error.message}
{#if $page.error.id}
  &lt;p&gt;
    Error ID: {$page.error.id}
  &lt;/p&gt;
{/if}</pre>
<p>To show our error messages, we’ll have to leverage the data within the Svelte store <code>page</code>. This store is imported from <code>$app/stores</code>, and the data within it can be accessed by prefacing the store name with a <code>$</code> symbol. The <code>page</code> store contains various properties and data pertaining to the accessed page. We then show the provided error message, followed by a Svelte <code>{#if}</code> directive to show the error ID, provided it exists.</p>
<p>We can then navigate to <code>http://localhost/github</code> and view our new error message, as well as an error ID number. To play around with this example and learn a little more about error handling, try moving <code>src/routes/(app)/github/+error.svelte</code> to <code>src/routes/(app)/+error.svelte</code>. What happens if you move it all the way up to <code>src/routes/+error.svelte</code>? You should try this in your own project, but in short, Svelte’s routing mechanism is robust enough to take the error to the nearest <code>+error.svelte</code> component it finds.</p>
<p>Having explored <a id="_idIndexMarker227"/>error handling, you should now be able to show your application users pertinent information related to the error they’ve stumbled across. Doing so in an informative way should minimize the time spent triaging support tickets.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>Summary</h1>
<p>Having explored the various hooks available in SvelteKit as well as error handling, we’ve covered a lot. We first saw how we can modify outgoing <code>fetch()</code> requests that leverage SvelteKit’s included <code>fetch()</code> by changing familiar <code>RequestEvent</code> objects in the <code>handleFetch()</code> hook. We also saw how we can adjust data flowing into our application via <code>handle()</code>. Then, we explored the <code>handleError()</code> shared hook and how it can be utilized to build a rich logging mechanism or incorporated with another service. Finally, we returned to look at how we can manage expected errors with SvelteKit’s error routing devices, which allow us to customize the look and feel through custom Svelte components.</p>
<p>Now that we have a firm grasp on how to manage errors, we’ll move on to the next chapter to assess how we can best manage static assets.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Resources</h1>
<ul>
<li>GitHub API documentation: <a href="https://docs.github.com/en/rest">https://docs.github.com/en/rest</a></li>
</ul>
</div>
</body></html>