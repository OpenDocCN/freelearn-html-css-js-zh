<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Deploying and Scaling the SPA</h1></div></div></div><p>Having built the core functionality of the application, now it's time to move the SPA into a production-like environment that is accessible from the Internet. For this, we will be using <strong>Platform as a Service </strong>(<strong>PaaS</strong>).</p><p>PaaS is a type of a cloud-based service that allows developers to launch applications on managed infrastructure. Before PaaS, developers or operations engineers had to perform a lot of setup and maintenance tasks, such as provisioning hardware, installing operating software, and insuring uptime.</p><p>There are a number of PaaS providers, but I have chosen Heroku. One reason for this is that you can stand up an application for free on a sandbox, which will allow you to experiment on the app and scale up when you're ready. Deploying an app to Heroku is also quite easy, as, you'll see, Heroku uses Git to deploy.</p><p>We will also set up a production database in the cloud. We will use MongoLab, which also has a free sandbox tier with enough memory to get started.</p><p>We'll finish this chapter by briefly discussing the following concerns for scaling your application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Packaging the application with the Grunt task runner</li><li class="listitem" style="list-style-type: disc">Setting up a production database online</li><li class="listitem" style="list-style-type: disc">Moving the SPA into the cloud</li><li class="listitem" style="list-style-type: disc">Considerations for scaling</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec71"/>Packaging for deployment</h1></div></div></div><p>Our application is still quite small and not complicated, but we will begin by setting up an automated process for packaging our application up for deployment.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec151"/>Setting up Grunt for deployment</h2></div></div></div><p>We will use the Grunt JavaScript task runner to set up some automated tasks to package up our files for deployment. There's not a lot for us to do here, but you'll get a sense of what can be done and be able to explore the rich selection of Grunt plugins to further customize your automated tasks.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec165"/>Installing Grunt</h3></div></div></div><p>If you haven't already, install the grunt CLI using NPM:</p><pre class="programlisting">
<strong>$ npm install -g grunt-cli</strong>
<strong>grunt-cli@0.1.13 /usr/local/lib/node_modules/grunt-cli</strong>
<strong>|- resolve@0.3.1</strong>
<strong>|- nopt@1.0.10 (abbrev@1.0.7)</strong>
<strong>|_ findup-sync@0.1.3 (lodash@2.4.2, glob@3.2.11)</strong>
</pre><p>For Grunt to run correctly, you'll need two files in your project root directory. The first one is a <code class="literal">package.json</code> file to declare dependencies. You already have one in your root directory. The next file you need is <code class="literal">Gruntfile.js</code>, where you will load grunt modules and configure the tasks that Grunt can run. Go ahead and create this file in your root directory and add the following code to it:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
 &#13;
grunt.initConfig({ &#13;
pkg: grunt.file.readJSON('package.json'), &#13;
 &#13;
    }); &#13;
 &#13;
}; &#13;
</pre><p>This is the framework for <code class="literal">Gruntfile</code>. We export a function that expects to receive a reference to the grunt object as its argument. Inside that function, we call the <code class="literal">grunt.initConfig()</code> function, passing it a configuration object. Currently, that configuration object has a single property, that is, a reference to the <code class="literal">package.json</code> file.</p><p>The power of Grunt comes from employing any number of the thousands of plugins made available by its active community. At the time of writing this book, there were over 5,000 Grunt plugins listed at <a class="ulink" href="http://gruntjs.com/plugins">http://gruntjs.com/plugins</a>. If there's some automated task you want to run, chances are that somebody's already created a plugin to support it.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Grunt plugins, which are officially maintained, are always named <code class="literal">grunt-contrib-X</code>. You can generally trust the quality of these plugins, although there are many great unofficially maintained plugins.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec166"/>Installing Grunt plugins</h3></div></div></div><p>A nice feature of Grunt is that plugins are installed using NPM. Let's install a few useful plugins that we will use:</p><pre class="programlisting">
<strong>$ npm install grunt-contrib-clean--save-dev</strong>
<strong>grunt-contrib-clean@1.0.0node_modules/grunt-contrib-clean</strong>
<strong>|- async@1.5.2</strong>
<strong>|_ rimraf@2.5.2 (glob@7.0.0)</strong>
<strong>$ sudonpm install grunt-contrib-uglify--save-dev</strong>
<strong>grunt-contrib-uglify@0.11.1node_modules/grunt-contrib-uglify</strong>
<strong>|- uri-path@1.0.0</strong>
<strong>|- maxmin@2.1.0 (figures@1.4.0, pretty-bytes@3.0.1, gzip-size@3.0.0)</strong>
<strong>|- chalk@1.1.1 (escape-string-regexp@1.0.5, supports-color@2.0.0, has-ansi@2.0.0, strip-ansi@3.0.1, ansi-styles@2.2.0)</strong>
<strong>|- uglify-js@2.6.2 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.5.3, yargs@3.10.0)</strong>
<strong>|_ lodash@4.5.1</strong>
<strong>$ sudonpm install grunt-contrib-htmlmin--save-dev</strong>
<strong>grunt-contrib-htmlmin@0.6.0node_modules/grunt-contrib-htmlmin</strong>
<strong>|- chalk@1.1.1 (escape-string-regexp@1.0.5, supports-color@2.0.0, strip-ansi@3.0.1, has-ansi@2.0.0, ansi-styles@2.2.0)</strong>
<strong>|- pretty-bytes@2.0.1 (number-is-nan@1.0.0, get-stdin@4.0.1, meow@3.7.0)</strong>
<strong>|_ html-minifier@1.2.0 (relateurl@0.2.6, change-case@2.3.1, concat-stream@1.5.1, cli@0.11.1, clean-css@3.4.9, uglify-js@2.6.2)</strong>
<strong>$ sudonpm install grunt-contrib-copy--save-dev</strong>
<strong>grunt-contrib-copy@0.8.2node_modules/grunt-contrib-copy</strong>
<strong>|- file-sync-cmp@0.1.1</strong>
<strong>|_ chalk@1.1.1 (supports-color@2.0.0, escape-string-regexp@1.0.5, ansi-styles@2.2.0, strip-ansi@3.0.1, has-ansi@2.0.0)</strong>
</pre><p>We installed Grunt plugins for <code class="literal">clean</code>, <code class="literal">uglify</code>, <code class="literal">htmlmin</code>, and <code class="literal">copy</code> tasks. Clean will clean files out of a directory. Uglify minimizes JavaScript files. <code class="literal">Htmlmin</code> minifies HTML files. The <code class="literal">Copy</code> task copies files. The <code class="literal">--save-dev</code> flag will add these modules to your <code class="literal">package.json</code> file as d<code class="literal">evdependecies</code>. You need these packages only in your development environment, not in your production environment.</p><p>Before we go any further, let's create a <code class="literal">dist</code> folder in the root of our project. This is where our production-ready assets will be found.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec167"/>Configuring the Gruntfile</h3></div></div></div><p>Now, we need to modify our <code class="literal">Gruntfile</code> to load the plugins:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
 &#13;
grunt.initConfig({ &#13;
pkg: grunt.file.readJSON('package.json'), &#13;
 &#13;
    }); &#13;
 &#13;
<strong>    //load the task plugins</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-uglify');</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-copy');</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-htmlmin');</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-clean');</strong> &#13;
 &#13;
}; &#13;
</pre><p>Here, we use a call to <code class="literal">grunt.loadNPMTasks()</code> for each Grunt plugin we want to load, passing it the name of the module to be loaded.</p><p>Next, we need to configure each of our tasks inside our <code class="literal">Gruntfile</code>. Note that every plugin will have its own configuration properties. Consult the documentation for each plugin you use to see how it is configured. Open up your <code class="literal">Gruntfile.js</code> and make the following edits:</p><pre class="programlisting">module.exports = function(grunt) { &#13;
 &#13;
grunt.initConfig({ &#13;
pkg: grunt.file.readJSON('package.json'), &#13;
<strong>        clean: ['dist/**'],&#13;
</strong>
<strong>        copy: {&#13;
</strong>
<strong>            main: {&#13;
</strong>
<strong>                files: [&#13;
</strong>
<strong>                    {expand: true, src: ['*'], dest: 'dist/',&#13;
                     filter: 'isFile'},</strong>
<strong> &#13;
                    {expand: true, src: ['bin/**'], dest:&#13;
                    'dist/', filter:&#13;
                     'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['config/**'], dest:&#13;
                    'dist/', filter:  &#13;
                     'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['models/**'], dest:&#13;
                    'dist/', filter:&#13;
                     'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['passport/**'], dest:&#13;
                    'dist/', filter:'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['public/**'], dest: &#13;
                   'dist/', filter:'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['routes/**'], dest:&#13;
                    'dist/', filter: 'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['scripts/**'], dest:&#13;
                    'dist/', filter: 'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['utils/**'], dest:&#13;
                    'dist/', filter:'isFile'},&#13;
</strong>
<strong>                    {expand: true, src: ['views/**'], dest: &#13;
                     'dist/', filter: &#13;
                     'isFile'}&#13;
</strong>
<strong> &#13;
               ]&#13;
</strong>
<strong>            }&#13;
</strong>
<strong>        },&#13;
</strong>
<strong>uglify: {</strong>
<strong> &#13;
           options: {&#13;
</strong>
<strong>                mangle: false&#13;
</strong>
<strong>            },&#13;
</strong>
<strong>my_target: {&#13;
</strong>
<strong>                files: {&#13;
</strong>
<strong>'dist/public/javascripts/giftapp.js': ['dist/public/javascripts/giftapp.js'],&#13;
</strong>
<strong>'dist/public/javascripts/controllers/dashMainController.js': ['dist/public/javascripts/controllers/dashMainController.js'],&#13;
</strong>
<strong>'dist/public/javascripts/controllers/giftappFormController.js': ['dist/public/javascripts/controllers/giftappFormController.js'],&#13;
</strong>
<strong>'dist/public/javascripts/services/giftlistFactory.js': ['dist/public/javascripts/services/giftlistFactory.js']&#13;
</strong>
<strong>                }&#13;
</strong>
<strong>            }&#13;
</strong>
<strong>        },&#13;
</strong>
<strong>htmlmin:{&#13;
</strong>
<strong>            options: {&#13;
</strong>
<strong>removeComments: true,&#13;
</strong>
<strong>colapseWhitespace: true&#13;
</strong>
<strong>            },&#13;
</strong>
<strong>dist: {&#13;
</strong>
<strong>                files: {&#13;
</strong>
<strong>'dist/public/templates/dash-add.tpl.html': 'dist/public/templates/dash-add.tpl.html',&#13;
</strong>
<strong>'dist/public/templates/dash-main.tpl.html': 'dist/public/templates/dash-main.tpl.html'&#13;
</strong>
<strong>                }&#13;
</strong>
<strong>            }&#13;
</strong>
<strong>        }</strong> &#13;
    }); &#13;
 &#13;
<strong>    //load the task plugins&#13;
</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-uglify');&#13;
</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-copy');&#13;
</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-htmlmin');&#13;
</strong>
<strong>grunt.loadNpmTasks('grunt-contrib-clean');&#13;
</strong>
<strong>    //register the default task&#13;
</strong>
<strong>grunt.registerTask('default', ['clean','copy','uglify','htmlmin']);</strong> &#13;
 &#13;
}; &#13;
</pre><p>The first change we made was adding a number of task configuration properties inside the <code class="literal">grunt.InitConfig()</code> function. Each of these properties decorates the grunt object when grunt is run and tells the various tasks how to execute.</p><p>The first task configuration is for clean. This task is configured to delete all the files and folders in the <code class="literal">dist</code> folder. The clean configuration takes an array of paths; the syntax of the path definition is pretty standard for the <code class="literal">grunt-contrib</code> plugins. For more information on Grunt's URL globbing, refer to <a class="ulink" href="http://gruntjs.com/configuring-tasks#globbing-patterns">http://gruntjs.com/configuring-tasks#globbing-patterns</a>.</p><p>The other task configurations are similar, but take objects, and can include some options, a target, and lists of files to operate on. For configuration options for grunt plugins, find the plugin you're interested in at <a class="ulink" href="http://gruntjs.com/plugins">http://gruntjs.com/plugins</a> and click on the name of the plugin to get the documentation.</p><p>The next section after the configuration is where we load each plugin that will be used by this <code class="literal">Gruntfile</code>. We do this by passing the name of the plugin as an argument to the <code class="literal">grunt.loadNPMTasks()</code> function. Grunt will look for these plugins in our <code class="literal">node_modules</code> folder. If we were to use custom tasks, such as the one we wrote ourselves, we could load them using calls to <code class="literal">grunt.loadTasks()</code>, passing in a path.</p><p>The last thing we did was to register a task. We did this by calling <code class="literal">grunt.registerTask()</code>. This took two arguments. The first is a string, the name of the task. In our case, this is the default task. Grunt requires that all <code class="literal">Gruntfiles</code> register a default task. The next argument is an array of strings containing the name of any tasks and targets required to run as part of this task.</p><p>Right now, we are just running tasks without listing any individual targets. If we had targets we wished to run on the tasks, the syntax would be <code class="literal">task:target</code>. For example, if we defined a test target for our <code class="literal">uglify</code> task, we would register it in our array as<code class="literal"> ['uglify:test']</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec168"/>Running Grunt</h3></div></div></div><p>Running grunt couldn't be simpler.</p><p>First, ensure that the grunt CLI is installed, as shown in the following:</p><pre class="programlisting">
<strong>$ npm install -g grunt-cli</strong>
<strong>Password:</strong>
<strong>/usr/local/bin/grunt -&gt; /usr/local/lib/node_modules/grunt-cli/bin/grunt</strong>
<strong>grunt-cli@1.2.0 /usr/local/lib/node_modules/grunt-cli</strong>
<strong>|- grunt-known-options@1.1.0</strong>
<strong>|- nopt@3.0.6 (abbrev@1.0.9)</strong>
<strong>|- resolve@1.1.7</strong>
<strong>|_ findup-sync@0.3.0 (glob@5.0.15)</strong>
</pre><p>From the directory where your <code class="literal">Gruntfile</code> lives, simply run grunt followed by the name of the task you wish to run. To run the default task, you can omit the <code class="literal">taskname</code>. Now, let's try running grunt:</p><pre class="programlisting">
<strong>$ grunt</strong>
<strong>Running "clean:0" (clean) task</strong>
<strong>&gt;&gt; 53 paths cleaned.</strong>
<strong>Running "copy:main" (copy) task</strong>
<strong>Copied 35 files</strong>
<strong>Running "uglify:my_target" (uglify) task</strong>
<strong>&gt;&gt; 4 files created.</strong>
<strong>Running "htmlmin:dist" (htmlmin) task</strong>
<strong>Minified 2 files</strong>
</pre><p>If you look in your <code class="literal">dist</code> folder now, you'll notice it's no longer empty. Grunt has cleaned it, moved a bunch of files in, and minified some things. Note that the first time you run this with an empty <code class="literal">dist</code> folder, the clean task will report 0 paths cleaned. When you run this subsequently, you should see the number of files in the <code class="literal">dist</code> folder actually being cleaned.</p><p>Another thing you might notice is that each task is running a target. Copy is running main, <code class="literal">uglify</code> is running <code class="literal">my_target</code>. By default, if no target is specified, Grunt will run the first-defined target.</p><p>If you open up your <code class="literal">dist/public/javascripts/giftapp.js</code> file, you should see that it has been minified:</p><pre class="programlisting">angular.module("giftapp",["ui.router","giftappControllers"]).config(["$stateProvider","$urlRouterProvider",function($stateProvider,$urlRouterProvider){$urlRouterProvider.otherwise("/dash"),$stateProvider.state("dash",{url:"/dash",templateUrl:"/templates/dash-main.tpl.html",controller:"DashMainController"}).state("add",{url:"/add",templateUrl:"/templates/dash-add.tpl.html",controller:"GiftappFormController"})}]); &#13;
</pre><p>Code minification makes our files smaller and somewhat harder to read. It can improve the files' performance on the web significantly. For a more significant performance improvement, we might have to look into concatenating script files and use tools such as the Closure compiler to make them even more efficient.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>There is no need to minify server-side JavaScript code. The main reason for minification is reduced data transfer with a client.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec152"/>Setting up our config for production</h2></div></div></div><p>One issue we're going to run into when moving our application into a production environment is that there will be a difference between our development and our production environment. Right now, all our database references point to our local MongoDB database.</p><p>We're going to use Git to push our files to production later on, and we also don't want to store configuration variables in Git repositories. We also don't want to store <code class="literal">node_modules</code> in Git or push them to production environment since they can be fetched on the fly using our <code class="literal">package.json</code> file.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec169"/>Create a .gitignore file</h3></div></div></div><p>In the root of your project, create a file called <code class="literal">.gitignore</code>. This file contains a list of files and paths that we don't want Git to store or track:</p><pre class="programlisting">node_modules &#13;
config &#13;
.idea &#13;
dist/config &#13;
</pre><p>Line by line we just list the files and folders we want Git to ignore. The first is <code class="literal">node_modules</code>. Again, there's no reason to store these. I then want to ignore anything in my <code class="literal">config</code> folder, which contains sensitive information.</p><p>In here, I ignore <code class="literal">.idea</code>. You may or may not have this folder. This is a folder created by my development environment to store project information. I'm using <code class="literal">JetBrains</code> IDE for JavaScript called Webstorm. Whatever you're using, you'll want to exclude your IDE files, if any. Finally, I explicitly exclude <code class="literal">dist/config</code>, which will be a copy of <code class="literal">config</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec170"/>Create an environment-based configuration module</h3></div></div></div><p>What we want is for the configuration to be handled dynamically. If you're in the development environment, use our configuration for your local machine. If you're in the production environment, you would want to use appropriate configuration variables for that environment.</p><p>The safest way to do that in the production environment setting up environment variables that can be read in the application. We will set them up when we set up our deployment environment, but we can set the stage now.</p><p>In your root <code class="literal">giftapp</code> folder, create a new file called <code class="literal">appconfig.js</code>, using the following code:</p><pre class="programlisting">module.exports = function(){ &#13;
    if(process.env.NODE_ENV&amp;&amp;process.env.NODE_ENV === 'production'){ &#13;
        return{ &#13;
db: process.env.DB, &#13;
facebookAuth : { &#13;
clientID: process.env.facebookClientID, &#13;
clientSecret: process.env.facebookClientSecret, &#13;
callbackURL: process.env.facebookCallbackURL, &#13;
            }, &#13;
 &#13;
twitterAuth : { &#13;
'consumerKey': process.env.twitterConsumerKey, &#13;
'consumerSecret': process.env.twitterConsumerSecret, &#13;
'callbackURL': process.env.twitterCallbackURL &#13;
            } &#13;
        } &#13;
    } else { &#13;
varauth = require('./config/authorization'); &#13;
        return { &#13;
db: 'localhost:27017/giftapp', &#13;
facebookAuth : { &#13;
clientID: auth.facebookAuth.clientID, &#13;
clientSecret: auth.facebookAuth.clientSecret, &#13;
callbackURL: auth.facebookAuth.callbackURL &#13;
            }, &#13;
 &#13;
twitterAuth : { &#13;
'consumerKey': auth.twitterAuth.consumerKey, &#13;
'consumerSecret': auth.twitterAuth.consumerSecret, &#13;
'callbackURL': auth.twitterAuth.callbackURL &#13;
            } &#13;
        } &#13;
    } &#13;
 &#13;
}; &#13;
</pre><p>We first check to see whether there is a <code class="literal">NODE_ENV</code> environment variable and whether it is set to <em>production</em>. If it is, we will have to grab our database and our Facebook and Twitter authorization information from environment variables. We will set up our environment variables later on when we set up our deployment environment.</p><p>If our test fails, we assume we're in our development environment and then manually set our database. We grab our <code class="literal">authorization.js</code> file out of the <code class="literal">config</code> directory and use that to set up our Twitter and Facebook authorization variables.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec171"/>Using the new config file</h3></div></div></div><p>Now, we need to employ our configuration file. Open up your main <code class="literal">app.js</code> file and make a couple of edits:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
varcookieParser = require('cookie-parser'); &#13;
varbodyParser = require('body-parser'); &#13;
varisJSON = require('./utils/json'); &#13;
var routing = require('resource-routing'); &#13;
var controllers = path.resolve('./controllers'); &#13;
var helmet = require('helmet'); &#13;
varcsrf = require('csurf'); &#13;
<strong>varappconfig = require('./appconfig');</strong>
<strong>varconfig = appconfig();</strong> &#13;
 &#13;
//Database stuff &#13;
varmongodb = require('mongodb'); &#13;
var monk = require('monk'); &#13;
<strong>vardb = monk(config.db);</strong> &#13;
 &#13;
var mongoose = require('mongoose'); &#13;
<strong>mongoose.connect(config.db);</strong> &#13;
 &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
var dashboard = require('./routes/dashboard'); &#13;
varauth = require('./routes/auth') &#13;
 &#13;
var app = express(); &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
app.set('x-powered-by', false); &#13;
 &#13;
app.locals.appName = "My Gift App"; &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
app.use(isJSON); &#13;
 &#13;
var flash = require('connect-flash'); &#13;
app.use(flash()); &#13;
 &#13;
var passport = require('passport'); &#13;
varexpressSession = require('express-session'); &#13;
app.use(expressSession({secret: 'mySecretKey'})); &#13;
app.use(passport.initialize()); &#13;
app.use(passport.session()); &#13;
 &#13;
varinitializePassport = require('./passport/init'); &#13;
initializePassport(passport); &#13;
 &#13;
//Database middleware &#13;
app.use(function(req,res,next){ &#13;
req.db = db; &#13;
    next(); &#13;
}); &#13;
 &#13;
app.use(helmet()); &#13;
app.use(csrf()); &#13;
 &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
app.use('/dash', dashboard); &#13;
app.use('/auth', auth); &#13;
 &#13;
 &#13;
var login = require('./routes/login')(passport); &#13;
app.use('/login', login); &#13;
 &#13;
routing.resources(app, controllers, "giftlist"); &#13;
routing.expose_routing_table(app, { at: "/my-routes" }); &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
var err = new Error('Not Found'); &#13;
err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
app.use(function(err, req, res, next) { &#13;
res.status(err.status || 500); &#13;
res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
res.status(err.status || 500); &#13;
res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
 &#13;
module.exports = app; &#13;
</pre><p>First, we load our <code class="literal">appconfig.js</code> file and assign it to the variable <code class="literal">appconfig</code>. Remember, our <code class="literal">appconfig </code>module exports a function. We need to invoke that function to run the code and get access to the dynamically set properties. So, we invoke <code class="literal">appconnfig()</code> and assign the returned object to the variable <code class="literal">config</code>.</p><p>Finally, we use <code class="literal">config.db</code> in the call to <code class="literal">monk()</code> to create the database object. You should now be able to start up your database and server, and there should be no difference in the functionalities.</p><p>Next, we need to use the <code class="literal">appconfig</code> in our passport <code class="literal">OAuth</code> strategies. Let's start with <code class="literal">passport</code>/<code class="literal">facebook.js</code>:</p><pre class="programlisting">varFacebookStrategy = require('passport-facebook').Strategy; &#13;
var User = require('../models/user'); &#13;
<strong>varappconfig = require('../appconfig')</strong>
<strong>varauth = appconfig();</strong> &#13;
 &#13;
module.exports = function(passport){ &#13;
 &#13;
passport.use('facebook', new FacebookStrategy({ &#13;
clientID: auth.facebookAuth.clientID, &#13;
clientSecret: auth.facebookAuth.clientSecret, &#13;
callbackURL: auth.facebookAuth.callbackURL, &#13;
profileFields: ['id', 'displayName', 'email'] &#13;
        }, &#13;
        function(accessToken, refreshToken, profile, cb) { &#13;
User.findOne({ 'facebook.id': profile.id }, function (err, user) { &#13;
                if(err){ &#13;
                    return cb(err) &#13;
                } else if (user) { &#13;
                    return cb(null, user); &#13;
                } else { &#13;
                    for(key in profile){ &#13;
                        if(profile.hasOwnProperty(key)){ &#13;
console.log(key + " -&gt;" + profile[key]); &#13;
                        } &#13;
                    } &#13;
var newUser = new User(); &#13;
newUser.facebook.id = profile.id; &#13;
newUser.facebook.token = accessToken; &#13;
newUser.facebook.name = profile.displayName; &#13;
                    if(profile.emails){ &#13;
newUser.email = profile.emails[0].value; &#13;
                    } &#13;
 &#13;
newUser.save(function(err){ &#13;
                        if(err){ &#13;
                            throw err; &#13;
                        }else{ &#13;
                            return cb(null, newUser); &#13;
                        } &#13;
                    }); &#13;
                } &#13;
            }); &#13;
        } &#13;
    )); &#13;
} &#13;
</pre><p>Once again, we require <code class="literal">appconfig.js</code> from the root of our application. We then invoke the returned function and assign it to the variable <code class="literal">auth</code>. We should require no additional changes, and restarting our server should show that our changes have worked.</p><p>Finally, let's do the same thing to our <code class="literal">passport/twitter.js</code> file:</p><pre class="programlisting">varTwitterStrategy = require('passport-twitter').Strategy; &#13;
var User = require('../models/user'); &#13;
<strong>varappconfig = require('../appconfig')</strong>
<strong>varauth = appconfig();</strong> &#13;
 &#13;
module.exports = function(passport){ &#13;
 &#13;
passport.use('twitter', new TwitterStrategy({ &#13;
consumerKey     : auth.twitterAuth.consumerKey, &#13;
consumerSecret  : auth.twitterAuth.consumerSecret, &#13;
callbackURL     : auth.twitterAuth.callbackURL &#13;
        }, &#13;
        function(token, tokenSecret, profile, cb) { &#13;
User.findOne({ 'twitter.id': profile.id }, function (err, user) { &#13;
                if(err){ &#13;
                    return cb(err) &#13;
                } else if (user) { &#13;
                    return cb(null, user); &#13;
                } else { &#13;
                    // if there is no user, create them &#13;
var newUser                 = new User(); &#13;
 &#13;
                    // set all of the user data that we need &#13;
newUser.twitter.id          = profile.id; &#13;
newUser.twitter.token       = token; &#13;
newUser.twitter.username    = profile.username; &#13;
newUser.twitter.displayName = profile.displayName; &#13;
 &#13;
newUser.save(function(err){ &#13;
                        if(err){ &#13;
                            throw err; &#13;
                        }else{ &#13;
                            return cb(null, newUser); &#13;
                        } &#13;
                    }); &#13;
                } &#13;
            }); &#13;
        } &#13;
    )); &#13;
} &#13;
</pre><p>As you can see, we've made exactly the same change to the Twitter authorization strategy file. Once again, give it a test and it should work exactly the same way.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec72"/>Setting up a cloud database</h1></div></div></div><p>Our SPA will soon live in the cloud, and it needs to be connected to a database. Moving our application to the cloud requires our database also to be accessible from the Web. Having a database running on your local machine isn't going to cut it.</p><p>There are a number of cloud-based database services, but I have found that MongoLab is one of the easiest to set up, use, and maintain. They offer a free sandbox database, which is perfect for development and experimentation. For production-level applications, you'd want to look into a higher subscription rate.</p><p>The PaaS we will use to deploy our application, Heroku, plays really well with MongoLab, and even offers Mongolab as a one-click add-on. We will set things up manually for now so you can learn how things work a little better.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec153"/>Creating a MongoLab account</h2></div></div></div><p>The first thing you need to do is to set up your account on MongoLab. This couldn't be simpler. Go to <a class="ulink" href="https://mongolab.com/signup/">https://mongolab.com/signup/</a> and fill in the form. After you've signed up, you'll be taken to a dashboard that looks like this:</p><p>
</p><div><img src="img/image_14_001.jpg" alt="Creating a MongoLab account"/></div><p>
</p><p>Currently, I have two databases provisioned in my account. If you've just signed up, you won't see anything here. It's from this dashboard that you can set up and manage databases and your account.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec154"/>Creating a database</h2></div></div></div><p>Right now, you have an account on MongoLab, but you don't have a database. We need to create a new database. Fortunately, MongoLab makes this super easy for us. On your dashboard, click on the button that says <strong>Create New</strong>:</p><p>
</p><div><img src="img/image_14_002.jpg" alt="Creating a database"/></div><p>
</p><p>On the Create a new subscription page, there are a lot of different choices for setting up a new deployment. We want to set up a sandbox deployment, which is free and will give you 500 MB of storage. I chose Amazon Web Services for storage in the US East region, and <strong>Single-node</strong> | <strong>Sandbox</strong>.</p><p>Scroll down to the bottom of the page, name your database and click on the button marked Create new MongoDB deployment. I named mine <code class="literal">giftapp</code>. Voila! You are now the proud owner of a shiny and new cloud-based MongoDB deployment.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec155"/>Setting up a user to access the database</h2></div></div></div><p>We can't connect to the database from our application yet. To do so, you'll need to set up a username and password for the database access. From your dashboard, click on the name of your new database, and on the next screen, click on the <strong>Users</strong> tab:</p><p>
</p><div><img src="img/image_14_003.jpg" alt="Setting up a user to access the database"/></div><p>
</p><p>From here, make note of the standard MongoDB URI, which will include the username and password you're about to set up. Click on <strong>Add database user</strong>:</p><p>
</p><div><img src="img/image_14_004.jpg" alt="Setting up a user to access the database"/></div><p>
</p><p>You'll get the preceding pop-up window. Fill it out; do not check read-only. Now, you have a database and a user who can access the data. Make a note of the URI; you will have to use this to access this database. If you want to test it out, you can plug it into your <code class="literal">appconfig</code> file in place of your local database.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec73"/>Deploying the application to Heroku</h1></div></div></div><p>Now, we have most of the pieces in place for web deployment. We will deploy our app to Heroku, a PaaS that supports Node.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec156"/>Getting ready to use Heroku</h2></div></div></div><p>There are just a few steps that are required to deploy your application to Heroku. You'll have to install Git, set up a Heroku account, create a new project on Heroku, and then it will be ready for deploying.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec172"/>Setting up Git</h3></div></div></div><p>Deployment to Heroku is done using Git, so you will need to have it installed. If you don't already have Git installed, go to <a class="ulink" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a> and follow the instructions for your operating system.</p><p>After you have Git installed, you need to initialize a Gitrepository in your <code class="literal">giftapp</code> folder. From the root, in your command line, type the following command:</p><pre class="programlisting">
<strong>$ gitinit</strong>
</pre><p>After you have initialized Git, you'll want to add all your files and commit them to your repo:</p><pre class="programlisting">
<strong>$ git add .</strong>
<strong>$ git commit -m "initil commit"</strong>
</pre><p>That's it for now.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec173"/>Signing up for a Heroku account</h3></div></div></div><p>The next thing you need to do is to sign up for a Heroku account, if you don't already have one. Like MongoLab, this is simple. Go to <a class="ulink" href="https://signup.heroku.com/login">https://signup.heroku.com/login</a> and fill out the form shown in the following screenshot:</p><p>
</p><div><img src="img/image_14_005.jpg" alt="Signing up for a Heroku account"/></div><p>
</p><p>Now you're all set with a free Heroku account.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec174"/>Installing the HerokuToolbelt</h3></div></div></div><p>Heroku provides a CLI app for managing apps called HerokuToolbelt. You'll need to install this to deploy your application to Heroku. To install for your operating system, go to <a class="ulink" href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a> and follow the instructions for your operating system.</p><p>Once installed, you can log in to Heroku from your command line:</p><pre class="programlisting">
<strong>$ heroku login</strong>
<strong>Enter your Heroku credentials.</strong>
<strong>Email: john@notreallymyemail.com</strong>
<strong>Password (typing will be hidden): </strong>
<strong>Authentication successful.</strong>
</pre><p>Now, you're good to go.</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec157"/>Setting up the Heroku project</h2></div></div></div><p>Now we need to actually set up your <code class="literal">giftapp</code> project to be deployed to Heroku. In your terminal, make sure you are in the root directory of your <code class="literal">giftapp</code> project:</p><pre class="programlisting">
<strong>$ heroku create</strong>
<strong>Creating app... done, stack is cedar-14</strong>
<strong>https://guarded-lake-23534.herokuapp.com/ https://git.heroku.com/guarded-lake-23534.git</strong>
</pre><p>The create command has created a Heroku app for us. In this case, the app will be accessed at <a class="ulink" href="https://guarded-lake-23534.herokuapp.com/">https://guarded-lake-23534.herokuapp.com/</a>. Navigating to that URL now won't be very exciting, since we haven't actually deployed anything yet.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Heroku generates a random app name for you. You can pass an app name you would like as part of the call to create, and, as long as it's unique, your app will live there. You can also point a custom domain to your Heroku app, but only if you have a paid account-refer to the Heroku documentation for more information.</p></div></div><p>The second thing the create command has done is to create a remote Git repository for us. This is how we will get our files deployed. There are a couple more steps we need to perform in order to deploy our app.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec158"/>Deploying to Heroku</h2></div></div></div><p>Now that most of the setup work is done, it's time to take the final steps to move our application online.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec175"/>Defining a Procfile</h3></div></div></div><p>We need a <strong>Procfile</strong> to tell Heroku what to run when we deploy. A Procfile is a file that tells the dynos at Heroku which commands to run. For Heroku to read this file, you must name the file Procfile (without any extension) and include it in the top-level directory of your project.</p><p>Create a file called <code class="literal">Procfile</code> in the root of your <code class="literal">giftapp</code> project and add the following line to it:</p><pre class="programlisting">web: node ./dist/bin/www &#13;
</pre><p>This tells Heroku to run the www script out of our <code class="literal">dist</code> directory.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec176"/>App environment variables</h3></div></div></div><p>If you remember, our application is expected to use a number of environment variables to operate correctly. To set these up, log into your Heroku account and navigate to your dashboard at <a class="ulink" href="https://dashboard.heroku.com/login">https://dashboard.heroku.com/login</a>.</p><p>Click on the name of your app to access its dashboard. Click on the settings tab, which will then reveal the <code class="literal">config</code> variables. This is where we will add all of the environment variables we need, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_14_006.jpg" alt="App environment variables"/></div><p>
</p><p>You can see I've added variables for <strong>NODE_ENV</strong>, <strong>PORT</strong>, and <strong>facebookClientID</strong>. You'll do the same and add one for each of the environment variables used in your <code class="literal">appconfig.js</code> file, including DB.</p><p>Make sure to adjust your Facebook and Twitter callback IDs to use your new Heroku domain. If you're confused about what it is, scroll down to the bottom of the settings page and it will be revealed.</p><p>Another step I'll leave you to do is to authorize your Heroku domain for your Facebook and Twitter apps. Just go into your app settings and add the new domain.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec177"/>Deploying</h3></div></div></div><p>Deploying is very easy, now that everything is completely ready. We will use a simple Gitpush. First let's make sure that our <code class="literal">dist</code> files are ready to go and everything is committed to <code class="literal">git</code> properly by running the following code:</p><pre class="programlisting">
<strong>$ grunt</strong>
<strong>Running "clean:0" (clean) task</strong>
<strong>&gt;&gt; 53 paths cleaned.</strong>
<strong>Running "copy:main" (copy) task</strong>
<strong>Copied 39 files</strong>
<strong>Running "uglify:my_target" (uglify) task</strong>
<strong>&gt;&gt; 4 files created.</strong>
<strong>Running "htmlmin:dist" (htmlmin) task</strong>
<strong>Minified 2 files</strong>
<strong>Done, without errors.</strong>
<strong>$ git add .</strong>
<strong>$ git commit -m "heroku commit"</strong>
<strong>[master 42e6f79] heroku commit</strong>
<strong> 17 files changed, 451 insertions(+), 207 deletions(-)</strong>
<strong> create mode 100644 Procfile</strong>
<strong> create mode 100644 appconfig.js</strong>
<strong> create mode 100644 dist/Procfile</strong>
<strong> create mode 100644 dist/appconfig.js</strong>
<strong> create mode 100644 dist/bin/www</strong>
</pre><p>Great, everything is checked in. If you want a sanity check, you can always try <code class="literal">git status</code>.</p><p>Now let's push everything we just committed to Heroku:</p><pre class="programlisting">
<strong>$ git push heroku master</strong>
<strong>Counting objects: 234, done.</strong>
<strong>Delta compression using up to 4 threads.</strong>
<strong>Compressing objects: 100% (207/207), done.</strong>
<strong>Writing objects: 100% (234/234), 46.90 KiB | 0 bytes/s, done.</strong>
<strong>Total 234 (delta 95), reused 0 (delta 0)</strong>
<strong>remote: Compressing source files... done.</strong>
<strong>remote: Building source:</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Node.js app detected</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Creating runtime environment</strong>
<strong>remote:        </strong>
<strong>remote:        NPM_CONFIG_LOGLEVEL=error</strong>
<strong>remote:        NPM_CONFIG_PRODUCTION=true</strong>
<strong>remote:        NODE_ENV=production</strong>
<strong>remote:        NODE_MODULES_CACHE=true</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Installing binaries</strong>
<strong>remote:        engines.node (package.json):  unspecified</strong>
<strong>remote:        engines.npm (package.json):   unspecified (use default)</strong>
<strong>remote:        </strong>
<strong>remote:        Resolving node version (latest stable) via semver.io...</strong>
<strong>remote:        Downloading and installing node 5.6.0...</strong>
<strong>remote:        Using default npm version: 3.6.0</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Restoring cache</strong>
<strong>remote:        Skipping cache restore (new runtime signature)</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Building dependencies</strong>
<strong>remote:        Pruning any extraneous modules</strong>
<strong>remote:        Installing node modules (package.json)</strong>
<strong>remote:        giftapp@0.0.0 /tmp/build_4e2a4d5757c9fb2834a0950c5e35235f</strong>
<strong>remote:        </strong>
<strong>remote: -----&gt; Discovering process types</strong>
<strong>remote:        Procfile declares types -&gt; web</strong>
<strong>remote: </strong>
<strong>remote: -----&gt; Compressing...</strong>
<strong>remote:        Done: 14.2M</strong>
<strong>remote: -----&gt; Launching...</strong>
<strong>remote:        Released v11</strong>
<strong>remote:        https://guarded-lake-23534.herokuapp.com/ deployed to Heroku</strong>
<strong>remote: </strong>
<strong>remote: Verifying deploy.... done.</strong>
<strong>To https://git.heroku.com/guarded-lake-23534.git</strong>
<strong> * [new branch]      master -&gt; master</strong>
</pre><p>And we're live! I omitted a significant portion of the output of the push. It's a very long output. If you go through what's here, you can see what <strong>HerokuToolbelt</strong> will do when we push it. You can see our application starting. You can see that the deployment was a success.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec74"/>Scaling the SPA</h1></div></div></div><p>I want to conclude with a few ideas about scaling the application. Scaling an application is a bit of a black art, but you do want to be prepared should you build out an application and it gets very popular very fast.</p><p>One of the really nice things about using PaaS tools is that they simplify scaling significantly.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec159"/>Scaling the database</h2></div></div></div><p>There are a number of options and considerations for scaling the database. You can see this just by looking at the different packages offered by MongoLab. MongoDB itself supports sharding and replication, as it was built for scaling.</p><p>Concerns about scaling include the size of the database - how much storage, and performance - usually a factor of RAM or using dedicated clusters.</p><p>MongoLab and other providers offer numerous combinations of high-storage and high-performance plans along with several steps, allowing you to incrementally increase your scaling without missing a beat, or installing or configuring a new hardware.</p><p>It's important to understand its usage, which only comes over time with an application, and how that's going to affect the storage. If your application is growing and making many hits on your database, you'll want to think about its performance. As your database fills up, you'll want to manage its storage.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec160"/>Scaling the server</h2></div></div></div><p>Heroku makes it extremely easy to scale your app to exactly the right size that you need; it's one of the things they built their business around. On Heroku, apps are run inside dynos. Think of a dyno as a lightweight container that runs your app.</p><p>Heroku has a number of different dynos running at different performance levels, and you can add and remove them, even at different levels of performance, from the command line or from your dashboard.</p><p>Heroku also offers a number of add-ons, for a fee of course, for doing things such as performance monitoring.</p><p>Not to be a sales pitch for Heroku, other PaaS providers offer similar options. Amazon Web Services is a popular choice for Node.js. There are others, such as Modulus and Digital Ocean. If you're deploying a real-world commercial app, it pays to shop around to find the right solution for you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec75"/>Summary</h1></div></div></div><p>We began this chapter by using Grunt to package up our app into a dist folder. We used Grunt plugins, installed using NPM, to do things such as minify our code. We spent a little time exploring the Grunt plugin ecosystem, which is quite vast and well supported.</p><p>We then prepared to deploy our app to the web by setting up a cloud-based database. We created an account on MongoLab, and then created a new database. We then added a user to the database so that we could access it from our application.</p><p>We then set up an account on Heroku, and prepared our application for deployment. We installed the HerokuToolbelt, which allowed us to create a new Heroku application deployment. We accessed our application through the Heroku dashboard and added our environment variables. Finally, we pushed our project to Heroku using Git.</p><p>We wrapped up by briefly touching on topics such as scaling the database and the server. Using PaaS and a web-based database management system, we are well set up for when our application becomes as popular as Facebook.</p><p>Thanks for reading all the way through the book. If you have followed all of the instructions, you have a cloud-deployed, tested, SPA written in JavaScript. You now have all the skills to build an application front-to-back, database-to-presentation tier, in modern JavaScript. You should have a firm grasp of SPA architecture, modular code, and separation of concerns, and should have worked with every aspect of the MEAN stack. Congratulations, and good work!</p></div></body></html>