<html><head></head><body>
        

                            
                    <h1 class="header-title">The State of JavaScript</h1>
                
            
            
                
<p>avaScript has not traditionally been considered a backend language; that space belonged to the likes of Java, Python, C/C++, C#/.NET, PHP, Ruby and so on. JavaScript was just a 'toy language' that allowed web developers to add animation to websites in order to improve its aesthetics. But this all changed with the advent of <strong>Node.js</strong>. With Node.js, developers can now write JavaScript code that executes on the server, as well as the client. In other words, developers can now write both front and backend code using <em>the same language</em>!</p>
<p>This provides huge productivity benefits, as common code can now be shared across the stack. Furthermore, developers can avoid context switching between different languages, which often breaks concentration and reduces output.</p>
<p>It also led to the rise in <strong>Isomorphic</strong>, or <strong>Universal</strong>, JavaScript frameworks, such as <em>Meteor</em>. These types of frameworks allow you to write applications entirely in JavaScript that run on both the client and the server.</p>
<p>Here's what we'll cover in this chapter:</p>
<ul>
<li>Examining a short history on the evolution of the web application and its transition from the <strong>client-server model</strong> to <strong>Single-Page Applications (SPAs)</strong></li>
<li>Explaining the concept of Isomorphic JavaScript</li>
<li>Exploring the benefits of using JavaScript across the entire stack</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Evolution of the web application</h1>
                
            
            
                
<p>When you type a URL, such as <kbd>www.example.com</kbd>, into your browser, what actually happens? First, the browser would send a request to one of Example Corp's servers, which retrieves the resource requested (for example, an HTML file), and sends it back to the client:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/142965cf-7095-49d0-b30b-51d24cc0dd30.jpg" style="width:56.67em;height:21.42em;"/></p>
<p>The browser then parses the HTML, retrieves all the files the web page depends on, such as CSS, JavaScript, and media files, and renders it onto the page.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bf7fadd0-1869-4b96-8c8c-263b01bb6f27.jpg" style="width:57.25em;height:43.75em;"/></p>
<p>The browser consumes flat, one-dimensional texts (HTML, CSS) and parses them into tree-like structures (DOM, CSSOM) before rendering it onto the page.</p>
<p>This scheme is known as the <em>client-server model</em>. In this model, most of the processing is handled server-side; the client's role is limited to simple and superficial uses, such as rendering the page, animating menus and image carousels, and providing event-based interactivity.</p>
<p>This model was popular in the 1990s and 2000s, when web browsers were not very powerful. Creating entire applications with JavaScript on the client side was unheard of, and those that had that requirement resorted to Java applets and Adobe Flash (and, to a certain extent, Microsoft Silverlight). However, over time, the computing power of personal devices, such as desktop computers, laptops, and smartphones increased dramatically, and this allowed browsers to handle more elaborate operations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Just-in-time (JIT) compilers</h1>
                
            
            
                
<p>Between 2008 and 2009, Mozilla, the company behind Firefox, slowly introduced <em>TraceMonkey</em>, the first <strong>Just-in-time (JIT)</strong> compiler for JavaScript, in different versions of Firefox 3.x, starting with 3.1. Similarly, the <em>V8</em> JavaScript Engine, which powers Chrome and Safari, and <em>Chakra</em>, which powers Internet Explorer and Edge, also included a JIT compiler.</p>
<p>Traditionally, the JavaScript engine uses an <strong>interpreter</strong>, which translates the JavaScript source code into <strong>machine code</strong> that your computer can run. The JIT compiler improved the performance of the engine by identifying blocks of code that are frequently run, compiling them, and adding them to a cache. When the same block of code needs to be run again at a later time, the JavaScript engine can simply run the cached, pre-compiled machine code, skipping the interpreter altogether. Needless to say, this is much faster and the JavaScript engine can execute more operations per unit time, greatly increasing performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Single page applications (SPAs)</h1>
                
            
            
                
<p>Because of this increased performance, developers can now build feature-rich JavaScript applications that run on the browser. Google was the first major company to take advantage of this, when they released the first <strong>client-side web application framework</strong>—<em>Angular</em> - on 20 October 2010. Since then, many competitors have emerged, including <em>Ember</em>, <em>React</em>, and <em>Vue.js</em>, but Angular still remains relevant today.</p>
<p>Angular is a framework for building SPAs. Instead of delegating the bulk of the processing to the server, the client takes on most of the responsibility.</p>
<p>Let's take an e-commerce web application as an example. In the client-server model, when the server receives a request from the client, it will compose a fully-formed HTML and attach it as the payload of the response. If it needs data from the database, it will query the database and inject the data into an HTML template to produce the fully-formed HTML. The client, usually a browser, is then entrusted with the simple task of rendering the HTML onto the screen.</p>
<p>In the SPA model, the server would initially send the entire application, including any HTML, CSS, and JavaScript files, to the client. All the application logic, including routing, now resides on the client. Because of this, the client can update the UI of the application very quickly, as it does not need to wait for a response from the server. Whenever the client requires information it does not have, such as certain entries in the database, it will send a request to the server. The server would then respond with the raw data, usually presented in JSON format, and nothing else. It is then the client's job to process this information and update the UI appropriately. With SPAs, most of the logic is handled client-side; the server's job is simply to retrieve and send back data:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/23fcb8b6-092c-4a84-9d8b-278dee9a49c1.jpg" style="width:54.92em;height:26.92em;"/></p>
<p>The SPA model has many benefits over the client-server model:</p>
<ul>
<li>It frees up the server to handle more requests, as requests are simpler to process.</li>
<li>It allows the UI of the app to respond more quickly to user interaction because the UI does not need to wait for the server to respond before updating itself.</li>
</ul>
<p class="mce-root"/>
<p>Nowadays, most web applications are built with an SPA framework. Tesla, Sony, Microsoft Support, Genius, Renault, Staples, Udemy, and Healthcare.gov are all websites built with Angular; Airbnb, Asana, BBC, Dropbox, Facebook, Lyft, Netflix, PayPal, and Uber all use React on their websites; although Vue.js is relatively new, several major Asian companies have already adopted it, such as Alibaba, Baidu, Tencent, Xiaomi, and Line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Isomorphic JavaScript applications</h1>
                
            
            
                
<p>However, everything has its drawbacks, and SPAs are no exception. The most obvious shortcoming of SPAs is that more code needs to be transferred at the beginning, which can increase the initial load time of the page. To counteract this deficiency, a technique called <strong>server-side rendering</strong> (<strong>SSR</strong>) can be employed.</p>
<p>With SSR, the initial page is processed and rendered on the server in the same way as the traditional client-server model. However, the returned HTML contains a tag that'll request the rest of the application to be downloaded at a later time, after the initial page has been successfully rendered. This allows us to improve the initial page load speed, whilst keeping all the benefits of the SPA. Furthermore, SSR is also useful for ensuring <strong>Search Engine Optimization</strong> (<strong>SEO</strong>) performance, as it helps web crawlers to quickly decipher how a page should look, without having to download all the assets.</p>
<p>SSR can be used alongside other techniques, such as <strong>code splitting</strong> and <strong>tree shaking</strong>, to reduce the size of the initial response payload, thus reducing the <strong>time-to-first-render</strong> (<strong>TTFR</strong>) and improving the user experience.</p>
<p>This is the state of the web application today. New web standards such as <strong>HTTP/2</strong> and <strong>WebAssembly</strong> (a.k.a. <em>Wasm</em>) may all change how we approach building web applications in the near future. In the fast-moving world of front-end development, this SPA + SSR model may soon be superseded by a new paradigm.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of Node.js</h1>
                
            
            
                
<p>JavaScript is the language of the browser. There's no denying that. Next, let's examine the reasons why a developer should pick Node.js as the back-end language for their application. Although there are many reasons, here we've boiled it down to two factors—<strong>context switching</strong> and <strong>shared code</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Context switching</h1>
                
            
            
                
<p>Context switching, or <em>task switching</em>, is when a developer is working on multiple projects, or in different languages, at the same time and has to switch between them regularly.</p>
<p>"Doing more than one task at a time, especially more than one complex task, takes a toll on productivity."                                               </p>
<p>– Multitasking: Switching costs (American Psychological Association)</p>
<p>(<a href="http://www.apa.org/research/action/multitask.aspx" target="_blank">http://www.apa.org/research/action/multitask.aspx</a>)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching between projects</h1>
                
            
            
                
<p>Programming is an activity that requires you to keep many variables in memory at the same time—variable names, interfaces of different modules, application structure and many more. If you switch to a different project, you'll have to dump the context of the current project and load in the context of the new project. The time required for this switch increases with the complexity of the project, and varies from one individual to the next, but can take anything from a few minutes to a few hours. This makes development extremely inefficient.</p>
<p>This is why, instead of multitasking, you should complete one project before moving on to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching between languages</h1>
                
            
            
                
<p>The same principle applies when switching between different programming languages. When switching between projects, you need to juggle between different contexts; when switching between languages, you need to juggle between different syntax, data structures, and ecosystems. To demonstrate, the following table illustrates some key differences between Python and JavaScript:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Python</strong></td>
<td><strong>JavaScript</strong></td>
</tr>
<tr>
<td>Has many data types, including <kbd>None</kbd>, Boolean, <kbd>int</kbd>, <kbd>float</kbd>, <kbd>complex</kbd>, <kbd>list</kbd>, <kbd>tuple</kbd>, <kbd>range</kbd>, <kbd>str</kbd>, <kbd>bytes</kbd>, <kbd>bytearray</kbd>, <kbd>memoryview</kbd>, <kbd>set</kbd>, <kbd>frozenset</kbd>, <kbd>dict</kbd>, and many more</td>
<td>Has seven data types: <kbd>undefined</kbd>, <kbd>null</kbd>, <kbd>Boolean</kbd>, <kbd>number</kbd>, <kbd>string</kbd>, <kbd>symbol</kbd>, and <kbd>object</kbd></td>
</tr>
<tr>
<td>Statements are grouped by indentation</td>
<td>Statements are grouped by blocks, expressed using enclosing braces (<kbd>{}</kbd>)</td>
</tr>
<tr>
<td>Uses <a href="https://virtualenv.pypa.io/en/stable/"><kbd>virtualenv</kbd></a> to create isolated environments</td>
<td>Uses <strong>Node Version Manager</strong> (<a href="https://github.com/creationix/nvm" target="_blank">https://github.com/creationix/nvm</a>) (<strong>nvm</strong>), <kbd>package.json</kbd>, and the local <kbd>node_modules</kbd> directory to create isolated environments</td>
</tr>
<tr>
<td>Uses a class-based inheritance model</td>
<td>Uses a prototype-based inheritance model</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In addition to syntactical differences, different languages may also follow different paradigms—Elixir is a functional language, whereas Java is an <strong>object-oriented</strong> (<strong>OO</strong>) <strong>language</strong>.</p>
<p>Therefore, context-switching between different languages also makes the development process very inefficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The business perspective</h1>
                
            
            
                
<p>From a business point of view, using different languages for the front- and back-end means they need to hire two different types of developer: JavaScript developers for the front-end and, say, Python developers for the back-end. If there's a large backlog in back-end tasks, front-end developers wouldn't be able to help (unless they also know Python). This makes resource allocation more difficult for project managers. But if everyone develops in JavaScript, then this problem becomes null.</p>
<p>Furthermore, using JavaScript for the entire stack makes the development process more efficient. Apart from the efficiencies gained by avoiding context switching, a single developer can now develop an entire feature from start to finish, as they can code both the front- and back-end.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Shared code</h1>
                
            
            
                
<p>As Node.js and SPAs have became more popular, more and more JavaScript libraries are being written every day. At the time of writing, over 775,000 packages are listed on <a href="http://npmjs.com">npmjs.com</a>, the <em>de facto</em> package manager for JavaScript. These include libraries for handling time and date (<kbd>moment.js</kbd>), utility libraries (<kbd>lodash</kbd>), and even a deep learning library (<kbd>convnetjs</kbd>).</p>
<p><strong>npm packages</strong> were originally only meant to be installed and run by server-side Node.js; however, tools such as <strong>Browserify</strong> and <strong>Webpack</strong> allowed us to bundle these dependencies and send them to the client. Now, many npm packages can be used in both the front- and back-end.</p>
<p>Likewise, by using JavaScript across your entire stack, you can encapsulate common logic and use it across both environments. For example, authentication checks should be performed on both the server (for security reasons) as well as the client (to ensure performance by preventing unnecessary requests).</p>
<p>If JavaScript is used for front- and back-end code, then the code can be shared and reused. If, however, we use Python in the back-end, then the same logic must be duplicated in JavaScript. This violates the <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) principle and makes our development process slower and more error-prone.</p>
<p>The project also becomes harder to maintain. Now, when we need to make changes to the code, we must update it twice, in two different languages, possibly across two different projects; both projects may also need to be deployed at the same time.</p>
<p>Therefore, using JavaScript in the front-end and Node.js in the back-end allows you to improve maintainability, reduce compatibility issues, and conserve manpower and development time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we described the evolution of web applications from using the client-server model to SPAs, and how advances in JavaScript engines facilitated this transformation. Then, we discussed the benefits of using JavaScript across the stack, focusing on the topics of context switching and shared code.</p>


            

            
        
    </body></html>