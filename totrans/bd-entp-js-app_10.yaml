- en: Deploying Our Application on a VPS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VPS上部署我们的应用程序
- en: In the last few chapters, we created a robust user directory API, which is now
    ready to face the outside world. Thus, in this chapter, we'll learn how to expose
    our API to the **World Wide Web** (**WWW**). First, we will need to set up a **V****irtual
    Private Server** (**VPS**) to host and serve our API, and associate it with a public, **static
    IP** address; we will achieve both of these goals using **DigitalOcean** (**DO**), a
    popular cloud provider. Then, to make it easier for our API consumers, we'll purchase
    a **domain name** from a **domain registry**, and configure its **Domain Name
    System** (**DNS**) records to resolve the domain name to the static IP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，我们创建了一个健壮的用户目录API，现在它已经准备好面对外部世界。因此，在本章中，我们将学习如何将我们的API暴露给**万维网**（**WWW**）。首先，我们需要设置一个**虚拟专用服务器**（**VPS**）来托管和提供我们的API，并将其与一个公共的、**静态IP地址**关联；我们将使用流行的云服务提供商**DigitalOcean**（**DO**）来实现这两个目标。然后，为了使API消费者更容易使用，我们将从一个**域名注册商**购买一个**域名**，并配置其**域名系统**（**DNS**）记录以解析域名到静态IP地址。
- en: 'By following this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章内容，您将：
- en: Learn to set up and secure a VPS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何设置和保障虚拟专用服务器（VPS）
- en: Learn about **privileged ports**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**特权端口**
- en: Keep processes alive using **PM2**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**PM2**保持进程活跃
- en: Set up **NGINX** as a **reverse proxy** to our API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**NGINX**配置为我们的API的**反向代理**
- en: Understand the architecture of the DNS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DNS的架构
- en: Purchase and configure a domain name
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买和配置域名
- en: Obtaining an IP address
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取IP地址
- en: The internet is a giant network of interconnected machines. For these machines
    to communicate with one another, each machine must have a unique identifier. The
    internet uses the **TCP/IP protocol** for its communication, which in turn uses
    the **IP address** as its unique identifier. So, the first requirement for exposing
    our API to the internet is to have an IP address.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是一个由相互连接的机器组成的巨大网络。为了这些机器能够相互通信，每台机器都必须有一个唯一的标识符。互联网使用**TCP/IP协议**进行通信，该协议反过来使用**IP地址**作为其唯一的标识符。因此，将我们的API暴露给互联网的第一个要求是拥有一个IP地址。
- en: 'If you are paying for internet at home, you too will have an IP address provided
    to you by your **Internet Service Provider** (**ISP**). You can check your IP
    address by using an external service such as [ipinfo.io](https://ipinfo.io/):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在家支付互联网费用，您也将获得由您的**互联网服务提供商**（**ISP**）提供的IP地址。您可以通过使用外部服务（如 [ipinfo.io](https://ipinfo.io/)）来检查您的IP地址：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This means it''s theoretically possible to host your API using your home PC,
    or even your laptop. However, doing so is problematic because of the following
    reasons:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着理论上您可以使用您的家用电脑，甚至笔记本电脑来托管您的API。然而，这样做存在以下问题：
- en: Most consumer-grade internet plans provide **dynamic IP addresses**, rather
    than static ones, which means your IP can change every few days
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数消费级互联网套餐提供**动态IP地址**，而不是静态的，这意味着您的IP地址可能每隔几天就会改变
- en: Many ISPs block incoming traffic to port `80`, which is the default HTTP port
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多互联网服务提供商（ISP）阻止端口`80`的入站流量，这是默认的HTTP端口
- en: You need to maintain your own hardware
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要维护自己的硬件
- en: Internet connection speed may be slow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接速度可能较慢
- en: Managed DNS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理DNS
- en: The first issue can be mitigated using **Managed DNS** services, such as **No-IP**
    ([noip.com](https://www.noip.com/)) and **Dyn** ([dyn.com](https://dyn.com/)),
    which provide a **dynamic DNS** service. These services will provide you with
    a hostname (for example, `username.no-ip.info`) and update the hostname's DNS
    **A record** to point to your machine's IP address (more on DNS records later).
    This means any requests destined for that hostname will arrive at your associated
    device. To make this work, you'd also have to install a client on your device,
    which frequently checks its own IP, and update the Managed DNS service whenever
    it changes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题可以通过使用**管理DNS**服务（如**No-IP** ([noip.com](https://www.noip.com/)) 和 **Dyn**
    ([dyn.com](https://dyn.com/)))来解决，这些服务提供**动态DNS**服务。这些服务将为您提供主机名（例如，`username.no-ip.info`）并更新主机名的DNS
    **A记录**以指向您的机器的IP地址（关于DNS记录的更多内容将在后面介绍）。这意味着任何针对该主机名的请求都将到达您关联的设备。为了使这生效，您还必须在您的设备上安装一个客户端，该客户端会频繁检查其自身的IP地址，并在IP地址更改时更新管理DNS服务。
- en: The second issue can be mitigated by using **port redirect**, which is a service
    that most Managed DNS services also provide. First, just as before, you must download
    the client to update the Managed DNS service with your dynamic IP. Then, bind
    your application to listen on a port on your machine that is not blocked by your
    ISP. Lastly, you'd have to go to the Managed DNS service and redirect all traffic
    that arrives at the hostname to your device's specified port.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题可以通过使用 **端口重定向** 来缓解，这是一种大多数托管 DNS 服务也提供的服务。首先，就像之前一样，您必须下载客户端来更新托管 DNS
    服务并使用您的动态 IP。然后，将您的应用程序绑定到机器上的一个端口，该端口不会被您的 ISP 封锁。最后，您需要前往托管 DNS 服务并将到达主机名的所有流量重定向到您的设备指定的端口。
- en: Dynamic DNS simply changes a DNS record; no application traffic actually arrives
    at the Managed DNS servers. On the other hand, with port redirect, the Managed
    DNS service acts as a proxy that redirects HTTP packets. If you'd like to try
    them out, No-IP provides a Free Dynamic DNS service, which you can sign up for
    at [noip.com/free](https://www.noip.com/free).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 DNS 只简单地更改 DNS 记录；实际上没有任何应用程序流量到达托管 DNS 服务器。另一方面，使用端口重定向时，托管 DNS 服务充当一个代理，将
    HTTP 数据包重定向。如果您想尝试它们，No-IP 提供了免费的动态 DNS 服务，您可以在 [noip.com/free](https://www.noip.com/free)
    上注册。
- en: While having a dynamic IP and using a dynamic DNS is acceptable for personal
    use, it's nowhere near reliable enough to be used for enterprise. Your IP address
    can change at any time, and this can cause connections to drop and data to get
    lost. There will also be a bit of latency between when an IP address updates and
    when the Managed DNS provider is made aware of this change, and thus you can never
    achieve 100% uptime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于个人使用来说，使用动态 IP 和动态 DNS 可以接受，但它远不足以可靠地用于企业。您的 IP 地址可以随时更改，这可能导致连接中断和数据丢失。在
    IP 地址更新和托管 DNS 提供商意识到这一变化之间，也会存在一定的延迟，因此您永远无法实现 100% 的正常运行时间。
- en: 'Businesses who host their own servers usually pay their ISP for a static IP
    and enhanced connection speeds. However, this can be costly. Take Comcast, the
    most popular and beloved broadband provider in the United States: their most basic
    consumer-grade offering, XFINITY Performance Internet, supports up to 60 Mbps
    download speed and costs $39.99 per month. However, for Comcast to assign you
    a static IP, you must subscribe to their business-grade plans. The most basic
    plan—Starter Internet—supports up to 25 Mbps speed, and costs $69.95 per month,
    or $89.90 if you''d want to include a static IP. This is just not cost-effective.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自行托管服务器的企业通常需要向他们的 ISP 支付静态 IP 和增强的连接速度费用。然而，这可能是昂贵的。以美国最受欢迎和最受喜爱的宽带提供商康卡斯特为例：他们最基础的消费级产品
    XFINITY 性能互联网支持高达 60 Mbps 的下载速度，每月费用为 $39.99。然而，为了康卡斯特为您分配静态 IP，您必须订阅他们的企业级计划。最基础的计划——入门级互联网——支持高达
    25 Mbps 的速度，每月费用为 $69.95，如果您想包括静态 IP，则为 $89.90。这显然不是性价比高的选择。
- en: A better alternative is to register an account with a cloud provider and deploy
    our application on a VPS. A VPS is essentially a **virtual machine** (**VM**)
    that is connected to the internet and is allocated its own static IP address.
    In terms of costs, VPS can cost as low as $0.996 per month!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是注册一个云服务提供商的账户，并在 VPS 上部署我们的应用程序。VPS 实质上是一个连接到互联网的 **虚拟机 (VM**)，并分配了自己的静态
    IP 地址。在成本方面，VPS 的价格可以低至每月 $0.996！
- en: You can find a list of cheap VPS hosting providers at [lowendbox.com](https://lowendbox.com/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [lowendbox.com](https://lowendbox.com/) 找到一系列便宜的 VPS 托管提供商。
- en: Setting up a Virtual Private Server (VPS)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置虚拟专用服务器 (VPS)
- en: 'There are many VPS providers, such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 VPS 提供商，例如以下这些：
- en: Amazon Elastic Compute Cloud (Amazon EC2): [aws.amazon.com/ec2](https://aws.amazon.com/ec2/)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊弹性计算云 (Amazon EC2)：[aws.amazon.com/ec2](https://aws.amazon.com/ec2/)
- en: IBM Virtual Servers: [ibm.com/cloud/virtual-servers](https://www.ibm.com/cloud/virtual-servers)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际商业机器公司虚拟服务器：[ibm.com/cloud/virtual-servers](https://www.ibm.com/cloud/virtual-servers)
- en: Google Cloud Compute Engine: [cloud.google.com/compute](https://cloud.google.com/compute/)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云计算引擎：[cloud.google.com/compute](https://cloud.google.com/compute/)
- en: Microsoft Azure Virtual Machines: [azure.microsoft.com/services/virtual-machines](https://azure.microsoft.com/services/virtual-machines/)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 Azure 虚拟机：[azure.microsoft.com/services/virtual-machines](https://azure.microsoft.com/services/virtual-machines/)
- en: Rackspace Virtual Cloud Servers: [rackspace.com/cloud/servers](https://www.rackspace.com/cloud/servers)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rackspace 虚拟云服务器：[rackspace.com/cloud/servers](https://www.rackspace.com/cloud/servers)
- en: Linode: [linode.com](https://www.linode.com/)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linode：[linode.com](https://www.linode.com/)
- en: For this book, we are going to use **DigitalOcean** (**DO**, [digitalocean.com](https://www.digitalocean.com/)).
    We picked DO because it has a very intuitive user interface (UI), where everything
    (VPS, DNS, block storage, monitoring, Kubernetes) can all be managed on the same
    dashboard. This is unlike AWS, which has an outdated and cumbersome UI.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将使用**DigitalOcean**（**DO**，[digitalocean.com](https://www.digitalocean.com/)）。我们选择
    DO 是因为它有一个非常直观的用户界面（UI），在这里可以管理所有内容（VPS、DNS、块存储、监控、Kubernetes），所有这些都可以在同一个仪表板上完成。这与
    AWS 不同，AWS 的用户界面过时且繁琐。
- en: Now, go to the DO website ([digitalocean.com](https://m.do.co/c/5cc901594b32))
    and create an account.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 DO 网站 ([digitalocean.com](https://m.do.co/c/5cc901594b32)) 并创建一个账户。
- en: 'You should use this referral link: [m.do.co/c/5cc901594b32](https://m.do.co/c/5cc901594b32);
    it will give you $10 in free credits!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用这个推荐链接：[m.do.co/c/5cc901594b32](https://m.do.co/c/5cc901594b32)；这将为你提供10美元的免费信用额度！
- en: DO will ask you for your billing details, but you won't be charged until you've
    used their services. You should also set up **Two-Factor Authentication** (**2FA**)
    on your account to keep it secure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DO 将会要求你提供账单详情，但直到你使用他们的服务之前，你不会产生费用。你还应该在你的账户上设置**双因素认证**（**2FA**）以保持账户安全。
- en: Creating a VPS instance
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 VPS 实例
- en: After you've successfully created your account, log in at [cloud.digitalocean.com](https://cloud.digitalocean.com/),
    click on the drop-down button that says Create, and then select Droplet.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功创建账户后，登录到 [cloud.digitalocean.com](https://cloud.digitalocean.com/)，点击显示创建的下拉按钮，然后选择
    Droplet。
- en: In DO vocabulary, a droplet is the same as a VPS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DO 术语中，droplet 与 VPS 相同。
- en: Choosing an image
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择镜像
- en: You'll be presented with a screen where we can configure the VPS. The first
    section on that screen is Choose an image, which is where we select the Linux
    distribution we want our VPS to run on. We are going to select the Ubuntu 18.04
    x64 option for our VPS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个屏幕，我们可以配置 VPS。屏幕上的第一个部分是“选择镜像”，这是我们选择 VPS 要运行的 Linux 发行版的地方。我们将为我们的 VPS
    选择 Ubuntu 18.04 x64 选项。
- en: 'We picked 18.04 because it is a **Long Term Support** (**LTS**) version, which
    means it will receive hardware and maintenance updates for five years, whereas
    standard Ubuntu releases are only supported for nine months. This is important
    for enterprise-level services because it ensures any security vulnerabilities
    or performance updates are treated as priority over other standard releases:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 18.04 是因为它是一个**长期支持**（**LTS**）版本，这意味着它将在五年内接收硬件和维护更新，而标准的 Ubuntu 发布版仅支持九个月。这对于企业级服务来说很重要，因为它确保任何安全漏洞或性能更新都优先于其他标准发布版：
- en: '![](img/81bdd4b8-eedc-46bc-93e0-745f5c617f66.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81bdd4b8-eedc-46bc-93e0-745f5c617f66.png)'
- en: This diagram is reproduced from the Ubuntu lifecycle and release cadence page
    on the Ubuntu website (ubuntu.com/about/release-cycle[)](https://www.ubuntu.com/about/release-cycle)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是从 Ubuntu 网站上的 Ubuntu 生命周期和发布周期页面复制的（ubuntu.com/about/release-cycle[)](https://www.ubuntu.com/about/release-cycle)
- en: Choosing a size
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择大小
- en: Next, we must pick the size of our VPS. This determines the amount of resources
    (CPU, memory, storage, and bandwidth) that are available to us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须选择我们的 VPS 的大小。这决定了我们可用的资源量（CPU、内存、存储和带宽）。
- en: Elasticsearch is very memory-intensive, and their official guide suggests using
    machines with 16-64 GB of memory. However, that is very costly. For this book, picking
    a VPS with at least 4 GB of RAM should suffice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 非常占用内存，他们的官方指南建议使用具有 16-64 GB 内存的服务器。然而，这非常昂贵。对于这本书，选择至少具有 4 GB
    RAM 的 VPS 应该足够了。
- en: We can ignore the backups and block storage options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以忽略备份和块存储选项。
- en: Block storage is extra disk space that can be associated with our VPS. For example,
    if we are hosting a file server or Image API, we may want to add extra disk space
    to store these files/images; purchasing pure disk space is much cheaper than running
    a VPS with an operating system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 块存储是与我们的 VPS 关联的额外磁盘空间。例如，如果我们托管文件服务器或 Image API，我们可能希望添加额外的磁盘空间来存储这些文件/图片；购买纯磁盘空间比运行带有操作系统的
    VPS 更便宜。
- en: Picking a data center region
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据中心区域
- en: Next, we must choose the data center where our VPS will reside.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须选择我们的 VPS 将驻留的数据中心。
- en: Different machines on the internet communicate by sending messages to one another. A
    message must "hop" through a string of proxy servers before it arrives at the
    receiver's machine, and this takes time. Generally speaking, the more **hops**
    a message must make, the longer the latency.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的不同机器通过相互发送消息进行通信。一条消息必须在到达接收者机器之前“跳跃”通过一系列代理服务器，这需要时间。一般来说，消息必须进行的跳跃越多，延迟越长。
- en: Therefore, you should pick the data center that is closest to your target users.
    For example, if your target audience is largely based in the UK, then you'd pick
    the London data center.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该选择离您的目标用户最近的数据中心。例如，如果您的目标受众主要基于英国，那么您会选择伦敦数据中心。
- en: Selecting additional options
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择附加选项
- en: 'Next, select the following additional options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择以下附加选项：
- en: '**Private networking**: This gives each VPS instance an internal IP address,
    which allows services deployed in the same data center to communicate with each
    other. At the time of this writing, this option is free and does not count towards
    your monthly bandwidth quota.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有网络**：这为每个 VPS 实例提供了一个内部 IP 地址，允许同一数据中心部署的服务相互通信。在撰写本文时，此选项是免费的，并且不计入您的月度带宽配额。'
- en: '**IPv6**: IPv4 can support up to 4,294,967,296 unique IP addresses. The internet
    has grown so much that we are close to exceeding this limit. Therefore, IPv6 increases
    the number of bits in the IP address from 32 bits to 128 bits, yielding 340,282,366,920,938,463,463,374,607,431,768,211,456
    addresses. By checking this option, we allow users to use the IPv6 address to
    address our server.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPv6**：IPv4 可以支持高达 4,294,967,296 个唯一的 IP 地址。互联网的增长如此之快，以至于我们接近了这一限制。因此，IPv6
    将 IP 地址的位数从 32 位增加到 128 位，产生了 340,282,366,920,938,463,463,374,607,431,768,211,456
    个地址。通过选择此选项，我们允许用户使用 IPv6 地址来定位我们的服务器。'
- en: '**Monitoring**: Collects system metrics on your server, such as CPU, memory,
    disk I/O, disk usage, public/private bandwidth, and alerts you when your server
    is running close to the limit:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：收集服务器上的系统指标，如 CPU、内存、磁盘 I/O、磁盘使用率、公共/私有带宽，并在服务器运行接近限制时发出警报：'
- en: '![](img/e5da637a-73d4-4426-8e4e-47820078d4d5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5da637a-73d4-4426-8e4e-47820078d4d5.png)'
- en: Naming your server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名您的服务器
- en: Lastly, pick a hostname for your server. This will appear in the administration
    panel of DigitalOcean, so pick something you can easily remember.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为您的服务器选择一个主机名。这将在 DigitalOcean 的管理面板中显示，因此请选择一个您容易记住的名称。
- en: 'When you have many machines, it may be worth setting up a naming convention,
    where the name of the machine itself imparts information about how it is used.
    For example, your naming convention may be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有大量机器时，设置一个命名约定可能值得考虑，其中机器的名称本身传达了有关其用途的信息。例如，您的命名约定可能如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, if we have a machine that acts as a load balancer for an authorization
    service in the staging environment, its hostname may be `staging.auth.lb1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一台机器在预发布环境中作为授权服务的负载均衡器，其主机名可能为 `staging.auth.lb1`。
- en: 'This is extremely useful when you log in to multiple servers using the terminal—they
    all look the same! The only way for you to figure out which machine you''re working
    on is by looking at the hostname printed in the prompt:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您使用终端登录多个服务器时非常有用——它们看起来都一样！您确定正在操作哪台机器的唯一方法是通过查看提示中打印的主机名：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you''re only setting up servers for personal use, feel free to get creative
    with the names. Popular conventions include using names of planets, periodic elements,
    animals, and car models. Personally, I name my machines after different components
    found in a cell: nucleus, nucleolus, vesicle, cytoplasm, lysosome, and ribosomes.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只为个人使用设置服务器，请随意发挥创意命名。流行的惯例包括使用行星、周期性元素、动物和汽车型号的名称。我个人会根据细胞中不同的组成部分来命名我的机器：细胞核、核仁、囊泡、细胞质、溶酶体和核糖体。
- en: Another article worth reading is *Choosing a Name for Your Computer* ([ietf.org/rfc/rfc1178](https://www.ietf.org/rfc/rfc1178)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一篇值得阅读的文章是 *为您的计算机命名* ([ietf.org/rfc/rfc1178](https://www.ietf.org/rfc/rfc1178))。
- en: For now, since we only have one machine, let's specify a simple name, `hobnob`,
    and click Create!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，因为我们只有一台机器，让我们指定一个简单的名称，`hobnob`，然后点击创建！
- en: Connecting to the VPS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 VPS
- en: 'After you click Create, DigitalOcean will provision a new VPS for you. You''ll
    also receive an email with instructions on how to log in:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建后，DigitalOcean 将为您配置一个新的 VPS。您还将收到一封包含登录说明的电子邮件：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these credentials, connect to your server as the `root` administrative
    user using SSH:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些凭证，通过SSH以`root`管理员用户连接到您的服务器：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, `<server-ip>` is the IP address of your server (`142.93.241.63` in our
    examples). This will prompt you for your password; enter the one you received
    in your email. After logging in, the server will ask you to change your root password:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<server-ip>`是您服务器的IP地址（在我们的示例中为`142.93.241.63`）。这将提示您输入密码；输入您在电子邮件中收到的密码。登录后，服务器将要求您更改root密码：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! You have successfully created a virtual server and logged in to it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！您已成功创建虚拟服务器并登录到其中。
- en: For the code blocks in this chapter, we will add the `<user>@hobnob:` prompt
    before any commands that are meant to run on the remote virtual server, and the
    normal prompt, `$`, for commands that should be run locally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的代码块，我们将在任何旨在在远程虚拟服务器上运行的命令之前添加`<user>@hobnob:`提示，对于应在本地运行的命令，我们将使用正常的提示`$`。
- en: Setting up user accounts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户账户
- en: At the moment, we are logging in as `root`, which is the administrative user
    of the machine with all privileges. This means a `root` user can do dangerous
    things, such as deleting every file in the system with `rm -rf /`. If a malicious
    user gains access to your `root` account, or if you accidentally issue the wrong
    command, then there's no turning back; most of these actions are irreversible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们是以`root`身份登录的，这是具有所有权限的机器的管理用户。这意味着`root`用户可以执行危险的操作，例如使用`rm -rf /`删除系统中的所有文件。如果恶意用户获得了您的`root`账户访问权限，或者您不小心发出了错误的命令，那么就无法回头了；大多数这些操作都是不可逆的。
- en: Therefore, to protect our server from both malicious parties and human error,
    it's advisable to not use `root` on an everyday basis. Instead, we should set
    up an account with reduced privileges, and only use root privileges when we need
    to (for example, when installing system-wide software).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了保护我们的服务器免受恶意行为和人为错误的侵害，建议不要在日常使用中频繁使用`root`。相反，我们应该设置一个具有降低权限的账户，并且只有在需要时（例如，安装系统级软件时）才使用root权限。
- en: Creating a new user
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'First, we must create a new user. While still logged in as `root`, run `adduser
    <username>`, replacing `<username>` with your username (we will use `hobnob` as
    the username going forward). This will initiate a wizard that asks you for details
    about the user, and for you to enter a password. After this, a new user with the
    username `hobnob` will be created, with their own home directory located at `/home/hobnob`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个新用户。在仍然以`root`身份登录的情况下，运行`adduser <username>`，将`<username>`替换为您的用户名（我们将使用`hobnob`作为用户名）。这将启动一个向导，要求您提供有关用户的信息，并输入密码。之后，将创建一个名为`hobnob`的新用户，其主目录位于`/home/hobnob`：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have a user with reduced privileges, we can use it to execute everyday
    commands. Try logging in using a different terminal, with the username and password
    of your new user:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有降低权限的用户，我们可以使用它来执行日常命令。尝试使用不同的终端，使用您新用户的用户名和密码登录：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great! We''ve created a user account with reduced privileges and are able to
    access the server with this new account. But because it has limited privileges,
    we won''t be able to perform even simple administrative tasks. Try updating the
    package lists by running `apt update`; it will produce an error that says `Permission
    denied` because this action requires root privileges:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经创建了一个具有降低权限的用户账户，并且能够使用这个新账户访问服务器。但是，由于权限有限，我们甚至无法执行简单的管理任务。尝试通过运行 `apt
    update` 来更新软件包列表；这将产生一个错误，显示 `Permission denied`，因为这个操作需要root权限：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if we run the same command with our `root` user, it executes successfully:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们用我们的`root`用户运行相同的命令，它将成功执行：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding a user to the sudo group
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户添加到sudo组
- en: If we are to use our `hobnob` account on a day-to-day basis, it would be annoying
    to have to switch to the `root` account every time we want to install something.
    Luckily, in Linux permissions can be assigned to each user, as well as to a named
    *group* of users. Linux provides a `sudo` group, which allows users within that
    group to run commands requiring `root` privileges, simply by prepending the command
    with the `sudo` keyword and providing their password. Therefore, we should add
    our `hobnob` user account to the `sudo` group.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在日常使用中经常使用`hobnob`账户，每次想要安装东西时都需要切换到`root`账户将会很烦人。幸运的是，在Linux中，可以为每个用户以及命名的用户组分配权限。Linux提供了一个`sudo`组，允许该组内的用户通过在命令前加上`sudo`关键字并输入他们的密码来运行需要`root`权限的命令。因此，我们应该将我们的`hobnob`用户账户添加到`sudo`组中。
- en: 'While still logged in as `root`, run the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然以 `root` 身份登录的情况下，运行以下命令：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-G` option specifies the group we are adding the user to, and the `-a` flag
    appends the user to the group without removing them from other groups.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`-G` 选项指定我们将用户添加到的组，而 `-a` 标志会将用户添加到该组中，而不会从其他组中删除他们。'
- en: Now, try running `sudo apt update` from the `hobnob` account; it will prompt
    you for your password, and then it will execute the command as if you're the `root`
    user!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试以 `hobnob` 账户运行 `sudo apt update`；它将提示您输入密码，然后它将像 `root` 用户一样执行该命令！
- en: Setting up public key authentication
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置公钥认证
- en: 'So far, we have been using password-based authentication to gain access to
    our server; this is cumbersome and insecure, as malicious parties can gain access
    to your server simply by guessing your password. It''s better to use public key
    authentication, which has the following benefits:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用基于密码的认证来访问我们的服务器；这既麻烦又不安全，因为恶意方只需猜测您的密码即可访问您的服务器。最好使用公钥认证，它有以下好处：
- en: 'Infeasible to guess: Passwords tend to have a number of common patterns (for
    example, `abcd1234` or `password`), whereas SSH keys look like gibberish and are
    hard to brute-force'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可猜测：密码往往有几种常见的模式（例如，`abcd1234` 或 `password`），而 SSH 密钥看起来像是乱码，难以暴力破解
- en: Manageable: `ssh-agent` is a program that holds private keys so that you don't
    have to remember your passwords
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可管理性：`ssh-agent` 是一个程序，它可以保存私钥，这样您就不必记住密码
- en: Checking for existing SSH key(s)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查现有的 SSH 密钥
- en: 'Firstly, check whether you already have an SSH key pair set up on your local
    machine. Usually, the SSH keys are stored under a `.ssh` directory under your
    home directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查您是否已经在本地机器上设置了 SSH 密钥对。通常，SSH 密钥存储在您家目录下的 `.ssh` 目录中：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you see output similar to this, then you already have an SSH key and can
    skip ahead to the *Adding SSH key to remote server* section; otherwise, carry
    on with creating an SSH key.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似以下内容的输出，则您已经有一个 SSH 密钥，可以跳到 *将 SSH 密钥添加到远程服务器* 部分；否则，继续创建 SSH 密钥。
- en: A key is basically a very long, random string that acts in place of your password.
    When you associate a key with a server, you're able to authenticate to that server
    using that key. Therefore, you may have multiple keys, each one associated with
    a different server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥基本上是一个非常长、随机的字符串，它代替了您的密码。当您将密钥与服务器关联时，您可以使用该密钥对该服务器进行身份验证。因此，您可能有多个密钥，每个密钥都与不同的服务器关联。
- en: This also means that you can create a new key for this exercise, even if you
    have a key already. But generally, most developers have one key for each development
    machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着即使您已经有了密钥，您也可以为这次练习创建一个新的密钥。但通常，大多数开发者为每台开发机器有一个密钥。
- en: Creating an SSH key
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SSH 密钥
- en: 'We will use a program called `ssh-keygen` to generate our SSH key. Run the
    following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为 `ssh-keygen` 的程序来生成我们的 SSH 密钥。运行以下命令：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are passing a few parameters to `ssh-keygen`, which instructs it to
    use the **Rivest-Shamir-Adleman** (**RSA**) cryptographic algorithm to generate
    key pairs of 4,096 bits in length. By default, `ssh-keygen` uses a key length
    of 2,048 bits, which should be sufficient, but since 4,096 is significantly harder
    to brute-force, why not enjoy that bit of extra security?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 `ssh-keygen` 传递了一些参数，指示它使用 **Rivest-Shamir-Adleman**（**RSA**）加密算法生成长度为
    4,096 位的密钥对。默认情况下，`ssh-keygen` 使用 2,048 位的密钥长度，这应该足够了，但既然 4,096 位更难暴力破解，为什么不享受那一点额外的安全性呢？
- en: There are many algorithms that can be used to generate key pairs. `ssh-keygen`
    accepts **DSA**, **RSA**, **Ed25519**, and **ECDSA**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多算法来生成密钥对。`ssh-keygen` 接受 **DSA**、**RSA**、**Ed25519** 和 **ECDSA**。
- en: DSA is an old algorithm that is superseded by RSA, and should not be used. Ed25519
    and **Elliptic Curve Digital Signature Algorithm** (**ECDSA**) are from a newer
    breed of cryptographic algorithms that rely on the mathematical properties of
    some very particular elliptical *curves*. They may potentially supersede RSA,
    as they can provide the same level of security but with shorter keys.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: DSA 是一种过时的算法，已被 RSA 取代，不应使用。Ed25519 和 **椭圆曲线数字签名算法**（**ECDSA**）是新一代的加密算法，依赖于某些非常特定的椭圆曲线的数学性质。它们可能最终会取代
    RSA，因为它们可以提供相同级别的安全性，但密钥更短。
- en: You can use ECDSA in place of RSA by running `ssh-keygen -t ecdsa -b 521` instead
    (note that `521` is *not* a typo), or Ed25519 by running `ssh-keygen -t ed25519`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `ssh-keygen -t ecdsa -b 521`（注意 `521` 不是一个打字错误）来使用 ECDSA 替代 RSA，或者通过运行
    `ssh-keygen -t ed25519` 来使用 Ed25519。
- en: 'After you execute the command, a wizard will ask you several questions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，向导将询问您几个问题：
- en: '`Enter file in which to save the key`: By default, the keys will be saved under
    the `.ssh` directory in your home directory.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入保存密钥的文件`：默认情况下，密钥将被保存在您家目录下的`.ssh`目录下。'
- en: '`Enter passphrase`/`Enter same passphrase again`: Anyone with access to your
    private key will be able to log in to your server. If you want extra security
    measures to protect your private key, you can set a password on it. Doing so means
    that only people who have your private key *and* your password are able to log
    in.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入密码`/`再次输入相同的密码`：任何有权访问您的私钥的人都能登录到您的服务器。如果您想采取额外的安全措施来保护您的私钥，您可以在其上设置密码。这样做意味着只有拥有您的私钥和密码的人才能登录。'
- en: Programs that run inside environments where user input is not possible may have
    to use an SSH key without a passphrase; otherwise, having a passphrase is recommended.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法进行用户输入的环境中运行的程序可能必须使用不带密码的SSH密钥；否则，建议设置密码。
- en: 'After you''ve answered those questions, `ssh-keygen` will generate a private
    key (`id_rsa`)/public key (`id_rsa.pub`) pair and save them under the `~/.ssh` directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答了这些问题后，`ssh-keygen`将生成一个私钥（`id_rsa`）/公钥（`id_rsa.pub`）对，并将它们保存在`~/.ssh`目录下：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you do not set a passphrase on your private key, anyone with your private
    key is able to gain access to any servers that use the corresponding public key
    to authenticate you. Therefore, generally speaking, **never share your private
    key**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有在您的私钥上设置密码，任何拥有您的私钥的人都能访问使用相应公钥来验证您的任何服务器。因此，一般来说，**永远不要共享您的私钥**。
- en: Adding the SSH key to the remote server
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SSH密钥添加到远程服务器
- en: Now that we have an SSH key pair, we need to set up our virtual server to accept
    this key.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了SSH密钥对，我们需要设置我们的虚拟服务器以接受这个密钥。
- en: 'On your local machine, use the `cat` command to print out the content of your
    public key to the terminal and copy it to your clipboard (for example, using *Ctrl*
    + *Shift* + *C*):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地机器上，使用`cat`命令将您的公钥内容打印到终端并复制到剪贴板（例如，使用*Ctrl* + *Shift* + *C*）：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alternatively, you can use `xclip` to copy the content of your public key directly
    to your clipboard.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`xclip`将您的公钥内容直接复制到剪贴板。
- en: '`$ xclip -selection clipboard < ~/.ssh/id_rsa.pub`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ xclip -selection clipboard < ~/.ssh/id_rsa.pub`'
- en: 'Now, if you haven''t done so already, log in to the remote server as `root`
    using your password. Next, create the `~/.ssh` directory and a `~/.ssh/authorized_keys` file,
    if they do not already exist. The `authorized_keys` file lists the keys that the
    server accepts as valid credentials:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您还没有这样做，请使用您的密码以`root`身份登录到远程服务器。接下来，如果它们尚未存在，创建`~/.ssh`目录和`~/.ssh/authorized_keys`文件。`authorized_keys`文件列出了服务器接受的有效凭据的密钥：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, set the permissions on the file so that only the current user (`root`)
    can read the file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置文件的权限，以确保只有当前用户（`root`）可以读取该文件：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, append the public key you just copied to the end of the `authorized_keys`
    file (for example, using `vim` or `nano`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将您刚刚复制的公钥追加到`authorized_keys`文件的末尾（例如，使用`vim`或`nano`）：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we need to reload the SSH daemon to ensure our changes are updated:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要重新加载SSH守护进程以确保我们的更改已更新：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test that this is working, open a new terminal window and run `ssh root@<remote-ip>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这是否正常工作，打开一个新的终端窗口并运行`ssh root@<remote-ip>`：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, the server doesn't ask for your password anymore, as it is using
    our SSH key to authenticate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，服务器不再要求您输入密码，因为它正在使用我们的SSH密钥进行验证。
- en: Using ssh-copy-id
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ssh-copy-id
- en: 'Next, we need to do the same for our `hobnob` user. But this time, we''re going
    to use a handy command line tool, `ssh-copy-id`, which will do everything described
    previously, but with a single command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的`hobnob`用户做同样的事情。但这次，我们将使用一个方便的命令行工具`ssh-copy-id`，它将执行之前描述的所有操作，但只需一个命令：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Providing extra security
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供额外的安全
- en: Before we move on, there are a few additional measures we can take to make our
    setup more secure.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们可以采取一些额外的措施来使我们的设置更加安全。
- en: Disable password-based authentication
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用基于密码的认证
- en: While we can now log in with our SSH key, we are still allowing logins via password.
    A chain is only as strong as its weakest link, and a system is only as secure
    as its least secure component. Therefore, now that we can log in using SSH, it's
    best to disable login via password.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在可以使用SSH密钥登录，但我们仍然允许通过密码登录。一个链条的强度取决于其最薄弱的环节，一个系统的安全性也取决于其最不安全的组件。因此，既然我们可以使用SSH登录，最好是禁用密码登录。
- en: Double-check that you are able to log in to your server using your SSH key before
    disabling password-based authentication; otherwise, you'll be locked out of the
    server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在禁用基于密码的认证之前，请务必确认您可以使用SSH密钥登录到您的服务器；否则，您将被锁定在服务器之外。
- en: 'On the remote virtual server, open up the configuration file for the SSH daemon
    at `/etc/ssh/sshd_config` (note that this is not the same as `/etc/ssh/ssh_config`,
    which is the configuration file for the *SSH client*). Search for an entry called `PasswordAuthentication`
    and set it to `no`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程虚拟服务器上，打开SSH守护进程的配置文件`/etc/ssh/sshd_config`（请注意，这不同于`/etc/ssh/ssh_config`，后者是*SSH客户端*的配置文件）。搜索名为`PasswordAuthentication`的条目并将其设置为`no`：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, reload the SSH daemon to ensure that it is updated with our changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，重新加载SSH守护进程以确保它已更新我们的更改：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Disable root login
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用root登录
- en: We shouldn't stop there. Now that we have access to a user with `sudo` privileges,
    we don't need to log in as `root` anymore. Therefore, we should disable root login
    through another configuration entry in the `sshd_config`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该就此止步。现在我们已经可以访问具有`sudo`权限的用户，我们不再需要以`root`身份登录。因此，我们应该通过`sshd_config`中的另一个配置条目禁用root登录。
- en: 'Find the `PermitRootLogin` entry and set that to `no`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`PermitRootLogin`条目并将其设置为`no`：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Reload the SSH daemon to ensure that this change takes effect:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载SSH守护进程以确保此更改生效：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, from your local machine, try to log in as `root`; you should get an error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从你的本地机器尝试以`root`身份登录；你应该会收到一个错误：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Firewall
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防火墙
- en: The last step in securing our server is to install a firewall. The idea behind
    a firewall is that every exposed port is a potential security vulnerability. Therefore,
    we want to expose as few ports as possible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 保障我们服务器安全性的最后一步是安装防火墙。防火墙背后的理念是每个暴露的端口都是一个潜在的安全漏洞。因此，我们希望尽可能少地暴露端口。
- en: 'All Linux distributions come with a firewall called `iptables`, which, by default, allows
    all traffic to pass through. Configuring `iptables` by hand can be challenging
    as the format is not the most intuitive. For example, an inactive `iptables` configuration
    looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Linux发行版都自带一个名为`iptables`的防火墙，默认情况下允许所有流量通过。手动配置`iptables`可能具有挑战性，因为其格式不是最直观的。例如，一个非活动的`iptables`配置看起来像这样：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To help system administrators to manage the `iptables` firewall more easily,
    the Ubuntu distribution comes with a command-line program called `ufw` (short
    for **u**ncomplicated **f**ire**w**all), which we will use here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助系统管理员更容易地管理`iptables`防火墙，Ubuntu发行版附带了一个名为`ufw`的命令行程序（简称为**u**ncomplicated
    **f**ire**w**all），我们将在这里使用它。
- en: '`ufw` is inactive by default, but before we enable it, let''s add some rules
    for it to enforce:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw`默认情况下是禁用的，但在我们启用它之前，让我们为它添加一些规则来强制执行：'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only port we need to expose right now is the one for SSH, which is port
    `22`. We can do this by adding individual ports directly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要暴露一个端口，那就是SSH端口`22`。我们可以通过直接添加单个端口来实现这一点：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, there''s an easier way: services may register their *profiles* with
    `ufw`, allowing `ufw` to manage their ports *by name*. You can view a list of
    registered applications by running `ufw app list`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个更简单的方法：服务可以将其*配置文件*注册到`ufw`，允许`ufw`通过名称管理它们的端口。您可以通过运行`ufw app list`来查看已注册应用程序的列表：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Therefore, instead of specifying port `22`, we can specify the name of the
    application instead:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必指定端口`22`，我们可以指定应用程序的名称：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now the rules are in place, we can enable `ufw`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在规则已经就位，我们可以启用`ufw`：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, when we check again, only the OpenSSH port (`22`) is opened:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次检查时，只有OpenSSH端口（`22`）是开放的：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuring the time zone
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置时区
- en: 'Lastly, we should configure all our servers to use the UTC time zone. Using
    a single time zone prevents us from having to keep track of which server is on
    which time zone when accessing multiple servers at the same time:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将所有服务器配置为使用协调世界时（UTC）时区。使用单一时区可以防止我们在同时访问多个服务器时需要跟踪每个服务器所在的时区：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you have run the command, you''ll be presented with the following screen.
    Use your up/down arrow keys to select None of the above. Then, use your left/right
    arrow keys to select OK and press Return:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令后，你会看到以下屏幕。使用你的上/下箭头键选择“以上皆不是”。然后，使用你的左/右箭头键选择“确定”并按回车键：
- en: '![](img/251432d7-cdcf-449c-a90e-1014c9317761.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/251432d7-cdcf-449c-a90e-1014c9317761.png)'
- en: 'On the next screen, select UTC, which stands for **Universal Time Coordinated**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，选择UTC，代表**协调世界时**：
- en: '![](img/018ffde0-6dcc-492d-a687-2fe0826387d2.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/018ffde0-6dcc-492d-a687-2fe0826387d2.png)'
- en: 'You should get a confirmation on your Terminal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上获得确认：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have now set our time zone, but to ensure the clock is accurate, we need
    to perform an additional step to keep it in sync with the global NTP servers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了时区，但为了确保时钟准确，我们需要执行一个额外的步骤，使其与全球NTP服务器保持同步：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will install and run the `ntp` daemon, which will automatically start when
    booting up, synchronize with these global NTP servers, and update the system's
    time if necessary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装并运行 `ntp` 守护进程，它将在启动时自动启动，与这些全球NTP服务器同步，并在必要时更新系统时间。
- en: Congratulations! You have now successfully set up and secured a VPS! We can
    now move on to deploying our API on it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已成功设置并保护了一个VPS！我们现在可以继续部署我们的API到上面。
- en: Running our API
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的API
- en: 'Before we can run our API on the VPS, we need to install the software and libraries
    it depends on, which include Git, Node, yarn, the**Java ****Development Kit** (**JDK**), and
    Elasticsearch:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在VPS上运行我们的API之前，我们需要安装它所依赖的软件和库，包括Git、Node、yarn、**Java开发工具包**（**JDK**）和Elasticsearch：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To prevent complications with permissions, we will place our application code
    under the `/home/hobnob/` directory and run it as the `hobnob` user. Therefore, create
    a new directory for our projects, clone our API repository from the remote repository,
    install the required version of Node.js, use `yarn` to install all dependencies,
    and serve the application:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止权限问题，我们将把我们的应用程序代码放在 `/home/hobnob/` 目录下，并以 `hobnob` 用户身份运行。因此，创建一个新的项目目录，从远程仓库克隆我们的API仓库，安装所需的Node.js版本，使用
    `yarn` 安装所有依赖项，并运行应用程序：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you want to place the API in a directory outside of the user's home directory,
    such as `/srv/` or `/var/www/`, then you can't use nvm, because nvm installs the
    Node.js binary under the installer's home directory. Instead, you'd need to install
    Node.js globally using an npm package called `n` ([github.com/tj/n](https://github.com/tj/n)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将API放置在用户主目录之外的目录中，例如 `/srv/` 或 `/var/www/`，那么您不能使用nvm，因为nvm会将Node.js二进制文件安装到安装者的主目录下。相反，您需要使用名为
    `n` 的npm包全局安装Node.js ([github.com/tj/n](https://github.com/tj/n))。
- en: What you *absolutely must not* do is run the API as the `root` user, because
    it poses a huge security risk.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您绝对不能做的事情是作为 `root` 用户运行API，因为这会带来巨大的安全风险。
- en: 'Next, we need to set the correct environment variables. The settings in our
    `*.env.example` files should work out of the box, so we can just copy them:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置正确的环境变量。`*.env.example` 文件中的设置应该直接可用，因此我们可以直接复制它们：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The site will now be running on the port we specified in our `.env` file, which
    is `8080`. To make it available externally, we must update our firewall to permit
    traffic going into port `8080`. Open up a new terminal and run the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 网站现在将运行在我们 `.env` 文件中指定的端口上，即 `8080`。为了使其对外可用，我们必须更新我们的防火墙，允许进入端口 `8080` 的流量。打开一个新的终端并运行以下命令：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In your browser, navigate to `http://<vps-ip-address>:8080/`, and you should
    see an error which says this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中，导航到 `http://<vps-ip-address>:8080/`，您应该会看到一个错误，内容如下：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means that Express is working; the error response is correctly telling
    us that the endpoint does not exist. Feel free to play around with the deployed
    API. It should work the same way as it did before.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Express正在工作；错误响应正确地告诉我们端点不存在。您可以随意尝试部署的API。它应该与之前一样工作。
- en: Keeping our API alive with PM2
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PM2保持我们的API运行
- en: We are running our Node.js process inside an ephemeral SSH session. When we
    log out, the host machine will kill any processes initiated during that session.
    Therefore, we need to come up with a way of keeping our process alive even after
    logging out.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在一个短暂的SSH会话中运行我们的Node.js进程。当我们登出时，主机机将杀死在该会话期间启动的所有进程。因此，我们需要想出一个方法，即使在登出后也能让我们的进程保持运行。
- en: Furthermore, no matter how good our code base is, or how complete our test plans
    are, in any application of significant size, there will be errors. Sometimes,
    these errors are fatal and crash the application. In these instances, we should
    log the error and notify the developers, but most importantly, we should restart
    the application as soon as it crashes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论我们的代码库有多好，或者我们的测试计划有多完整，在任何一个大型应用程序中，都难免会有错误。有时，这些错误是致命的，会导致应用程序崩溃。在这些情况下，我们应该记录错误并通知开发者，但最重要的是，我们应该在应用程序崩溃后立即重启它。
- en: Ubuntu provides the `upstart` daemon ([upstart.ubuntu.com](http://upstart.ubuntu.com/)),
    which can monitor a service and respawn it if it dies unexpectedly. Likewise,
    there's a popular npm package called `forever` ([github.com/foreverjs/forever](https://github.com/foreverjs/forever)),
    which does a similar job. However, I have found PM2 ([pm2.keymetrics.io](http://pm2.keymetrics.io/))
    to be the best process manager out there, so that's what we'll use in this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 提供了 `upstart` 守护进程（[upstart.ubuntu.com](http://upstart.ubuntu.com/)），它可以监控一个服务，并在服务意外死亡时重新启动它。同样，还有一个流行的
    npm 包名为 `forever`（[github.com/foreverjs/forever](https://github.com/foreverjs/forever)），它执行类似的任务。然而，我发现
    PM2（[pm2.keymetrics.io](http://pm2.keymetrics.io/)）是市面上最好的进程管理器，因此我们将在本书中使用它。
- en: 'First, install PM2 as a development dependency:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 PM2 安装为开发依赖项：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, update our `serve` npm scripts to execute `pm2 start` instead of `node`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新我们的 `serve` npm 脚本来执行 `pm2 start` 而不是 `node`：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, push these changes from your local machine and pull them into the virtual
    server. Run `yarn` again to install `pm2` and then run `yarn run serve`; now,
    our process is managed by PM2 and not our `hobnob` user. This means even if you
    log out or disconnect, our Node.js process would still continue to run:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这些更改从您的本地机器推送到虚拟服务器。再次运行 `yarn` 以安装 `pm2`，然后运行 `yarn run serve`；现在，我们的进程由
    PM2 而不是 `hobnob` 用户管理。这意味着即使您注销或断开连接，我们的 Node.js 进程仍然会继续运行：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The great thing about PM2 is that the user interface is fantastic for a CLI
    tool. If we run `npx pm2 monit`, you''ll get a dashboard with all the running
    processes, and you can use the mouse to see the status, resource usage, and other
    statistics in real time:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 的好处之一是其用户界面对于 CLI 工具来说非常出色。如果我们运行 `npx pm2 monit`，您将获得一个包含所有运行进程的仪表板，并且您可以使用鼠标实时查看状态、资源使用情况和其他统计数据：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Killing a process
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: 'To see PM2 in action, we''re going to kill our Node.js process manually, and
    see if PM2 will automatically restart it. We''ll use the `npx pm2 list` command,
    which lists all processes in a static table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 PM2 的实际运行情况，我们将手动终止 Node.js 进程，并观察 PM2 是否会自动重启它。我们将使用 `npx pm2 list` 命令，该命令以静态表格的形式列出所有进程：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, `pm2` started a new process, with a different **process ID**
    (**PID**), once the old process died. The restart count has also increased to
    1.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当旧进程死亡后，`pm2` 启动了一个新的进程，具有不同的 **进程 ID**（**PID**），并且重启次数也增加到了 1。
- en: Keeping PM2 alive
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持 PM2 运行
- en: 'PM2 will keep applications running, as long as it is running itself. But if
    PM2 itself is terminated (for example, as a result of a reboot), then we must
    also configure PM2 to automatically restart. Very conveniently, PM2 provides a
    `startup` command, which outputs a script for you to run on your terminal:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 PM2 本身正在运行，它就会保持应用程序的运行。但是，如果 PM2 本身被终止（例如，由于重启），那么我们还必须配置 PM2 以自动重启。非常方便的是，PM2
    提供了一个 `startup` 命令，它会为您在终端上运行输出一个脚本：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the script to ensure PM2 starts on boot. Now, when you log out of your terminal
    session, or when the application crashes unexpectedly, or even the whole machine
    restarts, you can be confident that your application will automatically restart
    as soon as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本以确保 PM2 在启动时启动。现在，当您从终端会话注销，或者应用程序意外崩溃，甚至整个机器重启时，您可以有信心应用程序会尽快自动重启。
- en: Running our API on port 80
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在端口 80 上运行我们的 API
- en: We are currently running our API server on port `8080`, whereas the standard
    port for HTTP requests is port `80`. It would be really inconvenient, and thus
    bad for user experience, to ask the consumers of our API to attach a port number
    to the URL for every request.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前将 API 服务器运行在端口 `8080` 上，而 HTTP 请求的标准端口是端口 `80`。要求 API 的消费者为每个请求将端口号附加到 URL
    上将非常不方便，这对用户体验来说也是不利的。
- en: 'Therefore, let''s change the port that Express is listening on from `8080`
    to `80` and see what happens. Change the `SERVER_PORT` environment variable to
    `80`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将 Express 监听的端口从 `8080` 更改为 `80`，看看会发生什么。将 `SERVER_PORT` 环境变量更改为 `80`：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, stop and delete the PM2 application, and run the `serve` script again.
    When we run it again, it will initially be successful:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，停止并删除 PM2 应用程序，再次运行 `serve` 脚本。当我们再次运行它时，它最初会成功：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, when we check its status again, PM2 will show you that the application
    has errored, and it has tried to restart it 15 times before giving up:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们再次检查其状态时，PM2 将显示应用程序已出现错误，并且在放弃之前尝试重启了 15 次：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can use the `pm2 show <name>` command to get information about a particular
    process:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `pm2 show <name>` 命令来获取特定进程的信息：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'From the output, we can see that the errors emanating from the application
    are stored at `/home/hobnob/.pm2/logs/index-error.log`, so let''s take a look
    at that to see what it says:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到应用程序产生的错误存储在 `/home/hobnob/.pm2/logs/index-error.log`，因此让我们看看它说了什么：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `EACCES 0.0.0.0:80` error means that our Node.js process does not have permission
    to access port `80`. This is because, in Linux, ports with numbers below `1024`
    are deemed **privileged**, which means they can only be bounded by processes initiated
    by the `root` user.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`EACCES 0.0.0.0:80` 错误意味着我们的 Node.js 进程没有权限访问端口 `80`。这是因为，在 Linux 中，低于 `1024`
    的端口被认为是 **特权端口**，这意味着它们只能被由 `root` 用户启动的进程绑定。'
- en: Privileged ports
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特权端口
- en: 'Apart from being bad for developer experience, there''s a more important reason
    why our API should be served on a **privileged port**: when the consumers of our
    API send us their data, they need to trust that the information they sent is only
    handled by processes that were initiated by the server administrator (often `root`),
    and not by some malicious party.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对开发者体验不好之外，还有一个更重要理由说明为什么我们的 API 应该在 **特权端口** 上提供服务：当 API 的消费者向我们发送数据时，他们需要信任他们发送的信息只由服务器管理员（通常是
    `root`）处理，而不是由某个恶意方处理。
- en: Let's suppose a malicious party somehow managed to breach our server and got
    access to an ordinary user account. If we had set our API port to a non-privileged
    port, then that malicious user could spawn a modified, rogue API service that
    binds to that port, and use it to extract sensitive information, such as user
    passwords. Now, any information sent by the client to this port would be exposed
    to the malicious party.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个恶意方以某种方式成功入侵我们的服务器并获得了普通用户账户的访问权限。如果我们已经将我们的 API 端口设置为非特权端口，那么那个恶意用户可以启动一个修改过的、恶意的
    API 服务，并将其绑定到该端口，并使用它来提取敏感信息，例如用户密码。现在，任何客户端发送到该端口的任何信息都将暴露给恶意方。
- en: However, privileged ports can only be bound by the `root` user, and so the malicious
    user won't be able to carry out the attack anymore.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，特权端口只能由 `root` 用户绑定，因此恶意用户将无法再执行攻击。
- en: Possible solutions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的解决方案
- en: 'However, we do control the server, so how can we allow our API service to run
    on port `80`? There are a few solutions, which we will outline later, but to see
    them working, we should first disable port `8080` and enable port `80`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们控制着服务器，那么我们如何允许我们的 API 服务在端口 `80` 上运行呢？我们将在稍后概述一些解决方案，但要看到它们的工作情况，我们首先应该禁用端口
    `8080` 并启用端口 `80`：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Running as root
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 root 运行
- en: The most straightforward solution is to run our Node process as `root`; in other
    words, something akin to `sudo node src/index.js`. However, this is a very bad
    idea as it poses a big security risk. If someone were to find a bug or vulnerability
    in your application, he/she can exploit it, and because the server process is
    run as `root`, the hacker can potentially do everything the `root` user can do,
    including wiping your entire machine clean or stealing data. Running the API server
    as an ordinary user will limit any potential damage to what is normally permissible
    to that user.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是将我们的 Node 进程作为 `root` 运行；换句话说，类似于 `sudo node src/index.js`。然而，这是一个非常糟糕的想法，因为它存在很大的安全风险。如果有人发现了你应用程序中的漏洞或漏洞，他/她可以利用它，因为服务器进程是以
    `root` 权限运行的，黑客可以潜在地做 `root` 用户能做的任何事情，包括清除你的整个机器或窃取数据。以普通用户身份运行 API 服务器将限制任何潜在损害到该用户通常可接受的范围。
- en: De-escalating privileges
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低权限
- en: 'There is a hack, however, which allows you to initiate the process as `root` using
    `sudo`, but de-escalate the privileges later by setting the user and group identity
    of the process to the user/group who issued the `sudo` command. We do this by
    using the environment variables `SUDO_UID` and `SUDO_GID`, and setting them using `process.setgid`
    and `process.setuid`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个技巧允许你使用 `sudo` 以 `root` 权限启动进程，但随后可以通过将进程的用户和组身份设置为发出 `sudo` 命令的用户/组来降低权限。我们通过使用环境变量
    `SUDO_UID` 和 `SUDO_GID` 并使用 `process.setgid` 和 `process.setuid` 来设置它们来完成此操作：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Setting capabilities
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置能力
- en: Another solution is to set **capabilities**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是设置 **能力**。
- en: On Linux, when a thread or process requires certain privilege(s) to perform
    an action, such as reading a file or binding to a port, it checks with a list
    of capabilities. If it has that capability, it'll be able to perform that function;
    otherwise, it can't. By default, the `root` user has all capabilities, for instance, the `CAP_CHOWN`
    capability, which allows it to change a file's UID and GID.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，当线程或进程需要某些权限来执行操作时，例如读取文件或绑定到端口，它会检查权限列表。如果它具有该权限，它将能够执行该功能；否则，它不能。默认情况下，`root`
    用户具有所有权限，例如，`CAP_CHOWN` 权限，它允许它更改文件的 UID 和 GID。
- en: 'Therefore, rather than running the process as `root`, we can simply grant our
    Node process the capability of binding to privileged ports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必以 `root` 身份运行进程，而可以简单地授予我们的 Node 进程绑定到专用端口的权限：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can check that the capability is set for this process by running `getcap`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `getcap` 来检查此进程是否设置了权限：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, when we run `npx pm2 delete 0; yarn run serve`, it'll successfully bind
    to port `80`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 `npx pm2 delete 0; yarn run serve` 时，它将成功绑定到端口 `80`。
- en: 'However, if we update our version of Node.js using nvm, we''d have to set the
    capabilities again for this new version of Node. Furthermore, this capability
    is not limited to binding to port `80`; it''s for binding to *all* privileged
    ports. This is a potential security vulnerability. Therefore, it''s best not to
    use this approach and we should unset the capabilities:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用 nvm 更新 Node.js 版本，我们就必须为这个新版本的 Node 设置权限。此外，这个权限不仅限于绑定到端口 `80`；它是用于绑定到
    **所有** 专用端口的。这是一个潜在的安全漏洞。因此，最好不使用这种方法，我们应该取消设置权限：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Using authbind
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 authbind
- en: 'Using `authbind` as an alternative may be preferable to setting capabilities.
    `authbind` is a system utility that allows users without superuser privileges
    to access privileged network services, including binding to privileged ports:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `authbind` 作为替代方案可能比设置权限更可取。`authbind` 是一个系统实用程序，允许没有超级用户权限的用户访问特权网络服务，包括绑定到特权端口：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In contrast to setting capabilities, `authbind` allows more fine-grained control
    with regard to the port and permissions it is granting. Configuration files for
    `authbind` can be found at `/etc/authbind`. In short, if a user has permission
    to access the `/etc/authbind/byport/<port>` file, then that user is able to bind
    to that port:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置权限相比，`authbind` 在端口和权限方面提供了更细粒度的控制。`authbind` 的配置文件位于 `/etc/authbind`。简而言之，如果用户有权访问
    `/etc/authbind/byport/<port>` 文件，则该用户能够绑定到该端口：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we are creating a configuration file for port `80`, changing its owner
    to be the user running the API server, and setting its permission so that only
    `hobnob` can read it. Now, we can run our start script with `authbind` and it
    should work:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为端口 `80` 创建一个配置文件，将其所有者更改为运行 API 服务器用户，并设置权限，以便只有 `hobnob` 可以读取它。现在，我们可以使用
    `authbind` 运行我们的启动脚本，并且它应该可以工作：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using iptables
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 iptables
- en: 'Another solution is to use `iptables`, which is the same firewall we used before.
    Apart from blocking out traffic from certain ports, `iptables` also allows you
    to redirect traffic from one port to another. Therefore, we can simply route all
    traffic entering port `80` to port `8080`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用 `iptables`，这是我们之前使用的同一防火墙。除了阻止来自某些端口的流量外，`iptables` 还允许您将流量从一个端口重定向到另一个端口。因此，我们可以简单地将所有进入端口
    `80` 的流量路由到端口 `8080`：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Using reverse proxy
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理
- en: As you can appreciate, there are many ways of binding to port `80` as a non-root
    user, and our list is not even exhaustive! However, the most popular method is
    to use a **reverse proxy** server to redirect traffic from one port to another.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所欣赏的，作为非 root 用户绑定到端口 `80` 的方法有很多，而且我们的列表甚至不是详尽的！然而，最流行的方法是使用 **反向代理** 服务器将流量从一个端口重定向到另一个端口。
- en: What's a proxy? What's a reverse proxy?
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是代理？什么是反向代理？
- en: A **proxy** is a server used by the client to indirectly access other servers.
    From the perspective of the server, it will view the proxy server as the client,
    and be oblivious to the original client. Proxy servers are the intermediary servers
    that your request passes through when it tries to get from your machine to the
    remote server.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理** 是客户端用于间接访问其他服务器的服务器。从服务器的角度来看，它将把代理服务器视为客户端，而不会意识到原始客户端。代理服务器是您请求在从您的机器到远程服务器时经过的中介服务器。'
- en: 'A **reverse proxy** is the same, but the scheme is flipped. This is how a reverse
    proxy works:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向代理**与此类似，但方案是颠倒的。这是反向代理的工作原理：'
- en: The reverse proxy receives a request
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向代理接收请求
- en: It relays the request to the proxied service (for example, an application server,
    such as our Express application)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将请求转发到代理服务（例如，一个应用程序服务器，如我们的Express应用程序）
- en: It receives the response from the service
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从服务接收响应
- en: It sends the response back to the client(s)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将响应发送回客户端（们）
- en: The client is oblivious to the fact that there's an internal service; in the
    client's view, the response came directly from the reverse proxy.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对内部服务的存在一无所知；在客户端看来，响应是直接从反向代理返回的。
- en: 'The most popular reverse proxy today is NGINX, and that''s what we''ll use
    in this book. NGINX is also a generic web server, which provides the following
    benefits:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的最流行的反向代理是NGINX，这正是我们在本书中要使用的。NGINX也是一个通用的Web服务器，它提供了以下好处：
- en: We can host multiple services on the same server; this provides greater flexibility
    if we are to add extra services running on the same server later.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在同一台服务器上托管多个服务；如果我们以后要添加在同一台服务器上运行的其他服务，这将提供更大的灵活性。
- en: It can handle SSL encryption, which is required for setting up HTTPS.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以处理SSL加密，这是设置HTTPS所必需的。
- en: It supports features such as caching and GZIP compression.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持诸如缓存和GZIP压缩等特性。
- en: It can also act as a load balancer; this allows us to run multiple instances
    of our Node application, all on different ports, and have NGINX distribute the
    requests across these processes. It'll do so in a way that minimizes the load
    on any particular process, and thus maximizes the speed at which a response can
    be generated.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还可以充当负载均衡器；这允许我们在不同的端口上运行我们的Node应用程序的多个实例，并且让NGINX在这些进程之间分配请求。它将以最小化特定进程负载的方式这样做，从而最大化响应生成的速度。
- en: Configuration as code; since all HTTP traffic goes through NGINX, it's easy
    to see a list of all the services that we are exposing to the external world simply
    by reading NGINX's configurations.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置为代码；由于所有HTTP流量都通过NGINX转发，因此只需阅读NGINX的配置，就可以轻松看到我们向外部世界公开的所有服务的列表。
- en: It has an additional layer of abstraction; we can change how we structure the
    application internally, and all we have to do is update the NGINX settings. For
    example, we can have the service run on a different machine within a private network,
    and our external users would not know the difference.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个额外的抽象层；我们可以更改应用程序内部的架构，我们只需要更新NGINX设置。例如，我们可以让服务在私有网络中的另一台机器上运行，而外部用户不会察觉到任何区别。
- en: Setting up NGINX
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NGINX
- en: So let's get NGINX installed on our machine!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们在我们的机器上安装NGINX吧！
- en: We will outline the installation instructions for NGINX on Ubuntu. Installation
    for other platforms can be found at [nginx.com/resources/wiki/start/topics/tutorials/install/](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将概述在Ubuntu上安装NGINX的说明。其他平台的安装说明可以在[nginx.com/resources/wiki/start/topics/tutorials/install/](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/)找到。
- en: 'By default, the `nginx` package should already be in Ubuntu''s default repositories:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`nginx`软件包应该已经包含在Ubuntu的默认仓库中：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, we should use the official NGINX repository to ensure we *always* get
    the most up-to-date version. To do this, we need to add NGINX's package repository
    to the list of repositories that Ubuntu will search for when it tries to download
    packages.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该使用官方的NGINX仓库以确保我们*始终*获取最新版本。为此，我们需要将NGINX的软件包仓库添加到Ubuntu在尝试下载软件包时搜索的仓库列表中。
- en: 'By default, there are two places that Ubuntu will search: inside the `/etc/apt/sources.list`
    file and inside files under the `/etc/apt/sources.list.d/` directory. We should
    not write directly to the `/etc/apt/sources.list` file because when we upgrade
    our distribution, this file will be overwritten. Instead, we should create a new
    file with a unique name inside the `/etc/apt/sources.list.d/` directory, and add
    the entry for the NGINX repository:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ubuntu会搜索两个地方：在`/etc/apt/sources.list`文件内部以及`/etc/apt/sources.list.d/`目录下的文件中。我们不应该直接写入`/etc/apt/sources.list`文件，因为当我们升级我们的发行版时，此文件将被覆盖。相反，我们应该在`/etc/apt/sources.list.d/`目录内创建一个具有唯一名称的新文件，并添加NGINX仓库的条目：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you ever delete your `/etc/apt/sources.list` file by accident, you can regenerate
    it using the Ubuntu Sources List Generator ([repogen.simplylinux.ch](https://repogen.simplylinux.ch/)).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意外删除了`/etc/apt/sources.list`文件，你可以使用Ubuntu源列表生成器([repogen.simplylinux.ch](https://repogen.simplylinux.ch/))重新生成它。
- en: 'To ensure the integrity and authenticity of the package they download, the
    Ubuntu package management tools (`dpkg` and `apt`) require package distributors
    to sign their packages using a publicly available GPG key. Therefore, we must
    add this key to APT so that it knows how to check the integrity and authenticity
    of the packages:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保他们下载的软件包的完整性和真实性，Ubuntu 软件包管理工具（`dpkg` 和 `apt`）要求软件包分发商使用公开可用的 GPG 密钥对他们的软件包进行签名。因此，我们必须将此密钥添加到
    APT 中，以便它知道如何检查软件包的完整性和真实性：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'NGINX is now installed, but it is not yet running:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 现已安装，但尚未运行：
- en: '[PRE64]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Configuring NGINX
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 NGINX
- en: 'Before we start NGINX, we need to configure it. Like other system-wide services,
    configuration files for NGINX are stored under the `/etc/` directory. Navigate
    to `/etc/nginx/` and have a look at the files there:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置 NGINX 之前，我们需要对其进行配置。和其他系统级服务一样，NGINX 的配置文件存储在 `/etc/` 目录下。导航到 `/etc/nginx/`
    并查看那里的文件：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The main configuration is defined inside `nginx.conf`, which looks like this
    (once comments are removed):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 主要配置定义在 `nginx.conf` 文件内，其结构如下（一旦移除注释）：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Understanding NGINX's configuration file
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 NGINX 的配置文件
- en: The NGINX server is made up of **modules**, which are controlled by **directives**
    defined inside the `nginx.conf` configuration file. For instance, the HTTP module
    is configured using the `http` directive in `nginx.conf`. A directive is basically
    a unit of instruction/setting. There are two types of directives: **simple** and
    **block**.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 服务器由**模块**组成，这些模块由 `nginx.conf` 配置文件内定义的**指令**控制。例如，HTTP 模块是通过 `nginx.conf`
    中的 `http` 指令进行配置的。指令基本上是一个指令/设置的单元。有两种类型的指令：**简单**和**块**。
- en: A simple directive consists of a name and one or more parameters, each separated
    by a space and ending with a semicolon. `pid /var/run/nginx.pid;` would be an
    example of a simple directive. On the other hand, a block directive consists of
    a name followed by a pair of braces (`{}`), inside which it may contain additional
    directives.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 简单指令由一个名称和一个或多个参数组成，每个参数由空格分隔，并以分号结尾。例如，`pid /var/run/nginx.pid;` 就是一个简单指令的例子。另一方面，块指令由一个名称后跟一对大括号（`{}`）组成，其中可以包含额外的指令。
- en: There's also the concept of **context**. The top-level directives exist inside
    the `main` context. Each block directive envelops the contained directives in
    its own context. For example, in the `nginx.conf` file, the `worker_connections`
    directive will be within the `events` context, which is itself within the `main`
    context.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还有**上下文**的概念。顶级指令存在于 `main` 上下文中。每个块指令都包含在其自己的上下文中包含的指令。例如，在 `nginx.conf` 文件中，`worker_connections`
    指令将位于 `events` 上下文中，而 `events` 上下文本身又位于 `main` 上下文中。
- en: Configuring the HTTP module
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 HTTP 模块
- en: 'To allow NGINX to route requests for a given service, we must define a `server`
    block directive within the `http` context:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许 NGINX 路由特定服务的请求，我们必须在 `http` 上下文中定义一个 `server` 块指令：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Within the `server` block, we can define certain directives that are only available
    in the `server` context. Here is a short list of the most common ones:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server` 块内，我们可以定义仅在 `server` 上下文中可用的某些指令。以下是一些最常见的指令列表：
- en: '`listen`: Which port should this service be listening to. If this is not set,
    it''ll default to port `80`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listen`：此服务应监听哪个端口。如果没有设置，它将默认为端口 `80`。'
- en: '`server_name`: Which domain name(s) should apply to this server block.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server_name`：应将哪些域名应用于此服务器块。'
- en: '`location`: How it should process requests based on the URL path. The `location`
    directive usually has two parameters. The first parameter is the **prefix**, and
    the second is another block of directives that specify how that request should
    be handled. That inner block can have the following directives:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：如何根据 URL 路径处理请求。`location` 指令通常有两个参数。第一个参数是**前缀**，第二个是另一个指令块，指定如何处理该请求。内部块可以包含以下指令：'
- en: '`root`: Used for serving static files. It tells NGINX where it can find the
    requested resources on our server.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`：用于服务静态文件。它告诉 NGINX 在我们的服务器上可以找到请求的资源的位置。'
- en: '`proxy_pass`: Used for reverse proxying. It tells NGINX the URL to which it
    should relay the request.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_pass`：用于反向代理。它告诉 NGINX 应将请求转发到哪个 URL。'
- en: When NGINX receives a request that matches the server block's `listen` and `server_name`
    directives, it will pass it to the `server` block. Then, the path of the URL of
    the request would be extracted and it will try to match with the prefixes of each
    `location` directive. If it finds a match, the request will be processed in accordance
    with the directives specified within that `location` block. If there is more than
    one `location` prefix that matches the URL, the `location` block with the longest
    (and thus most specific) prefix will be used.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `/etc/nginx/nginx.conf` and add the following server block to reverse
    proxy requests to our API server:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When NGINX receives a request at `http://142.93.241.63/`, the URL path (`/`)
    matches the prefix of the first `location` block. The `proxy_pass` directive then
    directs the request to our API, which would be running on port `8080`. NGINX will
    also relay the API's response back to the client.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s revert our change to the `SERVER_PORT` environment variable by editing
    the `envs/.env` file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, start both our API server and the NGINX service, test our API on `http://142.93.241.63/`,
    and check that everything is still working:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Splitting nginx.conf into multiple files
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, writing directly to `/etc/nginx/nginx.conf` is not a good idea because
    if we upgrade NGINX, the `nginx.conf` file may get replaced. Also, if the server
    has to handle many services, the large number of server blocks in the file will
    make it hard to read and maintain. Therefore, it's good practice to split configurations
    for different services into different files from the outset.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: A common convention is to use two directories: `/etc/nginx/sites-available`
    and `/etc/nginx/sites-enabled`. You'd place the configuration for each service
    as separate files under the `sites-available` directory. Then, to enable a service,
    you'd create a **symbolic link** from the `sites-enabled` directory to a file
    in the `sites-available` directory. Lastly, you'd link the `/etc/nginx/sites-available`
    directory to the main configuration by adding an `include` entry in the configuration.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the two directories:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, in the `/etc/nginx/nginx.conf` file, add an `include` directive after `include
    /etc/nginx/conf.d/*.conf;`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Then, pull out each `server` block from within the `http` context and place
    them, as separate files, inside `/etc/nginx/sites-available/`. By convention,
    the name of the file should correspond to the domain name, but since we don't
    have a domain yet, we can name it `api`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to clarify, `/etc/nginx/sites-available/api` should be a file with the
    following content:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, to enable the sites, we must add to the `/etc/nginx/sites-enabled` directory
    using a symbolic link:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It's very important that you use the full, absolute path when creating symbolic
    links; otherwise, you may link to the wrong location.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit to this approach is the separation of concerns: generic
    configurations reside inside the `nginx.conf` file and site-specific settings
    (for example, SSL certificates) reside within their own files. Lastly, this is
    similar to how virtual hosts are set up on the Apache HTTP server; thus, adopting
    this approach would make it easier for administrators who are accustomed to the
    Apache HTTP server to migrate over.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个好处是关注点的分离：通用配置位于 `nginx.conf` 文件中，而特定于站点的设置（例如，SSL 证书）位于它们自己的文件中。最后，这与
    Apache HTTP 服务器上设置虚拟主机的方式相似；因此，采用这种方法将使习惯于 Apache HTTP 服务器的管理员迁移变得更加容易。
- en: 'Now, we need to reload the configuration once more:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要再次重新加载配置：
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If you want to learn more about NGINX, check out the NGINX documentation at [nginx.org/en/docs/](http://nginx.org/en/docs/).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 NGINX 的信息，请查看 nginx.org 上的 NGINX 文档 [nginx.org/en/docs/](http://nginx.org/en/docs/).
- en: From IP to domain
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 IP 到域名
- en: Right now, we can access our API using an IP address. But if we want developers
    to use our API, we shouldn't expect them to remember a random sequence of numbers!
    Instead, we want to give them an easy-to-remember domain name such as `api.hobnob.social`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以使用 IP 地址访问我们的 API。但如果我们希望开发者使用我们的 API，我们不应该期望他们记住一串随机的数字！相反，我们希望给他们一个容易记住的域名，例如 `api.hobnob.social`。
- en: To do that, we must first purchase the domain name and then configure its Domain
    Name System (DNS) settings so that it will resolve to our server's IP address.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先必须购买域名，然后配置其域名系统（DNS）设置，使其解析到我们的服务器的 IP 地址。
- en: Buying a domain
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购买域名
- en: While the DNS is responsible for resolving domain names to IP addresses, a **domain
    registrar** is the entity/business that registers the domain(s) for you. There
    are many registrars available; the one we will be using is **Namecheap**.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 DNS 负责将域名解析为 IP 地址，但**域名注册商**是为你注册域名（们）的实体/业务。有许多注册商可供选择；我们将使用的是**Namecheap**。
- en: First, we must search for the domain we want on the Namecheap website. Although
    a registrar is an entity that can register domain names for many TLDs, it must
    first check with one or more **domain registries** to see whether the domain name
    is available. Domain registries collectively hold a list of all domain names and
    their availability, and domain registrars are the ones who rent an available domain
    to you for a price.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在 Namecheap 网站上搜索我们想要的域名。虽然注册商是一个可以为许多顶级域名注册域名的实体，但它必须先与一个或多个**域名注册机构**联系，以查看域名是否可用。域名注册机构共同持有所有域名及其可用性的列表，而域名注册商是那些以一定价格向您出租可用域名的实体。
- en: Go to [namecheap.com](https://www.namecheap.com/) and search for a domain you'd
    like to register (many are under US $1/year); we are going to use `hobnob.social`.
    Then, follow the onscreen instructions to complete the order.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [namecheap.com](https://www.namecheap.com/) 并搜索您想要注册的域名（许多域名的年费低于 1 美元）；我们将使用
    `hobnob.social`。然后，按照屏幕上的说明完成订单。
- en: Understanding DNS
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DNS
- en: We now have a domain name and a VPS, so it's time to associate them with each
    other. But first, we need to briefly explain how the DNS works.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个域名和一个 VPS，所以是时候将它们关联起来了。但首先，我们需要简要解释 DNS 的工作原理。
- en: The following overview is a simplification of the domain name resolution process.
    For brevity's sake, many details are left out. For a full interrogation of the
    process, please check out my blog post, *Resolving Domain Names*, which you can
    find at [blog.danyll.com/resolving-domain-names/](http://blog.danyll.com/resolving-domain-names/).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下概述是对域名解析过程的简化。为了简洁起见，省略了许多细节。对于过程的全面了解，请查看我的博客文章，*解析域名*，您可以在 [blog.danyll.com/resolving-domain-names/](http://blog.danyll.com/resolving-domain-names/)
    找到。
- en: The job of the DNS is to resolve **fully qualified domain names** (**FQDNs**)
    into IP addresses. When you type a URL in your browser, your computer would first
    look to resolve the IP locally by checking your `/etc/hosts` file. If it can't
    find it, it will pass the request on to a **resolving nameserver**, which is usually
    provided by your **internet service provider** (**ISP**). The resolving nameserver
    would first check its internal cache, and use the cached entry if available. If
    it cannot find an entry for your FQDN, it will query one of the **top-level domain**
    (**TLD**) nameservers. They will return the IP address of a **domain-level nameserver** (a.k.a.
    **domain nameserver** or **authoritative nameserver**), which is the nameserver
    that actually holds the **zone file** containing the DNS records (`A`, `CNAME`,
    `NS`, and so on) for that domain.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: DNS的职责是将**完全限定域名**（**FQDNs**）解析为IP地址。当你你在浏览器中输入一个URL时，你的电脑会首先检查你的`/etc/hosts`文件以本地解析IP。如果找不到，它将请求一个**解析域名服务器**，这通常由你的**互联网服务提供商**（**ISP**）提供。解析域名服务器会首先检查其内部缓存，如果可用则使用缓存条目。如果找不到你的FQDN的条目，它将查询**顶级域名**（**TLD**）域名服务器。它们将返回一个**域名级域名服务器**（也称为**域名服务器**或**授权域名服务器**）的IP地址，这是实际持有该域名的DNS记录（`A`、`CNAME`、`NS`等）的区域文件的服务器。
- en: The domain nameserver for the domain is usually controlled by the registrar
    that registered the domain (Namecheap, in our example). Finally, the domain nameserver
    will return the actual IP address of the FQDN to our resolving nameserver, which
    then relays that information back to us.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 域名服务器通常由注册该域名的注册商控制（在我们的例子中是Namecheap）。最后，域名服务器将返回FQDN的实际IP地址给我们的解析域名服务器，然后它将信息转回给我们。
- en: Updating the domain nameserver
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新域名服务器
- en: Therefore, to configure our domain name to resolve to our server's IP address,
    we need to update the zone file of the domain nameserver. At the moment, our domain
    is using Namecheap's domain nameserver, and we can update the zone file using Namecheap's
    administrative UI.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将我们的域名配置为解析到服务器的IP地址，我们需要更新域名服务器的区域文件。目前，我们的域名正在使用Namecheap的域名服务器，我们可以通过Namecheap的管理UI来更新区域文件。
- en: However, this approach means we'd have to manage our servers using DigitalOcean,
    and our domain using Namecheap. It'd be easier if we can carry out all the everyday
    administrative tasks using the same platform. Fortunately, DigitalOcean also has
    its own domain nameservers, which we can use.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法意味着我们不得不使用DigitalOcean来管理我们的服务器，使用Namecheap来管理我们的域名。如果能在一个平台上完成所有日常管理任务会更容易。幸运的是，DigitalOcean也有自己的域名服务器，我们可以使用。
- en: Now, all we have to do is go on Namecheap's administrative UI and update the
    TLD server to use DigitalOcean's domain nameserver, and use DO's administrative
    UI to update the zone file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在Namecheap的管理UI中更新TLD服务器以使用DigitalOcean的域名服务器，并使用DO的管理UI更新区域文件。
- en: 'Go to your Namecheap Dashboard ([ap.www.namecheap.com](https://ap.www.namecheap.com/))
    and select your domain. On the Domain tab, there should be a section named Nameservers.
    Select the Custom DNS section and add in DigitalOcean''s domain nameservers, which
    are `ns1.digitalocean.com`, `ns2.digitalocean.com`, and `ns3.digitalocean.com`.
    Then, make sure you press the green tick to save your changes:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的Namecheap控制台([ap.www.namecheap.com](https://ap.www.namecheap.com/))并选择你的域名。在域名选项卡中，应该有一个名为“Nameservers”的部分。选择自定义DNS部分，并添加DigitalOcean的域名服务器，它们是`ns1.digitalocean.com`、`ns2.digitalocean.com`和`ns3.digitalocean.com`。然后，确保按下绿色的勾号以保存你的更改：
- en: '![](img/6ff1b72e-62e3-4cdf-be44-340ac9a116fd.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ff1b72e-62e3-4cdf-be44-340ac9a116fd.png)'
- en: 'Because resolving nameservers caches results, it may take up to 48 hours for
    our changes to be propagated to all nameservers. You can use services such as [whatsmydns.net](https://www.whatsmydns.net/) to
    check the propagation progress for different nameservers around the world. Initially,
    you''ll see that they all point to the original nameservers (`dns1.registrar-servers.com`),
    but after a few minutes, many of them have changed to use DigitalOcean servers
    (`nsx.digitalocean.com`):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析域名服务器会缓存结果，我们的更改可能需要长达48小时才能传播到所有域名服务器。你可以使用如[whatsmydns.net](https://www.whatsmydns.net/)这样的服务来检查全球不同域名服务器的传播进度。最初，你会看到它们都指向原始域名服务器（`dns1.registrar-servers.com`），但几分钟后，其中许多已经改为使用DigitalOcean服务器（`nsx.digitalocean.com`）：
- en: '![](img/59452603-2ff7-4b48-b90f-a466692d4bee.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59452603-2ff7-4b48-b90f-a466692d4bee.jpg)'
- en: While we wait for our DNS changes to propagate, we can go to DigitalOcean and
    build our zone file using DigitalOcean's UI.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们等待DNS更改传播时，我们可以访问DigitalOcean并使用DigitalOcean的UI构建我们的区域文件。
- en: Building our zone file
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的区域文件
- en: A zone file is a text file that describes a **DNS zone**, which is any distinct,
    contiguous portion of the domain namespace that is managed by a single entity.
    In most cases, the boundaries of a DNS zone are confined to a single domain; thus,
    *for our purposes only*, a DNS zone is the same as a domain.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 区域文件是一个文本文件，它描述了一个**DNS区域**，即由单个实体管理的域名空间中的任何独立、连续的部分。在大多数情况下，DNS区域的边界局限于单个域名；因此，**就我们的目的而言**，DNS区域与域名相同。
- en: A zone file is made up of many **records**. Each record is a mapping between
    a **hostname** and a **resource**. Let's use the DigitalOcean administrative UI
    to visualize these records and build our zone file.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 区域文件由许多**记录**组成。每个记录都是**主机名**和**资源**之间的映射。让我们使用DigitalOcean管理UI来可视化这些记录并构建我们的区域文件。
- en: We are using the administrative UI provided by DigitalOcean to manage our DNS
    settings. If you have chosen a different hosting provider, the UI may be different,
    but the principle remains the same. For example, Amazon Web Services (AWS) has
    an equivalent service called Route 53.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用DigitalOcean提供的管理UI来管理我们的DNS设置。如果您选择了不同的托管提供商，UI可能会有所不同，但原则是相同的。例如，亚马逊网络服务（AWS）有一个等效的服务，称为Route
    53。
- en: 'Make sure you''re logged in to DigitalOcean''s control panel, then go to the
    Networking tab ([cloud.digitalocean.com/networking/domains](https://cloud.digitalocean.com/networking/domains)).
    Under where it says Add a domain, put in your domain name and click the Add Domain
    button:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已登录到DigitalOcean的控制面板，然后转到网络选项卡（[cloud.digitalocean.com/networking/domains](https://cloud.digitalocean.com/networking/domains)）。在“添加域名”处输入您的域名，然后点击“添加域名”按钮：
- en: '![](img/db6adf3e-1d91-4ffa-ab74-8be1d6e8e06d.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db6adf3e-1d91-4ffa-ab74-8be1d6e8e06d.png)'
- en: 'Next, you''ll be presented with a screen where we can add and update our records
    for the zone file of `hobnob.social`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个屏幕，我们可以添加和更新`hobnob.social`的区域文件记录：
- en: '![](img/f19f0768-bcdb-42ab-8cb9-eefcbd7fb14c.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f19f0768-bcdb-42ab-8cb9-eefcbd7fb14c.png)'
- en: The NS records have already been set for you, so let's talk about that first.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: NS记录已经为您设置好了，所以我们首先来谈谈这个问题。
- en: NS records
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NS记录
- en: The NS records specify the domain nameservers used for resolving hostnames to
    IP addresses. You may ask why do zone files need an NS record at all? Because
    it basically references itself. This is because NS records may have changed, and
    other servers need to be updated with the IP/hostname of the new domain nameserver.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: NS记录指定了解析主机名到IP地址所使用的域名服务器。您可能会问为什么区域文件需要NS记录？因为它基本上是引用自身的。这是因为NS记录可能会发生变化，其他服务器需要更新为新域名服务器的IP/主机名。
- en: Previously, this was pointed at `dns1.registrar-servers.com`, and was cached
    at many resolving nameservers. When these resolving nameservers query `dns1.registrar-servers.com`
    for the IP of `hobnob.social`, they see that the NS record has been updated to
    `ns1.digitalocean.com` and send the request to DigitalOcean's domain nameservers
    instead.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，它指向`dns1.registrar-servers.com`，并在许多解析名称服务器中被缓存。当这些解析名称服务器查询`dns1.registrar-servers.com`以获取`hobnob.social`的IP地址时，它们看到NS记录已更新为`ns1.digitalocean.com`，并将请求发送到DigitalOcean的域名服务器。
- en: 'We can use a program called `dig` to get the records from the zone file for
    our domain:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为`dig`的程序从区域文件中获取我们域的记录：
- en: '[PRE76]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The first value is the domain; the second is the **time-to-live** (**TTL**)
    value, which is how long this record should be cached for in seconds. The third
    value, `IN`, stands for "internet," and will be present in almost all records.
    The fourth value, `NS`, indicates that this record should be treated as an NS
    record. Lastly, the last portion is the value of the record; in this case, it's
    the hostname of DigitalOcean's domain nameservers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值是域名；第二个是**生存时间**（**TTL**）值，即此记录应缓存多长时间（以秒为单位）。第三个值`IN`代表“互联网”，几乎在所有记录中都会出现。第四个值`NS`表示此记录应被视为NS记录。最后，记录的最后一部分是记录的值；在这种情况下，它是DigitalOcean域名服务器的主机名。
- en: There are multiple NS records (and multiple domain nameservers) so that if and
    when one is down or overloaded, it can use the other domain nameservers.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个NS记录（和多个域名服务器），这样如果其中一个服务器宕机或过载，它可以使用其他域名服务器。
- en: A and AAAA
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A和AAAA
- en: The next most important record types are the `A` and `AAAA` records, which map
    a hostname to an IP address. `A` maps the host to an IPv4 address, whereas an `AAAA`
    record maps it to an IPv6 address.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最重要的记录类型是 `A` 和 `AAAA` 记录，它们将主机名映射到 IP 地址。`A` 记录将主机映射到 IPv4 地址，而 `AAAA` 记录将其映射到
    IPv6 地址。
- en: 'We want to point `api.hobnob.social` to the server that''s running our server
    (`142.93.241.63`), so we need to create the following `A` record:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 `api.hobnob.social` 指向运行我们服务器（`142.93.241.63`）的服务器，因此我们需要创建以下 `A` 记录：
- en: '[PRE77]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can also direct traffic going to `hobnob.social` to the same IP address.
    But instead of writing the full hostname (`hobnob.social`), we can replace it
    with the `@` symbol:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将前往 `hobnob.social` 的流量定向到相同的 IP 地址。但我们可以用 `@` 符号代替完整的域名（`hobnob.social`）：
- en: '[PRE78]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: There are two parameters you can set at the top of a zone file: `$ORIGIN` and `$TTL`. `$ORIGIN` should
    be set to the DNS zone's highest level of authority, which, in most cases, is
    the domain name. The `$TTL` (time-to-live) parameter indicates how long this zone
    file should be cached for by nameservers.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在区域文件顶部设置两个参数：`$ORIGIN` 和 `$TTL`。`$ORIGIN` 应设置为 DNS 区域的最高级别权限，在大多数情况下是域名。`$TTL`（生存时间）参数指示名称服务器应缓存此区域文件多长时间。
- en: In our records, we can use the `@` symbol as a placeholder/substitute for the
    `$ORIGIN` parameter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的记录中，我们可以使用 `@` 符号作为 `$ORIGIN` 参数的占位符/替代符。
- en: Since these settings often don't need to be changed, DigitalOcean has set them
    for us, but not exposed them in the administrative UI.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些设置通常不需要更改，DigitalOcean 已为我们设置它们，但未在管理界面中公开。
- en: 'Many domains also have a **catch-all** record that directs all traffic not
    specified with a record to an IP address:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 许多域名也有一个 **通配符** 记录，它将所有未指定记录的流量定向到 IP 地址：
- en: '[PRE79]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: However, using a catch-all (`*`) is not a good practice because a malicious
    party can link to your domain using a sub-domain such as `scam.hobnob.social`.
    If we do not have a catch-all record, when Google crawls that link, it will receive
    an error saying that the host cannot be reached. However, if you have a catch-all
    record, the request will be directed to your server, and your web server may opt
    to serve the default server block. This may make `scam.hobnob.social` the top
    result when people search for `hobnob.social`, which is not ideal.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用通配符（`*`）并不是一个好的做法，因为恶意方可以使用子域（如 `scam.hobnob.social`）链接到你的域名。如果我们没有通配符记录，当谷歌爬取该链接时，它将收到一个错误，表示无法到达该主机。但是，如果你有通配符记录，请求将被定向到你的服务器，并且你的网络服务器可以选择提供默认服务器块。这可能会使
    `scam.hobnob.social` 成为人们搜索 `hobnob.social` 时的顶级结果，这并不理想。
- en: Start of Authority (SOA)
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权威开始（SOA）
- en: 'The last record you need to know is the SOA record, which is a mandatory record
    in all zone files, and is used to describe the zone and configure how often nameservers
    should update the zone file for this domain. It also has a version counter that
    ensures that only the latest version of the zone file is propagated:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的最后一条记录是 SOA 记录，这是所有区域文件中的强制记录，用于描述区域并配置名称服务器应多久更新此域的区域文件。它还有一个版本计数器，确保只有区域文件的最新版本被传播：
- en: '[PRE80]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The first few values are similar to the ones in the NS records. The rest are
    as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个值与 NS 记录中的值类似。其余的如下：
- en: '`ns1.digitalocean.com` is the **primary master nameserver**, which holds the
    most up-to-date zone file. There may be **slave nameservers** that mirror the
    primary nameserver to reduce its load.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ns1.digitalocean.com` 是 **主主名称服务器**，它保存最新的区域文件。可能有 **从属名称服务器**，它们镜像主名称服务器以减少其负载。'
- en: '`dan.danyll.com` is the email for the administrator responsible for this DNS
    zone. The `@` symbol has been replaced by a period (`.`); if you have a period
    in your email address, it would be replaced by a backslash (`\`).'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dan.danyll.com` 是负责此 DNS 区域的管理员的电子邮件地址。`@` 符号已被点号（`.`）替换；如果你的电子邮件地址中包含点号，它将被反斜杠（`\`）替换。'
- en: '`<serial>` is the serial number for the zone file, which is essentially a version
    counter. Every time your zone is updated, you should also increase the serial
    number by `1`. Slave nameservers will check this serial number to determine whether
    their own zone file is outdated.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<serial>` 是区域文件的序列号，本质上是一个版本计数器。每次你的区域更新时，你也应该将序列号增加 `1`。从属名称服务器将检查此序列号以确定它们的区域文件是否过时。'
- en: '`<refresh>` is the amount of time a slave nameserver will wait before pinging
    the master server to see whether it needs to update its zone file.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<refresh>` 是从属名称服务器在ping主服务器以查看是否需要更新其区域文件之前将等待的时间。'
- en: '`<retry>` is the amount of time a slave nameserver will wait before pinging
    the master server again, if the previous connection attempt was unsuccessful.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<retry>`是从属域名服务器在再次ping主服务器之前将等待的时间长度，如果之前的连接尝试失败。'
- en: '`<expiry>` is the amount of time that the zone file should still be deemed
    to be valid, even if it was no longer able to connect to the master server to
    update it.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<expiry>`是区域文件仍然被认为是有效的时间长度，即使它已经无法连接到主服务器来更新它。'
- en: '`<negativeTTL>` is the amount of time the nameserver will cache a lookup that
    failed.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<negativeTTL>`是域名服务器缓存失败的查找的时间长度。'
- en: Again, since these values don't need to change often, and because having to
    manually update the serial number every time we update our zone file is tedious
    and error-prone, DigitalOcean has preset and hidden these values for us. DigitalOcean
    will update our SOA record for us when we update our records using DigitalOcean's
    web console.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于这些值不需要经常更改，并且由于每次我们更新区域文件时都必须手动更新序列号既麻烦又容易出错，DigitalOcean已经为我们预设并隐藏了这些值。当我们在DigitalOcean的Web控制台中更新记录时，DigitalOcean会为我们更新SOA记录。
- en: Now, just make sure you have the A record set for the `api.hobnob.social` subdomain
    and move on to the next section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请确保你已经为`api.hobnob.social`子域名设置了A记录，然后继续到下一节。
- en: Updating NGINX
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新NGINX
- en: Now that we have configured the DNS settings for our subdomain, we can update
    our NGINX configuration files to bear the name of our domain.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了子域名的DNS设置，我们可以更新我们的NGINX配置文件，使其以我们的域名命名。
- en: 'In the `/etc/nginx/sites-available` and `/etc/nginx/sites-enabled` directories,
    update the names of the files to the corresponding FQDN (without the trailing
    period):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/nginx/sites-available`和`/etc/nginx/sites-enabled`目录中，更新文件的名称为相应的FQDN（不包括尾随的点）：
- en: '[PRE81]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Lastly, update the configuration file to include a `server_name` directive.
    For example, the `api.hobnob.social` server block now looks like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新配置文件以包含`server_name`指令。例如，`api.hobnob.social`服务器块现在看起来像这样：
- en: '[PRE82]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, reload our NGINX configuration to ensure that the changes take effect:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新加载我们的NGINX配置以确保更改生效：
- en: '[PRE83]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, try sending a request to `api.hobnob.social`, and you should see the API
    server respond correctly!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试向`api.hobnob.social`发送请求，你应该看到API服务器正确响应！
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have deployed our code to a VPS and exposed it to the external
    world—first through a static IP address, and later via a domain name.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经将我们的代码部署到VPS上，并将其暴露给外部世界——首先是通过静态IP地址，然后是通过域名。
- en: In the next chapter, we are going to look into **Continuous Integration** (**CI**)
    and **Continuous Deployment** (**CD**) to see how we can automate the testing
    and deployment steps we've introduced in the last few chapters. You'll get the
    chance to work with **Travis CI** and **Jenkins**, a **build automation** tool.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**持续集成**（**CI**）和**持续部署**（**CD**），看看我们如何自动化在上一章中引入的测试和部署步骤。你将有机会与**Travis
    CI**和**Jenkins**（一个**构建自动化**工具）一起工作。
- en: Looking further ahead, in [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml),* Migrating
    to Docker* and [Chapter 18](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml),* Robust
    Infrastructure with Kubernetes*, we will use **Docker containers** and **Kubernetes** to
    make our deployment more scalable and reliable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 看得更远一些，在[第17章](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml)，*迁移到Docker*和[第18章](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml)，*使用Kubernetes构建健壮的基础设施*中，我们将使用**Docker容器**和**Kubernetes**来使我们的部署更具可扩展性和可靠性。
