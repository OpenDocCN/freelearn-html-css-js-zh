- en: Deploying Our Application on a VPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we created a robust user directory API, which is now
    ready to face the outside world. Thus, in this chapter, we'll learn how to expose
    our API to the **World Wide Web** (**WWW**). First, we will need to set up a **V****irtual
    Private Server** (**VPS**) to host and serve our API, and associate it with a public, **static
    IP** address; we will achieve both of these goals using **DigitalOcean** (**DO**), a
    popular cloud provider. Then, to make it easier for our API consumers, we'll purchase
    a **domain name** from a **domain registry**, and configure its **Domain Name
    System** (**DNS**) records to resolve the domain name to the static IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to set up and secure a VPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about **privileged ports**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep processes alive using **PM2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up **NGINX** as a **reverse proxy** to our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the architecture of the DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purchase and configure a domain name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining an IP address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The internet is a giant network of interconnected machines. For these machines
    to communicate with one another, each machine must have a unique identifier. The
    internet uses the **TCP/IP protocol** for its communication, which in turn uses
    the **IP address** as its unique identifier. So, the first requirement for exposing
    our API to the internet is to have an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are paying for internet at home, you too will have an IP address provided
    to you by your **Internet Service Provider** (**ISP**). You can check your IP
    address by using an external service such as [ipinfo.io](https://ipinfo.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This means it''s theoretically possible to host your API using your home PC,
    or even your laptop. However, doing so is problematic because of the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Most consumer-grade internet plans provide **dynamic IP addresses**, rather
    than static ones, which means your IP can change every few days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many ISPs block incoming traffic to port `80`, which is the default HTTP port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to maintain your own hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet connection speed may be slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first issue can be mitigated using **Managed DNS** services, such as **No-IP**
    ([noip.com](https://www.noip.com/)) and **Dyn** ([dyn.com](https://dyn.com/)),
    which provide a **dynamic DNS** service. These services will provide you with
    a hostname (for example, `username.no-ip.info`) and update the hostname's DNS
    **A record** to point to your machine's IP address (more on DNS records later).
    This means any requests destined for that hostname will arrive at your associated
    device. To make this work, you'd also have to install a client on your device,
    which frequently checks its own IP, and update the Managed DNS service whenever
    it changes.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue can be mitigated by using **port redirect**, which is a service
    that most Managed DNS services also provide. First, just as before, you must download
    the client to update the Managed DNS service with your dynamic IP. Then, bind
    your application to listen on a port on your machine that is not blocked by your
    ISP. Lastly, you'd have to go to the Managed DNS service and redirect all traffic
    that arrives at the hostname to your device's specified port.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic DNS simply changes a DNS record; no application traffic actually arrives
    at the Managed DNS servers. On the other hand, with port redirect, the Managed
    DNS service acts as a proxy that redirects HTTP packets. If you'd like to try
    them out, No-IP provides a Free Dynamic DNS service, which you can sign up for
    at [noip.com/free](https://www.noip.com/free).
  prefs: []
  type: TYPE_NORMAL
- en: While having a dynamic IP and using a dynamic DNS is acceptable for personal
    use, it's nowhere near reliable enough to be used for enterprise. Your IP address
    can change at any time, and this can cause connections to drop and data to get
    lost. There will also be a bit of latency between when an IP address updates and
    when the Managed DNS provider is made aware of this change, and thus you can never
    achieve 100% uptime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Businesses who host their own servers usually pay their ISP for a static IP
    and enhanced connection speeds. However, this can be costly. Take Comcast, the
    most popular and beloved broadband provider in the United States: their most basic
    consumer-grade offering, XFINITY Performance Internet, supports up to 60 Mbps
    download speed and costs $39.99 per month. However, for Comcast to assign you
    a static IP, you must subscribe to their business-grade plans. The most basic
    plan—Starter Internet—supports up to 25 Mbps speed, and costs $69.95 per month,
    or $89.90 if you''d want to include a static IP. This is just not cost-effective.'
  prefs: []
  type: TYPE_NORMAL
- en: A better alternative is to register an account with a cloud provider and deploy
    our application on a VPS. A VPS is essentially a **virtual machine** (**VM**)
    that is connected to the internet and is allocated its own static IP address.
    In terms of costs, VPS can cost as low as $0.996 per month!
  prefs: []
  type: TYPE_NORMAL
- en: You can find a list of cheap VPS hosting providers at [lowendbox.com](https://lowendbox.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Virtual Private Server (VPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many VPS providers, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Compute Cloud (Amazon EC2): [aws.amazon.com/ec2](https://aws.amazon.com/ec2/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IBM Virtual Servers: [ibm.com/cloud/virtual-servers](https://www.ibm.com/cloud/virtual-servers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Compute Engine: [cloud.google.com/compute](https://cloud.google.com/compute/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure Virtual Machines: [azure.microsoft.com/services/virtual-machines](https://azure.microsoft.com/services/virtual-machines/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rackspace Virtual Cloud Servers: [rackspace.com/cloud/servers](https://www.rackspace.com/cloud/servers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linode: [linode.com](https://www.linode.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this book, we are going to use **DigitalOcean** (**DO**, [digitalocean.com](https://www.digitalocean.com/)).
    We picked DO because it has a very intuitive user interface (UI), where everything
    (VPS, DNS, block storage, monitoring, Kubernetes) can all be managed on the same
    dashboard. This is unlike AWS, which has an outdated and cumbersome UI.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to the DO website ([digitalocean.com](https://m.do.co/c/5cc901594b32))
    and create an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use this referral link: [m.do.co/c/5cc901594b32](https://m.do.co/c/5cc901594b32);
    it will give you $10 in free credits!'
  prefs: []
  type: TYPE_NORMAL
- en: DO will ask you for your billing details, but you won't be charged until you've
    used their services. You should also set up **Two-Factor Authentication** (**2FA**)
    on your account to keep it secure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VPS instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you've successfully created your account, log in at [cloud.digitalocean.com](https://cloud.digitalocean.com/),
    click on the drop-down button that says Create, and then select Droplet.
  prefs: []
  type: TYPE_NORMAL
- en: In DO vocabulary, a droplet is the same as a VPS.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll be presented with a screen where we can configure the VPS. The first
    section on that screen is Choose an image, which is where we select the Linux
    distribution we want our VPS to run on. We are going to select the Ubuntu 18.04
    x64 option for our VPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We picked 18.04 because it is a **Long Term Support** (**LTS**) version, which
    means it will receive hardware and maintenance updates for five years, whereas
    standard Ubuntu releases are only supported for nine months. This is important
    for enterprise-level services because it ensures any security vulnerabilities
    or performance updates are treated as priority over other standard releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81bdd4b8-eedc-46bc-93e0-745f5c617f66.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram is reproduced from the Ubuntu lifecycle and release cadence page
    on the Ubuntu website (ubuntu.com/about/release-cycle[)](https://www.ubuntu.com/about/release-cycle)
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we must pick the size of our VPS. This determines the amount of resources
    (CPU, memory, storage, and bandwidth) that are available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch is very memory-intensive, and their official guide suggests using
    machines with 16-64 GB of memory. However, that is very costly. For this book, picking
    a VPS with at least 4 GB of RAM should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: We can ignore the backups and block storage options.
  prefs: []
  type: TYPE_NORMAL
- en: Block storage is extra disk space that can be associated with our VPS. For example,
    if we are hosting a file server or Image API, we may want to add extra disk space
    to store these files/images; purchasing pure disk space is much cheaper than running
    a VPS with an operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a data center region
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we must choose the data center where our VPS will reside.
  prefs: []
  type: TYPE_NORMAL
- en: Different machines on the internet communicate by sending messages to one another. A
    message must "hop" through a string of proxy servers before it arrives at the
    receiver's machine, and this takes time. Generally speaking, the more **hops**
    a message must make, the longer the latency.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should pick the data center that is closest to your target users.
    For example, if your target audience is largely based in the UK, then you'd pick
    the London data center.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting additional options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, select the following additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private networking**: This gives each VPS instance an internal IP address,
    which allows services deployed in the same data center to communicate with each
    other. At the time of this writing, this option is free and does not count towards
    your monthly bandwidth quota.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPv6**: IPv4 can support up to 4,294,967,296 unique IP addresses. The internet
    has grown so much that we are close to exceeding this limit. Therefore, IPv6 increases
    the number of bits in the IP address from 32 bits to 128 bits, yielding 340,282,366,920,938,463,463,374,607,431,768,211,456
    addresses. By checking this option, we allow users to use the IPv6 address to
    address our server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Collects system metrics on your server, such as CPU, memory,
    disk I/O, disk usage, public/private bandwidth, and alerts you when your server
    is running close to the limit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e5da637a-73d4-4426-8e4e-47820078d4d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Naming your server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, pick a hostname for your server. This will appear in the administration
    panel of DigitalOcean, so pick something you can easily remember.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have many machines, it may be worth setting up a naming convention,
    where the name of the machine itself imparts information about how it is used.
    For example, your naming convention may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For example, if we have a machine that acts as a load balancer for an authorization
    service in the staging environment, its hostname may be `staging.auth.lb1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is extremely useful when you log in to multiple servers using the terminal—they
    all look the same! The only way for you to figure out which machine you''re working
    on is by looking at the hostname printed in the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re only setting up servers for personal use, feel free to get creative
    with the names. Popular conventions include using names of planets, periodic elements,
    animals, and car models. Personally, I name my machines after different components
    found in a cell: nucleus, nucleolus, vesicle, cytoplasm, lysosome, and ribosomes.'
  prefs: []
  type: TYPE_NORMAL
- en: Another article worth reading is *Choosing a Name for Your Computer* ([ietf.org/rfc/rfc1178](https://www.ietf.org/rfc/rfc1178)).
  prefs: []
  type: TYPE_NORMAL
- en: For now, since we only have one machine, let's specify a simple name, `hobnob`,
    and click Create!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the VPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you click Create, DigitalOcean will provision a new VPS for you. You''ll
    also receive an email with instructions on how to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With these credentials, connect to your server as the `root` administrative
    user using SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<server-ip>` is the IP address of your server (`142.93.241.63` in our
    examples). This will prompt you for your password; enter the one you received
    in your email. After logging in, the server will ask you to change your root password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! You have successfully created a virtual server and logged in to it.
  prefs: []
  type: TYPE_NORMAL
- en: For the code blocks in this chapter, we will add the `<user>@hobnob:` prompt
    before any commands that are meant to run on the remote virtual server, and the
    normal prompt, `$`, for commands that should be run locally.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, we are logging in as `root`, which is the administrative user
    of the machine with all privileges. This means a `root` user can do dangerous
    things, such as deleting every file in the system with `rm -rf /`. If a malicious
    user gains access to your `root` account, or if you accidentally issue the wrong
    command, then there's no turning back; most of these actions are irreversible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to protect our server from both malicious parties and human error,
    it's advisable to not use `root` on an everyday basis. Instead, we should set
    up an account with reduced privileges, and only use root privileges when we need
    to (for example, when installing system-wide software).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we must create a new user. While still logged in as `root`, run `adduser
    <username>`, replacing `<username>` with your username (we will use `hobnob` as
    the username going forward). This will initiate a wizard that asks you for details
    about the user, and for you to enter a password. After this, a new user with the
    username `hobnob` will be created, with their own home directory located at `/home/hobnob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a user with reduced privileges, we can use it to execute everyday
    commands. Try logging in using a different terminal, with the username and password
    of your new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We''ve created a user account with reduced privileges and are able to
    access the server with this new account. But because it has limited privileges,
    we won''t be able to perform even simple administrative tasks. Try updating the
    package lists by running `apt update`; it will produce an error that says `Permission
    denied` because this action requires root privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we run the same command with our `root` user, it executes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding a user to the sudo group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are to use our `hobnob` account on a day-to-day basis, it would be annoying
    to have to switch to the `root` account every time we want to install something.
    Luckily, in Linux permissions can be assigned to each user, as well as to a named
    *group* of users. Linux provides a `sudo` group, which allows users within that
    group to run commands requiring `root` privileges, simply by prepending the command
    with the `sudo` keyword and providing their password. Therefore, we should add
    our `hobnob` user account to the `sudo` group.
  prefs: []
  type: TYPE_NORMAL
- en: 'While still logged in as `root`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `-G` option specifies the group we are adding the user to, and the `-a` flag
    appends the user to the group without removing them from other groups.
  prefs: []
  type: TYPE_NORMAL
- en: Now, try running `sudo apt update` from the `hobnob` account; it will prompt
    you for your password, and then it will execute the command as if you're the `root`
    user!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up public key authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been using password-based authentication to gain access to
    our server; this is cumbersome and insecure, as malicious parties can gain access
    to your server simply by guessing your password. It''s better to use public key
    authentication, which has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Infeasible to guess: Passwords tend to have a number of common patterns (for
    example, `abcd1234` or `password`), whereas SSH keys look like gibberish and are
    hard to brute-force'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manageable: `ssh-agent` is a program that holds private keys so that you don't
    have to remember your passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for existing SSH key(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, check whether you already have an SSH key pair set up on your local
    machine. Usually, the SSH keys are stored under a `.ssh` directory under your
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you see output similar to this, then you already have an SSH key and can
    skip ahead to the *Adding SSH key to remote server* section; otherwise, carry
    on with creating an SSH key.
  prefs: []
  type: TYPE_NORMAL
- en: A key is basically a very long, random string that acts in place of your password.
    When you associate a key with a server, you're able to authenticate to that server
    using that key. Therefore, you may have multiple keys, each one associated with
    a different server.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that you can create a new key for this exercise, even if you
    have a key already. But generally, most developers have one key for each development
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SSH key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use a program called `ssh-keygen` to generate our SSH key. Run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing a few parameters to `ssh-keygen`, which instructs it to
    use the **Rivest-Shamir-Adleman** (**RSA**) cryptographic algorithm to generate
    key pairs of 4,096 bits in length. By default, `ssh-keygen` uses a key length
    of 2,048 bits, which should be sufficient, but since 4,096 is significantly harder
    to brute-force, why not enjoy that bit of extra security?
  prefs: []
  type: TYPE_NORMAL
- en: There are many algorithms that can be used to generate key pairs. `ssh-keygen`
    accepts **DSA**, **RSA**, **Ed25519**, and **ECDSA**.
  prefs: []
  type: TYPE_NORMAL
- en: DSA is an old algorithm that is superseded by RSA, and should not be used. Ed25519
    and **Elliptic Curve Digital Signature Algorithm** (**ECDSA**) are from a newer
    breed of cryptographic algorithms that rely on the mathematical properties of
    some very particular elliptical *curves*. They may potentially supersede RSA,
    as they can provide the same level of security but with shorter keys.
  prefs: []
  type: TYPE_NORMAL
- en: You can use ECDSA in place of RSA by running `ssh-keygen -t ecdsa -b 521` instead
    (note that `521` is *not* a typo), or Ed25519 by running `ssh-keygen -t ed25519`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you execute the command, a wizard will ask you several questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enter file in which to save the key`: By default, the keys will be saved under
    the `.ssh` directory in your home directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enter passphrase`/`Enter same passphrase again`: Anyone with access to your
    private key will be able to log in to your server. If you want extra security
    measures to protect your private key, you can set a password on it. Doing so means
    that only people who have your private key *and* your password are able to log
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that run inside environments where user input is not possible may have
    to use an SSH key without a passphrase; otherwise, having a passphrase is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve answered those questions, `ssh-keygen` will generate a private
    key (`id_rsa`)/public key (`id_rsa.pub`) pair and save them under the `~/.ssh` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you do not set a passphrase on your private key, anyone with your private
    key is able to gain access to any servers that use the corresponding public key
    to authenticate you. Therefore, generally speaking, **never share your private
    key**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SSH key to the remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an SSH key pair, we need to set up our virtual server to accept
    this key.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your local machine, use the `cat` command to print out the content of your
    public key to the terminal and copy it to your clipboard (for example, using *Ctrl*
    + *Shift* + *C*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use `xclip` to copy the content of your public key directly
    to your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: '`$ xclip -selection clipboard < ~/.ssh/id_rsa.pub`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you haven''t done so already, log in to the remote server as `root`
    using your password. Next, create the `~/.ssh` directory and a `~/.ssh/authorized_keys` file,
    if they do not already exist. The `authorized_keys` file lists the keys that the
    server accepts as valid credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the permissions on the file so that only the current user (`root`)
    can read the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, append the public key you just copied to the end of the `authorized_keys`
    file (for example, using `vim` or `nano`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to reload the SSH daemon to ensure our changes are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that this is working, open a new terminal window and run `ssh root@<remote-ip>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, the server doesn't ask for your password anymore, as it is using
    our SSH key to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: Using ssh-copy-id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to do the same for our `hobnob` user. But this time, we''re going
    to use a handy command line tool, `ssh-copy-id`, which will do everything described
    previously, but with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Providing extra security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, there are a few additional measures we can take to make our
    setup more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Disable password-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can now log in with our SSH key, we are still allowing logins via password.
    A chain is only as strong as its weakest link, and a system is only as secure
    as its least secure component. Therefore, now that we can log in using SSH, it's
    best to disable login via password.
  prefs: []
  type: TYPE_NORMAL
- en: Double-check that you are able to log in to your server using your SSH key before
    disabling password-based authentication; otherwise, you'll be locked out of the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the remote virtual server, open up the configuration file for the SSH daemon
    at `/etc/ssh/sshd_config` (note that this is not the same as `/etc/ssh/ssh_config`,
    which is the configuration file for the *SSH client*). Search for an entry called `PasswordAuthentication`
    and set it to `no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, reload the SSH daemon to ensure that it is updated with our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Disable root login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shouldn't stop there. Now that we have access to a user with `sudo` privileges,
    we don't need to log in as `root` anymore. Therefore, we should disable root login
    through another configuration entry in the `sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `PermitRootLogin` entry and set that to `no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the SSH daemon to ensure that this change takes effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from your local machine, try to log in as `root`; you should get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step in securing our server is to install a firewall. The idea behind
    a firewall is that every exposed port is a potential security vulnerability. Therefore,
    we want to expose as few ports as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Linux distributions come with a firewall called `iptables`, which, by default, allows
    all traffic to pass through. Configuring `iptables` by hand can be challenging
    as the format is not the most intuitive. For example, an inactive `iptables` configuration
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To help system administrators to manage the `iptables` firewall more easily,
    the Ubuntu distribution comes with a command-line program called `ufw` (short
    for **u**ncomplicated **f**ire**w**all), which we will use here.
  prefs: []
  type: TYPE_NORMAL
- en: '`ufw` is inactive by default, but before we enable it, let''s add some rules
    for it to enforce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The only port we need to expose right now is the one for SSH, which is port
    `22`. We can do this by adding individual ports directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s an easier way: services may register their *profiles* with
    `ufw`, allowing `ufw` to manage their ports *by name*. You can view a list of
    registered applications by running `ufw app list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, instead of specifying port `22`, we can specify the name of the
    application instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the rules are in place, we can enable `ufw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we check again, only the OpenSSH port (`22`) is opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the time zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, we should configure all our servers to use the UTC time zone. Using
    a single time zone prevents us from having to keep track of which server is on
    which time zone when accessing multiple servers at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have run the command, you''ll be presented with the following screen.
    Use your up/down arrow keys to select None of the above. Then, use your left/right
    arrow keys to select OK and press Return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/251432d7-cdcf-449c-a90e-1014c9317761.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, select UTC, which stands for **Universal Time Coordinated**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/018ffde0-6dcc-492d-a687-2fe0826387d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should get a confirmation on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set our time zone, but to ensure the clock is accurate, we need
    to perform an additional step to keep it in sync with the global NTP servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will install and run the `ntp` daemon, which will automatically start when
    booting up, synchronize with these global NTP servers, and update the system's
    time if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now successfully set up and secured a VPS! We can
    now move on to deploying our API on it.
  prefs: []
  type: TYPE_NORMAL
- en: Running our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can run our API on the VPS, we need to install the software and libraries
    it depends on, which include Git, Node, yarn, the**Java ****Development Kit** (**JDK**), and
    Elasticsearch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent complications with permissions, we will place our application code
    under the `/home/hobnob/` directory and run it as the `hobnob` user. Therefore, create
    a new directory for our projects, clone our API repository from the remote repository,
    install the required version of Node.js, use `yarn` to install all dependencies,
    and serve the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you want to place the API in a directory outside of the user's home directory,
    such as `/srv/` or `/var/www/`, then you can't use nvm, because nvm installs the
    Node.js binary under the installer's home directory. Instead, you'd need to install
    Node.js globally using an npm package called `n` ([github.com/tj/n](https://github.com/tj/n)).
  prefs: []
  type: TYPE_NORMAL
- en: What you *absolutely must not* do is run the API as the `root` user, because
    it poses a huge security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set the correct environment variables. The settings in our
    `*.env.example` files should work out of the box, so we can just copy them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The site will now be running on the port we specified in our `.env` file, which
    is `8080`. To make it available externally, we must update our firewall to permit
    traffic going into port `8080`. Open up a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In your browser, navigate to `http://<vps-ip-address>:8080/`, and you should
    see an error which says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This means that Express is working; the error response is correctly telling
    us that the endpoint does not exist. Feel free to play around with the deployed
    API. It should work the same way as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our API alive with PM2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are running our Node.js process inside an ephemeral SSH session. When we
    log out, the host machine will kill any processes initiated during that session.
    Therefore, we need to come up with a way of keeping our process alive even after
    logging out.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, no matter how good our code base is, or how complete our test plans
    are, in any application of significant size, there will be errors. Sometimes,
    these errors are fatal and crash the application. In these instances, we should
    log the error and notify the developers, but most importantly, we should restart
    the application as soon as it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu provides the `upstart` daemon ([upstart.ubuntu.com](http://upstart.ubuntu.com/)),
    which can monitor a service and respawn it if it dies unexpectedly. Likewise,
    there's a popular npm package called `forever` ([github.com/foreverjs/forever](https://github.com/foreverjs/forever)),
    which does a similar job. However, I have found PM2 ([pm2.keymetrics.io](http://pm2.keymetrics.io/))
    to be the best process manager out there, so that's what we'll use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install PM2 as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update our `serve` npm scripts to execute `pm2 start` instead of `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, push these changes from your local machine and pull them into the virtual
    server. Run `yarn` again to install `pm2` and then run `yarn run serve`; now,
    our process is managed by PM2 and not our `hobnob` user. This means even if you
    log out or disconnect, our Node.js process would still continue to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The great thing about PM2 is that the user interface is fantastic for a CLI
    tool. If we run `npx pm2 monit`, you''ll get a dashboard with all the running
    processes, and you can use the mouse to see the status, resource usage, and other
    statistics in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Killing a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see PM2 in action, we''re going to kill our Node.js process manually, and
    see if PM2 will automatically restart it. We''ll use the `npx pm2 list` command,
    which lists all processes in a static table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `pm2` started a new process, with a different **process ID**
    (**PID**), once the old process died. The restart count has also increased to
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping PM2 alive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PM2 will keep applications running, as long as it is running itself. But if
    PM2 itself is terminated (for example, as a result of a reboot), then we must
    also configure PM2 to automatically restart. Very conveniently, PM2 provides a
    `startup` command, which outputs a script for you to run on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run the script to ensure PM2 starts on boot. Now, when you log out of your terminal
    session, or when the application crashes unexpectedly, or even the whole machine
    restarts, you can be confident that your application will automatically restart
    as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Running our API on port 80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are currently running our API server on port `8080`, whereas the standard
    port for HTTP requests is port `80`. It would be really inconvenient, and thus
    bad for user experience, to ask the consumers of our API to attach a port number
    to the URL for every request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s change the port that Express is listening on from `8080`
    to `80` and see what happens. Change the `SERVER_PORT` environment variable to
    `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, stop and delete the PM2 application, and run the `serve` script again.
    When we run it again, it will initially be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we check its status again, PM2 will show you that the application
    has errored, and it has tried to restart it 15 times before giving up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `pm2 show <name>` command to get information about a particular
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, we can see that the errors emanating from the application
    are stored at `/home/hobnob/.pm2/logs/index-error.log`, so let''s take a look
    at that to see what it says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `EACCES 0.0.0.0:80` error means that our Node.js process does not have permission
    to access port `80`. This is because, in Linux, ports with numbers below `1024`
    are deemed **privileged**, which means they can only be bounded by processes initiated
    by the `root` user.
  prefs: []
  type: TYPE_NORMAL
- en: Privileged ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from being bad for developer experience, there''s a more important reason
    why our API should be served on a **privileged port**: when the consumers of our
    API send us their data, they need to trust that the information they sent is only
    handled by processes that were initiated by the server administrator (often `root`),
    and not by some malicious party.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose a malicious party somehow managed to breach our server and got
    access to an ordinary user account. If we had set our API port to a non-privileged
    port, then that malicious user could spawn a modified, rogue API service that
    binds to that port, and use it to extract sensitive information, such as user
    passwords. Now, any information sent by the client to this port would be exposed
    to the malicious party.
  prefs: []
  type: TYPE_NORMAL
- en: However, privileged ports can only be bound by the `root` user, and so the malicious
    user won't be able to carry out the attack anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Possible solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, we do control the server, so how can we allow our API service to run
    on port `80`? There are a few solutions, which we will outline later, but to see
    them working, we should first disable port `8080` and enable port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Running as root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most straightforward solution is to run our Node process as `root`; in other
    words, something akin to `sudo node src/index.js`. However, this is a very bad
    idea as it poses a big security risk. If someone were to find a bug or vulnerability
    in your application, he/she can exploit it, and because the server process is
    run as `root`, the hacker can potentially do everything the `root` user can do,
    including wiping your entire machine clean or stealing data. Running the API server
    as an ordinary user will limit any potential damage to what is normally permissible
    to that user.
  prefs: []
  type: TYPE_NORMAL
- en: De-escalating privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a hack, however, which allows you to initiate the process as `root` using
    `sudo`, but de-escalate the privileges later by setting the user and group identity
    of the process to the user/group who issued the `sudo` command. We do this by
    using the environment variables `SUDO_UID` and `SUDO_GID`, and setting them using `process.setgid`
    and `process.setuid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Setting capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another solution is to set **capabilities**.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, when a thread or process requires certain privilege(s) to perform
    an action, such as reading a file or binding to a port, it checks with a list
    of capabilities. If it has that capability, it'll be able to perform that function;
    otherwise, it can't. By default, the `root` user has all capabilities, for instance, the `CAP_CHOWN`
    capability, which allows it to change a file's UID and GID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, rather than running the process as `root`, we can simply grant our
    Node process the capability of binding to privileged ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check that the capability is set for this process by running `getcap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run `npx pm2 delete 0; yarn run serve`, it'll successfully bind
    to port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we update our version of Node.js using nvm, we''d have to set the
    capabilities again for this new version of Node. Furthermore, this capability
    is not limited to binding to port `80`; it''s for binding to *all* privileged
    ports. This is a potential security vulnerability. Therefore, it''s best not to
    use this approach and we should unset the capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Using authbind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `authbind` as an alternative may be preferable to setting capabilities.
    `authbind` is a system utility that allows users without superuser privileges
    to access privileged network services, including binding to privileged ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to setting capabilities, `authbind` allows more fine-grained control
    with regard to the port and permissions it is granting. Configuration files for
    `authbind` can be found at `/etc/authbind`. In short, if a user has permission
    to access the `/etc/authbind/byport/<port>` file, then that user is able to bind
    to that port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a configuration file for port `80`, changing its owner
    to be the user running the API server, and setting its permission so that only
    `hobnob` can read it. Now, we can run our start script with `authbind` and it
    should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another solution is to use `iptables`, which is the same firewall we used before.
    Apart from blocking out traffic from certain ports, `iptables` also allows you
    to redirect traffic from one port to another. Therefore, we can simply route all
    traffic entering port `80` to port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Using reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can appreciate, there are many ways of binding to port `80` as a non-root
    user, and our list is not even exhaustive! However, the most popular method is
    to use a **reverse proxy** server to redirect traffic from one port to another.
  prefs: []
  type: TYPE_NORMAL
- en: What's a proxy? What's a reverse proxy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **proxy** is a server used by the client to indirectly access other servers.
    From the perspective of the server, it will view the proxy server as the client,
    and be oblivious to the original client. Proxy servers are the intermediary servers
    that your request passes through when it tries to get from your machine to the
    remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **reverse proxy** is the same, but the scheme is flipped. This is how a reverse
    proxy works:'
  prefs: []
  type: TYPE_NORMAL
- en: The reverse proxy receives a request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It relays the request to the proxied service (for example, an application server,
    such as our Express application)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It receives the response from the service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends the response back to the client(s)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client is oblivious to the fact that there's an internal service; in the
    client's view, the response came directly from the reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular reverse proxy today is NGINX, and that''s what we''ll use
    in this book. NGINX is also a generic web server, which provides the following
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: We can host multiple services on the same server; this provides greater flexibility
    if we are to add extra services running on the same server later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can handle SSL encryption, which is required for setting up HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports features such as caching and GZIP compression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also act as a load balancer; this allows us to run multiple instances
    of our Node application, all on different ports, and have NGINX distribute the
    requests across these processes. It'll do so in a way that minimizes the load
    on any particular process, and thus maximizes the speed at which a response can
    be generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration as code; since all HTTP traffic goes through NGINX, it's easy
    to see a list of all the services that we are exposing to the external world simply
    by reading NGINX's configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an additional layer of abstraction; we can change how we structure the
    application internally, and all we have to do is update the NGINX settings. For
    example, we can have the service run on a different machine within a private network,
    and our external users would not know the difference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let's get NGINX installed on our machine!
  prefs: []
  type: TYPE_NORMAL
- en: We will outline the installation instructions for NGINX on Ubuntu. Installation
    for other platforms can be found at [nginx.com/resources/wiki/start/topics/tutorials/install/](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `nginx` package should already be in Ubuntu''s default repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: However, we should use the official NGINX repository to ensure we *always* get
    the most up-to-date version. To do this, we need to add NGINX's package repository
    to the list of repositories that Ubuntu will search for when it tries to download
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are two places that Ubuntu will search: inside the `/etc/apt/sources.list`
    file and inside files under the `/etc/apt/sources.list.d/` directory. We should
    not write directly to the `/etc/apt/sources.list` file because when we upgrade
    our distribution, this file will be overwritten. Instead, we should create a new
    file with a unique name inside the `/etc/apt/sources.list.d/` directory, and add
    the entry for the NGINX repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you ever delete your `/etc/apt/sources.list` file by accident, you can regenerate
    it using the Ubuntu Sources List Generator ([repogen.simplylinux.ch](https://repogen.simplylinux.ch/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure the integrity and authenticity of the package they download, the
    Ubuntu package management tools (`dpkg` and `apt`) require package distributors
    to sign their packages using a publicly available GPG key. Therefore, we must
    add this key to APT so that it knows how to check the integrity and authenticity
    of the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'NGINX is now installed, but it is not yet running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Configuring NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start NGINX, we need to configure it. Like other system-wide services,
    configuration files for NGINX are stored under the `/etc/` directory. Navigate
    to `/etc/nginx/` and have a look at the files there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The main configuration is defined inside `nginx.conf`, which looks like this
    (once comments are removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Understanding NGINX's configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NGINX server is made up of **modules**, which are controlled by **directives**
    defined inside the `nginx.conf` configuration file. For instance, the HTTP module
    is configured using the `http` directive in `nginx.conf`. A directive is basically
    a unit of instruction/setting. There are two types of directives: **simple** and
    **block**.
  prefs: []
  type: TYPE_NORMAL
- en: A simple directive consists of a name and one or more parameters, each separated
    by a space and ending with a semicolon. `pid /var/run/nginx.pid;` would be an
    example of a simple directive. On the other hand, a block directive consists of
    a name followed by a pair of braces (`{}`), inside which it may contain additional
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: There's also the concept of **context**. The top-level directives exist inside
    the `main` context. Each block directive envelops the contained directives in
    its own context. For example, in the `nginx.conf` file, the `worker_connections`
    directive will be within the `events` context, which is itself within the `main`
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the HTTP module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow NGINX to route requests for a given service, we must define a `server`
    block directive within the `http` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `server` block, we can define certain directives that are only available
    in the `server` context. Here is a short list of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`listen`: Which port should this service be listening to. If this is not set,
    it''ll default to port `80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server_name`: Which domain name(s) should apply to this server block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`: How it should process requests based on the URL path. The `location`
    directive usually has two parameters. The first parameter is the **prefix**, and
    the second is another block of directives that specify how that request should
    be handled. That inner block can have the following directives:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root`: Used for serving static files. It tells NGINX where it can find the
    requested resources on our server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy_pass`: Used for reverse proxying. It tells NGINX the URL to which it
    should relay the request.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When NGINX receives a request that matches the server block's `listen` and `server_name`
    directives, it will pass it to the `server` block. Then, the path of the URL of
    the request would be extracted and it will try to match with the prefixes of each
    `location` directive. If it finds a match, the request will be processed in accordance
    with the directives specified within that `location` block. If there is more than
    one `location` prefix that matches the URL, the `location` block with the longest
    (and thus most specific) prefix will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `/etc/nginx/nginx.conf` and add the following server block to reverse
    proxy requests to our API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When NGINX receives a request at `http://142.93.241.63/`, the URL path (`/`)
    matches the prefix of the first `location` block. The `proxy_pass` directive then
    directs the request to our API, which would be running on port `8080`. NGINX will
    also relay the API's response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s revert our change to the `SERVER_PORT` environment variable by editing
    the `envs/.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start both our API server and the NGINX service, test our API on `http://142.93.241.63/`,
    and check that everything is still working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Splitting nginx.conf into multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, writing directly to `/etc/nginx/nginx.conf` is not a good idea because
    if we upgrade NGINX, the `nginx.conf` file may get replaced. Also, if the server
    has to handle many services, the large number of server blocks in the file will
    make it hard to read and maintain. Therefore, it's good practice to split configurations
    for different services into different files from the outset.
  prefs: []
  type: TYPE_NORMAL
- en: A common convention is to use two directories: `/etc/nginx/sites-available`
    and `/etc/nginx/sites-enabled`. You'd place the configuration for each service
    as separate files under the `sites-available` directory. Then, to enable a service,
    you'd create a **symbolic link** from the `sites-enabled` directory to a file
    in the `sites-available` directory. Lastly, you'd link the `/etc/nginx/sites-available`
    directory to the main configuration by adding an `include` entry in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the two directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `/etc/nginx/nginx.conf` file, add an `include` directive after `include
    /etc/nginx/conf.d/*.conf;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Then, pull out each `server` block from within the `http` context and place
    them, as separate files, inside `/etc/nginx/sites-available/`. By convention,
    the name of the file should correspond to the domain name, but since we don't
    have a domain yet, we can name it `api`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to clarify, `/etc/nginx/sites-available/api` should be a file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to enable the sites, we must add to the `/etc/nginx/sites-enabled` directory
    using a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It's very important that you use the full, absolute path when creating symbolic
    links; otherwise, you may link to the wrong location.
  prefs: []
  type: TYPE_NORMAL
- en: An additional benefit to this approach is the separation of concerns: generic
    configurations reside inside the `nginx.conf` file and site-specific settings
    (for example, SSL certificates) reside within their own files. Lastly, this is
    similar to how virtual hosts are set up on the Apache HTTP server; thus, adopting
    this approach would make it easier for administrators who are accustomed to the
    Apache HTTP server to migrate over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to reload the configuration once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about NGINX, check out the NGINX documentation at [nginx.org/en/docs/](http://nginx.org/en/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: From IP to domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we can access our API using an IP address. But if we want developers
    to use our API, we shouldn't expect them to remember a random sequence of numbers!
    Instead, we want to give them an easy-to-remember domain name such as `api.hobnob.social`.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we must first purchase the domain name and then configure its Domain
    Name System (DNS) settings so that it will resolve to our server's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Buying a domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the DNS is responsible for resolving domain names to IP addresses, a **domain
    registrar** is the entity/business that registers the domain(s) for you. There
    are many registrars available; the one we will be using is **Namecheap**.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must search for the domain we want on the Namecheap website. Although
    a registrar is an entity that can register domain names for many TLDs, it must
    first check with one or more **domain registries** to see whether the domain name
    is available. Domain registries collectively hold a list of all domain names and
    their availability, and domain registrars are the ones who rent an available domain
    to you for a price.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [namecheap.com](https://www.namecheap.com/) and search for a domain you'd
    like to register (many are under US $1/year); we are going to use `hobnob.social`.
    Then, follow the onscreen instructions to complete the order.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a domain name and a VPS, so it's time to associate them with each
    other. But first, we need to briefly explain how the DNS works.
  prefs: []
  type: TYPE_NORMAL
- en: The following overview is a simplification of the domain name resolution process.
    For brevity's sake, many details are left out. For a full interrogation of the
    process, please check out my blog post, *Resolving Domain Names*, which you can
    find at [blog.danyll.com/resolving-domain-names/](http://blog.danyll.com/resolving-domain-names/).
  prefs: []
  type: TYPE_NORMAL
- en: The job of the DNS is to resolve **fully qualified domain names** (**FQDNs**)
    into IP addresses. When you type a URL in your browser, your computer would first
    look to resolve the IP locally by checking your `/etc/hosts` file. If it can't
    find it, it will pass the request on to a **resolving nameserver**, which is usually
    provided by your **internet service provider** (**ISP**). The resolving nameserver
    would first check its internal cache, and use the cached entry if available. If
    it cannot find an entry for your FQDN, it will query one of the **top-level domain**
    (**TLD**) nameservers. They will return the IP address of a **domain-level nameserver** (a.k.a.
    **domain nameserver** or **authoritative nameserver**), which is the nameserver
    that actually holds the **zone file** containing the DNS records (`A`, `CNAME`,
    `NS`, and so on) for that domain.
  prefs: []
  type: TYPE_NORMAL
- en: The domain nameserver for the domain is usually controlled by the registrar
    that registered the domain (Namecheap, in our example). Finally, the domain nameserver
    will return the actual IP address of the FQDN to our resolving nameserver, which
    then relays that information back to us.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the domain nameserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Therefore, to configure our domain name to resolve to our server's IP address,
    we need to update the zone file of the domain nameserver. At the moment, our domain
    is using Namecheap's domain nameserver, and we can update the zone file using Namecheap's
    administrative UI.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach means we'd have to manage our servers using DigitalOcean,
    and our domain using Namecheap. It'd be easier if we can carry out all the everyday
    administrative tasks using the same platform. Fortunately, DigitalOcean also has
    its own domain nameservers, which we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we have to do is go on Namecheap's administrative UI and update the
    TLD server to use DigitalOcean's domain nameserver, and use DO's administrative
    UI to update the zone file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your Namecheap Dashboard ([ap.www.namecheap.com](https://ap.www.namecheap.com/))
    and select your domain. On the Domain tab, there should be a section named Nameservers.
    Select the Custom DNS section and add in DigitalOcean''s domain nameservers, which
    are `ns1.digitalocean.com`, `ns2.digitalocean.com`, and `ns3.digitalocean.com`.
    Then, make sure you press the green tick to save your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ff1b72e-62e3-4cdf-be44-340ac9a116fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because resolving nameservers caches results, it may take up to 48 hours for
    our changes to be propagated to all nameservers. You can use services such as [whatsmydns.net](https://www.whatsmydns.net/) to
    check the propagation progress for different nameservers around the world. Initially,
    you''ll see that they all point to the original nameservers (`dns1.registrar-servers.com`),
    but after a few minutes, many of them have changed to use DigitalOcean servers
    (`nsx.digitalocean.com`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59452603-2ff7-4b48-b90f-a466692d4bee.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While we wait for our DNS changes to propagate, we can go to DigitalOcean and
    build our zone file using DigitalOcean's UI.
  prefs: []
  type: TYPE_NORMAL
- en: Building our zone file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A zone file is a text file that describes a **DNS zone**, which is any distinct,
    contiguous portion of the domain namespace that is managed by a single entity.
    In most cases, the boundaries of a DNS zone are confined to a single domain; thus,
    *for our purposes only*, a DNS zone is the same as a domain.
  prefs: []
  type: TYPE_NORMAL
- en: A zone file is made up of many **records**. Each record is a mapping between
    a **hostname** and a **resource**. Let's use the DigitalOcean administrative UI
    to visualize these records and build our zone file.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the administrative UI provided by DigitalOcean to manage our DNS
    settings. If you have chosen a different hosting provider, the UI may be different,
    but the principle remains the same. For example, Amazon Web Services (AWS) has
    an equivalent service called Route 53.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you''re logged in to DigitalOcean''s control panel, then go to the
    Networking tab ([cloud.digitalocean.com/networking/domains](https://cloud.digitalocean.com/networking/domains)).
    Under where it says Add a domain, put in your domain name and click the Add Domain
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db6adf3e-1d91-4ffa-ab74-8be1d6e8e06d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you''ll be presented with a screen where we can add and update our records
    for the zone file of `hobnob.social`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f19f0768-bcdb-42ab-8cb9-eefcbd7fb14c.png)'
  prefs: []
  type: TYPE_IMG
- en: The NS records have already been set for you, so let's talk about that first.
  prefs: []
  type: TYPE_NORMAL
- en: NS records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NS records specify the domain nameservers used for resolving hostnames to
    IP addresses. You may ask why do zone files need an NS record at all? Because
    it basically references itself. This is because NS records may have changed, and
    other servers need to be updated with the IP/hostname of the new domain nameserver.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, this was pointed at `dns1.registrar-servers.com`, and was cached
    at many resolving nameservers. When these resolving nameservers query `dns1.registrar-servers.com`
    for the IP of `hobnob.social`, they see that the NS record has been updated to
    `ns1.digitalocean.com` and send the request to DigitalOcean's domain nameservers
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a program called `dig` to get the records from the zone file for
    our domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The first value is the domain; the second is the **time-to-live** (**TTL**)
    value, which is how long this record should be cached for in seconds. The third
    value, `IN`, stands for "internet," and will be present in almost all records.
    The fourth value, `NS`, indicates that this record should be treated as an NS
    record. Lastly, the last portion is the value of the record; in this case, it's
    the hostname of DigitalOcean's domain nameservers.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple NS records (and multiple domain nameservers) so that if and
    when one is down or overloaded, it can use the other domain nameservers.
  prefs: []
  type: TYPE_NORMAL
- en: A and AAAA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next most important record types are the `A` and `AAAA` records, which map
    a hostname to an IP address. `A` maps the host to an IPv4 address, whereas an `AAAA`
    record maps it to an IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to point `api.hobnob.social` to the server that''s running our server
    (`142.93.241.63`), so we need to create the following `A` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also direct traffic going to `hobnob.social` to the same IP address.
    But instead of writing the full hostname (`hobnob.social`), we can replace it
    with the `@` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: There are two parameters you can set at the top of a zone file: `$ORIGIN` and `$TTL`. `$ORIGIN` should
    be set to the DNS zone's highest level of authority, which, in most cases, is
    the domain name. The `$TTL` (time-to-live) parameter indicates how long this zone
    file should be cached for by nameservers.
  prefs: []
  type: TYPE_NORMAL
- en: In our records, we can use the `@` symbol as a placeholder/substitute for the
    `$ORIGIN` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Since these settings often don't need to be changed, DigitalOcean has set them
    for us, but not exposed them in the administrative UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many domains also have a **catch-all** record that directs all traffic not
    specified with a record to an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: However, using a catch-all (`*`) is not a good practice because a malicious
    party can link to your domain using a sub-domain such as `scam.hobnob.social`.
    If we do not have a catch-all record, when Google crawls that link, it will receive
    an error saying that the host cannot be reached. However, if you have a catch-all
    record, the request will be directed to your server, and your web server may opt
    to serve the default server block. This may make `scam.hobnob.social` the top
    result when people search for `hobnob.social`, which is not ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Start of Authority (SOA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last record you need to know is the SOA record, which is a mandatory record
    in all zone files, and is used to describe the zone and configure how often nameservers
    should update the zone file for this domain. It also has a version counter that
    ensures that only the latest version of the zone file is propagated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few values are similar to the ones in the NS records. The rest are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ns1.digitalocean.com` is the **primary master nameserver**, which holds the
    most up-to-date zone file. There may be **slave nameservers** that mirror the
    primary nameserver to reduce its load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dan.danyll.com` is the email for the administrator responsible for this DNS
    zone. The `@` symbol has been replaced by a period (`.`); if you have a period
    in your email address, it would be replaced by a backslash (`\`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<serial>` is the serial number for the zone file, which is essentially a version
    counter. Every time your zone is updated, you should also increase the serial
    number by `1`. Slave nameservers will check this serial number to determine whether
    their own zone file is outdated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<refresh>` is the amount of time a slave nameserver will wait before pinging
    the master server to see whether it needs to update its zone file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<retry>` is the amount of time a slave nameserver will wait before pinging
    the master server again, if the previous connection attempt was unsuccessful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<expiry>` is the amount of time that the zone file should still be deemed
    to be valid, even if it was no longer able to connect to the master server to
    update it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<negativeTTL>` is the amount of time the nameserver will cache a lookup that
    failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, since these values don't need to change often, and because having to
    manually update the serial number every time we update our zone file is tedious
    and error-prone, DigitalOcean has preset and hidden these values for us. DigitalOcean
    will update our SOA record for us when we update our records using DigitalOcean's
    web console.
  prefs: []
  type: TYPE_NORMAL
- en: Now, just make sure you have the A record set for the `api.hobnob.social` subdomain
    and move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have configured the DNS settings for our subdomain, we can update
    our NGINX configuration files to bear the name of our domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/etc/nginx/sites-available` and `/etc/nginx/sites-enabled` directories,
    update the names of the files to the corresponding FQDN (without the trailing
    period):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, update the configuration file to include a `server_name` directive.
    For example, the `api.hobnob.social` server block now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, reload our NGINX configuration to ensure that the changes take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now, try sending a request to `api.hobnob.social`, and you should see the API
    server respond correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have deployed our code to a VPS and exposed it to the external
    world—first through a static IP address, and later via a domain name.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look into **Continuous Integration** (**CI**)
    and **Continuous Deployment** (**CD**) to see how we can automate the testing
    and deployment steps we've introduced in the last few chapters. You'll get the
    chance to work with **Travis CI** and **Jenkins**, a **build automation** tool.
  prefs: []
  type: TYPE_NORMAL
- en: Looking further ahead, in [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml),* Migrating
    to Docker* and [Chapter 18](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml),* Robust
    Infrastructure with Kubernetes*, we will use **Docker containers** and **Kubernetes** to
    make our deployment more scalable and reliable.
  prefs: []
  type: TYPE_NORMAL
