- en: Chapter 2. Be Selective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting multiple elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing subselection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating raw selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental tasks that you will need to perform with any data
    visualization project using D3 is selection. Selection helps you target certain
    visual elements on the page. If you are already familiar with the W3C-standardized
    CSS selector or other similar selector APIs provided by popular JavaScript libraries,
    such as jQuery and Zepto.js, then you will find yourself right at home with D3's
    selection API. Don't worry if you haven't used the selector API before; this chapter
    is designed to cover this topic in steps with the help of some very visual recipes.
    It will cover pretty much all common use cases for your data visualization needs.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selector support is standardized by W3C, so all modern web browsers have built-in
    support for the selector API. However, the basic W3C selector API has limitations
    when it comes to Web development, especially in the data visualization realm.
    The standard W3C selector API provides only the selector, but not the selection.
    What this means is that the selector API helps you to select element(s) in your
    document; however, to manipulate the selected element(s), you still need to loop
    through each element. Consider the following code snippet using the standard selector
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code essentially selects all `<p>` elements in the document and
    then iterates through each element to perform some task. This can obviously get
    tedious quickly, especially when you have to manipulate many different elements
    on the page constantly, which is what we usually do in data visualization projects.
    This is why D3 introduced its own selection API, making development less of a
    chore. In the rest of this chapter, we will cover how D3's selection API works
    and some of its powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 selector basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into D3''s selection API, some basic introduction on the W3C
    level-3 selector API is required. If you are already comfortable with CSS3 selectors,
    feel free to skip this section. D3''s selection API is built based on the level-3
    selector or is more commonly known as CSS3 selector support. In this section,
    we plan to go through some of the most common CSS3 selector syntaxes that are
    required to understand the D3 selection API. The following list contains some
    of the most common CSS3 selector conventions you will typically encounter in a
    data visualization project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#foo`: Selects elements with `foo` as the value of `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo`: Selects element `foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.foo`: Selects elements with `foo` as the value of `class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`[foo=goo]`: Selects elements with the `foo` attribute value and sets it to
    `goo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo goo`: Selects the `goo` element inside the `foo` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo#goo`: Selects the `foo` element with `goo` as the value of `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo.goo`: Selects the `foo` element with `goo` as the value of `class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo:first-child`: Selects the first child of the `foo` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo:nth-child(n)`: Selects the `n`th child of the `foo` elements (`n` is one-based,
    starting at 1 for the first child)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: CSS3 selector is a pretty complex topic. Here, we have only listed some of the
    most common selectors that you will need to understand and that you need to be
    effective when working with D3\. For more information on this topic, please visit
    the W3C level-3 selector API document at [http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are targeting an older browser that does not support selector natively,
    you can include Sizzle before D3 for backward compatibility. You can find Sizzle
    at [http://sizzlejs.com/](http://sizzlejs.com/) .
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the next-generation selector API level-4 is in the draft stage with
    W3C. You can have a peek at what it has to offer and its current draft at [https://drafts.csswg.org/selectors-4/](https://drafts.csswg.org/selectors-4/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Major browser vendors have already started implementing some of the level-4
    selectors; if you are interested to find out the level of support in your browser,
    try out this handy website:  [http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common that at times you will need to select a single element on
    a page to perform some visual manipulation. This recipe will show you how to perform
    a targeted single element selection in D3 using a CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's select something (a `paragraph` element perhaps) and produce the classic
    *hello world* on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This recipe simply produces text **Hello world!** on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `d3.select` command is used to perform a single-element selection in D3\.
    This method accepts a string that represents a valid CSS3 selector or an element
    object if you already have a reference to the element you want to select. The
    `d3.select` command returns a D3 selection object on which you can chain modifier
    functions to manipulate the attribute, content, or inner HTML of this element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More than one element can be selected using the selector, provided only the
    first element is returned in the selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we simply select the paragraph element with `target` as the
    value of `id` at line `B`, and then set its textual content to `Hello world!`
    on line `C`. All D3 selections support a set of standard modifier functions. The
    `text` function we have shown in this particular example is one of them. The following
    are some of the most common modifier functions you will encounter throughout this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selection.attr`: This function allows you to retrieve or modify a given attribute
    on the selected element(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`selection.classed`: This function allows you to add or remove CSS classes
    on the selected element(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`selection.style`: This function lets you set the CSS style with a specific
    name to the specific value on the selected element(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Variable `this` in the preceding anonymous function is the DOM element object
    for the selected element `<p>`; therefore, it needs to be wrapped in `d3.select`
    again in order to access its `style` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection.text`: This function allows you to access and set the text content
    of the selected element(s) as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`selection.html`: This function lets you modify the element''s inner HTML content
    as shown in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These modifier functions work on both single-element and multi-element selection
    results. When applied to multi-element selections, these modifications will be
    applied to each and every selected element. We will see them in action in other,
    more complex  recipes that will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When a function is used as a value in these modifier functions, there are actually
    some built-in parameters passed to these functions to enable data-driven calculation.
    This data-driven approach is what gives D3 its power and its name (**Data-Driven
    Document**) and will be discussed in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting multiple elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often selecting a single element is not good enough, but rather you want to
    apply a certain change to a set of elements on the page simultaneously. In this
    recipe, we will play with the D3 multi-element selector and its selection API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what the `d3.selectAll` function is designed for. In the following
    code snippet, we will select three different `div` elements and enhance them with
    some CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet produces the following visual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-element selection
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First thing you probably will notice in this example is how similar the usage
    of D3 selection API is when compared to the single-element version. This is one
    of the powerful design choices of the D3 selection API. No matter how many elements
    you target and manipulate, whether one or many, the modifier functions are exactly
    the same. All the modifier functions we mentioned in the previous section can
    be applied directly to multi-element selection; in other words, D3 selection is
    set-based.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with that being said, let's take a closer look at the code example shown
    in this section, though it is generally pretty simple and self-descriptive. At
    line `A`, the `d3.selectAll` function is used to select all the `div` elements
    on the page. The return of this function call is a D3 selection object that contains
    all the three `div` elements. Immediately after that, on line `B`, the `attr`
    function was called on this selection to set the `class` attribute to `red box`
    for all three `div` elements. As shown in this example, the selection and manipulation
    code are very generic, and will not change even if now we have more than three
    `div` elements on the page. This seems to be an insignificant convenience for
    now, but in later chapters, we will show how this convenience can make your visualization
    code simpler and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is handy to be able to iterate through each element within a selection
    and modify each element differently according to their position. In this recipe,
    we will show you how this can be achieved using D3 selection iteration API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'D3 selection object provides a simple iterator interface to perform iteration
    in a similar fashion to how you will iterate through a JavaScript array. In this
    example, we will iterate through the three selected `div` elements we worked with
    in the previous recipe and annotate them with an index number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet produces the following visual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selection iteration
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is built on top of what we have already seen in the previous section.
    In addition to selecting all the `div` elements on the page at line `A` and setting
    their class attributes at line `B`, in this example, we will call the `each` function
    on the selection to demonstrate how we can iterate through a multi-element selection
    and process each element, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This form of calling a function on another function's return is called **Function
    Chaining**. If you are unfamiliar with this kind of invocation pattern, please
    refer to [Chapter 1](ch01.html "Chapter 1. Getting Started with D3.js"), *Getting
    Started with D3.js*, where the topic was explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list explains the `select` `each` and `append` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selection.each(function)`: The `each` function takes an iterator function
    as its parameter. The given iterator function can receive two optional parameters
    `d` and `i` with one more hidden parameter passed in as the `this` reference,
    which points to the current DOM element object. The first parameter `d` represents
    the datum bound to this particular element (if this sounds confusing to you, don''t
    worry, we will cover data binding in depth in the next chapter). The second parameter
    `i` is the index number for the current element object being iterated through.
    This index is zero-based, meaning it starts from zero and increments each time
    a new element is encountered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection.append(tagName)`: Another new function introduced in this example
    is the `append` function. This function creates a new element with the given element
    name and appends it as the last child of each element in the current selection.
    It returns a new selection containing the newly appended element. Now, with this
    knowledge, let''s take a closer look at the code example in this recipe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The iterator function is defined on line `C` with both `d` and `i` parameters.
    Line `D` is a little bit more interesting. At the beginning of line `D`, the `this`
    reference is wrapped by the `d3.select` function. This wrapping essentially produces
    a single-element selection containing the current DOM element, which the `this`
    variable represents. Once wrapped, the standard D3 selection manipulation API
    becomes available on `d3.select(this)`. After that, the `append("h1")` function
    is called on the current element selection appending a newly created `h1` element
    to the current element. Afterward, it simply sets the textual content of this
    newly created `h1` element to the index number of the current element. This produces
    the visual of numbered boxes as shown in this recipe as illustrated in the screen
    capture. Again, you should notice that the index starts from 0 and increments
    1 for each element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DOM element object itself has a very rich interface. If you are interested
    to know more about what it can do in an iterator function, please refer to the
    DOM element API at [https://developer.mozilla.org/en-US/docs/Web/API/element](https://developer.mozilla.org/en-US/docs/Web/API/element)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Performing subselection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite common that you will need to perform scoped selection when working
    on visualization. For example, selecting all `div` elements within a particular
    `section` element is one such use case of scoped selection. In this recipe, we
    will demonstrate how this can be achieved with different approaches and their
    advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code example selects two different `div` elements using two different
    styles of subselection supported by D3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Subselection
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though it produces the same visual effect, this example demonstrates two very
    different subselection techniques. We will discuss them separately here so you
    can understand their pros and cons as well as when to use one versus the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector level-3 combinators:** On line `A`, `d3.select` is used with a special-looking
    string, which consists of one tag name connected with another one using a greater-than
    sign (U+003E, >). This syntax is called *combinators* (the greater-than sign here
    indicates it is a child combinator). Level-3 selector supports a few different
    kinds of structural combinators. Here, we will give a quick introduction to the
    most common ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The descendant combinator**: This combinator has the syntax just like `selector
    selector`. The descendant combinator, as suggested by its name, is used to describe
    a loose parent-child relationship between two selections. The reason why it is
    called a loose parent-child relationship is that the descendant combinatory does
    not care if the second selection is a child or a grandchild or a great-grandchild
    of the parent selection. Let''s take a look at some examples to illustrate this
    loose relationship concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we use the following selector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will select the `em` element since `div` is the ancestor of the `em` element
    and `em` is a descendent of the `div` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Child combinator**: This combinator has the syntax such as `selector > selector`.
    The child combinator offers a more restrictive way to describe a parent-child
    relationship between two elements. A child combinator is defined using a greater-than
    sign (U+003E, >) character separating the two selectors, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will select the `em` element since `em` is a direct child of the `span` element
    in our example. The selector `div > em` will not produce any valid selection since
    `em` is not a direct child of the `div` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The level-3 selector also supports sibling combinators; however, since it is
    less common, we will not cover it here; interested readers can refer to W3C level-3
    selector documentation at [http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)
    . The W3C level-4 selector offers some interesting additional combinators, that
    is, following-sibling and reference combinators that can yield some very powerful
    target selection capability; refer to [https://drafts.csswg.org/selectors-4/#combinators](https://drafts.csswg.org/selectors-4/#combinators)
    for more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The D3 nested subselection**: On lines `B` and `C`, a different kind of subselection
    technique was used. In this case, a simple D3 selection was made first on line
    `B` by selecting the `section #section2` element. Immediately afterward, another
    `select` was chained to select a `div` element on line `C`. This kind of nested
    selection defines a scoped selection. In plain English, this basically means to
    select a `div` element that is nested under `#section2`. In semantics, this is
    essentially the same as using a descendant combinator `#section2 div`. However,
    the advantage of this form of subselection is that since the parent element is
    separately selected, it allows you to handle the parent element before selecting
    the child element. To demonstrate this, let''s take a look at the following code
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the preceding code snippet, you can see that before we select the
    `div` element, we can apply a modifier function to `#section2` on line `B-1`.
    This flexibility will be further explored in the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, the D3 API is completely designed around the idea of
    function chaining. Therefore, it forms a DSL for building HTML/SVG elements dynamically.
    In this code example, we will take a look at how the entire body structure of
    the previous example can be constructed using D3 alone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If DSL is a new concept for you, I highly recommend checking out this excellent
    explanation on DSL by *Martin Fowler* in the form of an excerpt from his book
    *Domain-Specific Languages*. The excerpt can be found at [http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how a function chain can be used to produce concise and
    readable code that produces dynamic visual content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following visual output (similar to what we saw in
    the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function chain
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the visual similarity to the previous example, the construction process
    of the DOM elements is significantly different in this example. As demonstrated
    by the code example, there is no static HTML element on the page contrary to the
    previous recipe where both the `section` and `div` elements existed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine closely how these elements were dynamically created. On line A,
    a general selection was made to the top-level `body` element. The `body` selection
    result was cached using a local variable called `body`. Then, at line `B`, a new
    element `section` was appended to the body. Remember that the `append` function
    returns a new selection that contains the newly appended element; therefore, on
    line `C`, the `id` attribute can then be set on a newly created section element
    to `section1`. Afterward, on line `D`, a new `div` element was created and appended
    to `#section1` with its CSS class set to `blue box` on line `E`. For the next
    step, similar to the previous line, on line `F`, a `paragraph` element was appended
    to the `div` element with its textual content set to `dynamic blue box` on line
    `G`.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated by this example, this chaining process can continue to create
    any structure of arbitrary complexity. In fact this is how a typical D3-based
    data visualization structure is created. Many visualization projects simply contain
    only a HTML skeleton and rely on D3 to create the rest. Getting comfortable with
    this way of function chaining is critical if you want to become efficient with
    the D3 library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of D3's modifier functions return a new selection, such as the `select`,
    `append`, and `insert` functions. It is a good practice to use different levels
    of indentation to differentiate the selection your function chain is being applied
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the raw selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, having access to the D3 raw selection array might be beneficial in
    development whether it's for debugging purposes or for integrating with other
    JavaScript libraries, which require access to raw DOM elements; in this recipe,
    we will show you ways to do that. We will also see some, internal structure of
    a D3 selection object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, you can achieve this using the `nth-child` selector or the selection
    iterator function `each`, but there are cases where these options are just too
    cumbersome and inconvenient. This is when you might find dealing with the raw
    selection array a more convenient approach. In this example, we will see how the
    raw selection array can be accessed and leveraged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raw selection manipulation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we went through an existing HTML table to color the table.
    This is not intended to be a good example of how you would color odd versus even
    rows in a table using D3\. Instead, this example is designed to show how raw selection
    array can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A much better way to color odd and even rows in a table would be using the `each`
    function and then relying on the index parameter `i` to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: On line `A`, we select all rows and store the selection in the `trSelection`
    variable. D3 selection has a convenient `node()` function that returns an array
    containing the selected element nodes. Thus, in order to access the first selected
    element, you will need to use `d3.selectAll("tr").nodes()[0]`, the second element
    can be accessed with `d3.selectAll("tr").nodes()[1]`, and so on. As we can see
    on line `B`, the table header element can be accessed using `trSelection.nodes()[0]`
    and this will return a DOM element object. Again, as we have demonstrated in previous
    sections, any DOM element can then be selected directly using `d3.select` as shown
    on line `C`. Line `D`, `E`, and `F` demonstrate how each element in selection
    can be directly indexed and accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Raw selection access could be handy in some cases especially when you need to
    use D3 in partnership with other JavaScript libraries since other libraries won't
    be able to work with D3 selection but only with raw DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additionally, this approach is typically very useful in a testing environment
    where knowing the absolute index for each element quickly and gaining a reference
    to them could be convenient. We will cover unit tests in a later chapter in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we covered many different ways of how HTML elements can be selected
    and manipulated using D3's selection API. In the next chapter, we will explore
    how data can be bound to such selection to dynamically drive the visual appearance
    of selected elements which is the fundamental step of data visualization.
  prefs: []
  type: TYPE_NORMAL
