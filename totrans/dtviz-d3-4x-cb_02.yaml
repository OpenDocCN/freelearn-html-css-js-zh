- en: Chapter 2. Be Selective
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：选择
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Selecting a single element
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择单个元素
- en: Selecting multiple elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择多个元素
- en: Iterating through a selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历选择
- en: Performing subselection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行子选择
- en: Function chaining
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数链式调用
- en: Manipulating raw selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作原始选择
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most fundamental tasks that you will need to perform with any data
    visualization project using D3 is selection. Selection helps you target certain
    visual elements on the page. If you are already familiar with the W3C-standardized
    CSS selector or other similar selector APIs provided by popular JavaScript libraries,
    such as jQuery and Zepto.js, then you will find yourself right at home with D3's
    selection API. Don't worry if you haven't used the selector API before; this chapter
    is designed to cover this topic in steps with the help of some very visual recipes.
    It will cover pretty much all common use cases for your data visualization needs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用D3进行任何数据可视化项目时，你需要执行的最基本任务之一就是选择。选择可以帮助你定位页面上的某些视觉元素。如果你已经熟悉W3C标准化的CSS选择器或其他类似的选择器API，例如jQuery和Zepto.js，那么你会发现D3的选择器API非常容易上手。如果你之前没有使用过选择器API，不要担心；本章旨在通过一些非常直观的食谱分步骤介绍这个主题。它将涵盖你数据可视化需求的所有常见用例。
- en: Introducing selection
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍选择
- en: 'Selector support is standardized by W3C, so all modern web browsers have built-in
    support for the selector API. However, the basic W3C selector API has limitations
    when it comes to Web development, especially in the data visualization realm.
    The standard W3C selector API provides only the selector, but not the selection.
    What this means is that the selector API helps you to select element(s) in your
    document; however, to manipulate the selected element(s), you still need to loop
    through each element. Consider the following code snippet using the standard selector
    API:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器支持由W3C标准化，因此所有现代网络浏览器都内置了对选择器API的支持。然而，当涉及到Web开发时，特别是数据可视化领域，基本的W3C选择器API存在局限性。标准的W3C选择器API只提供选择器，而不提供选择。这意味着选择器API可以帮助你在文档中选择元素；然而，要操作选中的元素，你仍然需要遍历每个元素。考虑以下使用标准选择器API的代码片段：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code essentially selects all `<p>` elements in the document and
    then iterates through each element to perform some task. This can obviously get
    tedious quickly, especially when you have to manipulate many different elements
    on the page constantly, which is what we usually do in data visualization projects.
    This is why D3 introduced its own selection API, making development less of a
    chore. In the rest of this chapter, we will cover how D3's selection API works
    and some of its powerful features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实际上选择了文档中的所有`<p>`元素，然后遍历每个元素执行某些任务。这显然会很快变得繁琐，尤其是在你需要在页面上不断操作许多不同元素时，这是我们通常在数据可视化项目中做的事情。这就是为什么D3引入了自己的选择器API，使得开发变得更加轻松。在本章的其余部分，我们将介绍D3的选择器API是如何工作的以及它的一些强大功能。
- en: CSS3 selector basics
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS3选择器基础
- en: 'Before we dive into D3''s selection API, some basic introduction on the W3C
    level-3 selector API is required. If you are already comfortable with CSS3 selectors,
    feel free to skip this section. D3''s selection API is built based on the level-3
    selector or is more commonly known as CSS3 selector support. In this section,
    we plan to go through some of the most common CSS3 selector syntaxes that are
    required to understand the D3 selection API. The following list contains some
    of the most common CSS3 selector conventions you will typically encounter in a
    data visualization project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨D3的选择器API之前，需要对W3C第三级选择器API进行一些基本介绍。如果你已经熟悉CSS3选择器，可以自由跳过这一部分。D3的选择器API是基于第三级选择器构建的，也更为人所知的是CSS3选择器支持。在本节中，我们计划介绍一些理解D3选择器API所必需的常见CSS3选择器语法。以下列表包含了一些在数据可视化项目中通常会遇到的常见CSS3选择器约定：
- en: '`#foo`: Selects elements with `foo` as the value of `id`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#foo`：选择具有`id`值为`foo`的元素'
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`foo`: Selects element `foo`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`：选择元素`foo`'
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`.foo`: Selects elements with `foo` as the value of `class`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.foo`：选择具有`class`值为`foo`的元素'
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`[foo=goo]`: Selects elements with the `foo` attribute value and sets it to
    `goo`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[foo=goo]`：选择具有`foo`属性值并将其设置为`goo`的元素'
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`foo goo`: Selects the `goo` element inside the `foo` element'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo goo`：选择`foo`元素内部的`goo`元素'
- en: '[PRE5]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`foo#goo`: Selects the `foo` element with `goo` as the value of `id`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo#goo`：选择具有`id`值为`goo`的`foo`元素'
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`foo.goo`: Selects the `foo` element with `goo` as the value of `class`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo.goo`：选择具有`goo`作为`class`值的`foo`元素'
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`foo:first-child`: Selects the first child of the `foo` elements'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo:first-child`：选择`foo`元素的第一个子元素'
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`foo:nth-child(n)`: Selects the `n`th child of the `foo` elements (`n` is one-based,
    starting at 1 for the first child)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo:nth-child(n)`：选择`foo`元素的第`n`个子元素（`n`是从1开始的，第一个子元素为1）'
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: CSS3 selector is a pretty complex topic. Here, we have only listed some of the
    most common selectors that you will need to understand and that you need to be
    effective when working with D3\. For more information on this topic, please visit
    the W3C level-3 selector API document at [http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3选择器是一个相当复杂的话题。在这里，我们只列出了一些您需要理解和掌握的常见选择器，这些选择器在您使用D3时非常有效。有关此主题的更多信息，请访问W3C第3级选择器API文档[http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are targeting an older browser that does not support selector natively,
    you can include Sizzle before D3 for backward compatibility. You can find Sizzle
    at [http://sizzlejs.com/](http://sizzlejs.com/) .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在针对不支持选择器的旧版浏览器，可以在D3之前包含Sizzle以实现向后兼容。您可以在[http://sizzlejs.com/](http://sizzlejs.com/)找到Sizzle。
- en: Currently, the next-generation selector API level-4 is in the draft stage with
    W3C. You can have a peek at what it has to offer and its current draft at [https://drafts.csswg.org/selectors-4/](https://drafts.csswg.org/selectors-4/)
    .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，下一代选择器API的第4级正处于W3C的草案阶段。您可以查看它提供的内容及其当前草案[https://drafts.csswg.org/selectors-4/](https://drafts.csswg.org/selectors-4/)。
- en: Major browser vendors have already started implementing some of the level-4
    selectors; if you are interested to find out the level of support in your browser,
    try out this handy website:  [http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/)
    .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主要浏览器厂商已经开始了对第4级选择器的实现；如果您想了解您浏览器对选择器的支持程度，可以尝试访问这个实用的网站：[http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/)。
- en: Selecting a single element
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择单个元素
- en: It is very common that at times you will need to select a single element on
    a page to perform some visual manipulation. This recipe will show you how to perform
    a targeted single element selection in D3 using a CSS selector.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要在页面上选择单个元素以执行某些视觉操作。这个配方将向您展示如何使用CSS选择器在D3中执行有针对性的单个元素选择。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html)
    .'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/single-selection.html)。'
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's select something (a `paragraph` element perhaps) and produce the classic
    *hello world* on screen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一些东西（比如一个`paragraph`元素）并在屏幕上生成经典的*hello world*。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This recipe simply produces text **Hello world!** on your screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方简单地在您的屏幕上生成文本**Hello world!**。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `d3.select` command is used to perform a single-element selection in D3\.
    This method accepts a string that represents a valid CSS3 selector or an element
    object if you already have a reference to the element you want to select. The
    `d3.select` command returns a D3 selection object on which you can chain modifier
    functions to manipulate the attribute, content, or inner HTML of this element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.select`命令用于在D3中执行单个元素选择。此方法接受一个表示有效CSS3选择器的字符串，或者如果您已经有了要选择的元素的引用，则接受一个元素对象。`d3.select`命令返回一个D3选择对象，您可以在其上链式调用修改函数来操作此元素的属性、内容或内部HTML。'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More than one element can be selected using the selector, provided only the
    first element is returned in the selection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用选择器选择多个元素，只要在选中时只返回第一个元素即可。
- en: 'In this example, we simply select the paragraph element with `target` as the
    value of `id` at line `B`, and then set its textual content to `Hello world!`
    on line `C`. All D3 selections support a set of standard modifier functions. The
    `text` function we have shown in this particular example is one of them. The following
    are some of the most common modifier functions you will encounter throughout this
    book:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们简单地选择了`target`值为`id`的段落元素，并在第`B`行将其文本内容设置为`Hello world!`。所有D3选择都支持一组标准修改函数。在这个特定例子中我们展示的`text`函数就是其中之一。以下是在本书中你将遇到的一些最常见的修改函数：
- en: '`selection.attr`: This function allows you to retrieve or modify a given attribute
    on the selected element(s):'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.attr`：此函数允许你检索或修改选定元素（或元素集）上的给定属性：'
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`selection.classed`: This function allows you to add or remove CSS classes
    on the selected element(s):'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.classed`：此函数允许你为选定的元素（或元素集）添加或删除CSS类：'
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`selection.style`: This function lets you set the CSS style with a specific
    name to the specific value on the selected element(s):'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.style`：此函数允许你为选定的元素（或元素集）设置具有特定名称的CSS样式值：'
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Variable `this` in the preceding anonymous function is the DOM element object
    for the selected element `<p>`; therefore, it needs to be wrapped in `d3.select`
    again in order to access its `style` attribute.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的匿名函数中的变量`this`是选定元素`<p>`的DOM元素对象；因此，需要再次将其包裹在`d3.select`中，以便访问其`style`属性。
- en: '`selection.text`: This function allows you to access and set the text content
    of the selected element(s) as follows:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.text`：此函数允许你访问和设置选定元素（或元素集）的文本内容，如下所示：'
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`selection.html`: This function lets you modify the element''s inner HTML content
    as shown in the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.html`：此函数允许你修改元素的内部HTML内容，如下所示：'
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These modifier functions work on both single-element and multi-element selection
    results. When applied to multi-element selections, these modifications will be
    applied to each and every selected element. We will see them in action in other,
    more complex  recipes that will be covered later in this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修改函数适用于单元素和多元素选择结果。当应用于多元素选择时，这些修改将应用于每个选定的元素。我们将在本章稍后的更复杂食谱中看到它们的实际应用。
- en: When a function is used as a value in these modifier functions, there are actually
    some built-in parameters passed to these functions to enable data-driven calculation.
    This data-driven approach is what gives D3 its power and its name (**Data-Driven
    Document**) and will be discussed in detail in the next chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数用作这些修改函数的值时，实际上有一些内置参数传递给这些函数，以启用数据驱动的计算。这种数据驱动的方法赋予了D3其力量和名称（**数据驱动文档**），将在下一章中详细讨论。
- en: Selecting multiple elements
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择多个元素
- en: Often selecting a single element is not good enough, but rather you want to
    apply a certain change to a set of elements on the page simultaneously. In this
    recipe, we will play with the D3 multi-element selector and its selection API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常选择单个元素是不够的，而是你想要同时将某些更改应用于页面上的元素集。在这个食谱中，我们将使用D3多元素选择器和其选择API进行操作。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html)
    .'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/multiple-selection.html)
    .'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This is what the `d3.selectAll` function is designed for. In the following
    code snippet, we will select three different `div` elements and enhance them with
    some CSS classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`d3.selectAll`函数的设计目的。在下面的代码片段中，我们将选择三个不同的`div`元素，并使用一些CSS类来增强它们：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code snippet produces the following visual:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段生成以下视觉效果：
- en: '![How to do it...](img/image_02_001.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_02_001.jpg)'
- en: Multi-element selection
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多元素选择
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First thing you probably will notice in this example is how similar the usage
    of D3 selection API is when compared to the single-element version. This is one
    of the powerful design choices of the D3 selection API. No matter how many elements
    you target and manipulate, whether one or many, the modifier functions are exactly
    the same. All the modifier functions we mentioned in the previous section can
    be applied directly to multi-element selection; in other words, D3 selection is
    set-based.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可能首先注意到D3选择API的使用与单元素版本是多么相似。这是D3选择API的强大设计选择之一。无论您要针对和操作多少个元素，是一个还是多个，修改函数都是完全相同的。我们之前章节中提到的所有修改函数都可以直接应用于多元素选择；换句话说，D3选择是基于集合的。
- en: Now, with that being said, let's take a closer look at the code example shown
    in this section, though it is generally pretty simple and self-descriptive. At
    line `A`, the `d3.selectAll` function is used to select all the `div` elements
    on the page. The return of this function call is a D3 selection object that contains
    all the three `div` elements. Immediately after that, on line `B`, the `attr`
    function was called on this selection to set the `class` attribute to `red box`
    for all three `div` elements. As shown in this example, the selection and manipulation
    code are very generic, and will not change even if now we have more than three
    `div` elements on the page. This seems to be an insignificant convenience for
    now, but in later chapters, we will show how this convenience can make your visualization
    code simpler and easier to maintain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，话虽如此，让我们更仔细地看看本节中所示的代码示例，尽管它通常很简单且具有自我描述性。在行`A`，使用了`d3.selectAll`函数来选择页面上的所有`div`元素。此函数调用的返回值是一个包含所有三个`div`元素的D3选择对象。紧接着，在行`B`，对这个选择调用了`attr`函数，将所有三个`div`元素的`class`属性设置为`red
    box`。正如本例所示，选择和操作代码非常通用，即使现在页面上有超过三个`div`元素，代码也不会改变。现在这似乎是一个微不足道的便利，但在后面的章节中，我们将展示这种便利如何使您的可视化代码更简单、更容易维护。
- en: Iterating through a selection
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历选择项
- en: Sometimes it is handy to be able to iterate through each element within a selection
    and modify each element differently according to their position. In this recipe,
    we will show you how this can be achieved using D3 selection iteration API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时能够遍历选择项中的每个元素并根据它们的位置不同地修改每个元素是非常方便的。在本菜谱中，我们将向您展示如何使用D3选择迭代API实现这一点。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html)
    .'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/selection-iteration.html)
    .'
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'D3 selection object provides a simple iterator interface to perform iteration
    in a similar fashion to how you will iterate through a JavaScript array. In this
    example, we will iterate through the three selected `div` elements we worked with
    in the previous recipe and annotate them with an index number as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: D3选择对象提供了一个简单的迭代接口，以便以类似于遍历JavaScript数组的方式执行迭代。在本例中，我们将遍历我们在前一个菜谱中使用的三个选定的`div`元素，并按如下方式用索引数字标注它们：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet produces the following visual:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段生成了以下视觉效果：
- en: '![How to do it...](img/image_02_002.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_02_002.jpg)'
- en: Selection iteration
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项迭代
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This example is built on top of what we have already seen in the previous section.
    In addition to selecting all the `div` elements on the page at line `A` and setting
    their class attributes at line `B`, in this example, we will call the `each` function
    on the selection to demonstrate how we can iterate through a multi-element selection
    and process each element, respectively:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例基于我们在前一个部分中已经看到的内容构建。除了在行`A`选择页面上的所有`div`元素并在行`B`设置它们的类属性之外，在本例中，我们将对选择调用`each`函数，以展示我们如何遍历多元素选择并分别处理每个元素：
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This form of calling a function on another function's return is called **Function
    Chaining**. If you are unfamiliar with this kind of invocation pattern, please
    refer to [Chapter 1](ch01.html "Chapter 1. Getting Started with D3.js"), *Getting
    Started with D3.js*, where the topic was explained.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个函数的返回值上调用函数的形式称为 **函数链式调用**。如果您不熟悉这种调用模式，请参阅 [第 1 章](ch01.html "第 1 章。D3.js
    入门")，*D3.js 入门*，其中解释了该主题。
- en: 'The following list explains the `select` `each` and `append` functions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表解释了 `select`、`each` 和 `append` 函数：
- en: '`selection.each(function)`: The `each` function takes an iterator function
    as its parameter. The given iterator function can receive two optional parameters
    `d` and `i` with one more hidden parameter passed in as the `this` reference,
    which points to the current DOM element object. The first parameter `d` represents
    the datum bound to this particular element (if this sounds confusing to you, don''t
    worry, we will cover data binding in depth in the next chapter). The second parameter
    `i` is the index number for the current element object being iterated through.
    This index is zero-based, meaning it starts from zero and increments each time
    a new element is encountered.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.each(function)`: `each` 函数接受一个迭代函数作为其参数。给定的迭代函数可以接收两个可选参数 `d` 和
    `i`，以及一个作为 `this` 引用传递的隐藏参数，该引用指向当前 DOM 元素对象。第一个参数 `d` 代表绑定到该特定元素的数值（如果您觉得这很困惑，不用担心，我们将在下一章深入探讨数据绑定）。第二个参数
    `i` 是正在迭代的当前元素对象的索引号。这个索引是从零开始的，意味着它从零开始，每次遇到新元素时增加。'
- en: '`selection.append(tagName)`: Another new function introduced in this example
    is the `append` function. This function creates a new element with the given element
    name and appends it as the last child of each element in the current selection.
    It returns a new selection containing the newly appended element. Now, with this
    knowledge, let''s take a closer look at the code example in this recipe:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.append(tagName)`: 在本例中引入的另一个新功能是 `append` 函数。此函数使用给定的元素名称创建一个新元素，并将其作为当前选择中每个元素的最后一个子元素附加。它返回一个包含新附加元素的新选择。现在，有了这些知识，让我们更仔细地看看这个菜谱中的代码示例：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The iterator function is defined on line `C` with both `d` and `i` parameters.
    Line `D` is a little bit more interesting. At the beginning of line `D`, the `this`
    reference is wrapped by the `d3.select` function. This wrapping essentially produces
    a single-element selection containing the current DOM element, which the `this`
    variable represents. Once wrapped, the standard D3 selection manipulation API
    becomes available on `d3.select(this)`. After that, the `append("h1")` function
    is called on the current element selection appending a newly created `h1` element
    to the current element. Afterward, it simply sets the textual content of this
    newly created `h1` element to the index number of the current element. This produces
    the visual of numbered boxes as shown in this recipe as illustrated in the screen
    capture. Again, you should notice that the index starts from 0 and increments
    1 for each element.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代函数定义在第 `C` 行，其中包含 `d` 和 `i` 参数。第 `D` 行稍微有趣一些。在第 `D` 行的开始处，`this` 引用被 `d3.select`
    函数包装。这种包装实际上产生了一个包含当前 DOM 元素的单一元素选择，`this` 变量代表该元素。一旦包装，标准 D3 选择操作 API 就可以在 `d3.select(this)`
    上使用。之后，对当前元素选择调用 `append("h1")` 函数，将新创建的 `h1` 元素附加到当前元素上。之后，它简单地设置这个新创建的 `h1`
    元素的文本内容为当前元素的索引号。这产生了本菜谱中所示的可视化编号框。再次提醒，索引从 0 开始，每次遇到新元素时增加 1。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The DOM element object itself has a very rich interface. If you are interested
    to know more about what it can do in an iterator function, please refer to the
    DOM element API at [https://developer.mozilla.org/en-US/docs/Web/API/element](https://developer.mozilla.org/en-US/docs/Web/API/element)
    .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 元素对象本身具有非常丰富的接口。如果您想了解更多关于迭代函数中它能做什么的信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/API/element](https://developer.mozilla.org/en-US/docs/Web/API/element)
    上的 DOM 元素 API。
- en: Performing subselection
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行子选择
- en: It is quite common that you will need to perform scoped selection when working
    on visualization. For example, selecting all `div` elements within a particular
    `section` element is one such use case of scoped selection. In this recipe, we
    will demonstrate how this can be achieved with different approaches and their
    advantages and disadvantages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理可视化时，您可能需要执行范围选择。例如，选择特定 `section` 元素内的所有 `div` 元素是范围选择的一个用例。在这个菜谱中，我们将展示如何通过不同的方法和它们的优缺点来实现这一点。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html)
    .'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/sub-selection.html)
    .'
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code example selects two different `div` elements using two different
    styles of subselection supported by D3:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例使用D3支持的不同子选择器样式选择了两个不同的 `div` 元素：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code generates the following visual output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下视觉输出：
- en: '![How to do it...](img/image_02_003.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_02_003.jpg)'
- en: Subselection
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 子选择
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Though it produces the same visual effect, this example demonstrates two very
    different subselection techniques. We will discuss them separately here so you
    can understand their pros and cons as well as when to use one versus the other:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它产生了相同的效果，但这个例子展示了两种非常不同的子选择技术。我们将分别讨论它们，这样您可以了解它们的优缺点以及何时使用一种而不是另一种：
- en: '**Selector level-3 combinators:** On line `A`, `d3.select` is used with a special-looking
    string, which consists of one tag name connected with another one using a greater-than
    sign (U+003E, >). This syntax is called *combinators* (the greater-than sign here
    indicates it is a child combinator). Level-3 selector supports a few different
    kinds of structural combinators. Here, we will give a quick introduction to the
    most common ones.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器级别-3组合器**: 在行 `A`，`d3.select` 使用了一个看起来特殊的字符串，该字符串由一个标签名和一个使用大于号（U+003E,
    >）连接的另一个标签名组成。这种语法称为 *组合器*（这里的大于号表示它是一个子组合器）。级别-3选择器支持几种不同的结构组合器。在这里，我们将简要介绍其中最常见的一些。'
- en: '**The descendant combinator**: This combinator has the syntax just like `selector
    selector`. The descendant combinator, as suggested by its name, is used to describe
    a loose parent-child relationship between two selections. The reason why it is
    called a loose parent-child relationship is that the descendant combinatory does
    not care if the second selection is a child or a grandchild or a great-grandchild
    of the parent selection. Let''s take a look at some examples to illustrate this
    loose relationship concept:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后代组合器**: 这个组合器的语法与 `selector selector` 相同。正如其名称所暗示的，后代组合器用于描述两个选择之间的松散父子关系。之所以称之为松散的父子关系，是因为后代组合器不关心第二个选择是否是父选择器的子元素、孙子元素或曾孙元素。让我们通过一些例子来阐述这种松散关系概念：'
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we use the following selector:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用以下选择器：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It will select the `em` element since `div` is the ancestor of the `em` element
    and `em` is a descendent of the `div` element.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将选择 `em` 元素，因为 `div` 是 `em` 元素的祖先元素，而 `em` 是 `div` 元素的子元素。
- en: '**Child combinator**: This combinator has the syntax such as `selector > selector`.
    The child combinator offers a more restrictive way to describe a parent-child
    relationship between two elements. A child combinator is defined using a greater-than
    sign (U+003E, >) character separating the two selectors, as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子组合器**: 这个组合器的语法类似于 `selector > selector`。子组合器提供了一种更严格的方式来描述两个元素之间的父子关系。子组合器是通过使用大于号（U+003E,
    >）字符分隔两个选择器来定义的，如下所示：'
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will select the `em` element since `em` is a direct child of the `span` element
    in our example. The selector `div > em` will not produce any valid selection since
    `em` is not a direct child of the `div` element.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将选择 `em` 元素，因为在我们这个例子中 `em` 是 `span` 元素的直接子元素。选择器 `div > em` 不会产生任何有效选择，因为
    `em` 不是 `div` 元素的直接子元素。
- en: Note
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The level-3 selector also supports sibling combinators; however, since it is
    less common, we will not cover it here; interested readers can refer to W3C level-3
    selector documentation at [http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)
    . The W3C level-4 selector offers some interesting additional combinators, that
    is, following-sibling and reference combinators that can yield some very powerful
    target selection capability; refer to [https://drafts.csswg.org/selectors-4/#combinators](https://drafts.csswg.org/selectors-4/#combinators)
    for more details.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三级选择器也支持兄弟组合器；然而，由于它不太常见，我们在这里不会涉及；感兴趣的读者可以参考 W3C 第三级选择器文档，网址为 [http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)
    。W3C 第四级选择器提供了一些有趣的附加组合器，即后续兄弟和引用组合器，这些组合器可以提供一些非常强大的目标选择能力；更多详情请参阅 [https://drafts.csswg.org/selectors-4/#combinators](https://drafts.csswg.org/selectors-4/#combinators)。
- en: '**The D3 nested subselection**: On lines `B` and `C`, a different kind of subselection
    technique was used. In this case, a simple D3 selection was made first on line
    `B` by selecting the `section #section2` element. Immediately afterward, another
    `select` was chained to select a `div` element on line `C`. This kind of nested
    selection defines a scoped selection. In plain English, this basically means to
    select a `div` element that is nested under `#section2`. In semantics, this is
    essentially the same as using a descendant combinator `#section2 div`. However,
    the advantage of this form of subselection is that since the parent element is
    separately selected, it allows you to handle the parent element before selecting
    the child element. To demonstrate this, let''s take a look at the following code
    snippet:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D3嵌套子选择**：在行`B`和`C`上，使用了不同类型的子选择技术。在这种情况下，首先在行`B`上通过选择`section #section2`元素进行简单的D3选择。紧接着，在行`C`上又进行了一次`select`操作来选择一个`div`元素。这种嵌套选择定义了一个作用域选择。用简单的话来说，这基本上意味着选择嵌套在`#section2`下的`div`元素。在语义上，这本质上等同于使用后代组合器`#section2
    div`。然而，这种子选择形式的优势在于，由于父元素是单独选择的，它允许你在选择子元素之前处理父元素。为了演示这一点，让我们看一下以下代码片段：'
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As shown in the preceding code snippet, you can see that before we select the
    `div` element, we can apply a modifier function to `#section2` on line `B-1`.
    This flexibility will be further explored in the next section.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，您可以看到在选中`div`元素之前，我们可以在行`B-1`上对`#section2`应用一个修改器函数。这种灵活性将在下一节中进一步探讨。
- en: Function chaining
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数链
- en: As we have seen so far, the D3 API is completely designed around the idea of
    function chaining. Therefore, it forms a DSL for building HTML/SVG elements dynamically.
    In this code example, we will take a look at how the entire body structure of
    the previous example can be constructed using D3 alone.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，D3 API完全围绕函数链的概念设计。因此，它形成了一个用于动态构建HTML/SVG元素的领域特定语言（DSL）。在这个代码示例中，我们将看看如何仅使用D3构建上一个示例的整个主体结构。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If DSL is a new concept for you, I highly recommend checking out this excellent
    explanation on DSL by *Martin Fowler* in the form of an excerpt from his book
    *Domain-Specific Languages*. The excerpt can be found at [http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379)
    .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DSL对您来说是一个新概念，我强烈推荐您查看由*马丁·福勒*在其书籍《领域特定语言》中的摘录形式提供的关于DSL的出色解释。摘录可以在 [http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379)
    找到。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html)
    .'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/function-chain.html)。'
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take a look at how a function chain can be used to produce concise and
    readable code that produces dynamic visual content:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用函数链来生成简洁且易于阅读的代码，这些代码可以生成动态的视觉内容：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code generates the following visual output (similar to what we saw in
    the previous chapter):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下视觉输出（类似于我们在上一章中看到的）：
- en: '![How to do it...](img/image_02_004.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_02_004.jpg)'
- en: Function chain
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数链
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Despite the visual similarity to the previous example, the construction process
    of the DOM elements is significantly different in this example. As demonstrated
    by the code example, there is no static HTML element on the page contrary to the
    previous recipe where both the `section` and `div` elements existed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与上一个例子在视觉上相似，但在这个例子中，DOM元素的构建过程与上一个菜谱有显著不同。正如代码示例所示，与上一个菜谱中同时存在`section`和`div`元素不同，页面上没有静态的HTML元素。
- en: Let's examine closely how these elements were dynamically created. On line A,
    a general selection was made to the top-level `body` element. The `body` selection
    result was cached using a local variable called `body`. Then, at line `B`, a new
    element `section` was appended to the body. Remember that the `append` function
    returns a new selection that contains the newly appended element; therefore, on
    line `C`, the `id` attribute can then be set on a newly created section element
    to `section1`. Afterward, on line `D`, a new `div` element was created and appended
    to `#section1` with its CSS class set to `blue box` on line `E`. For the next
    step, similar to the previous line, on line `F`, a `paragraph` element was appended
    to the `div` element with its textual content set to `dynamic blue box` on line
    `G`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这些元素是如何动态创建的。在第A行，对顶级`body`元素进行了通用选择。使用名为`body`的局部变量缓存了`body`选择结果。然后，在第B行，向body中添加了一个新的`section`元素。记住，`append`函数返回一个包含新添加元素的新选择；因此，在第C行，可以将新创建的`section`元素的`id`属性设置为`section1`。之后，在第D行，创建了一个新的`div`元素并将其附加到`#section1`上，其CSS类在E行设置为`blue
    box`。对于下一步，类似于上一行，在第F行，将一个`paragraph`元素附加到`div`元素上，其文本内容在G行设置为`dynamic blue box`。
- en: As illustrated by this example, this chaining process can continue to create
    any structure of arbitrary complexity. In fact this is how a typical D3-based
    data visualization structure is created. Many visualization projects simply contain
    only a HTML skeleton and rely on D3 to create the rest. Getting comfortable with
    this way of function chaining is critical if you want to become efficient with
    the D3 library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，此链式过程可以继续创建任意复杂度的结构。实际上，这就是典型的基于D3的数据可视化结构创建方式。许多可视化项目仅包含HTML骨架，并依赖于D3创建其余部分。如果您想高效地使用D3库，熟悉这种函数链式方法至关重要。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of D3's modifier functions return a new selection, such as the `select`,
    `append`, and `insert` functions. It is a good practice to use different levels
    of indentation to differentiate the selection your function chain is being applied
    on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: D3的一些修改函数返回一个新的选择，例如`select`、`append`和`insert`函数。使用不同级别的缩进区分函数链正在应用的选择是一个好习惯。
- en: Manipulating the raw selection
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作原始选择
- en: Sometimes, having access to the D3 raw selection array might be beneficial in
    development whether it's for debugging purposes or for integrating with other
    JavaScript libraries, which require access to raw DOM elements; in this recipe,
    we will show you ways to do that. We will also see some, internal structure of
    a D3 selection object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在开发过程中访问D3原始选择数组可能有益，无论是用于调试目的还是与其他需要访问原始DOM元素的JavaScript库集成。在这个菜谱中，我们将向您展示如何做到这一点。我们还将看到D3选择对象的一些内部结构。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html)
    .'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter2/raw-selection.html)
    .'
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Of course, you can achieve this using the `nth-child` selector or the selection
    iterator function `each`, but there are cases where these options are just too
    cumbersome and inconvenient. This is when you might find dealing with the raw
    selection array a more convenient approach. In this example, we will see how the
    raw selection array can be accessed and leveraged:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用`nth-child`选择器或选择迭代函数`each`来实现这一点，但在某些情况下，这些选项可能过于繁琐和不方便。这时，您可能会发现处理原始选择数组是一种更方便的方法。在这个例子中，我们将看到如何访问和利用原始选择数组：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This recipe generates the following visual output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱生成以下视觉输出：
- en: '![How to do it...](img/image_02_005.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_02_005.jpg)'
- en: Raw selection manipulation
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 原始选择操作
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we went through an existing HTML table to color the table.
    This is not intended to be a good example of how you would color odd versus even
    rows in a table using D3\. Instead, this example is designed to show how raw selection
    array can be accessed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们遍历了一个现有的HTML表格来着色表格。这并不是一个很好的例子，说明你如何使用D3来着色表格中的奇数行和偶数行。相反，这个例子旨在展示如何访问原始选择数组。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A much better way to color odd and even rows in a table would be using the `each`
    function and then relying on the index parameter `i` to do the job.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格中为奇数和偶数行着色的一个更好的方法就是使用`each`函数，然后依靠索引参数`i`来完成这项工作。
- en: On line `A`, we select all rows and store the selection in the `trSelection`
    variable. D3 selection has a convenient `node()` function that returns an array
    containing the selected element nodes. Thus, in order to access the first selected
    element, you will need to use `d3.selectAll("tr").nodes()[0]`, the second element
    can be accessed with `d3.selectAll("tr").nodes()[1]`, and so on. As we can see
    on line `B`, the table header element can be accessed using `trSelection.nodes()[0]`
    and this will return a DOM element object. Again, as we have demonstrated in previous
    sections, any DOM element can then be selected directly using `d3.select` as shown
    on line `C`. Line `D`, `E`, and `F` demonstrate how each element in selection
    can be directly indexed and accessed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`A`上，我们选择所有行并将选择存储在`trSelection`变量中。D3选择有一个方便的`node()`函数，它返回一个包含所选元素节点的数组。因此，为了访问第一个选中的元素，你需要使用`d3.selectAll("tr").nodes()[0]`，第二个元素可以通过`d3.selectAll("tr").nodes()[1]`访问，依此类推。正如我们在行`B`上所看到的，可以使用`trSelection.nodes()[0]`来访问表格的表头元素，这将返回一个DOM元素对象。同样，正如我们在前面的章节中所展示的，任何DOM元素都可以直接使用`d3.select`来选择，如行`C`所示。行`D`、`E`和`F`演示了如何直接索引和访问选择中的每个元素。
- en: Raw selection access could be handy in some cases especially when you need to
    use D3 in partnership with other JavaScript libraries since other libraries won't
    be able to work with D3 selection but only with raw DOM elements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，原始选择访问可能很有用，尤其是当你需要与其他JavaScript库一起使用D3时，因为其他库无法与D3选择一起工作，而只能与原始DOM元素一起工作。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Additionally, this approach is typically very useful in a testing environment
    where knowing the absolute index for each element quickly and gaining a reference
    to them could be convenient. We will cover unit tests in a later chapter in more
    detail.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法在测试环境中通常非常有用，因为在测试环境中，快速知道每个元素的绝对索引并获得它们的引用可能会很方便。我们将在稍后的章节中更详细地介绍单元测试。
- en: In this chapter we covered many different ways of how HTML elements can be selected
    and manipulated using D3's selection API. In the next chapter, we will explore
    how data can be bound to such selection to dynamically drive the visual appearance
    of selected elements which is the fundamental step of data visualization.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多不同的方法，说明了如何使用D3的选择API来选择和操作HTML元素。在下一章中，我们将探讨如何将数据绑定到这样的选择上，以动态驱动选中元素的可视外观，这是数据可视化的基本步骤。
