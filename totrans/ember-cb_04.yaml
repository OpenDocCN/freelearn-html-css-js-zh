- en: Chapter 4. Ember Router
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：Ember路由器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Defining an application route
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序路由
- en: Setting up a route model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置路由模型
- en: Handling dynamic segments inside routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由中处理动态段
- en: Defining routes with templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板定义路由
- en: Using redirection with routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由进行重定向
- en: Working with asynchronous routing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步路由
- en: Loading and error handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和错误处理
- en: Using query parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The router in Ember is responsible for changing the state of the application
    when a user performs an action. This can be anything from the user changing the
    URL to hitting the back button in the application. Regardless of what action is
    performed, the route handler is responsible. It takes the current URL and maps
    it to the correct route so that it can be displayed to the user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ember中的路由器负责在用户执行操作时更改应用程序的状态。这可能包括用户更改URL或在应用程序中点击后退按钮。无论执行什么操作，路由处理程序都负责。它获取当前URL并将其映射到正确的路由，以便向用户显示。
- en: Route handlers take care of rendering templates, loading up the model, and redirecting
    and transitioning from one route to another. They can also handle actions that
    occur when the model changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序负责渲染模板、加载模型以及从一个路由到另一个路由的重定向和过渡。它们还可以处理模型变化时发生的行为。
- en: Defining an application route
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序路由
- en: When loading your application, the router looks at the URL and matches it to
    the route. We'll go over some basics on how this works.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载应用程序时，路由器会查看URL并将其与路由匹配。我们将介绍一些关于它是如何工作的基础知识。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The route map is used to define the URL mappings. Let's take a look at adding
    a new route using `this.route`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 路由图用于定义URL映射。让我们看看如何使用`this.route`添加新路由。
- en: 'In a new application, open the `router.js` file in the `app` folder. To begin,
    we''ll create a new route called `about`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用程序中，打开`app`文件夹中的`router.js`文件。首先，我们将创建一个名为`about`的新路由：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Router.map` in the preceding code handles the routing of the program. The
    `this.route` creates the `about` route. By default, the name of the route will
    be the same as the path to it. For example, the `about` route path would be located
    at `/about`. We can specifically set the path using `path`.'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码中的`Router.map`处理程序的程序路由。`this.route`创建`about`路由。默认情况下，路由的名称将与路径相同。例如，`about`路由路径将位于`/about`。我们可以使用`path`来具体设置路径。
- en: 'Instead of having all requests go to `/about`, let''s change the path so that
    they go to `/me`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望所有请求都发送到`/about`，让我们更改路径，使它们发送到`/me`：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The new route `about` will be mapped to the URL `/aboutme now`.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的路由`about`现在将被映射到URL `/aboutme`。
- en: 'To test this, we can create a new template and add a `link-to` helper to our
    application route. First, we''ll create the template:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以创建一个新的模板并在应用程序路由中添加一个`link-to`助手。首先，我们将创建模板：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Ember CLI generated will create the template for us. This will create the
    `about.hbs` file in the `app/templates` folder.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember CLI为我们创建的模板。这将创建`app/templates`文件夹中的`about.hbs`文件。
- en: 'Add the `link-to` helper to the `application.hbs` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`link-to`助手添加到`application.hbs`文件中：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code creates a new link to the `about` template in the main application
    template.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码在主应用程序模板中创建了一个指向`about`模板的新链接。
- en: 'Add a new message to the `about` template that we just created:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们刚刚创建的`about`模板添加一条新消息：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This text will be displayed only when we navigate to this new route.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们导航到这个新路由时，将只显示此文本。
- en: We can now run the server and check the output. Run `ember server` and click
    on the **about template** link. The about route will load and will look as follows:![How
    to do it...](img/00008.jpeg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行服务器并检查输出。运行`ember server`并点击**about模板**链接。about路由将加载，如下所示：![如何操作...](img/00008.jpeg)
- en: Tip
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Application route**'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用程序路由**'
- en: When your app first boots up, the application route is loaded. Just like any
    other route, the application template will load by default. The application route
    is given for free and does not need to be added to the `app/router.js` file. The
    `{{outlet}}` will be used to render all other routes. It's a good idea to put
    the header, footer, and other decorative content here.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您的应用程序首次启动时，应用程序路由将被加载。就像任何其他路由一样，应用程序模板将默认加载。应用程序路由是免费提供的，不需要添加到`app/router.js`文件中。`{{outlet}}`将用于渲染所有其他路由。在这里放置页眉、页脚和其他装饰性内容是个好主意。
- en: Working with nested routes in your application
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用嵌套路由
- en: At times, you may need multiple levels of routes. You might need templates within
    other templates. This can be accomplished using nested routes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要多个级别的路由。您可能需要在其他模板中包含模板。这可以通过嵌套路由来实现。
- en: 'Let''s say that we had `about` with a nested `location` and `job` route:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个 `about` 路由，其中嵌套了 `location` 和 `job` 路由：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The router `map` has the highest-level route called `about`. Underneath this
    route is the `location` and `job`. Create two templates needed for `location`
    and `job`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由 `map` 有一个最高级别的路由称为 `about`。在这个路由之下是 `location` 和 `job`。创建 `location` 和 `job`
    所需的两个模板：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create the correct `location.hbs` and `job.hbs` files in the `app/templates/about`
    folder as well as the `about.hbs` file in the `app/templates` folder.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在 `app/templates/about` 文件夹中创建正确的 `location.hbs` 和 `job.hbs` 文件，以及在 `app/templates`
    文件夹中的 `about.hbs` 文件。
- en: 'For us to be able to access nested routes, we''ll need to edit `about.hbs`
    and add `outlet` for the `location` and `job` nested routes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够访问嵌套路由，我们需要编辑 `about.hbs` 并为 `location` 和 `job` 嵌套路由添加 `outlet`：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note how the `link-to` helpers route to `about.location`. You can link nested
    routes with the dot notation. The `location` and `job` nested routes will render
    in `{{outlet}}`.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `link-to` 辅助函数如何路由到 `about.location`。您可以使用点符号来链接嵌套路由。`location` 和 `job` 嵌套路由将在
    `{{outlet}}` 中渲染。
- en: 'Just to make things interesting, we''ll update the `job` and `location` route
    templates:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，我们将更新 `job` 和 `location` 路由模板：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we''ll add a `link-to` helper to the application route:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在应用程序路由中添加一个 `link-to` 辅助函数：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `link-to` helper will route to about. This will be rendered in `outlet`.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`link-to` 辅助函数将路由到 `about`。这将渲染在 `outlet` 中。'
- en: After running `ember server`, you'll have access to click on the links and go
    between the routes. It should look similar to the following image:![Working with
    nested routes in your application](img/00009.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 后，您将可以点击链接并在路由间切换。它应该看起来与以下图片相似：![在您的应用程序中使用嵌套路由](img/00009.jpeg)
- en: If we click on the **job** link, the URL changes to `http://localhost:4200/about/job`.
    The `{{outlet}}` in the `about` template will then display the `job` template
    information.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们点击 **工作** 链接，URL 将更改为 `http://localhost:4200/about/job`。然后 `about` 模板中的
    `{{outlet}}` 将显示 `job` 模板信息。
- en: Adding a wildcard
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加通配符
- en: You can use wildcards in your routes. This allows you to create URLs that match
    multiple segments. Let's create a wildcard for any URL that isn't found.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在路由中使用通配符。这允许您创建匹配多个段的 URL。让我们为任何未找到的 URL 创建一个通配符。
- en: 'In a new project, update the `router.js` file in the `app` folder:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，更新 `app` 文件夹中的 `router.js` 文件：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `/*wildcard` path will catch all the undefined routes and route them to
    `page-not-found`.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/*wildcard` 路径将捕获所有未定义的路由并将它们路由到 `page-not-found`。'
- en: 'Create a new `page-not-found` template:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `page-not-found` 模板：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This route will render in the `application.hbs` outlet whenever a user navigates
    to a URL that matches `/*` and no existing routes match.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户导航到匹配 `/*` 且没有现有路由匹配的 URL 时，此路由将在 `application.hbs` 的 `outlet` 中渲染。
- en: Adding dynamic segments to our about application
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向我们的关于应用程序添加动态段
- en: One important responsibility of the route is to load a model. In this example,
    we'll create a simple dynamic segment in the router that lists multiple jobs for
    the about route.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的一个重要责任是加载模型。在这个例子中，我们将在路由中创建一个简单的动态段，列出关于路由的多个工作。
- en: 'In a new project, edit the `router.js` file and add the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，编辑 `router.js` 文件并添加以下代码：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: View the output, and we can see that the router map shows an `about` route and
    a nested `location` route below it. The `location` route is a dynamic segment
    that starts with `:` and is followed by an identifier. The `:location_id` identifier
    will retrieve the model information from the `location` model.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出，我们可以看到路由图显示了 `about` 路由及其下方的嵌套 `location` 路由。`location` 路由是一个以 `:` 开头的动态段，后面跟着一个标识符。`:location_id`
    标识符将从 `location` 模型检索模型信息。
- en: For example, if a user navigates to `/about/5`, the route will set `location_id`
    of `5` so that the `location` model with the ID of `5` is loaded. We'll be going
    over the `about` routes in more detail in the next section.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果用户导航到 `/about/5`，则路由将设置 `location_id` 为 `5`，以便加载具有 `5` ID 的 `location`
    模型。我们将在下一节中更详细地介绍 `about` 路由。
- en: Note
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Index routes**'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**索引路由**'
- en: At every level of nesting, including the application layer, Ember.js automatically
    creates a route called **index**. You don't need to map this in `router.js`. Similar
    to the application route, it's already there. The index route will automatically
    be rendered in the outlet of its parent's template. For example, if you created
    an `index.hbs` file in the `app/templates` folder, it would automatically be rendered
    in the `application.hbs` outlet. Keep this in mind when you create routes.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在嵌套的每一层，包括应用层，Ember.js 都会自动创建一个名为 **index** 的路由。你不需要在 `router.js` 中映射它。类似于应用路由，它已经存在了。索引路由将自动在其父模板的出口处渲染。例如，如果你在
    `app/templates` 文件夹中创建了一个 `index.hbs` 文件，它将自动在 `application.hbs` 出口处渲染。创建路由时请记住这一点。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Routes in Ember.js are defined in the `app/router.js` file. The router map is
    used to define each route, and it tells the Ember application what path should
    be used in the URL. By convention, each route has a corresponding template with
    the same name. Wildcards and dynamic segments can make routes more versatile so
    that they can load specific data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 中的路由定义在 `app/router.js` 文件中。路由映射用于定义每个路由，并告诉 Ember 应用程序应使用 URL 中的哪个路径。按照惯例，每个路由都有一个同名的模板。通配符和动态段可以使路由更加灵活，以便它们可以加载特定数据。
- en: Setting up a route model
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置路由模型
- en: Occasionally, you'll need to retrieve data from a model for a template. The
    route is responsible for loading the appropriate model. This recipe will go over
    how to do this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要从模型中检索数据以供模板使用。路由负责加载适当的模型。本教程将介绍如何进行此操作。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, open the `router.js` file and add a new route. We''ll
    call this route `students`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用中，打开 `router.js` 文件并添加一个新的路由。我们将把这个路由称为 `students`：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `students` route will retrieve data from the `students` route handler.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`students` 路由将从 `students` 路由处理程序中检索数据。'
- en: 'Generate the `students` route. This will create the `students` route handler
    and template:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成 `students` 路由。这将创建 `students` 路由处理程序和模板：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `students.js` file, add a new model that returns a JavaScript object:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `students.js` 文件中，添加一个新的模型，该模型返回一个 JavaScript 对象：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `model` hook normally returns an Ember Data record. However, it can also
    return any promise objects, plain JavaScript objects, or arrays. Ember will wait
    until the data is loaded or the promise is resolved before rending the template.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model` 钩子通常返回一个 Ember Data 记录。然而，它也可以返回任何承诺对象、纯 JavaScript 对象或数组。Ember 将等待数据加载或承诺解决后再渲染模板。'
- en: For simplicity in our example, we returned an array.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，为了简化，我们返回了一个数组。
- en: 'Create a simple `each` loop in the template to display the data from `model`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中创建一个简单的 `each` 循环来显示 `model` 中的数据：
- en: '[PRE16]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `each` loop will display each `number` in the array. The model data is returned
    from the route that we created earlier.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`each` 循环将显示数组中的每个 `number`。模型数据是从我们之前创建的路由返回的。'
- en: Run `ember server` and load the route at `http://localhost:4200/students`. It
    will look like the following image after it is rendered:![How to do it...](img/00010.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 并在 `http://localhost:4200/students` 路由上加载。渲染后，它将看起来像以下图片：![如何操作...](img/00010.jpeg)
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A very important job of a route is loading the model. Models are objects that
    represent data that your application may present to the user. The route can return
    an Ember Data record, array, or object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的一个重要任务是加载模型。模型是代表应用程序可能向用户展示的数据的对象。路由可以返回 Ember Data 记录、数组或对象。
- en: Handling dynamic segments inside routes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路由内的动态段
- en: Using dynamic segments and dynamic models is an important aspect of routes.
    The following recipe will go over how this can be accomplished.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态段和动态模型是路由的一个重要方面。以下教程将介绍如何实现这一点。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin our recipes, we'll need to set up a plugin called **Ember CLI
    Mirage**. Ember plugins, also known as **add-ons**, make it easy to share common
    code between applications. The Ember CLI Mirage plugin makes it easy to create
    a mock server so that we can develop, test, and prototype our data. We won't cover
    too much of this add-on in this chapter. If you'd like more information, you can
    download it at [https://github.com/samselikoff/ember-cli-mirage](https://github.com/samselikoff/ember-cli-mirage).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始我们的食谱之前，我们需要设置一个名为**Ember CLI Mirage**的插件。Ember插件，也称为**附加组件**，使得在应用程序之间共享通用代码变得容易。Ember
    CLI Mirage插件使得创建模拟服务器变得容易，这样我们就可以开发、测试和原型化我们的数据。在本章中，我们不会过多地介绍这个附加组件。如果您想了解更多信息，您可以在[https://github.com/samselikoff/ember-cli-mirage](https://github.com/samselikoff/ember-cli-mirage)下载。
- en: In this example, we'll use the **Ember Data's RESTAdapter**, not the new **JSON
    API** adapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用**Ember Data的RESTAdapter**，而不是新的**JSON API**适配器。
- en: 'In a new project, run this installation command in the `application` folder:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，在`application`文件夹中运行以下安装命令：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will install version `0.1.11` of Ember CLI Mirage, Bower, and `npm` packages
    in the application. We'll be using this version for all the examples in the book.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装Ember CLI Mirage `0.1.11`版本、Bower和`npm`包到应用程序中。我们将使用这个版本在本书的所有示例中。
- en: 'Open the `config.js` file in the `app/mirage` folder. Add a couple of new routes:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/mirage`文件夹中的`config.js`文件中打开。添加几个新的路由：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first fake route, `/students`, will return all the student data from our
    Mirage in the memory database. The second fake route, `/students/:id`, will return
    only the data that matches the ID in the URL. This will be used later when we
    try out dynamic segments with our models.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个模拟路由`/students`将返回我们Mirage内存数据库中的所有学生数据。第二个模拟路由`/students/:id`将只返回与URL中的ID匹配的数据。这将在我们尝试使用模型动态段时使用。
- en: 'Create a new set of fixture data for `students`. Create a new file called `students.js`
    in the `app/mirage/fixtures` directory:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`students`创建一组新的固定数据。在`app/mirage/fixtures`目录中创建一个名为`students.js`的新文件：
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This file name, `students.js`, matches the route and will be used to load the
    data in Mirages in the memory database. Be aware that Mirage also supports factories.
    Factories is an immensely powerful feature that makes it extremely easy to load
    lots of fake data. The factories can be used in test cases as well.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件名`students.js`与路由匹配，并将用于在Mirage内存数据库中加载数据。请注意，Mirage还支持工厂。工厂是一个功能强大的特性，使得加载大量虚假数据变得极其容易。工厂也可以用于测试用例。
- en: For simplicity's sake, we'll just use fixture data.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只使用固定数据。
- en: 'Load a new scenario for our application. Update the `app/mirage/scenarios/default.js`
    file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用程序加载一个新的场景。更新`app/mirage/scenarios/default.js`文件：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `default.js` file in the `scenarios` folder is used to seed the database
    in development. The `server.loadFixtures()` method loads all the fixture data
    so that it can be accessible to the `/students` route.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`scenarios`文件夹中的`default.js`文件用于在开发中初始化数据库。`server.loadFixtures()`方法加载所有固定数据，以便它可以被`/students`路由访问。'
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Data in our model may never change. On the other hand, that data might change
    many times depending on interactions with the user. This recipe will cover how
    to use dynamic segments with your routes and return data from the model.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型中的数据可能永远不会改变。另一方面，这些数据可能会根据与用户的交互多次更改。这个食谱将介绍如何使用动态段与您的路由一起使用并从模型返回数据。
- en: 'Begin by creating a new resource called `students`. Then generate an adapter
    named `application` and finally, a route:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为`students`的新资源。然后生成一个名为`application`的适配器，最后创建一个路由：
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will generate the routes, adapter, and template files needed for this recipe.
    Keep in mind that by generating the `application` route, you will be prompted
    to overwrite the `application.hbs` file. You can select *n*, for no, when this
    occurs.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成本食谱所需的路线、适配器和模板文件。请注意，通过生成`application`路由，您将被提示覆盖`application.hbs`文件。当发生这种情况时，您可以选择*n*，即不覆盖。
- en: 'Update the `router.js` file with the new dynamic segment route:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中更新新的动态段路由：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new route has a path of `/students/:student_id`. This route will extract
    `:student_id` from the URL and pass it to the model hook as the first argument.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新的路由路径为`/students/:student_id`。这个路由将从URL中提取`:student_id`并将其作为第一个参数传递给模型钩子。
- en: For example, let's say that we have a list of `students` and we wanted to be
    able to access each student's data by visiting `/students/1` and `/students/2`.
    Each URL would then return the data for that student.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个学生列表，并且我们希望能够通过访问 `/students/1` 和 `/students/2` 来访问每个学生的数据。每个 URL
    都将返回该学生的数据。
- en: 'Update the `application.js` file in the `app/adapters` folder:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/adapters` 文件夹中的 `application.js` 文件：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will create a new `RESTAdapter` that Ember will use for this example. This
    will be covered more in the models chapter.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的 `RESTAdapter`，Ember 将用于此示例。这将在模型章节中更详细地介绍。
- en: 'Edit the `students.js` file in the `app/models` folder. This file is our model
    and will be used to retrieve data from the Mirage mock server that we created
    earlier:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `app/models` 文件夹中的 `students.js` 文件。此文件是我们的模型，将用于从我们之前创建的 Mirage 模拟服务器检索数据：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates a new model with two attributes, `name` and `age`. The model file
    defines what the data will look like. We'll be covering this more in the *Chapter
    7*, *Ember Models and Ember Data*. For now, we will be retrieving this data from
    the mock server.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个具有两个属性 `name` 和 `age` 的新模型。模型文件定义了数据将如何看起来。我们将在 *第 7 章*，*Ember 模型和 Ember
    Data* 中更详细地介绍这一点。现在，我们将从模拟服务器检索这些数据。
- en: 'Update the `students.js` file in the `app/routes` folder. Add the Ember Data
    `findRecord` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/routes` 文件夹中的 `students.js` 文件。添加 Ember Data 的 `findRecord` 方法：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `model` hook here has one argument, `param`. The `param` argument is `student_id`
    that is passed from the route's URL. Ember Data has a `findRecord` method that
    takes two parameters. The first parameter is the name of the model and the second
    is the ID.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此处的 `model` 钩子有一个参数，即 `param`。`param` 参数是 `student_id`，它从路由的 URL 中传递过来。Ember
    Data 有一个 `findRecord` 方法，它接受两个参数。第一个参数是模型名称，第二个是 ID。
- en: This model will return the student record with the ID passed to it. We can now
    use this in our template.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模型将返回传递给它的 ID 的学生记录。我们现在可以在模板中使用它。
- en: 'Edit the `students.hbs` file in the `app/templates` folder. Add the model information:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `app/templates` 文件夹中的 `students.hbs` 文件。添加模型信息：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `{{model.name}}` and `{{model.age}}` properties will retrieve the model
    information passed to the template from the route.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{model.name}}` 和 `{{model.age}}` 属性将检索从路由传递到模板的模型信息。'
- en: At this point, we should be able to run `ember server` and see data when we
    access `http://localhost:4200/students/1`. To make things a little easier, we'll
    go ahead and create a new route handler for the main application route.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够运行 `ember server` 并在访问 `http://localhost:4200/students/1` 时看到数据。为了使事情变得简单一些，我们将继续创建一个新的路由处理器用于主应用程序路由。
- en: 'Edit the `application.js` file in the `app/routes` folder:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `app/routes` 文件夹中的 `application.js` 文件：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '**Multiple models**'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**多个模型**'
- en: 'At times, you may want to use multiple models in one route. This can be accomplished
    using `Ember.RSVP.hash`. The hash takes parameters that return promises. When
    all the parameters are resolved, then `Ember.RSVP.hash` is resolved. In the model,
    it may look like this: return `Ember.RSVP.hash({ students: this.store.findAll(''student'')`,
    books: `this.store.findAll(''book'')})`. Each model is separated by a comma.'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '有时，你可能想在一条路由中使用多个模型。这可以通过使用 `Ember.RSVP.hash` 来实现。该 hash 接收返回承诺的参数。当所有参数都解析完成后，`Ember.RSVP.hash`
    才会解析。在模型中，它可能看起来像这样：`return Ember.RSVP.hash({ students: this.store.findAll(''student''),
    books: this.store.findAll(''book'')})`。每个模型之间用逗号分隔。'
- en: This will allow our application to retrieve all the records from our student
    model.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许我们的应用程序从我们的学生模型中检索所有记录。
- en: 'Open the `application.hbs` file in the `app/templates` folder. We''ll add an
    `each` iterator that will link to each student''s information:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/templates` 文件夹中的 `application.hbs` 文件。我们将添加一个 `each` 迭代器，它将链接到每个学生的信息：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this template, we are iterating through all the records in the `student`
    model. We are using each individual student's name as a link to our dynamic segment.
    The `student.id` argument is passed to the `link-to` helper.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此模板中，我们正在迭代 `student` 模型中的所有记录。我们使用每个学生的名字作为链接到我们的动态段。`student.id` 参数传递给 `link-to`
    辅助函数。
- en: After starting the server, you'll see a list of the students and a link to each
    student's information. After clicking on the student's name, the `student.hbs`
    template will load with the student's information. It will look like the following
    image:![How to do it...](img/00011.jpeg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器后，你会看到一个学生列表以及每个学生信息的链接。点击学生的名字后，`student.hbs` 模板将加载并显示学生的信息。它看起来像以下图片：![如何操作...](img/00011.jpeg)
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Dynamic models allow data to change depending on the user action. This data
    will depend on the dynamic segment setup in the `router.js` file. The segment
    is defined in the `router` file and passed from the URL to the model hook as its
    first argument. Ember Data uses the `findRecord` method to find the correct record
    and return it to the template so that it's available for use.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 动态模型允许数据根据用户操作而变化。这些数据将取决于`router.js`文件中设置的动态段。该段在`router`文件中定义，并从URL传递给模型钩子作为其第一个参数。Ember
    Data使用`findRecord`方法查找正确的记录并将其返回到模板，以便可以使用。
- en: Defining routes with templates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板定义路由
- en: Another job of the route handler is rendering the appropriate template. Here
    is a recipe that goes over this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理器的另一个任务是渲染适当的模板。以下是一个关于这一点的示例。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we'll create a few nested routes and check where they get rendered.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一些嵌套路由并检查它们在哪里渲染。
- en: 'In a new project, create a new `students` and `schools` route:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，创建一个新的`students`和`schools`路由：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will create the nested `students` and `schools` route.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建嵌套的`students`和`schools`路由。
- en: 'Let''s take a look at the `router.js` file:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`router.js`文件：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The generated command already created the routes that we need. The `schools`
    route has a nested route called `students`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的命令已经创建了我们需要的路由。`schools`路由有一个嵌套的路由，称为`students`。
- en: By convention, the route will render the template with the same name. Therefore,
    the `schools` route will render to the `schools.hbs` file while the `students`
    route will be rendered to the `schools/students.hbs` file.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据约定，路由将渲染与名称相同的模板。因此，`schools`路由将渲染到`schools.hbs`文件，而`students`路由将渲染到`schools/students.hbs`文件。
- en: 'Update the `schools.hbs` file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`schools.hbs`文件：
- en: '[PRE31]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `{{outlet}}` will render the `students.hbs` file in the `schools` folder.
    Every template will be rendered to `{{outlet}}` of its parent route's template.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{outlet}}`将在`schools`文件夹中渲染`students.hbs`文件。每个模板都将渲染到其父路由模板的`{{outlet}}`中。'
- en: 'Update the `students.hbs` file in the `app/templates/schools` folder:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app/templates/schools`文件夹中的`students.hbs`文件：
- en: '[PRE32]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run `ember server` and you should see this result:![How to do it...](img/00012.jpeg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ember server`，你应该看到这个结果：![如何操作...](img/00012.jpeg)
- en: By visiting `http://localhost:4200/schools/students`, both the templates are
    displayed. The application `{{outlet}}` renders the school template. The school
    template's `{{outlet}}` renders the students template.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问`http://localhost:4200/schools/students`，将显示两个模板。应用程序`{{outlet}}`渲染学校模板。学校模板的`{{outlet}}`渲染学生模板。
- en: 'If required, you can change where the route renders. Instead of rendering in
    the template with the same name, you can set it to anything using the `renderTemplate()`
    method in the route handler:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，您可以更改路由的渲染位置。您不必在具有相同名称的模板中渲染，而是可以使用路由处理器中的`renderTemplate()`方法将其设置为任何内容：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The school route will now render to the `anotherSchool` template.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学校路由现在将渲染到`anotherSchool`模板。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Routes, by default, will render a template based on the same name as the route.
    Ember does this by convention. On the other hand, using `renderTemplate` in the
    route handler can change this default. This is all done under the hood by the
    Ember API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，路由将根据路由的名称渲染模板。Ember通过约定来实现这一点。另一方面，在路由处理器中使用`renderTemplate`可以改变这个默认设置。所有这些都是在Ember
    API的底层完成的。
- en: Using redirection with routes
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由进行重定向
- en: A very important feature of routes is redirection. This recipe will go over
    using the `transitionTo` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的一个重要特性是重定向。这个示例将介绍如何使用`transitionTo`方法。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In our route handler, we have special hooks called `beforeModel` and `afterModel`.
    We can use these hooks to perform actions before the model is loaded or after
    the model is loaded. The `transitionTo` method can be used to redirect the application
    to different routes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由处理器中，我们有特殊的钩子，称为`beforeModel`和`afterModel`。我们可以使用这些钩子在模型加载前或加载后执行操作。`transitionTo`方法可以用来将应用程序重定向到不同的路由。
- en: 'In a new application, create a new `students` route:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用中，创建一个新的`students`路由：
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will generate the `students` route and template files.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成`students`路由和模板文件。
- en: 'For the sake of simplicity, we''ll have the route handler return a simple array
    of numbers:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化，我们将让路由处理器返回一个简单的数字数组：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Edit the `routes/students.js` file again. This time, we''ll add a before hook
    and a transition to it:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编辑`routes/students.js`文件。这次，我们将添加一个before钩子和一个过渡到它：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `transitionTo` method will redirect from one route to another. This option
    will redirect before the model is loaded and transition to the teacher's route.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`transitionTo` 方法将从一条路由重定向到另一条路由。此选项将在模型加载之前进行重定向并切换到教师的路由。'
- en: 'We can also transition after the model is loaded using the `afterModel()` hook:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用 `afterModel()` 钩子在模型加载后进行转换：
- en: '[PRE37]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will wait until the model is fully loaded before transitioning to the new
    route. You can check the loaded route before transitioning, if needed.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在切换到新路由之前等待模型完全加载。如果需要，您可以在切换之前检查已加载的路由。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Redirect**'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重定向**'
- en: When transitioning to nested routes, it's a good idea to use the `redirect`
    method instead of the `afterModel` or `beforeModel` hooks. This will prevent `beforeModel`,
    `afterModel`, and model from firing again after redirecting. Keep this in mind
    when dealing with `transitionTo` in nested routes.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当转换到嵌套路由时，使用 `redirect` 方法而不是 `afterModel` 或 `beforeModel` 钩子是个好主意。这将防止在重定向后再次触发
    `beforeModel`、`afterModel` 和模型。在处理嵌套路由中的 `transitionTo` 时，请记住这一点。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `afterModel` and `beforeModel` hooks occur after or before a model is loaded.
    The `transitionTo` method is used to redirect from one route to another. It can
    be used in the route handler or anywhere else in the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterModel` 和 `beforeModel` 钩子在模型加载之后或之前触发。`transitionTo` 方法用于从一条路由重定向到另一条路由。它可以在路由处理程序或应用程序的任何其他地方使用。'
- en: Working with asynchronous routing
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步路由
- en: A more advanced feature of the router is dealing with asynchronous logic. The
    following recipes explain this concept using promises.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器的一个更高级功能是处理异步逻辑。以下食谱使用承诺解释了这个概念。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the route, Ember makes heavy use of promises. Promises are objects that represent
    an eventual value. We can use promises in our model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由中，Ember 大量使用承诺。承诺是表示最终值的对象。我们可以在我们的模型中使用承诺。
- en: 'Create a new router for the application route:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用路由创建一个新的路由器：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If prompted to overwrite the template, type `Y`. This will generate the router
    file for the default application route.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果提示覆盖模板，请输入 `Y`。这将生成默认应用路由的路由器文件。
- en: 'Add a new model to the `application.js` file in the `app/router` folder:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/router` 文件夹中的 `application.js` 文件中添加一个新的模型：
- en: '[PRE39]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the router, we created a new model. This model will be accessible to our
    application template. In this model, we are returning `Ember.RSVP.Promise`, which
    is Ember's way of dealing with a promise. It can either resolve or reject. For
    the sake of simplicity, we are having it return a message.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在路由器中，我们创建了一个新的模型。这个模型将可用于我们的应用程序模板。在这个模型中，我们返回 `Ember.RSVP.Promise`，这是 Ember
    处理承诺的方式。它可以解决或拒绝。为了简单起见，我们让它返回一个消息。
- en: The `setupController` hook to set up the controller for the current route. As
    we are overwriting `setupController`, it also overwrites its default behavior.
    Therefore, we must call `super` on it. Otherwise it may effect how it normally
    behaves. We can use `console.log` to output the model message to the console.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setupController` 钩子用于设置当前路由的控制器。由于我们正在覆盖 `setupController`，它也会覆盖其默认行为。因此，我们必须在它上面调用
    `super`。否则，它可能会影响其正常行为。我们可以使用 `console.log` 将模型消息输出到控制台。'
- en: Tip
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Asynchronous routing**'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**异步路由**'
- en: During a transition, the model hook is fired in the router. If, during this
    transition, the model is returning an array, it will return immediately. On the
    other hand, if the model is returning a promise, it must wait for this promise
    to fulfill or reject. The router will consider any object with a `then` method
    defined on it to be a promise. After the promise fulfills, the transition will
    continue from where it left off. It's possible to chain multiple promises, so
    the next promise or model must be fulfilled before the transition will be complete.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在转换过程中，模型钩子在路由器中触发。如果在转换过程中模型返回一个数组，它将立即返回。另一方面，如果模型返回一个承诺，它必须等待这个承诺得到解决或拒绝。路由器将任何定义了
    `then` 方法的对象视为承诺。在承诺解决后，转换将从它离开的地方继续。可以链式多个承诺，因此下一个承诺或模型必须在转换完成之前得到解决。
- en: 'Let''s edit the application router one more time and set it to reject:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次编辑应用路由器并将其设置为拒绝：
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the model returns a rejected promise. As described in
    the *Loading and error handling* recipe, there is something called an `error`
    event. This will fire only when an error occurs in the model. We can then log
    the error to the console.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，模型返回一个拒绝的承诺。如*加载和错误处理*配方中所述，有一个名为`error`的事件。这个事件仅在模型中发生错误时才会触发。然后我们可以将错误记录到控制台。
- en: 'We can test this by editing the `application.hbs` file in the `app/templates`
    folder:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过编辑`app/templates`文件夹中的`application.hbs`文件来测试这一点：
- en: '[PRE41]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the promise doesn't reject, the model message will be displayed. If the model
    rejects, then nothing will be displayed; the route halts the loading and the console
    will show the message, **error**.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果承诺没有拒绝，将显示模型消息。如果模型拒绝，则不会显示任何内容；路由停止加载，控制台将显示**错误**信息。
- en: Error events bubble upwards. In this case, we are already on the application
    route and it can't bubble up any further. If we were in another route, we could
    have returned true and that error would have bubbled up to the application error
    event.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误事件向上冒泡。在这种情况下，我们已经在应用程序路由上，并且无法进一步冒泡。如果我们处于另一个路由，我们可以返回true，那么错误就会冒泡到应用程序错误事件。
- en: 'Edit the `application.js` file again in the `app/router` folder. Let''s deal
    with the rejection:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编辑`app/router`文件夹中的`application.js`文件。让我们处理拒绝：
- en: '[PRE42]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, the `RSVP` promise rejects. However, we then return the
    message anyway, by chaining another promise at the end. This way the transition
    won't halt and will continue.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RSVP`承诺拒绝。然而，我们仍然在最后链式返回一个消息。这样，转换就不会停止，并且会继续。
- en: Run `ember server` and open a web page. You should see this message:![How to
    do it...](img/00013.jpeg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ember server`并打开一个网页。您应该看到这条消息：![如何做...](img/00013.jpeg)
- en: This message shows **Returned from rejection** because we handled the promise
    reject callback and returned a message anyway.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这条消息显示**从拒绝返回**，因为我们处理了承诺拒绝回调并仍然返回了一个消息。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Promises are a way for Ember to handle asynchronous logic. A promise is an object
    that represents an eventual value. The promise can either reject or fullfill,
    as in resolve a value. To retrieve the value or handle when it rejects, you can
    use the then method, which can accept two different callbacks. The first is for
    fulfillment and the second is for rejection. For example, you might use the rejection
    to retry or return different data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是Ember处理异步逻辑的一种方式。承诺是一个表示最终值的对象。承诺可以拒绝或满足，即解决一个值。要检索值或处理拒绝，可以使用`then`方法，它可以接受两个不同的回调。第一个是用于满足，第二个是用于拒绝。例如，您可能使用拒绝来重试或返回不同的数据。
- en: Loading and error handling
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和错误处理
- en: When routes are loading or there's an error, we have the ability to let the
    user know what's happening. This recipe will go over the basics on how to do this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由正在加载或发生错误时，我们有能力让用户知道正在发生什么。这个配方将介绍如何做到这一点的基础知识。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In a new project, create a new `students` route:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，创建一个新的`students`路由：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `ember generate` command will create all the necessary files for the `students`
    route.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ember generate`命令将为`students`路由创建所有必要的文件。'
- en: 'Edit the `students.js` file in the `app/routes` folder. Add a new model to
    return:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/routes`文件夹中编辑`students.js`文件。添加一个新的模型返回：
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In our route file, we are returning an Ember `RSVP` promise. This promise resolves
    to a simple array that will be returned. `Ember.run.later` is a built-in Ember
    method that is a part of the Ember run loop. It acts like the JavaScript's `setTimeout()`.
    In this case, we are setting the timeout for 2,000 milliseconds so that we can
    simulate what might occur if the model was slow to load. After two seconds pass,
    the resolve will return with the array.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的路由文件中，我们返回一个Ember `RSVP`承诺。这个承诺解决为一个简单的数组，将被返回。`Ember.run.later`是Ember的一个内置方法，它是Ember运行循环的一部分。它类似于JavaScript的`setTimeout()`。在这种情况下，我们设置了2,000毫秒的超时，以便我们可以模拟如果模型加载缓慢可能会发生的情况。两秒钟后，解决将返回数组。
- en: 'Add a loading substate template in the `app/templates` folder:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/templates`文件夹中添加一个加载子状态模板：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This substate will be loaded while the students route is loading. A loading
    substate is created by adding a template with the name of the route and a dash
    loading at the end. For example, for the students route in our example, we called
    the `students-loading.hbs` substate. The application loading the substate would
    be `application-loading.hbs`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个子状态将在学生路由加载时被加载。通过添加一个带有路由名和结尾破折号加载的模板来创建一个加载子状态。例如，在我们的示例中，我们调用`students-loading.hbs`子状态。加载子状态的应用程序将是`application-loading.hbs`。
- en: 'As an alternative to substates, we can use a loading event in the route. If
    the `beforeModel`, `model`, and `afterModel` hooks don''t resolve immediately,
    the loading event will be fired. Add a new loading action that displays an alert
    box while the model loads and transitions to the application route:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为子状态的替代，我们可以在路由中使用加载事件。如果`beforeModel`、`model`和`afterModel`钩子不能立即解决，将触发加载事件。添加一个新的加载动作，在模型加载时显示弹窗，并过渡到应用程序路由：
- en: '[PRE46]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The alert box will fire while the route is loading.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当路由加载时，将触发弹窗。
- en: Navigate to `http://localhost:4200/students` and you'll see the alert box while
    the model is loading.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:4200/students`，当模型加载时，你会看到弹窗。
- en: Creating an error substate
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建错误子状态
- en: Error substates occur whenever an error is encountered. It's very similar to
    the loading substate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 错误子状态会在遇到错误时发生。它与加载子状态非常相似。
- en: 'In a new application, create a `teachers` route:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的应用程序中，创建一个`teachers`路由：
- en: '[PRE47]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will create all the necessary files for the `teachers` route.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为`teachers`路由创建所有必要的文件。
- en: 'Edit the `teachers.js` file in the `app/routes` folder. Add a new `Ember.RSVP.Promise`
    with a reject:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/routes`文件夹中的`teachers.js`文件。添加一个新的`Ember.RSVP.Promise`并拒绝：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, we return a new `Ember.RSVP.Promise` that will reject. This
    will cause an error to occur.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们返回一个新的`Ember.RSVP.Promise`，它将拒绝。这将导致错误发生。
- en: 'Create a new `teachers-error.hbs` file in the `app/templates` folder. This
    will be displayed when an error occurs in the `teachers` route:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/templates`文件夹中创建一个新的`teachers-error.hbs`文件。当`teachers`路由发生错误时，将显示此文件：
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Error substates, like loading substates, must be named after the route with
    a dash loading at the end. The template will be displayed during an error and
    doesn't need any other logic to occur.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误子状态，就像加载子状态一样，必须以带有结尾破折号的路由名命名。模板将在错误发生时显示，不需要执行任何其他逻辑。
- en: 'Alternatively, you can also use the error event in the route to display an
    error and redirect to a different route:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您也可以在路由中使用错误事件来显示错误并重定向到不同的路由：
- en: '[PRE50]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using the error event is just another way to handle errors. We could certainly
    have created an error route to transition to.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用错误事件只是处理错误的一种方式。我们当然可以创建一个错误路由来过渡到。
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Ember route has built-in methods and events to handle errors and loading.
    When loading information, the model hook is waiting for the query to get completed.
    During this time, a template with the name dash loading at the end will be transitioned
    to immediately and synchronously. The URL will not be effected. After the query
    completes, the loading route will be exited and the original route will continue.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Ember路由具有内置的方法和事件来处理错误和加载。在加载数据时，模型钩子正在等待查询完成。在此期间，将立即和同步地过渡到一个以破折号加载结尾的模板。URL不会受到影响。查询完成后，加载路由将退出，并继续原始路由。
- en: When dealing with errors, the error template will be loaded. Once again, the
    URL will not change to the error route. The error will be passed to the error
    state as it's model.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理错误时，将加载错误模板。再次强调，URL不会切换到错误路由。错误将作为模型传递给错误状态。
- en: Using query parameters
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: Query parameters allow you to use the URL for the application state. In these
    recipes, we'll use query parameters in several different ways to show how it works.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数允许您使用URL来表示应用程序状态。在这些菜谱中，我们将以几种不同的方式使用查询参数来展示其工作原理。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Query parameters are optional key-value pairs. They will appear to the right
    of ? in a URL.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是可选的关键字值对。它们将出现在URL中?的右侧。
- en: 'In a new project, generate a new `application` controller:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的项目中，生成一个新的`application`控制器：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `application` controller will be generated in the `app/controllers` folder.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application`控制器将在`app/controllers`文件夹中生成。'
- en: 'Update the application controller with a new `queryParams` for `student`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序控制器，为`student`添加一个新的`queryParams`：
- en: '[PRE52]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will set up the binding between the `student` query parameter in the URL
    and the `student` property in the controller. If either one changes, the other
    will change as well.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在URL中的`student`查询参数和控制器中的`student`属性之间建立绑定。如果任一发生变化，另一个也会发生变化。
- en: If the `student` property was set to anything other than null, then the `student`
    property will have a default value. This is important to remember because query
    parameter values are cast to the same datatype as the default value. In other
    words, if the student property was defaulted to the number *1* and you changed
    the URL to `/?student=2`, the property would be set to the number `2`, not the
    string `"2"`. Additionally, remember that default values will not be serialized
    in the URL.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`student`属性被设置为任何非null的值，则`student`属性将有一个默认值。这一点很重要，因为查询参数值会被转换为与默认值相同的数据类型。换句话说，如果学生属性默认为数字*1*，而你将URL更改为`/?student=2`，属性将被设置为数字`2`，而不是字符串`"2"`。此外，请记住，默认值不会在URL中序列化。
- en: 'Update the `application.hbs` file in the `app/templates` folder. We''ll add
    the `student` property to test:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app/templates`文件夹中的`application.hbs`文件。我们将添加`student`属性以进行测试：
- en: '[PRE53]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is a very simple template that just displays the `student` information
    from the controller.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个非常简单的模板，它只是显示控制器中的`student`信息。
- en: Start Ember server and try changing the URL. Navigate to `http://localhost:4200?students=Erik`.
    The template will be updated in order to display the new student information:![How
    to do it...](img/00014.jpeg)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器并尝试更改URL。导航到`http://localhost:4200?students=Erik`。模板将更新以显示新的学生信息：![如何操作...](img/00014.jpeg)
- en: Everything to the right of the question mark ? in the URL can be used in the
    query parameter. Each parameter is separated by an ampersand. In this case, the
    student property is set to Erik. This will be updated in the template.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: URL中问号`?`之后的任何内容都可以用于查询参数。每个参数由一个与号`&`分隔。在这种情况下，学生属性被设置为Erik。这将在模板中更新。
- en: Adding a link-to helper with a query parameter
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加带有查询参数的`link-to`辅助器
- en: It's important to realize that we can pass query parameters using the `link-to`
    helper.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到我们可以使用`link-to`辅助器传递查询参数。
- en: 'In a new project, create a new `application.js` controller:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，创建一个新的`application.js`控制器：
- en: '[PRE54]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will generate the `application` controller that we can use for our query
    parameter.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成我们可以用于查询参数的`application`控制器。
- en: 'Edit the application controller and add a new query parameter:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`application`控制器并添加一个新的查询参数：
- en: '[PRE55]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, we created a simple query parameter called `student`.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个简单的名为`student`的查询参数。
- en: 'Update the `application.hbs` file in the `app/templates` folder. Add the `student`
    property and new `link-to` helper with a query parameter:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app/templates`文件夹中的`application.hbs`文件。添加`student`属性和带有查询参数的新`link-to`辅助器：
- en: '[PRE56]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can add a query parameter to `link-to` by surrounding it with parentheses
    and using the `query-params` sub-expression helper. After the sub-expression comes
    the key-value pair. In this case, we have a `student` key.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过将查询参数用括号括起来并使用`query-params`子表达式辅助器来将其添加到`link-to`中。子表达式之后是键值对。在这种情况下，我们有一个`student`键。
- en: Start Ember server and click on the **Jane Query** link. The following page
    should appear:![Adding a link-to helper with a query parameter](img/00015.jpeg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器并点击**Jane Query**链接。应该出现以下页面：![添加带有查询参数的`link-to`辅助器](img/00015.jpeg)
- en: Tip
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Using TransitionTo with query parameters**'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**使用带有查询参数的`transitionTo`**'
- en: 'Query parameters can be used when transitioning routes with the `transitionTo`
    method. You can add the query parameter as the final argument with the object
    key, `queryParmams`. For example, if you need to transition to the application
    route and you need to pass the query parameter for student, it might look like
    this:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用`transitionTo`方法转换路由时，可以使用查询参数。您可以将查询参数作为对象键`queryParmams`的最后一个参数添加。例如，如果您需要转换到应用程序路由并需要传递学生查询参数，它可能看起来像这样：
- en: '`this.transitionTo(''application'', { queryParams: { student: ''Erik'' }});`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`this.transitionTo(''application'', { queryParams: { student: ''Erik'' }});`'
- en: Resetting a controller's query parameters
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置控制器的查询参数
- en: By default, query parameters are sticky. In other words, they are preserved
    when you move in and out of the route. They will also preserve the model loaded
    in the route.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，查询参数是粘性的。换句话说，当你进入和离开路由时，它们会被保留。它们也会保留路由中加载的模型。
- en: You can override this behavior in a couple of ways. One is to pass the default
    query parameter to the `link-to` helper or use `transitionTo`. The other way is
    to use the `Route.resetController` hook.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过几种方式来覆盖这种行为。一种方式是将默认查询参数传递给`link-to`辅助函数或使用`transitionTo`。另一种方式是使用`Route.resetController`钩子。
- en: 'Create a new project and generate a new route called `route1`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并生成一个名为`route1`的新路由：
- en: '[PRE57]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will create a new route and controller for `route1`.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的路由和控制器`route1`。
- en: 'Edit the `route1.js` file in the `app/controllers` folder:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/controllers`文件夹中的`route1.js`文件：
- en: '[PRE58]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Just like our previous example, we are using a simple query parameter called
    `student`.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像我们之前的例子一样，我们使用了一个简单的查询参数`student`。
- en: 'Edit the `route1.js` file in the `app/routes` folder. Add a new `resetController`
    hook to the route:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/routes`文件夹中的`route1.js`文件。向路由添加一个新的`resetController`钩子：
- en: '[PRE59]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this route, we are using the `resetController` hook. This will fire whenever
    someone exits or transitions from the route. As before, we must call super so
    that we don't prevent the default behavior. The `isExiting` argument will be false
    only if the route's model is changing, otherwise it will fire.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个路由中，我们使用`resetController`钩子。这将在有人退出或从路由转换时触发。和之前一样，我们必须调用super，这样我们就不阻止默认行为。`isExiting`参数只有在路由的模型发生变化时才会为false，否则它将触发。
- en: The `controller.set` method is a way in which we can access the student property.
    We'll set it to null so that when we move away from route1, it will not be preserved.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`controller.set`方法是我们访问学生属性的一种方式。我们将它设置为null，这样当我们离开`route1`时，它就不会被保留。'
- en: 'Edit the `application.hbs` file in the `app/templates` folder. Add a `link-to`
    helper to the new `route1` route:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/templates`文件夹中的`application.hbs`文件。将`link-to`辅助函数添加到新的`route1`路由中：
- en: '[PRE60]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This template is very simple. All we are doing is creating a link to the new
    `route1`.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板非常简单。我们只是创建了一个指向新的`route1`的链接。
- en: 'Edit the `route1.hbs` file in the `app/templates` folder. Add the `student`
    property and a link back to the main `application` route:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/templates`文件夹中的`route1.hbs`文件。添加`student`属性和一个返回主`application`路由的链接：
- en: '[PRE61]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This template displays the `student` property that we can set via query parameters.
    It then has a link back to the main `application` route.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板显示了我们可以通过查询参数设置的`student`属性。然后它有一个返回主`application`路由的链接。
- en: Run `ember server` and load the application. Enter the URL, `http://localhost:4200/route1?student=Erik`.
    This will display `route1` with the query parameter for student. If you click
    on the app link, it will bring you back to the main application. If you click
    on the **Route 1** link again, it will not preserve the query parameter and will
    be reset. It will look like the following image:![Resetting a controller's query
    parameters](img/00016.jpeg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ember server`并加载应用程序。输入URL，`http://localhost:4200/route1?student=Erik`。这将显示带有学生查询参数的`route1`。如果您点击应用程序链接，它将带您回到主应用程序。如果您再次点击**Route
    1**链接，它将不会保留查询参数并重置。它看起来像以下图片：![重置控制器查询参数](img/00016.jpeg)
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Query parameters are key-value pairs that appear to the right of ? in the URL
    of the application. They help define an additional application state by serializing
    data in the URL. They are set in the route-driven controllers. We can use `transitionTo`
    and `link-to` helpers to navigate to them easily.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是出现在应用程序URL中?右侧的键值对。它们通过在URL中序列化数据来定义额外的应用程序状态。它们在路由驱动控制器中设置。我们可以使用`transitionTo`和`link-to`辅助函数轻松地导航到它们。
