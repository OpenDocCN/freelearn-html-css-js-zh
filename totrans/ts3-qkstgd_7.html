<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Mastering the Art of Defining Types</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will see how to create types from libraries that we are not working directly with but importing inside our TypeScript project. The main difference is that when consuming code outside our project, we will not use TypeScript code directly, but its definition. The reason is that JavaScript is provided in those libraries, not TypeScript code. We will see how it is possible to master the art of creating definition files for code that does not provide them, allowing us to keep working in a strong environment.</p>
<p>This chapter covers the following:</p>
<ul>
<li class="h1">How to use a third-party library definition file</li>
<li class="h1">How TypeScript can generate a definition file</li>
<li class="h1">How to manually add a definition file for a JavaScript project</li>
<li class="h1">How to merge types into an existing definition file</li>
<li class="h1">How to create a definition file for a JavaScript project</li>
<li class="h1">No need for a strong type but want to use a JavaScript library</li>
<li class="h1">The need to use another module</li>
<li class="h1">How to add a definition file to an extension of an existing module</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use a third-party library definition file</h1>
                </header>
            
            <article>
                
<p>TypeScript works well when it knows the type of every variable and function. However, when using third-party libraries written in JavaScript, you do not have a definition file. TypeScript is smart and tries to infer type as much as it can by leveraging the standard documentation JSDoc, but nothing beats a signature written with TypeScript rules. However, there are many useful libraries written in JavaScript that do not have TypeScript’s types. A definition file fills the gap between JavaScript and TypeScript. For a third-party library, the idea is to use a definition file. The definition file source can come from a manual edition if the original library is written in JavaScript or generated automatically by TypeScript if coded in TypeScript.</p>
<p>To use a third-party library definition file, you need to have the file in our project. The TypeScript definition file is a .d.ts extension. TypeScript will search for a definition file in the <kbd>node_modules</kbd> folder as well as in our project. Because TypeScript uses the <kbd>node_modules</kbd>, it means it can fetch definition files from NPM. TypeScript has one of the most active GitHub repositories, which has over 4,200 definition files supported by the community. They are all accessible using NPM under <kbd>@types</kbd>. Here is an example of how to get JQuery definition files:</p>
<pre><strong>npm install @types/jquery --save-dev</strong></pre>
<p>The rising popularity of TypeScript made many libraries incorporate the definition file directly into their main npm package. For example, Redux, has <kbd>index.d.ts</kbd> at the root of the main <kbd>npm</kbd> package. It means that you may already have the definition files without noticing. The reason library brings the definition files directly in the NPM package is that the versions of the types are always synchronized with the code. It has also benefited people who use JavaScript and using a code editor that can read the definition file. Some code editors can leverage the definition file to provide autocomplete features.</p>
<p>Other than the <kbd>node_modules</kbd>, TypeScript reads the configuration <kbd>types</kbd> and <kbd>typeroots</kbd> in the <kbd>tsconfig.json</kbd> file. For further details, refer to <a href="e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with TypeScript</em>.</p>
<p>If a definition file is missing for a third party, you can create one; create a type that sets to <kbd>any</kbd> the main export that would remove the type safety but be able to access anything. There is also the option to enhance an existing third-party library by merging new definitions into the existing one. We will cover this area in this chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How typescript can generate a definition file</h1>
                </header>
            
            <article>
                
<p>Even if the code is built in TypeScript, when it is time to share with the world, only the JavaScript files are published. The reason is to have everyone, including JavaScript and TypeScript developers, to use your code. It is better to publish TypeScript's types in a format where the sole purpose is to provide type capability instead of using a full TypeScript code. On the other hand, TypeScript can generate JavaScript files that allow a browser to interpret the code flawlessly. Having TypeScript generating two kinds of files, the definition file and the JavaScript file, open the compatibility for the developers and browsers. While the definition file can be crafted by hand, which is handy for a library written in JavaScript that wants to offer TypeScript support, it is faster and generates less errors to have it generated automatically. That being said, TypeScript is the best to produce automatically the definition, since it is present in the .ts file. This is why TypeScript has a compilation option to produce the definition at compilation time called <kbd>declaration</kbd>, which the path can be controlled by the other option <kbd>declarationDir</kbd>. Both options have been discussed in <a href="e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with TypeScript</em>. Here is the line that allows the generation of the <kbd>definition</kbd> file from a TypeScript compilation:</p>
<div>
<pre><span>"declaration"</span><span>: </span><span>true</span></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to manually add a definition file for a JavaScript project</h1>
                </header>
            
            <article>
                
<p>Many projects are written in JavaScript but still want to have TypeScript uses to the benefice of type. Or, some JavaScript projects produce TypeScript's definition files to have good support in their code editor. Finally, some people outside the main repository of the JavaScript library develop manual definition files for every TypeScript user to consume the library.</p>
<p>To create a definition file from a project that you do not own, you need to create a folder with the name of the module you want to add types to, and add an index.d.ts file. However, if you own the library, you can set the <kbd>types</kbd> or <kbd>typing</kbd> (they are synonyms) to the path and filename of the <kbd>definition</kbd> file. In the following code example, the definition file is set to <kbd>main.d.ts</kbd> under the <kbd>lib</kbd> folder. If the <kbd>types</kbd> or <kbd>typing</kbd> are not provided, the definition file must be called <kbd>index.d.ts</kbd> at the root of the package folder.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Using <kbd>index.d.ts</kbd> is the best practice because TypeScript is optimized to search for <kbd>index.d.ts</kbd> when doing module resolution, as well as having the file with the name of the module (followed by <kbd>.d.ts</kbd>):</p>
<pre>{<br/>"name": "your-library",<br/>"main": "./lib/main.js",<br/>"types": "./lib/main.d.ts"<br/>}</pre>
<p>As with <kbd>library</kbd>, all dependencies must be specified. This time, all the definition file libraries must be mentioned in the <kbd>package.json</kbd>. It is important to notice that we are not referring to the definition files in the <kbd>dev</kbd> dependencies, because we want to have all the types downloaded and installed by the consumer of our <kbd>definition</kbd> file library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to merge types into an existing definition file</h1>
                </header>
            
            <article>
                
<p>Types can be written in several places and merged into a single set of definitions that TypeScript can rely on. The principle is that you may be able to extend existing definitions with your own. The merging capability is helpful when you have JavaScript code that can be enhanced with plugins or with extensions. For example, the library Redux has its definition files in its repository and NPM package. The library named <kbd>Redux-thunk</kbd> also has its definition file, which adds to Redux a new <kbd>dispatch</kbd> function signature that overrides the one defined by <kbd>redux</kbd>. The definition file relies on merging type to add its own definition of the dispatch into the <kbd>redux</kbd> module:</p>
<pre>declare module "redux" {<br/>   export interface Dispatch&lt;S&gt; {<br/>   &lt;R, E&gt;(asyncAction: ThunkAction&lt;R, S, E&gt;): R;<br/> }<br/>}</pre>
<p>Merging type requires to have some knowledge of how TypeScript allows. The first rule is that all namespace can be defined more than once in one or many files. It means that you can define code inside many namespace scopes and that TypeScript will see it was all in the same namespace.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The content of a namespace is shared only if tagged as an exported element:</p>
<pre>namespace Merge {<br/> export interface I1 { m1: string; }<br/>}<br/><br/>namespace Merge {<br/> export interface I2 { m2: string; }<br/>}</pre>
<p>This can be written in a single namespace:</p>
<pre>namespace Merge {<br/>   export interface I1 { m1: string; }<br/>   export interface I2 { m2: string; }<br/>}</pre>
<p>Similarly, interfaces can be merged:</p>
<pre>interface Mergeable {<br/> m1: string;<br/>}<br/><br/>interface Mergeable {<br/> m2: string;<br/>}</pre>
<pre>const mergeInterface: Mergeable = { m1: "", m2: "" }</pre>
<p>However, <kbd>type</kbd> does not act as an interface and does not allow to merge.</p>
<p>A class can have its definition enhanced by having an interface of the same name. So, it means that you can have the interface defined with the same name as the concrete class (in JavaScript) and be able to define a strongly typed definition. It also means that you can provide extension members of the class in the definition, if needed:</p>
<pre>export interface Album { m1: string; m2: number; }<br/>export class Album {<br/>public m2: number = 12;<br/>}<br/>const a = new Album();<br/><span><span>a</span></span>.m1; // Not implemented but compile.<br/>a.m2;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A namespace can be used to define a function variable. In JavaScript, it is possible to assign a variable to a function by using the function name and the dot notation. To define the type of this function, it requires specifying not only the parameter name and return type but also the variable. This is possible by defining a namespace with the function name:</p>
<pre>function functionInJavaScript(param: string): string {<br/>  return functionInJavaScript.variableOfFunction + param;<br/>}<br/>namespace functionInJavaScript {<br/>  export let variableOfFunction = "";<br/>}</pre>
<p>It is possible to declare at the <kbd>global</kbd> scope an <kbd>interface</kbd> function:</p>
<pre>declare global {<br/>   interface Array&lt;T&gt; {<br/>       toObservable(): Observable&lt;T&gt;;<br/>   }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a definition file for a JavaScript project</h1>
                </header>
            
            <article>
                
<p>Today’s world of open source reduces the barrier of examples. TypeScript has one of the most active repositories, which is the one that all the types of third-party libraries that do not have the definition file in their main repository. A quick look at a few libraries shows a fragmentation on how to write definition files. This is due to the high amount of different library structure. JavaScript has a global, modular, UMD, plugins, and global-modifying.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definition file for global structure library</h1>
                </header>
            
            <article>
                
<p>The epitome of a global library is JQuery with its popular dollar sign. Global library adds their functions and variables to the window scope. This can be done explicitly by using <kbd>window</kbd> or implicitly by defining a var. It does not use any import, export, or require functions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To create a definition file for a global structure library, you can use many TypeScript keywords to define a type. In the case of a function, you can use <kbd>function</kbd> preceded by <kbd>declare</kbd> and write the signature of the function as you would do in an interface, without a body:</p>
<pre>declare function myGlobalFunction(p1: string): string;</pre>
<p>The keyword <kbd>declare</kbd> is there to say that the function is present somewhere else:</p>
<pre>Let var1:string = myGlobalFunction(“test”);</pre>
<p>If you have a type instead of a function declared at the global scope, you can use an interface. The keyword <kbd>declare</kbd> is omitted:</p>
<pre>interface myGlobalType{<br/>   name: string;<br/>}</pre>
<p>The global interface allows declaring a variable of a global type without prefixing the type by anything:</p>
<pre>Let var1: myGlobalType={name:”test”};</pre>
<p>A global interface allows specifying a type in a group of a cohesive element. It often represents a function scope:</p>
<pre>declare namespace myScope{<br/>  let var1: number;<br/>  class MyClass{<br/>  }<br/>}<br/><br/>let x: number = myScope.var1;<br/>let y: myScope.MyClass = new myScope.MyClass();</pre>
<p>The namespace can include an interface to define an object, a type to define a variable of a specific type and to use a <kbd>function</kbd> for functions:</p>
<pre>declare namespace myScope{<br/> interface MyObject{<br/>    x: number;<br/> }<br/><br/> type data = string;<br/> function myFunction():void{};<br/>}</pre>
<p>The usage of the object, variable, and function always uses the namespace name because it is exposed globally by the variable name:</p>
<pre>let s: myScope.MyObject = { x: 5 };<br/>let x: myScope.data = “test”;<br/>myScope.myFunction();</pre>
<p>In this section, we saw how to define a global library that can have a global function or variable but also a global variable that can hold an object, a primitive of a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definition file for module library</h1>
                </header>
            
            <article>
                
<p>The <kbd>definition</kbd> file for a library is similar but also different. If you need to provide a definition file, it is recommended to name an <kbd>index.d.ts</kbd> with the following rules. First, there is an optional export declaration that is needed if the library supports UMD. This happens when the library exports a variable. The variable exposed in the following code example is <kbd>myScope</kbd>, where the whole module resides:</p>
<pre>export as namespace myScope;</pre>
<p>The next steps are to add every function directly to the definition file. There is no need to englobe the functions into a namespace. This is the same for an object:</p>
<pre>export function myFunction(): void;<br/>export interface MyObject{<br/> x: number;<br/>}<br/>export let data: string;</pre>
<p>The usage of the function, interface, and variable would be like this in the actual code:</p>
<pre>import {myFunction, MyObject, data} from “myScope”;<br/>myFunction();<br/>x:MyObject = {x:1};<br/>console.log(data);</pre>
<p>The remaining feature would be to have an object inside your module:</p>
<pre>export namespace myProperty{<br/>   export function myFunction2(): void;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here is the actual usage of the namespace, which, like the functions, object, and data, is available in two formats. The first is with the explicit callout of the element to be retrieved from the module or the second with the star, which gets the whole content definition into the alias:</p>
<pre>Import {myProperty} from “myScope”;<br/>myProperty.myFunction2();<br/>//or<br/>Import * from my from “myScope”<br/>my.myProperty.myFunction2();</pre>
<p>However, in some cases, this won't work. It depends how the JavaScript module is written. The following code works for modern module creation. It uses the declare statement with a module. The module name must be the library name between quotes. Inside the module, you can define your export for <kbd>CommonJs/Amd</kbd> with <kbd>export =</kbd>, followed by what you want to export by default. In the following code, the class <kbd>MessageFormat</kbd> is the default export. It is possible to not have a <kbd>CommonJs/Amd</kbd> export and to export every type. You can export a namespace that contains many types as well:</p>
<pre>declare module "modulenamehere" {<br/>  type Msg = (params: {}) =&gt; string;<br/>  type SrcMessage = string | SrcObject;<br/>  interface SrcObject {<br/>  m1: SrcMessage;<br/>}<br/><br/>class MessageFormat {<br/>  constructor(message: string);<br/>  constructor();<br/>  compile: (messages: SrcMessage, locale?: string) =&gt; Msg;<br/>}<br/><br/>export = MessageFormat ; // CommonJs/AMD export syntax<br/>}<br/><br/>// Usage:<br/><br/>import MessageFormat from "modulenamehere";<br/>const mf = new MessageFormat("en");<br/>const thing = mf.compile("blarb");</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript library without a definition file</h1>
                </header>
            
            <article>
                
<p>If you need to use a third-party library that does not have any definition file, you can start by a single-line declaration. You need to create a file with the name of the module with the extension <kbd>.d.ts</kbd> and add this single line:</p>
<pre>declare module "*";</pre>
<p>This won't give you any Intellisence, auto-completion, but the file will be importable inside your TypeScript file without any issue with the compiler. You can start with this one-line approach and then slowly move to a more elaborate definition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using another module from a definition file</h1>
                </header>
            
            <article>
                
<p>You may need to consume another module from your definition file. The reason might be to get types from another library. To be able to use the type of another library, you can use <kbd>import *</kbd> and assign an alias with <kbd>as</kbd> from the type you want to refer in your <kbd>definition</kbd> file:</p>
<pre>declare module "react-summernote" {<br/>  import * as React from "react";<br/>  let ReactSummernote: React.ComponentClass&lt;any&gt;;<br/>  export default ReactSummernote;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a definition file to an extension of an existing module</h1>
                </header>
            
            <article>
                
<p>The idea is to use the <kbd>declare</kbd> and the name of the module to extend. A system can have more than one declaration of the same module, allowing the possibility to add an exported <kbd>type</kbd>, <kbd>function</kbd>, <kbd>interface</kbd>, or <kbd>class</kbd>. The following code shows also the usage of another module that is used by the extension of the module:</p>
<pre><span>import * as </span>extendMe<span> from "moduleToExtend";</span><br/><span>import * as other from "</span>anotherModule<span>";</span><br/><br/><span>declare module "moduleToExtend" {</span><br/><span>export function theNewMethod(x: extendMe.aTypeInsideModuleToExtend): other.anotherTypeFromAnotherModule;</span><br/><span>export interface ExistingInterfaceFromModuleToExtend {</span><br/><span>newMember: string;</span><br/><span>}</span><br/><br/><span>export interface NewTypeForModuleToExtend {</span><br/><span>size: number;</span><br/><span>}</span><br/><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we illustrated how to work with definition files. We explained many facets of how to work with definition files as well as many details to facilitate the creation of definition, depending on how the JavaScript code was written.</p>
<p>In this book, we summarized everything that is essential to get started with TypeScript. This quick starting guide goal was to set the table for a wonderful meal that you can prepare with TypeScript. The book talked about how to code from a basic concept with primitive type to a more advanced one with generic. Hopefully, you will be as delighted as I am working with a typed language that is close to JavaScript but more powerful in terms of maintainability, as well as being easier to read. Thanks to type and TypeScript, web development is safer, more productive, and enjoyable.</p>


            </article>

            
        </section>
    </body></html>