- en: Chapter 5. ES6 Iterators and Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed language constructs of JavaScript without looking
    at any specific language version. In this chapter, however, we will primarily
    focus on a few language features introduced in ES6\. These features have a big
    impact on how you write JavaScript code. Not only do they improve the language
    significantly, they also offer several functional programming constructs unavailable
    to JavaScript programmers thus far.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at newly introduced iterators and generators
    in ES6\. With that knowledge, we will proceed to take a detailed look at the enhanced
    Collections constructs.
  prefs: []
  type: TYPE_NORMAL
- en: For...of loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`For...of` loops are introduced in ES6 along with the iterable and iterator
    constructs. This new loop constructs replaces both the `for...in` and `for...each`
    loop constructs of ES5\. As the `for...of` loop supports the iteration protocol,
    it can be used on built-in objects such as arrays, strings, maps, sets, and so
    on, and custom objects that are iterables. Consider the following piece of code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `for...of` loop works with iterables and built-ins like arrays are iterables.
    If you notice, we are using `const` instead of `var` when we define the loop variable.
    This is a good practice because when you use `const`, a fresh variable is created
    with a new binding and storage space. You should use `const` over a `var` declaration
    with the `for...of` loop when you don't intend to modify the value of the loop
    variable inside the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other collections support `for...of` loop too. For example, as a string is
    a sequence of Unicode characters, `for...of` loop works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between the `for...in` and `for...of` loop is that the `for...in`
    loop iterates through all enumerable properties of an object. `For...of` loop
    has a specific purpose, and that is to follow the iteration behavior based on
    how the object defines the iterable protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators and iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces a new mechanism of iterating over data. Traversing a list of
    data and doing something with it is a very common operation. ES6 enhances the
    iteration constructs. There are two primary concepts involved with this change-iterators
    and iterables.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript iterator is an object that exposes the `next()` method. This method
    returns the next item from the collection in the form of an object that has two
    properties-`done` and `value`. In the following example, we will return an iterator
    from an array by exposing the `next()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are returning `value` and `done` till we have elements
    in the array. When we exhaust elements in the array to return, we will return
    `done` as `true`, indicating that the iteration has no more values. Elements from
    an iterator are accessed using the `next()` method repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterable is an object that defines its iteration behavior or internal iteration.
    Such objects can be used in the `for...of` loops introduced in ES6\. Built-in
    types such as arrays and strings define default iteration behavior. For an object
    to be iterable, it must implement the `@@iterator` method, meaning the object
    must have a property with `'Symbol.iterator'` as key.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object becomes iterable if it implements a method whose key is `''Symbol.iterator''`.
    This method must return an iterator via the `next()` method. Let''s take a look
    at the following example to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this example down into smaller pieces. We are creating an iterable
    object. We will create an `iter` object using object literal syntax that we are
    already familiar with. One special aspect of this object is a `[Symbol.iterator]`
    method. This method definition uses a combination of computed properties and ES6
    shorthand method definition syntax, which we already discussed in the last chapter.
    As this object contains a `[Symbol.iterator]` method, this object is iterable,
    or it follows an iterable protocol. This method also returns the iterator object
    that defines the iteration behavior via exposing the `next()` method. Now this
    object can be used with the `for...of` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closely linked with iterators and iterables, generators are one of the most
    talked about features of ES6\. Generator functions return a generator object;
    this term sounds confusing at first. When you write a function, you also instinctively
    understand its behavior-the function starts execution, line-by-line, and finishes
    execution when the last line is executed. Once the function is linearly executed
    this way, the rest of the code that follows the function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In languages where multithreading is supported, such flow of execution can be
    interrupted and partially finished tasks can be shared between different threads,
    processes, and channels. JavaScript is single-threaded, and you don't need to
    deal with challenges around multithreading at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: However, generator functions can be paused and resumed later. The important
    idea here is that the generator function chooses to pause itself, it cannot be
    paused by any external code. During execution, the function uses the `yield` keyword
    to pause. Once a generator function is paused, it can only be resumed by code
    outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: You can pause and resume a generator function as many times you want to. With
    generator functions, a popular pattern is to write infinite loops and pause and
    resume them when needed. There are pros and cons of doing this, but the pattern
    has caught up already.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to understand is that generator functions also allow
    two-way message passing, in and out of it. Whenever you pause the function using
    `yield` keyword, the message is sent out of the generator function, and when the
    function is resumed, the message is passed back to the generator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to clarify how the generator functions
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple generator function. However, there are several interesting
    aspects that need careful understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, notice an asterix `*` immediately after the keyword function, this is
    the syntax to indicate that the function is a generator function. It is also okay
    to keep the asterix immediately preceding the function name. Both of the following
    are valid declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, the real magic is around the `yield` keyword. When the
    `yield` keyword is encountered, the function pauses itself. Before we move further,
    let''s see how the function is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we invoke the generator function, it is not executed like a normal function,
    but it returns a generator object. You can use this generator object to control
    the execution of the generator function. The `next()` method on the generator
    object resumes the execution of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `next()` the first time, the execution proceeds up until the first
    line of the function (marked by ''A''), and pauses when the `yield` keyword is
    encountered. If we call the `next()` function again, it will resume the execution
    to the next line from the point the execution was paused last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the entire function body is executed, any calls to `next()` on the generator
    object have no effect. We talked about generator functions allowing a two-way
    message passing. How does that work? In the previous example, you can see that
    whenever we resume the generator function, we receive an object with two values,
    `done` and `value`; in our case, we received `undefined` as the value. This is
    because we did not return any value with the `yield` keyword. When you return
    a value with the `yield` keyword, the calling function receives it. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s trace the flow of execution of this example step by step. The generator
    function has three pauses or yields. We can create the generator object by writing
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start the execution of the generator function by calling the `next`
    method; this method starts the execution till the first yield. If you notice,
    we are not passing any value to the `next()` method in the first call. The purpose
    of this `next()` method is just to start the generator function. We will call
    the `next()` method again, but this time with a `"Save"` value passed as a parameter.
    This value is received by `yield` when the function execution is resumed, and
    we can see the value printed on console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the `next()` method again with two different values, and the output
    is similar to the one in the preceding code. When we call the `next()` method
    the last time, the execution ends and the generator function returns an `end`
    value to the calling piece of code. At the end of the execution, you will see
    `done` set as `true` and `value` assigned the value returned by the function,
    that is, `end`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the purpose of the first `next()` method is to
    start the execution of the generator function-it takes us to the first `yield`
    keyword and hence, any value passed to the first `next()` method is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the discussion so far, it is apparent that generator objects conform to
    the iterator contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example confirms that generator functions also conform to the iterables
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators are iterators, and like all ES6 constructs that support iterables,
    they can be used to iterate over generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is to use the `for...of` loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are not creating a generator object here. The `For...of` loop has support
    for iterables and generators naturally fall into this loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator can be used to turn iterables into arrays. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the destructuring syntax with generators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Generators play an important role in asynchronous programming. Shortly, we will
    look at asynchronous programming and promises in ES6\. JavaScript and Node.js
    offer a great environment to write asynchronous programs. Generators can help
    you write cooperative multitasking functions.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces four data structures-`Map`, `WeakMap`, `Set`, and `WeakSet`.
    JavaScript, when compared to other languages such as Python and Ruby, had a very
    weak standard library to support hash or Map data structures or dictionaries.
    Several hacks were invented to somehow achieve the behavior of a `Map` by mapping
    a string key with an object. There were side effects of such hacks. Language support
    for such data structures was sorely needed.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 supports standard dictionary data structures; we will look at more details
    around these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Map` allows arbitrary values as `keys`. The `keys` are mapped to values. Maps
    allow fast access to values. Let''s look at some examples of maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will create an empty `Map` using the constructor. You can use the `set()`
    method to add an entry to the `Map` associating key with value, and overwriting
    any existing entry with the same key. Its counterpart method, `get()`, gets the
    value associated with a key, or `undefined` if there is no such entry in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other helper methods available with maps, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a `Map` using the following iterable *[key, value]* pairs as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can chain the `set()` method for a compact syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use any value as a key. For objects, the key can only be strings, but
    with collections, this limitation is removed. We can use an object as a key as
    well, though such use is not very popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important thing to remember is that order is important with maps. Maps retain
    the order in which elements were added.
  prefs: []
  type: TYPE_NORMAL
- en: There are three iterables you can use to iterate over a `Map`, that is, `keys`,
    `values`, and `entries`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keys()` method returns iterable over the keys of a `Map` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `values()` method returns iterable over the values of a `Map`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entries()` method returns entries of the `Map` in form of a *[key,value]*
    pair, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use destructuring to make this concise as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'An even more succinct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Converting maps to arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The spread operator (`...`) comes in handy if you want to convert a `Map` to
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As maps are iterable, you can convert the entire `Map` into an array using
    spread operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Set` is a collection of values. You can add and remove values from it. Although
    this sounds similar to arrays, sets don''t allow the same value twice. Value in
    a `Set` can be of any type. So far, you must be wondering how different is this
    from an Array? A `Set` is designed to do one thing quickly-membership testing.
    Arrays are relatively slower at this. `Set` operations are similar to `Map` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to maps, you can create a `Set` via an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you add a value to the `Set`, and the value already existed, nothing happens.
    Similarly, if you delete a value from the `Set`, and the value didn't exist in
    the first place, nothing happens. There is no way to catch this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap and WeakSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WeakMap` and `WeakSet` have the similar, but restricted, APIs as the `Map`
    and `Set` respectively, and they work mostly like their strong counterparts. There
    are a few differences though, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakMap` only supports the `new`, `has()`, `get()`, `set()`, and `delete()`
    methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakSet` only supports `new`, `has()`, `add()`, and `delete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys of a `WeakMap` must be objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of a `WeakSet` must be objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't iterate over `WeakMap`; the only way you can access a value is via
    its key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't iterate over a `WeakSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't clear a `WeakMap` or a `WeakSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand `WeakMap` first. The difference between a `Map` and a `WeakMap`
    is that a `WeakMap` allows itself to be garbage collected. The keys in a `WeakMap`
    are weakly held. `WeakMap` keys are not counted when the garbage collector does
    a reference count (a technique to see all alive references), and they are garbage
    collected when possible.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMaps are useful when you don't have any control over the life cycle of the
    object you are keeping in the Map. You don't need to worry about memory leak when
    using WeakMaps because the objects will not keep the memory occupied even if their
    life cycle is long.
  prefs: []
  type: TYPE_NORMAL
- en: Same implementation details apply to `WeakSet` as well. However, as you cannot
    iterate over a `WeakSet,` there are not many use cases for a `WeakSet.`
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a detailed look at ES6 Generators. Generators are one
    of the most anticipated features of ES6\. The ability to pause and resume execution
    of a function opens up a lot of possibilities around co-operative programming.
    The primary strength of generators is that they provide a single-threaded, synchronous-looking
    code style, while hiding the asynchronous nature away. This makes it easier for
    us to express in a very natural way what the flow of our program's steps/statements
    is without simultaneously having to navigate asynchronous syntax and gotchas.
    We achieve separation of concern using generators due to this.
  prefs: []
  type: TYPE_NORMAL
- en: Generators work hand-in-hand with the iterators and iterables contract. These
    are welcome addition to ES6 and significantly boosts the data structures the language
    offers. Iterators provide a simple way to return a (potentially unbounded) sequence
    of values. The `@@iterator` symbol is used to define default iterators for objects,
    making them an iterable.
  prefs: []
  type: TYPE_NORMAL
- en: The most important use case for iterators becomes evident when we want to use
    it in a construct that consumes iterables, such as the `for...of` loop. In this
    chapter we also looked at a new loop construct `for...of` introduced in ES6\.
    `for...of` works with a lot of native objects because they have default `@@iterator`
    methods defined. We looked at new additions to the ES6 collections like-Maps,
    Sets, WeakMaps, and Weak Sets. These collections have additional iterator methods-`.entries()`,
    `.values()` and `.keys()`.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take a detailed look at JavaScript Prototypes.
  prefs: []
  type: TYPE_NORMAL
