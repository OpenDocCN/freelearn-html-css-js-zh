- en: Chapter 5. Building a Canvas Game's Masterclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we explored some basic Canvas context drawing APIs
    and created a game named Untangle. In this chapter, we are going to enhance the
    game by using some other context drawing APIs.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the Untangle game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill text in the Canvas with a custom web font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw images in the Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate a sprite sheet image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build multiple Canvas layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot is a preview of the final result that we are going
    to build through this chapter. It is a Canvas-based Untangle game with an animated
    game guideline and several subtle details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Canvas Game''s Masterclass](img/B04290_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also try the final game example at: [http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/).'
  prefs: []
  type: TYPE_NORMAL
- en: So let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Untangle puzzle game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created an interactive Canvas, we can drag the circles, and
    the lines connecting the circles which are intersecting with other lines. How
    about we make it a game? There are some predefined circles and lines and our aim
    is to drag the circles so that there are no lines intersecting with others. This
    is called an **Untangle puzzle game**.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the Untangle puzzle game in Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the game logic to our line intersection code:'
  prefs: []
  type: TYPE_NORMAL
- en: We need two more files for the game logic. Create two new files named `untangle.game.js`
    and `untangle.levels.js` file. Put them into the `js` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.html` file in a text editor. Add the following code to include
    our newly created file. Put the code in the file before including the `js/untangle.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the `index.html` file, we add the following code after the `canvas`
    element. It displays the game level information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.levels.js` file. Put the following level data definition
    code into the file. It is a predefined level data for the players to play. It
    is a collection of data that defines where the circles are placed and how they
    connect to each other initially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `untangle.game.js` file in text editor. We will put game logic into
    this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a new file, so we define the `untangleGame` object at the beginning
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue in the `untangle.game.js` file. Add the following variables to the
    file. They store the current level and level progress of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When starting on each level, we need to set up the initial level data. To help
    make the code more readable, we create a function. Append the following code to
    the `untangle.game.js` JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a game with several levels. We need to check whether the player solves
    the puzzle in the current level and jumps to the next puzzle. Add the following
    function to the end of the `untangle.game.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need another function to update the game progress. Add the following function
    to the end of `untangle.game.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.input.js` file. We add the following code to the mouse move
    event handler, which updates the level progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the following code to the mouse up event handler to check whether the
    player completes the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open the `untangle.js` file in an editor. Inside the jQuery document''s
    `ready` function, we had code to set up the circles and lines. They are now replaced
    by our level setup code. Delete the call to `untangleGame.createRandomCircles`
    and `untangleGame.connectCircles` functions. Replace them with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `untangle.drawing.js` file in the code editor. We replace
    the `connectCircles` function to connect circles based on the level data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all files and test the game in the browser. We can drag the circles and
    the line thickness will indicate whether it is intersected with other lines. During
    the mouse dragging, the level completeness percentage should change when more
    or less line intersections are detected. If we solve the puzzle, that is when
    no lines are intersected, the game will jump to the next level. When the game
    reaches the last level, it will keep showing the last level again. This is because
    we have not yet added the game over screen.![Time for action – making the Untangle
    puzzle game in Canvas](img/B04290_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have added the game logic to our Canvas so that we can play our circle dragging
    code that has been created throughout this chapter. This section changes quite
    a lot of code. You may find the working example with uncompressed source code
    at: [http://makzan.net/html5-games/untangle-wip-gameplay/](http://makzan.net/html5-games/untangle-wip-gameplay/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the variables we added to the `untangleGame` object. The following
    table lists the description and usage of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `circleRadius` | The radius setting of all drawing circles. |'
  prefs: []
  type: TYPE_TB
- en: '| `thinLineThickness` | The line thickness when drawing thin lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `boldLineThickness` | The line thickness when drawing bold lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `circles` | An array to store all drawn circles in the Canvas. |'
  prefs: []
  type: TYPE_TB
- en: '| `lines` | An array to store all drawn lines in the Canvas. |'
  prefs: []
  type: TYPE_TB
- en: '| `targetCircle` | Keeps track of the circle that we are dragging. |'
  prefs: []
  type: TYPE_TB
- en: '| `levels` | Stores all initial data of each level in the JSON format. |'
  prefs: []
  type: TYPE_TB
- en: '| `currentLevel` | A number to help you remember the current level. |'
  prefs: []
  type: TYPE_TB
- en: '| `levelProgress` | The percentage of non-intersected lines over all the lines.
    |'
  prefs: []
  type: TYPE_TB
- en: Defining the leveling data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each level, we have an initial position of the circles for the Untangle
    puzzle. The level data is designed as an array of objects. Each object contains
    every level''s data. Inside each level''s data, there are three properties: level
    number, circles, and lines connecting the circles. The following table shows the
    properties in each level''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Level property | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `circles` | An array of circles'' positions in the level. | This defines
    how the circles are placed initially when the level is set up. |'
  prefs: []
  type: TYPE_TB
- en: '| `relationships` | An array of relationships defining which circles connect
    to each other. | There are some lines connecting the circles in each level. We
    design the line connections so that there is a solution in each level. The array
    index of each relationship indicates the target circle. The value of the line
    relationship defines which circle connects to the target circle. For example,
    the following code means the target circle is connected to both circle 1 and circle
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Determining level-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The level is complete when there are no lines intersecting with each other.
    We loop through each line and see how many lines are thin. Thin lines mean they
    are not intersected with others. We can use the thin lines for all line ratios
    to get the percentage of the level of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can then simply determine that the level has been completed when the progress
    is 100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the current level and completeness progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have displayed a sentence below the Canvas game describing the current level
    status and progress. It is used to display the game status to the players so they
    know that they are making progress in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the jQuery `text` function that we discussed in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with DOM-based Game Development"), *Getting Started
    with DOM-based Game Development*, to update the completeness progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have only defined three levels in the example Untangle puzzle game so far.
    But it is not fun enough to play with just three levels. How about adding more
    levels to the game? If you cannot come up with a level, try searching for similar
    untangle games on the Internet and get some inspiration on the levels.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that now we want to show the progress level directly inside the Canvas.
    Canvas provides us with methods to draw text inside the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying the progress level text inside the canvas element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue using our Untangle game. Open the `untangle.drawing.js` JavaScript
    file in text editor. Add the following code after the Canvas drawing code in the
    `gameloop` function, which draws the current level and progress text inside the
    Canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.js` file. We put the following code inside the `gameloop`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and preview the `index.html` in a web browser. We will see that
    the text is now drawn inside the Canvas.![Time for action – displaying the progress
    level text inside the canvas element](img/B04290_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just drawn the title and the level progress text in our Canvas-based
    game. We draw text in the Canvas by using the `fillText` function. The following
    table shows how we use the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | The text that we are going to draw |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | The *x* coordinate that the text draws |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | The *y* coordinate that the text draws |'
  prefs: []
  type: TYPE_TB
- en: 'This is the basic setting to draw some text. There are several more drawing
    context properties to set up the text drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Context properties | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `context.font` | The font style of the text | This shares the same syntax
    we used to declare the font style in CSS. For example, the following code sets
    the font style to 20 pixels bold with the Arial typeface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `context.textAlign` | The text alignment | The **alignment** defines how
    the text is aligned. It can be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, if we are going to place some text on the right edge of the Canvas,
    using the `left` alignment means we need to calculate the text's width in order
    to know the x coordinate of the text.When using right alignment in this case,
    all we need to do is set the x position directly to the Canvas width. The text
    will then automatically be placed on the right edge of the Canvas. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `context.textBaseline` | The text baseline | The following lists the common
    value of a `textBaseline` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alphabet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to text alignment, the `bottom` baseline is useful when we want to place
    our text at the bottom of the Canvas. The *y* position of the `fillText` function
    is based on the bottom baseline of the text instead of the top.The `alphabet`
    baseline aligns the y position based on the lowercase alphabet. The following
    screenshot shows our text drawing with the **alphabet** baseline. |
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please be aware that the text drawing in Canvas is treated as bitmap image data.
    This means visitors cannot select the text; search engines cannot index the text;
    we cannot search the text. For this reason, we should think carefully about whether
    we want to draw the text inside the Canvas or just place it directly in the DOM.
    Alternatively, we should change the fallback text inside the `canvas` element
    to reflect the drawing text.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – drawing text in the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. If we are going to draw some text close to the bottom-right corner of the
    Canvas, which alignment and baseline setting is better?
  prefs: []
  type: TYPE_NORMAL
- en: Left alignment, bottom baseline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center alignment, alphabet baseline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right alignment, bottom baseline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center alignment, middle baseline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. We are going to make a realistic book with a flipping effect with the latest
    open web standard. Which of the following settings is better?
  prefs: []
  type: TYPE_NORMAL
- en: Draw the realistic book in Canvas, including all the text and the flipping effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put all text and content in the DOM and draw the realistic page-flipping effect
    in Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using embedded web font inside the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used a custom font in our memory, matching the game in the previous chapter.
    Custom font embedding also works in the Canvas. Let's conduct an experiment on
    drawing a custom font in our Untangle game in the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – embedding a Google web font into the canvas element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s draw the Canvas texts with a handwriting style font:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to the Google font directory and choose a handwriting style font.
    I used the font **Rock Salt** and you can get it from the following URL:[http://www.google.com/fonts/specimen/Rock+Salt](http://www.google.com/fonts/specimen/Rock+Salt).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Google font directory provides a CSS link code that we can add to our game
    in order to embed the font. Add the following CSS link to the head of `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing is to use the font. We open the `untangle.drawing.js` JavaScript
    file and modify the context `font` property in the `drawLevelProgress` function
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is time to open our game in the web browser to test the result. The text
    drawn in the Canvas is now using the font we chose in the Google font directory.![Time
    for action – embedding a Google web font into the canvas element](img/B04290_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just chose a web font and embedded it into the Canvas when drawing text.
    This shows that we can style the font family of the filled text in the Canvas
    just like other DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the width of the text varies in different font families although
    they have the same word count. In this case, we can use the `measureText` function
    to get the width of the text we draw. The Mozilla Developer Network explains how
    we can use the function at: [https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()).'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing images in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have drawn some text inside the Canvas. What about drawing an image? Yes.
    Drawing images and image manipulation is a big feature of the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding graphics to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to draw a blackboard background to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the graphics files from the code example bundle or the following URL:
    [http://mak.la/book-assets](http://mak.la/book-assets). The graphics files include
    all the graphics that we need in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the newly downloaded graphics files into a folder named `images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it is time to really load the image. There is a `board.png` file in the
    graphics file we just downloaded. It is a blackboard graphic that we will draw
    in the Canvas as a background. Add the following code after the code we just added
    in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the image loading takes time, we also need to ensure it is loaded before
    drawing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.js` file, in the jQuery document `ready` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `gameloop` function in the `untangle.js` file, we draw the image in
    the Canvas after clearing the context and before drawing anything else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we do not want a background color set to the Canvas because we have a
    PNG background with a transparent border. Open the `untangle.css` file and remove
    the background property in Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, save all files and open the `index.html` file in the web browser. The background
    should be there and the handwritten fonts should match our blackboard theme.![Time
    for action – adding graphics to the game](img/B04290_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just drew an image inside the `canvas` element. You can find the working
    example at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://makzan.net/html5-games/untangle-wip-graphics1/](http://makzan.net/html5-games/untangle-wip-graphics1/)'
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways to draw an image in the Canvas. We can either reference
    an existing `<img>` tag or load the image on the fly in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we reference the existing image tag in `canvas`, assuming that
    we have the following `img` tag in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can draw the image in the Canvas by using the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another code snippet to load the image without attaching the `<img>`
    tag into the DOM. If we load the image inside JavaScript, we need to make sure
    the image is loaded before drawing it in the Canvas. Therefore, we draw the image
    after the `onload` event of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order matters when setting the `onload` event handler and assigning the
    image `src`.
  prefs: []
  type: TYPE_NORMAL
- en: When we assign the `src` property to the image and if the image is cached by
    the browser, some browsers fire the `onload` event immediately. If we place the
    `onload` event handler after assigning the `src` property, we may miss it because
    it is fired before we set the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used the latter approach. We create an `Image` object and
    loaded the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another event that we should handle when loading the image is the `onerror`
    event. It is especially useful when we are accessing extra network data. We use
    the following code snippet to check the errors in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The error loading now only displays a message in the console. The console is
    normally not viewed by players. How about writing a message to the Canvas to tell
    players that the game failed to load the game's assets?
  prefs: []
  type: TYPE_NORMAL
- en: Using the drawImage function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three ways to draw an image in the Canvas using the `drawImage` function.
    We can draw the image without any modification on a given coordinate, we can also
    draw the image with a scaling factor on a given coordinate, or we can even crop
    the image and draw only the clipping region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drawImage` function accepts several arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every argument present in `drawImage(image, x, y);` is explained in the following
    table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Argument | Definition | Discussion |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `image` | The reference of the image that we are going to draw. | We either
    get the image reference by using an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `x` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `y` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Every argument present in `drawImage(image, x, y, width, height);` is explained
    in the following table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Argument | Definition | Discussion |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `image` | The image reference that we are going to draw. | We either get
    the image reference by using an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `x` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `y` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `width` | The width of the final drawn image. | We apply scale to the image
    if the width and height is not the same as the original image. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `height` | The height of the final drawn image. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Every argument present in `drawImage(image, sx, sy, sWidth, sHeight, dx, dy,
    width, height);` is explained in the following table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Argument | Definition | Discussion |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `image` | The image reference that we are going to draw. | We either get
    the image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `sx` | The *x* coordinate of the top-left corner of the clipping region.
    | Clipping *x*, *y*, width, height together defines a rectangular clipping area.
    The given image is clipped by this rectangle. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `sy` | The *y* coordinate of the top-left corner of the clipping region.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `sWidth` | The width of the clipping region. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `sHeight` | The height of the clipping region. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `dx` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `dy` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `width` | The width of the final drawn image. | We are applying scale to
    the clipped image if the width and height is not the same as the clipping dimension.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `height` | The height of the final drawn image. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Have a go hero – optimizing the background image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example, we draw the blackboard image as the background in every call
    to the `gameloop` function. Since our background is static and does not change
    with time, clearing it and redrawing it again and again is wasting CPU resources.
    How can we optimize this performance issue? In a later section, we will divide
    the game into multiple layers to avoid redrawing the static background image.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the Canvas-based game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have enhanced the Canvas game with gradients and images. Before moving forward,
    let's decorate the web page of our Canvas game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding CSS styles and image decoration to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a center-aligned layout with a game title:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `index.html` in a text editor. It is easier for us to style the layout
    with one grouping DOM element. We put all the elements inside the body into a
    section with the `id` page. Replace the contents of the HTML file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s apply CSS to the page layout. Replace existing content in the `untangle.css`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is time to save all the files and preview the game in a web browser. We should
    see a title ribbon and a well-styled layout that is center-aligned. The following
    screenshot shows the result:![Time for action – adding CSS styles and image decoration
    to the game](img/B04290_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just decorated the web page that contains our Canvas-based game. Although
    our game is based on a Canvas drawing, it does not restrict us from decorating
    the whole web page with graphics and CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Default background of the canvas element**'
  prefs: []
  type: TYPE_NORMAL
- en: The default background of the `canvas` element is transparent. If we do not
    set any background CSS style for the Canvas, it will be transparent. This is useful
    when our drawing is not a rectangle. In this example, the textured layout background
    shows within the Canvas region.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – styling a Canvas background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How can we set the Canvas background to be transparent?
  prefs: []
  type: TYPE_NORMAL
- en: Set the background color to `#ffffff`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do nothing. It is transparent by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animating a sprite sheet in Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first used **sprite sheet** images in [Chapter 3](ch03.html "Chapter 3. Building
    a Card-matching Game in CSS3"), *Building a Card-matching Game in CSS3*, when
    displaying a deck of playing cards.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making a game guide animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a graphics file named `guide_sprite.png` in the images folder. It is
    a game guideline graphic that contains each step of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – making a game guide animation](img/B04290_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s draw this guide into our game with **animations**:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `untangle.drawing.js` JavaScript file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `untangleGame.loadImages` function, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the `untangleGame.drawing.js` file, we add the following function
    to move the current frame to the next frame every 500 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the `drawGuide` function in the `untangleGame.drawing.js` file.
    This function draws the guide animation according to the current frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's switch to the `untangle.js` file. In the `gameloop` function, we call
    the guide drawing function before ending the `gameloop` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's watch the animation in the web browser by opening the `index.html` file.
    The following screenshot demonstrates the animation of the game guideline. The
    guideline animation will play and loop until the player levels up:![Time for action
    – making a game guide animation](img/B04290_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can draw only a region of an image when using the `drawImage` context function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the process of animation step by step.
    The rectangle is the clipping region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We used a variable named `guideFrame` to control which frame to show. The width
    of each frame is 80\. Therefore, we get the x position of the clipping region
    by multiplying the width and the current frame number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `guideFrame` variable is updated every 500 milliseconds by the following
    `guideNextFrame` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Animating a sprite is a commonly used technique when developing games. There
    are some benefits of using sprite animation when developing traditional video
    games. The reasons may not apply to web game development but there are other benefits
    of using sprite sheet animation:'
  prefs: []
  type: TYPE_NORMAL
- en: All frames are loaded as one file so the whole animation is ready once the sprite
    file is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting all frames into one file means we can reduce the HTTP request from the
    web browser to the server. If each frame is a file, the browser requests the file
    many times, while now it just requests one file and uses one HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting different images into one file also reduces the duplication of files,
    which helps to reduce the duplicate file's header, footer, and metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting all frames into one image means we can easily clip the image to display
    any frame without complex code to change the image source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite sheet animation is usually used in character animation. The following
    screenshot is a **sprite animation** of an angry cat that I used in an HTML5 game
    named **Neighbours**.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We built the sprite sheet animation by clipping the frame and setting up the
    timer ourselves in this example. When working with a lot of animations, we may
    want to use a third-party sprite animation plugin or create our own Canvas sprite
    animation to better reuse and manage the logic code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sprite animation is an important topic in HTML5 games development and there
    are many online resources discussing this topic. The following links are some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The sprite animation tutorial ([http://simurai.com/blog/2012/12/03/step-animation/](http://simurai.com/blog/2012/12/03/step-animation/))
    by Simurai discusses how we can make a sprite animation with CSS only.
  prefs: []
  type: TYPE_NORMAL
- en: Spritely ([http://www.spritely.net/](http://www.spritely.net/)), on the other
    hand, provides sprite animation over the DOM element with CSS. It is useful when
    we want to animate a sprite without using Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multilayer Canvas game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now all things are drawn into the context, which has no other state to distinguish
    the items drawn. We may split the Canvas game into different layers and code the
    logic to control and draw each layer at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – dividing the game into four layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to separate our Untangle game into four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.html`, we need to change or replace the current `canvas` tag with
    the following code. It should contain several Canvases within a section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to apply some styles to the Canvases so they overlap with each
    other to create a multiple layers effect. Also we have to prepare a `fadeout`
    class and a `dim` class to make the target transparent. Add the following code
    into the `untangle.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.js` JavaScript file. We modify the code to support the layers
    feature. First, we add an array to store the context reference of each Canvas.
    Add it at the beginning of the file, before the jQuery document ready function
    and after the `untangleGame` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we remove the following lines of code in the jQuery document ready function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We replace the code we deleted with the following code. We get the context
    reference of each Canvas layer and store them in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's switch to `untangle.drawing.js` file. We are going to update the context
    references at several places to support multilayers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are now four Canvas contexts that we may clear. Find the existing `clear`
    function and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `drawCircle` and `drawLine` function, replace `var ctx = untangleGame.ctx;`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `drawLevelProgress` function, replace `var ctx = untangleGame.ctx;`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `drawBackground` function, we replace the existing code with the following,
    which draws on the background layer with index `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we move to the `loadImages` function. Add the following code to the function.
    It draws the background once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `drawGuide` function, replace `var ctx = untangleGame.ctx;` with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Actually, we fade out the guide layer in this function too. So we replace the
    entire `drawGuide` function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `guideNextFrame` function, we clear the guide layer and redraw it.
    Add the following code to the end of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During the circle dragging, we don''t want our progress text layer to block
    the game elements. So we will define an extra function that dims the opacity of
    the progress layer when there are any game circles overlapping the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are done with the `untangle.drawing.js` file. Let''s switch back to the
    `untangle.js` file. In the `gameloop` function, we remove the calls to the `drawBackground`
    and `drawGuide` functions. Then, we call the `dimUILayerIfNeeded` function. We
    also clear the layer 2 game elements and layer 3 level progress in every game
    loop. Now the `gameloop` function becomes the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `untangle.input.js` file. We had mouse down, move, and up
    event listeners on the `#game` Canvas. Since the game Canvases are now overlapping,
    the mouse event listener we had in the `game` Canvas does not fire anymore. We
    can change the listener to listen to the events from its parent `#layers` DIV,
    which has the same position and dimension of the Canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the files and check our code changes in the web browser. The game should
    be displayed as if we haven't changed anything. Try dragging the circle down close
    to the bottom edge of the blackboard. The level progress text should dim to a
    low opacity. When you finish the first level, the guideline animation will fade
    out gracefully. The following screenshot shows the level progress in half opacity:![Time
    for action – dividing the game into four layers](img/B04290_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We divided our working game into four layers. There are quite a lot of changes
    in this section. You may try the working example at: [http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/).
    By observing the source code, you can view the uncompressed code example.'
  prefs: []
  type: TYPE_NORMAL
- en: There are four Canvases in total now. Each Canvas is in charge of one layer.
    The layers are divided into the background, game guideline, game itself, and the
    user interface showing the level progress.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Canvases, like other elements, are placed one after the other.
    In order to overlap all Canvases to construct the layer effect, we applied the
    `absolute` position to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show the four layers in our game. By default, the
    DOM that was added later is on top of the one added before. Therefore, the `bg`
    Canvas is at the bottom and `ui` is on the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By using different layers, we can create specific logic for each layer. For
    example, the background in this game is static. We only draw it once. The guide
    layer is a 6-frames animation with 500 milliseconds for each frame. We redraw
    the guide layer in 500 milliseconds intervals. The game layer and UI layer are
    the core game logic, which we draw 30 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing a CSS technique with Canvas drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are creating a Canvas-based game but we are not restricted to use only a
    Canvas drawing API. Each layer is an individual Canvas layer. We can apply a CSS
    technique to any layer. The level progress information is now in another Canvas
    with the ID `ui`. In this example, we mixed the CSS technique we discussed in
    [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game in CSS3"), *Building
    a Card-matching Game in CSS3*.
  prefs: []
  type: TYPE_NORMAL
- en: When we drag the circles around the Canvas, they may overlap the level information.
    When drawing the UI Canvas layer, we check whether any circle's coordinate is
    too low and is overlapping the text. We then fade the UI Canvas CSS opacity so
    it does not distract the player from the circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also fade out the guideline animation after the player levels up. This is
    done by fading out the whole `guide` Canvas with CSS transition easing to 0 opacity.
    Since the `guide` Canvas is only in charge of that animation, hiding that Canvas
    does not affect other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Clearing only the changed region to boost the canvas performance**'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the clear function to only clear part of the Canvas context. This
    will give the performance some boost because it avoids redrawing the entire Canvas
    context every time. This is achieved by marking the 'dirty' region of the context
    that has changed state since last drawn.
  prefs: []
  type: TYPE_NORMAL
- en: In the guide Canvas layer in our example, we may consider clearing only the
    region of the sprite sheet image drawing instead of the whole Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We may not see significant differences in simple Canvas examples but it helps
    boost the performance when we have a complex Canvas game that includes many sprite
    image animations and complex shape drawings.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We fade out the guide when the players advance to level 2\. How about we fade
    out the guide animation once the player drags any circles? How can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about drawing gradients, text, and images
    in a Canvas. Specifically, we built the Untangle game logic and used several advanced
    Canvas techniques, including sprite sheet animation using the clipping function
    when drawing images. We divided the game into several layers by stacking several
    `canvas` elements. This allows us to handle different parts of the game rendering
    in separated and specific logic. Finally, we mixed the CSS transition animation
    in a Canvas-based game.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we haven't mentioned in this book is the bitmap manipulation in Canvas.
    Canvas context is a bitmap data where we can apply an operation on each pixel.
    For instance, we may draw an image in the Canvas and apply Photoshop-like filters
    to the image. We will not cover this in the book because image manipulation is
    an advanced topic and the application may not relate to game development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about building games in Canvas and making animation
    for game objects, such as game character, we are ready to add audio components
    and sound effects to our games in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will get back to Canvas-based games in [Chapter 9](ch09.html "Chapter 9. Building
    a Physics Car Game with Box2D and Canvas"), *Building a Physics Car Game with
    Box2D and Canvas*.
  prefs: []
  type: TYPE_NORMAL
