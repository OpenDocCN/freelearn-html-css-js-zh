- en: Chapter 7. Setting up an Automated Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a major step from a demo application to a maintainable
    codebase by starting to write automated tests. Another important component of
    real-world software projects is build automation.
  prefs: []
  type: TYPE_NORMAL
- en: Automated builds allow a whole team to work on a project in a consistent manner.
    A standardized way of executing common tasks makes it easier for new developers
    to get started. It also avoids annoying issues with developers getting different
    results for spurious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an integration server to build and run our tests automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an automated task runner to simplify the execution of our tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating more tasks to help maintain coding standards and test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an integration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build and test automation allow code changes to be verified by an **integration
    server**, an automated server independent of individual developers' machines.
    This helps keep the project stable by catching errors or regressions early on.
    The integration server can automatically alert the developer who introduced the
    problem. They then have a chance to fix the problem before it causes issues for
    the rest of the team or the project as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Building the codebase and running tests automatically on each commit is called
    **Continuous Integration** (**CI**). There are many CI/build servers available.
    These can be self-hosted or provided as a third-party service. Examples that you
    may have used before include Jenkins (formerly Hudson), Atlassian Bamboo, JetBrains
    TeamCity, and Microsoft's Team Foundation Server.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be using Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    which is a hosted service for running automated builds. It is free for use with
    public source code repositories. In order to use Travis CI's free service, we
    need to host our application's code in a public GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a public GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have your own version of the example application code from following
    along with the book so far, and are already familiar with GitHub, you can push
    your code to a new GitHub repository of your own. Otherwise, you can fork one
    of the example chapter repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use [https://github.com/NodeJsForDevelopers/chapter06/](https://github.com/NodeJsForDevelopers/chapter06/)
    if you want to follow along with the changes in this chapter. This contains the
    example code from the end of [Chapter 6](part0034.xhtml#aid-10DJ41 "Chapter 6. Testing
    Node.js Applications"), *Testing Node.js Applications*, which we will build on
    in this chapter. You can create your own fork of this repository using the **Fork**
    button on GitHub. This should be visible at the top-right of the screen when visiting
    the URL mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a public GitHub repository](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will create a new repository under your own GitHub account, using the example
    code as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is all you need to get started in this chapter. However, if you are not
    already familiar with Git and/or GitHub and would like to know more, you can find
    more information at [https://help.github.com/](https://help.github.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Building a project on Travis CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll now set up a build for our application on Travis CI. If you created your
    own public repository in the previous section, you can try this out for yourself.
    Visit [https://travis-ci.org](https://travis-ci.org) and sign in with GitHub.
    You should see a profile page listing your repositories. Enable the repository
    you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create a simple `config` file to tell Travis CI in what environment(s)
    to build our application. Create a file in the root of the project as follows
    (note the leading dot in the file name `.travis.yml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This tells TravisCI to build our project with the current stable and long-term
    support versions of Node.js (at the time of writing). If you're familiar with
    Git, you can make this change in a local clone of your repository, commit, and
    push it to master. If you're new to Git, the easiest way to create this file is
    to navigate to your repository on [https://github.com](https://github.com) and
    click on the **New file** button. This will open a web-based editor from which
    you can create and commit the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added this file to your repository, visit [https://travis-ci.org](https://travis-ci.org)
    again. You should now see a passing build for your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a project on Travis CI](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: TravisCI built our project twice, once for each version of Node.js that we specified.
    If you click on either build you can see the command-line output. Notice that
    TravisCI automatically ran our tests using the standard `npm test` command.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build process with Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's great that TravisCI runs our tests automatically. But that's not the only
    task we want to automate. Of course, as JavaScript is an interpreted language,
    we don't have a compile step in our build process. There are other tasks we want
    to carry out though, for example, checking our code style, running integration
    tests, and gathering code coverage. We can make use of a build tool to automate
    these tasks and allow us to run them in a consistent manner. You may have used
    MSBuild for this in .NET before or Java tools such as Maven or Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different build tools available for Node.js. The two most
    popular by far are Grunt and Gulp. Both have large communities and an extensive
    range of plugins for performing different operations. Grunt's model has each operation
    reading in files and writing back to the filesystem. Gulp uses Node.js streams
    to pipe processing from one operation to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt's model is slightly simpler and may be easier to get started with, especially
    if you have modest build requirements. Gulp's model is potentially faster for
    some types of task and can reduce the amount of build configuration code you need
    to write. Both are excellent, well-supported build tools. We'll be using Gulp,
    but everything we do in this chapter could be achieved with Grunt as well.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests using Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first need to install Gulp, both globally (to add it to our path) and into
    the project. Then we add Gulp plugins for controlling Mocha and environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now add a configuration file for Gulp to our project. Gulp will look for
    a file with this name by convention as `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a test task and makes an empty default task to run it. The `''default''`
    task name is special and will be invoked when we run `gulp` from the command line.
    We can now remove our test script from `package.json` and update our `.travis.yml`
    file to run Gulp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This hasn't gained us much yet. We now just have a slightly shorter command
    to execute our tests. However, the use of a build tool will become more valuable
    as we add more tasks to automate. Let's look at some of the other processes we
    may want to make part of our build.
  prefs: []
  type: TYPE_NORMAL
- en: Checking code style with ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we don't need a compiler, we can still benefit from having the computer
    perform static analysis of our code. Linting tools are common in many languages
    for spotting common programming errors that may lead to subtle bugs or confusing
    code. You may be familiar with CodeRush, StyleCop, and others for .NET, or CheckStyle,
    Findbugs, Sonar, and others for Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using a JavaScript/ECMAScript linting tool called ESLint. Let''s
    first install it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a config file to tell ESLint what rules to use as `.eslintrc.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we tell ESLint to use its standard recommended rules for the environments
    that we are using in our scripts. We also tell it to check for semicolons at the
    ends of statements and to prefer single quotes. You can run ESLint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'ESLint outputs any errors it finds, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An unused `favicon` local variable in app.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unused `next` parameter in various middleware functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `console.log` in our PhantomJS integration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `phantom` variable in our PhantomJS integration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first of these is trivial to solve: we can just remove the variable declaration
    (this was created for us by the express application template in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*). We
    could do the same for the `next` parameters on our middleware functions. However,
    I prefer middleware functions to have a standard and easily identifiable signature.
    Instead of removing this parameter, we can tell ESLint to ignore this particular
    parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two bullet points both relate to our PhantomJS integration test. This
    is quite a special file, so here we''ll change ESLint''s behavior for this file
    specifically, using a comment directive. We can add the following directives at
    the very top of the offending file, `integration-test/game.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first of these directives tells ESLint that this script file will run in
    the PhantomJS environment, where the `phantom` variable will be provided for us,
    so ESLint does not need to warn us against referencing it. The second directive
    disable's ESLint's rule against using console logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you run ESLint again, you should find that the errors listed previously have
    disappeared. Any remaining errors should be smaller issues such as missing semicolons
    or inconsistent use of quotes. These should be quick to fix manually, but in fact,
    ESLint can do this for us, as we'll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically fixing issues in ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ESLint is able to automatically correct some of the issues it finds. If ESLint
    is not currently reporting any errors, try removing a semicolon from one of the
    project's source files. Run ESLint and you should see an error for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run ESLint with the `--fix` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ESLint replaces the semicolon for us. Not all of ESLint's rules can be fixed
    in this way, but many of them can. It depends on whether a rule's errors always
    have a single unambiguous fix. The full list of rules, including which ones are
    fixable, can be found on the ESLint site at [http://eslint.org/docs/rules/](http://eslint.org/docs/rules/).
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to run ESLint with no errors or warnings. ESLint is now
    ready to pick up errors in any new code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: Running ESLint from Gulp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's slightly messy to specify special exclusions for our Phantom integration
    test. It's also unfortunate that we're enabling the Node.js, Mocha, browser, and
    jQuery environments globally. The Mocha environment is only needed for our test
    code. The browser and jQuery environments are only need for our client-side code,
    where the Node.js environment is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be easier to manage if we ran ESLint separately on different sets
    of files. This would start to become tedious and error-prone if we did it manually.
    But it''s a great use case for a build tool. We can set up separate ESLint profiles
    for different sets of files using Gulp. First, install the Gulp ESLint plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create Gulp tasks to lint each set of sources. By default, the `gulp-eslint`
    plugin uses rules from our `.eslintrc.json` file. So, we can cut this down to
    just the rules that are relevant to all sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then specify the relevant rules or environments for each set of sources
    in their own Gulp task. This also allows us to remove the special directive comments
    from the top of our integration test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we wire up the dependencies between our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make the `test` task depend on `lint-test` and create a new overall
    `lint` task to run all of the others as part of the default build. Try running
    Gulp and observe the output. Note that it kicks off all the lint tasks in parallel,
    but waits for `lint-test` to complete before running tests. By default, Gulp will
    run tasks concurrently if possible. If a task returns a stream (the object obtained
    from `gulp.src`) at the end, Gulp is able to use this to detect when the task
    finishes. Gulp will wait for a task to finish before starting any tasks that depend
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how ESLint failures affect Gulp, let''s add another ESLint rule to ensure
    the use of JavaScript''s strict mode, as described in [Chapter 3](part0022.xhtml#aid-KVCC1
    "Chapter 3. A JavaScript Primer"), *A JavaScript Primer*. The following code is
    from `.eslintrc.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'ESLint is clever enough to make use of the specified environment for each set
    of files to work out how strict mode should be applied: at the top of functions
    for client-side scripts and globally for files that will become Node.js modules.
    It also spots when we unnecessarily specify strict mode multiple times, globally
    or in nested functions.'
  prefs: []
  type: TYPE_NORMAL
- en: When you execute Gulp, notice that failures in the ESLint tasks prevent the
    dependent test tasks from running. If you fix the strict mode errors, then Gulp
    will run successfully again.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering code coverage statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although we have some tests for our application, they are certainly not yet
    comprehensive. It would be useful to be able to see what parts of our code are
    covered by tests. For this, we''ll use Istanbul, a JavaScript code coverage tool.
    First, install the `gulp-instanbul` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add a Gulp task to instrument our production code for coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update our test task to output a coverage report and fail
    the build if we are below our threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run Gulp, three new results occur:'
  prefs: []
  type: TYPE_NORMAL
- en: A coverage summary appears on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of coverage reports appear under the `coverage` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build fails because we are below the coverage threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build summary on the command line is very useful. There is even more detail
    in the HTML report that appears at `coverage/lcov-report/index.html` (in the project
    directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we need to improve our test coverage, we don''t want to leave our
    build failing. For now, we''ll set the coverage target just below our current
    level so it doesn''t drop further. We can do this with the options passed to `istanbul.enforceThresholds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running integration tests from Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gulp tasks are just ordinary JavaScript functions, so can contain any functionality
    we like. Let''s look at a more complex use case. We''ll create a task that starts
    up our server, runs integration tests, and then closes the server. For this, we''ll
    need the Gulp Shell plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we update our integration test script so that we can pass in the port
    number of the test server. This makes use of the PhantomJS `''system''` module
    as follows (in `integration-test/game.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define a Gulp task to run the server and the integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This launches the application and then makes use of the `gulp-shell` plugin
    to execute our integration test scripts. Finally, we make sure we close the server
    when done, passing in Gulp's async callback. Like returning a stream, using this
    callback allows Gulp to know when the task has completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make this task depend on the `test` task so that they don''t interfere with
    one another. We don''t make this part of our default task as it''s a more heavyweight
    operation. We do want it to run on our build server though, so we''ll add it to
    `.travis.yml` along with the default task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we push to the remote master, TravisCI will run static analysis on our
    code, execute all of our unit and integration tests, and check the unit test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have set up an integration build using Travis CI, added
    static analysis of our code using ESLint, automated our tests and other tasks
    using Gulp, and started measuring our test coverage using the Istanbul tool.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the infrastructure in place for stable development, we can
    start expanding our project. In the next chapter, we'll introduce persistent data
    stores to the application.
  prefs: []
  type: TYPE_NORMAL
