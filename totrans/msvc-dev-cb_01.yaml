- en: Breaking the Monolith
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破单体架构
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Organizing your team to embrace microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织团队以拥抱微服务
- en: Decomposing by business capability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按业务能力分解
- en: Identifying bounded contexts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别边界上下文
- en: Migrating data in production
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境中的数据迁移
- en: Refactoring your monolith
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构单体架构
- en: Evolving your monolith into services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单体架构演进为服务
- en: Evolving your test suite
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步完善测试套件
- en: Using Docker for local development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker进行本地开发
- en: Routing requests to services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求路由到服务
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the hardest things about microservices is getting started. Many teams
    have found themselves building features into an ever-growing, hard-to-manage monolithic
    code base and don't know how to start breaking it apart into more manageable,
    separately deployable services. The recipes in this chapter will explain how to
    make the transition from monolith to microservices. Many of the recipes will involve
    no code whatsoever; instead, they will be focused on architectural design and
    how best to structure teams to work on microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务中最困难的事情之一就是开始。许多团队发现自己正在将功能构建到一个不断增长、难以管理的单体代码库中，并且不知道如何开始将其拆分成更易于管理的、可独立部署的服务。本章中的食谱将解释如何从单体过渡到微服务。许多食谱将完全不涉及任何代码；相反，它们将专注于架构设计和如何最佳地构建团队以在微服务上工作。
- en: You'll learn how to begin moving from a single monolithic code base to suites
    of microservices. You'll also learn how to manage some of the initial challenges
    when you begin to develop features using this new architectural style.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何从单一的大型代码库开始逐步过渡到微服务套件。你还将了解在开始使用这种新的架构风格开发功能时如何应对一些初始挑战。
- en: Organizing your team
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的团队
- en: Conway's law tells us that organizations will produce designs whose structure
    is a copy of their communication structure. This often means that the organizational
    chart of an engineering team will have a profound impact on the structure of the
    designs of the software it produces. When a new startup begins building software,
    the team is small—sometimes it is comprised of just one or two engineers. In this
    setup, engineers work on everything, including frontend and backend systems, as
    well as operations. Monoliths suit this organizational structure very well, allowing
    engineers to work on any part of the system at any given time without moving between
    code bases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律告诉我们，组织将产生结构与其沟通结构相匹配的设计。这通常意味着工程团队的组织结构将对它产生的软件设计结构产生深远的影响。当一个新创业公司开始构建软件时，团队规模很小——有时可能只有一到两名工程师。在这种配置下，工程师负责一切，包括前端和后端系统，以及运维。单体架构非常适合这种组织结构，允许工程师在任何给定时间都能在系统中的任何部分工作，而无需在代码库之间移动。
- en: As a team grows, and you start to consider the benefits of microservices, you
    can consider employing a technique commonly referred to as an the **Inverse Conway
    Maneuver**. This technique recommends evolving your team and organizational structure
    to encourage the kind of architectural style you want to see emerge. With regard
    to microservices, this will usually involve organizing engineers into small teams
    that you will eventually want to be responsible for a handful of related services.
    Setting your team up for this structure ahead of time can motivate engineers to
    build services by limiting communication and decision-making overhead within the
    team. Simply put, monoliths continue to exist when the cost of adding features
    as services is greater than the cost of adding a feature to the monolith. Organizing
    your teams in this way reduces the cost of developing services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队规模扩大，你开始考虑微服务的优势时，你可以考虑采用一种通常被称为**康威逆向行动**的技术。这种技术建议通过演进团队和组织结构来鼓励出现你希望看到的架构风格。对于微服务而言，这通常意味着将工程师组织成小团队，你最终希望他们负责少量相关的服务。提前为这种结构做好准备可以激励工程师通过限制团队内部的沟通和决策开销来构建服务。简单来说，当添加功能作为服务的成本大于添加到单体架构的成本时，单体架构将继续存在。以这种方式组织团队可以降低开发服务的成本。
- en: This recipe is aimed at managers and other leaders in companies who have the
    influence to implement changes to the structure of the organization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱针对那些在公司中具有影响力以实施组织结构变革的管理者和其他领导者。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Re-organizing a team is never a simple task, and there are many non-obvious
    factors to consider. Factors such as personality, individual strengths and weaknesses,
    and past histories are outside the scope of this recipe, but they should be considered
    carefully when making any changes. The steps in this recipe provide one possible
    way to move a team from being organized around a monolithic code base to being
    optimized for microservices, but there is no one-size-fits-all recipe for every
    organization.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重组团队永远不是一项简单的工作，有许多非显而易见因素需要考虑。如个性、个人优势和劣势以及过去的历史等因素超出了本食谱的范围，但在做出任何改变时都应该仔细考虑。本食谱中的步骤提供了一种将团队从围绕单体代码库组织转变为针对微服务优化的一种可能方式，但并非每个组织都有一劳永逸的食谱。
- en: 'Use the following steps as a guide if you think they apply, but otherwise use
    them for inspiration and to encourage thought and discussion:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这些步骤适用，请以此为指导，否则请以此作为灵感，并鼓励思考和讨论：
- en: Working with other stakeholders in your organization, build out a product roadmap.
    You may have limited information about the challenges your organization will face
    in the short term, but do the best you can. It's perfectly natural to be very
    detailed for short-term items on a roadmap and very general for the longer term.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与你组织中的其他利益相关者合作，制定产品路线图。你可能会对你的组织在短期内将面临哪些挑战的信息有限，但尽你所能。在路线图上对短期项目非常详细，而对长期项目非常概括是完全自然的。
- en: Using the product roadmap, try to identify technical capabilities that will
    be required to help you deliver value to your users. For example, you may be planning
    to work on a feature that relies heavily on search. You may also have a number
    of features that rely on content uploading and management. This means that search
    and uploading are two technical capabilities you know you will need to invest
    in.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用产品路线图，尝试确定你需要的技术能力，以帮助你向用户提供价值。例如，你可能正在计划开发一个高度依赖搜索的功能。你也可能有多个依赖内容上传和管理的功能。这意味着搜索和上传是你知道需要投资的两个技术能力。
- en: As you see patterns emerge, try to identify the main functional areas of your
    application, paying attention to how much work you anticipate will go into each
    area. Assign higher priorities to the functional areas you anticipate will need
    a lot of investment in the short to medium term.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着你看到模式开始显现，尝试确定你应用程序的主要功能区域，注意你预计每个区域将投入多少工作量。将更高的优先级分配给你预计在短期内和中期内需要大量投资的那些功能区域。
- en: Create new teams, ideally consisting of four to six engineers, who are responsible
    for one of the functional areas within your application. Start with the functional
    areas that you anticipate will require the most work over the next quarter or
    so. These teams can be focused on the backend services or they can be cross-functional
    teams that include the mobile and web engineers. The benefit of having cross-functional
    teams is that the team can then deliver the entire vertical component of the application
    autonomously. The combination of service engineers with engineers consuming their
    services will also enable more information sharing, and hopefully, empathy.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的团队，理想情况下由四到六名工程师组成，负责你应用程序中的一个功能区域。从你预计在接下来的一个季度左右需要最多工作的功能区域开始。这些团队可以专注于后端服务，也可以是包括移动和网页工程师的跨职能团队。拥有跨职能团队的优点是，团队可以自主地交付应用程序的整个垂直组件。服务工程师与使用他们服务的工程师的组合也将促进更多的信息共享，并希望产生同理心。
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论
- en: Using this approach, you should end up with small, cohesive, and focused teams
    responsible for core areas of your application. The nature of teams is that individuals
    within the team should start to see the benefit of creating separately managed
    and deployed code bases that they can work in autonomously without the costly
    overhead of coordinating changes and deployments with other teams.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你应该最终拥有小型、团结和专注于你应用程序核心区域的小团队。团队的本质是，团队内部的个人应该开始看到创建单独管理和部署的代码库的好处，他们可以在没有与其他团队协调更改和部署的昂贵开销的情况下自主工作。
- en: To help illustrate these steps, imagine your organization builds an image-messaging
    application. The application allows users to take a photo with their smart phone
    and send it, along with a message, to a friend in their contacts list. Their friends
    can also send them photos with messages. A fictional roadmap for this fictional
    product could involve the need to add support for short videos, photo filters,
    and support for emojis. You now know that the ability to record, upload, and play
    videos, the ability to apply photo filters, and the ability to send rich text
    will be important to your organization. Additionally, you know from experience
    that users need to register, log in, and maintain a friends list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明这些步骤，想象一下你的组织正在开发一个图片消息应用。该应用允许用户用智能手机拍照并发送照片，以及一条消息，给他们的联系人列表中的朋友。他们的朋友也可以向他们发送带消息的照片。这个虚构产品的路线图可能包括添加对短视频、照片滤镜和对表情符号的支持的需求。你现在知道，记录、上传和播放视频的能力、应用照片滤镜的能力以及发送富文本的能力将对你的组织非常重要。此外，根据经验，你知道用户需要注册、登录并维护朋友列表。
- en: Using the preceding example, you may decide to organize engineers into a media
    team, responsible for uploading, processing and playing, filters, and storage
    and delivery, a messaging team, responsible for the sending of photo or video
    messages with associated text, and a users team, responsible for providing reliable
    authentication, registration, on-boarding, and social features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的例子，你可能会决定将工程师组织成一个媒体团队，负责上传、处理和播放、滤镜以及存储和交付，一个消息团队，负责发送带有相关文本的图片或视频消息，以及一个用户团队，负责提供可靠的认证、注册、入职和社交功能。
- en: Decomposing by business capability
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按业务能力分解
- en: In the early stages of product development, monoliths are the best suited to
    delivering features to users as quickly and simply as possible. This is appropriate,
    as at this point in a products development you do not have luxury problems of
    having to scale your teams, code bases or ability to serve customer traffic. Following
    good design practices, you separate your applications concerns into easy-to-read,
    modular code patterns. Doing so allows engineers to work on different sections
    of the code autonomously and limits the possibility of having to untangle complicated
    merge conflicts when it comes time to merge your branch into the master and deploy
    your code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品开发的早期阶段，单体架构最适合以最快、最简单的方式向用户提供功能。这是合适的，因为在产品开发的这个阶段，你还没有扩展团队、代码库或服务客户流量的奢侈问题。遵循良好的设计实践，你将应用程序的关注点分离成易于阅读的、模块化的代码模式。这样做允许工程师独立地工作在不同的代码部分，并限制了在合并分支到主分支和部署代码时需要解决复杂的合并冲突的可能性。
- en: Microservices require you to go a step further than the good design practices
    you've already been following in your monolith. To organize your small, autonomous
    teams around microservices, you should consider first identifying the core business
    capabilities that your application provides. Business capability is a business
    school term that describes the various ways your organization produces value.
    For example, your internal order management is responsible for processing customer
    orders. If you have a social application that allows users to submit user-generated
    content such as photos, your photo upload system provides a business capability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务要求你比你在单体中遵循的良好设计实践更进一步。为了围绕微服务组织你的小型、自主团队，你应该首先考虑确定你的应用程序提供的核心业务能力。业务能力是商学院的一个术语，描述了你的组织创造价值的不同方式。例如，你的内部订单管理负责处理客户订单。如果你有一个允许用户提交用户生成内容（如照片）的社交应用，你的照片上传系统提供了一个业务能力。
- en: When thinking about system design, business capabilities are closely related
    to the **Single Responsibility Principle** (**SRP**) from **object-oriented design**
    (**OOD**). Microservices are essentially SRP extended to code bases. Thinking
    about this will help you design appropriately sized microservices. Services should
    have one primary job and they should do it well. This could be storing and serving
    images, delivering messages, or creating and authenticating user accounts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑系统设计时，业务能力与面向对象设计（OOD）中的**单一职责原则（SRP**）密切相关。微服务本质上是将SRP扩展到代码库。考虑这一点将帮助你设计适当规模的微服务。服务应该有一个主要任务，并且应该很好地完成它。这可能包括存储和提供图像、传递消息或创建和验证用户账户。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Decomposing your monolith by business capability is a process. These steps
    can be carried out in parallel for each new service you identify a need for, but
    you may want to start with one service and apply the lessons you learn to subsequent
    efforts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过业务能力分解你的单体应用是一个过程。这些步骤可以并行执行，以应对你识别出的每个新服务的需求，但你可能想从一个服务开始，并将你学到的经验应用到后续的工作中：
- en: 'Identify a business capability that is currently provided by your monolith.
    This will be the target for our first service. Ideally this business capability
    is something that has some focus on the roadmap you worked on in the previous
    recipe and ownership can be given to one of your newly created teams. Let''s use
    our fictional photo messaging service as an example and assume we''ll start with
    the ability to upload and display media as our first identified business capability.
    This functionality is currently implemented as a single model and controller in
    your **Ruby on Rails** monolith:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别一个目前由你的单体应用提供的业务能力。这将是我们第一个服务的目标。理想情况下，这个业务能力是你之前在食谱中工作的路线图上有所关注的，并且可以分配给你的一个新创建的团队。让我们以我们的虚构照片消息服务为例，并假设我们将从上传和显示媒体的能力作为我们第一个识别的业务能力。这个功能目前作为你的**Ruby
    on Rails**单体应用中的一个单一模型和控制器实现：
- en: '![](img/20a0be37-40db-4825-8f00-684ad75a3153.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20a0be37-40db-4825-8f00-684ad75a3153.png)'
- en: 'In the preceding screenshot, **AttachmentsController** has four methods (called
    **actions** in Ruby on Rails lingo), which roughly correspond to the **create,
    retrieve, update, delete** (**CRUD**) operations you want to perform on an **Attachment**
    resource. We don''t strictly need it, and so will omit the update action. This
    maps very nicely to a RESTful service, so you can design, implement, and deploy
    a microservice with the following API:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，**AttachmentsController**有四个方法（在Ruby on Rails术语中称为**actions**），它们大致对应于你想要在**Attachment**资源上执行的**创建、检索、更新、删除**（**CRUD**）操作。我们并不严格需要它，因此将省略更新操作。这非常适合RESTful服务，因此你可以设计、实现和部署一个具有以下API的微服务：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the new microservice deployed (migrating data is discussed in a later recipe),
    you can now begin modifying client code paths to use the new service. You can
    begin by replacing the code in the **Attachm****entsController** action's methods
    to make an HTTP request to our new microservice. Techniques for doing this are
    covered in the *Evolving your monolith into services* recipe later in this chapter.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着新微服务的部署（迁移数据将在后面的食谱中讨论），你现在可以开始修改客户端代码路径以使用新服务。你可以通过替换**AttachmentsController**动作方法中的代码来开始，使其向我们的新微服务发送HTTP请求。关于如何做到这一点，将在本章后面的**将单体应用演进为服务**食谱中介绍。
- en: Identifying bounded contexts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别边界上下文
- en: When designing microservices, a common point of confusion is how big or small
    a service should be. This confusion can lead engineers to focus on things such
    as the number of lines of code in a particular service. Lines of code are an awful
    metric for measuring software; it's much more useful to focus on the role that
    a service plays, both in terms of the business capability it provides and the
    domain objects it helps manage. We want to design services that have low coupling
    with other services, because this limits what we have to change when introducing
    a new feature in our product or making changes to an existing one. We also want
    to give services a single responsibility.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计微服务时，一个常见的困惑点是服务应该有多大或多小。这种困惑可能导致工程师专注于诸如特定服务中的代码行数等问题。代码行数是衡量软件的一个糟糕指标；更多地关注服务所扮演的角色，无论是从它提供的业务能力还是它帮助管理的领域对象来看，都更有用。我们希望设计与其他服务耦合度低的服务，因为这样可以限制我们在产品中引入新功能或对现有功能进行更改时需要更改的内容。我们还想给服务赋予单一责任。
- en: 'When decomposing a monolith, it''s often useful to look at the data model when
    deciding what services to extract. In our fictional image-messaging application,
    we can imagine the following data model:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当分解单体应用时，在决定要提取哪些服务时查看数据模型通常很有用。在我们的虚构图片消息应用中，我们可以想象以下数据模型：
- en: '![](img/0a20b515-a676-41c2-a20a-50797c9e1a34.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a20b515-a676-41c2-a20a-50797c9e1a34.png)'
- en: We have a table for messages, a table for users, and a table for attachments.
    The **Message** entity has a one-to-many relationship with the **User** entity;
    every user can have many messages that originate from or are targeted at them,
    and every message can have multiple attachments. What happens as the application
    evolves and we add more features? The preceding data model does not include anything
    about social graphs. Let's imagine that we want a user to be able to follow other
    users. We'll define the following as a asymmetric relationship, just because user
    1 follows user 2, that does not mean that user 2 follows user 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个消息表、一个用户表和一个附件表。**消息**实体与**用户**实体有一个一对多的关系；每个用户可以有多个来自或针对他们的消息，每条消息也可以有多个附件。随着应用程序的发展和我们添加更多功能，会发生什么？前面的数据模型没有包含关于社交图谱的任何内容。让我们假设我们想让用户能够关注其他用户。我们将定义以下内容为一个非对称关系，仅仅因为用户1关注用户2，并不意味着用户2也关注用户1。
- en: 'There are a number of ways to model this kind of relationship; we''ll focus
    on one of the simplest, which is an adjacency list. Take a look at the following
    diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式来建模这种关系；我们将关注其中最简单的一种，即邻接表。看看下面的图：
- en: '![](img/f253d211-e168-49f1-b637-410ca096db07.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f253d211-e168-49f1-b637-410ca096db07.png)'
- en: We now have an entity, **Followings**, to represent a follow relationship between
    two users. This works perfectly in our monolith, but introduces a challenge with
    microservices. If we were to build two new services, one to handle attachments,
    and another to handle the social graph (two distinct responsibilities), we now
    have two definitions of the user. This duplication of models is often necessary.
    The alternative is to have multiple services access and make updates to the same
    model, which is extremely brittle and can quickly lead to unreliable code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个实体，**关注者**，用来表示两个用户之间的关注关系。这在我们的单体应用中运行得很好，但在微服务中引入了挑战。如果我们构建两个新的服务，一个处理附件，另一个处理社交图谱（两个不同的职责），我们现在有两个用户定义。这种模型的重复通常是必要的。另一种选择是让多个服务访问和更新同一个模型，这非常脆弱，并且可能导致代码不可靠。
- en: This is where bounded contexts can help. A bounded context is a term from **Domain-Driven
    Design** (**DDD**) and it defines the area of a system within which a particular
    model makes sense. In the preceding example, the social-graph service would have
    a **User** model whose bounded context would be the users social graph (easy enough).
    The media service would have a **User** model whose bounded context would be photos
    and videos. Identifying these bounded contexts is important, especially when deconstructing
    a monolith—you'll often find that as a monolithic code base grows, the previously
    discussed business capabilities (uploading and viewing photos and videos, and
    user relationships) would probably end up sharing the same, bloated **User** model,
    which will then have to be untangled. This can be a tricky but enlightening and
    important process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是边界上下文可以发挥作用的地方。边界上下文是**领域驱动设计**（**DDD**）中的一个术语，它定义了系统中的一个特定模型有意义的区域。在前面的例子中，社交图谱服务将有一个**用户**模型，其边界上下文将是用户的社会图谱（足够简单）。媒体服务将有一个**用户**模型，其边界上下文将是照片和视频。识别这些边界上下文很重要，尤其是在解构单体应用时——你经常会发现，随着单体代码库的增长，之前讨论的业务能力（上传和查看照片和视频，以及用户关系）可能会最终共享同一个庞大而臃肿的**用户**模型，然后就需要解开这个模型。这可能是一个棘手但启发性和重要的过程。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Deciding on how to define bounded contexts within a system can be a rewarding
    endeavor. The process itself encourages teams to have many interesting discussions
    about the models in a system and the various interactions that must happen between
    various systems:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 决定如何在系统中定义边界上下文可以是一项有益的工作。这个过程本身鼓励团队就系统中的模型和各个系统之间必须发生的各种交互进行许多有趣的讨论：
- en: Before a team can start to define the bounded contexts it works with, it should
    first start listing the models that are owned by the parts of the system it works
    on. For example, the media team will obviously own the **Attachment** model, but
    it will also need to have information about users, and messages. The **Attachment**
    model may be entirely maintained within the context of the media teams services,
    but the others will have to have a well-defined bounded context that can be communicated
    to other teams if necessary.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个团队能够开始定义其工作的边界上下文之前，它首先应该开始列出其工作的系统部分所拥有的模型。例如，媒体团队显然拥有**附件**模型，但它还需要了解用户和消息的信息。**附件**模型可能完全在媒体团队服务的上下文中维护，但其他部分将需要有一个定义良好的边界上下文，以便在必要时与其他团队进行沟通。
- en: Once a team has identified potentially shared models, it's a good idea to have
    a discussion with other teams that use similar models or the same model.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦一个团队确定了可能共享的模型，与使用类似模型或相同模型的其它团队进行讨论是个好主意。
- en: In those discussions, hammer out the boundaries of the model and decide whether
    it makes sense to share a model implementation (which in a microservice world
    would necessitate a service-to-service call) or go their separate ways and develop
    and maintain separate model implementations. If the choice is made to develop
    separate model implementations, it'll become important to clearly define the bounded
    context within which the model applies.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些讨论中，明确模型的边界，并决定是否共享模型实现（在微服务世界中这需要服务之间的调用）或者各自发展并维护独立的模型实现。如果选择开发独立的模型实现，那么明确模型应用的边界上下文就变得非常重要。
- en: The team should document clear boundaries in terms of teams, specific parts
    of the application, or specific code bases that should make use of the model.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队应该明确记录关于团队、应用程序的特定部分或特定代码库的模型边界，这些部分或代码库应该使用该模型。
- en: Migrating data in production
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境中的数据迁移
- en: Monolith code bases usually use a primary relational database for persistence.
    Modern web frameworks are often packaged with **object-relational mapping** (**ORM**),
    which allows you to define your domain objects using classes that correspond to
    tables in the database. Instances of these model classes correspond to rows in
    the table. As monolith code bases grow, it's not uncommon to see additional data
    stores, such as document or key value stores, be added.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单体代码库通常使用主关系型数据库进行持久化。现代Web框架通常包含**对象关系映射**（**ORM**），这允许你使用与数据库中的表对应的类来定义你的领域对象。这些模型类的实例对应于表中的行。随着单体代码库的增长，添加额外的数据存储，如文档或键值存储，并不罕见。
- en: Microservices should not share access with the same database your monolith connects
    to. Doing so will inevitably cause problems when trying to coordinate data migrations,
    such as schema changes. Even schema-less stores will cause problems when you change
    the way data is written in one code base but not how data is read in another code
    base. For this and other reasons, it's best to have microservices fully manage
    the data stores they use for persistence.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不应与单体连接到相同数据库共享访问权限。这样做在尝试协调数据迁移，如模式更改时，不可避免地会导致问题。即使是模式无关的存储，当你在某个代码库中更改数据写入方式，但在另一个代码库中不更改数据读取方式时，也会引起问题。出于这些和其他原因，最好让微服务完全管理它们用于持久化的数据存储。
- en: When transitioning from a monolith to microservices, it's important to have
    a strategy for how to migrate data. All too often, a team will extract the code
    for a microservice and leave the data, setting themselves up for future pain.
    In addition to difficulty managing migrations, a failure in the monolith relational
    database will now have cascading impacts on services, leading to difficult-to-debug
    production incidents.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当从单体过渡到微服务时，制定数据迁移策略非常重要。过于频繁地，一个团队会提取微服务的代码，而留下数据，给自己未来的痛苦埋下伏笔。除了管理迁移的困难之外，单体关系型数据库的故障现在将对服务产生级联影响，导致难以调试的生产事件。
- en: One popular technique for managing large-scale data migrations is to set up
    dual writing. When your new service is deployed, you'll have two write paths–one
    from the original monolith code base to its database and one from your new service
    to its own data store. Make sure that writes go to both of these code paths. You'll
    now be replicating data from the moment your new service goes into production,
    allowing you to backfill older data using a script or a similar offline task.
    Once data is being written to both data stores, you can now modify all of your
    various read paths. Wherever the code is used to query the monolith database directly,
    replace the query with a call to your new service. Once all read paths have been
    modified, remove any write paths that are still writing to the old location. Now
    you can delete the old data (you have backups, right?).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 管理大规模数据迁移的一种流行技术是设置双重写入。当你的新服务部署后，你将有两个写入路径——一个是从原始单体代码库到其数据库，另一个是从你的新服务到其自己的数据存储。确保写入同时发送到这两个代码路径。现在你将从新服务投入生产的那一刻开始复制数据，这样你就可以使用脚本或类似的离线任务回填旧数据。一旦数据开始写入两个数据存储，你现在可以修改所有各种读取路径。无论代码在哪里直接查询单体数据库，都将其替换为对新服务的调用。一旦所有读取路径都已修改，删除任何仍然写入旧位置的写入路径。现在你可以删除旧数据（你备份了吗？）。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Migrating data from a monolith database to a new store fronted by a new service,
    without any impact on availability or consistency, is a difficult but common task
    when making the transition to microservices. Using our fictional photo-messaging
    application, we can imagine a scenario where we want to create a new microservice
    responsible for handling media uploads. In this scenario, we''d follow a common
    dual-writing pattern:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从单体数据库迁移到由新服务前端的新存储，而不影响可用性或一致性，在向微服务过渡时是一个困难但常见的任务。使用我们虚构的图片消息应用，我们可以想象一个场景，其中我们想要创建一个新的微服务来处理媒体上传。在这个场景中，我们会遵循一个常见的双重写入模式：
- en: 'Before writing a new service to handle media uploads, we''ll assume that the
    monolith architecture looks something like the following diagram, where HTTP requests
    are being handled by the monolith, which presumably reads the multipart/form-encoded
    content body as a binary object and stores the file in a distributed file store
    (Amazon''s S3 service, for example). Metadata about the file is then written to
    a database table, called **attachments**, as shown in the following diagram:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写用于处理媒体上传的新服务之前，我们假设单体架构看起来像以下图示，其中HTTP请求由单体处理，它可能将multipart/form-encoded的内容体作为二进制对象读取，并将文件存储在分布式文件存储中（例如亚马逊的S3服务）。然后，文件的相关元数据被写入一个名为**附件**的数据库表，如图所示：
- en: '![](img/60bd0c1d-4d04-4079-81ea-c976d3d5d6e2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/60bd0c1d-4d04-4079-81ea-c976d3d5d6e2.png)'
- en: 'After writing a new service, you now have two write paths. In the write path
    in the monolith, make a call to your service so that you''re replicating the data
    in the monolith database as well as the database fronted by your new service.
    You''re now duplicating new data and can write a script to backfill older data.
    Your architecture now looks something like this:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写新服务后，你现在有两个写入路径。在单体中的写入路径中，调用你的服务以复制单体数据库以及由你的新服务前端的数据存储中的数据。你现在正在复制新数据，可以编写脚本回填旧数据。你的架构现在看起来像这样：
- en: '![](img/3bc1de53-10b7-4ef0-b705-2965a33c3efb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/3bc1de53-10b7-4ef0-b705-2965a33c3efb.png)'
- en: Find all read paths in your **Client** and **Monolith** code, and update them
    to use your new service. All reads will now be going to your service, which will
    be able to give consistent results.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的**客户端**和**单体**代码中找到所有读取路径，并将它们更新为使用你的新服务。所有读取现在都将发送到你的服务，这将能够提供一致的结果。
- en: 'Find all write paths in your **Client** and **Monolith** code, and update them
    to use your new service. All reads and writes are now going to your service, and
    you can safely delete old data and code paths. Your final architecture should
    look something like the following (we''ll discuss edge proxies in later chapters):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的**客户端**和**单体**代码中找到所有写入路径，并将它们更新为使用你的新服务。所有读取和写入现在都将发送到你的服务，你可以安全地删除旧数据和相关代码路径。你的最终架构应该看起来像以下这样（我们将在后面的章节中讨论边缘代理）：
- en: '![](img/79342aca-e866-4530-a8bf-1efbc114461c.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/79342aca-e866-4530-a8bf-1efbc114461c.png)'
- en: Using this approach, you'll be able to safely migrate data from a monolith database
    to a new store created for a new microservice without the need for downtime. It's
    important not to skip this step; otherwise, you won't truly realize the benefits
    of microservice architectures (although, arguably, you'll experience all the downsides!).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你将能够安全地将数据从单体数据库迁移到为新的微服务创建的新存储中，而无需停机。跳过这一步是很重要的；否则，你将无法真正实现微服务架构的好处（尽管，可以说，你将体验到所有弊端！）。
- en: Refactoring your monolith
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构单体架构
- en: A common mistake when making the transition to microservices is to ignore the
    monolith and just build new features as services. This usually happens when a
    team feels that the monolith has gotten so out of control, and the code so unwieldy,
    that it would be better to declare bankruptcy and leave it to rot. This can be
    especially tempting because the idea of building green field code with no legacy
    baggage sounds a lot nicer than refactoring brittle, legacy code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在向微服务过渡时，一个常见的错误是忽略单体，只是作为服务构建新功能。这通常发生在团队觉得单体已经失控，代码难以控制，最好是宣布破产并让它腐烂的时候。这特别诱人，因为构建没有遗留负担的绿色代码的想法听起来比重构脆弱的遗留代码要好得多。
- en: Resist the temptation to abandon your monolith. To successfully decompose your
    monolith by business capability and start evolving it into a set of nicely factored,
    single-responsibility microservices, you'll need to make sure that your monolith
    code base is in good shape and is well factored, and well tested. Otherwise, you'll
    end up with a proliferation of new services that don't model your domain cleanly
    (because they overlap with functionality in the monolith), and you'll continue
    to have trouble working with any code that exists in your monolith. Your users
    won't be happy and your teams' energy will most likely start to decline as the
    weight of technical debt becomes unbearable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 抵制放弃单体架构的诱惑。为了通过业务能力成功地将单体架构分解，并开始将其演进为一组结构良好、单一职责的微服务，你需要确保你的单体代码库处于良好状态，并且结构良好、经过充分测试。否则，你将面临新服务的激增，这些服务无法干净地建模你的领域（因为它们与单体中的功能重叠），并且你将继续在与单体中存在的任何代码打交道时遇到麻烦。你的用户不会满意，而且随着技术债务的负担变得难以承受，你团队的精力很可能会开始下降。
- en: Instead, take constant, proactive steps to refactor your monolith using good,
    solid design principles. Excellent books have been written on the subject of refactoring
    (I recommend *Refactoring* by Martin Fowler and *Working Effectively with Legacy
    Code* by Michael Feathers), but the most important thing to know is that refactoring
    is never an all-or-nothing effort. Few product teams or companies will have the
    patience or luxury to wait while an engineering team stops the world and spends
    time making their code easier to change, and an engineering team that tries this
    will rarely be successful. Refactoring has to be a constant, steady process.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，采取持续、积极的步骤，使用良好的、稳固的设计原则来重构你的单体架构。已经有许多关于重构的书籍（我推荐马丁·福勒的《重构》和迈克尔·费瑟斯的《与遗留代码有效工作》），但最重要的是要知道，重构永远不是全有或全无的努力。很少有产品团队或公司有耐心或奢侈的时间等待工程团队停止世界并花费时间使代码更容易更改，而尝试这样做的工程团队很少会成功。重构必须是一个持续、稳定的过程。
- en: However your team schedules its work, make sure you're reserving an appropriate
    time for refactoring. A guiding principle is, whenever you go to make a change,
    first make the change easy to make, then make the change. Your goal is to make
    your monolith code easier to work with, easier to understand, and less brittle.
    You should also be able to develop a robust test suite that will come in handy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的团队如何安排工作，确保你为重构预留了适当的时间。一个指导原则是，每次你打算进行更改时，首先使更改变得容易进行，然后再进行更改。你的目标是使单体代码更容易工作、更容易理解，并且更不易破碎。你还应该能够开发出一个健壮的测试套件，这将非常有用。
- en: Once your monolith is in better shape, you can start to continuously shrink
    the monolith as you factor out services. Another aspect of most monolith code
    bases is serving dynamically generated views and static assets served through
    browsers. If your monolith is responsible for this, consider moving your web application
    component into a separately served JavaScript application. This will allow you
    to shrink your monolith from multiple directions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的单体应用处于更好的状态时，你可以开始连续缩小单体应用，同时提取服务。大多数单体代码库的另一个方面是服务于通过浏览器提供的动态生成的视图和静态资源。如果你的单体应用负责这项工作，考虑将你的Web应用程序组件移动到一个单独提供的JavaScript应用程序中。这将允许你从多个方向缩小单体应用。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Refactoring any code base is a process. For monoliths, there are a few techniques
    that can work quite well. In this example, we''ll document the steps that can
    be taken to make refactoring a Ruby on Rails code base easy:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码库的重构都是一个过程。对于单体应用，有一些技术可以非常有效。在这个例子中，我们将记录可以采取的步骤，使Ruby on Rails代码库的重构变得容易：
- en: Using the techniques described in previous recipes, identify business capabilities
    and bounded contexts within your application. Let's focus on the ability to upload
    pictures and videos.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面菜谱中描述的技术，在你的应用程序中识别业务能力和边界上下文。让我们专注于上传图片和视频的能力。
- en: Create a directory called `app/services` alongside `controllers`, `models`,
    and `views`. This directory will hold all of your service objects. Service objects
    are a pattern used in many Rails applications to factor out a conceptual service
    into a ruby object that does not inherit any Ruby on Rails functionality. This
    will make it easier to move the functionality encapsulated within a service object
    into a separate microservice. There is no one way to structure your service objects.
    I prefer to have each object represent a service, and move operations I want that
    service to be responsible for to that service object as methods.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controllers`、`models`和`views`旁边创建一个名为`app/services`的目录。这个目录将包含你所有的服务对象。服务对象是许多Rails应用程序中用来将概念服务分解为一个Ruby对象的模式，该对象不继承任何Ruby
    on Rails功能。这将使将封装在服务对象中的功能移动到单独的微服务变得更容易。你的服务对象的结构没有一种固定的方式。我更喜欢让每个对象代表一个服务，并将我希望该服务负责的操作移动到该服务对象作为方法。
- en: 'Create a new file called `attachments_service.rb` under `app/services` and
    give it the following definition:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/services`目录下创建一个名为`attachments_service.rb`的新文件，并给它以下定义：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking at the source code for the `AttachmentsController#create` method in
    the `app/controllers/attachments_controller.rb` file, it currently handles the
    responsibility for creating the `Attachment` instance and uploading the file data
    to the attachment store, which in this case is an Amazon S3 bucket. This is the
    functionality that we need to move to the newly created service object:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`app/controllers/attachments_controller.rb`文件中`AttachmentsController#create`方法的源代码，它目前负责创建`Attachment`实例并将文件数据上传到附件存储，在这个例子中是一个Amazon
    S3存储桶。这是我们需要转移到新创建的服务对象的功能：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the newly created service object in the `app/services/attachments_service.rb` file
    and move the responsibility for uploading the file to the `AttachmentsService#upload`
    method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/services/attachments_service.rb`文件中打开新创建的服务对象，并将上传文件的责任转移到`AttachmentsService#upload`方法：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now upload the `AttachmentsController#create` method in `app/controllers/attachments_controller.rb`
    to use the newly created `AttachmentsService#upload` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`app/controllers/attachments_controller.rb`中的`AttachmentsController#create`方法上传，以使用新创建的`AttachmentsService#upload`方法：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Repeat this process for code in the `AttachmentsController#destroy` method,
    moving the responsibility to the new service object. When you're finished, no
    code in `AttachmentsController` should be interacting with the `Attachments` model
    directly; instead, it should be going through the `AttachmentsService` service
    object.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`AttachmentsController#destroy`方法中的代码重复此过程，将责任转移到新的服务对象。当你完成时，`AttachmentsController`中的代码不应直接与`Attachments`模型交互；相反，它应该通过`AttachmentsService`服务对象进行交互。
- en: You've now isolated responsibility for the management of attachments to a single
    service class. This class should encapsulate all of the business logic that will
    eventually be moved to a new attachment service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经将附件管理的责任隔离到单个服务类中。这个类应该封装所有最终将转移到新附件服务中的业务逻辑。
- en: Evolving your monolith into services
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单体应用演化成服务
- en: One of the most complicated aspects of transitioning from a monolith to services
    can be request routing. In later recipes and chapters, we'll explore the topic
    of exposing your services to the internet so that the mobile and web client applications
    can communicate directly with them. For now, however, having your monolith act
    as a router can serve as a useful intermediary step.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体应用过渡到服务时最复杂的方面之一可能是请求路由。在后面的菜谱和章节中，我们将探讨将你的服务暴露给互联网的话题，以便移动和Web客户端应用可以直接与它们通信。然而，目前，让你的单体应用充当路由器可以作为有用的中间步骤。
- en: As you break your monolith into small, maintainable microservices, you can replace
    code paths in your monolith with calls to your services. Depending on the programming
    language or framework you used to build your monolith, these sections of code
    can be called controller actions, views, or something else. We'll continue to
    assume that your monolith was built in the popular Ruby on Rails framework; in
    which case, we'll be looking at controller actions. We'll also assume that you've
    begun refactoring your monolith and have created one or more service objects as
    described in the previous recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将单体应用拆分成小型、可维护的微服务时，你可以用对服务的调用替换单体应用中的代码路径。根据你用来构建单体应用的编程语言或框架，这些代码段可以被称为控制器操作、视图或其他。我们将继续假设你的单体应用是用流行的
    Ruby on Rails 框架构建的；在这种情况下，我们将查看控制器操作。我们还将假设你已经开始了重构单体应用，并已根据前一个菜谱创建了零个或多个服务对象。
- en: It's important when doing this to follow best practices. In later chapters,
    we'll introduce concepts, such as circuit breakers, that become important when
    doing service-to-service communication. For now, be mindful that HTTP calls from
    your monolith to a service could fail, and you should consider how best to handle
    that kind of situation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这项工作时，遵循最佳实践非常重要。在后面的章节中，我们将介绍电路断路器等概念，这些概念在服务间通信时变得很重要。目前，请注意，从你的单体应用到服务的HTTP调用可能会失败，你应该考虑如何最好地处理这种情况。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Open the service object we created in the previous recipe. We''ll modify the
    service object to be able to call an external microservice responsible for managing
    attachments. For the sake of simplicity, we''ll use an HTTP client that is provided
    in the Ruby standard library. The service object should be in the `app/services/attachments_service.rb` file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在前一个菜谱中创建的服务对象。我们将修改服务对象，使其能够调用一个负责管理附件的外部微服务。为了简化，我们将使用Ruby标准库中提供的HTTP客户端。服务对象应在`app/services/attachments_service.rb`文件中：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the `attachments_controller.rb` file, located in `pichat/app/controllers/`,
    and look at the following create action. Because of the refactoring work done
    in the previous chapter, we require only a small change to make the controller
    work with our new service object:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`pichat/app/controllers/`的`attachments_controller.rb`文件，查看以下创建操作。由于前一章中进行的重构工作，我们只需要进行少量更改，使控制器与我们的新服务对象一起工作：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Evolving your test suite
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试套件的演进
- en: Having a good test suite in the first place will help tremendously as you move
    from a monolith to microservices. Each time you remove functionality from your
    monolith code base, your tests will need to be updated. It's tempting to replace
    unit and functional tests in your Rails app with tests that make external network
    calls to your services, but this approach has a number of downsides. Tests that
    make external calls will be prone to failures caused by intermittent network connectivity
    issues and will take an enormous amount of time to run after a while.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始就拥有良好的测试套件将极大地帮助你从单体应用过渡到微服务。每次你从单体代码库中移除功能时，你的测试都需要更新。用使外部网络调用到你的服务的测试替换Rails应用中的单元和功能测试可能很有诱惑力，但这种方法有许多缺点。进行外部调用的测试可能会因为间歇性网络连接问题而失败，并且经过一段时间后运行时间会非常长。
- en: Instead of making external network calls, you should modify your monolith tests
    to stub microservices. Tests that use stubs to represent calls to microservices
    will be less brittle and will run faster. As long as your microservices satisfy
    the API contracts you develop, the tests will be reliable indicators of your monolith
    code base's health. Making backwards-incompatible changes to your microservices
    is another topic that will be covered in a later recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `webmock` gem for stubbing out external HTTP requests in our
    tests, so update your monolith gemfile to include the `webmock` gem in the test
    group:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should also update `spec/spec_helper.rb` to disable external network requests.
    That will keep you honest when writing the rest of your test code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have `webmock` included in your project, you can start stubbing
    HTTP requests in your specs. Once again, open `specs/spec_helper.rb` and add the
    following content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using Docker for local development
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've discussed, microservices solve a particular set of problems but introduce
    some new challenges of their own. One challenge that engineers on your team will
    probably run into is doing local development. With a monolith, there are fewer
    moving parts that have to be managed—usually, you can get away with just running
    a database and an application server on your workstation to get work done. As
    you start to create new microservices, however, the situation gets more complicated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a great way to manage this complexity. Docker is a popular, open
    source software containerization platform. Docker allows you to specify how to
    run your application as a container—a lightweight standardized unit for deployment.
    There are plenty of books and online documentation about Docker, so we won't go
    into too much detail here, just know that a container encapsulates all of the
    information needed to run your application. As mentioned, a monolith application
    will often require an application server and a database server at a minimum—these
    will each run in their own container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Compose** is a tool for running multicontainer applications. Compose
    allows you to define your applications containers in a YAML configuration file.
    Using the information in this file, you can then build and run your application.
    Compose will manage all of the various services defined in the configuration file
    in separate containers, allowing you to run a complex system on your workstation
    for local development.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can follow the steps in this recipe, you''ll need to install the
    required software:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker. Download the installation package from the Docker website ([https://www.docker.com/docker-mac](https://www.docker.com/docker-mac))
    and follow the instructions.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `docker-compose` by executing the following command line on macOS X:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On Ubuntu Linux, you can execute the following command line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With those two packages installed, you'll be ready to follow the steps in this
    recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the root directory of your Rails application, create a single file called
    `Dockerfile` with the following contents:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a file called `docker-compose.yml` with the following contents:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Start your application by running the `docker-compose up app` command. You should
    be able to access your monolith by entering `http://localhost:3000/` in your browser.
    You can use this approach for new services that you write.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing requests to services
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous recipes, we focused on having your monolith route requests to services.
    This technique is a good start since it requires no client changes to work. Your
    clients still make requests to your monolith and your monolith marshals the request
    to your microservices through its controller actions. At some point, however,
    to truly benefit from a microservices architecture, you'll want to remove the
    monolith from the critical path and allow your clients to make requests to your
    microservices. It's not uncommon for an engineer to expose their organization's
    first microservice to the internet directly, usually using a different hostname.
    However, this starts to become unmanageable as you develop more services and need
    a certain amount of consistency when it comes to monitoring, security, and reliability
    concerns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Internet-facing systems face a number of challenges. They need to be able to
    handle a number of security concerns, rate limiting, periodic spikes in traffic,
    and so on. Doing this for each service you expose to the public internet will
    become very expensive, very quickly. Instead, you should consider having a single
    edge service that supports routing requests from the public internet to internal
    services. A good edge service should support common features, such as dynamic
    path rewriting, load shedding, and authentication. Luckily, there are a number
    of good open source edge service solutions. In this recipe, we'll use a Netflix
    project called **Zuul**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new Spring Boot service called `Edge Proxy` with a main class called
    `EdgeProxyApplication`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spring Cloud includes an embedded Zuul proxy. Enable it by adding the `@EnableZuulProxy`
    annotation to your `EdgeProxyApplication` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a file called `application.properties` under `src/main/resources/` with
    the following contents:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, it tells `zuul` to route requests to `/media` to a service
    running on port `8090`. We'll touch on that `eureka` option in later chapters
    when we discuss service discovery, for now just make sure it's set to `false`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your service should be able to proxy requests to the appropriate
    service. You've just taken one of the biggest steps toward building a microservices
    architecture. Congratulations!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
