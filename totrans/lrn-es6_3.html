<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Using Iterators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using Iterators</h1></div></div></div><p>ES6 introduces new object interfaces and loops for iteration. The addition of the new iteration protocols opens up a new world of algorithms and abilities for JavaScript. We will start the chapter by introducing the symbols and various properties of the <code class="literal">Symbol</code> object. We will also learn how the execution stacks are created for the nested function calls, their impacts, and how to optimize their performance and memory usage.</p><p>Although symbols are a separate topic to iterators, we will still be covering symbols in this chapter because to implement the iterable protocol, you need to use symbols.</p><p>In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using symbols as the object property keys</li><li class="listitem" style="list-style-type: disc">Implementing the iteration protocols in the objects</li><li class="listitem" style="list-style-type: disc">Creating and using the generator objects</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">for…of</code> loop for iterating</li><li class="listitem" style="list-style-type: disc">The tail call optimization</li></ul></div><div class="section" title="The ES6 symbols"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>The ES6 symbols</h1></div></div></div><p>ES6 symbols<a id="id194" class="indexterm"/> are the new primitive type introduced in ES6. A symbol is a unique and immutable value. Here is an example code, which shows how to create a symbol:</p><div class="informalexample"><pre class="programlisting">var s = Symbol();</pre></div><p>Symbols don't have a literal form; therefore, we need to use the <code class="literal">Symbol()</code> function to create a symbol. The <code class="literal">Symbol()</code> function returns a unique symbol every time it is called.</p><p>The <code class="literal">Symbol()</code> function<a id="id195" class="indexterm"/> takes an optional string parameter that represents the description of the symbol. A description of a symbol can be used for debugging, but not to access the symbol itself. Two symbols with the same description are not equal at all. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let s1 = window.Symbol("My Symbol");
let s2 = window.Symbol("My Symbol");

console.log(s1 === s2); //Output is "false"</pre></div><p>From the <a id="id196" class="indexterm"/>preceding example, we can also say that a symbol is a <span class="emphasis"><em>string-like</em></span> value that can't collide with any other value.</p><div class="section" title="The &quot;typeof&quot; operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>The "typeof" operator</h2></div></div></div><p>The <code class="literal">typeof</code> operator <a id="id197" class="indexterm"/>outputs <code class="literal">"symbol"</code> when applied on a variable, holding <a id="id198" class="indexterm"/>a symbol. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">var s = Symbol();
console.log(typeof s); //Output "symbol"</pre></div><p>Using the <code class="literal">typeof</code> operator is the only way to identify whether a variable is holding a symbol.</p></div><div class="section" title="The &quot;new&quot; operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>The "new" operator</h2></div></div></div><p>You cannot apply <a id="id199" class="indexterm"/>the <code class="literal">new</code> operator<a id="id200" class="indexterm"/> on the <code class="literal">Symbol()</code> function. The <code class="literal">Symbol()</code> function detects if it's being used as an constructor, and if <code class="literal">true</code>, it then throws an exception. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">try
{
  let s = new Symbol(); //"TypeError" exception
}
catch(e)
{
  console.log(e.message); //Output "Symbol is not a constructor"
}</pre></div><p>But the JavaScript engine can internally use the <code class="literal">Symbol()</code> function as an constructor to wrap a symbol in an object. Therefore, "<code class="literal">s</code>" will be equal to <code class="literal">Object(s)</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>All the primitive types that are introduced from ES6 onwards will not allow their constructors to be invoked manually.</p></div></div></div><div class="section" title="Using symbols as property keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Using symbols as property keys</h2></div></div></div><p>Till ES5, the<a id="id201" class="indexterm"/> JavaScript object property keys had to be<a id="id202" class="indexterm"/> string type. But in ES6, the JavaScript object property keys can be strings or symbols. Here is an example that demonstrates how to use a symbol as an object property key:</p><div class="informalexample"><pre class="programlisting">let obj = null;
let s1 = null;

(function(){
  let s2 = Symbol();
  s1 = s2;
  obj = {[s2]: "mySymbol"}
  console.log(obj[s2]);
  console.log(obj[s2] == obj[s1]);
})();

console.log(obj[s1]);</pre></div><p>The output is:</p><div class="informalexample"><pre class="programlisting">mySymbol
true
mySymbol</pre></div><p>From the preceding code, you can see that in order to create or retrieve a property key using symbols, you need to use the <code class="literal">[]</code> token. We saw the <code class="literal">[]</code> token while discussing the computed property names in <a class="link" href="ch02.html" title="Chapter 2. Knowing Your Library">Chapter 2</a>, <span class="emphasis"><em>Knowing Your Library</em></span>.</p><p>To access a<a id="id203" class="indexterm"/> symbol property key, we need the symbol. In the <a id="id204" class="indexterm"/>previous example, both <code class="literal">s1</code> and <code class="literal">s2</code> hold the same symbol value.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The primary reason for introducing symbols in ES6 was so that it can be used as a key for object property, and prevent the accidental collision of the property keys.</p></div></div></div><div class="section" title="The Object.getOwnPropertySymbols() method"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>The Object.getOwnPropertySymbols() method</h2></div></div></div><p>The <code class="literal">Object.getOwnPropertyNames()</code> method <a id="id205" class="indexterm"/>cannot retrieve<a id="id206" class="indexterm"/> the symbol properties. Therefore, ES6 introduced <code class="literal">Object.getOwnPropertySymbols()</code> to retrieve an array of symbol properties of an object. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let obj = {a: 12};
let s1 = Symbol("mySymbol");
let s2 = Symbol("mySymbol");

Object.defineProperty(obj, s1, {
  enumerable: false
});

obj[s2] = "";

console.log(Object.getOwnPropertySymbols(obj));</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Symbol(mySymbol),Symbol(mySymbol)</pre></div><p>From the previous <a id="id207" class="indexterm"/>example, you can see that <a id="id208" class="indexterm"/>the <code class="literal">Object.getOwnPropertySymbols()</code> method can also retrieve the non-enumerable symbol properties.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The <code class="literal">in</code> operator can find the symbol properties in an object, whereas the <code class="literal">for…in</code> loop and <code class="literal">Object.getOwnPropertyNames()</code> cannot find the symbol properties in an object for the sake of backward compatibility.</p></div></div></div><div class="section" title="The Symbol.for(string) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/>The Symbol.for(string) method</h2></div></div></div><p>The <code class="literal">Symbol</code> object<a id="id209" class="indexterm"/> maintains a registry of the key/value pairs, where<a id="id210" class="indexterm"/> the key is the symbol description, and the value is the symbol. Whenever we create a symbol using the <code class="literal">Symbol.for()</code> method, it gets added to the registry and the method returns the symbol. If we try to create a symbol with a description that already exists, then the existing symbol will be retrieved.</p><p>The advantage of using the <code class="literal">Symbol.for()</code> method instead of the <code class="literal">Symbol()</code> method to create symbols is that while using the <code class="literal">Symbol.for()</code> method, you don't have to worry about making the symbol available globally, because its always available globally. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let obj = {};

(function(){
  let s1 = Symbol("name");
  obj[s1] = "Eden";
})();

//obj[s1] cannot be accessed here

(function(){
  let s2 = Symbol.for("age");
  obj[s2] = 27;
})();

console.log(obj[Symbol.for("age")]); //Output "27"</pre></div></div><div class="section" title="The well-known symbols"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>The well-known symbols</h2></div></div></div><p>In addition to your<a id="id211" class="indexterm"/> own symbols, ES6 comes up with a built-in set of symbols, known as the <span class="strong"><strong>well-known</strong></span> symbols. Here is a list of properties, referencing some important built-in symbols:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.iterator</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.match</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.search</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.replace</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.split</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.hasInstance</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.species</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.unscopables</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.isContcatSpreadable</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.toPrimitive</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Symbol.toStringTag</code></li></ul></div><p>You will come across the use of these symbols in various chapters of this book.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>While referring to the well-known symbols in the text, we usually prefix them using the <code class="literal">@@</code> notation. For example, the <code class="literal">Symbol.iterator</code> symbol is referred to as the <code class="literal">@@iterator</code> method. This is done to make it easier to refer to the well-known symbols in the text.</p></div></div></div></div></div>
<div class="section" title="The iteration protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>The iteration protocols</h1></div></div></div><p>An iteration protocol<a id="id212" class="indexterm"/> is a set of rules that an object needs to follow for implementing the interface, which when used, a loop or a construct can iterate over a group of values of the object.</p><p>ES6 introduces two new iteration protocols known as the<a id="id213" class="indexterm"/> <span class="strong"><strong>iterable protocol</strong></span>, and the iterator protocol.</p><div class="section" title="The iterator protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>The iterator protocol</h2></div></div></div><p>Any object <a id="id214" class="indexterm"/>that implements the iterator protocol is known as an <a id="id215" class="indexterm"/>iterator. According to the iterator protocol, an object needs to provide a <code class="literal">next()</code> method that returns the next item in the sequence of a group of items.</p><p>Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let obj = {
  array: [1, 2, 3, 4, 5],
  nextIndex: 0,
  next: function(){
    return this.nextIndex &lt; this.array.length ?
    {value: this.array[this.nextIndex++], done: false} :
    {done: true};
  }
};

console.log(obj.next().value);
console.log(obj.next().value);
console.log(obj.next().value);
console.log(obj.next().value);
console.log(obj.next().value);
console.log(obj.next().done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
2
3
4
5
true</pre></div><p>Every time the <code class="literal">next()</code> method is called, it returns an object with two properties: <code class="literal">value</code> and <code class="literal">done</code>. Let's see what these two properties represent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">done</code> property: This returns <code class="literal">true</code> if the iterator has finished iterating over the collection of values. Otherwise, this returns as <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">value</code> property: This holds the value of the current item in the collection. It is omitted when the <code class="literal">done</code> property is <code class="literal">true</code>.</li></ul></div></div><div class="section" title="The iterable protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>The iterable protocol</h2></div></div></div><p>Any object that<a id="id216" class="indexterm"/> implements the iterable protocol is known as an <a id="id217" class="indexterm"/>iterable. According to the iterable protocol, an object needs to provide the <code class="literal">@@iterator</code> method; that is, it must have the <code class="literal">Symbol.iterator</code> symbol as a property key. The <code class="literal">@@iterator</code> method must return an iterator object.</p><p>Here is an example <a id="id218" class="indexterm"/>to <a id="id219" class="indexterm"/>demonstrate this:</p><div class="informalexample"><pre class="programlisting">let obj = {
  array: [1, 2, 3, 4, 5],
  nextIndex: 0,
  [Symbol.iterator]: function(){
    return {
      array: this.array,
      nextIndex: this.nextIndex,
      next: function(){
        return this.nextIndex &lt; this.array.length ?
        {value: this.array[this.nextIndex++], done: false} :
        {done: true};
      }
    }
  }
};

let iterable = obj[Symbol.iterator]()

console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
2
3
4
5
true</pre></div></div></div>
<div class="section" title="Generators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Generators</h1></div></div></div><p>A generator function is like <a id="id220" class="indexterm"/>a normal function, but instead of returning a single value, it returns multiple values one by one. Calling a generator function doesn't execute its body immediately, but rather returns a new instance of the generator object (that is, an object that implements both, iterable and iterator protocols).</p><p>Every generator object holds a new execution context of the generator function. When we execute the <code class="literal">next()</code> method of the generator object, it executes the generator function's body until the <code class="literal">yield</code> keyword is encountered. It returns the yielded value, and pauses the function. When the <code class="literal">next()</code> method is called again, it resumes the execution, and then returns the next yielded value. The <code class="literal">done</code> property is true when the generator function doesn't yield any more value.</p><p>A generator <a id="id221" class="indexterm"/>function is written using the <code class="literal">function*</code> expression. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function* generator_function()
{
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
}

let generator = generator_function();

console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().done);

generator = generator_function();

let iterable = generator[Symbol.iterator]();

console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().value);
console.log(iterable.next().done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
2
3
4
5
true
1
2
3
4
5
true</pre></div><p>There is an expression following the <code class="literal">yield</code> keyword. The value of the expression is what returned by the generator function via the iterable protocol. If we omit the expression, then <code class="literal">undefined</code> is returned. The value of the expression is what we call as the yielded value.</p><p>We can also <a id="id222" class="indexterm"/>pass an optional argument to the <code class="literal">next()</code> method. This argument becomes the value returned by the <code class="literal">yield</code> statement, where the generator function is currently paused. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function* generator_function()
{
  var a = yield 12;
  var b = yield a + 1;
  var c = yield b + 2;
  yield c + 3;
}

var generator = generator_function();

console.log(generator.next().value);
console.log(generator.next(5).value);
console.log(generator.next(11).value);
console.log(generator.next(78).value);
console.log(generator.next().done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">12
6
13
81
true</pre></div><div class="section" title="The return(value) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>The return(value) method</h2></div></div></div><p>You can <a id="id223" class="indexterm"/>anytime end a generator function before it has yielded all the <a id="id224" class="indexterm"/>values using the <code class="literal">return()</code> method of the generator object. The <code class="literal">return()</code> method takes an optional argument, representing the final value to return.</p><p>Here is an <a id="id225" class="indexterm"/>example <a id="id226" class="indexterm"/>demonstrating this:</p><div class="informalexample"><pre class="programlisting">function* generator_function()
{
  yield 1;
  yield 2;
  yield 3;
}

var generator = generator_function();

console.log(generator.next().value);
console.log(generator.return(22).value);
console.log(generator.next().done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
22
true</pre></div></div><div class="section" title="The throw(exception) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>The throw(exception) method</h2></div></div></div><p>You can manually <a id="id227" class="indexterm"/>trigger an exception inside a generator <a id="id228" class="indexterm"/>function using the <code class="literal">throw()</code> method of the generator object. You must pass an exception to the <code class="literal">throw()</code> method that you want to throw. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function* generator_function()
{

  try
  {
    yield 1;
  }
  catch(e)
  {
    console.log("1st Exception");
  }

  try
  {
    yield 2;
  }
  catch(e)
  {
    console.log("2nd Exception");
  }

}

var generator = generator_function();

console.log(generator.next().value);
console.log(generator.throw("exception string").value);
console.log(generator.throw("exception string").done);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
1st Exception
2
2nd Exception
true</pre></div><p>In the preceding<a id="id229" class="indexterm"/> example, you can see that the exception is <a id="id230" class="indexterm"/>thrown where the function was paused the last time. After the exception is handled, the <code class="literal">throw()</code> method continuous execution, and returns the next yielded value.</p></div><div class="section" title="The &quot;yield*&quot; keyword"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>The "yield*" keyword</h2></div></div></div><p>The <code class="literal">yield*</code> keyword<a id="id231" class="indexterm"/> inside a<a id="id232" class="indexterm"/> generator function takes an iterable object as the expression and iterates it to yield its values. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function* generator_function_1()
{
  yield 2;
  yield 3;
}

function* generator_function_2()
{
  yield 1;
  yield* generator_function_1();
  yield* [4, 5];
}

var generator = generator_function_2();

console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().done);</pre></div><p>The <a id="id233" class="indexterm"/>output is as<a id="id234" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">1
2
3
4
5
true</pre></div></div></div>
<div class="section" title="The &quot;for&#x2026;of&quot; loop"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>The "for…of" loop</h1></div></div></div><p>Until now, we were<a id="id235" class="indexterm"/> iterating over an iterable object using the <code class="literal">next()</code> method, which<a id="id236" class="indexterm"/> is a cumbersome task. ES6 introduced the <code class="literal">for…of</code> loop to make this task easier.</p><p>The <code class="literal">for…of</code> loop was introduced to iterate over the values of an iterable object. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function* generator_function()
{
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
}

let arr = [1, 2, 3];

for(let value of generator_function())
{
  console.log(value);
}

for(let value of arr)
{
  console.log(value);
}</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
2
3
4
5
1
2
3</pre></div></div>
<div class="section" title="The tail call optimization"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>The tail call optimization</h1></div></div></div><p>Whenever a function<a id="id237" class="indexterm"/> call is made, an execution stack is created in the stack memory to store the variables of the function.</p><p>When a function call is made inside another function call, a new execution stack is created for the inner function call. But the problem is that the inner function execution stack takes up some extra memory, that is, it stores an extra address, representing where to resume the execution when this function finishes executing. Switching and creating the execution stacks also takes some additional CPU time. This problem is not noticeable when there are a couple or hundreds of nested levels of calls, but it's noticeable when there are thousands or more of the nested levels of calls, that is, the JavaScript engines throw the <code class="literal">RangeError: Maximum call stack size exceeded</code> exception. You might have, at some point, experienced the <code class="literal">RangeError</code> exception while creating a recursive function.</p><p>A <span class="strong"><strong>tail call</strong></span> <a id="id238" class="indexterm"/>is a function call, performed optionally at the very end of a function with the <code class="literal">return</code> statement. If a tail call leads to the same function call again and again, then it's called as a <a id="id239" class="indexterm"/>
<span class="strong"><strong>tail-recursion</strong></span>, which is a special case of recursion. What's special about tail calls is that there is a way to actually prevent the extra CPU-time and memory usage while making the tail calls, which is to reuse the stack of the out function, instead of creating a new execution stack thereby saving the CPU time and the extra memory usage. Reusing the execution stack while making a tail call is called as the <span class="strong"><strong>tail call optimization</strong></span>.</p><p>ES6 adds the support for a tail call optimization if the script is written in the <code class="literal">"use</code> <code class="literal">strict"</code> mode. Let's see an example of a tail call:</p><div class="informalexample"><pre class="programlisting">"use strict";

function _add(x, y)
{
  return x + y;
}

function add1(x, y)
{
  x = parseInt(x);
  y = parseInt(y);

  //tail call
  return _add(x, y);
}

function add2(x, y)
{
  x = parseInt(x);
  y = parseInt(y);

  //not tail call
  return 0 + _add(x, y);
}

console.log(add1(1, '1')); //2
console.log(add2(1, '2')); //3</pre></div><p>Here, the <code class="literal">_add()</code> call in the <code class="literal">add1()</code> function is a tail call, as it's the final action of the <code class="literal">add1()</code> function. But the <code class="literal">_add()</code> call in the <code class="literal">add2()</code> function is not a tail call, as it's not the final action, which is adding <code class="literal">0</code> to the result of <code class="literal">_add()</code> is the final action.</p><p>The <code class="literal">_add()</code> call in <code class="literal">add1()</code> doesn't create a new execution stack. Instead, it reuses the <code class="literal">add1()</code> function's execution stack; in other words, the tail call optimization occurs.</p><div class="section" title="Converting the non-tail calls into the tail calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Converting the non-tail calls into the tail calls</h2></div></div></div><p>As the tail calls are<a id="id240" class="indexterm"/> optimized, you must use the tail calls <a id="id241" class="indexterm"/>whenever possible, instead of the non-tail calls. You can optimize your code by converting the non-tail calls into the tail calls.</p><p>Let's see an example of converting a non-tail call into a tail call, which is similar to the previous:</p><div class="informalexample"><pre class="programlisting">"use strict";

function _add(x, y)
{
  return x + y;
}

function add(x, y)
{
  x = parseInt(x);
  y = parseInt(y);

  var result = _add(x, y);
  return result;
}

console.log(add(1, '1'));</pre></div><p>In the previous code, the <code class="literal">_add()</code> call was not a tail call and therefore, two execution stacks were created. We can convert it into a tail call in this way:</p><div class="informalexample"><pre class="programlisting">function add(x, y)
{
  x = parseInt(x);
  y = parseInt(y);

  return _add(x, y);
}</pre></div><p>Here, we omitted<a id="id242" class="indexterm"/> the use of the <code class="literal">result</code> variable and instead, we <a id="id243" class="indexterm"/>lined up the function call with the <code class="literal">return</code> statement. Similarly, there are many other strategies to convert the non-tail calls into the tail calls.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we learned a new way of creating the object property keys using symbols. We saw the iterator and iterable protocols, and learned how to implement these protocols in the custom objects. Then, we learned how to iterate over an iterable object using the <code class="literal">for…of</code> loop. Finally, we ended the chapter by learning what tail calls are, and how they are optimized in ES6.</p><p>In the next chapter, we will learn what Promises are, and how to write a better asynchronous code using Promises.</p></div></body></html>