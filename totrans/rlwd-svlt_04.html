<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-65"><a id="_idTextAnchor064"/>4</h1>
<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Composing Components</h1>
<p>As your application grows, cramming all the logic into a single component becomes impractical. You’ll need to split your app into smaller, modular components and assemble them to form a more complex application.</p>
<p>In this chapter, we’ll explore various techniques to combine components effectively. We’ll start by examining how to inject custom content into a component using slots. Then, we’ll discuss how to conditionally render different HTML elements within a component. We’ll also delve into recursive components, useful for displaying nested or hierarchical data.</p>
<p>We’ll guide you through each topic with hands-on examples, ensuring the techniques you learn are both practical and applicable in real-world scenarios. By the end of this chapter, you’ll have a richer set of strategies to compose components in your Svelte applications.</p>
<p>In this chapter, you will learn the following:</p>
<ul>
<li>Manipulating how a child component looks from the perspective of its parent</li>
<li>Passing dynamic content through slots</li>
<li>Rendering different HTML element and component types</li>
<li>Creating recursive components for recursive data</li>
<li>The Container/Presentational pattern</li>
</ul>
<p>Let’s kick things off by exploring the various ways we can manipulate and control the content of a child component.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Technical requirements</h1>
<p>All the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Manipulating how a child component looks</h1>
<p>When you’re <a id="_idIndexMarker136"/>combining multiple components, you’ll need to manage how each child component appears and behaves. Even though a child component handles its own display and logic, it still offers controls to tweak its appearance and behavior. From the perspective of the parent component, you’ll want to coordinate these child components to achieve the desired overall functionality.</p>
<p>In this section, we’ll explore various ways to control the look of child components, ranging from the most to the least commonly used methods. Understanding these options will equip you with the tools to make your components both versatile and effective.</p>
<p>The list of options to control how the child component looks includes the following:</p>
<ul>
<li><strong class="bold">Controlling through props</strong>: This <a id="_idIndexMarker137"/>is perhaps the most straightforward way to influence the behavior and appearance of a child component. By passing props from a parent component to a child, you can make your child component highly dynamic and responsive to external changes.<p class="list-inset">To demonstrate how a parent component can control content using props in Svelte, consider the following code example:</p><pre class="source-code">
&lt;script&gt;
  import Child from './Child.svelte';
  let message = 'Hello from Parent';
&lt;/script&gt;
&lt;Child message={message} /&gt;
Child</strong> component and passed the <code>message</code> prop to it. The child component, implemented in the following code snippet, then uses this <code>message</code> prop to display text within a <code>&lt;</code><code>p&gt;</code> element:</pre><pre class="source-code">&lt;script&gt;
  export let message;
&lt;/script&gt;
&lt;p&gt;{message}&lt;/p&gt;</pre><p class="list-inset">As you can see, the parent component has the ability to dictate the text shown in the <code>Child</code> component by modifying the <code>message</code> prop’s value. Controlling props is a <a id="_idIndexMarker138"/>simple yet effective way to manipulate a child component’s content. If you’re interested in learning more about props, we covered the topic extensively in <a href="B18887_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>.</p></li> <li><code>parent</code> component:</p><pre class="source-code">
&lt;script&gt;
  import Child from './Child.svelte';
  import { setContext } from 'svelte';
  setContext('message', 'Hello from parent');
&lt;/script&gt;
&lt;Child /&gt;</pre><p class="list-inset">In the previous code, we established a context named <code>message</code> with the <code>'Hello from parent'</code> value, using <code>setContext</code>. Then, we imported and used the <code>Child</code> component without sending any props to it.</p><p class="list-inset">The following is the code for the <code>Child</code> component:</p><pre class="source-code">&lt;script&gt;
  import { getContext } from 'svelte';
  const message = getContext('message');
&lt;/script&gt;
&lt;p&gt;{message}&lt;/p&gt;</pre><p class="list-inset">Here, <code>getContext</code> is used to read the <code>message</code> context value, which is then displayed within a <code>&lt;p&gt;</code> element. As demonstrated, the parent component can influence<a id="_idIndexMarker140"/> the text in the child component’s <code>&lt;p&gt;</code> element by changing the context value.</p><p class="list-inset">For a deeper dive into Svelte’s context feature, you can refer to <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, where we will explore the topic in greater detail.</p></li> <li><strong class="bold">Controlling the styles</strong>: Manipulating a child component’s appearance isn’t solely about <a id="_idIndexMarker141"/>controlling the data passed to it. It also involves tweaking or modifying its styles.<p class="list-inset">You can modify a component style through CSS custom properties. This approach allows for greater design flexibility, and it ensures that child components can adapt to various contexts or themes within the parent component or the broader application.</p><p class="list-inset">For an in-depth discussion on how to alter a component’s style using CSS custom properties, feel free to refer to <a href="B18887_02.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>.</p></li>
<li><strong class="bold">Passing dynamic content through slot</strong>: Svelte’s slot feature allows you to insert custom <a id="_idIndexMarker142"/>content into specific areas of a child component. This provides a flexible way to have greater control over a component’s content without modifying its internal behavior.<p class="list-inset">We will talk about slots and how to use them in the following section.</p></li>
</ul>
<p>As you can see, there are various ways to shape a child component’s appearance and behavior. When we compose different components within a parent component, the goal is to make them work together in a coordinated way. You can use a combination of the approaches discussed to achieve this.</p>
<p>Most of these methods will be covered in separate chapters, and in the following section, we’ll focus on how to dynamically alter a child component’s look by passing content through <a id="_idTextAnchor068"/><a id="_idTextAnchor069"/>slots.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>Passing dynamic content through slots</h1>
<p>When building <a id="_idIndexMarker143"/>complex applications, one size doesn’t always fit all. Balancing between a component’s modularity and a component’s flexibility for customization is crucial.</p>
<p>Take <a id="_idIndexMarker144"/>a generic <code>Card</code> component, for example. You might sometimes want to include special headlines, unique lists, or custom footers for specific use cases. It’s nearly impossible to anticipate every requirement, so it’s essential to design components that are both modular and maintainable, yet still open to customization.</p>
<p>This is where Svelte’s slot feature <a id="_idIndexMarker145"/>shines. <code>Card</code> component that tries to include every possible feature, aim for a simple, clean base that can be enhanced through composition. This approach allows you to piece together more complex, customized components as your needs evolve.</p>
<p>In a Svelte component, a <code>&lt;slot&gt;</code> element is a placeholder within your component where you can inject any type of content from a parent component. Here’s how you can define a slot inside a Svelte component:</p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;</pre> <p>In the preceding code snippet, we defined a <code>&lt;slot&gt;</code> element inside a <code>&lt;div&gt;</code> element. Any dynamic content from the parent component will be inserted into the <code>&lt;</code><code>div&gt;</code> element.</p>
<p>Now, to pass dynamic content from a parent component into the slot of a child component, you need to place that content between the opening and closing tags of the child component:</p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;h1&gt;Special headline&lt;/h1&gt;
&lt;/Card&gt;</pre> <p>In this <a id="_idIndexMarker146"/>code snippet, we passed in a <code>&lt;h1&gt;</code> element <a id="_idIndexMarker147"/>between the opening and closing tags of the <code>&lt;Card&gt;</code> component. This effectively replaces the <code>&lt;slot&gt;</code> element in the <code>Card</code> component with the <code>&lt;h1&gt;</code> element we provide.</p>
<p>There may be instances where you don’t need to pass dynamic content from a parent component to a child component’s slot. For these cases, Svelte allows you to define default content within the <code>&lt;slot&gt;</code> element, providing a fallback when no custom content is supplied by the parent.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Providing default slot content</h2>
<p>To provide <a id="_idIndexMarker148"/>default content for your <code>&lt;slot&gt;</code> element, you can place them inside the <code>&lt;slot&gt;</code> element, like so:</p>
<pre class="source-code">
&lt;div class="card"&gt;
  &lt;slot&gt;
    &lt;div&gt;this is the default content&lt;/div&gt;
  &lt;/slot&gt;
&lt;/div&gt;</pre> <p>In the preceding code snippet, we defined <code>&lt;div&gt;</code>, containing the text <code>This is the default content</code> within the <code>&lt;slot&gt;</code> element. This serves as the default content for the slot.</p>
<p>When you use this <code>Card</code> component in a parent component and don’t provide content for the slot, as shown in the following code snippet, the default text will automatically appear:</p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card /&gt;</pre> <p>By utilizing the default content in slots, you can create more flexible Svelte components that offer <a id="_idIndexMarker149"/>sensible fallbacks when no custom content is provided.</p>
<p>In the examples we’ve seen so far, we’ve been limited to inserting dynamic content from the parent component into just one spot. But what if we wanted multiple insertion points for dynamic content? Let’s explore how to achieve that.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Having multiple slots with named slots</h2>
<p>Slots are <a id="_idIndexMarker150"/>amazing, and you are not limited to a single slot either. You can define multiple slots in a component and name them to target specific areas for dynamic content.</p>
<p>You can use the <code>name</code> attribute on the <code>&lt;slot&gt;</code> element to give the slot a name, as shown in the following code:</p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;header&gt;
    &lt;slot name="header"&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;footer&gt;
    &lt;slot name="footer"&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;</pre> <p>In the previous code snippet, we defined two named slots, one named <code>"header"</code> and another named <code>"footer"</code>.</p>
<p>To target the dynamic content into these named slots, you will need to use the <code>&lt;svelte:fragment&gt;</code> element in the parent component:</p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;svelte:fragment slot="header"&gt;
    &lt;h1&gt;Special headline&lt;/h1&gt;
  &lt;/svelte:fragment&gt;
  &lt;svelte:fragment slot="footer"&gt;
    Custom footer
  &lt;/svelte:fragment&gt;
&lt;/Card&gt;</pre> <p>Here, we <a id="_idIndexMarker151"/>pass two <code>&lt;svelte:fragment&gt;</code> elements into the <code>Card</code> component. The first has a slot attribute set to <code>"header"</code>, and the second slot attribute is set to <code>"footer"</code>.</p>
<p>The name specified in the <code>slot</code> attribute will correspond with the named slots within the <code>Card</code> component. The content within <code>&lt;svelte:fragment slot="header"&gt;</code> replaces the <code>&lt;slot name="header"&gt;</code> in the <code>Card</code> component. Similarly, the content within <code>&lt;svelte:fragment slot="footer"&gt;</code> takes the place of <code>&lt;slot name="footer"&gt;</code> in the component.</p>
<p>Sometimes, you will want the dynamic content from the parent component to be aware of the data within the child component. To handle this scenario, Svelte offers a feature known as slot props, which allows you to pass data from the child component to the content in the slot. Let’s explore how this works.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Passing data through slot props</h2>
<p>You can pass <a id="_idIndexMarker152"/>data from the child component back to the dynamic content in the parent component using slot props, like so:</p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;header&gt;
    &lt;slot name="header" width={30} height={50}&gt;&lt;/slot&gt;
  &lt;/header&gt;
&lt;/div&gt;</pre> <p>In the code <a id="_idIndexMarker153"/>example, we passed in two additional attributes to the <code>&lt;slot&gt;</code> element besides the <code>name</code> attribute, which is used to name the slot. These additional attributes, <code>width</code> and <code>height</code>, serve as slot props; their values can be accessed in the parent component when you create dynamic content.</p>
<p>Here is an example of how you can use these slot prop values when using <code>&lt;svelte:fragment&gt;</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;svelte:fragment slot="header" let:width let:height&gt;
    &lt;h1&gt;Dimension: {width} x {height}&lt;/h1&gt;
  &lt;/svelte:fragment&gt;
&lt;/Card&gt;</pre> <p>In the preceding code snippet, you can see that we use <code>let:width</code> and <code>let:height</code> within the <code>&lt;svelte:fragment&gt;</code> element. These are called <code>let:</code> bindings.</p>
<p>The <code>let:</code> bindings allow us to access the <code>width</code> and <code>height</code> slot props provided by the child <code>Card</code> component. The values for the width and height are then used within an <code>&lt;h1&gt;</code> element to display the dimensions. This way, we can dynamically adjust content in the parent component, based on data originating from the child component.</p>
<p>Now that we have covered how to pass dynamic content through slots, how to define multiple-named slots, and how to pass data from a child component to the dynamic slot content in a parent component, you are well equipped to create more versatile and reusable Svelte components.</p>
<p class="callout-heading">Renderless component</p>
<p class="callout">One of many <a id="_idIndexMarker154"/>common patterns to compose components using slots is the Renderless component pattern. This technique allows you to build components that are purely functional, leaving the presentation details to the parent component. We have dedicated <a href="B18887_11.xhtml#_idTextAnchor163"><em class="italic">Chapter 11</em></a> to delving into this fascinating topic.</p>
<p>Now that <a id="_idIndexMarker155"/>we’ve explored how to pass dynamic content through slots, let’s dive into another exciting feature of Svelte that lets you dynamically render different element or component types.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Rendering different HTML element or component types</h1>
<p>In any dynamic <a id="_idIndexMarker156"/>application, there comes a time when you need even more flexibility than what static components or elements offer. What if you don’t know the type of element or component you’ll need to render until runtime?</p>
<p>Let’s imagine<a id="_idIndexMarker157"/> that you’re building a form generator, and the type of form field – whether it’s <code>&lt;Input&gt;</code>, <code>&lt;Checkbox&gt;</code>, or <code>&lt;Select&gt;</code> – is determined by dynamic data. How could you switch between these components seamlessly, especially when they share the same set of props?</p>
<p>One straightforward approach is to use Svelte’s <code>{#if}</code> blocks to conditionally render the component you need. Here is an example code snippet:</p>
<pre class="source-code">
&lt;script&gt;
  import Input from './Input.svelte';
  import Checkbox from './Checkbox.svelte';
  import Select from './Select.svelte';
  let type = "input"; // Could be "checkbox" or "select"
&lt;/script&gt;
{#if type === "input"}
  &lt;Input value={value} onChange={onChange} /&gt;
{:else if type === "checkbox"}
  &lt;Checkbox value={value} onChange={onChange} /&gt;
{:else}
  &lt;Select value={value} onChange={onChange} /&gt;
{/if}</pre> <p>In the <a id="_idIndexMarker158"/>code snippet, we use the <code>{#if}</code> blocks to choose among<a id="_idIndexMarker159"/> three different component types, passing the same prop values to each. If you find yourself needing to manage more component types, this could lead to a lengthy and hard-to-maintain series of conditional blocks.</p>
<p>Is there a more efficient way to handle this?</p>
<p>Svelte provides two specialized elements, <code>&lt;svelte:element&gt;</code> and <code>&lt;svelte:component&gt;</code>, precisely for this. The <code>&lt;svelte:element&gt;</code> element lets you create different HTML element types dynamically, based on variable data, whereas the <code>&lt;svelte:component&gt;</code> element lets you dynamically render different Svelte component types.</p>
<p>Here’s how you can rewrite the previous example using <code>&lt;svelte:component&gt;</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import Input from './Input.svelte';
  import Checkbox from './Checkbox.svelte';
  import Select from './Select.svelte';
  let type = "input"; // Could be "checkbox" or "select"
<strong class="bold">  let DynamicComponent;</strong>
<strong class="bold">  if (type === "input") {</strong>
<strong class="bold">    DynamicComponent = Input;</strong>
<strong class="bold">  } else if (type === "checkbox") {</strong>
<strong class="bold">    DynamicComponent = Checkbox;</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    DynamicComponent = Select;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
<strong class="bold">&lt;svelte:component</strong>
<strong class="bold">  this={DynamicComponent}</strong>
<strong class="bold">  value={value}</strong>
<strong class="bold">  onChange={onChange}</strong>
<code>DynamicComponent</code> variable is used to hold the type of component that will be rendered. This component type is then passed to the <code>this</code> attribute within the <code>&lt;svelte:component&gt;</code> element. The <code>&lt;svelte:component&gt;</code> element also accepts other props such as <code>value</code> and <code>onChange</code>.</p>
<p>With the <a id="_idIndexMarker161"/>preceding code, what happens is that <code>&lt;svelte:component&gt;</code> renders the designated component stored in the <code>this</code> attribute, simultaneously forwarding any props passed to <code>&lt;svelte:component&gt;</code> to this dynamically rendered component. For example, if the value of <code>DynamicComponent</code> is the <code>Select</code> component, then the preceding code is effectively the same as this code:</p>
<pre class="source-code">
&lt;Select value={value} onChange={onChange} /&gt;</pre> <p>By using <code>&lt;svelte:component&gt;</code>, we simplify the code and make it more maintainable. It’s also easier to extend; adding another form element type would only require an additional condition and assignment.</p>
<p>Now that we’ve explored the use of <code>&lt;svelte:component&gt;</code>, let’s look at <code>&lt;svelte:element&gt;</code>, which follows a similar pattern. The following is a sample code snippet that demonstrates the usage of <code>&lt;svelte:element&gt;</code>:</p>
<pre class="source-code">
&lt;script&gt;
  let type = 'button'; // could be 'div', 'p', 'a', etc.
&lt;/script&gt;
&lt;svelte:element this={type}&gt;
  Click Me
&lt;/svelte:element&gt;</pre> <p>In the <a id="_idIndexMarker162"/>preceding code snippet, the <code>type</code> variable holds the type of HTML element we want to render – in this example, it’s <code>button</code>. The <code>&lt;svelte:element&gt;</code> tag dynamically creates an HTML element of the type specified by <code>type</code>. So, if <code>type</code> is <code>'button'</code>, this will render as a <code>&lt;button&gt;</code> element, containing the text <code>"</code><code>Click Me"</code>.</p>
<p>This <a id="_idIndexMarker163"/>approach is particularly useful when you want to switch the type of an HTML element, based on some condition, without having to rewrite the entire block of code. All you need to do is change the value of <code>type</code>.</p>
<p>To summarize, <code>&lt;svelte:element&gt;</code> and <code>&lt;svelte:component&gt;</code> offer a more efficient and maintainable way to handle dynamic rendering needs. They provide a robust alternative to multiple <code>{#if}</code> blocks, making your Svelte applications more flexible and easier to manage.</p>
<p>Sometimes, when designing Svelte components for data visualization, we encounter recursive data structures. In such cases, we need to build components that can recursively render themselves. Let’s delve into how we can accomplish this next.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Creating recursive components for recursive data</h1>
<p>A <strong class="bold">recursive data structure</strong> is a <a id="_idIndexMarker164"/>data structure that is defined in terms of itself, meaning that it can be composed of smaller instances of the same type of structure. Recursive data<a id="_idIndexMarker165"/> is everywhere – think of a comment section where replies can have their own sub-replies, or a filesystem with nested folders. Creating a component to display them in a frontend application can be challenging.</p>
<p>Imagine we have a variable called <code>folder</code>, which is an array containing either files or additional folders. In this example, the <code>folder</code> variable could look like this:</p>
<pre class="source-code">
const folder = [
  { type: 'file', name: 'a.js' },
  { type: 'file', name: 'b.js' },
  { type: 'folder', name: 'c', children: [
    { type: 'file', name: 'd.js' },
  ]},
];</pre> <p>Currently, our <code>folder</code> variable is two levels deep. To represent this structure in a Svelte <a id="_idIndexMarker166"/>component, you might think to use nested <code>{#</code><code>each}</code> blocks:</p>
<pre class="source-code">
&lt;script&gt;
  export let folder;
&lt;/script&gt;
&lt;ul&gt;
  {#each folder as item}
    &lt;li&gt;
      {#if item.type === 'file'}
        &lt;div&gt;File: {item.name}&lt;/div&gt;
      {:else}
        &lt;div&gt;Folder: {item.name}&lt;/div&gt;
        &lt;ul&gt;
          {#each item.children as child}
            &lt;li&gt;
              {#if child.type === 'file'}
                &lt;div&gt;File: {child.name}&lt;/div&gt;
              {:else}
                ...
              {/if}
            &lt;/li&gt;
          {/each}
        &lt;/ul&gt;
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker167"/>preceding code snippet, we used an <code>{#each}</code> block to iterate over the items in the <code>folder</code> variable, rendering either a file or a folder based on <code>item.type</code>. If <code>item.type</code> is a folder, we use another nested <code>{#each}</code> block to go through its contents.</p>
<p>However, here’s the catch – the inner folder could also contain files or additional folders, making it recursive. As a result, we end up with repeated code for the inner and outer <code>{#each}</code> blocks. This works fine for a folder structure that’s only two levels deep, but what if it’s more complex? How can we avoid duplicating the same code for each level of nesting?</p>
<p>Svelte offers an elegant solution to handle such recursive structures with the <code>&lt;svelte:self&gt;</code> element. The <code>&lt;svelte:self&gt;</code> element allows a component to embed itself within its own markup, thus making it easier to handle recursive data.</p>
<p>Here’s the updated code using the <code>&lt;</code><code>svelte:self&gt;</code> element:</p>
<pre class="source-code">
&lt;script&gt;
  export let folder;
&lt;/script&gt;
&lt;ul&gt;
  {#each folder as item}
    &lt;li&gt;
      {#if item.type === 'file'}
        &lt;div&gt;File: {item.name}&lt;/div&gt;
      {:else}
        &lt;div&gt;Folder: {item.name}&lt;/div&gt;
        <strong class="bold">&lt;svelte:self folder={item.children} /&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker168"/>updated code snippet, we replaced the nested <code>{#each}</code> block with <code>&lt;svelte:self folder={item.children} /&gt;</code>. This effectively re-renders the current component, passing <code>item.children</code> as the <code>folder</code> prop.</p>
<p>The beauty of this is that it eliminates the need to initiate a new <code>&lt;ul&gt;</code> element and duplicate <code>{#each}</code> blocks for each nesting level. Instead, the component simply reuses itself, making it capable of handling nested structures of any depth.</p>
<p>When comparing this with the previous code snippet, you can immediately see the advantage – it’s much cleaner and avoids repetitive code, making it easier to read and maintain, and it scales naturally to handle any level of nested folders.</p>
<p>Now that we’ve discussed how to tackle recursive data with <code>&lt;svelte:self&gt;</code>, let’s look at a practical example in the following section, where we will create a Svelte-based JSON tree viewer.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Example – a JSON tree viewer</h1>
<p>In this section, we <a id="_idIndexMarker169"/>will walk you through building a JSON tree viewer component in Svelte. The JSON tree viewer component helps you visualize JSON data in a tree-like format. Along the way, we’ll make use of some of the advanced Svelte features we’ve covered in this chapter, including <code>&lt;svelte:self&gt;</code>, <code>&lt;svelte:component&gt;</code>, and slots.</p>
<p>Before we start, let’s think <a id="_idIndexMarker170"/>about what our JSON Tree Viewer should look like and how it should behave. Essentially, a JSON object is made up of key-value pairs, where the values can be either primitives, arrays, or other nested objects. Our goal is to display these key-value pairs in a way that clearly represents the hierarchical structure of the JSON object.</p>
<p>So, let’s create a <code>JsonTree</code> component for our JSON tree viewer:</p>
<pre class="source-code">
&lt;!-- filename: JsonTree.svelte --&gt;
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;{key}: {value}&lt;li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker171"/>preceding code snippet, we defined a <code>JsonTree</code> component that accepts data as a prop. Inside this component, we utilize Svelte’s <code>{#each}</code> block to generate a list of <code>&lt;li&gt;</code> elements. Each element displays a key-value pair from the <code>data</code> object.</p>
<p>However, these values can vary. They could be primitive types or nested objects. Take the following example:</p>
<pre class="source-code">
data = {
  name: 'John Doe',
  address: {
    street: '123 Main St'
  },
}</pre> <p>In the preceding <code>data</code> object, the <code>name</code> key has a primitive string value, while the value for the <code>address</code> key is an object. For nested objects like this, we will need to use our <code>JsonTree</code> component recursively to render that nested object. This is where <code>&lt;svelte:self&gt;</code> comes into play.</p>
<p>Here’s the updated code:</p>
<pre class="source-code">
&lt;!-- filename: JsonTree.svelte --&gt;
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      {key}:
<strong class="bold">      {#if typeof value === 'object'}</strong>
<strong class="bold">        &lt;svelte:self data={value} /&gt;</strong>
<strong class="bold">      {:else}</strong>
<strong class="bold">        {value}</strong>
<strong class="bold">      {/if}</strong>
    &lt;li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In this <a id="_idIndexMarker172"/>updated code snippet, we introduced an <code>{#if}</code> block that renders differently based on whether the value is a primitive type or a nested object. For nested objects, we recursively render another <code>JsonTree</code> component using <code>&lt;svelte:self&gt;</code>. This allows us to elegantly handle JSON objects of any depth.</p>
<p>Now, in our current implementation, we haven’t made distinctions between different types of primitive values. Suppose you’d like to render various primitive types using specialized Svelte components. In that case, you could dynamically switch between different component types using <code>&lt;svelte:component&gt;</code>.</p>
<p>Let’s assume you have three separate Svelte components – <code>StringValue</code> for strings, <code>NumberValue</code> for numbers, and <code>JsonValue</code> for others (such as Booleans, <code>null</code>, and <code>undefined</code>). Here is how you can <a id="_idIndexMarker173"/>update the code to use <code>&lt;svelte:component&gt;</code>:</p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  import StringValue from './StringValue.svelte';</strong>
<strong class="bold">  import NumberValue from './NumberValue.svelte';</strong>
<strong class="bold">  import JsonValue from './JsonValue.svelte';</strong>
  export let data;
<strong class="bold">  function getComponent(type) {</strong>
<strong class="bold">    if (type === 'string') return StringValue;</strong>
<strong class="bold">    if (type === 'number') return NumberValue;</strong>
<strong class="bold">    return JsonValue;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      {key}:
      {#if typeof value === 'object'}
        &lt;svelte:self data={value} /&gt;
      {:else}
        <strong class="bold">&lt;svelte:component this={getComponent(typeof value)} value={value} /&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the updated code snippet, we created a utility function named <code>getComponent</code> to determine which component to render, based on the type of the primitive value. We then used <code>&lt;svelte:component this={getComponent(typeof value)} /&gt;</code> to dynamically load the appropriate component for each primitive type, allowing our <code>JsonTree</code> component to switch to different components for different types of data.</p>
<p>Lastly, to <a id="_idIndexMarker174"/>make our JSON tree viewer more versatile, we can introduce named slots to customize the appearance of keys and values. By doing so, users can easily tailor the look of these elements according to their needs, while keeping our current design as the default fallback. Let’s update the code to add the two named slots:</p>
<pre class="source-code">
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      <strong class="bold">&lt;slot name="obj-key" key={key}&gt;</strong>{key}:<strong class="bold">&lt;slot&gt;</strong>
      {#if typeof value === 'object'}
        &lt;svelte:self data={value} /&gt;
      {:else}
        <strong class="bold">&lt;slot name="obj-value" value={value}&gt;</strong>
          &lt;svelte:component this={getComponent(typeof value)} value={value} /&gt;
        <strong class="bold">&lt;/slot&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the updated code, we added two named slots – one to customize keys, called <code>"obj-key"</code>, and another to customize values, called <code>"obj-value"</code>. These slots receive the current <code>key</code> and <code>value</code> as slot props, enabling you to tailor their appearance in the parent component.</p>
<p>For instance, if you wish to change how keys and values are displayed, here’s how you can write in your parent component:</p>
<pre class="source-code">
&lt;JsonTree data={{a: 1, b: 2}}&gt;
  &lt;svelte:fragment slot="obj-key" let:key&gt;
    &lt;em&gt;{key}&lt;/em&gt;
  &lt;/svelte:fragment&gt;
  &lt;svelte:fragment slot="obj-value" let:value&gt;
    &lt;u&gt;{value}&lt;/u&gt;
  &lt;/svelte:fragment&gt;
&lt;/JsonTree&gt;</pre> <p>Here, we <a id="_idIndexMarker175"/>use Svelte’s <code>&lt;svelte:fragment&gt;</code> special element to target the named slots, <code>"obj-key"</code> and <code>"obj-value"</code>, in our <code>JsonTree</code> component. The <code>let:key</code> and <code>let:value</code> syntax allows us to access the current key and value being rendered, respectively.</p>
<p>In the <code>&lt;svelte:fragment&gt;</code> element, we wrapped the key in an <code>&lt;em&gt;</code> tag and the value in a <code>&lt;u&gt;</code> tag, offering custom styling for these elements. This customization overrides the default rendering provided by the <code>JsonTree</code> component. If you don’t specify any custom content, the component will fall back to its default rendering, offering both robustness and flexibility.</p>
<p>By combining <code>&lt;svelte:self&gt;</code> for recursion, <code>&lt;svelte:component&gt;</code> for dynamic behavior, and slots for customization, we have created a flexible and powerful JSON tree viewer. This not only demonstrates Svelte’s capability to handle complex UI patterns but also serves as a practical example of component composition in Svelte.</p>
<p>You can find the complete code for this exercise here: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree%0D">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree</a>.</p>
<p>Before we wrap up this chapter, let us take a moment to discuss a helpful common pattern to organize our components, the Container/Presentational pattern.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>The Container/Presentational pattern</h1>
<p>As your application <a id="_idIndexMarker176"/>scales in complexity, you may find it beneficial to adopt specific design patterns or guidelines to structure components. One such approach is the <strong class="bold">Container/Presentational pattern</strong>, which divides a component into two categories, the Container component and the Presentational component:</p>
<ul>
<li><em class="italic">Container components</em> focus on <a id="_idIndexMarker177"/>functionality. They handle data fetching, state management, and user interactions. While they usually don’t <a id="_idIndexMarker178"/>render <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) elements themselves, they wrap around Presentational components and supply them with data and actions.</li>
<li><em class="italic">Presentational components</em> are all <a id="_idIndexMarker179"/>about the user interface. They get their data and event-handling functions exclusively through props, making them highly reusable and straightforward to test.</li>
</ul>
<p>A common scenario where you’ll see this pattern in action is when using a UI component library. In this case, the library’s components serve as the presentational elements, focusing solely on how things look. Meanwhile, the components you create that utilize these library elements act as Container components, managing data and handling interactions such as clicks, typing, and dragging.</p>
<p>The Component/Presentational pattern<a id="_idIndexMarker180"/> is useful in a few aspects:</p>
<ul>
<li><strong class="bold">Simplicity</strong>: Separating behavior from appearance makes your codebase easier to understand and maintain</li>
<li><strong class="bold">Reusability</strong>: Since Presentational components are agnostic about data sources or user actions, you can reuse them in different parts of your application</li>
<li><strong class="bold">Collaboration</strong>: With this division, designers can work on the Presentational components while developers focus on the Container components, streamlining development</li>
</ul>
<p>As you come to appreciate the <a id="_idIndexMarker181"/>benefits of the Component/Presentational pattern, there are specific situations where I think you should consider using it, such as the following:</p>
<ul>
<li><strong class="bold">When your application starts to grow</strong>: Managing everything in a single component can become confusing as complexity increases</li>
<li><strong class="bold">When you find yourself repeating the same UI patterns</strong>: Creating reusable Presentational components can save time in the long run</li>
<li><strong class="bold">When your team scales</strong>: As your development team grows, having a standardized way of building components can reduce learning curves and prevent code conflicts</li>
</ul>
<p>While the Container/Presentational pattern <a id="_idIndexMarker182"/>offers a structured approach to organizing your components, it’s not always the best fit – especially for smaller applications, where it might be overkill. Hopefully, with the insights provided, you’ll be better equipped to make informed decisions.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Summary</h1>
<p>In this chapter, we delved into various strategies for component composition in Svelte, each offering its own set of advantages and applicable scenarios. Mastering these techniques will equip you to build Svelte applications that are not only more dynamic but also easier to maintain and scale.</p>
<p>We kicked off by discussing multiple ways to influence a child component. These ranged from controlling props or using Svelte’s context to customizing styles via CSS custom properties, and even dynamically passing content through slots.</p>
<p>Then, we turned our attention to some of Svelte’s special elements. We explored <code>&lt;svelte:element&gt;</code> and <code>&lt;svelte:component&gt;</code> to dynamically render various HTML elements and Svelte components. We also learned about <code>&lt;svelte:self&gt;</code>, which allows a component to reference itself, thereby facilitating the creation of recursive UI structures. We then applied these newfound skills to build a JSON tree viewer as an illustrative example.</p>
<p>Finally, we touched upon a popular design pattern – the Container/Presentational pattern. We examined its advantages and considered scenarios where it would be beneficial to employ this approach.</p>
<p>Armed with these advanced techniques, you are now better prepared to tackle complex challenges in your Svelte projects. As we conclude our four-chapter exploration of writing Svelte components, we’ll shift our focus in the upcoming chapter to another fundamental feature of Svelte – Svelte actions.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-78" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor079"/>Part 2: Actions</h1>
<p>In this part, we embark on a journey to learn about Svelte actions. Across three chapters, we will delve into three different use cases of Svelte actions. Starting with the creation of custom events using actions, we’ll progress to integrating third-party JavaScript libraries with Svelte via actions. Finally, we’ll unveil techniques to progressively enhance our applications, harnessing the power of Svelte actions.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18887_05.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Custom Events with Actions</em></li>
<li><a href="B18887_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Libraries with Actions</em></li>
<li><a href="B18887_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, <em class="italic">Progressive Enhancements with Svelte Actions</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>