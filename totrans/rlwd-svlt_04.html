<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-65"><a id="_idTextAnchor064"/>4</h1>
<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Composing Components</h1>
<p>As your application grows, cramming all the logic into a single component becomes impractical. You’ll need to split your app into smaller, modular components and assemble them to form a more <span class="No-Break">complex application.</span></p>
<p>In this chapter, we’ll explore various techniques to combine components effectively. We’ll start by examining how to inject custom content into a component using slots. Then, we’ll discuss how to conditionally render different HTML elements within a component. We’ll also delve into recursive components, useful for displaying nested or <span class="No-Break">hierarchical data.</span></p>
<p>We’ll guide you through each topic with hands-on examples, ensuring the techniques you learn are both practical and applicable in real-world scenarios. By the end of this chapter, you’ll have a richer set of strategies to compose components in your <span class="No-Break">Svelte applications.</span></p>
<p>In this chapter, you will learn <span class="No-Break">the following:</span></p>
<ul>
<li>Manipulating how a child component looks from the perspective of <span class="No-Break">its parent</span></li>
<li>Passing dynamic content <span class="No-Break">through slots</span></li>
<li>Rendering different HTML element and <span class="No-Break">component types</span></li>
<li>Creating recursive components for <span class="No-Break">recursive data</span></li>
<li>The <span class="No-Break">Container/Presentational pattern</span></li>
</ul>
<p>Let’s kick things off by exploring the various ways we can manipulate and control the content of a <span class="No-Break">child component.</span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Technical requirements</h1>
<p>All the code in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Manipulating how a child component looks</h1>
<p>When you’re <a id="_idIndexMarker136"/>combining multiple components, you’ll need to manage how each child component appears and behaves. Even though a child component handles its own display and logic, it still offers controls to tweak its appearance and behavior. From the perspective of the parent component, you’ll want to coordinate these child components to achieve the desired <span class="No-Break">overall functionality.</span></p>
<p>In this section, we’ll explore various ways to control the look of child components, ranging from the most to the least commonly used methods. Understanding these options will equip you with the tools to make your components both versatile <span class="No-Break">and effective.</span></p>
<p>The list of options to control how the child component looks includes <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Controlling through props</strong>: This <a id="_idIndexMarker137"/>is perhaps the most straightforward way to influence the behavior and appearance of a child component. By passing props from a parent component to a child, you can make your child component highly dynamic and responsive to <span class="No-Break">external changes.</span><p class="list-inset">To demonstrate how a parent component can control content using props in Svelte, consider the following <span class="No-Break">code example:</span></p><pre class="source-code">
&lt;script&gt;
  import Child from './Child.svelte';
  let message = 'Hello from Parent';
&lt;/script&gt;
&lt;Child message={message} /&gt;</pre><p class="list-inset">In the code snippet, we imported the <strong class="source-inline">Child</strong> component and passed the <strong class="source-inline">message</strong> prop to it. The child component, implemented in the following code snippet, then uses this <strong class="source-inline">message</strong> prop to display text within a <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">p&gt;</strong></span><span class="No-Break"> element:</span></p><pre class="source-code">&lt;script&gt;
  export let message;
&lt;/script&gt;
&lt;p&gt;{message}&lt;/p&gt;</pre><p class="list-inset">As you can see, the parent component has the ability to dictate the text shown in the <strong class="source-inline">Child</strong> component by modifying the <strong class="source-inline">message</strong> prop’s value. Controlling props is a <a id="_idIndexMarker138"/>simple yet effective way to manipulate a child component’s content. If you’re interested in learning more about props, we covered the topic extensively in <a href="B18887_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p></li> <li><strong class="bold">Controlling through context</strong>: Svelte’s context API allows components to share state <a id="_idIndexMarker139"/>without explicitly passing props through every layer of the component tree. This is particularly useful when you have deeply <span class="No-Break">nested components.</span><p class="list-inset">Here’s an example of a <span class="No-Break"><strong class="source-inline">parent</strong></span><span class="No-Break"> component:</span></p><pre class="source-code">
&lt;script&gt;
  import Child from './Child.svelte';
  import { setContext } from 'svelte';
  setContext('message', 'Hello from parent');
&lt;/script&gt;
&lt;Child /&gt;</pre><p class="list-inset">In the previous code, we established a context named <strong class="source-inline">message</strong> with the <strong class="source-inline">'Hello from parent'</strong> value, using <strong class="source-inline">setContext</strong>. Then, we imported and used the <strong class="source-inline">Child</strong> component without sending any props <span class="No-Break">to it.</span></p><p class="list-inset">The following is the code for the <span class="No-Break"><strong class="source-inline">Child</strong></span><span class="No-Break"> component:</span></p><pre class="source-code">&lt;script&gt;
  import { getContext } from 'svelte';
  const message = getContext('message');
&lt;/script&gt;
&lt;p&gt;{message}&lt;/p&gt;</pre><p class="list-inset">Here, <strong class="source-inline">getContext</strong> is used to read the <strong class="source-inline">message</strong> context value, which is then displayed within a <strong class="source-inline">&lt;p&gt;</strong> element. As demonstrated, the parent component can influence<a id="_idIndexMarker140"/> the text in the child component’s <strong class="source-inline">&lt;p&gt;</strong> element by changing the <span class="No-Break">context value.</span></p><p class="list-inset">For a deeper dive into Svelte’s context feature, you can refer to <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, where we will explore the topic in <span class="No-Break">greater detail.</span></p></li> <li><strong class="bold">Controlling the styles</strong>: Manipulating a child component’s appearance isn’t solely about <a id="_idIndexMarker141"/>controlling the data passed to it. It also involves tweaking or modifying <span class="No-Break">its styles.</span><p class="list-inset">You can modify a component style through CSS custom properties. This approach allows for greater design flexibility, and it ensures that child components can adapt to various contexts or themes within the parent component or the <span class="No-Break">broader application.</span></p><p class="list-inset">For an in-depth discussion on how to alter a component’s style using CSS custom properties, feel free to refer to <a href="B18887_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p></li>
<li><strong class="bold">Passing dynamic content through slot</strong>: Svelte’s slot feature allows you to insert custom <a id="_idIndexMarker142"/>content into specific areas of a child component. This provides a flexible way to have greater control over a component’s content without modifying its <span class="No-Break">internal behavior.</span><p class="list-inset">We will talk about slots and how to use them in the <span class="No-Break">following section.</span></p></li>
</ul>
<p>As you can see, there are various ways to shape a child component’s appearance and behavior. When we compose different components within a parent component, the goal is to make them work together in a coordinated way. You can use a combination of the approaches discussed to <span class="No-Break">achieve this.</span></p>
<p>Most of these methods will be covered in separate chapters, and in the following section, we’ll focus on how to dynamically alter a child component’s look by passing content <span class="No-Break">through <a id="_idTextAnchor068"/><a id="_idTextAnchor069"/>slots.</span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>Passing dynamic content through slots</h1>
<p>When building <a id="_idIndexMarker143"/>complex applications, one size doesn’t always fit all. Balancing between a component’s modularity and a component’s flexibility for customization <span class="No-Break">is crucial.</span></p>
<p>Take <a id="_idIndexMarker144"/>a generic <strong class="source-inline">Card</strong> component, for example. You might sometimes want to include special headlines, unique lists, or custom footers for specific use cases. It’s nearly impossible to anticipate every requirement, so it’s essential to design components that are both modular and maintainable, yet still open <span class="No-Break">to customization.</span></p>
<p>This is where Svelte’s slot feature <a id="_idIndexMarker145"/>shines. <strong class="bold">Slots</strong> enable you to inject dynamic content into your components, making them incredibly versatile. Instead of designing a <strong class="source-inline">Card</strong> component that tries to include every possible feature, aim for a simple, clean base that can be enhanced through composition. This approach allows you to piece together more complex, customized components as your <span class="No-Break">needs evolve.</span></p>
<p>In a Svelte component, a <strong class="source-inline">&lt;slot&gt;</strong> element is a placeholder within your component where you can inject any type of content from a parent component. Here’s how you can define a slot inside a <span class="No-Break">Svelte component:</span></p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;</pre> <p>In the preceding code snippet, we defined a <strong class="source-inline">&lt;slot&gt;</strong> element inside a <strong class="source-inline">&lt;div&gt;</strong> element. Any dynamic content from the parent component will be inserted into the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>Now, to pass dynamic content from a parent component into the slot of a child component, you need to place that content between the opening and closing tags of the <span class="No-Break">child component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;h1&gt;Special headline&lt;/h1&gt;
&lt;/Card&gt;</pre> <p>In this <a id="_idIndexMarker146"/>code snippet, we passed in a <strong class="source-inline">&lt;h1&gt;</strong> element <a id="_idIndexMarker147"/>between the opening and closing tags of the <strong class="source-inline">&lt;Card&gt;</strong> component. This effectively replaces the <strong class="source-inline">&lt;slot&gt;</strong> element in the <strong class="source-inline">Card</strong> component with the <strong class="source-inline">&lt;h1&gt;</strong> element <span class="No-Break">we provide.</span></p>
<p>There may be instances where you don’t need to pass dynamic content from a parent component to a child component’s slot. For these cases, Svelte allows you to define default content within the <strong class="source-inline">&lt;slot&gt;</strong> element, providing a fallback when no custom content is supplied by <span class="No-Break">the parent.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Providing default slot content</h2>
<p>To provide <a id="_idIndexMarker148"/>default content for your <strong class="source-inline">&lt;slot&gt;</strong> element, you can place them inside the <strong class="source-inline">&lt;slot&gt;</strong> element, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;div class="card"&gt;
  &lt;slot&gt;
    &lt;div&gt;this is the default content&lt;/div&gt;
  &lt;/slot&gt;
&lt;/div&gt;</pre> <p>In the preceding code snippet, we defined <strong class="source-inline">&lt;div&gt;</strong>, containing the text <strong class="source-inline">This is the default content</strong> within the <strong class="source-inline">&lt;slot&gt;</strong> element. This serves as the default content for <span class="No-Break">the slot.</span></p>
<p>When you use this <strong class="source-inline">Card</strong> component in a parent component and don’t provide content for the slot, as shown in the following code snippet, the default text will <span class="No-Break">automatically appear:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card /&gt;</pre> <p>By utilizing the default content in slots, you can create more flexible Svelte components that offer <a id="_idIndexMarker149"/>sensible fallbacks when no custom content <span class="No-Break">is provided.</span></p>
<p>In the examples we’ve seen so far, we’ve been limited to inserting dynamic content from the parent component into just one spot. But what if we wanted multiple insertion points for dynamic content? Let’s explore how to <span class="No-Break">achieve that.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Having multiple slots with named slots</h2>
<p>Slots are <a id="_idIndexMarker150"/>amazing, and you are not limited to a single slot either. You can define multiple slots in a component and name them to target specific areas for <span class="No-Break">dynamic content.</span></p>
<p>You can use the <strong class="source-inline">name</strong> attribute on the <strong class="source-inline">&lt;slot&gt;</strong> element to give the slot a name, as shown in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;header&gt;
    &lt;slot name="header"&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;footer&gt;
    &lt;slot name="footer"&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;</pre> <p>In the previous code snippet, we defined two named slots, one named <strong class="source-inline">"header"</strong> and another <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">"footer"</strong></span><span class="No-Break">.</span></p>
<p>To target the dynamic content into these named slots, you will need to use the <strong class="source-inline">&lt;svelte:fragment&gt;</strong> element in the <span class="No-Break">parent component:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;svelte:fragment slot="header"&gt;
    &lt;h1&gt;Special headline&lt;/h1&gt;
  &lt;/svelte:fragment&gt;
  &lt;svelte:fragment slot="footer"&gt;
    Custom footer
  &lt;/svelte:fragment&gt;
&lt;/Card&gt;</pre> <p>Here, we <a id="_idIndexMarker151"/>pass two <strong class="source-inline">&lt;svelte:fragment&gt;</strong> elements into the <strong class="source-inline">Card</strong> component. The first has a slot attribute set to <strong class="source-inline">"header"</strong>, and the second slot attribute is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"footer"</strong></span><span class="No-Break">.</span></p>
<p>The name specified in the <strong class="source-inline">slot</strong> attribute will correspond with the named slots within the <strong class="source-inline">Card</strong> component. The content within <strong class="source-inline">&lt;svelte:fragment slot="header"&gt;</strong> replaces the <strong class="source-inline">&lt;slot name="header"&gt;</strong> in the <strong class="source-inline">Card</strong> component. Similarly, the content within <strong class="source-inline">&lt;svelte:fragment slot="footer"&gt;</strong> takes the place of <strong class="source-inline">&lt;slot name="footer"&gt;</strong> in <span class="No-Break">the component.</span></p>
<p>Sometimes, you will want the dynamic content from the parent component to be aware of the data within the child component. To handle this scenario, Svelte offers a feature known as slot props, which allows you to pass data from the child component to the content in the slot. Let’s explore how <span class="No-Break">this works.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Passing data through slot props</h2>
<p>You can pass <a id="_idIndexMarker152"/>data from the child component back to the dynamic content in the parent component using slot props, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;!-- filename: Card.svelte --&gt;
&lt;div class="card"&gt;
  &lt;header&gt;
    &lt;slot name="header" width={30} height={50}&gt;&lt;/slot&gt;
  &lt;/header&gt;
&lt;/div&gt;</pre> <p>In the code <a id="_idIndexMarker153"/>example, we passed in two additional attributes to the <strong class="source-inline">&lt;slot&gt;</strong> element besides the <strong class="source-inline">name</strong> attribute, which is used to name the slot. These additional attributes, <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>, serve as slot props; their values can be accessed in the parent component when you create <span class="No-Break">dynamic content.</span></p>
<p>Here is an example of how you can use these slot prop values when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">&lt;svelte:fragment&gt;</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;
&lt;Card&gt;
  &lt;svelte:fragment slot="header" let:width let:height&gt;
    &lt;h1&gt;Dimension: {width} x {height}&lt;/h1&gt;
  &lt;/svelte:fragment&gt;
&lt;/Card&gt;</pre> <p>In the preceding code snippet, you can see that we use <strong class="source-inline">let:width</strong> and <strong class="source-inline">let:height</strong> within the <strong class="source-inline">&lt;svelte:fragment&gt;</strong> element. These are called <span class="No-Break"><strong class="source-inline">let:</strong></span><span class="No-Break"> bindings.</span></p>
<p>The <strong class="source-inline">let:</strong> bindings allow us to access the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> slot props provided by the child <strong class="source-inline">Card</strong> component. The values for the width and height are then used within an <strong class="source-inline">&lt;h1&gt;</strong> element to display the dimensions. This way, we can dynamically adjust content in the parent component, based on data originating from the <span class="No-Break">child component.</span></p>
<p>Now that we have covered how to pass dynamic content through slots, how to define multiple-named slots, and how to pass data from a child component to the dynamic slot content in a parent component, you are well equipped to create more versatile and reusable <span class="No-Break">Svelte components.</span></p>
<p class="callout-heading">Renderless component</p>
<p class="callout">One of many <a id="_idIndexMarker154"/>common patterns to compose components using slots is the Renderless component pattern. This technique allows you to build components that are purely functional, leaving the presentation details to the parent component. We have dedicated <a href="B18887_11.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> to delving into this <span class="No-Break">fascinating topic.</span></p>
<p>Now that <a id="_idIndexMarker155"/>we’ve explored how to pass dynamic content through slots, let’s dive into another exciting feature of Svelte that lets you dynamically render different element or <span class="No-Break">component types.</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Rendering different HTML element or component types</h1>
<p>In any dynamic <a id="_idIndexMarker156"/>application, there comes a time when you need even more flexibility than what static components or elements offer. What if you don’t know the type of element or component you’ll need to render <span class="No-Break">until runtime?</span></p>
<p>Let’s imagine<a id="_idIndexMarker157"/> that you’re building a form generator, and the type of form field – whether it’s <strong class="source-inline">&lt;Input&gt;</strong>, <strong class="source-inline">&lt;Checkbox&gt;</strong>, or <strong class="source-inline">&lt;Select&gt;</strong> – is determined by dynamic data. How could you switch between these components seamlessly, especially when they share the same set <span class="No-Break">of props?</span></p>
<p>One straightforward approach is to use Svelte’s <strong class="source-inline">{#if}</strong> blocks to conditionally render the component you need. Here is an example <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Input from './Input.svelte';
  import Checkbox from './Checkbox.svelte';
  import Select from './Select.svelte';
  let type = "input"; // Could be "checkbox" or "select"
&lt;/script&gt;
{#if type === "input"}
  &lt;Input value={value} onChange={onChange} /&gt;
{:else if type === "checkbox"}
  &lt;Checkbox value={value} onChange={onChange} /&gt;
{:else}
  &lt;Select value={value} onChange={onChange} /&gt;
{/if}</pre> <p>In the <a id="_idIndexMarker158"/>code snippet, we use the <strong class="source-inline">{#if}</strong> blocks to choose among<a id="_idIndexMarker159"/> three different component types, passing the same prop values to each. If you find yourself needing to manage more component types, this could lead to a lengthy and hard-to-maintain series of <span class="No-Break">conditional blocks.</span></p>
<p>Is there a more efficient way to <span class="No-Break">handle this?</span></p>
<p>Svelte provides two specialized elements, <strong class="source-inline">&lt;svelte:element&gt;</strong> and <strong class="source-inline">&lt;svelte:component&gt;</strong>, precisely for this. The <strong class="source-inline">&lt;svelte:element&gt;</strong> element lets you create different HTML element types dynamically, based on variable data, whereas the <strong class="source-inline">&lt;svelte:component&gt;</strong> element lets you dynamically render different Svelte <span class="No-Break">component types.</span></p>
<p>Here’s how you can rewrite the previous example <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">&lt;svelte:component&gt;</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import Input from './Input.svelte';
  import Checkbox from './Checkbox.svelte';
  import Select from './Select.svelte';
  let type = "input"; // Could be "checkbox" or "select"
<strong class="bold">  let DynamicComponent;</strong>
<strong class="bold">  if (type === "input") {</strong>
<strong class="bold">    DynamicComponent = Input;</strong>
<strong class="bold">  } else if (type === "checkbox") {</strong>
<strong class="bold">    DynamicComponent = Checkbox;</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    DynamicComponent = Select;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
<strong class="bold">&lt;svelte:component</strong>
<strong class="bold">  this={DynamicComponent}</strong>
<strong class="bold">  value={value}</strong>
<strong class="bold">  onChange={onChange}</strong>
<strong class="bold">/&gt;</strong></pre> <p>In the <a id="_idIndexMarker160"/>preceding code snippet, the <strong class="source-inline">DynamicComponent</strong> variable is used to hold the type of component that will be rendered. This component type is then passed to the <strong class="source-inline">this</strong> attribute within the <strong class="source-inline">&lt;svelte:component&gt;</strong> element. The <strong class="source-inline">&lt;svelte:component&gt;</strong> element also accepts other props such as <strong class="source-inline">value</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">onChange</strong></span><span class="No-Break">.</span></p>
<p>With the <a id="_idIndexMarker161"/>preceding code, what happens is that <strong class="source-inline">&lt;svelte:component&gt;</strong> renders the designated component stored in the <strong class="source-inline">this</strong> attribute, simultaneously forwarding any props passed to <strong class="source-inline">&lt;svelte:component&gt;</strong> to this dynamically rendered component. For example, if the value of <strong class="source-inline">DynamicComponent</strong> is the <strong class="source-inline">Select</strong> component, then the preceding code is effectively the same as <span class="No-Break">this code:</span></p>
<pre class="source-code">
&lt;Select value={value} onChange={onChange} /&gt;</pre> <p>By using <strong class="source-inline">&lt;svelte:component&gt;</strong>, we simplify the code and make it more maintainable. It’s also easier to extend; adding another form element type would only require an additional condition <span class="No-Break">and assignment.</span></p>
<p>Now that we’ve explored the use of <strong class="source-inline">&lt;svelte:component&gt;</strong>, let’s look at <strong class="source-inline">&lt;svelte:element&gt;</strong>, which follows a similar pattern. The following is a sample code snippet that demonstrates the usage <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">&lt;svelte:element&gt;</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  let type = 'button'; // could be 'div', 'p', 'a', etc.
&lt;/script&gt;
&lt;svelte:element this={type}&gt;
  Click Me
&lt;/svelte:element&gt;</pre> <p>In the <a id="_idIndexMarker162"/>preceding code snippet, the <strong class="source-inline">type</strong> variable holds the type of HTML element we want to render – in this example, it’s <strong class="source-inline">button</strong>. The <strong class="source-inline">&lt;svelte:element&gt;</strong> tag dynamically creates an HTML element of the type specified by <strong class="source-inline">type</strong>. So, if <strong class="source-inline">type</strong> is <strong class="source-inline">'button'</strong>, this will render as a <strong class="source-inline">&lt;button&gt;</strong> element, containing the text <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Click Me"</strong></span><span class="No-Break">.</span></p>
<p>This <a id="_idIndexMarker163"/>approach is particularly useful when you want to switch the type of an HTML element, based on some condition, without having to rewrite the entire block of code. All you need to do is change the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">type</strong></span><span class="No-Break">.</span></p>
<p>To summarize, <strong class="source-inline">&lt;svelte:element&gt;</strong> and <strong class="source-inline">&lt;svelte:component&gt;</strong> offer a more efficient and maintainable way to handle dynamic rendering needs. They provide a robust alternative to multiple <strong class="source-inline">{#if}</strong> blocks, making your Svelte applications more flexible and easier <span class="No-Break">to manage.</span></p>
<p>Sometimes, when designing Svelte components for data visualization, we encounter recursive data structures. In such cases, we need to build components that can recursively render themselves. Let’s delve into how we can accomplish <span class="No-Break">this next.</span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Creating recursive components for recursive data</h1>
<p>A <strong class="bold">recursive data structure</strong> is a <a id="_idIndexMarker164"/>data structure that is defined in terms of itself, meaning that it can be composed of smaller instances of the same type of structure. Recursive data<a id="_idIndexMarker165"/> is everywhere – think of a comment section where replies can have their own sub-replies, or a filesystem with nested folders. Creating a component to display them in a frontend application can <span class="No-Break">be challenging.</span></p>
<p>Imagine we have a variable called <strong class="source-inline">folder</strong>, which is an array containing either files or additional folders. In this example, the <strong class="source-inline">folder</strong> variable could look <span class="No-Break">like this:</span></p>
<pre class="source-code">
const folder = [
  { type: 'file', name: 'a.js' },
  { type: 'file', name: 'b.js' },
  { type: 'folder', name: 'c', children: [
    { type: 'file', name: 'd.js' },
  ]},
];</pre> <p>Currently, our <strong class="source-inline">folder</strong> variable is two levels deep. To represent this structure in a Svelte <a id="_idIndexMarker166"/>component, you might think to use nested <strong class="source-inline">{#</strong><span class="No-Break"><strong class="source-inline">each}</strong></span><span class="No-Break"> blocks:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let folder;
&lt;/script&gt;
&lt;ul&gt;
  {#each folder as item}
    &lt;li&gt;
      {#if item.type === 'file'}
        &lt;div&gt;File: {item.name}&lt;/div&gt;
      {:else}
        &lt;div&gt;Folder: {item.name}&lt;/div&gt;
        &lt;ul&gt;
          {#each item.children as child}
            &lt;li&gt;
              {#if child.type === 'file'}
                &lt;div&gt;File: {child.name}&lt;/div&gt;
              {:else}
                ...
              {/if}
            &lt;/li&gt;
          {/each}
        &lt;/ul&gt;
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker167"/>preceding code snippet, we used an <strong class="source-inline">{#each}</strong> block to iterate over the items in the <strong class="source-inline">folder</strong> variable, rendering either a file or a folder based on <strong class="source-inline">item.type</strong>. If <strong class="source-inline">item.type</strong> is a folder, we use another nested <strong class="source-inline">{#each}</strong> block to go through <span class="No-Break">its contents.</span></p>
<p>However, here’s the catch – the inner folder could also contain files or additional folders, making it recursive. As a result, we end up with repeated code for the inner and outer <strong class="source-inline">{#each}</strong> blocks. This works fine for a folder structure that’s only two levels deep, but what if it’s more complex? How can we avoid duplicating the same code for each level <span class="No-Break">of nesting?</span></p>
<p>Svelte offers an elegant solution to handle such recursive structures with the <strong class="source-inline">&lt;svelte:self&gt;</strong> element. The <strong class="source-inline">&lt;svelte:self&gt;</strong> element allows a component to embed itself within its own markup, thus making it easier to handle <span class="No-Break">recursive data.</span></p>
<p>Here’s the updated code using the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">svelte:self&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let folder;
&lt;/script&gt;
&lt;ul&gt;
  {#each folder as item}
    &lt;li&gt;
      {#if item.type === 'file'}
        &lt;div&gt;File: {item.name}&lt;/div&gt;
      {:else}
        &lt;div&gt;Folder: {item.name}&lt;/div&gt;
        <strong class="bold">&lt;svelte:self folder={item.children} /&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker168"/>updated code snippet, we replaced the nested <strong class="source-inline">{#each}</strong> block with <strong class="source-inline">&lt;svelte:self folder={item.children} /&gt;</strong>. This effectively re-renders the current component, passing <strong class="source-inline">item.children</strong> as the <span class="No-Break"><strong class="source-inline">folder</strong></span><span class="No-Break"> prop.</span></p>
<p>The beauty of this is that it eliminates the need to initiate a new <strong class="source-inline">&lt;ul&gt;</strong> element and duplicate <strong class="source-inline">{#each}</strong> blocks for each nesting level. Instead, the component simply reuses itself, making it capable of handling nested structures of <span class="No-Break">any depth.</span></p>
<p>When comparing this with the previous code snippet, you can immediately see the advantage – it’s much cleaner and avoids repetitive code, making it easier to read and maintain, and it scales naturally to handle any level of <span class="No-Break">nested folders.</span></p>
<p>Now that we’ve discussed how to tackle recursive data with <strong class="source-inline">&lt;svelte:self&gt;</strong>, let’s look at a practical example in the following section, where we will create a Svelte-based JSON <span class="No-Break">tree viewer.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Example – a JSON tree viewer</h1>
<p>In this section, we <a id="_idIndexMarker169"/>will walk you through building a JSON tree viewer component in Svelte. The JSON tree viewer component helps you visualize JSON data in a tree-like format. Along the way, we’ll make use of some of the advanced Svelte features we’ve covered in this chapter, including <strong class="source-inline">&lt;svelte:self&gt;</strong>, <strong class="source-inline">&lt;svelte:component&gt;</strong>, <span class="No-Break">and slots.</span></p>
<p>Before we start, let’s think <a id="_idIndexMarker170"/>about what our JSON Tree Viewer should look like and how it should behave. Essentially, a JSON object is made up of key-value pairs, where the values can be either primitives, arrays, or other nested objects. Our goal is to display these key-value pairs in a way that clearly represents the hierarchical structure of the <span class="No-Break">JSON object.</span></p>
<p>So, let’s create a <strong class="source-inline">JsonTree</strong> component for our JSON <span class="No-Break">tree viewer:</span></p>
<pre class="source-code">
&lt;!-- filename: JsonTree.svelte --&gt;
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;{key}: {value}&lt;li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the <a id="_idIndexMarker171"/>preceding code snippet, we defined a <strong class="source-inline">JsonTree</strong> component that accepts data as a prop. Inside this component, we utilize Svelte’s <strong class="source-inline">{#each}</strong> block to generate a list of <strong class="source-inline">&lt;li&gt;</strong> elements. Each element displays a key-value pair from the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> object.</span></p>
<p>However, these values can vary. They could be primitive types or nested objects. Take the <span class="No-Break">following example:</span></p>
<pre class="source-code">
data = {
  name: 'John Doe',
  address: {
    street: '123 Main St'
  },
}</pre> <p>In the preceding <strong class="source-inline">data</strong> object, the <strong class="source-inline">name</strong> key has a primitive string value, while the value for the <strong class="source-inline">address</strong> key is an object. For nested objects like this, we will need to use our <strong class="source-inline">JsonTree</strong> component recursively to render that nested object. This is where <strong class="source-inline">&lt;svelte:self&gt;</strong> comes <span class="No-Break">into play.</span></p>
<p>Here’s the <span class="No-Break">updated code:</span></p>
<pre class="source-code">
&lt;!-- filename: JsonTree.svelte --&gt;
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      {key}:
<strong class="bold">      {#if typeof value === 'object'}</strong>
<strong class="bold">        &lt;svelte:self data={value} /&gt;</strong>
<strong class="bold">      {:else}</strong>
<strong class="bold">        {value}</strong>
<strong class="bold">      {/if}</strong>
    &lt;li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In this <a id="_idIndexMarker172"/>updated code snippet, we introduced an <strong class="source-inline">{#if}</strong> block that renders differently based on whether the value is a primitive type or a nested object. For nested objects, we recursively render another <strong class="source-inline">JsonTree</strong> component using <strong class="source-inline">&lt;svelte:self&gt;</strong>. This allows us to elegantly handle JSON objects of <span class="No-Break">any depth.</span></p>
<p>Now, in our current implementation, we haven’t made distinctions between different types of primitive values. Suppose you’d like to render various primitive types using specialized Svelte components. In that case, you could dynamically switch between different component types <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">&lt;svelte:component&gt;</strong></span><span class="No-Break">.</span></p>
<p>Let’s assume you have three separate Svelte components – <strong class="source-inline">StringValue</strong> for strings, <strong class="source-inline">NumberValue</strong> for numbers, and <strong class="source-inline">JsonValue</strong> for others (such as Booleans, <strong class="source-inline">null</strong>, and <strong class="source-inline">undefined</strong>). Here is how you can <a id="_idIndexMarker173"/>update the code to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">&lt;svelte:component&gt;</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  import StringValue from './StringValue.svelte';</strong>
<strong class="bold">  import NumberValue from './NumberValue.svelte';</strong>
<strong class="bold">  import JsonValue from './JsonValue.svelte';</strong>
  export let data;
<strong class="bold">  function getComponent(type) {</strong>
<strong class="bold">    if (type === 'string') return StringValue;</strong>
<strong class="bold">    if (type === 'number') return NumberValue;</strong>
<strong class="bold">    return JsonValue;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      {key}:
      {#if typeof value === 'object'}
        &lt;svelte:self data={value} /&gt;
      {:else}
        <strong class="bold">&lt;svelte:component this={getComponent(typeof value)} value={value} /&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the updated code snippet, we created a utility function named <strong class="source-inline">getComponent</strong> to determine which component to render, based on the type of the primitive value. We then used <strong class="source-inline">&lt;svelte:component this={getComponent(typeof value)} /&gt;</strong> to dynamically load the appropriate component for each primitive type, allowing our <strong class="source-inline">JsonTree</strong> component to switch to different components for different types <span class="No-Break">of data.</span></p>
<p>Lastly, to <a id="_idIndexMarker174"/>make our JSON tree viewer more versatile, we can introduce named slots to customize the appearance of keys and values. By doing so, users can easily tailor the look of these elements according to their needs, while keeping our current design as the default fallback. Let’s update the code to add the two <span class="No-Break">named slots:</span></p>
<pre class="source-code">
&lt;ul&gt;
  {#each Object.entries(data) as [key, value]}
    &lt;li&gt;
      <strong class="bold">&lt;slot name="obj-key" key={key}&gt;</strong>{key}:<strong class="bold">&lt;slot&gt;</strong>
      {#if typeof value === 'object'}
        &lt;svelte:self data={value} /&gt;
      {:else}
        <strong class="bold">&lt;slot name="obj-value" value={value}&gt;</strong>
          &lt;svelte:component this={getComponent(typeof value)} value={value} /&gt;
        <strong class="bold">&lt;/slot&gt;</strong>
      {/if}
    &lt;/li&gt;
  {/each}
&lt;/ul&gt;</pre> <p>In the updated code, we added two named slots – one to customize keys, called <strong class="source-inline">"obj-key"</strong>, and another to customize values, called <strong class="source-inline">"obj-value"</strong>. These slots receive the current <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> as slot props, enabling you to tailor their appearance in the <span class="No-Break">parent component.</span></p>
<p>For instance, if you wish to change how keys and values are displayed, here’s how you can write in your <span class="No-Break">parent component:</span></p>
<pre class="source-code">
&lt;JsonTree data={{a: 1, b: 2}}&gt;
  &lt;svelte:fragment slot="obj-key" let:key&gt;
    &lt;em&gt;{key}&lt;/em&gt;
  &lt;/svelte:fragment&gt;
  &lt;svelte:fragment slot="obj-value" let:value&gt;
    &lt;u&gt;{value}&lt;/u&gt;
  &lt;/svelte:fragment&gt;
&lt;/JsonTree&gt;</pre> <p>Here, we <a id="_idIndexMarker175"/>use Svelte’s <strong class="source-inline">&lt;svelte:fragment&gt;</strong> special element to target the named slots, <strong class="source-inline">"obj-key"</strong> and <strong class="source-inline">"obj-value"</strong>, in our <strong class="source-inline">JsonTree</strong> component. The <strong class="source-inline">let:key</strong> and <strong class="source-inline">let:value</strong> syntax allows us to access the current key and value being <span class="No-Break">rendered, respectively.</span></p>
<p>In the <strong class="source-inline">&lt;svelte:fragment&gt;</strong> element, we wrapped the key in an <strong class="source-inline">&lt;em&gt;</strong> tag and the value in a <strong class="source-inline">&lt;u&gt;</strong> tag, offering custom styling for these elements. This customization overrides the default rendering provided by the <strong class="source-inline">JsonTree</strong> component. If you don’t specify any custom content, the component will fall back to its default rendering, offering both robustness <span class="No-Break">and flexibility.</span></p>
<p>By combining <strong class="source-inline">&lt;svelte:self&gt;</strong> for recursion, <strong class="source-inline">&lt;svelte:component&gt;</strong> for dynamic behavior, and slots for customization, we have created a flexible and powerful JSON tree viewer. This not only demonstrates Svelte’s capability to handle complex UI patterns but also serves as a practical example of component composition <span class="No-Break">in Svelte.</span></p>
<p>You can find the complete code for this exercise <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree%0D"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree</span></a><span class="No-Break">.</span></p>
<p>Before we wrap up this chapter, let us take a moment to discuss a helpful common pattern to organize our components, the <span class="No-Break">Container/Presentational pattern.</span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>The Container/Presentational pattern</h1>
<p>As your application <a id="_idIndexMarker176"/>scales in complexity, you may find it beneficial to adopt specific design patterns or guidelines to structure components. One such approach is the <strong class="bold">Container/Presentational pattern</strong>, which divides a component into two categories, the Container component and the <span class="No-Break">Presentational component:</span></p>
<ul>
<li><em class="italic">Container components</em> focus on <a id="_idIndexMarker177"/>functionality. They handle data fetching, state management, and user interactions. While they usually don’t <a id="_idIndexMarker178"/>render <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) elements themselves, they wrap around Presentational components and supply them with data <span class="No-Break">and actions.</span></li>
<li><em class="italic">Presentational components</em> are all <a id="_idIndexMarker179"/>about the user interface. They get their data and event-handling functions exclusively through props, making them highly reusable and straightforward <span class="No-Break">to test.</span></li>
</ul>
<p>A common scenario where you’ll see this pattern in action is when using a UI component library. In this case, the library’s components serve as the presentational elements, focusing solely on how things look. Meanwhile, the components you create that utilize these library elements act as Container components, managing data and handling interactions such as clicks, typing, <span class="No-Break">and dragging.</span></p>
<p>The Component/Presentational pattern<a id="_idIndexMarker180"/> is useful in a <span class="No-Break">few aspects:</span></p>
<ul>
<li><strong class="bold">Simplicity</strong>: Separating behavior from appearance makes your codebase easier to understand <span class="No-Break">and maintain</span></li>
<li><strong class="bold">Reusability</strong>: Since Presentational components are agnostic about data sources or user actions, you can reuse them in different parts of <span class="No-Break">your application</span></li>
<li><strong class="bold">Collaboration</strong>: With this division, designers can work on the Presentational components while developers focus on the Container components, <span class="No-Break">streamlining development</span></li>
</ul>
<p>As you come to appreciate the <a id="_idIndexMarker181"/>benefits of the Component/Presentational pattern, there are specific situations where I think you should consider using it, such as <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">When your application starts to grow</strong>: Managing everything in a single component can become confusing as <span class="No-Break">complexity increases</span></li>
<li><strong class="bold">When you find yourself repeating the same UI patterns</strong>: Creating reusable Presentational components can save time in the <span class="No-Break">long run</span></li>
<li><strong class="bold">When your team scales</strong>: As your development team grows, having a standardized way of building components can reduce learning curves and prevent <span class="No-Break">code conflicts</span></li>
</ul>
<p>While the Container/Presentational pattern <a id="_idIndexMarker182"/>offers a structured approach to organizing your components, it’s not always the best fit – especially for smaller applications, where it might be overkill. Hopefully, with the insights provided, you’ll be better equipped to make <span class="No-Break">informed decisions.</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Summary</h1>
<p>In this chapter, we delved into various strategies for component composition in Svelte, each offering its own set of advantages and applicable scenarios. Mastering these techniques will equip you to build Svelte applications that are not only more dynamic but also easier to maintain <span class="No-Break">and scale.</span></p>
<p>We kicked off by discussing multiple ways to influence a child component. These ranged from controlling props or using Svelte’s context to customizing styles via CSS custom properties, and even dynamically passing content <span class="No-Break">through slots.</span></p>
<p>Then, we turned our attention to some of Svelte’s special elements. We explored <strong class="source-inline">&lt;svelte:element&gt;</strong> and <strong class="source-inline">&lt;svelte:component&gt;</strong> to dynamically render various HTML elements and Svelte components. We also learned about <strong class="source-inline">&lt;svelte:self&gt;</strong>, which allows a component to reference itself, thereby facilitating the creation of recursive UI structures. We then applied these newfound skills to build a JSON tree viewer as an <span class="No-Break">illustrative example.</span></p>
<p>Finally, we touched upon a popular design pattern – the Container/Presentational pattern. We examined its advantages and considered scenarios where it would be beneficial to employ <span class="No-Break">this approach.</span></p>
<p>Armed with these advanced techniques, you are now better prepared to tackle complex challenges in your Svelte projects. As we conclude our four-chapter exploration of writing Svelte components, we’ll shift our focus in the upcoming chapter to another fundamental feature of Svelte – <span class="No-Break">Svelte actions.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer019">
<h1 id="_idParaDest-78" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor079"/>Part 2: Actions</h1>
<p>In this part, we embark on a journey to learn about Svelte actions. Across three chapters, we will delve into three different use cases of Svelte actions. Starting with the creation of custom events using actions, we’ll progress to integrating third-party JavaScript libraries with Svelte via actions. Finally, we’ll unveil techniques to progressively enhance our applications, harnessing the power of <span class="No-Break">Svelte actions.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18887_05.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Custom Events with Actions</em></li>
<li><a href="B18887_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Libraries with Actions</em></li>
<li><a href="B18887_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, <em class="italic">Progressive Enhancements with Svelte Actions</em></li>
</ul>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer021">
</div>
</div>
</div></body></html>