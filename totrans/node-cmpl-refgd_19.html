<html><head></head><body><div><h1 class="header-title">The Age of Microservices</h1>
                
            
            
                
<p>Decades ago, more specifically in 1974, Intel introduced 8080 to the world, which is an 8-bit processor with a 2 MHz clock speed and 64 KB of memory. This processor was used in Altair and began the revolution in personal computers.</p>
<p>It was sold pre-assembled or as a kit for hobbyists. It was the first computer to have enough power to actually be used for calculations. Even though it had some poor design choices and needed an engineering major to be able to use and program it, it started the spread of personal computers to the general public.</p>
<p>The technology evolved rapidly and the processor industry followed Moore's law, almost doubling speed every two years. Processors were still single core, with a low-efficiency ratio (power consumption per clock cycle). Because of this, servers usually did one specific job, called a service, like serving HTTP pages or managing a <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) directory. Services were the monolith, with very few components, and were compiled altogether to be able to take the most out of the hardware processor and memory.</p>
<p>In the 90s, the internet was still only available for the few. Hypertext, based on HTML and HTTP, was in its infancy. Documents were simple and browsers developed language and protocol as they pleased. Competition for market share was ferocious between Internet Explorer and Netscape. The latter introduced JavaScript, which Microsoft copied as JScript:</p>
<p class="mce-root"/>
<div><img src="img/e38df4a8-338d-4077-b40f-ec079f5ad490.png" width="381" height="221"/></div>
<p>Simple single-core servers</p>
<p>After the turn of the century, processor speed continued to increase, memory grew to generous sizes, and 32-bit became insufficient for allocating memory addresses. The all-new 64-bit architecture appeared and personal computer processors hit the 100 W consumption mark. Servers gained muscle and were able to handle different services. Developers still avoided breaking the service into parts. Interprocess communication was considered slow and services were kept in threads, inside a single process.</p>
<p>The internet was starting to become largely available. Telcos started offering triple play, which included the internet bundled with television and phone services. Cellphones became part of the revolution and the age of the smartphone began.</p>
<p>JSON appeared as a subset of the JavaScript language, although it's considered a language-independent data format. Some web services began to support the format.</p>
<p class="mce-root"/>
<p>The following is an example of servers with a couple of services running, but still having only one processor.</p>
<div><img src="img/dd8fac4c-1cd8-47af-9711-192faa7cdedf.png" width="381" height="221"/></div>
<p>Powerful but single-core servers</p>
<p>Processor evolution then shifted. Instead of the increased speed that we were used to, processors started to appear with two cores, and then four cores. Eight cores followed, and it seemed the evolution of the computer would follow this path for some time.</p>
<p>This also meant a shift in architecture in the development paradigms. Relying on the system to take advantage of all processors is unwise. Services started to take advantage of this new layout and now it's common to see services having at least one processor per core. Just look at any web server or proxy, such as Apache or Nginx.</p>
<p>The internet is now widely available. Mobile access to the internet and its information corresponds to more or less half of all internet access.</p>
<p>In 2012, the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) began its first drafts for the second version of HTTP or HTTP/2, and <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) did the same for HTML/HTML5, as both standards were old and needed a remake. Thankfully, browsers agreed on merging new features and specifications and developers no longer have the burden of developing and testing their ideas on the different browser edge cases.</p>
<p>The following is an example of servers with more services running as we reach a point where each server has more than one processor:</p>
<div><img src="img/d535ce61-66e6-4f4c-865e-af2ef9e9725b.png" width="391" height="221"/></div>
<p>Powerful multi-core servers</p>
<p>Access to information in real time is a growing demand. The <strong>Internet of Things</strong> (<strong>IoT</strong>) multiplies the number of devices connected to the internet. People now have a couple of devices at home, and the number will just keep rising. Applications need to be able to handle this growth.</p>
<p>On the internet, HTTP is the standard protocol for communication. Routers usually do not block it, as it is considered a low traffic protocol (in contrast with video streams). This is actually not true nowadays, but it's now so widely used that changing this behavior would probably cause trouble.</p>
<p>Nowadays, it's actually so common to have the HTTP serving developer API working with JSON that most programming languages that release any version after 2015 probably support this data format natively.</p>
<p>As a consequence of processor evolution, and because of the data-demanding internet we now have, it's important to not only be able to scale a service or application to the several available cores, but also to scale outside a single hardware machine.</p>
<p>Many developers started using and following the <strong>Service-Oriented Architecture</strong> (<strong>SOA</strong>) principle. It's a principle where the architecture is focused on services, and each service presents itself to others as an application component and provides information to other application components, passing messages over some standard communication protocol.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">From monolith to microservices</h1>
                
            
            
                
<p>As we described previously, a microservices architecture is based on a loosely coupled set of services that work together to achieve a specific target application. At the end of the spectrum, there are monolith applications.</p>
<p>A monolith application is composed of a set of components that are tightly coupled. These components are usually developed using the same language and the application runs as a whole. The first noticeable difference is probably the slow start. Deploying might also be slow since you might need a couple of dependencies before having anything up and running.</p>
<p>Let's imagine an event application, a simple one, an application that lets users define events and be notified when those events are about to start.</p>
<div><img src="img/893a307a-7fcd-4a7d-9639-5341fbfe5906.png" width="551" height="221"/></div>
<p>A monolith event application</p>
<p>Let's describe what the event application does:</p>
<ul>
<li class="mce-root">It allows users to register themselves and add events to a calendar</li>
<li>A few minutes before the event starts (that's what the <strong>Scheduler</strong> component is for), the users receive an email with the event information (that's the <strong>SMTP</strong> component)</li>
<li>Users can use the frontend interface or the <strong>API</strong> interface</li>
</ul>
<p>Imagine the preceding application as being a monolith (the greyed out area on the right).</p>
<p>Imagine that all four parts are part of the same process, even though they could be in separate threads. Imagine that the database is accessed directly across the application. Sound good?</p>
<p>Well, it sounds terrible, perhaps not for a small application, but for a medium one, this would be a representation of chaos. Having a group of developers making new features or improvements would be a nightmare, and for new developers entering the group, it would take some time before having the base knowledge to make some changes.</p>
<p>The first principle that you should follow is the <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) principle. Avoiding multiple components from accessing a data source helps developers in the future. Later on, if there's a need to change the data source or part of its structure, it will be easier if only one component manipulates it. This is not always possible, but if it is possible, you should keep the data source access to a minimum.</p>
<p>In our example, the API should probably have access, and all others should use the API.</p>
<div><img src="img/debed603-fdb0-4f0b-9c31-5fea32261ec8.png" width="553" height="261"/></div>
<p>A single service accessing a data source</p>
<p>We now have two services:</p>
<ul>
<li class="mce-root">The API, which is the only service accessing the data source</li>
<li>The frontend, which is the user's interface to change the data source</li>
</ul>
<p>Although the frontend is used to manage events, it uses the API service to manipulate data sources. Besides having only one service managing data sources, it forces you to think of the API for external developers. It's a win-win.</p>
<p>There is still room for improvement. The <strong>Frontend</strong> could be in a separate service, allowing you to scale the interface according to user traffic, and have the other parts on separate services. <strong>Scheduler</strong> and <strong>SMTP</strong> are both candidates for separate services. <strong>SMTP</strong> should be thought of as a reusable service for other applications you might develop later on.</p>
<p>Let's take a look at how we could build the same application using the microservices approach:</p>
<div><img src="img/034310f1-1917-4a3e-aa4e-0fba06ef39ea.png" width="550" height="261"/></div>
<p>A microservices event application</p>
<p>It looks more complex. Well, the architecture is more complex. The difference is that now, we have loosely coupled components, and each one of them is easily understandable and maintainable. Summing up the changes and advantages:</p>
<ul>
<li class="mce-root">The <strong>API</strong> is the only one accessing the database so it can change from SQLite, MongoDB, MySQL, or anything else, and no other component is affected</li>
<li><strong>SMTP</strong> can be used from the <strong>Frontend</strong> and <strong>Scheduler</strong>, and if you decide to change it from using a local service to using a third-party email sending <strong>API</strong>, you can make the change easily</li>
<li><strong>SMTP</strong> is a candidate for being a reusable service in other applications, meaning you can use it in other applications or event share the same service between multiple applications</li>
</ul>
<p>You can think of these components as capabilities of your application. They can be swapped, upgraded, maintained, and scaled, all without affecting other components or your application.</p>
<p>A commonly underestimated advantage of using this approach is that your application is much more resilient to failures. In a monolith application, any part can bring your application offline. In this microservices approach, this application might not send emails but can still be running and accessible. Add caching into the mixture and the API can restart in moments.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Patterns of microservices</h1>
                
            
            
                
<p>Microservices architecture, like other archicectures, has a set of patterns that are easily identifiable and form the basis for this application development approach.</p>
<p>Some of these patterns can make the initial bootstrap a burden and can eventually be postponed. Others are essential from the beginning or you will have difficulty, later on, in migrating to a full microservice approach.</p>
<p>The following patterns are not an extensive list but they represent a solid foundation:</p>
<div><img src="img/c78fda11-0afc-49b7-a839-6acb6be49f58.png" style="width:28.58em;height:16.67em;" width="490" height="285"/></div>
<p>An example of services working together to form an application</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Decomposable</h1>
                
            
            
                
<p>The main pattern behind a microservice architecture is the ability to have loosely coupled services. These services are decomposed, separated into smaller parts. This decomposition should create a set of services that implement a set of strongly related functions.</p>
<p>Each service should be small but complete, meaning it should run a set of functions in a given context. Those functions should represent all the functions you need or need to support for that context. What this means is that if you have a service that handles meeting events, all meeting event functions should be done using that service, whether it's creating an event, changing, removing, or getting information about a specific event. This ensures that an implementation change to events will affect that service only.</p>
<p>Decomposing an application can take one of two main approaches:</p>
<ul>
<li>By capability, when a service has a specific power or set of powers, such as sending emails, regardless of its content</li>
<li>By subdomain, when a service has the complete knowledge of a subdomain or module of your application domain</li>
</ul>
<p>In our previous event application, a service that was decomposed by capability is, for example, the SMTP service. A service decomposed by the domain could be the API service, assuming the application only manages events:</p>
<div><img src="img/39cd716e-fc18-4160-bc96-9d49f3e99af8.png" width="658" height="295"/></div>
<p>An example of services being tested and deployed autonomously, instead of the whole application</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Autonomous</h1>
                
            
            
                
<p>In a microservice architecture, each service should be autonomous. A small team should be able to run it without the other services that make your application. That team should also be able to develop autonomously and make changes to implementation without affecting the application.</p>
<p>The development team should be able to:</p>
<ul>
<li>Test, creating business logic and unit tests to ensure the service functions work as expected</li>
<li>Deploy, upgrading functionality, without restarting other services in the process</li>
</ul>
<p>Services should be able to evolve regardless of others, keeping backward compatibility, adding new functions, and scaling to several locations, with minimal changes to the architecture:</p>
<div><img src="img/1dff5ae6-966b-4dbb-be33-8df99b86f0bb.png" width="492" height="284"/></div>
<p>An example of an application with two instances per service, making it fault-tolerant</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Scalable</h1>
                
            
            
                
<p>A service should be scalable. At least two instances should be able to run in parallel, enabling failure tolerance and maintenance downtime. A service can also, later on, scale geographically, be near your customers, and improve apparent performance and application response.</p>
<p>For this scaling to be effective, the application platform will need service discovery and routing, a service that could be used by other services to register themselves and expose their capabilities. Other services could, later on, inquire this service directory and know how to reach these capabilities.</p>
<p>To reduce complexity for other services, a service router can redirect requests to service instances. For example, to send emails, you could have three instances and one central router that would redirect requests in a round-robin manner. If any of those instances go offline, the router will stop redirecting to it and the rest of the application doesn't need to care about it.</p>
<p>Another approach could be to use a DNS approach. The name service is capable of handling registrations to a subdomain, and then, when another service makes simple requests, it will receive one or all of the addresses and connect it as if there was only one service operating:</p>
<div><img src="img/1fac72a0-5c63-4460-b7c0-70e529a6afc7.png" style="width:35.67em;height:20.92em;" width="489" height="286"/></div>
<p>An example of communication between services of an application</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Communicable</h1>
                
            
            
                
<p>Usually, services communicate over HTTP using a REST-compliant API. This is not a pattern that you must follow, but it's something that comes naturally based on how common HTTP is nowadays, making it an obvious choice.</p>
<p>There are plenty of HTTP servers out there, making it easy to expose a non-HTTP service with minimum effort.</p>
<p>HTTP is also a mature communication transport layer. It's a stateless protocol, giving developers and operations many features, such as:</p>
<ul>
<li>Caching commonly used and often updated resources</li>
<li>Proxying and routing requests</li>
<li>Securing communication over TLS</li>
</ul>
<p> </p>
<div><img src="img/3a5de26d-a878-480b-b568-3011eb16e22d.png" width="502" height="310"/></div>
<p>A complex application with several services and streams of communication</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In conclusion, microservices architecture is a good, clear pattern that helps tackle more complex projects. In the long term, it reduces the complexity associated with new projects by appealing to service reuse. It helps to structure an application into loosely coupled services that can be independently developed and tested by small, different teams. It comes at the cost of initial proper planning and a more complex deployment.</p>
<p>Before creating your first microservice, let's look at some Node.js tools that could eventually help you leverage your next big project. This is what we'll be covering in the next chapter.</p>


            

            
        
    </div>



  </body></html>