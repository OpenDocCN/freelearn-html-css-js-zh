<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor127"/>11</h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Replacing Behavior with a Side-By-Side Implementation</h1>
<p>In the previous two chapters you built out a fully formed repository and an API for accessing it. Now it’s time to complete the story arc by updating both the SvelteKit loader and form actions to use the API instead of the repository.</p>
<p>It’s worth pointing out that this isn’t a necessary step: it would be perfectly acceptable to keep the SvelteKit server pieces pointing directly at the repository.</p>
<p>But reworking our existing code to point at the new API endpoints will introduce you to two ideas: first, that of a <strong class="bold">side-by-side implementation</strong>, which is a way to use tests to replace the existing code while ensuring the test suite remains on <em class="italic">Green</em>. The second is the use of a test double to shield the unit tests from SvelteKit. The test double takes the place of the framework code, avoiding a real network call out to the API – which wouldn’t work anyway since the API isn’t running within our Vitest test suite.</p>
<p><em class="italic">Figure 11</em><em class="italic">.1</em> shows two views of our code base. The left side shows how the new architecture of our application code will look, with the SvelteKit route loaders and form actions pointing to the API endpoints. The right side shows how the unit tests for the router loaders and form actions will see the world. In this setup, the API endpoints are not accessed at all.</p>
<div><div><img alt="Figure 11.1 – Using a test double to plug SvelteKit behavior within unit test suites" height="638" src="img/Figure_11.1_B19611.jpg" width="1495"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Using a test double to plug SvelteKit behavior within unit test suites</p>
<p>After updating our SvelteKit components, we’ll wrap things up by updating the Playwright test to use the new API and stop the database seed data from appearing in test environments (both Playwright and Vitest).</p>
<p>This chapter covers the following key topics:</p>
<ul>
<li>Updating the route loader to use the API</li>
<li>Updating the page form action to use the API</li>
<li>Using a server hook to seed sample data</li>
</ul>
<p>By the end of the chapter, you’ll have seen how to use a <strong class="bold">spy</strong> (a form of test double) and the process of building a side-by-side implementation.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter11/Start</a>.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Updating the route loader to use the API</h1>
<p>In this section, you’ll introduce <a id="_idIndexMarker362"/>a call to the <code>GET</code> <code>/api/birthdays</code> endpoint <a id="_idIndexMarker363"/>using the SvelteKit fetch function. That will involve using a spy.</p>
<p class="callout-heading">What is a test spy?</p>
<p class="callout">A spy is a function that keeps a record of each time it is called, together with the arguments it is called <a id="_idIndexMarker364"/>with. It can then be inspected later to verify that it was called with the correct arguments. The spy is almost always a <em class="italic">stub</em> as well, meaning it avoids calling the real function entirely, instead returning a hardcoded – stubbed – value. The spy acts as a substitute for a real function.</p>
<p class="callout">In Vitest, a spy is created by calling the <code>vi.fn</code> function.</p>
<p>When we use a test spy, you’ll have at least one test that checks the arguments passed to the spy. Then you’ll have at least one more test for each stubbed return value that the spy returns.</p>
<p>We will use a spy for the <code>fetch</code> function that mimics retrieving birthdays via the <code>GET</code> <code>/</code><code>api/birthdays</code> endpoint.</p>
<p class="callout-heading">Understanding the SvelteKit fetch function</p>
<p class="callout">SvelteKit provides a <code>fetch</code> parameter to the user-defined <code>load</code> function and to the form actions. The value <a id="_idIndexMarker365"/>of this parameter is a function that has the same semantics as the standard Fetch API provided by browsers. The difference is in mechanics: SvelteKit’s <code>fetch</code> function is able to short-cut calls made on the server so that they don’t cause an HTTP request but instead feed directly into the <code>GET</code> function that matches the route specified.</p>
<p>Let’s begin with a new factory method definition:</p>
<ol>
<li>Create a new file named <code>src/factories/fetch.js</code> and add the following definition. We will use this to build stub <code>Response</code> objects that the test spy will return:<pre class="source-code">
export const fetchResponseOk = (response = {}) =&gt; ({
  status: 'ok',
  json: () =&gt; Promise.resolve(response)
});</pre></li>
<li>Now open the test file at <code>src/routes/birthdays/page.server.test.js</code> and add an <code>import</code> statement to that function:<pre class="source-code">
import {
  fetchResponseOk
} from 'src/factories/fetch.js';</pre></li>
<li>Next, update <a id="_idIndexMarker366"/>the Vitest <code>import</code> statement <a id="_idIndexMarker367"/>to include an import for <code>vi</code>, like this:<pre class="source-code">
import {
  describe,
  it,
  expect,
  beforeEach<strong class="bold">,</strong>
  <strong class="bold">vi</strong>
} from 'vitest';</pre></li>
<li>Add the following test at the bottom of the <code>describe</code> block with the title <code>/birthdays - load</code>. In addition to creating a test spy with a call to <code>vi.fn()</code>, this also uses the <code>mockResolvedValue</code> function to specify that the spy should return a value wrapped in a <code>Promise</code> object. The test concludes with the <code>toBeCalledWith</code> matcher to verify that the spy is called in the right way:<pre class="source-code">
describe('/birthdays - load', () =&gt; {
  ...
  it('calls fetch with /api/birthdays', async () =&gt; {
    const fetch = vi.fn();
    fetch.mockResolvedValue(fetchResponseOk());
    const result = await load({ fetch });
    expect(fetch).toBeCalledWith('/api/birthdays');
  });
});</pre></li>
<li>To make that pass, we’ll start with a side-by-side implementation. That means the <a id="_idIndexMarker368"/>previous implementation remains in place <a id="_idIndexMarker369"/>alongside the new implementation. In the <code>src/routes/birthdays/+page.server.js</code> file, modify the <code>load</code> function so that it takes a <code>fetch</code> argument and then invokes it as the first thing it does, like this:<pre class="source-code">
export const load = (<strong class="bold">{ fetch }</strong>) =&gt; <strong class="bold">{</strong>
  <strong class="bold">fetch('/api/birthdays');</strong>
  <strong class="bold">return</strong> {
    birthdays: getAll()
  }
<strong class="bold">}</strong>;</pre></li>
</ol>
<p>This will cause the original test case to fail due to a missing value for <code>fetch</code>. We are about to delete this test, but for now, let’s humor ourselves by fixing the test.</p>
<ol>
<li value="6">Update the test case to use a very simple stub value for <code>fetch</code>, as shown in the following code. This highlights the fact that a Vitest spy created by <code>vi.fn</code> is not always necessary. If you’re not checking the spy, then a plain stub is enough:<pre class="source-code">
describe('/birthdays - load', () =&gt; {
  it('returns a fixture of two items', () =&gt; {
    const result = load(<strong class="bold">{ fetch: () =&gt; {} }</strong>);
    ...
  });
});</pre></li>
<li>Continue by <a id="_idIndexMarker370"/>writing the second test, which checks <a id="_idIndexMarker371"/>that the <code>load</code> function returns whatever data came back from <code>fetch</code>. This time, we need to pass an actual value to <code>fetchResponseOk</code>, and compare that to the <code>return</code> value:<pre class="source-code">
describe('/birthdays - load', () =&gt; {
  ...
  it('returns the response body', async () =&gt; {
    const birthdays = [
      createBirthday('Hercules', '1994-02-02'),
      createBirthday('Athena', '1989-01-01')
    ];
    const fetch = vi.fn();
    fetch.mockResolvedValue(
      fetchResponseOk({ birthdays })
    );
    const result = await load({ fetch });
    expect(result).toEqual({ birthdays });
  });
});</pre></li>
<li>Go ahead and update the <code>load</code> function to return this value:<pre class="source-code">
export const load = async ({ fetch }) =&gt; {
  const result = await fetch('/api/birthdays');
  return <strong class="bold">result.json();</strong>
};</pre></li>
<li>You might have noticed this is in direct conflict with the original test we wrote. When we build <a id="_idIndexMarker372"/>a side-by-side implementation, the <a id="_idIndexMarker373"/>final step is often switching out the return value. When that happens, it’s time to delete the original test. So, go ahead and delete the original test – the only one titled <em class="italic">returns a fixture of two items</em> – since it no longer applies.</li>
<li>Finally, remove the <code>getAll</code> import from the <code>+</code><code>page.server.js</code> file:<pre class="source-code">
import {
  addNew,
  replace
} from '$lib/server/birthdayRepository.js';</pre></li>
</ol>
<p>You’ve now seen how to use <code>vi.fn</code> to create a test spy for testing <code>fetch</code> calls and a basic side-by-side implementation. The next section repeats the same process for the page form action, but this time the implementation is more complex.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Updating the page form action to use the API</h1>
<p>In the section, we <a id="_idIndexMarker374"/>will update the page form action to <a id="_idIndexMarker375"/>use the new <code>POST</code> and <code>PUT</code> methods on the API endpoints instead of the <code>addNew</code> and <code>replace</code> functions of the repository.</p>
<p>This will be done using the same side-by-side technique of the previous section, but this time it’s more involved. We still need tests to verify that the spy is called with the right parameters and that the return value is given. But now we also need to verify that errors are converted to SvelteKit form failures, since the form action has separate handling for errors.</p>
<p>Another important change here is that we will use two tests for checking the parameters passed to the <code>fetch</code> call. This is a powerful technique when faced with complex arguments where there are <em class="italic">clumps</em> of arguments that have separate meanings.</p>
<p>In the case of fetch, the <a id="_idIndexMarker376"/>URL and the HTTP verb are one <em class="italic">clump</em>: we <a id="_idIndexMarker377"/>can have a single test that verifies, for example, that we’re calling the <code>POST</code> <code>/api/birthdays</code> endpoint. But there’s also the <code>body</code> property, and since that isn’t static data – it changes depending on the form action input parameters – it seems sensible to give that a test of its own.</p>
<p>Finally, since the API endpoints are performing data validation, we no longer need that functionality. So we’ll finish by deleting that implementation and its related tests.</p>
<p>Let’s get started by updating the existing <code>describe</code> block with some new setup:</p>
<ol>
<li>Find the <code>describe</code> block named <code>/birthdays - default action</code> and add the following three pieces of setup: a <code>fetch</code> variable that can be accessed in all tests; a new <code>beforeEach</code> block to set up the <code>fetch</code> response; and an updated <code>performFormAction</code> method that passes in the <code>fetch</code> argument:<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  <strong class="bold">const fetch = vi.fn();</strong>
  <strong class="bold">beforeEach(() =&gt; {</strong>
  <strong class="bold">  fetch.mockResolvedValue(fetchResponseOk());</strong>
  <strong class="bold">});</strong>
  const performFormAction = (formData) =&gt;
    actions.default({
      request: createFormDataRequest(formData)<strong class="bold">,</strong>
<strong class="bold">      fetch</strong>
    });
  ...
});</pre></li>
<li>Then, add this <a id="_idIndexMarker378"/>new nested <code>describe</code> block <a id="_idIndexMarker379"/>with its single test below all the existing tests. It checks that the <code>fetch</code> spy has been called with the correct URL and <code>method</code> of <code>POST</code>:<pre class="source-code">
describe('when adding a new birthday', () =&gt; {
  it('requests data from POST /api/birthdays', async
  () =&gt; {
    await performFormAction(
      createBirthday('Zeus', '2009-02-02')
    );
    expect(fetch).toBeCalledWith(
      '/api/birthdays',
      expect.objectContaining({ method: 'POST' })
    );
  });
});</pre></li>
<li>To make that pass, start by adding the <code>fetch</code> argument into the form action:<pre class="source-code">
export const actions = {
  default: async ({ request<strong class="bold">, fetch</strong> }) =&gt; {
  ...
}</pre></li>
<li>Then, make a start on the side-by-side implementation. Find the call to <code>addNew</code>, and just below it, add a new call to <code>fetch</code>, as shown here:<pre class="source-code">
let result;
if (id) {
  ...
} else {
  result = addNew({ name, dob });
  <strong class="bold">await fetch('/api/birthdays', {</strong>
  <strong class="bold">  method: 'POST'</strong>
  <strong class="bold">});</strong>
}</pre></li>
<li>For the next test, we <a id="_idIndexMarker380"/>have a very similar test which is <a id="_idIndexMarker381"/>still testing the arguments to the <code>fetch</code> spy, but this time checking the varying portion of it: the <code>body</code> property. Add that test now:<pre class="source-code">
it('sends the birthday as the request body', async () =&gt; {
  await performFormAction(
    createBirthday('Zeus', '2009-02-02')
  );
  expect(fetch).toBeCalledWith(
    expect.anything(),
    expect.objectContaining({
      body: JSON.stringify({
        name: 'Zeus',
        dob: '2009-02-02'
      })
    })
  );
});</pre></li>
</ol>
<p>The preceding code sample makes use of a helper function called <code>expect.anything</code>, which you also saw in <a href="B19611_10.xhtml#_idTextAnchor119"><em class="italic">Chapter 10</em></a>, <em class="italic">Test-Driving API Endpoints</em>. Since we already have a previous test that checks the value of the first argument, we can avoid repeating ourselves by checking it here and simultaneously relax the expectation so that the tests are kept independent of each other.</p>
<p>Using this helper <a id="_idIndexMarker382"/>also aids with the readability of the <a id="_idIndexMarker383"/>test by focusing the reader’s attention on what’s specifically of interest: the second argument, not the first.</p>
<ol>
<li value="6">To make that pass, update the <code>fetch</code> call from <em class="italic">step 4</em> to include the <code>body</code> property:<pre class="source-code">
await fetch('/api/birthdays', {
  method: 'POST'<strong class="bold">,</strong>
  <strong class="bold">body: JSON.stringify({ name, dob })</strong>
});</pre></li>
<li>Now let’s handle the error case. For this, we need a new factory for an error response. In <code>src/factories/fetch.js</code>, add the following definition for <code>fetchResponseError</code>:<pre class="source-code">
export const fetchResponseError = (errorMessage) =&gt; ({
  status: 'error',
  json: () =&gt;
    Promise.resolve({ message: errorMessage })
});</pre></li>
<li>Then import it into your test suite:<pre class="source-code">
import {
  fetchResponseOk<strong class="bold">,</strong>
<strong class="bold">  fetchResponseError</strong>
} from 'src/factories/fetch.js';</pre></li>
<li>We’re ready for the next test. This test checks what happens when an error occurs. Since our spy has no real logic, we don’t care about the <em class="italic">specifics</em> of the error. We just <a id="_idIndexMarker384"/>need it to trigger the same behavior <a id="_idIndexMarker385"/>as the real code. That means having a non-<code>ok</code> status message, just like the <code>fetchResponseError</code> factory gives us. To make it clear that it’s not real logic, I’ve used an <code>error message</code> string as opposed to a real error message:<pre class="source-code">
it('returns a 422 if the POST request returns an error', async () =&gt; {
  fetch.mockResolvedValue(
    fetchResponseError('error message')
  );
  const result = await performFormAction(
    createBirthday('Zeus', '2009-02-02')
  );
  expect(result).toBeUnprocessableEntity({
    error: 'error message',
    name: 'Zeus',
    dob: '2009-02-02'
  });
});</pre></li>
<li>To make this pass, start by saving the response from the <code>fetch</code> call in the form action:<pre class="source-code">
let result;
<strong class="bold">let response;</strong>
if (id) {
  ...
} else {
  result = addNew({ name, dob });
<strong class="bold">  response = </strong>await fetch('/api/birthdays', {
    method: 'POST',
    body: JSON.stringify({ name, dob })
  });
}</pre></li>
<li>Then, add the <a id="_idIndexMarker386"/>following return clause <em class="italic">after</em> the <a id="_idIndexMarker387"/>existing error clause for the original <code>result</code> value. This is a trick of the side-by-side implementation. It ensures that the original implementation won’t fail on us:<pre class="source-code">
if (!response.ok) {
  const { message } = await response.json();
  return fail(422, {
    id,
    name,
    dob,
    error: message
  });
}</pre></li>
<li>All right, let’s do the same for the <code>replace</code> call. Add the following new nested <code>describe</code> block with a single test:<pre class="source-code">
describe('when replacing an existing birthday', () =&gt; {
  it('requests data from PUT /api/birthday/{id}',
  async () =&gt; {
    await performFormAction(
      createBirthday('Zeus', '2009-02-02', {
        id: '123'
      })
    );
    expect(fetch).toBeCalledWith(
      '/api/birthday/123',
      expect.objectContaining({ method: 'PUT' })
    );
  });
});</pre></li>
<li>In the application <a id="_idIndexMarker388"/>code, find the call to <code>replace</code>, and <a id="_idIndexMarker389"/>just below it, add a new call to <code>fetch</code>. After this, the test should pass:<pre class="source-code">
if (id) {
  result = replace(id, { name, dob });
  <strong class="bold">await fetch(`/api/birthday/${id}`, {</strong>
  <strong class="bold">  method: 'PUT'</strong>
  <strong class="bold">});</strong>
} else {
 ...
}</pre></li>
<li>Next, we’ll <a id="_idIndexMarker390"/>test the body of the <code>PUT</code> request. Because <a id="_idIndexMarker391"/>we’re not actually calling into the repository, it no longer matters whether the item exists or not. It’s all down to the test double setup:<pre class="source-code">
it('sends the birthday as the request body', async () =&gt; {
  await performFormAction(
    createBirthday('Zeus', '2009-02-02', {
      id: '123'
    })
  );
  expect(fetch).toBeCalledWith(
    expect.anything(),
    expect.objectContaining({
      body: JSON.stringify({
        name: 'Zeus',
        dob: '2009-02-02'
      })
    })
  );
});</pre></li>
<li>To make that pass, add the <code>body</code> property to the <code>fetch</code> call:<pre class="source-code">
await fetch(`/api/birthday/${id}`, {
  method: 'PUT'<strong class="bold">,</strong>
  <strong class="bold">body: JSON.stringify({ name, dob })</strong>
});</pre></li>
<li>For the <a id="_idIndexMarker392"/>final test, repeat the same process used <a id="_idIndexMarker393"/>for the <code>POST</code> request. We use <code>mockResolvedValue</code> combined with the <code>fetchResponseError</code> factory to make the spy trigger our error flow:<pre class="source-code">
it('returns a 422 if the POST request returns an error', async () =&gt; {
  fetch.mockResolvedValue(
    fetchResponseError('error message')
  );
  const result = await performFormAction(
    createBirthday('Zeus', '2009-02-02', {
      id: '123'
    })
  );
  expect(result).toBeUnprocessableEntity({
    error: 'error message',
    name: 'Zeus',
    dob: '2009-02-02',
    id: '123'
  });
});</pre></li>
<li>To make that pass, simply save the result in the <code>response</code> variable. The code will then rely on the same return clause from <em class="italic">step 11</em>:<pre class="source-code">
if (id) {
  result = replace(id, { name, dob });
  <strong class="bold">response = </strong>await fetch('/api/birthdays', {
    method: 'POST',
    body: JSON.stringify({ name, dob })
  });
} ...</pre></li>
<li>Now comes the <a id="_idIndexMarker394"/>satisfying bit. You can go ahead and <a id="_idIndexMarker395"/>delete the original implementation, first by deleting the tests, then by deleting the code itself. Delete all these tests:<ul><li><code>adds a new birthday into </code><code>the list</code></li><li><code>saves unique ids onto each </code><code>new birthday</code></li><li><code>updates an entry that shares the </code><code>same id</code></li><li><code>when the name is </code><code>not provided...</code></li><li><code>when the date of birth in the </code><code>wrong format...</code></li><li><code>when the id </code><code>is unknown...</code></li><li><code>returns the id when an empty name </code><code>is provided</code></li><li><code>returns the id when an empty date of birth </code><code>is provided</code></li></ul></li>
</ol>
<p class="callout-heading">Using the online code repository</p>
<p class="callout">This is a lot of code change. You can use the online repository to cross-check your changes as you go along.</p>
<ol>
<li value="19">You can delete the import for <code>birthayRepository</code>, since you’re no longer using that, and the <code>storedId</code> method too. If you run your tests now, you should find they still pass.</li>
<li>Go ahead and <a id="_idIndexMarker396"/>delete all the bits from the <a id="_idIndexMarker397"/>implementation that reference the birthday repository:<ul><li>The calls to <code>addNew</code> and <code>replace</code></li><li>The <code>result</code> variable and the error handling</li><li>The <code>import</code> statement for the <code>replace</code> function (although the <code>addNew</code> function is still needed; we’ll remove it in the next section)</li></ul></li>
</ol>
<p>That completes the new version of the page form actions. But before finishing, we need to do something about our seed data.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Using a server hook to seed sample data</h1>
<p>In the early chapters <a id="_idIndexMarker398"/>of the book, we added seed data into the <code>/birthdays</code> route in the <code>src/routes/birthdays/+page.server.js</code> file. At the top, there are two calls to <code>addNew</code> to create two fake birthdays. We relied on this data within our Playwright tests. It’s now time to clean up.</p>
<p class="callout-heading">Creating repeated data in the development environment</p>
<p class="callout">If you’ve been running the dev server while you edited files, you will have noticed that as SvelteKit reloaded your files, the fake birthdays were repeatedly created, resulting in many birthday objects in the system. This was because of those <code>addNew</code> calls at the top of the route’s <code>+page.server.js</code> file. Another problem caused by our seed data will now be fixed.</p>
<p>First, we’ll update the Playwright tests to create all their test data via the API. Then we’ll remove the hardcoded seed data from our system. Finally, we will bring the seed data back when loading the development environment.</p>
<p>That means the seed data is available using the <code>npm run dev</code> command but won’t be there when running the automated tests or when launching in production mode.</p>
<p>Let’s start with the Playwright tests:</p>
<ol>
<li>Add the following to the top of <code>tests/birthdays.test.js</code>, which is a new <a id="_idIndexMarker399"/>function to make a <code>POST /api/birthdays</code> request to insert a birthday into the repository:<pre class="source-code">
const addBirthday = async (request, { name, dob }) =&gt; {
  await request.post('/api/birthdays', {
    data: { name, dob }
  });
};</pre></li>
<li>Then, update the <code>list all birthdays</code> test so that it begins with two calls to <code>addBirthday</code>, like this:<pre class="source-code">
test('lists all birthday', async ({ page, request }) =&gt; {
  <strong class="bold">await addBirthday(request, {</strong>
  <strong class="bold">  </strong><strong class="bold">name: 'Hercules',</strong>
  <strong class="bold">  dob: '1995-02-03'</strong>
  <strong class="bold">});</strong>
  <strong class="bold">await addBirthday(request, {</strong>
  <strong class="bold">  name: 'Athena',</strong>
  <strong class="bold">  dob: '1995-02-03'</strong>
  <strong class="bold">});</strong>
  ...
});</pre></li>
<li>Next, update the <code>edits a birthday</code> test in the same way:<pre class="source-code">
test('edits a birthday', async ({ page, request }) =&gt; {
  <strong class="bold">await addBirthday(request, {</strong>
  <strong class="bold">  name: 'Ares',</strong>
  <strong class="bold">  dob: '1985-01-01'</strong>
  <strong class="bold">});</strong>
  ...
});</pre></li>
<li>Before running the Playwright tests, we need to remove the seed data. In <code>src/routes/birthdays/+page.server.js</code>, delete the two calls to <code>addNew</code> and the <code>addNew</code> import statement.</li>
<li>Run the Playwright tests and verify they’ve passed.</li>
<li>All that’s left is <a id="_idIndexMarker400"/>to add a server hook for that data so that when you run the server in dev mode, you get some data. Create a new file named <code>src/hooks.server.js</code> with the following content. SvelteKit will automatically load this file when the web server is launched:<pre class="source-code">
import {
  addNew
} from '$lib/server/birthdayRepository.js';
if (import.meta.env.MODE === 'development') {
  addNew({ name: 'Hercules', dob: '1994-02-02' });
  addNew({ name: 'Athena', dob: '1989-01-01' });
}</pre></li>
</ol>
<p>That completes <a id="_idIndexMarker401"/>the removal of the hardcoded seed data.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>Summary</h1>
<p>This chapter introduced you to the concept of a test double that can be used to block out unwanted framework behavior. In our case, that was the <code>fetch</code> call that, at runtime, will be magically hooked up to the API endpoints. But since we don’t have access to the SvelteKit runtime environment within a Vitest unit test, we stubbed it out.</p>
<p>You also learned how a side-by-side implementation is used to keep your test suites on <em class="italic">Green</em> while you systematically replace the internals of a function.</p>
<p>The next chapter continues the theme of test doubles with a detailed look at component mocks.</p>
</div>
</div></body></html>