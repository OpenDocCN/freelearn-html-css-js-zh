<html><head></head><body>
        

                            
                    <h1 class="header-title">Mastering Functions</h1>
                
            
            
                
<p>In <a href="65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml" target="_blank">Chapter 1</a><q>, Functional Programming Fundamentals</q>, we learned about some of the most fundamental functional programming concepts. Functions are one of the fundamental building blocks of any TypeScript application, and they are powerful enough to warrant an entire chapter being dedicated to them in order to explore their potential.</p>
<p>In this chapter, we are going to master the usage of functions. The chapter starts with a quick recap of a number of basic concepts and then moves on to some less commonly known function features and use cases:</p>
<ul>
<li><strong>Function types</strong>:
<ul>
<li>Function declarations and function expressions</li>
<li>Named and anonymous functions</li>
</ul>
</li>
<li><strong>Working with parameters</strong>:
<ul>
<li>Functions with optional parameters</li>
<li>Functions with default parameters</li>
<li>Functions with rest parameters</li>
<li>Function overloading</li>
<li>Specialized overloading signature</li>
</ul>
</li>
<li>Function scope</li>
<li>Immediately-invoked functions</li>
<li>Tag functions and tagged templates</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Function types</h1>
                
            
            
                
<p>We already know that it is possible to explicitly declare the type of an element in our application by using optional type annotations:</p>
<pre>function greetNamed(name: string): string {<br/>    return 'Hi! ${name}';<br/>}</pre>
<p>In the previous function, we specified the type of parameter <kbd>name</kbd> (<kbd>string</kbd>) and its return type (<kbd>string</kbd>). Sometimes, we will need to specify the types of the function, as opposed to specifying the types of its components (arguments or returned value). Let's look at an example:</p>
<pre>let greetUnnamed: (name: string) =&gt; string;<br/><br/>greetUnnamed = function(name: string): string {<br/> return 'Hi! ${name}';<br/>};</pre>
<p>In the preceding example, we have declared the <kbd>greetUnnamed</kbd> variable and its type. The <kbd>greetUnnamed</kbd> type is a function type that takes a string variable called <kbd>name</kbd> as its only parameter and returns a string after being invoked. After declaring the variable, a function, whose type must be equal to the variable type, is assigned to it.</p>
<p>We can also declare the <kbd>greetUnnamed</kbd> type and assign a function to it in the same line, rather than declaring it in two separate lines, as we did in the previous example:</p>
<pre>let greetUnnamed: (name: string) =&gt; string = function(name: string): string {<br/>    return 'Hi! ${name}';<br/>};</pre>
<p>Just like in the previous example, the preceding code snippet also declares a variable, <kbd>greetUnnamed</kbd>, and its type. <kbd>greetUnnamed</kbd>  is a function type that takes a string variable called <kbd>name</kbd> as its only parameter and will return a string after being invoked. We will assign a function to this variable in the same line in which it is declared. The type of the assigned function must match the variable type.</p>
<div><p>In the preceding example, we have declared the type of the <kbd>greetUnnamed</kbd>  variable and then assigned a function as its value. The type of function can be inferred from the assigned function and, for this reason, it is unnecessary to add a redundant type annotation. We have done this to facilitate your understanding of this section, but it is important to mention that adding redundant type annotations can make our code harder to read, and is considered a bad practice.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Named and anonymous functions</h1>
                
            
            
                
<p>Just as in JavaScript, TypeScript functions can be created either as a named function or as an anonymous function, which allows us to choose the most appropriate approach for an application, whether we are building a list of functions in an API or a one-off function to hand over to another function:</p>
<pre>// named function<br/>function greet(name?: string): string {<br/>  if(name){<br/>    return "Hi! " + name;<br/>  } else {<br/>    return "Hi!";<br/>  }<br/>}<br/><br/>// anonymous function<br/>let greet = function(name?: string): string {<br/>  if (name) {<br/>    return "Hi! " + name;<br/>  } else {<br/>    return "Hi!";<br/>  }<br/>}</pre>
<p>As we can see in the preceding code snippet, in TypeScript, we can add types to each of the parameters and then to the function itself to add a <kbd>return</kbd> type. TypeScript can infer the <kbd>return</kbd> type by looking at the <kbd>return</kbd> statements, so we can also optionally leave this off in many cases.</p>
<p>There is an alternative syntax for functions that use the <kbd>=&gt;</kbd> operator after the <kbd>return</kbd> type and don't use the <kbd>function</kbd> keyword:</p>
<pre>let greet = (name: string): string =&gt; {<br/>    if(name){<br/>      return "Hi! " + name;<br/>    }<br/>    else<br/>    {<br/>      return "Hi";<br/>    }<br/>};</pre>
<p>Now that we have learned about this alternative syntax, we can return to the previous example in which we were assigning an anonymous function to the <kbd>greet</kbd> variable. We can now add type annotations to the <kbd>greet</kbd> variable to match the <kbd>anonymous</kbd> function signature:</p>
<pre>let greet: (name: string) =&gt; string = function(name: string): <br/>string {<br/>    if (name) {<br/>      return "Hi! " + name;<br/>    } else {<br/>      return "Hi!";<br/>    }<br/>};</pre>
<div><p>Keep in mind that the arrow function (<kbd>=&gt;</kbd>) syntax changes the way the <kbd>this</kbd> operator works when working with classes. We will learn more about this in upcoming chapters.</p>
</div>
<p>The previous code snippet demonstrates how to use type annotations to force a variable to be a function with a specific signature. These kinds of annotation are commonly used when we annotate a <kbd>callback</kbd> (a function used as an argument of another function):</p>
<pre>function add(<br/>    a: number,<br/>    b: number,<br/>    callback: (result: number) =&gt; void<br/>) {<br/>    callback(a + b);<br/>}</pre>
<p>In the preceding example, we are declaring a function named <kbd>add</kbd> that takes two numbers and a <kbd>callback</kbd> as a function. The type annotations will force the <kbd>callback</kbd> to return <kbd>void</kbd> and take a number as its only argument.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function declarations and function expressions</h1>
                
            
            
                
<p>In the preceding section, we introduced the possibility of declaring functions with (a named function) or without (an unnamed or anonymous function) explicitly indicating their name, but we didn't mention that we were also using two different types of function.</p>
<p>In the following example, the named function, <kbd>greetNamed</kbd>, is a <strong>function declaration</strong> while <kbd>greetUnnamed</kbd> is a <strong>function expression</strong>. For the time being, please ignore the first two lines, which contain two <kbd>console.log</kbd> statements:</p>
<pre>console.log(greetNamed("John")); // OK<br/>console.log(greetUnnamed("John")); // Error<br/><br/>function greetNamed(name: string): string {<br/>    return 'Hi! ${name}';<br/>}<br/><br/>let greetUnnamed = function(name: string): string {<br/>    return 'Hi! ${name}';<br/>};</pre>
<p>We might think that the preceding functions are identical, but they behave differently. The JavaScript interpreter can evaluate a function declaration as it is being parsed. On the other hand, the <kbd>function</kbd> expression is part of an assignment and will not be evaluated until the assignment has been completed.</p>
<div><p>The primary cause of the different behavior of these functions is a process known as variable <strong>hoisting</strong>. We will learn more about the variable hoisting process in the <em>Function scope and hoisting </em>section later in this chapter.</p>
</div>
<p>Fortunately, the TypeScript compiler can detect this error and throw a compilation-time error. However, if we compile the preceding TypeScript code snippet into JavaScript, ignore the compilation errors, and try to execute it in a web browser, we will observe that the first <kbd>console.log</kbd> call works. This is the case because JavaScript knows about the declaration function and can parse it before the program is executed.</p>
<p>However, the second alert statement will throw an exception, to indicate that <kbd>greetUnnamed</kbd> is not a function. The exception is thrown because the <kbd>greetUnnamed</kbd> assignment must be completed before the function can be evaluated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with function parameters</h1>
                
            
            
                
<p>In this section, we are going to learn how to work with function parameters in multiple scenarios, including <kbd>optional</kbd> parameters, <kbd>default</kbd> parameters, and <kbd>rest</kbd> parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trailing commas in function arguments</h1>
                
            
            
                
<p>Trailing commas are commas that are used after the final argument of a function. Using a comma after the last parameter of a function can be useful because it is very common to forget a comma when we modify an existing function by adding additional parameters.</p>
<p>For example, the following function only takes one parameter and doesn't use trailing commas:</p>
<pre>function greetWithoutTralingCommas(<br/>    name: string<br/>): string {<br/>    return 'Hi! ${name}';<br/>}</pre>
<p>Some time after the initial implementation, we might be required to add a parameter to the previous function. A common mistake is to declare the new parameter and forget to add a comma after the first parameter:</p>
<pre>function updatedGreetWithoutTralingCommas(<br/>    name: string<br/>    surname: string, // Error<br/>): string {<br/>    return 'Hi! ${name} ${surname}';<br/>}</pre>
<p>Using a trailing comma in the first version of the function could have helped us to prevent this common mistake:</p>
<pre>function greetWithTralingCommas(<br/>    name: string,<br/>): string {<br/>    return 'Hi! ${name}';<br/>}</pre>
<p>Using a trailing comma eliminates the possibility of forgetting the comma when adding a new argument:</p>
<div><pre>function updatedGreetWithTralingCommas(<br/>    name: string,<br/>    surname: string,<br/>): string {<br/>    return 'Hi! ${name} ${surname}';<br/>}</pre></div>
<p>TypeScript will throw an error if we forget a comma, so trailing commas are not needed as much as they are when working with JavaScript. Trailing commas are optional, but using them is considered good practice by many JavaScript and TypeScript engineers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions with optional parameters</h1>
                
            
            
                
<p>Unlike JavaScript, the TypeScript compiler will throw an error if we attempt to invoke a function without providing the exact number and types of parameters that its signature declares. Let's look at a code sample to demonstrate it:</p>
<pre>function add(foo: number, bar: number, foobar: number): number {<br/>    return foo + bar + foobar;<br/>}</pre>
<p>The preceding function is called <kbd>add</kbd> and will take three numbers as parameters, named <kbd>foo</kbd>, <kbd>bar</kbd>, and <kbd>foobar</kbd>. If we attempt to invoke this function without providing exactly three numbers, we will get a compilation error indicating that the supplied parameters do not match the function's signature:</p>
<pre>add(); // Error, expected 3 arguments, but got 0.<br/>add(2, 2); // Error, expected 3 arguments, but got 2.<br/>add(2, 2, 2); // OK, returns 6</pre>
<p>There are scenarios in which we might want to be able to call the function without providing all of its arguments. TypeScript features optional parameters in functions to help us to increase the flexibility of our functions and overcome such scenarios.</p>
<p>We can indicate to the TypeScript compiler that we want a function's parameter to be optional by appending the character <kbd>?</kbd> to its name. Let's update the previous function to transform the required parameter, <kbd>foobar</kbd>, into an optional parameter:</p>
<pre>function add(foo: number, bar: number, foobar?: number): number {<br/>    let result = foo + bar;<br/>    if (foobar !== undefined) {<br/>        result += foobar;<br/>    }<br/>    return result;<br/>}</pre>
<p>Note how we have changed the <kbd>foobar</kbd> parameter name into <kbd>foobar?</kbd> and are checking the <kbd>foobar</kbd> type inside the function to identify whether the parameter was supplied as an argument to the function. After implementing these changes, the TypeScript compiler will allow us to invoke the function without errors when we supply two or three arguments to it:</p>
<pre>add(); // Error, expected 2-3 arguments, but got 0.<br/>add(2, 2); // OK, returns 4<br/>add(2, 2, 2); // OK, returns 6</pre>
<p>It is important to note that the optional parameters must always be located after the requisite parameters in the function's parameter list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions with default parameters</h1>
                
            
            
                
<p>When a function has some optional parameters, we must check whether an argument has been passed to the function (just like we did in the previous example) to prevent potential errors.</p>
<p>There are a number of scenarios in which it would be more useful to provide a default value for a parameter when it is not supplied than to make it an optional parameter. Let's rewrite the <kbd>add</kbd> function (from the previous section) using the inline <kbd>if</kbd> structure:</p>
<pre>function add(foo: number, bar: number, foobar?: number): number {<br/>    return foo + bar + (foobar !== undefined ? foobar : 0);<br/>}</pre>
<p>There is nothing wrong with the preceding function, but we can improve its readability by providing a default value for the <kbd>foobar</kbd> parameter instead of using an <kbd>optional</kbd> parameter:</p>
<pre>function add(foo: number, bar: number, foobar: number = 0): number {<br/>    return foo + bar + foobar;<br/>}</pre>
<p>To indicate that a <kbd>function</kbd> parameter is optional, we need to provide a default value using the <kbd>=</kbd> operator when declaring the function's signature. After compiling the preceding examples, the TypeScript compiler will generate an <kbd>if</kbd> statement in the JavaScript output to set a default value for the <kbd>foobar</kbd> parameter if it is not passed as an argument to the <kbd>function</kbd>:</p>
<pre>function add(foo, bar, foobar) {<br/>    if (foobar === void 0) { foobar = 0; }<br/>    return foo + bar + foobar;<br/>}</pre>
<p>This is great because the TypeScript compiler generated the code required to prevent potential runtime errors for us.</p>
<div><p>The <kbd>void 0</kbd> parameter is used by the TypeScript compiler to check whether a variable is equal to undefined. While most developers use the <kbd>undefined</kbd> variable to perform this kind of check, most compilers use <kbd>void 0</kbd> because it will always evaluate as undefined. Checking against <kbd>undefined</kbd> is less secure because its value could have been modified, as demonstrated by the following code snippet:</p>
<pre>function test() {<br/>     var undefined = 2; // 2<br/>     console.log(undefined === 2); // true<br/> }</pre></div>
<p>Just like <kbd>optional</kbd> parameters, <kbd>default</kbd> parameters must always be located after any required parameters in the function's parameter list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions with rest parameters</h1>
                
            
            
                
<p>We have learned how to use <kbd>optional</kbd> and <kbd>default</kbd> parameters to increase the number of ways that we can invoke a function. Let's return to the previous example one more time:</p>
<pre>function add(foo: number, bar: number, foobar: number = 0): number {<br/>    return foo + bar + foobar;<br/>}</pre>
<p>We have learned how to invoke the <kbd>add</kbd> function with two or three parameters, but what if we wanted to allow other developers to pass four or five parameters to our function? We would have to add two extra <kbd>default</kbd> or <kbd>optional</kbd> parameters. And what if we wanted to allow them to pass as many parameters as they need? The solution to this possible scenario is the use of <kbd>rest</kbd> parameters. The <kbd>rest</kbd> parameter syntax allows us to represent an indefinite number of arguments as an array:</p>
<pre>function add(...foo: number[]): number {<br/>    let result = 0;<br/>    for (let i = 0; i &lt; foo.length; i++) {<br/>        result += foo[i];<br/>    }<br/>    return result;<br/><br/>}</pre>
<p>As we can see in the preceding code snippet, we have replaced the <kbd>function</kbd> parameters <kbd>foo</kbd>, <kbd>bar</kbd>, and <kbd>foobar</kbd>, with just one parameter named <kbd>foo</kbd>. Note that the name of the parameter <kbd>foo</kbd> is preceded by an ellipsis (a set of three periods—not the actual ellipsis character). A <kbd>rest</kbd> parameter must be of an array type, or we will get a compilation error. We can now invoke the <kbd>add</kbd> function with as many parameters as we need:</p>
<pre>add(); // 0<br/>add(2); // 2<br/>add(2, 2); // 4<br/>add(2, 2, 2); // 6<br/>add(2, 2, 2, 2); // 8<br/>add(2, 2, 2, 2, 2); // 10<br/>add(2, 2, 2, 2, 2, 2); // 12</pre>
<p>Although there is no specific limit in the theoretical maximum number of arguments that a function can take, there are, of course, practical limits. These limits are entirely implementation-dependent and, most likely, will also depend exactly on how we are calling the function.</p>
<p>JavaScript functions have a built-in object called the <kbd>arguments</kbd> object. This object is available as a local variable named arguments. The <kbd>arguments</kbd> variable contains an object such as an array, which includes the arguments used when the function was invoked.</p>
<div><p>The <kbd>arguments</kbd> object exposes some of the methods and properties provided by a standard array, but not all of them. Refer to the complete reference at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments</a> to learn more about its peculiarities.</p>
</div>
<p>If we examine the JavaScript output, we will notice that TypeScript iterates the <kbd>arguments</kbd> object to add the values to the <kbd>foo</kbd> variable:</p>
<pre>function add() {<br/>    var foo = [];<br/>    for (var _i = 0; _i &lt; arguments.length; _i++) {<br/>        foo[_i - 0] = arguments[_i];<br/>    }<br/>    var result = 0;<br/>    for (var i = 0; i &lt; foo.length; i++) {<br/>        result += foo[i];<br/>    }<br/>    return result;<br/>}</pre>
<p>We can argue that this is an extra, unnecessary iteration over the function's parameters. Even though it is hard to imagine this further iteration becoming a performance issue, if you think that this could be a problem in terms of the performance of your application, you may want to consider avoiding the use of <kbd>rest</kbd> parameters and use an array as the only parameter of the function instead:</p>
<pre>function add(foo: number[]): number {<br/>    let result = 0;<br/>    for (let i = 0; i &lt; foo.length; i++) {<br/>        result += foo[i];<br/>    }<br/>    return result;<br/>}</pre>
<p>The preceding function takes an array of numbers as its only parameter. The invocation API will be a little bit different from the <kbd>rest</kbd> parameters, but we will effectively avoid the extra iteration over the function's argument list:</p>
<pre>add(); // Error, expected 1 argument, but got 0.<br/>add(2); // Error, '2' is not assignable to parameter of type 'number[]'.<br/>add(2, 2); // Error, expected 1 argument, but got 2.<br/>add(2, 2, 2); // Error, expected 1 argument, but got 3.<br/>add([]); // returns 0<br/>add([2]); // returns 2<br/>add([2, 2]); // returns 4<br/>add([2, 2, 2]); // returns 6</pre>
<p>The following table summarizes the parameter-related features that we have explored in this section:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Operator</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Trailing commas</td>
<td><kbd>,</kbd></td>
<td>Used to facilitate adding additional parameters to an existing function at a later time.</td>
</tr>
<tr>
<td>Optional parameters</td>
<td><kbd>?</kbd></td>
<td>Used to describe optional arguments. When the argument is missed, the value of the parameter is <kbd>undefined</kbd>.</td>
</tr>
<tr>
<td>Default parameters</td>
<td><kbd>=</kbd></td>
<td>Used to describe optional arguments. When the argument is missed, the value of the parameter takes a default value.</td>
</tr>
<tr>
<td>Rest parameters</td>
<td><kbd>...</kbd></td>
<td>Used to describe functions with an unknown number of arguments.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the following section, we are going to learn about function overloading.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function overloading</h1>
                
            
            
                
<p>Function, or method, overloading is the ability to create multiple methods with the same name and a different number of parameters or types. In TypeScript, we can overload a function by specifying all function signatures (known as <strong>overload signatures</strong>) of a function, followed by a signature (known as the <strong>implementation signature</strong>). Let's look at an example:</p>
<pre>function test(name: string): string; // overloaded signature<br/>function test(age: number): string; // overloaded signature<br/>function test(single: boolean): string; // overloaded signature<br/>function test(value: (string|number|boolean)): string { // implementation signature<br/>    switch (typeof value) {<br/>        case "string":<br/>            return 'My name is ${value}.';<br/>        case "number":<br/>            return 'I'm ${value} years old.';<br/>        case "boolean":<br/>            return value ? "I'm single." : "I'm not single.";<br/>        default:<br/>            throw new Error("Invalid Operation!");<br/>    }<br/>}</pre>
<p>As we can see in the preceding example, we have overloaded the function test three times by adding a signature that takes a <kbd>string</kbd> as its only parameter, another function that takes a <kbd>number</kbd>, and a final signature that takes a <kbd>Boolean</kbd> as its unique parameter. It is important to note that all function signatures must be compatible; so, if, for example, one of the signatures tries to return a <kbd>number</kbd> while another tries to return a <kbd>string</kbd>, we will get a compilation error:</p>
<pre>function test(name: string): string;<br/>function test(age: number): number; // Error<br/>function test(single: boolean): string;<br/>function test(value: (string|number|boolean)): string {<br/>    switch (typeof value) {<br/>        case "string":<br/>            return 'My name is ${value}.';<br/>        case "number":<br/>            return 'I'm ${value} years old.';<br/>        case "boolean":<br/>            return value ? "I'm single." : "I'm not single.";<br/>        default:<br/>            throw new Error("Invalid Operation!");<br/>    }<br/>}</pre>
<div><p>Please note that this restriction can be overcome by using a specialized overloaded signature, as we will learn in the following section.</p>
</div>
<p>The implementation signature must be compatible with all the overloaded signatures, always be the last in the list, and take any or a union type as the type of its parameters.</p>
<p>Invoking the function by providing arguments that don't match any of the types declared by the overload signatures will lead to a compilation error:</p>
<pre>test("Remo"); // returns "My name is Remo."<br/>test(29); // returns "I'm 29 years old.";<br/>test(false); // returns "I'm not single.";<br/>test({ custom: "custom" }); // Error</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Specialized overloading signature</h1>
                
            
            
                
<p>We can use a specialized signature to create multiple methods with the same name and number of parameters, but a different return type. To create a specialized signature, we must indicate the type of function parameter using a string. The string literal is used to identify which of the function overloads is invoked:</p>
<pre>interface Document {<br/>    createElement(tagName: "div"): HTMLDivElement; // specialized<br/>    createElement(tagName: "span"): HTMLSpanElement; // specialized<br/>    createElement(tagName: "canvas"): HTMLCanvasElement; // specialized<br/>    createElement(tagName: string): HTMLElement; // non-specialized<br/>}</pre>
<p>In the preceding example, we have declared three <strong>specialized overloaded signatures</strong> and one <strong>non-specialized signature</strong> for the function named <kbd>createElement</kbd>.</p>
<p>When we declare a specialized signature in an object, it must be assignable to at least one non-specialized signature in the same object. This can be observed in the preceding example, as the <kbd>createElement</kbd> property belongs to a type that contains three specialized signatures, all of which are assignable to the non-specialized signature in the type.</p>
<p>When writing overloaded declarations, we must list the non-specialized signature last.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function scope and hoisting</h1>
                
            
            
                
<p>Low-level languages, such as C, have low-level memory management features. In programming languages with a higher level of abstraction, such as TypeScript, values are allocated when variables are created, and automatically cleared from memory when they are no longer used. The process that cleans the memory is known as <strong>garbage</strong> <strong>collection</strong> and is performed by the JavaScript runtime garbage collector.</p>
<p>The garbage collector does a great job, but it is a mistake to assume that it will always prevent us from facing a memory leak. The garbage collector will clear a variable from the memory whenever the variable is out of scope. It is important to understand how the TypeScript scope works in order for us to understand the life cycle of variables.</p>
<p>Some programming languages use the structure of the program source code to determine what variables we are referring to (<strong>lexical scoping</strong>), while others use the runtime state of the program stack to determine what variable we are referring to (<strong>dynamic scoping</strong>). Most modern programming languages use lexical scoping (including TypeScript). Lexical scoping tends to be dramatically easier to understand for both humans and analysis tools than dynamic scoping.</p>
<p>While, in most lexical-scoped programming languages, variables are scoped to a block (a section of code delimited by curly braces <kbd>{}</kbd>), in TypeScript (and JavaScript) variables are scoped to a function, as demonstrated by the following code snippet:</p>
<pre>function foo(): void {<br/>    if (true) {<br/>        var bar: number = 0;<br/>    }<br/>    console.log(bar);<br/>}<br/><br/>foo(); // 0</pre>
<p>The preceding function, named <kbd>foo</kbd>, contains an <kbd>if</kbd> structure. We have declared a numeric variable named <kbd>bar</kbd> inside the <kbd>if</kbd> statement, and later we have attempted to show the value of the <kbd>bar</kbd> variable using the <kbd>log</kbd> function.</p>
<p>We might think that the preceding code sample would throw an error in the fifth line because the <kbd>bar</kbd> variable should be out of scope when the <kbd>log</kbd> function is invoked. However, if we invoke the <kbd>foo</kbd> function, the <kbd>log</kbd> function will be able to display the variable <kbd>bar</kbd> without errors because all variables inside a function will be within the scope of the entire function body, even if they are inside another block of code (except a function block).</p>
<p>The following diagram displays the lexical scope at the function level (left), and the lexical scope at the block level (right). As we can see, there is only one function, but there are two blocks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0bc4b27a-d287-41ef-84f8-4d0f8ba48f01.png" style="width:42.92em;height:15.08em;"/></p>
<p>The preceding code snippet might seem confusing, but it is easy to understand once we know that, at runtime, all the variable declarations are moved to the top of a function before the function is executed. This behavior is known as <strong>hoisting</strong>.</p>
<div><p>TypeScript is compiled to JavaScript and then executed—this means that a TypeScript application is a JavaScript application at runtime and, for this reason, when we refer to the TypeScript runtime, we are talking about the JavaScript runtime. We will learn in depth about the runtime in <a href="0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml" target="_blank"/><a href="0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml" target="_blank">Chapter 4</a><em>, The Runtime – The Event Loop and The this Operator,</em> and <a href="68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml" target="_blank">Chapter 5</a><em>, The Runtime – Closures and Prototypes</em>.</p>
</div>
<p>Before the preceding code snippet is executed, the runtime will move the declaration of the <kbd>bar</kbd> variable to the top of our function:</p>
<pre>function foo() {<br/>    var bar;<br/>    if (true) {<br/>        bar = 0;<br/>    }<br/>    console.log(bar);<br/>}<br/><br/>foo(); // 0</pre>
<p>This explains why it is possible to use a variable before it is declared. Let's look at an example:</p>
<pre>function foo(): void {<br/>    bar = 0;<br/>    var bar: number;<br/>    console.log(bar);<br/>}<br/><br/>foo(); // 0</pre>
<p>In the preceding code snippet, we have declared a function, <kbd>foo</kbd>, and, in its body, we have assigned the value <kbd>0</kbd> to a variable named <kbd>bar</kbd>. At this point, the variable has not been declared. In the second line, we are declaring the <kbd>bar</kbd> variable and its type. In the last line, we are displaying the value of the <kbd>bar</kbd> variable using the <kbd>alert</kbd> function.</p>
<p>Since declaring a variable anywhere inside a function (except another function) is equivalent to declaring it at the top of the function, the <kbd>foo</kbd> function is transformed into the following at runtime:</p>
<pre>function foo(): void {<br/>    var bar: number;<br/>    bar = 0;<br/>    console.log(bar);<br/>}<br/><br/>foo(); // 0</pre>
<p>Developers with a background in programming languages with block scope, such as Java or C#, are not used to function scope and it is one of the most criticized characteristics of JavaScript. The people in charge of the development of the ECMAScript 6 specification are aware of this, and, as a result, they have introduced the keywords <kbd>let</kbd> and <kbd>const</kbd>.</p>
<p>The <kbd>let</kbd> keyword allows us to set the scope of a variable to a block (<kbd>if</kbd>, <kbd>while</kbd>, <kbd>for</kbd>, and so on) rather than a function. We can update the first example in this section to showcase how the <kbd>let</kbd> keyword works:</p>
<pre>function foo(): void {<br/>    if (true) {<br/>        let bar: number = 0;<br/>        bar = 1;<br/>    }<br/>    console.log(bar); // Error<br/>}</pre>
<p>The <kbd>bar</kbd> variable is now declared using the <kbd>let</kbd> keyword, and, as a result, it is only accessible inside the <kbd>if</kbd> block. The variable is not hoisted to the top of the <kbd>foo</kbd> function and cannot be accessed by the <kbd>alert</kbd> function outside the <kbd>if</kbd> statement.</p>
<p>While variables defined with <kbd>const</kbd> follow the same scope rules as variables declared with <kbd>let</kbd>, they can't be reassigned:</p>
<pre>function foo(): void {<br/>    if (true) {<br/>        const bar: number = 0;<br/>        bar = 1; // Error<br/>    }<br/>    alert(bar); // Error<br/>}</pre>
<p>If we attempt to compile the preceding code snippet, we will get an error because the <kbd>bar</kbd> variable is not accessible outside the <kbd>if</kbd> statement (just like when we used the <kbd>let</kbd> keyword), and a new error occurs when we try to assign a new value to the <kbd>bar</kbd> variable. The second error is caused because it is not possible to assign a new value to a constant variable once the variable has already been initialized.</p>
<div><p>Variables declared with the <kbd>const</kbd> keyword cannot be reassigned, but are not immutable. When we say that a variable is immutable, we mean that it cannot be modified. We will learn more about immutability in <a href="6a03c916-f7a5-439a-bea6-6facecef0347.xhtml" target="_blank">Chapter 9</a><em>, Functional-Reactive Programming</em>.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Immediately-invoked functions</h1>
                
            
            
                
<p>An <strong>immediately-invoked function expression</strong> (<strong>IIFE</strong>) is a design pattern that produces a lexical scope using function scoping. IIFE can be used to avoid variable hoisting from within blocks or to prevent us from polluting the global scope, for example:</p>
<pre>let bar = 0; // global<br/><br/>(function() {<br/>    let foo: number = 0; // In scope of this function<br/>    bar = 1; // Access global scope<br/>    console.log(bar); // 1<br/>    console.log(foo); // 0<br/>})();<br/><br/>console.log(bar); // 1<br/>console.log(foo); // Error</pre>
<p>In the preceding example, we have wrapped the declaration of a variable (<kbd>foo</kbd>) with an IIFE. The <kbd>foo</kbd> variable is scoped to the IIFE function and is not available in the global scope, which explains the error when trying to access it on the last line.</p>
<p>The <kbd>bar</kbd> variable is global. Therefore, it can be accessed from within and from outside the IIFE function.</p>
<p>We can also pass a variable to the IIFE to have better control over the creation of variables outside its scope:</p>
<pre>let bar = 0; // global<br/>let topScope = window;<br/><br/>(function(global: any) {<br/>    let foo: number = 0; // In scope of this function<br/>    console.log(global.bar); // 0<br/>    global.bar = 1; // Access global scope<br/>    console.log(global.bar); // 1<br/>    console.log(foo); // 0<br/>})(topScope);<br/><br/>console.log(bar); // 1<br/>console.log(foo); // Error</pre>
<p>Furthermore, IIFE can help us to simultaneously allow public access to methods while retaining privacy for variables defined within the function. Let's look at an example:</p>
<pre>class Counter {<br/>    private _i: number;<br/>    public constructor() {<br/>        this._i = 0;<br/>    }<br/>    public get(): number {<br/>        return this._i;<br/>    }<br/>    public set(val: number): void {<br/>        this._i = val;<br/>    }<br/>    public increment(): void {<br/>        this._i++;<br/>    }<br/>}<br/><br/>let counter = new Counter();<br/>console.log(counter.get()); // 0<br/>counter.set(2);<br/>console.log(counter.get()); // 2<br/>counter.increment();<br/>console.log(counter.get()); // 3<br/>console.log(counter._i); // Error: Property '_i' is private</pre>
<p>We have defined a class named <kbd>Counter</kbd>, which has a private numerical attribute named <kbd>_i</kbd>. The class also has methods to get and set the value of the <kbd>_i</kbd> private property.</p>
<div><p>By convention, TypeScript and JavaScript developers usually name private variables with names preceded by the underscore character (<kbd>_</kbd>).</p>
</div>
<p>We have also created an instance of the <kbd>Counter</kbd> class and invoked the methods <kbd>set</kbd>, <kbd>get</kbd>, and <kbd>increment</kbd> to observe that everything is working as expected. If we attempt to access the <kbd>_i</kbd> property in an instance of <kbd>Counter</kbd>, we will get an error because the variable is private.</p>
<p>If we compile the preceding TypeScript code (only the class definition) and examine the JavaScript code generated, we will see the following:</p>
<pre>var Counter = (function() {<br/>    function Counter() {<br/>        this._i = 0;<br/>    }<br/><br/>    Counter.prototype.get = function() {<br/>        return this._i;<br/>    };<br/><br/>    Counter.prototype.set = function(val) {<br/>        this._i = val;<br/>    };<br/><br/>    Counter.prototype.increment = function() {<br/>        this._i++;<br/>    };<br/><br/>    return Counter;<br/>})();</pre>
<p>This generated JavaScript code will work perfectly in most scenarios, but if we execute it in a browser and try to create an instance of <kbd>Counter</kbd> and access its property <kbd>_i</kbd>, we will not get any errors because TypeScript will not generate runtime private properties for us. Occasionally, we will need to write our classes in such a way that some properties are private at runtime, for example, if we release a library that will be used by JavaScript developers.</p>
<p>We can also use IIFE to simultaneously allow public access to methods while retaining privacy for variables defined within the function:</p>
<pre>var Counter = (function() {<br/>    var _i: number = 0;<br/>    function Counter() {<br/>        //<br/>    }<br/>    Counter.prototype.get = function() {<br/>        return _i;<br/>    };<br/>    Counter.prototype.set = function(val: number) {<br/>        _i = val;<br/>    };<br/>    Counter.prototype.increment = function() {<br/>        _i++;<br/>    };<br/>    return Counter;<br/>})();</pre>
<p>In the preceding example, everything is almost identical to TypeScript's generated JavaScript, except that the variable <kbd>_i</kbd> is now an object in the <kbd>Counter</kbd> closure instead of a property of the <kbd>Counter</kbd> class.</p>
<div><p>Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure remembers the environment (variables in the scope) in which it was created. We will discover more about closures in <a href="68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml" target="_blank">Chapter 5</a><em>, The Runtime – Closures and Prototypes</em>.</p>
</div>
<p>If we run the generated JavaScript output in a browser and try to invoke the <kbd>_i</kbd> property directly, we will notice that the property is now private at runtime:</p>
<pre>let counter = new Counter();<br/>console.log(counter.get()); // 0<br/>counter.set(2);<br/>console.log(counter.get()); // 2<br/>counter.increment();<br/>console.log(counter.get()); // 3<br/>console.log(counter._i); // undefined</pre>
<div><p>In some cases, we will need to have precise control over scope and closures, and our code will end up looking much more like JavaScript. If we write our application components (classes, modules, and so on) to be consumed by other TypeScript components, we will rarely have to worry about implementing runtime private properties. We will look in depth at the TypeScript runtime in <a href="0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml" target="_blank">Chapter 4</a><em>, The Runtime – The Event Loop and The this Operator,</em> and <a href="68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml" target="_blank">Chapter 5</a><em>, The Runtime – Closures and Prototypes.</em></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Tag functions and tagged templates</h1>
                
            
            
                
<p>In TypeScript, we can use template strings such as the following:</p>
<pre>let name = "remo";<br/>let surname = "jansen";<br/>let html = '&lt;h1&gt;${name} ${surname}&lt;/h1&gt;';</pre>
<p>We can use a template string to create a special kind of function known as a <strong>tag function</strong>.</p>
<p>We can use a <kbd>tag</kbd> function to extend or modify the standard behavior of template strings. When we apply a <kbd>tag</kbd> function to a template string, the template string becomes a tagged template.</p>
<p>We are going to implement a <kbd>tag</kbd> function named <kbd>htmlEscape</kbd>. To use a <kbd>tag</kbd> function, we must use the name of the function, followed by a template string:</p>
<pre>let html = htmlEscape '&lt;h1&gt;${name} ${surname}&lt;/h1&gt;';</pre>
<p>A <kbd>tag</kbd> template must return a string and take the following arguments:</p>
<ul>
<li>A <kbd>TemplateStringsArray</kbd>, which contains all the static literals in the template string (<kbd>&lt;h1&gt;</kbd> and <kbd>&lt;/h1&gt;</kbd> in the preceding example), is passed as the first argument.</li>
</ul>
<div><p>The <kbd>TemplateStringsArray</kbd> type is declared by the <kbd>lib.d.ts</kbd> file. The <kbd>lib.d.ts</kbd> file contains the type declarations of the native JavaScript and browser APIs.</p>
</div>
<ul>
<li>A <kbd>rest</kbd> parameter is passed as the second parameter. The <kbd>rest</kbd> parameter contains all the values in the template string (name and surname in the preceding example).</li>
</ul>
<p>The signature of a <kbd>tag</kbd> function appears as follows:</p>
<pre>tag(literals: TemplateStringsArray, ...placeholders: any[]): string;</pre>
<p>Let's implement the <kbd>htmlEscape</kbd> tag function:</p>
<pre>function htmlEscape(literals: TemplateStringsArray, ...placeholders: any[]) {<br/>    let result = "";<br/>    for (let i = 0; i &lt; placeholders.length; i++) {<br/>        result += literals[i];<br/>        result += placeholders[i]<br/>            .replace(/&amp;/g, "&amp;amp;")<br/>            .replace(/"/g, "&amp;quot;")<br/>            .replace(/"/g, "'")<br/>            .replace(/&lt;/g, "&amp;lt;")<br/>            .replace(/&gt;/g, "&amp;gt;");<br/>    }<br/>    result += literals[literals.length - 1];<br/>    return result;<br/>}</pre>
<p>We can then invoke the function as follows:</p>
<pre>let html = htmlEscape '&lt;h1&gt;${name} ${surname}&lt;/h1&gt;';</pre>
<p>The template string contains values and literals. The <kbd>htmlEscape</kbd> function iterates through them and ensures that the HTML code is escaped in the values to avoid possible code injection attacks.</p>
<p>The main benefit of using a tagged function is that it allows us to create custom template string processors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned a lot about functions. We have learned about different kinds of functions, such as named and anonymous function, and function declarations and function expressions. We also learned how to declare different types of function signatures as well as how to work with function arguments in multiple scenarios.</p>
<p>In the next chapter, we are going to learn about asynchronous programming techniques. We will learn why functions play a very fundamental role in the TypeScript and JavaScript asynchronous programming model.</p>


            

            
        
    </body></html>