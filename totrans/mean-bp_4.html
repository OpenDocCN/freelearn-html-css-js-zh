<html><head></head><body>
<div class="book" title="Chapter&#xA0;4.&#xA0;Chat Application" id="1BRPS1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Chat Application</h1></div></div></div><p class="calibre8">In this chapter, we will build a chat application. The application that we are going to build will serve perfectly as an in-house communication tool for a company. Teams could create channels to discuss certain things related to their projects, even send auto-deleting messages with sensitive data, such as login credentials for servers and so on.</p></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Chat Application" id="1BRPS1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Setting up the base application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec39" class="calibre1"/>Setting up the base application</h1></div></div></div><p class="calibre8">We are going to <a id="id332" class="calibre1"/>start by setting up the base application using the same boilerplate code used in the previous chapter. Follow these simple steps to achieve this:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Clone the <a id="id333" class="calibre1"/>project from GitHub: <a class="calibre1" href="https://github.com/robert52/express-api-starter">https://github.com/robert52/express-api-starter</a>.</li><li class="listitem" value="2">Rename your boilerplate project <code class="email">mean-blueprints-chatapp</code>.</li><li class="listitem" value="3">If you want, you can stop pointing to the initial Git repository by running the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">git remote remove origin</strong></span>
</pre></div></li><li class="listitem" value="4">Jump to your working directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">cd mean-blueprints-chatapp</strong></span>
</pre></div></li><li class="listitem" value="5">Install all dependencies:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">npm install</strong></span>
</pre></div></li><li class="listitem" value="6">Create a development configuration file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">cp config/environments/example.js config/environments/development.js</strong></span>
</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">Your configuration file, <code class="email">config/environments/development.js</code>, should look similar to the following:</p><div class="informalexample"><pre class="programlisting">module.exports = {
  port: 3000,
  hostname: '127.0.0.1',
  baseUrl: 'http://localhost:3000',
  mongodb: {
    uri: 'mongodb://localhost/chatapp_dev_db'
  },
  app: {
    name: 'MEAN Blueprints - chat application'
  },
  serveStatic: true,
  session: {
    type: 'mongo',                     
    secret: 'someVeRyN1c3S#cr3tHer34U',
    resave: false,                          
    saveUninitialized: true            
  },
  proxy: {
    trust: true
  },
  logRequests: false  
};</pre></div></div></div>
<div class="book" title="Modifying the user model" id="1CQAE1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Modifying the user model</h1></div></div></div><p class="calibre8">We don't need <a id="id334" class="calibre1"/>much information about a user, so we can reduce the <code class="email">User</code> schema to only the strictly necessary information. Also, we can add a <code class="email">profile</code> field, which can hold any extra info about the user, such as social media profile info or other accounts data.</p><p class="calibre8">Let's modify the <code class="email">User</code> schema from <code class="email">app/models/user.js</code> with the following:</p><div class="informalexample"><pre class="programlisting">const UserSchema = new Schema({
  email:  {
    type: String,
    required: true,
    unique: true
  },
  name: {
    type: String
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  passwordSalt: {
    type: String,
    required: true,
    select: false
  },
  profile: {
    type: Mixed
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});</pre></div></div>

<div class="book" title="The message history data model" id="1DOR01-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec41" class="calibre1"/>The message history data model</h1></div></div></div><p class="calibre8">The message <a id="id335" class="calibre1"/>history will be a collection of user-submitted messages through the chat application. We can choose from a number <a id="id336" class="calibre1"/>of approaches when storing such data in MongoDB. The good thing is that there is no correct implementation, although we have a number of common approaches and considerations for each implementation.</p><p class="calibre8">Our starting point will be that messages sent by users are part of a conversation thread. When two or more users chat with each other, initially a conversation thread is created for them. The messages become private for that conversation. This means that the messages have a parent-child relationship with another entity, a thread entity in our case.</p><p class="calibre8">Keeping in mind our application's requirements, we can explore the following implementations to store our messages:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Store each message in a separate document</strong></span>: This is the easiest to implement and it's the most flexible one, but it comes with some application-level complexity. </li><li class="listitem"><span class="strong"><strong class="calibre2">Embed all messages in the thread document</strong></span>: Because of MongoDB's limit on document size, this is not an acceptable solution.</li><li class="listitem"><span class="strong"><strong class="calibre2">Implement a hybrid solution</strong></span>: Messages are stored separately from the thread document but are held in a bucket-like manner, each bucket storing a limited number of documents. So, instead of storing all messages for a thread in one bucket, we are going to spread them out.</li></ul></div><p class="calibre8">For our application, we can go with the one-document-per-message implementation. It will provide us with the greatest flexibility and ease of implementation. Also, we can easily retrieve messages in a chronological and threaded order.</p></div>

<div class="book" title="The message history data model" id="1DOR01-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The thread schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec88" class="calibre1"/>The thread schema</h2></div></div></div><p class="calibre8">Each <a id="id337" class="calibre1"/>message is going to be part of a conversation thread. Information such as who is participating in the conversation will be stored in a document in the threads collection.</p><p class="calibre8">We are going to start with a simple schema with only the necessary fields, in which we'll store simple information about a thread. Create a new file called <code class="email">/app/models/thread.js</code> with the following schema design:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const ThreadSchema = new Schema({
  participants: {
    type: [
      {
        type: ObjectId,
        ref: 'User'
      }
    ]
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Thread', ThreadSchema);</pre></div><p class="calibre8">The most important part for us at the moment is the <code class="email">participants</code> field, which describes who is participating in the current conversation. By design, our application will support multiple users participating in the same conversation thread. Imagine it to be a channel, where your team can discuss a specific project.</p></div></div>

<div class="book" title="The message history data model" id="1DOR01-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The message schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec89" class="calibre1"/>The message schema</h2></div></div></div><p class="calibre8">As we <a id="id338" class="calibre1"/>said earlier, we are going to use the one-document-per-message approach. For now, we are going to have a fairly simple schema for our messages. This can change based on the application's complexity.</p><p class="calibre8">We are going to define our schema in <code class="email">app/models/message.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const ObjectId = Schema.ObjectId;

const MessageSchema = new Schema({
  sender: {
    type: ObjectId,
    required: true,
    ref: 'User'
  },
  thread: {
    type: ObjectId,
    required: true,
    ref: 'Thread'
  },
  body: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Message', MessageSchema);</pre></div><p class="calibre8">The schema is <a id="id339" class="calibre1"/>fairly simple. We have a sender that has a reference to a user and to a thread. In the thread entity, we are going to store additional data regarding the conversation.</p></div></div>

<div class="book" title="Thread backend" id="1ENBI1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec42" class="calibre1"/>Thread backend</h1></div></div></div><p class="calibre8">In the Node.js backend <a id="id340" class="calibre1"/>application, we are going make <a id="id341" class="calibre1"/>available endpoints, defined in our Express application routes, related to managing conversation threads. Also, there should be a way to get the message history from a specific thread.</p></div>

<div class="book" title="Thread backend" id="1ENBI1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Thread controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec90" class="calibre1"/>Thread controller</h2></div></div></div><p class="calibre8">We are <a id="id342" class="calibre1"/>going to add the necessary business logic to manage our threads in a new controller file, called <code class="email">app/controllers/thread.js</code>, by following these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the required modules:<div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Thread = mongoose.model('Thread');</pre></div></li><li class="listitem" value="2">Export the module's methods:<div class="informalexample"><pre class="programlisting">module.exports.allByUser = allThreadsByUser;
module.exports.find = findThread;
module.exports.open = openThread;
module.exports.findById = findThreadById;</pre></div></li><li class="listitem" value="3">Find all the threads for a specific user:<div class="informalexample"><pre class="programlisting">function allThreadsByUser(req, res, next) {
  Thread
  .find({
    participants: req.user._id
  })
  .populate('participants')
  .exec((err, threads) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.threads = threads;
    next();
  });
}</pre></div></li><li class="listitem" value="4">Find a thread by different criteria, for example, by the currently logged-in user and the ID of another user who participates in the conversation:<div class="informalexample"><pre class="programlisting">function findThread(req, res, next) {
  let query = {};
  if (req.body.userId) {
    query.$and = [
      { participants: req.body.userId },
      { participants: req.user._id.toString() }
    ];
  }

  if (req.body.participants) {
    query.$and = req.body.participants.map(participant =&gt; {
      return { participants: participant };
    });
  }

  Thread
  .findOne(query)
  .populate('participants')
  .exec((err, thread) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.thread = thread;
    next();
  });
}</pre></div></li><li class="listitem" value="5">Open <a id="id343" class="calibre1"/>a new conversation:<div class="informalexample"><pre class="programlisting">function openThread(req, res, next) {
  var data = {};

  //  If we have already found the thread 
  //  we don't need to create a new one
  if (req.resources.thread) {
    return next();
  }

  data.participants = req.body.participants || [req.user._id, req.body.user];

  Thread
  .create(data, (err, thread) =&gt; {
    if (err) {
      return next(err);
    }

    thread.populate('participants', (err, popThread) =&gt; {
      if (err) {
        return next(err);
      }

      req.resources.thread = popThread;
      next();
    });
  });
}</pre></div></li><li class="listitem" value="6">And <a id="id344" class="calibre1"/>finally, finding a thread by its ID:<div class="informalexample"><pre class="programlisting">function findThreadById(req, res, next) {
  Thread
  .findById(req.params.threadId, (err, thread) =&gt; {
    if (err) {
      return next(err);
    }

    req.resources.thread = thread;
    next();
  });
}</pre></div></li></ol><div class="calibre12"/></div></div></div>

<div class="book" title="Thread backend" id="1ENBI1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Defining routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec91" class="calibre1"/>Defining routes</h2></div></div></div><p class="calibre8">All of the <a id="id345" class="calibre1"/>necessary business logic is implemented in the controller file. We just need to mount the methods from the controller to the routes so that they can be called externally. Create a new file called <code class="email">app/routes/thread.js</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">const express = require('express');
const router = express.Router();
const threadCtrl = require('../controllers/thread');
const messageCtrl = require('../controllers/message');
const auth = require('../middlewares/authentication');
const authorize = require('../middlewares/authorization');
const response = require('../helpers/response');

module.exports = router;</pre></div><p class="calibre8">After we have added the necessary module dependencies, we can implement each route one by one:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Get all the user's threads:<div class="informalexample"><pre class="programlisting">router.get(
  '/threads',
  auth.ensured,
  threadCtrl.allByUser,
  response.toJSON('threads')
);</pre></div></li><li class="listitem" value="2">Open a new thread. If a thread already exists for the participants, it will be returned:<div class="informalexample"><pre class="programlisting">router.post(
  '/thread/open',
  auth.ensured,
  threadCtrl.find,
  threadCtrl.open,
  response.toJSON('thread')
);</pre></div></li><li class="listitem" value="3">Get a <a id="id346" class="calibre1"/>thread by ID:<div class="informalexample"><pre class="programlisting">router.get(
  '/threads/:threadId',
  auth.ensured,
  threadCtrl.findById,
  authorize.onlyParticipants('thread'),
  response.toJSON('thread')
)</pre></div></li><li class="listitem" value="4">Get all messages for a thread:<div class="informalexample"><pre class="programlisting">router.get(
  '/threads/:threadId/messages',
  auth.ensured,
  threadCtrl.findById,
  authorize.onlyParticipants('thread'),
  messageCtrl.findByThread,
  response.toJSON('messages')
);</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We jump a few steps and already used a method from the message controller; don't worry, we are going to implement it in the next step.</p></div></div>

<div class="book" title="Thread backend" id="1ENBI1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Message controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec92" class="calibre1"/>Message controller</h2></div></div></div><p class="calibre8">Our API <a id="id347" class="calibre1"/>should return the message history for a specific conversation. We are going to keep things simple and just retrieve all the data from the <code class="email">Message</code> collection from MongoDB. Create a new controller file, <code class="email">app/controllers/message.js</code>, and add the following logic to find all message documents for a thread:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Thread = mongoose.model('Thread');
const Message = mongoose.model('Message');
const ObjectId = mongoose.Types.ObjectId;

module.exports.findByThread = findMessagesByThread;

function findMessagesByThread(req, res, next) {
  let query = {
    thread: req.resources.thread._id
  };

  if (req.query.beforeId) {
    query._id = { $lt: new ObjectId(req.query.sinceId) };
  }

  Message
  .find(query)
  .populate('sender')
  .exec(function(err, messages) {
    if (err) {
      return next(err);
    }

    req.resources.messages = messages;
    next();
  });
}</pre></div><p class="calibre8">Because we <a id="id348" class="calibre1"/>have a lot of ground to cover, we are not going to treat pagination for the message history, neither on the backend nor on the frontend. But I've added a little bit of help in the preceding code. If the <code class="email">beforeId</code> query string is sent, then messages can be easily paginated by the last known ID. Also remember that the <code class="email">_id</code> field can be used to sort by, if it stores an <code class="email">ObjectId</code> value, is almost equivalent as sorting by creation time.</p><p class="calibre8">Let's dive a little bit deeper into this <code class="email">_id</code> field. Most MongoDB clients will generate the <code class="email">ObjectId</code> value to the <code class="email">_id</code> field by themselves. If no <code class="email">_id</code> field is sent with the document, <code class="email">mongod</code> (the primary daemon process for MongoDB) will add the field.</p><p class="calibre8">One problem we could encounter is if the message documents are generated by multiple processes or systems within a single second. In such a case, the insertion order will not be strictly preserved.</p></div></div>

<div class="book" title="Backend chat service" id="1FLS41-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec43" class="calibre1"/>Backend chat service</h1></div></div></div><p class="calibre8">So far, we've only <a id="id349" class="calibre1"/>scratched the surface of our <a id="id350" class="calibre1"/>backend application. We are going to add a service layer to our server. This abstraction layer will implement all the business logic, such as instant messaging. The service layer will handle interaction with other application modules and layers. </p><p class="calibre8">As for the <code class="email">WebSockets</code> part of the application, we are going to use <code class="email">socketIO</code>, which is a real-time communication <a id="id351" class="calibre1"/>engine. They have a really <a id="id352" class="calibre1"/>neat chat application example. If you haven't heard of it, you can <a id="id353" class="calibre1"/>take a look at the following link:</p><p class="calibre8">
<a class="calibre1" href="http://socket.io/get-started/chat/">http://socket.io/get-started/chat/</a>
</p></div>

<div class="book" title="Backend chat service" id="1FLS41-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Chat service implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec93" class="calibre1"/>Chat service implementation</h2></div></div></div><p class="calibre8">Now that we <a id="id354" class="calibre1"/>are familiar with <code class="email">socketIO</code>, we can continue and implement our chat service. We are going to start by creating a new file called <code class="email">app/services/chat/index.js</code>. This will be the main file for our chat service. Add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const socketIO = require('socket.io');
const InstantMessagingModule = require('./instant-messaging.module');

module.exports = build;

class ChatService {
}

function build(app, server) {
  return new ChatService(app, server);
}</pre></div><p class="calibre8">Don't worry about the <code class="email">InstantMessagingModule</code>. We just added it as a reference so that we'll not forget about it. We'll come back later to reveal the mystery. Our class should have a constructor. Let's add that now:</p><div class="informalexample"><pre class="programlisting">  constructor(app, server) {
    this.connectedClients = {};
    this.io = socketIO(server);
    this.sessionMiddleware = app.get('sessionMiddleware');
    this.initMiddlewares();
    this.bindHandlers();
  }</pre></div><p class="calibre8">In the constructor, we initialize <code class="email">socketIO</code>, get the session middleware, and finally bind all the handlers to our <code class="email">socketIO</code> instance. More information about the session middleware can be found in our Express configuration file, <code class="email">config/express.js</code>. Look for something <a id="id355" class="calibre1"/>similar:</p><div class="informalexample"><pre class="programlisting">  var sessionOpts = {
    secret: config.session.secret,
    key: 'skey.sid',
    resave: config.session.resave,
    saveUninitialized: config.session.saveUninitialized
  };

  if (config.session.type === 'mongodb') {
    sessionOpts.store = new MongoStore({
      url: config.mongodb.uri
    });
  }

  var sessionMiddleware = session(sessionOpts);
  app.set('sessionMiddleware', sessionMiddleware);</pre></div><p class="calibre8">The nice thing is that we can share this session logic with <code class="email">socketIO</code> and mount it with the <code class="email">.use()</code> method. This will be done in the <code class="email">.initMiddlewares()</code> method:</p><div class="informalexample"><pre class="programlisting">  initMiddlewares() {
    this.io.use((socket, next) =&gt; {
      this.sessionMiddleware(socket.request, socket.request.res, next);
    });

    this.io.use((socket, next) =&gt; {
      let user = socket.request.session.passport.user;

      //  authorize user
      if (!user) {
        let err = new Error('Unauthorized');
        err.type = 'unauthorized';
        return next(err);
      }

      // attach user to the socket, like req.user
      socket.user = {
        _id: socket.request.session.passport.user
      };
      next();
    });
  }</pre></div><p class="calibre8">First, we mount the session middleware to our instance, which will do something similar to mounting it on our Express app. Second, we check whether the user is present on the socket's session, in other words, whether the user is authenticated or not. </p><p class="calibre8">Being able to add middleware is a pretty neat feature and enables us to do interesting things for each <a id="id356" class="calibre1"/>connected socket. We should also add the last method from the constructor:</p><div class="informalexample"><pre class="programlisting">  bindHandlers() {
    this.io.on('connection', socket =&gt; {
      // add client to the socket list to get the session later
      this.connectedClients[socket.request.session.passport.user] = socket;
      InstantMessagingModule.init(socket, this.connectedClients, this.io);
    });
  }</pre></div><p class="calibre8">For each successfully connected client, we are going to initialize the instant messaging module and store the connected clients in a map, for later reference.</p></div></div>

<div class="book" title="Backend chat service" id="1FLS41-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Instant messaging module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec94" class="calibre1"/>Instant messaging module</h2></div></div></div><p class="calibre8">To be a <a id="id357" class="calibre1"/>little bit modular, we'll split functionalities that represent connected clients into separate modules. For now there will be only one module, but in the future, you can easily add new ones. The <code class="email">InstantMessagingModule</code> will be found in the same folder with the main chat file, more precisely, <code class="email">app/services/chat/instant-messaging.module.js</code>. You can safely add the following code to it:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Message = mongoose.model('Message');
const Thread = mongoose.model('Thread');

module.exports.init = initInstantMessagingModule;

class InstantMessagingModule {
}

function initInstantMessagingModule(socket, clients) {
  return new InstantMessagingModule(socket, clients);
}</pre></div><p class="calibre8">The service will use the <code class="email">Message</code> and <code class="email">Thread</code> models to validate and persist data. We are exporting an initialization function instead of the entire class. You could easily add extra initialization logic to the exported function.</p><p class="calibre8">The class constructor will be fairly simple, and it will look something similar to this:</p><div class="informalexample"><pre class="programlisting">  constructor(socket, clients) {
    this.socket = socket;
    this.clients = clients;
    this.threads = {};
    this.bindHandlers();
  }</pre></div><p class="calibre8">We <a id="id358" class="calibre1"/>just assign the necessary dependencies to each property, and bind all the handlers to the connected socket. Let's continue with the <code class="email">.bindHandlers()</code> method:</p><div class="informalexample"><pre class="programlisting">  bindHandlers() {
    this.socket.on('send:im', data =&gt; {
      data.sender = this.socket.user._id;

      if (!data.thread) {
        let err = new Error('You must be participating in a conversation.')
        err.type = 'no_active_thread';
        return this.handleError(err);
      }

      this.storeIM(data, (err, message, thread) =&gt; {
        if (err) {
          return this.handleError(err);
        }

        this.socket.emit('send:im:success', message);

        this.deliverIM(message, thread);
      });
    });
  }</pre></div><p class="calibre8">When sending a new message through WebSockets, it will be stored using the <code class="email">.storeIM()</code> method and delivered to each participant by the <code class="email">.deliverIM()</code> method.</p><p class="calibre8">We slightly abstracted the logic to send instant messages, so let's define our first method, which stores the messages:</p><div class="informalexample"><pre class="programlisting">  storeIM(data, callback) {
    this.findThreadById(data.thread, (err, thread) =&gt; {
      if (err) {
        return callback(err);
      }

      let user = thread.participants.find((participant) =&gt; {
        return participant.toString() === data.sender.toString();
      });

      if (!user) {
        let err = new Error('Not a participant.')
        err.type = 'unauthorized_thread';
        return callback(err);
      }

      this.createMessage(data, (err, message) =&gt; {
        if (err) {
          return callback(err);
        }

        callback(err, message, thread);
      });
    });
  }</pre></div><p class="calibre8">So <a id="id359" class="calibre1"/>basically, the <code class="email">.storeIM()</code> method finds the conversation thread and creates a new message. We have also added a simple authorization when storing a message. The sender must be a participant in the given conversation. You could move that piece of logic into a more suitable module. I'll leave it to you as practice.</p><p class="calibre8">Let's add the next two methods that we used before:</p><div class="informalexample"><pre class="programlisting">  findThreadById(id, callback) {
    if (this.threads[id]) {
      return callback(null, this.threads[id]);
    }

    Thread.findById(id, (err, thread) =&gt; {
      if (err) {
        return callback(err);
      }

      this.threads[id] = thread;
      callback(null, thread);
    });
  }

  createMessage(data, callback) {
    Message.create(data, (err, newMessage) =&gt; {
      if (err) {
        return callback(err);
      }

      newMessage.populate('sender', callback);
    });
  }</pre></div><p class="calibre8">Finally, we can deliver our message to the rest of the participants. The implementation can <a id="id360" class="calibre1"/>be found in the following class method:</p><div class="informalexample"><pre class="programlisting">  deliverIM(message, thread) {
    for (let i = 0; i &lt; thread.participants.length; i++) {
      if (thread.participants[i].toString() === message.sender.toString()) {
        continue;
      }

      if (this.clients[thread.participants[i]]) {
        this.clients[thread.participants[i]].emit('receive:im', message);
      }
    }
  }</pre></div><p class="calibre8">We have reached the end with our backend application. It should have all the necessary features implemented to start working on the client Angular application.</p></div></div>

<div class="book" title="Bootstrapping the Angular app" id="1GKCM1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec44" class="calibre1"/>Bootstrapping the Angular app</h1></div></div></div><p class="calibre8">It's time to start <a id="id361" class="calibre1"/>building our client application using <a id="id362" class="calibre1"/>Angular 2. We are going to integrate <code class="email">SocketIO</code> with the client to communicate with our backend application. We are going to showcase only the most important parts of the application, but you can look at the final version anytime.</p></div>

<div class="book" title="Bootstrapping the Angular app" id="1GKCM1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The boot file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec95" class="calibre1"/>The boot file</h2></div></div></div><p class="calibre8">We are going to <a id="id363" class="calibre1"/>boot our application from a specific file, and—probably you have already guessed it—it will be called <code class="email">public/src/boot.ts</code>. For better transparency and to foresee what we are going to build, the following code snippet from the <code class="email">boot.ts</code> file will be the final version, with all the necessary data added to it:</p><div class="informalexample"><pre class="programlisting">import { bootstrap } from 'angular2/platform/browser';
import { provide } from 'angular2/core';
import { HTTP_PROVIDERS } from 'angular2/http';
import { ROUTER_PROVIDERS, LocationStrategy, HashLocationStrategy } from 'angular2/router';
import { AppComponent } from './app.component';
import { ChatService }  from './services/chat.service';
import { ThreadService }  from './services/thread.service';
import { MessageService }  from './services/message.service';
import { UserService } from './services/user.service';

import 'rxjs/add/operator/map';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/combineLatest';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/debounceTime';

bootstrap(AppComponent, [
  HTTP_PROVIDERS, ROUTER_PROVIDERS,
  ChatService,
  ThreadService,
  MessageService,
  UserService,
  provide(LocationStrategy, {useClass: HashLocationStrategy})
]); </pre></div><p class="calibre8">We are going to <a id="id364" class="calibre1"/>implement four services for this particular application, and we'll start with an app component. For the sake of simplicity, we are going to use a hash-based location strategy.</p></div></div>

<div class="book" title="Bootstrapping the Angular app" id="1GKCM1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="App component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec96" class="calibre1"/>App component</h2></div></div></div><p class="calibre8">The main <a id="id365" class="calibre1"/>component of our application is the <code class="email">app</code> component. We are going to keep it simple for now, only adding a router outlet to it, and configure the routes of our application.</p><p class="calibre8">Create a new file called <code class="email">public/src/app.component.ts</code> with the following code:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { RouteConfig, RouterOutlet } from 'angular2/router';
import { Router } from 'angular2/router';
import { ChatComponent } from './chat/chat.component';

@RouteConfig([
  { path: '/messages/...', as: 'Chat', component: ChatComponent, useAsDefault: true }
])
@Component({
    selector: 'chat-app',
    directives: [
      RouterOutlet
    ],
    template: `
      &lt;div class="chat-wrapper row card whiteframe-z2"&gt;
        &lt;div class="chat-header col"&gt;
          &lt;h3&gt;Chat application&lt;/h3&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      &lt;/div&gt;
    `
})
export class AppComponent {
  constructor() {
  }
}</pre></div><p class="calibre8">We created the <a id="id366" class="calibre1"/>main application component and configured a route that will have child routes. By default, the <code class="email">ChatComponent</code> will be mounted. So, this was very basic. Before we continue with our application's components, let's take a break and define custom data types.</p></div></div>

<div class="book" title="Custom data types" id="1HIT81-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec45" class="calibre1"/>Custom data types</h1></div></div></div><p class="calibre8">In order to group similar <a id="id367" class="calibre1"/>functionalities and <a id="id368" class="calibre1"/>have custom type checking, we are going to define classes for each entity used in our application. This will give us access to custom initialization and default values when creating entities.</p></div>

<div class="book" title="Custom data types" id="1HIT81-5c78d361d97340239270192b72d53e7b">
<div class="book" title="User type"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec97" class="calibre1"/>User type</h2></div></div></div><p class="calibre8">Our first custom data type <a id="id369" class="calibre1"/>used in the frontend Angular application will be a user. You can use an interface to define a custom type or a regular class. If you need default values or custom validation, go with a regular class definition.</p><p class="calibre8">Create a new file called <code class="email">public/src/datatypes/user.ts</code> and add the following class:</p><div class="informalexample"><pre class="programlisting">export class User {
  _id: string;
  email: string;
  name: string;
  avatar: string;
  createdAt: string;

  constructor(_id?: string, email?: string, name?: string, createdAt?: string) {
    this._id = _id;
    this.email = email;
    this.name = name;
    this.avatar = 'http://www.gravatar.com/avatar/{{hash}}?s=50&amp;r=g&amp;d=retro'.replace('{{hash}}', _id);     this.createdAt = createdAt;
  }
}</pre></div><p class="calibre8">When instantiating a new user, the <code class="email">user</code> instance will have the <code class="email">avatar</code> property prepopulated, with a specific link for the avatar picture. I've used a <code class="email">gravatar</code> for this and added the user's ID as a <a id="id370" class="calibre1"/>hash to generate the image. Normally, you have to use the user's e-mail as an <code class="email">md5</code> hash. Obviously, the avatar image can be provided by any service. You can even try adding file upload and profile management to this application.</p></div></div>

<div class="book" title="Custom data types" id="1HIT81-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Thread type"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec98" class="calibre1"/>Thread type</h2></div></div></div><p class="calibre8">Next, we are <a id="id371" class="calibre1"/>going to define a thread class, with some custom initialization logic. Create a new file, called <code class="email">public/src/datatypes/thread.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { User } from './user';

export class Thread {
  _id: string;
  name: string;
  participants: Array&lt;User&gt;;
  createdAt: string;

  constructor(_id?: string, name?: string, participants?: Array&lt;User&gt;, createdAt?: string) {
    this._id = _id;
    this.name = name || '';
    this.participants = participants || [];
    this.createdAt = createdAt;
  }

  generateName(omittedUser) {
    let names = [];
    this.participants.map(participant =&gt; {
      if (omittedUser._id !== participant._id) {
        names.push(participant.name);
      }
    });

    return (names[1]) ? names.join(', ') : names[0];
  }
}</pre></div><p class="calibre8">As you can see, the user data type was imported and used to signal that the participants for a given thread <a id="id372" class="calibre1"/>must be an array of users. Also, a class method was defined to generate a custom name for a specific thread-based on the participating users in the conversation thread.</p></div></div>

<div class="book" title="Custom data types" id="1HIT81-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Message type"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec99" class="calibre1"/>Message type</h2></div></div></div><p class="calibre8">At last, we are going <a id="id373" class="calibre1"/>to define what structure a message will have in our application. For that, we are going to create a new file called <code class="email">public/src/datatypes/message.ts</code> with the following logic:</p><div class="informalexample"><pre class="programlisting">export class Message {
  _id: string;
  sender: any;
  thread: string;
  body: string;
  createdAt: string;
  time: string;
  fulltime: string;

  constructor(_id?: string, sender?: any, thread?: string, body?: string, createdAt?: string) {
    this._id = _id;
    this.sender = sender;
    this.body = body;
    this.createdAt = createdAt;
    this.time = this._generateTime(new Date(createdAt));
    this.fulltime = this._generateDateTime(new Date(createdAt));
  }

  private _generateTime(date) {
    return  date.getHours() + ":"
          + date.getMinutes() + ":"
          + date.getSeconds();
  }

  private _generateDateTime(date) {
    return date.getDate() + "/"
          + (date.getMonth()+1)  + "/"
          + date.getFullYear() + " @ "
          + this._generateTime(date);
  }
}</pre></div><p class="calibre8">You may already be thinking, "Why not include the <code class="email">User</code> data type and mark the sender as a user?" To be honest, this is not a must have. You can have <span class="strong"><em class="calibre11">any</em></span> type you like and the code would be still valid. It's up to you how much granularity you want to add to your code.</p><p class="calibre8">Getting back to our <a id="id374" class="calibre1"/>code, we have added two extra methods to the <code class="email">Message</code> class in order to generate two timestamps, one that displays the time when the message was created and one that displays a full timestamp with date and time.</p></div></div>

<div class="book" title="Application services"><div class="book" id="1IHDQ2-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec46" class="calibre1"/>Application services</h1></div></div></div><p class="calibre8">In the initial <a id="id375" class="calibre1"/>chapters, we grouped our files by <a id="id376" class="calibre1"/>their domain context. We did things a bit differently this time to highlight the fact that you can also start with a more flat approach. And, if necessary, you can start grouping your files based on their domain context instead of their type.</p><p class="calibre8">Still, we are going to group our components based on their context in order to locate them faster. Also imagine that you can load the whole application into a different application, and having a flatter folder structure will reduce the unnecessary navigation hassle. </p></div>

<div class="book" title="Application services">
<div class="book" title="User service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec100" class="calibre1"/>User service</h2></div></div></div><p class="calibre8">We are going to start <a id="id377" class="calibre1"/>with a simple service that will handle all of the user application logic. Create a new file called <code class="email">public/src/services/user.service.ts</code> with the following code:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { contentHeaders } from '../common/headers';
import { User } from '../datatypes/user';

type ObservableUsers = Observable&lt;Array&lt;User&gt;&gt;;

@Injectable()
export class UserService {
  public users: ObservableUsers;
  public user: User;
  private _http: Http;
  private _userObservers: any;
  private _dataStore: { users: Array&lt;User&gt; };

  constructor(http: Http) {
    this._http = http;
    this.users = new Observable(observer =&gt; this._userObservers = observer).share();
    this._dataStore = { users: [] };
    this.getAll();
  }
}</pre></div><p class="calibre8">We exposed a <a id="id378" class="calibre1"/><code class="email">users</code> property, which is an observable, and transformed it to a <code class="email">hot</code> observable. We defined an internal data storage for the service, which is a simple object. Almost forgot to mention! Remember to import your dependencies. As a closing line for our constructor, we retrieve all users from the backend. We are doing this in the service so that we don't have to call it explicitly from a component.</p><p class="calibre8">Actually, the <code class="email">.getAll()</code> method is not implemented, so let's append the following method to the class:</p><div class="informalexample"><pre class="programlisting">  getAll() {
    return this._http
    .get('/api/users', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .subscribe(users =&gt; this.storeUsers(users));
  }</pre></div><p class="calibre8">We have also moved the data persistence to another method, just in case we want to use it somewhere else. Add the following method to the <code class="email">UserService</code> class:</p><div class="informalexample"><pre class="programlisting">  storeUsers(users: Array&lt;User&gt;) {
    this._dataStore.users = users;
    this._userObservers.next(this._dataStore.users);
  }</pre></div><p class="calibre8">For now, our application has all the necessary functionalities from <code class="email">UserService</code>, and we can move on to implementing other application components.</p></div></div>

<div class="book" title="Application services">
<div class="book" title="The thread service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec101" class="calibre1"/>The thread service</h2></div></div></div><p class="calibre8">The <a id="id379" class="calibre1"/>thread service will handle and share across our application data related to threads. We are going to store the retrieved threads from the backend. Also, the currently active thread will be stored in this service.</p><p class="calibre8">Let's start by <a id="id380" class="calibre1"/>creating the service file, called <code class="email">public/src/services/thread.service.ts</code>. After that, follow a few steps to implement the core logic of the service:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Load the necessary dependencies:<div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { contentHeaders } from '../common/headers';
import { Thread } from '../datatypes/thread';
import { User } from '../datatypes/user';</pre></div></li><li class="listitem" value="2">Define a few custom data types:<div class="informalexample"><pre class="programlisting">type ObservableThreads = Observable&lt;Array&lt;Thread&gt;&gt;;
type SubjectThread = Subject&lt;Thread&gt;;</pre></div></li><li class="listitem" value="3">Define the base class:<div class="informalexample"><pre class="programlisting">@Injectable()
export class ThreadService {
  public threads: ObservableThreads;
  public currentThread: SubjectThread = new BehaviorSubject&lt;Thread&gt;(new Thread());
  private _http: Http;
  private _threadObservers: any;
  private _dataStore: { threads: Array&lt;Thread&gt; };
  private _currentUser: any;
}</pre></div></li><li class="listitem" value="4">Add the constructor:<div class="informalexample"><pre class="programlisting">  constructor(http: Http) {
    this._http = http;
    this._dataStore = { threads: [] };
    this.threads = new Observable(
      observer =&gt; this._threadObservers = observer
    ).share();
  }</pre></div></li><li class="listitem" value="5">Append the necessary method to get all threads from the server:<div class="informalexample"><pre class="programlisting">  getAll() {
    return this._http
    .get('/api/threads', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map(data =&gt; {
      return data.map(thread =&gt; {
        return new Thread(thread._id, thread._id, thread.participants, thread.createdAt)
      });
    })
    .subscribe(threads =&gt; {
      this._dataStore.threads = threads;
      this._threadObservers.next(this._dataStore.threads);
    });</pre></div><p class="calibre22">This method will retrieve all the threads from the backend service. It will store them inside the service's data store and push the latest values to the thread observers so that all subscribers can get the latest values.</p></li><li class="listitem" value="6">Define <a id="id381" class="calibre1"/>how to open a new thread:<div class="informalexample"><pre class="programlisting">  open(data: any) {
    return this._http
    .post('/api/thread/open', JSON.stringify(data), { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map(data =&gt; {
      return new Thread(data._id, data.name, data.participants, data.createdAt);
    });
  }</pre></div><p class="calibre22">The <code class="email">open()</code> method will return an observable instead of handling data inside the service.</p></li><li class="listitem" value="7">We also need to be able to set the current thread:<div class="informalexample"><pre class="programlisting">  setCurrentThread(newThread: Thread) {
    this.currentThread.next(newThread);
  }</pre></div><p class="calibre22">
<code class="email">currentThread</code> is a <code class="email">BehaviorSubject</code> that will hold only the last value and share it with any new subscriber. This comes in handy when storing the current thread. Remember that you need to initialize the subject with an initial value. </p></li><li class="listitem" value="8">Expose a method to store threads from an external data source:<div class="informalexample"><pre class="programlisting">  storeThread(thread: Thread) {
    var found = this._dataStore.threads.find(t =&gt; {
      return t._id === thread._id;
    });

    if (!found) {
      this._dataStore.threads.push(thread);
      this._threadObservers.next(this._dataStore.threads);
    }
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We don't <a id="id382" class="calibre1"/>want to store the same thread twice. One thing we can improve is updating the thread if it has changed, but we don't need this in our application at this point. It is something you should remember when you are improving this application.</p><p class="calibre8">With the last implemented logic, we should have the minimal functionality required for the conversation threads.</p></div></div>

<div class="book" title="Application services">
<div class="book" title="The message service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec102" class="calibre1"/>The message service</h2></div></div></div><p class="calibre8">The <a id="id383" class="calibre1"/>message service is going to be a little bit different, because we are going to use socket.io to send and receive data through <code class="email">WebSockets</code> from the socket server, which was set up earlier in this chapter. No worries! The difference will not be reflected in the rest of the application. A service should always abstract the underlining logic.</p><p class="calibre8">We are going to start by creating the service file, called <code class="email">public/src/services/message.service.ts</code>, and import the necessary dependencies:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { ThreadService } from './thread.service';
import { contentHeaders } from '../common/headers';
import { Message } from '../datatypes/message';
import { User } from '../datatypes/user';
import * as io from 'socket.io-client';</pre></div><p class="calibre8">You can see that we imported everything from the <code class="email">socket.io-client</code> library as <code class="email">io</code>. Next, we are going to append the class definition:</p><div class="informalexample"><pre class="programlisting">type ObservableMessages = Observable&lt;Array&lt;Message&gt;&gt;;

@Injectable()
export class MessageService {
  public messages: ObservableMessages;

  private _http: Http;
  private _threadService: ThreadService;
  private _io: any;
  private _messagesObservers: any;
  private _dataStore: { messages: Array&lt;Message&gt; };

  constructor(http: Http, threadService: ThreadService) {
    this._io = io.connect();
    this._http = http;
    this._threadService = threadService;
    this.messages = new Observable(observer =&gt; this._messagesObservers = observer).share();
    this._dataStore = { messages: [] };
    this._socketOn();
  }
}</pre></div><p class="calibre8">In the <a id="id384" class="calibre1"/>constructor, we are going to initialize and connect to the socket server. Because we are using the default configuration both on the server side and the client side, we can just call the <code class="email">.connect()</code> method. The <code class="email">_socketOn()</code> private method will define all event bindings for the socket; let's append this method:</p><div class="informalexample"><pre class="programlisting">  private _socketOn() {
    this._io.on('receive:im', message =&gt; this._storeMessage(message));
    this._io.on('send:im:success', message =&gt; this._storeMessage(message));
  }</pre></div><p class="calibre8">We just defined two events to listen for and call the <code class="email">_storeMessage()</code> method. For each event, a new message will arrive through the socket. Following this, we should add the method to our <code class="email">MessageSerivce</code> class:</p><div class="informalexample"><pre class="programlisting">  private _storeMessage(message: Message) {
    let sender = new User(
      message.sender._id,
      message.sender.email,
      message.sender.name,
      message.sender.createdAt
    );
    let m = new Message(
      message._id,
      new User(sender._id, sender.email, sender.name, sender.createdAt),
      message.thread,
      message.body,
      message.createdAt
    );
    this._dataStore.messages.push(m);
    this._messagesObservers.next(this._dataStore.messages);
  }</pre></div><p class="calibre8">When storing a new message, we are going to create a new <code class="email">User</code> instance in order to have all the necessary data regarding the message sender. This method will only be used internally <a id="id385" class="calibre1"/>within the service, but we need to expose a method to send messages, and it will be accessed by other components:</p><div class="informalexample"><pre class="programlisting">  sendMessage(message: Message) {
    this._io.emit('send:im', message);
  }</pre></div><p class="calibre8">Sending a message was not so hard. We had to emit the <code class="email">send:im</code> event and attach the message itself. Besides sending and receiving messages, we also need to get the message history for a given thread and store the messages in the service's data store. Let's do that right now:</p><div class="informalexample"><pre class="programlisting">  getByThread(threadId) {
    this._http
    .get('/api/threads/'+threadId+'/messages', { headers: contentHeaders })
    .map((res: Response) =&gt; res.json())
    .map(res =&gt; {
      return res.map(data =&gt; {
        let sender = new User(
          data.sender._id,
          data.sender.email,
          data.sender.name,
          data.sender.createdAt
        );
        return new Message(
          data._id,
          sender,
          data.thread,
          data.body,
          data.createdAt
        );
      });
    })
    .subscribe(messages =&gt; {
      this._dataStore.messages = messages;
      this._messagesObservers.next(this._dataStore.messages);
    });
  }</pre></div><p class="calibre8">The preceding method should retrieve for us the necessary data from the Express application. We <a id="id386" class="calibre1"/>are doing the same thing for each message as before when we stored an incoming message. More precisely, we are instantiating a new user with the sender's information. This should be all for the message service.</p></div></div>
<div class="book" title="The chat component" id="1JFUC1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec47" class="calibre1"/>The chat component</h1></div></div></div><p class="calibre8">Now that we have <a id="id387" class="calibre1"/>all the necessary data types and services, we can get back to our application's components. Looking back at the <code class="email">app</code> component, a good thing would be to start with the <code class="email">chat</code> component. Create a new file called <code class="email">public/src/chat/chat.component.ts</code> and add the following imports:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { RouteConfig, RouterOutlet } from 'angular2/router';
import { ChatService } from '../services/chat.service';
import { ThreadListComponent } from '../thread/thread-list.component';
import { MessageListComponent } from '../message/message-list.component';
import { MessageFormComponent } from '../message/message-form.component';
import { UserListComponent } from '../user/user-list.component';
import { ChatHelpComponent } from './chat-help.component';</pre></div><p class="calibre8">After we have imported all our required modules, we can actually implement our component:</p><div class="informalexample"><pre class="programlisting">@RouteConfig([
  { path: '/',            as: 'ThreadMessagesDefault', component: ChatHelpComponent, useAsDefault: true },
  { path: '/:identifier', as: 'ThreadMessages', component: MessageListComponent }
])
@Component({
  selector: 'chat',
  directives: [
    ThreadListComponent,
    MessageFormComponent,
    UserListComponent,
    RouterOutlet
  ],
  template: `
    &lt;div class="threads-container col sidebar"&gt;
      &lt;user-list&gt;&lt;/user-list&gt;
      &lt;thread-list&gt;&lt;/thread-list&gt;
    &lt;/div&gt;

    &lt;div class="messages-container col content"&gt;
      &lt;router-outlet&gt;&lt;/router-outlet&gt;

      &lt;div class="message-form-container"&gt;
        &lt;message-form&gt;&lt;/message-form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `
})
export class ChatComponent {
  private _chatService: ChatService;

  constructor(chatService: ChatService) {
    this._chatService = chatService;
  }
}</pre></div><p class="calibre8">In the component's template are included components that we'll implement later on, for example, the thread list component, which will display all the current conversations with other users. The chat <a id="id388" class="calibre1"/>component will be the container for our smaller components, but we are also adding a <code class="email">RouterOutlet</code> to dynamically load components matched to the current route.</p><p class="calibre8">The default route will load a helper component in case no thread ID is added as a parameter in the route. We can associate this with a home page for our component. You can make the default view as complex as you want; for example, you can add a link for the last opened thread. We are going to keep it simple for now. Create a new file called <code class="email">public/src/chat-help.component.ts</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';

@Component({
  selector: 'chat-help',
  template: `
    &lt;h2&gt;Start a new conversation with someone&lt;/h2&gt;
  `
})
export class ChatHelpComponent {
  constructor() {
  }
}</pre></div><p class="calibre8">Noting fancy here! Just a simple component with an inline template that has a nice message displayed for the user. Now that we have covered this, we can move on and implement the rest <a id="id389" class="calibre1"/>of our components.</p></div>
<div class="book" title="The user list component" id="1KEEU1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec48" class="calibre1"/>The user list component</h1></div></div></div><p class="calibre8">The user list <a id="id390" class="calibre1"/>component will give us the ability to search <a id="id391" class="calibre1"/>for users and start a new conversation with them. We will need to display a list of users and filter them by a search criterion. Also, by clicking on a user from the list, a new conversation thread should open. All this should be fairly simple to implement. Let's start by creating the component file. Create a new file called <code class="email">public/src/user/user.component.ts</code>, with the following base structure:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { Router } from 'angular2/router'
import { Subject } from 'rxjs/Subject';
import { ReplaySubject } from 'rxjs/Subject/ReplaySubject';
import { UserService } from '../services/user.service';
import { ThreadService } from '../services/thread.service';
import { User } from '../datatypes/user';

@Component({
    selector: 'user-list',
    template: ``
})
export class UserListComponent {
  public users: Array&lt;User&gt;;
  public filteredUsers: Array&lt;User&gt;;
  public selected: boolean = false;
  public search: Subject&lt;String&gt; = new ReplaySubject(1);
  public searchValue: string = '';
  private _threadService: ThreadService;
  private _userService: UserService;
  private _router: Router;

  constructor(userService: UserService, threadService: ThreadService, router: Router) {
    this._userService = userService;
    this._threadService = threadService;
    this._router = router;
  }
}</pre></div><p class="calibre8">We imported the necessary dependencies and defined the base for our component. The component will have two major parts, a list of users and an input field, which will be used to search for a given user from the list. Let's define the template for our component:</p><div class="informalexample"><pre class="programlisting">      &lt;div class="user-search-container"&gt;
        &lt;input
          type="text"
          class="form-control block"
          placeholder="start a conversation"
          [(ngModel)]="searchValue"
          (focus)="onFocus($event)"
          (input)="onInput($event)"
          (keydown.esc)="onEsc($event)"
        /&gt;
      &lt;/div&gt;
      &lt;div class="user-list-container"&gt;
        &lt;div class="users-container" [ngClass]="{active: selected }"&gt;
          &lt;div class="user-list-toobar"&gt;
            &lt;a href="#" (click)="onClose($event)" class="close-button"&gt;
              &lt;span&gt;×&lt;/span&gt;
              &lt;span class="close-text"&gt;esc&lt;/span&gt;
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div *ngFor="#user of filteredUsers"&gt;
            &lt;a href="javascript:void(0);" (click)="openThread($event, user)"&gt;{{user.name}}&lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;</pre></div><p class="calibre8">In order to show a <a id="id392" class="calibre1"/>list of users, we are going to subscribe to the <code class="email">users</code> observable from the user service. Append the following code to the constructor:</p><div class="informalexample"><pre class="programlisting">    this._userService.users.subscribe(users =&gt; {
      this.filteredUsers = this.users = users;
    });</pre></div><p class="calibre8">To display a list of filtered users, we are going to use the following logic. Append this code to the constructor:</p><div class="informalexample"><pre class="programlisting">    this.search
      .debounceTime(200)
      .distinctUntilChanged()
      .subscribe((value: string) =&gt; {
        this.filteredUsers = this.users.filter(user =&gt; {
          return user.name.toLowerCase().startsWith(value);
        });
      });</pre></div><p class="calibre8">To feed data from the input, we can use something like this method, which will execute only when the user starts typing:</p><div class="informalexample"><pre class="programlisting">  onInput(event) {
    this.search.next(event.target.value);
  }</pre></div><p class="calibre8">In order to open a <a id="id393" class="calibre1"/>new thread, we bound a click event for each user displayed in the list. Let's add the required method for this:</p><div class="informalexample"><pre class="programlisting">  openThread(event, user: User) {
    this._threadService.open({ userId: user._id }).subscribe(thread =&gt; {
      this._threadService.storeThread(thread);
      this._router.navigate(['./ThreadMessages', { identifier: thread._id}]);
      this.cleanUp();
    });
  }</pre></div><p class="calibre8">The preceding code will just call the <code class="email">.open()</code> method from the thread service, and upon success, it will navigate to the returned thread. We are also calling the <code class="email">cleanUp()</code> method from this component, which will reset our component to the initial state.</p><p class="calibre8">Finally, let's add all the missing logic from our component. Just append the methods to the component:</p><div class="informalexample"><pre class="programlisting">  onFocus() {
    this.selected = true;
  }

  onClose(event) {
    this.cleanUp();
    event.preventDefault();
  }

  onEsc(event) {
    this.cleanUp();
    let target: HTMLElement = &lt;HTMLElement&gt;event.target;
    target.blur();
    event.preventDefault();
  }
  cleanUp() {
    this.searchValue = '';
    this.selected = false;
    this.search.next('');
  }</pre></div><p class="calibre8">As a quick recap, we <a id="id394" class="calibre1"/>created a user list component that displays all users in a list when focusing on the search input; by default, the list is hidden. We added some special events; for example, by pressing the <span class="strong"><em class="calibre11">Esc</em></span> key, the list should be hidden.</p></div>

<div class="book" title="Displaying threads" id="1LCVG1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec49" class="calibre1"/>Displaying threads</h1></div></div></div><p class="calibre8">A user must <a id="id395" class="calibre1"/>know in which conversation he/she is <a id="id396" class="calibre1"/>participating, so we need to display this information to the user. To do so, we are going to implement a thread listing component.</p></div>

<div class="book" title="Displaying threads" id="1LCVG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Thread component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec103" class="calibre1"/>Thread component</h2></div></div></div><p class="calibre8">In order to display a <a id="id397" class="calibre1"/>list of threads, we are going to use a component for each thread to encapsulate all the information displayed to the user and functionalities. To create the desired component, follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the component file, called <code class="email">public/src/thread/thread.component.ts</code>.</li><li class="listitem" value="2">Import the necessary dependencies:<div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouterLink } from 'angular2/router';
import { ThreadService } from '../services/thread.service';
import { Thread } from '../datatypes/thread';</pre></div></li><li class="listitem" value="3">Add the component annotation:<div class="informalexample"><pre class="programlisting">@Component({
    inputs: ['thread'],
    selector: 'thread',
    directives: [ RouterLink ],
    template: `
      &lt;div class="thread-item"&gt;
        &lt;a href="#" [routerLink]="['./ThreadMessages', { identifier: thread._id }]" data-id="{{thread._id}}"&gt;
          {{thread.name}}
          &lt;span *ngIf="selected"&gt; &amp;bull; &lt;/span&gt;
        &lt;/a&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="4">Define the component's class:<div class="informalexample"><pre class="programlisting">export class ThreadComponent implements OnInit {
  public thread: Thread;
  public selected: boolean = false;
  private _threadService: ThreadService;

  constructor(threadService: ThreadService) {
    this._threadService = threadService;
  }

  ngOnInit() {
    this._threadService.currentThread.subscribe( (thread: Thread) =&gt; {
      this.selected = thread &amp;&amp; this.thread &amp;&amp; (thread._id === this.thread._id);
    });
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">We created a single <a id="id398" class="calibre1"/>thread component to be used to display information in a list. We are using <code class="email">routerLink</code> to navigate to the desired conversation thread. On initialization, we check which is the current thread so that we can mark the selected thread. </p></div></div>

<div class="book" title="Displaying threads" id="1LCVG1-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Thread list component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec104" class="calibre1"/>Thread list component</h2></div></div></div><p class="calibre8">Now that we <a id="id399" class="calibre1"/>have our thread component, we can display them in a list. For this, a new component will be used. Let's do something similar to what was done before:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the component file, called <code class="email">public/src/thread/thread-list.component.ts</code>.</li><li class="listitem" value="2">Import the necessary dependencies, together with the <code class="email">thread</code> component:<div class="informalexample"><pre class="programlisting">import { Component, ChangeDetectionStrategy } from 'angular2/core';
import { Observable } from 'rxjs/Observable';
import { ThreadService } from '../services/thread.service';
import { Thread } from '../datatypes/thread';
import { ThreadComponent } from './thread.component';</pre></div></li><li class="listitem" value="3">Build the component annotation:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'thread-list',
    directives: [ThreadComponent],
    // changeDetection: ChangeDetectionStrategy.OnPushObserve,
    // changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
      &lt;h4&gt;Recent &lt;span class="muted"&gt;({{threads.length}})&lt;/span&gt;&lt;/h4&gt;
      &lt;thread
        *ngFor="#thread of threads"
        [thread]="thread"&gt;
      &lt;/thread&gt;
    `
})</pre></div></li><li class="listitem" value="4">Define the <a id="id400" class="calibre1"/><code class="email">ThreadListComponent</code> class:<div class="informalexample"><pre class="programlisting">export class ThreadListComponent {
  public threads: Array&lt;Thread&gt; = [];
  private _threadService: ThreadService;

  constructor(threadService: ThreadService) {
    this._threadService = threadService;
    this._threadService.threads.subscribe(threads =&gt; {
      this.threads = threads;
    });
    this._threadService.getAll();
  }
}</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">This should display a nice list of opened conversation threads for the user. We are using the <code class="email">thread</code> service to get the necessary data for the component. If the <code class="email">threads</code> collection from the service changes, the update strategy will handle the necessary updates for us.</p></div></div>

<div class="book" title="Messaging" id="1MBG21-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec50" class="calibre1"/>Messaging</h1></div></div></div><p class="calibre8">Now that we can initiate <a id="id401" class="calibre1"/>and resume a conversation, we <a id="id402" class="calibre1"/>need to be able to send messages in that conversation to the participants. We are going to focus on achieving this functionality. </p><p class="calibre8">The flow for sending messages is pretty simple. First, we send the desired message to the backend application, storing the message for history purposes, and we notify the recipient of a new message. Both <a id="id403" class="calibre1"/>the sender and the recipient have the message <a id="id404" class="calibre1"/>displayed on their devices.</p></div>

<div class="book" title="Messaging" id="1MBG21-5c78d361d97340239270192b72d53e7b">
<div class="book" title="Sending messages"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec105" class="calibre1"/>Sending messages</h2></div></div></div><p class="calibre8">Earlier, in the <code class="email">chat</code> <a id="id405" class="calibre1"/>component, we used a <code class="email">message form</code> component. This component will permit us to input messages and send them to the Node.js backend service. Let's keep it simple and add only the necessary functionalities. Create a new component file called <code class="email">public/src/message/message-form.component.ts</code>.</p><p class="calibre8">We are going to <a id="id406" class="calibre1"/>import two services in our component. We append the following code for our dependencies:</p><div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { ThreadService } from '../services/thread.service';
import { MessageService } from '../services/message.service';
import { Message } from '../datatypes/message';
import { User } from '../datatypes/user';
import { Thread } from '../datatypes/thread';</pre></div><p class="calibre8">Now we are going to add the component annotation and define the component's class:</p><div class="informalexample"><pre class="programlisting">@Component({
    selector: 'message-form',
    // changeDetection: ChangeDetectionStrategy.OnPush,
    template: `
      &lt;input
        class="message-form form-control"
        autocorrect="off" autocomplete="off" spellcheck="true"
        (keydown.enter)="onEnter($event)"
        [(ngModel)]="draftMessage.body"
      &gt;
    `
})
export class MessageFormComponent implements OnInit {

  constructor() {
  }

  ngOnInit() {
  }
}</pre></div><p class="calibre8">To define the rest of the necessary logic, we are going to follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the following properties to the class:<div class="informalexample"><pre class="programlisting">  public draftMessage: Message;
  private _messageService: MessageService;
  private _threadService: ThreadService;
  private _thread: Thread;</pre></div></li><li class="listitem" value="2">Change the constructor to something similar to the following:<div class="informalexample"><pre class="programlisting">  constructor(messageService: MessageService, threadService: ThreadService) {
    this._messageService = messageService;
    this._threadService = threadService;
    this._threadService.currentThread.subscribe(thread =&gt; this._thread = thread);
  }</pre></div></li><li class="listitem" value="3">Modify the component's initialization to reset the <code class="email">draft message</code> value:<div class="informalexample"><pre class="programlisting">  ngOnInit() {
    this.draftMessage = new Message();
  }</pre></div></li><li class="listitem" value="4">Add the <a id="id407" class="calibre1"/>send message logic:<div class="informalexample"><pre class="programlisting">  sendMessage() {
    let message: Message = this.draftMessage;
    message.thread = this._thread._id;
    this._messageService.sendMessage(message);
    this.draftMessage = new Message();
  }</pre></div><p class="calibre22">This will simply call the <code class="email">.sendMessage()</code> method from the <code class="email">thread</code> service.</p></li><li class="listitem" value="5">Define what happens when the user hits the <span class="strong"><em class="calibre11">Enter</em></span> key:<div class="informalexample"><pre class="programlisting">  onEnter(event: any) {
    this.sendMessage();
    event.preventDefault();
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">Technically, we can now send messages to the backend and persist them in MongoDB to construct the message history.</p></div></div>

<div class="book" title="Messaging" id="1MBG21-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The message component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec106" class="calibre1"/>The message component</h2></div></div></div><p class="calibre8">To display all the <a id="id408" class="calibre1"/>messages, we are going to start small and create the message component. This component will be a single entry from the list of messages. We should already have the necessary data and logic to display a single message.</p><p class="calibre8">To implement the <code class="email">message</code> component, create a new file called <code class="email">public/src/message/message.component.ts</code> and append the following code:</p><div class="informalexample"><pre class="programlisting">import { Component, AfterViewInit } from 'angular2/core';

@Component({
    inputs: ['message'],
    selector: 'message',
    template: `
      &lt;div class="message-item"&gt;
        &lt;div class="message-identifier"&gt;
          &lt;img src="{{message.sender.avatar}}" width="36" height="36"/&gt;
        &lt;/div&gt;
        &lt;div class="message-content"&gt;
          &lt;div class="message-sender"&gt;
            &lt;span class="user-name"&gt;{{message.sender.name}}&lt;/span&gt;
            &lt;span class="message-timestamp" title={{message.fulltime}}&gt;{{message.time}}&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class="message-body"&gt;
            {{message.body}}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
})
export class MessageComponent implements AfterViewInit {
  constructor() {
  }

  ngAfterViewInit() {
    var ml = document.querySelector('message-list .message-list');
    ml.scrollTop = ml.scrollHeight;
  }
}</pre></div><p class="calibre8">The component is <a id="id409" class="calibre1"/>fairly simple. It just displays data about a single message, and after the view has initialized, it will scroll the message list to the bottom. With the last functionality, if there are more messages than can actually fit in the view, it will simply scroll to the latest message.</p></div></div>

<div class="book" title="Messaging" id="1MBG21-5c78d361d97340239270192b72d53e7b">
<div class="book" title="The message list component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec107" class="calibre1"/>The message list component</h2></div></div></div><p class="calibre8">Before we <a id="id410" class="calibre1"/>implemented a single message component, this was necessary for our message list component, which will display all messages to the user. We are going to use a similar pattern to implement this component as for the thread list.</p><p class="calibre8">Follow these steps to implement the message list component:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Import the necessary dependencies:<div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { RouteParams } from 'angular2/router';
import { MessageService } from '../services/message.service';
import { ThreadService } from '../services/thread.service';
import { Thread } from '../datatypes/thread';
import { Message } from '../datatypes/message';
import { MessageComponent } from './message.component';</pre></div></li><li class="listitem" value="2">Append <a id="id411" class="calibre1"/>the Angular component annotation:<div class="informalexample"><pre class="programlisting">@Component({
    selector: 'message-list',
    directives: [MessageComponent],
    template: `
      &lt;div class="message-list"&gt;
        &lt;div *ngIf="messages.length === 0" class="empty-message-list"&gt;
          &lt;h3&gt;No messages so far :)&lt;/h3&gt;
        &lt;/div&gt;
        &lt;message
          *ngFor="#message of messages"
          [message]="message"
          &gt;&lt;/message&gt;
      &lt;/div&gt;
    `
})</pre></div></li><li class="listitem" value="3">Define the component's class:<div class="informalexample"><pre class="programlisting">export class MessageListComponent {
  public messages: Array&lt;Message&gt; = [];
  private _messageService: MessageService;
  private _threadService: ThreadService;
  private _routeParams:RouteParams;
}
Add the constructor:
  constructor(
    messageService: MessageService,
    threadService: ThreadService,
    routeParams: RouteParams
  ) {
    this._routeParams = routeParams;
    this._messageService = messageService;
    this._threadService = threadService;
    this._messageService.messages.subscribe(messages =&gt; this.messages = messages);
    let threadId: string = this._routeParams.get('identifier');
    this._threadService.setCurrentThread(new Thread(threadId));
    this._messageService.getByThread(threadId);
  }</pre></div></li></ol><div class="calibre12"/></div><p class="calibre8">Because we are reloading the component each time we navigate to the matched route, we can get the <a id="id412" class="calibre1"/>current <code class="email">identifier</code> parameter and load messages by the current thread ID. We are also setting the current thread ID so that other subscribers can take actions accordingly. For example, in the <code class="email">thread</code> component, we check whether the current thread matches the component's thread.</p></div></div>
<div class="book" title="Summary" id="1NA0K1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec51" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We have reached the end of this chapter. The chapter was about building a real-time chat application. We used <code class="email">WebSockets</code> for the real-time communication, stored the message history in MongoDB, and created threaded conversations. We also left some room for improvements, or to add new functionalities.</p><p class="calibre8">In the next chapter, we'll try to build an e-commerce application.</p></div></body></html>