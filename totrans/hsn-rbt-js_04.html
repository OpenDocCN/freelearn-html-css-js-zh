<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Bringing in Input with Buttons</h1>
                </header>
            
            <article>
                
<p>We've now explored digital and PWM output in Johnny-Five, but that's only half of the story. There is so much you can do with input devices in robotics projects, allowing either user input or observations of the world surrounding your projects to affect the outputs.</p>
<p>We're going to start with a user-input device—buttons. We're also going to talk about how the Raspberry Pi handles digital inputs, and build buttons into our previous project that allows users to stop the rainbow color cycle, and advance the color themselves.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Using inputs in robotics projects</li>
<li>The Johnny-Five sensor and button objects</li>
<li>Wiring up buttons</li>
<li>Adding buttons to our RGB LED project</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You'll need your Pi, with the RGB LED from the  <a href="c7b761b9-d526-4998-8ec4-375debe53806.xhtml" target="_blank">Chapter 3</a>, <span><em>Building Interactive Projects with RGB LED</em> </span>project wired up, along with the GPIO expander board.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using inputs in robotics projects</h1>
                </header>
            
            <article>
                
<p>You can do a lot with output devices in robotics projects, but the possibilities become endless when you add inputs. Whether they are user-controlled inputs, such as buttons and potentiometers, or environmental sensors that measure things such as ambient light or air quality, input devices can add a new dimension to any robotics project.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital versus analog input</h1>
                </header>
            
            <article>
                
<p>Much like with digital and PWM output, there are two types of input devices: digital and analog. Digital inputs are either on or off: buttons are a prime example of this. Analog inputs give a different level of voltage of signal depending on what they are sensing; a photoresistor, for example, puts out higher voltage signals when the ambient light is high, and lower when it is darker. </p>
<p>In order to read data from analog devices, you'll need a pin that can accept an analog input. But as we saw in the last chapter, all of the GPIO pins on the Raspberry Pi are digital. Luckily, there are ways to get around this limitation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to handle analog input with the Raspberry Pi</h1>
                </header>
            
            <article>
                
<p>There are two ways to go about obtaining analog sensor data on the Raspberry Pi: adding a GPIO expander that has analog pins, or using sensors that make use of digital signaling to communicate analog data. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analog GPIO expanders</h1>
                </header>
            
            <article>
                
<p>These boards act almost exactly like the GPIO expansion board we used in <a href="c7b761b9-d526-4998-8ec4-375debe53806.xhtml" target="_blank">Chapter 3</a>,<em> </em><span><em>Building Interactive Projects with RGB LED</em></span>,<span> </span>except instead of adding PWM output pins, they add analog input pins. These boards also usually utilize an I<sup>2</sup>C interface to communicate with the Raspberry Pi. However, I usually find these boards unnecessary, because many sensors that collect more than one channel of data (such as an accelerometer) already utilize I<sup>2</sup>C or other digital interfaces, and the few sensors that collect one channel of data can be found with these digital interfaces on board.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using input devices with digital interfaces</h1>
                </header>
            
            <article>
                
<p>This is the way we'll go in our projects. Devices like these use protocols such as UART, SPI, and I<sup>2</sup>C that allow devices that only have digital GPIO to receive analog data. In the materials for each project, the devices included will not require analog input pins.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Johnny-Five handles input</h1>
                </header>
            
            <article>
                
<p>So we've gotten a glimpse of the way Johnny-Five uses events via the board <kbd>ready</kbd> event. If you've ever programmed with C and Arduino, you may be familiar with the event loop style of program—a loop runs forever and checks the state of the input devices, then responds accordingly. You may also be aware of interrupt-driven programming, where a change in a hardware pin causes the code to jump to a specific function. </p>
<p>Johnny-Five code is closer to the interrupt style; events drive nearly all Johnny-Five projects. This has several benefits; you can keep your code organized by event type, and make sure each piece of functionality fires only when it needs to, without having to deal with programming your own hardware interrupt routines.</p>
<p>When a Johnny-Five project receives input from a sensor or device, it fires a <kbd>data</kbd> event. But what if you only want to run a function when the environment changes? The <kbd>change</kbd> event is for you. We'll look more at the exact event types and when they fire in a later section, but for now keep in mind that events are how you'll capture the data of your sensors and input devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The structure of a typical Johnny-Five project</h1>
                </header>
            
            <article>
                
<p>A Johnny-Five project consists of a few key sections and building blocks that make it really easy to read through an example. Let's go through an example here to see more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The beginning – including libraries and creating our board object</h1>
                </header>
            
            <article>
                
<p><span>This section sets the stage for us by bringing in the Johnny-Five. The following code snippet tells it we're using a Raspberry Pi, and constructs the appropriate board objects. If you're using other <kbd>npm</kbd> modules, like the <kbd>color</kbd> module we used in<a href="c7b761b9-d526-4998-8ec4-375debe53806.xhtml" target="_blank"/></span><span> </span><a href="c7b761b9-d526-4998-8ec4-375debe53806.xhtml" target="_blank">Chapter 3</a><span>,</span><em> </em><span><em>Building Interactive Projects with RGB LED</em></span>,<span> you'd use <kbd>require</kbd> to bring them in here as well, as shown:</span></p>
<pre><span><br/>const five = </span><span class="hljs-built_in">require</span><span>(</span><span class="hljs-string">"johnny-five"</span><span>)<br/>const Raspi = require("raspi-io")<br/><br/>let board = new five.board({<br/> io: new Raspi()<br/>})</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The board ready event handler</h1>
                </header>
            
            <article>
                
<p><span>Everything else that we do in a Johnny-Five project, besides the header, goes inside this event handler. This handler, as shown here, means our board is ready to read and write to GPIO pins, and any code run outside this event handler that manipulates GPIO is not guaranteed to work and may cause strange behavior:</span></p>
<pre><span>board.on(</span><span class="hljs-string">"ready"</span><span>, </span><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span><span>{<br/>  // Everything else goes in here!<br/></span><span>});</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing our component objects</h1>
                </header>
            
            <article>
                
<p><span>The first thing I do inside the board ready event handler is set up Johnny-Five objects for all of the components of my projects. It's easier to wire up a project from the code if all of the component types and pins are in the same place in the code:</span></p>
<pre>  // remember, this goes inside the board ready event handler!<br/>  let LED = new five.LED('P1-7')<br/>  let button = new.five.Button('P1-8')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Input event handlers and output device manipulation</h1>
                </header>
            
            <article>
                
<p><span>This is where the fun happens, we wait for input and manipulate outputs accordingly! This will watch for a button connected to <kbd>P1–8</kbd> to be pressed, then turn on an LED. But how would we turn the LED off when the button is released? For that, we're going to take another look at the Johnny-Five documentation:</span></p>
<pre>  // We'll go over more about the Button in the next section!<br/>  // This is still inside the board ready event handler!<br/>  button.on('press', () =&gt; {<br/>    led.on()<br/>  })</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Johnny-Five button object</h1>
                </header>
            
            <article>
                
<p>Before we program our button project, let's take a good look at the Johnny-Five button object, so we know what events to look for, and what information the constructor wants from us.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The button object</h1>
                </header>
            
            <article>
                
<p>When we look at the button's parameters section, there is only one required parameter, pin. So we'll need to remember what pin to which we hook the signal from the button, but other than that, the defaults will serve us nicely:</p>
<ul>
<li><kbd>invert</kbd>: Defaults to false, and inverts the up and down values. We'd like to keep this false, as we're wiring the button to not require inversion.</li>
<li><kbd>isPullup</kbd>: Tells boards with pull-up resistors tied to their GPIO pins to initialize this button with the pull-up enabled. We're going to wire our own resistor, so this can stay the default false.</li>
<li><kbd>isPulldown</kbd>: Similar to <kbd>isPullup</kbd>, but with pull-down resistors. Leave this false as we are wiring our own pull-down resistor.</li>
<li><kbd>holdtime</kbd>: This is the number of milliseconds a button must be held down before the hold event is fired. The default of 500 <span>milliseconds</span> will do fine for us here.</li>
</ul>
<p>There's also a special section called <kbd>collection</kbd>, which details how you can control several buttons with the same object. It's an interesting design, and while we won't explore it for our two-button project, a good bonus project would be to refactor it to use the buttons <kbd>collection</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Button events</h1>
                </header>
            
            <article>
                
<p>There are three events that the button object uses, and each of them can be used on a single instance of a button object:</p>
<ul>
<li><kbd>press</kbd>, <kbd>down</kbd>: These are the same event, and they fire when the button has been pressed</li>
<li><kbd>release</kbd>, <kbd>up</kbd>: These events fire when the button is released</li>
<li><kbd>hold</kbd>: This event fires when the button is held down for longer than the threshold set in the <kbd>holdtime</kbd> parameter in the constructor</li>
</ul>
<div class="packt_tip">If you've dealt with hardware before, you might be worried about button event <kbd>noise</kbd>; multiple events firing on one button press or release, release events when the button hasn't been pressed, and so on. Johnny-Five has baked debouncing into the button object, so there's no need to worry about noisy buttons!</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wiring up buttons</h1>
                </header>
            
            <article>
                
<p>We're going to add buttons to the project from the previous chapter, to allow users to change the way the RGB LED works by pressing buttons. When you look at a button, you see four prongs. While there are four prongs, there are only two input/outputs to a button—one where electricity goes in, and one where it goes out when the button is pressed. This is because a button essentially controls the flow of electricity. When the button is not pressed, the contacts are not connected and electricity cannot flow, and when pressed, a conductor bridges the two sides and electricity flows. This is how we will use the button as an input device: a high signal means the button is pressed, a low signal means it isn't.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting a button on a breadboard</h1>
                </header>
            
            <article>
                
<p>Take your button and observe the metal prongs on the bottom. Usually, the two pairs curve towards the inside of the button. There is one in and out on each side, and each pair with the same curve has one of each. Keep this in mind when placing it on the breadboard, shown in the following image:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-728 image-border" src="assets/b131c0d4-93f1-465d-bcaa-73d885ecb681.png" style="width:20.50em;height:15.42em;"/></p>
<p class="CDPAlignLeft CDPAlign"> When you're placing a button on the breadboard, you'll want to make sure that the button crosses the trough in the middle of the breadboard in order to prevent a short. </p>
<p>Once you've placed the button into the breadboard, make sure it's well-seated, and that none of the prongs have curled up into themselves instead of going into the breadboard socket. If one has, use needle-nose pliers to straighten it.</p>
<p>Now that you've got your button on the breadboard, it's time to wire it to your Pi.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a pull-down resistor</h1>
                </header>
            
            <article>
                
<p>So the question is, how are we going to get three wires into a device with two leads? We're going to use what's called a pull-down resistor to tie an input to the side of the button not connected to power. When the button is pressed, electricity will flow through the resistor into the signal wire, and we'll use a digital input pin on the Pi to detect that as a button press.</p>
<p>To do this, wire one side of your button to a 5V power pin on the cobbler. On the other side, place a 10K ohm resistor that bridges to another row of the breadboard, and in that row place a wire to bridge to a GPIO pin on the cobbler. Then, in the second row of the button, below the resistor, place a wire bridging to a GND pin on the cobbler.</p>
<p>The resistor prevents the Pi from shorting when the button is pressed, which will cause your Pi to temporarily cease functioning and, if left for too long, will cause irreparable damage.</p>
<div class="packt_tip">A short circuit, or short, is when the power and ground of a circuit are connected without a load (like our resistor) in between, which causes a lot of issues. To learn more, check out the <em>Further reading</em> section of this chapter, or any introduction to an electronics book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding buttons to our RGB LED project</h1>
                </header>
            
            <article>
                
<p>Now that we know how buttons work and how to wire one up to the Pi, let's add two buttons to our RGB LED project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wiring everything up</h1>
                </header>
            
            <article>
                
<p>Before we wire up our buttons, we're going to need to do some housekeeping on our current wiring setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the power and ground side rails</h1>
                </header>
            
            <article>
                
<p>From here on, we'll be needing more access to power and GND pins, and we don't want a ton of really long wires criss-crossing our projects. So the first thing we'll do is a little hardware refactoring. </p>
<ol>
<li>Take the RGB LED ground off the cobbler row.</li>
</ol>
<p> </p>
<ol start="2">
<li>Take the VCC and GND from the GPIO expander off the 5V and GND cobbler rows.</li>
<li>Place a wire between the 5V row of the cobbler and the outer long row (if there's one marked red and one blue, use red).</li>
<li>Place a wire between a GND pin of the cobbler and the other outer row.</li>
<li>Plug the RGB LED ground into the side rail you linked to the GND on the cobbler.</li>
<li>Plug the GND from the GPIO expander into the side rail linked to GND on the cobbler, and the VCC into the side rail linked to 5V on the cobbler, as shown in the following diagram:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea36319f-bb5a-41f2-898c-1bafe7fa91e1.png" style="width:53.33em;height:37.25em;"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wiring up the buttons</h1>
                </header>
            
            <article>
                
<p>Now that we've sorted out our power and ground rails, let's place buttons. For both of the two buttons:</p>
<ol>
<li>Place the button on the breadboard as outlined in the last section, bridging the gap in the center of the breadboard. </li>
<li>Wire one side of the button to the side rail connected to the 5V pin on the cobbler.</li>
<li>Place a 10K ohm resistor on the other side, bridging to an empty rail.</li>
<li>Wire the side of the button with the resistor to the side rail linked to GND on the cobbler. Make sure the resistor is in between the button and the link to ground!</li>
<li>Wire the other end of the resistors to a pin on the cobbler; use #5 for button 1 and #6 for button 2, as shown in the next diagram:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-168 image-border" src="assets/b2cc4051-e57e-44d5-adb5-686c5f6bf6a9.png" style="width:34.67em;height:35.83em;"/></p>
<p>And now you're ready to write some code!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Button 1 – stop and start rainbow </h1>
                </header>
            
            <article>
                
<p>Before we set up our buttons, we're going to refactor our rainbow-cycle program a bit to accommodate the new functionality of the buttons.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the rainbow cycle</h1>
                </header>
            
            <article>
                
<p>We're going to refactor the rainbow cycle to do the following:</p>
<ol>
<li>Look at a scoped variable to see if the color should keep changing on a timed interval or not (for the stop and start button)</li>
<li>Break the code that changes the RGB LED to the next color into its own function (for the next color button)</li>
</ol>
<p>Let's take a look at the refactor:</p>
<pre>board.on('ready', () =&gt; {<br/>  let rgbLED = new five.Led.RGB({<br/>    controller: "PCA9685",<br/>    pins: {<br/>      red: 0,<br/>      green: 1,<br/>      blue: 2<br/>    }<br/>  })<br/>  let colorCycle = true<br/><br/>  setInterval(() =&gt; {<br/>    if( colorCycle ) {<br/>      colorChange()<br/>    }<br/>  }, 1000)<br/><br/>  function colorChange() {<br/>    console.log(currentColor)<br/>    currentColor = color(colors[colorIndex])<br/>    rgbLED.color([currentColor.red(), currentColor.green(), currentColor.blue()])<br/>    colorIndex++<br/>    if(colorIndex &gt;= colors.length) {<br/>      colorIndex = 0<br/>    }<br/>  }<br/>})</pre>
<p>We're going to make <kbd>button1</kbd> stop and start the cycle through rainbow colors. To do this, we'll need to:</p>
<ol>
<li>Construct a button object to represent our button in the code</li>
<li>Watch for the <kbd>press</kbd> event from the Johnny-Five button object API</li>
<li>Add a variable called <kbd>cycleOn</kbd> that can be set to true or false, and have the loop that changes the color use to either change the color or not</li>
<li>We're also going to pull the logic for changing the color out in preparation for our next button</li>
</ol>
<p>Let's add it to the beginning of our board ready handler:</p>
<pre>  let button1 = new five.Button('P1-29')<br/>  <br/>  button1.on('press', () =&gt; {<br/>     colorCycle = !colorCycle<br/>  })</pre>
<p>Load this on your Pi, run it with <kbd>sudo node rainbow-pause-button.js</kbd>, and see what happens when you press the button a few times!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Button 2 – next color</h1>
                </header>
            
            <article>
                
<p>Now we'll add a second button and press handler to make the second advance the color when it is pressed:</p>
<pre>  let button2 = new five.Button('P1-31')<br/><br/>  button2.on('press', () =&gt; {<br/>    colorChange()<br/>  })</pre>
<p>Now, when you press the second button, the color of the LED will advance to the next color in the array.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter brought together user inputs and output—an RGB LED. We learned how to use input events in Johnny-Five to manipulate output devices, which is the core of most Johnny-Five projects, and learned how to use multiple inputs (buttons) to achieve different effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What events are available to the Johnny-Five button object?</li>
<li>Can the Raspberry Pi use analog input devices?</li>
<li>How will we use sensors with the Pi?</li>
<li>Why are there no events for the <kbd>RGB.LED</kbd> object?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><strong>More about analog input pins</strong>: <a href="https://learn.sparkfun.com/tutorials/analog-to-digital-conversion">https://learn.sparkfun.com/tutorials/analog-to-digital-conversion</a></li>
<li><strong>More about pull-up resistors</strong>: <a href="https://learn.sparkfun.com/tutorials/pull-up-resistors">https://learn.sparkfun.com/tutorials/pull-up-resistors</a></li>
</ul>


            </article>

            
        </section>
    </body></html>