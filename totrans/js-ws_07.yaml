- en: 7\. Popping the Hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to differentiate between single-threaded
    and multi-threaded execution; describe JavaScript's execution process; show how
    the call stack and memory heap interact with the other elements of the runtime;
    write code that works in tandem with JavaScript's garbage collection process;
    and debug memory-related issues in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at how JavaScript is executed in the browser and
    how it manages important system resources such as memory.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, you learned about some of the core concepts of
    JavaScript, were introduced to the ideas of the `event` loop, and looked at how
    JavaScript handles the process of **memory management**. In this chapter, we'll
    look at those aspects of the language in more detail and learn how we can write
    code that works in concert with some underlying features of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for developers to get quite far in their careers without having
    a solid understanding of some of the core concepts underlying (and surrounding)
    JavaScript. Indeed, it's quite possible to be a successful developer who writes
    solid, commercially viable applications, without ever fully grasping the topics
    that are covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, why should we learn about the inner workings of JavaScript? Can't we just
    write our code and let JavaScript handle the nitty-gritty? Well, the problem with
    that approach is that, sometimes, things don't quite go according to plan, and
    we need to be able to understand what's happening under the hood in order to rewrite
    the part of our code that is making the application buggy or less performant.
    Imagine you're a rally driver. You can drive your car along the track with just
    a rudimentary level of knowledge of how to drive a car. This skill level may get
    you to the finish line, but it definitely won't have you winning any races.
  prefs: []
  type: TYPE_NORMAL
- en: To set yourself apart from other drivers, you need to increase your skill and
    experience levels. Sure, simply practicing the skill will help you improve over
    time, and allow you to intuit a lot of what's happening behind the scenes – this
    is true for driving a car and programming computers with JavaScript – but having
    a deeper understanding of the actual processes involved will allow you to plan
    and make decisions with confidence so that you know specifically what parts of
    the system you want to control.
  prefs: []
  type: TYPE_NORMAL
- en: To give you a more concrete programming example, imagine you're testing a co-worker's
    code and you can't understand why a page seems to take so long to load, why it
    becomes unresponsive during a certain operation, or why the application takes
    up excessive system resources. These kinds of performance issues don't necessarily
    break an application, and they may not even be noticeable to every user. But they
    do affect the software's usability and the user experience, which has knock-on
    effects on things such as SEO page ranking and a site's popularity with its end
    users. Understanding what's going on under the hood can help you write better
    code and debug code faster, making your life as a developer easier, and making
    for smoother user experience and more successful applications.
  prefs: []
  type: TYPE_NORMAL
- en: Arming yourself with the knowledge covered in this chapter means that the code
    you write will make the best use of the JavaScript programming language and its
    runtime environments.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Execution and the Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a single-threaded language, meaning it lines up all of its operations
    in a single thread and executes them one at a time. Many other languages are multi-threaded,
    that is, they are able to execute more than one thread of operations at a time.
    There are pros and cons to each method of execution, mostly revolving around efficiency
    versus complexity, but we won't look at these in-depth here. As we'll see in a
    moment, JavaScript's call stack processes operations one at a time, on a last
    in, first out (LIFO) basis.
  prefs: []
  type: TYPE_NORMAL
- en: LIFO describes a process of adding and removing elements from a data structure
    – in this case, from a stack. As the name suggests, the last thing that's added
    is the first thing taken away – much like stacking books on a desk.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A runtime environment is an application that allows the software to be run on
    a system. It's the bridge between the software being run and the system on which
    it is being run and provides access to system resources such as memory and filesystem,
    and to runtime and environment variables. In the case of JavaScript, the runtime
    is often – but not always – the browser.
  prefs: []
  type: TYPE_NORMAL
- en: There are different implementations of the JavaScript runtime, and the exact
    way they handle executions differs between each. Each one makes use of optimization,
    which can make real-life processes differ from those described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, from a theoretical standpoint, a JavaScript runtime can be usefully
    broken down into several key components and processes:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment/Browser APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Message Queue/Callback Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JavaScript runtime environment and execution broken down into these key
    components can be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: An overview of the JavaScript runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: An overview of the JavaScript runtime'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of these in turn to get a better understanding of their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JavaScript engine is a piece of software that runs JavaScript code, turning
    the high-level JavaScript source code into low-level machine code via the process
    of `Node.js` (used in server-side JavaScript execution) among other places. V8,
    like most modern browsers, uses a **Just-In-Time compilation** process to execute
    JavaScript code, meaning that the code is compiled at runtime and not ahead of
    time, like with older compilation processes.
  prefs: []
  type: TYPE_NORMAL
- en: The two elements of a JavaScript engine that we're concerned with here are the
    **memory heap** and the **call stack**, both of which will be explained shortly.
    Note that the preceding diagram shows the event loop as being separate from the
    JavaScript engine as it's generally expected that the JavaScript runtime will
    implement and manage the event loop. However, many JavaScript engines implement
    their own event loop process, which can be used as a fallback for the runtime
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, Node runs on the V8 JavaScript engine. However, alternate implementations
    of Node using different engines are being worked on. **Node-ChakraCore**, which
    uses Microsoft's ChakraCore JavaScript engine, is one such project and is under
    active development. Another is **SpiderNode**, although the development of this
    project has stalled at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Environment APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often called Web APIs or Browser APIs in the context of a browser, these are
    the interfaces that are made available to JavaScript by the environment in which
    it is being run. For example, the browser gives access to the `LocalStorage`,
    and methods such as `setTimeout()` and `setInterval()`, which we've covered in
    previous chapters. JavaScript running outside of a browser will have different
    needs, and therefore the runtime will expose different interfaces for it to use.
    Node.js is a popular server-side JavaScript runtime environment, which we will
    cover later on in this book. It usually wouldn't make much sense for Node.js to
    have a Document Object Model (DOM), so instead, Node provides APIs that are more
    relevant to server-side code such as the `FileSystem` API for performing `filesystem`.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see shortly, environment APIs are a crucial component of JavaScript's
    ability to run **asynchronous operations**.
  prefs: []
  type: TYPE_NORMAL
- en: Message Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message queue (also known as the `setTimeout` function's delay time has
    expired, or when an event occurs and there is a corresponding event listener,
    such as when a user clicks on a button and the button has a click event listener
    attached to it. These operations occur in a **first in, first out**(**FIFO**)
    sequence, much like the queue you find at a supermarket checkout. The message
    queue doesn't actually execute the functions itself – it's simply a place to keep
    them on hold until the call stack has finished doing what it's doing. The time
    at which the operation is executed is decided by the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Event Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event loop is the process by which messages are added from the message queue
    to the call stack. The event loop watches the call stack and the message queue,
    and if the call stack is empty, then the oldest message from the message queue
    (the first in) will be pushed onto the stack for execution. Only when all the
    function calls on the stack have returned will subsequent messages (function calls)
    be pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Call Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The call stack keeps track of JavaScript''s function invocations. When a function
    is called, a **stack frame**, consisting of the function''s name (or ''anonymous,"
    for anonymous functions), and a reference to the function caller''s address, is
    pushed onto the top of the stack. If this function calls another function, then
    a new frame for the second function is pushed to the top of the stack, on top
    of the previous frame. When the function returns – either explicitly or implicitly
    – the function''s corresponding stack frame is popped off the call stack, and
    code execution carries on from where it was before the function call. Unlike the
    message queue, the call stack processes frames in a LIFO sequence: stack frames
    are added to and taken from, the top of the stack, much like stacking books on
    a desk. When the call stack is empty, the event loop will decide whether to push
    messages from the message queue or to allow new stack frames to be added to the
    call stack for subsequent function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The memory heap is an unsorted area of memory that the JavaScript engine uses
    to dynamically read and write objects at runtime. We will look at memory management
    in JavaScript in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Event Loop in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains the code we will use to demonstrate the event loop in
    action and also provide a brief precursor regarding how asynchronous code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser''s JavaScript console or your code editor of choice, the three
    simple function declarations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this simple code snippet, we are declaring three functions and then calling
    the first of the three. The `firstCall` function logs the `'I'm logged first"`
    string in the console, and then calls the next function, `secondCall()`. This
    function logs the `'I'm second..."` string, and subsequently calls the third of
    our functions, `thirdCall()`. `thirdCall()` simply logs the `'I'm last."` string
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you expect to see in the console when we run this code? Hopefully,
    it''s quite obvious that we will see the following logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, each function invocation is added to the call stack, executed
    in turn, and then popped off the top of the stack. Therefore, we get the strings
    from the three functions logged in their correct order. You can see the stack
    frames for each of the function invocations in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Demonstrating the sequence of execution in the call stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Demonstrating the sequence of execution in the call stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a small change to our code by adding a `setTimout()` function
    in the second function block. So, let''s take a look at what the three strings
    will be logged in this time if you write and run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Logic dictates that the order of our console logs will remain the same – after
    all, the `setTimeout` delay is `0` milliseconds, so it will execute on the console
    log straight away, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we find that the order has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, what do you think is going on here? We will go through the source code line
    by line and see how the JavaScript runtime is handling each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the `firstCall()` function is invoked and a new stack frame is
    pushed to the top of the call stack of this function invocation. The function
    contains a call to the `log()` method of the console object, with an argument
    of the string type with the value `''I''m logged first!!"`. This is highlighted
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Demonstrating the call stack after calling firstCall()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Demonstrating the call stack after calling firstCall()'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `''I''m logged first!!"` string is logged to the console, the `secondCall()`
    function is invoked, and a new stack frame is pushed onto the top of the stack
    for `secondCall()`. Here is where things are different from the original code
    snippet. This function contains a call to the `setTimeout()` function, which is
    a part of the browser''s API, so this function is taken outside of the main JavaScript
    execution thread for now. The `setTimeout()` function is called with a delay of
    0 milliseconds, after which a message is passed to the message queue with a reference
    to the `console.log()` call contained within the `secondCall()` function. Now,
    this message sits in the message queue, waiting patiently to be dealt with by
    the `event` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Demonstrating the setTimeout() method being assigned to the message
    queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Demonstrating the setTimeout() method being assigned to the message
    queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how the `secondCall()` function calls `thirdCall()`. Another
    new stack frame is pushed onto the call stack for this function invocation. It
    calls `console.log()` with the `''I''m last."` string, which is printed to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The end of the final function call'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: The end of the final function call'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, `thirdCall()` has no other operations to execute, so it implicitly
    returns the value `undefined` back to `secondCall()`, and the stack frame for
    `thirdCall()` is popped off the call stack. Then `secondCall()` returns `undefined`
    to `firstCall()`, and the stack frame for `secondCall()` is popped off the stack.
    Next, the stack frame for `firstCall()` is popped off the stack, and `undefined`
    is returned back to the main process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Showing the empty call stack after the functions have returned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Showing the empty call stack after the functions have returned'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can see that the only remaining frame on the call stack is the anonymous
    main process and that no other functions are being called by the main process.
    The event loop sees that the call stack is available and that there is a message
    waiting in the message queue, so it pushes a new stack frame for the callback
    function referenced in the pending message. This callback function is our remaining
    `console.log()` call, with the `''I''m second…"`: string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Showing the console.log stack frame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Showing the console.log stack frame'
  prefs: []
  type: TYPE_NORMAL
- en: The final `console.log` call is executed, with the string being printed to the
    console, and the stack frame is then popped off the call stack, again leaving
    only the anonymous main process left on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how, despite JavaScript being single-threaded, it's possible
    to continue executing code while a previously invoked function is waiting to be
    completed. There are many other functions and APIs built into the browser besides
    `setTimeout`, and we will look at more of these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.01: Working with the Event Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can apply this knowledge to a more realistic (albeit
    simple) application. The goal of this exercise is to illustrate how the `event`
    loop can produce some unexpected behavior in our applications and also to see
    how we can work with the `event` loop to give useful functionality to our apps.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll have an HTML file with two `<div>` elements in the body with IDs of
    `status` and `result`. The purpose of the application is going to be to run a
    function and display the result in the `result` div. We know that our function
    will take a not-insignificant amount of time to run, so we will also incorporate
    a status feature so as to keep the user aware of what''s happening in the application.
    For this example, our main function will be an arbitrary calculation that takes
    a few seconds to complete. In real life, this could be any kind of complex calculation,
    or a function for fetching data from an external source, such as a database or
    an API. Load the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a separate JavaScript file, called `event-loop.js`, we''ll write a collection
    of functions to make up our application. First, we''re adding an event listener
    to the window object so that the rest of the code won''t run until the DOM''s
    content has loaded (`DOMContentLoaded` is triggered when the browser completes
    the DOM tree structure, not including any style sheets or images):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we are assigning our two `<span>` elements with the IDs of `status`
    and `result` to two aptly named variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are defining two functions, `showStatus()` and `doCalculation()`.
    The `showStatus()` function takes in an argument of `statusText`, which will be
    set to the `innerText` property of `statusSpan`, thereby displaying whatever text
    we pass to `showStatus()` on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other function, `doCalculation()`, runs our calculation and then sets the
    result to the `innerText` property of the `resultSpan` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, to join these together, we could call the functions at the end of the `DOMContentLoaded`
    callback function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try running this code and see whether it works as we expect. Not very good,
    is it? When we first open the page, it loads for a while and then displays the
    `Calculation finished` status and the result. But we never see the `Calculation
    running` status:![Figure 7.8: The output from the first version of the application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.8: The output from the first version of the application'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it, then, that don't we get to see the first status? When we update the
    DOM by doing something such as setting the `innerText` property of a DOM node,
    the DOM tree itself is updated, and then the browser repaints the render tree
    to the browser window. These are two separate steps, and the repaint step happens
    after the current call stack has finished. So, with our new knowledge of the event
    loop, we should be able to see what's happening. When we call `showStatus()` for
    the first time, the DOM is updated, but the browser doesn't redraw the page yet.
    Then, `doCalculation()` is called, and the execution thread is blocked until the
    calculation has finished. The `showStatus()` function is called a second time
    with the `Calculation finished` string, and at this point, the browser repaints
    the render tree with the `Calculation finished` string that we passed to the second
    call of `showStatus()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get our application to work more in line with our specifications, have a
    go at this yourself before checking out the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the call to `doCalculation()` and the second call to `showStatus()`
    to a `setTimout()` function, the call stack is emptied after the first `showStatus()`
    function executes, at which point the browser repaints the page, displaying the
    `Calculation running` string as expected. This is a much better implementation
    since it keeps the user informed of what the application is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Showing the status while the calculation is running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Showing the status while the calculation is running'
  prefs: []
  type: TYPE_NORMAL
- en: Stack Overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The call stack is an example of a data type called – you guessed it – a stack.
    You can think of a stack simply as a container of objects (stack frames, representing
    functions and arguments, in the case of a call stack). There's a limit to the
    number of frames a call stack can hold. We'll now look at what happens when the
    call stack gets full, a common problem that developers face, and what's known
    as a stack overflow. (In the V8 JavaScript engine, it has a different name, but
    the theory is the same.)
  prefs: []
  type: TYPE_NORMAL
- en: This can happen, for example, when developers are trying to write a recursive
    function but fail to code in a base case and/or a termination condition, at which
    point the recursion should stop. It can be tricky – especially for new developers
    – to account for every edge case that may bypass these points.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a simple example of a stack overflow first, after which
    we'll explore a more true-to-life example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following code, let''s take a look at what will happen in the JavaScript
    engine when we call the `callMe()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It should be fairly obvious what will happen with this code, but still, let's
    look through a few steps of the process on the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `callMe()`, a new stack frame is added to the call stack for that
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: The first stack frame is added to the call stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: The first stack frame is added to the call stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `callMe()`, the other function, `nowCallMe()`, is called, adding a stack
    frame for that function invocation to the stack. `nowCallMe()` in turn calls `callMe()`,
    adding a new stack frame to the call stack, and on and on it goes, with both functions
    calling each other in turn, and a new stack frame is added to the stack every
    time. In this scenario, the JavaScript execution thread has nowhere else to go
    – there is no condition in the code that will cause the thread to move on from
    this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: The call stack is filling with stack frames'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: The call stack is filling with stack frames'
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop will continue to add stack frames to the call stack until the stack''s
    limit is reached. In the V8 implementation of the JavaScript engine, the limit
    for the number of frames in the stack is often somewhere around 16,000, although
    it can be higher or lower, depending on the content of each frame, the variables
    being used, and other factors. (At the end of this chapter, we''ll write a function
    to calculate the stack limit for different JavaScript engines and environments.)
    If this limit is exceeded, the engine throws a stack overflow error, referred
    to by V8 as `Maximum call stack size exceeded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Stack overflow error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: Stack overflow error'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to change the call stack size limit in the V8 JavaScript engine.
    To do so, simply launch the environment – be it Node, Chrome, or another implementation
    – with the `stack-size=[value]` flag. Bear in mind, though, that this should only
    be used for debugging or for experimentation – you certainly don't want to write
    code with the expectation that it will be run with anything other than the default
    call stack size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a more real-life example, and later see how we can
    fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function is an example of **recursion**, which we'll look at in more detail
    later on in this book. It may not be immediately obvious what this function is
    doing, so let's break it down into steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function takes in a number and calls itself recursively, subtracting 2
    from the `num` argument for each call. Let''s say we call it with the argument
    of `10`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The function first checks to see whether `num` is equal to `0`, and if it is,
    it will return a console log with the value of `0`, and this function's execution
    will finish (this line is our termination condition). Right now, `num` is equal
    to `10`, so this `if` statement is `false`, and the execution proceeds to the
    next line.
  prefs: []
  type: TYPE_NORMAL
- en: The next line logs the value of `num` to the console and then proceeds to the
    next line.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the function calls itself again, with the value of `num` `minus 2` – so
    `8`, in our case. This continues.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the preceding function with the argument of `10`, we'll see the numbers
    `10`, `8`, `6`, `4`, `2`, and `0` are logged to the console, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if we call the function with an odd number? Try calling the
    same function with `11` as the input. You'll see that our termination condition
    of `num=== 0` never occurs since `num` goes from `1` to `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.02: Stack Overflow'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to rewrite the stack overflow function so that
    it accounts for as many other inputs as it can. Think about all the possible arguments
    this function could be called with, and how the function will handle each one.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a few possible inputs to make sure we''re accounting for
    all eventualities, thereby minimizing the risk of an error occurring. Here are
    some of the edge cases we need to be careful of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `num` input is odd.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The input is 0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This input is less than 0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The input is null or is not of a `number` type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, let''s assume that we want the function to return whenever the input
    is not a number or is a negative number, and if it''s 0, then we want the function
    to log 0 to the console and return. Write the function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we've added a termination condition using the `typeof` operator to determine
    whether the input, `num`, is a number as expected. We will return `undefined`
    if it's not of a `number` type or if it's a number less than `0`. If `num` is
    a number, and it's greater than or equal to `0`, then the function will log the
    value of `num` and call itself again with `num` `–2`, and so the cycle repeats.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By making these changes to the function, we are accounting for the initial
    input of an odd number, which would have bypassed our termination condition in
    the original function. We''re also accounting for inputs where `num` is not of
    type `number`; say, a string or an object. But there are also some less obvious
    edge cases we need to be aware of. Let''s see what happens when we call a function
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It turns out that multiplying `bananas` by `2` doesn''t make any sense: JavaScript
    cannot coerce the result to a numerical value, and therefore it results in a value
    of `NaN`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what does this mean for our function? To answer that question, we need to
    establish what data type the `NaN` property is. You'd be forgiven for assuming
    that running `typeof` `NaN` would return something – anything – other than `number`,
    but you'd be wrong. As we saw in the previous chapter, `NaN` is a property of
    the `Number` object and is indeed of the `number` type. This results in yet another
    stack overflow, with the function logging `NaN` repeatedly until the maximum call
    stack size is reached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A similar problem would also occur when calling the function with Infinity,
    so it''s clear that we need to add another check in our `isFinite()` function
    that returns true if its input is a finite and legal number to handle these edge
    cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function is used so that we can remove the `typeof` operator check. Now,
    we have a fairly robust set of termination cases for this function. There may
    still be other checks we would want to implement, such as limiting the size of
    the number that the function will count down from. For example, if we wanted to
    make sure the input is less than `10,000`, we could amend our `if` statement to
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Outputs from various inputs to countdownByTwo()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Outputs from various inputs to countdownByTwo()'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we've seen a basic example of how we may inadvertently write
    code that works poorly with the JavaScript engine, and that we should handle as
    many different edge cases that our code may be presented with as possible.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we've looked at the JavaScript runtime, what it is conceptually,
    and the processes and components it comprises. We've looked at the JavaScript
    engine in detail – particularly the V8 implementation – and how its call stack
    and memory heap interact with the other elements of the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at a common call stack error that developers face, and at
    the ways, we can ensure our code doesn't reach the maximum call stack size.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now move our attention to another core aspect of a computer's hardware
    – its memory. Memory management is an important, but often overlooked, aspect
    of developing software in JavaScript. Memory management simply refers to the allocation,
    use, and deallocation of system memory for the various data structures that make
    up our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main approaches that are used by different programming languages
    to handle memory management: **explicit allocation and deallocation** and **automatic
    allocation and deallocation**. When writing software in an explicit memory management
    language, such as C-like languages, it''s the software developer''s job to tell
    the compiler when to allocate memory and how much to allocate to the software
    at any given stage. The developer also has to decide when that memory is no longer
    needed and explicitly tell the compiler to deallocate it. This increases the workload
    for the developer and can lead to frustrating bugs being introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Automatic memory management, on the other hand, removes the need for developers
    to explicitly allocate and deallocate memory, which, for the most part, makes
    the developer''s job easier. The compiler requests memory from the operating system
    in two main stages: static allocation at compilation time and dynamic allocation
    at runtime. Modern JavaScript engines use **Just-in-Time compilation**, which
    makes use of more than one compiler – a baseline compiler – and one or more optimization
    compilers, which recompile and cache parts of the code so that it''s more efficient.
    This forms a continuous loop of compilation, optimization, and decompilation/recompilation.
    The result of this is that JavaScript code is compiled and recompiled continuously
    at runtime, somewhat blurring the static and dynamic memory allocation stages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory allocation step is basically straightforward: the JavaScript engine
    identifies the amount of memory it needs and requests it from the operating system.
    Memory is then read from and written to as required by the program. The final
    stage of memory management, that is, deallocation, is the stage we need to focus
    on here.'
  prefs: []
  type: TYPE_NORMAL
- en: The Garbage Collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript engines have an additional application called a garbage collector,
    which deals with the automatic deallocation of memory at runtime. The garbage
    collector uses a process called mark-and-sweep to identify objects that are no
    longer needed and remove them from memory. It does this by starting at a root
    object – for example, the global window object – and traversing each object that
    is referenced by the root. It then checks all child and grandchild objects referenced
    by those objects, and thus maps out all the objects that are reachable from the
    root. Anything that is cut off from this map, thus being unreachable by the root
    object, is marked for deletion and subsequently removed from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: References between objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: References between objects'
  prefs: []
  type: TYPE_NORMAL
- en: In this simple case, the root object has a reference to the `cat` object, and
    the `cat` object has a reference to its `name` property, which is a string with
    the `Professor Meow` value. The garbage collector will see these references and
    will mark the `cat` object and its `name` property as reachable, and they will
    not be collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now reassign `cat` to `null`, we will have removed the reference chain
    between the root object and the `name` property of `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: The reference is lost, and the memory is freed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.15: The reference is lost, and the memory is freed'
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` object remains property of the global object, with a value of `null`,
    but any properties of `cat` that are not also referenced by another object linked
    to the root are removed from memory by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expand on this example to show how referencing an object from more than
    one other object can preserve its place in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Multiple references to the same object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Multiple references to the same object'
  prefs: []
  type: TYPE_NORMAL
- en: The `cat`, `dog`, and `mammal` objects are all properties of the global object
    (the `root`, in garbage collector speak), and the `cat` and `dog` objects reference
    the `mammal` object through their **class** property.
  prefs: []
  type: TYPE_NORMAL
- en: If we now reassign the `mammal` object to `null`, and once again the `cat` object
    to `null`, the reference from the `global` object to the `mammal` object via the
    `cat` object will be broken, as will its direct reference. However, since we have
    another reference to the `mammal` object via the `dog` object, the `mammal` object
    is still 'reachable" from the `global` object and is not collected by the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that, by inadvertently maintaining object references, you can make
    a program take up more memory than it needs. This is especially troubling for
    large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Garbage collection is a handy process for us developers since it reduces the
    workload that comes with manually managing memory. But it''s a double-edged sword;
    garbage collection happens automatically – we have no way of triggering the garbage
    collection process, nor do we know when the JavaScript engine will decide to do
    a garbage collection run – so it''s easy for us to forget all about the potential
    pitfalls of memory management. But garbage collection is not a perfect process,
    or at least it doesn''t always behave as we may expect it to. It will often fail
    to free up memory which, in actuality, is no longer needed. This is not a bug
    or mistake in the garbage collection process, it''s just a symptom of a problem:
    the question of whether an object will be needed again later on during execution
    can only be answered with certainty by the developer.'
  prefs: []
  type: TYPE_NORMAL
- en: When a piece of memory is allocated but maintains a link to the root object,
    even after it's no longer needed in the program, it will never be freed and will
    remain allocated, thereby taking up system memory until the software's execution
    ends. This is a memory leak, and it's not hard to imagine that they can become
    big issues with large objects, or frequent reoccurrences. It's not always obvious
    when our application is suffering from a memory leak, especially if we're developing
    our applications on a powerful machine, so it's important to avoid the common
    mistakes and to keep an eye on our application's memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few common memory leak scenarios and look at how we can avoid
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Event Listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common ways in which memory leaks occur comes from event listeners.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite common to see event listeners being added with an anonymous callback
    function, and it will work as expected (as long as there is an element with an
    ID of `scrollable`). However, by using an anonymous function, we are unable to
    remove the event listener at a later date should we need to, meaning that once
    this event listener is added, it will remain in place for the entirety of the
    program''s execution, and, depending on the function, could be adding objects
    to memory every time it''s called. To tackle this, let''s declare a named function
    and then pass that function to the event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the handler function instead of an anonymous function, we
    can make use of the `removeEventListener` method if we want to remove the event
    listener later on in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Detached DOM Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any reference to a DOM node that's made by JavaScript will prevent that node's
    memory allocation from being freed, even if the node is subsequently removed from
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have an array of image sources that we want to add
    to the DOM. It would make sense to store the parent DOM node in a variable and
    add the images via this variable reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, we have all of the images attached to the DOM, but we have also created
    an additional reference to the image parent element; there is one reference in
    the DOM tree, and one via the JavaScript variable, that is, `imageParent`. Let''s
    say that, later on in the program, we need to remove the image parent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This would remove the DOM node with the ID of `image-wrapper` from the DOM tree,
    but the variable, along with all its appended child `img` elements, is still referenced
    by the `imageParent` variable, and will still occupy memory, never to be collected
    by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The simple solution in this situation is to reassign the `imageParent` variable
    an `undefined` value after removing `imageParent` from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the mark-and-sweep algorithm looks for all the references connected to
    the roots of the memory object graph, any variables of the global object (the
    `window` object, in browser-based JavaScript, or the `global` object, in Node.js),
    will always be referenced and will therefore never be collected by the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to avoid declaring variables on the global object wherever
    possible, in other words, don't pollute the global namespace. There are a few
    good reasons for avoiding this, one of which is to avoid the resulting memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s fairly obvious when variables are explicitly declared on the global object,
    but there are a couple of situations that can lead to unexpected global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates an undeclared variable called `cat` that will implicitly
    be a property of the `global` object, even though it was created inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, using the `this` keyword will create a global variable. You can declare
    a variable with `var`, `let`, or `const` inside a function, and it will have a
    function-level scope of that function, instead of having global scope, like it
    would with an undeclared variable. It's also a good idea to use the `use strict`
    statement at the top of your JavaScript files, which will result in an error being
    thrown if you try to create an undeclared variable.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Memory Leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite our best efforts, memory leaks can creep into our code. They're often
    not obvious because the amount of memory they consume can be small, and they may
    grow relatively slowly, meaning they may not impact an application's performance
    unless they're kept running over many hours or days. And even when you find that
    you have a memory leak, it can be tricky to find the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.03: Identifying Memory Leaks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a simple example and see how Chrome's developer tools can help us
    identify that we have a memory leak. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new tab in Chrome, open `Menu` > `More Tools` > `Developer tools`, and
    go to the `Sources` tab:![Figure 7.17: An empty code snippet'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.17: An empty code snippet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click `''+ New snippet''` at the top left of this window and add the following
    code to set up our memory leak: First of all, we are creating a new DOM element
    of the `div` type and assigning it to a variable called `imageWrappe`r:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every modern browser has its own set of developer tools. However, for dealing
    with memory leaks, Chrome's developer tools are the most useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we declare three functions that simulate some user interaction with our
    page. The first function, `loadImages()`, creates 50 new image elements and adds
    a data property to them of a string containing `1,024 b` characters. This is analogous
    to loading images and adding them to `imageWrapper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function, `add()`, simply adds the `imageWrapper` element to the end
    of the document body, and our third function `remove()` will be used to remove
    that image wrapper.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s write one last function to tie these three together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This last function simulates adding and removing the image wrapper multiple
    times, thus loading 50 new images to it each time. A real-world example may be
    that we have a gallery of images and the user is clicking the ''`next`" button
    to load the next set of images (in our scenario, they''d be clicking it 1,000
    times!). Clearly, this would be a rather poor implementation of such a feature,
    but our aim here is to demonstrate how memory leaks can occur in a simple way.
    Your final code snippet should look something like this:![Figure 7.18: Code snippet
    with all the process() code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.18: Code snippet with all the process() code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click the `run snippet` button to execute the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will go to the performance tab of the dev tools and have a look at
    what''s happening in the memory heap as we add and remove our images. From the
    performance tab, click the record button to start recording a performance profile.
    While it''s recording, in the console, call the `process()` function, say, three
    times, and then hit the `stop` button. You should now see a screen that looks
    something like this:![Figure 7.19: Memory heap of the performance tab of the developer
    tools'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.19: Memory heap of the performance tab of the developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: This is the performance profile we have just recorded. It can tell us lots of
    information about the system resources that are being used by our application
    over the duration of the recording. The blue line here shows us how much of JavaScript's
    memory heap is being used over time. In an application without memory leaks, we
    would expect the memory usage to repeatedly go up with memory allocation and back
    down again to a base level with memory deallocation, giving us a `images` we've
    loaded are no longer needed after each call of `process()`, and so they stay in
    the memory heap. If you notice a real-life application becoming less performant
    over time, or using higher than expected system resources, then this is a good
    place to come to check for a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.04: Fixing the Memory Leak'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve established that we have a memory leak – as shown by the JavaScript
    memory heap graph in the preceding screenshot – our next task is to fix our code
    so that it no longer contains the leak. Given what you know of the garbage collector
    and the reason for our leak, try to implement a fix for the previous code so that
    the garbage collector can see when our objects are no longer needed. After each
    function call, record a performance profile to see whether the garbage collector
    is able to free up the memory. What you''re looking for is that the blue heap-memory
    allocation line goes up with memory allocation, but then comes back down again
    at regular intervals, showing that the memory is being deallocated. This is a
    sign of a garbage collector being able to deallocate the memory after each execution
    of the `process()` function. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a function and add it to the existing three functions that are called
    in the `process`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we've added one more function that is called `resetImageWrapper()`, which
    resets the `imageWrapper` object to an empty `div` element and added the function
    to our `process()` function's `for…loop`. Now, each time a set of images is removed
    from the DOM, its reference in JavaScript is also removed, and it can be marked
    by the garbage collector for deletion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to call this new function each time we process our images,
    so we will add it to our main `process()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, we''ll run the performance profiler. Go to the dev tools, then
    to the `Performance` tab, and click the record button to begin a performance profile
    recording. Then, call the `process()` function a few times and take a look at
    the memory heap usage:![Figure 7.20: Memory heap usage'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.20: Memory heap usage'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you probably noticed, the problem with our code was that we were storing
    references to each image element, and, therefore, the contents of its data attribute,
    inside the `imageWrapper` variable. The simple solution to this problem is to
    reassign the `imageWrapper` variable each time we remove it from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: This is a much healthier memory heap profile. After each of the three `process()`
    function calls, the garbage collector could see that the images were no longer
    referenced by either the DOM or by JavaScript, and the space they were allocated
    in memory was freed up and given back to the memory pool.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've covered the two main techniques for dealing with memory
    management in different programming languages – manual and automatic – and looked
    at the browser's garbage collector processes. We then looked at the major con
    of automatic memory management and modern browsers' garbage collection algorithms,
    namely memory leaks, in more detail. Finally, we had an overview of one of the
    techniques we can use to identify when our application has such a leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Finding out the Number of Stack Frames'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned about JavaScript's call stack and saw that
    it's possible to generate an error if too many stack frames are added to the stack.
    Each implementation of a JavaScript engine can have a different limit regarding
    the size of the stack. In this activity, we'll write a function that will tell
    us when the maximum number of stack frames has been reached in the stack before
    the stack overflow error is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a function that calls itself repeatedly, causing the stack overflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep count of the number of times the function calls itself. (This is like counting
    the number of stack frames getting pushed to the call stack.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the final number after the stack overflow error has occurred. Remember
    that no new functions can be called after a stack overflow error!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of this activity will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.21: Showing the number of stack frames pushed before a stack overflow
    was triggered'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_07_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.21: Showing the number of stack frames pushed before a stack overflow
    was triggered'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 731.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen how the blocks of code many people think of as
    just ''JavaScript" can actually be broken down into separate components: the JavaScript
    engine, consisting of the call stack, memory heap, and the garbage collector (as
    well as other important components not covered by this chapter); and the JavaScript
    runtime environment, such as a browser, or Node.js, which contains the JavaScript
    engine, and gives the engine access to additional functions and interfaces, such
    as `setTimeout()` or a filesystem interface.'
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how JavaScript manages memory allocation and deallocation,
    and how even though it is managed automatically, it's important for developers
    to bear the processes involved in mind in order to write code that enables the
    garbage collector to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at different aspects of the environment API
    in more detail so that we can learn about some of the less commonly used features
    we can find in the browser and in Node.js.
  prefs: []
  type: TYPE_NORMAL
