- en: 7\. Popping the Hood
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 拆卸引擎盖
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to differentiate between single-threaded
    and multi-threaded execution; describe JavaScript's execution process; show how
    the call stack and memory heap interact with the other elements of the runtime;
    write code that works in tandem with JavaScript's garbage collection process;
    and debug memory-related issues in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够区分单线程和多线程执行；描述JavaScript的执行过程；展示调用栈和内存堆如何与其他运行时元素交互；编写与JavaScript的垃圾回收过程协同工作的代码；并在浏览器中调试与内存相关的问题。
- en: In this chapter, we'll look at how JavaScript is executed in the browser and
    how it manages important system resources such as memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨JavaScript在浏览器中的执行方式以及它如何管理重要的系统资源，如内存。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous two chapters, you learned about some of the core concepts of
    JavaScript, were introduced to the ideas of the `event` loop, and looked at how
    JavaScript handles the process of **memory management**. In this chapter, we'll
    look at those aspects of the language in more detail and learn how we can write
    code that works in concert with some underlying features of JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，你学习了JavaScript的一些核心概念，了解了`事件循环`的概念，并探讨了JavaScript如何处理**内存管理**的过程。在本章中，我们将更详细地探讨这些语言方面，并学习如何编写与JavaScript的一些底层功能协同工作的代码。
- en: It is common for developers to get quite far in their careers without having
    a solid understanding of some of the core concepts underlying (and surrounding)
    JavaScript. Indeed, it's quite possible to be a successful developer who writes
    solid, commercially viable applications, without ever fully grasping the topics
    that are covered in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，在职业生涯中取得很大进展而没有对JavaScript的一些核心概念及其周围的概念有坚实的理解是很常见的。确实，完全有可能成为一名成功的开发者，编写出坚实、具有商业价值的应用程序，而从未完全掌握本章涵盖的主题。
- en: So, why should we learn about the inner workings of JavaScript? Can't we just
    write our code and let JavaScript handle the nitty-gritty? Well, the problem with
    that approach is that, sometimes, things don't quite go according to plan, and
    we need to be able to understand what's happening under the hood in order to rewrite
    the part of our code that is making the application buggy or less performant.
    Imagine you're a rally driver. You can drive your car along the track with just
    a rudimentary level of knowledge of how to drive a car. This skill level may get
    you to the finish line, but it definitely won't have you winning any races.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们应该了解JavaScript的内部工作原理呢？我们难道不能只是编写我们的代码，让JavaScript处理细节吗？嗯，这种方法的缺点是，有时事情并不完全按照计划进行，我们需要能够理解底层发生了什么，以便重写使应用程序出现错误或性能下降的代码部分。想象一下，你是一名拉力赛车手。你只需要对如何驾驶汽车有基本的了解，就可以沿着赛道驾驶你的汽车。这种技能水平可能让你到达终点线，但绝对不能让你赢得任何比赛。
- en: To set yourself apart from other drivers, you need to increase your skill and
    experience levels. Sure, simply practicing the skill will help you improve over
    time, and allow you to intuit a lot of what's happening behind the scenes – this
    is true for driving a car and programming computers with JavaScript – but having
    a deeper understanding of the actual processes involved will allow you to plan
    and make decisions with confidence so that you know specifically what parts of
    the system you want to control.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他驾驶员区分开来，你需要提高你的技能和经验水平。当然，仅仅练习技能会随着时间的推移而帮助你提高，并让你能够直观地了解幕后发生的事情——这适用于驾驶汽车和用JavaScript编写计算机程序——但更深入地了解实际涉及的过程将使你能够自信地制定计划和做出决策，以便你知道具体想要控制系统的哪些部分。
- en: To give you a more concrete programming example, imagine you're testing a co-worker's
    code and you can't understand why a page seems to take so long to load, why it
    becomes unresponsive during a certain operation, or why the application takes
    up excessive system resources. These kinds of performance issues don't necessarily
    break an application, and they may not even be noticeable to every user. But they
    do affect the software's usability and the user experience, which has knock-on
    effects on things such as SEO page ranking and a site's popularity with its end
    users. Understanding what's going on under the hood can help you write better
    code and debug code faster, making your life as a developer easier, and making
    for smoother user experience and more successful applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个更具体的编程示例，想象一下你正在测试同事的代码，你无法理解为什么页面似乎加载得如此缓慢，为什么在某个操作期间变得无响应，或者为什么应用程序消耗了过多的系统资源。这类性能问题并不一定会破坏应用程序，甚至可能对每个用户都不可见。但它们确实会影响软件的可使用性和用户体验，这对
    SEO 页面排名和网站在最终用户中的受欢迎程度有连锁反应。了解底层发生的事情可以帮助你编写更好的代码，更快地调试代码，使你的开发者生活更轻松，并为用户提供更流畅的体验和更成功的应用程序。
- en: Arming yourself with the knowledge covered in this chapter means that the code
    you write will make the best use of the JavaScript programming language and its
    runtime environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握本章所涵盖的知识，你编写的代码将最大限度地利用 JavaScript 编程语言及其运行时环境。
- en: JavaScript Execution and the Event Loop
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 执行和事件循环
- en: JavaScript is a single-threaded language, meaning it lines up all of its operations
    in a single thread and executes them one at a time. Many other languages are multi-threaded,
    that is, they are able to execute more than one thread of operations at a time.
    There are pros and cons to each method of execution, mostly revolving around efficiency
    versus complexity, but we won't look at these in-depth here. As we'll see in a
    moment, JavaScript's call stack processes operations one at a time, on a last
    in, first out (LIFO) basis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种单线程语言，这意味着它将所有的操作都排成一条线，并逐个执行。许多其他语言是多线程的，也就是说，它们能够同时执行多个操作线程。每种执行方法都有其优缺点，主要围绕效率与复杂度展开，但在这里我们不会深入探讨这些。正如我们马上要看到的，JavaScript
    的调用栈会逐个处理操作，按照后进先出（LIFO）的原则。
- en: LIFO describes a process of adding and removing elements from a data structure
    – in this case, from a stack. As the name suggests, the last thing that's added
    is the first thing taken away – much like stacking books on a desk.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: LIFO 描述的是从数据结构中添加和删除元素的过程——在本例中，是从栈中。正如其名所示，最后添加的元素是第一个被移除的——就像在桌子上堆叠书籍一样。
- en: The JavaScript Runtime
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 运行时
- en: A runtime environment is an application that allows the software to be run on
    a system. It's the bridge between the software being run and the system on which
    it is being run and provides access to system resources such as memory and filesystem,
    and to runtime and environment variables. In the case of JavaScript, the runtime
    is often – but not always – the browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时环境是一个允许软件在系统上运行的应用程序。它是正在运行的软件与其运行系统之间的桥梁，并提供对系统资源（如内存和文件系统）以及运行时和环境变量的访问。在
    JavaScript 的情况下，运行时通常是——但并不总是——浏览器。
- en: There are different implementations of the JavaScript runtime, and the exact
    way they handle executions differs between each. Each one makes use of optimization,
    which can make real-life processes differ from those described here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 运行时有不同的实现方式，它们处理执行的具体方式各不相同。每个实现都使用了优化，这可能导致实际过程与这里描述的不同。
- en: 'However, from a theoretical standpoint, a JavaScript runtime can be usefully
    broken down into several key components and processes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从理论角度来看，JavaScript 运行时可以有效地分解为几个关键组件和过程：
- en: The JavaScript engine
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 引擎
- en: Environment/Browser APIs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境/浏览器 API
- en: The Message Queue/Callback Queue
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列/回调队列
- en: The `event` loop
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'The JavaScript runtime environment and execution broken down into these key
    components can be displayed as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 运行时环境和执行分解为以下关键组件，可以表示如下：
- en: '![Figure 7.1: An overview of the JavaScript runtime'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：JavaScript 运行时概述](img/C14377_07_01.jpg)'
- en: '](img/C14377_07_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：JavaScript 运行时概述](img/C14377_07_01.jpg)'
- en: 'Figure 7.1: An overview of the JavaScript runtime'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：JavaScript 运行时概述
- en: Let's look at each of these in turn to get a better understanding of their functionality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些组件，以更好地理解它们的功能。
- en: JavaScript Engine
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 引擎
- en: A JavaScript engine is a piece of software that runs JavaScript code, turning
    the high-level JavaScript source code into low-level machine code via the process
    of `Node.js` (used in server-side JavaScript execution) among other places. V8,
    like most modern browsers, uses a **Just-In-Time compilation** process to execute
    JavaScript code, meaning that the code is compiled at runtime and not ahead of
    time, like with older compilation processes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎是一段运行JavaScript代码的软件，通过`Node.js`（用于服务器端JavaScript执行）等过程，将高级JavaScript源代码转换为低级机器代码。V8，像大多数现代浏览器一样，使用**即时编译**过程来执行JavaScript代码，这意味着代码是在运行时编译的，而不是像旧编译过程那样提前编译。
- en: The two elements of a JavaScript engine that we're concerned with here are the
    **memory heap** and the **call stack**, both of which will be explained shortly.
    Note that the preceding diagram shows the event loop as being separate from the
    JavaScript engine as it's generally expected that the JavaScript runtime will
    implement and manage the event loop. However, many JavaScript engines implement
    their own event loop process, which can be used as a fallback for the runtime
    environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里关注的JavaScript引擎的两个元素是**内存堆栈**和**调用栈**，这两者都将在稍后进行解释。请注意，前面的图示显示事件循环是独立于JavaScript引擎的，因为通常预期JavaScript运行时会实现并管理事件循环。然而，许多JavaScript引擎实现了它们自己的事件循环过程，这可以作为运行时环境的后备。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, Node runs on the V8 JavaScript engine. However, alternate implementations
    of Node using different engines are being worked on. **Node-ChakraCore**, which
    uses Microsoft's ChakraCore JavaScript engine, is one such project and is under
    active development. Another is **SpiderNode**, although the development of this
    project has stalled at the time of writing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node在V8 JavaScript引擎上运行。然而，正在开发使用不同引擎的Node的替代实现。**Node-ChakraCore**，它使用微软的ChakraCore
    JavaScript引擎，是这样一个项目，并且正在积极开发中。另一个是**SpiderNode**，尽管在撰写本文时，这个项目的发展已经停滞。
- en: Environment APIs
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境API
- en: Often called Web APIs or Browser APIs in the context of a browser, these are
    the interfaces that are made available to JavaScript by the environment in which
    it is being run. For example, the browser gives access to the `LocalStorage`,
    and methods such as `setTimeout()` and `setInterval()`, which we've covered in
    previous chapters. JavaScript running outside of a browser will have different
    needs, and therefore the runtime will expose different interfaces for it to use.
    Node.js is a popular server-side JavaScript runtime environment, which we will
    cover later on in this book. It usually wouldn't make much sense for Node.js to
    have a Document Object Model (DOM), so instead, Node provides APIs that are more
    relevant to server-side code such as the `FileSystem` API for performing `filesystem`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器的上下文中通常被称为Web API或浏览器API，这些是运行JavaScript的环境提供给JavaScript的接口。例如，浏览器提供了对`LocalStorage`的访问，以及我们已在前面章节中介绍过的`setTimeout()`和`setInterval()`等方法。在浏览器之外运行的JavaScript将有不同的需求，因此运行时会为它提供不同的接口。Node.js是一个流行的服务器端JavaScript运行环境，我们将在本书的后面部分进行介绍。对于Node.js来说，拥有文档对象模型（DOM）通常没有太多意义，因此，Node提供了更适用于服务器端代码的API，例如用于执行`filesystem`的`FileSystem`
    API。
- en: As we'll see shortly, environment APIs are a crucial component of JavaScript's
    ability to run **asynchronous operations**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们很快就会看到的，环境API是JavaScript执行**异步操作**能力的一个关键组成部分。
- en: Message Queue
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列
- en: The message queue (also known as the `setTimeout` function's delay time has
    expired, or when an event occurs and there is a corresponding event listener,
    such as when a user clicks on a button and the button has a click event listener
    attached to it. These operations occur in a **first in, first out**(**FIFO**)
    sequence, much like the queue you find at a supermarket checkout. The message
    queue doesn't actually execute the functions itself – it's simply a place to keep
    them on hold until the call stack has finished doing what it's doing. The time
    at which the operation is executed is decided by the event loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列（也称为`setTimeout`函数的延迟时间已过期，或者当发生事件并且有相应的事件监听器时，例如当用户点击按钮并且按钮附加了点击事件监听器时。这些操作按照**先进先出**（**FIFO**）的顺序发生，就像你在超市结账处找到的队列一样。消息队列本身并不执行函数——它只是一个在调用栈完成其操作之前暂时存放它们的地方。操作执行的时间由事件循环决定。
- en: Event Loop
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: The event loop is the process by which messages are added from the message queue
    to the call stack. The event loop watches the call stack and the message queue,
    and if the call stack is empty, then the oldest message from the message queue
    (the first in) will be pushed onto the stack for execution. Only when all the
    function calls on the stack have returned will subsequent messages (function calls)
    be pushed onto the stack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是通过将消息从消息队列添加到调用栈的过程。事件循环监视调用栈和消息队列，如果调用栈为空，则消息队列中最老的消息（第一个）将被推送到栈上执行。只有当栈上的所有函数调用都返回后，后续的消息（函数调用）才会被推送到栈上。
- en: Call Stack
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用栈
- en: 'The call stack keeps track of JavaScript''s function invocations. When a function
    is called, a **stack frame**, consisting of the function''s name (or ''anonymous,"
    for anonymous functions), and a reference to the function caller''s address, is
    pushed onto the top of the stack. If this function calls another function, then
    a new frame for the second function is pushed to the top of the stack, on top
    of the previous frame. When the function returns – either explicitly or implicitly
    – the function''s corresponding stack frame is popped off the call stack, and
    code execution carries on from where it was before the function call. Unlike the
    message queue, the call stack processes frames in a LIFO sequence: stack frames
    are added to and taken from, the top of the stack, much like stacking books on
    a desk. When the call stack is empty, the event loop will decide whether to push
    messages from the message queue or to allow new stack frames to be added to the
    call stack for subsequent function calls.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈跟踪 JavaScript 的函数调用。当一个函数被调用时，一个**栈帧**（由函数的名称（或“匿名”，对于匿名函数）和函数调用者的地址引用组成）被推送到栈顶。如果这个函数调用另一个函数，那么第二个函数的新帧会被推送到栈顶，位于上一个帧之上。当函数返回——无论是显式还是隐式——相应的栈帧就会被从调用栈中弹出，代码执行从函数调用之前的位置继续。与消息队列不同，调用栈以
    LIFO（后进先出）的顺序处理帧：栈帧被添加到和从栈顶移除，就像在桌子上堆叠书籍一样。当调用栈为空时，事件循环将决定是否将消息队列中的消息推送到调用栈，或者允许新的栈帧被添加到调用栈以供后续函数调用。
- en: Memory Heap
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存堆
- en: The memory heap is an unsorted area of memory that the JavaScript engine uses
    to dynamically read and write objects at runtime. We will look at memory management
    in JavaScript in detail later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内存堆是 JavaScript 引擎在运行时用于动态读取和写入对象的未排序内存区域。我们将在本章的后面部分详细讨论 JavaScript 中的内存管理。
- en: Event Loop in Action
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环实战
- en: This section explains the code we will use to demonstrate the event loop in
    action and also provide a brief precursor regarding how asynchronous code is executed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释我们将用来演示事件循环实战的代码，并提供关于异步代码执行的一个简要先导。
- en: 'In your browser''s JavaScript console or your code editor of choice, the three
    simple function declarations are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你选择的浏览器 JavaScript 控制台或代码编辑器中，三个简单的函数声明如下：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this simple code snippet, we are declaring three functions and then calling
    the first of the three. The `firstCall` function logs the `'I'm logged first"`
    string in the console, and then calls the next function, `secondCall()`. This
    function logs the `'I'm second..."` string, and subsequently calls the third of
    our functions, `thirdCall()`. `thirdCall()` simply logs the `'I'm last."` string
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的代码片段中，我们声明了三个函数，然后调用这三个函数中的第一个。`firstCall`函数在控制台记录了`'I'm logged first'`字符串，然后调用下一个函数`secondCall()`。这个函数记录了`'I'm
    second...'`字符串，随后调用我们的第三个函数`thirdCall()`。`thirdCall()`简单地记录了`'I'm last.'`字符串
- en: 'What do you expect to see in the console when we run this code? Hopefully,
    it''s quite obvious that we will see the following logged:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，你期望在控制台看到什么？希望它非常明显，我们将看到以下日志：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, each function invocation is added to the call stack, executed
    in turn, and then popped off the top of the stack. Therefore, we get the strings
    from the three functions logged in their correct order. You can see the stack
    frames for each of the function invocations in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个函数调用都被添加到调用栈中，依次执行，然后从栈顶弹出。因此，我们以正确的顺序看到了来自三个函数的字符串。你可以在以下屏幕截图中看到每个函数调用的栈帧：
- en: '![Figure 7.2: Demonstrating the sequence of execution in the call stack'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：演示调用栈中的执行顺序'
- en: '](img/C14377_07_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_02.jpg)'
- en: 'Figure 7.2: Demonstrating the sequence of execution in the call stack'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：演示调用栈中的执行顺序
- en: 'Now, let''s make a small change to our code by adding a `setTimout()` function
    in the second function block. So, let''s take a look at what the three strings
    will be logged in this time if you write and run the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Logic dictates that the order of our console logs will remain the same – after
    all, the `setTimeout` delay is `0` milliseconds, so it will execute on the console
    log straight away, right?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we find that the order has changed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what do you think is going on here? We will go through the source code line
    by line and see how the JavaScript runtime is handling each function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the `firstCall()` function is invoked and a new stack frame is
    pushed to the top of the call stack of this function invocation. The function
    contains a call to the `log()` method of the console object, with an argument
    of the string type with the value `''I''m logged first!!"`. This is highlighted
    in the following figure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Demonstrating the call stack after calling firstCall()'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Demonstrating the call stack after calling firstCall()'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The `''I''m logged first!!"` string is logged to the console, the `secondCall()`
    function is invoked, and a new stack frame is pushed onto the top of the stack
    for `secondCall()`. Here is where things are different from the original code
    snippet. This function contains a call to the `setTimeout()` function, which is
    a part of the browser''s API, so this function is taken outside of the main JavaScript
    execution thread for now. The `setTimeout()` function is called with a delay of
    0 milliseconds, after which a message is passed to the message queue with a reference
    to the `console.log()` call contained within the `secondCall()` function. Now,
    this message sits in the message queue, waiting patiently to be dealt with by
    the `event` loop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Demonstrating the setTimeout() method being assigned to the message
    queue'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Demonstrating the setTimeout() method being assigned to the message
    queue'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how the `secondCall()` function calls `thirdCall()`. Another
    new stack frame is pushed onto the call stack for this function invocation. It
    calls `console.log()` with the `''I''m last."` string, which is printed to the
    console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The end of the final function call'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: The end of the final function call'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, `thirdCall()` has no other operations to execute, so it implicitly
    returns the value `undefined` back to `secondCall()`, and the stack frame for
    `thirdCall()` is popped off the call stack. Then `secondCall()` returns `undefined`
    to `firstCall()`, and the stack frame for `secondCall()` is popped off the stack.
    Next, the stack frame for `firstCall()` is popped off the stack, and `undefined`
    is returned back to the main process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Showing the empty call stack after the functions have returned'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Showing the empty call stack after the functions have returned'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：显示函数返回后的空调用栈
- en: 'Now, we can see that the only remaining frame on the call stack is the anonymous
    main process and that no other functions are being called by the main process.
    The event loop sees that the call stack is available and that there is a message
    waiting in the message queue, so it pushes a new stack frame for the callback
    function referenced in the pending message. This callback function is our remaining
    `console.log()` call, with the `''I''m second…"`: string:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到调用栈上唯一剩下的帧是匿名的主进程，并且主进程没有调用其他函数。事件循环看到调用栈可用，并且消息队列中有一个等待的消息，因此它为待处理消息中引用的回调函数推入一个新的栈帧。这个回调函数是我们的剩余
    `console.log()` 调用，带有字符串 `'I'm second…'`：
- en: '![Figure 7.7: Showing the console.log stack frame'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7：显示 console.log 调用栈帧'
- en: '](img/C14377_07_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_07_07.jpg](img/C14377_07_07.jpg)'
- en: 'Figure 7.7: Showing the console.log stack frame'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：显示 console.log 调用栈帧
- en: The final `console.log` call is executed, with the string being printed to the
    console, and the stack frame is then popped off the call stack, again leaving
    only the anonymous main process left on the stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `console.log` 调用被执行，字符串被打印到控制台，然后调用栈帧从调用栈中弹出，再次只留下匿名的主进程留在栈上。
- en: This demonstrates how, despite JavaScript being single-threaded, it's possible
    to continue executing code while a previously invoked function is waiting to be
    completed. There are many other functions and APIs built into the browser besides
    `setTimeout`, and we will look at more of these in the next chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了尽管 JavaScript 是单线程的，但在之前调用的函数等待完成的同时继续执行代码是可能的。除了 `setTimeout` 之外，浏览器还内置了许多其他函数和
    API，我们将在下一章中探讨更多这些内容。
- en: 'Exercise 7.01: Working with the Event Loop'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：与事件循环一起工作
- en: 'Let''s take a look at how we can apply this knowledge to a more realistic (albeit
    simple) application. The goal of this exercise is to illustrate how the `event`
    loop can produce some unexpected behavior in our applications and also to see
    how we can work with the `event` loop to give useful functionality to our apps.
    Let''s get started:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将这一知识应用到更现实（尽管简单）的应用中。本练习的目的是说明事件循环如何在我们的应用中产生一些意外的行为，并了解我们如何与事件循环一起工作，为我们的应用提供有用的功能。让我们开始吧：
- en: 'We''ll have an HTML file with two `<div>` elements in the body with IDs of
    `status` and `result`. The purpose of the application is going to be to run a
    function and display the result in the `result` div. We know that our function
    will take a not-insignificant amount of time to run, so we will also incorporate
    a status feature so as to keep the user aware of what''s happening in the application.
    For this example, our main function will be an arbitrary calculation that takes
    a few seconds to complete. In real life, this could be any kind of complex calculation,
    or a function for fetching data from an external source, such as a database or
    an API. Load the `index.html` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有一个包含两个 `<div>` 元素的 HTML 文件，其 body 中的 ID 分别为 `status` 和 `result`。应用的目的将是运行一个函数并在
    `result` div 中显示结果。我们知道我们的函数将需要相当长的时间才能运行，因此我们还将结合状态功能，以便让用户了解应用中正在发生的事情。在这个例子中，我们的主函数将是一个任意计算，需要几秒钟才能完成。在现实生活中，这可能是一类复杂的计算，或者是从外部源（如数据库或
    API）获取数据的函数。加载 `index.html` 文件：
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a separate JavaScript file, called `event-loop.js`, we''ll write a collection
    of functions to make up our application. First, we''re adding an event listener
    to the window object so that the rest of the code won''t run until the DOM''s
    content has loaded (`DOMContentLoaded` is triggered when the browser completes
    the DOM tree structure, not including any style sheets or images):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `event-loop.js` 的单独的 JavaScript 文件中，我们将编写一组函数来构建我们的应用。首先，我们向窗口对象添加一个事件监听器，这样在
    DOM 的内容加载完成之前（`DOMContentLoaded` 在浏览器完成 DOM 树结构时触发，不包括任何样式表或图像）其余的代码不会运行：
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After this, we are assigning our two `<span>` elements with the IDs of `status`
    and `result` to two aptly named variables:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们将两个具有 `status` 和 `result` ID 的 `<span>` 元素分配给两个恰如其分的变量：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we are defining two functions, `showStatus()` and `doCalculation()`.
    The `showStatus()` function takes in an argument of `statusText`, which will be
    set to the `innerText` property of `statusSpan`, thereby displaying whatever text
    we pass to `showStatus()` on the page:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The other function, `doCalculation()`, runs our calculation and then sets the
    result to the `innerText` property of the `resultSpan` variable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, to join these together, we could call the functions at the end of the `DOMContentLoaded`
    callback function like this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Try running this code and see whether it works as we expect. Not very good,
    is it? When we first open the page, it loads for a while and then displays the
    `Calculation finished` status and the result. But we never see the `Calculation
    running` status:![Figure 7.8: The output from the first version of the application'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_07_08.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.8: The output from the first version of the application'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Why is it, then, that don't we get to see the first status? When we update the
    DOM by doing something such as setting the `innerText` property of a DOM node,
    the DOM tree itself is updated, and then the browser repaints the render tree
    to the browser window. These are two separate steps, and the repaint step happens
    after the current call stack has finished. So, with our new knowledge of the event
    loop, we should be able to see what's happening. When we call `showStatus()` for
    the first time, the DOM is updated, but the browser doesn't redraw the page yet.
    Then, `doCalculation()` is called, and the execution thread is blocked until the
    calculation has finished. The `showStatus()` function is called a second time
    with the `Calculation finished` string, and at this point, the browser repaints
    the render tree with the `Calculation finished` string that we passed to the second
    call of `showStatus()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'To get our application to work more in line with our specifications, have a
    go at this yourself before checking out the solution:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By adding the call to `doCalculation()` and the second call to `showStatus()`
    to a `setTimout()` function, the call stack is emptied after the first `showStatus()`
    function executes, at which point the browser repaints the page, displaying the
    `Calculation running` string as expected. This is a much better implementation
    since it keeps the user informed of what the application is doing:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Showing the status while the calculation is running'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Showing the status while the calculation is running'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Stack Overflow
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The call stack is an example of a data type called – you guessed it – a stack.
    You can think of a stack simply as a container of objects (stack frames, representing
    functions and arguments, in the case of a call stack). There's a limit to the
    number of frames a call stack can hold. We'll now look at what happens when the
    call stack gets full, a common problem that developers face, and what's known
    as a stack overflow. (In the V8 JavaScript engine, it has a different name, but
    the theory is the same.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈是称为——你猜对了——栈的数据类型的一个例子。你可以简单地将栈视为对象的容器（在调用栈的情况下，栈帧代表函数和参数）。调用栈可以容纳的帧数是有限的。现在，我们将看看调用栈满了会发生什么，这是开发者面临的一个常见问题，也称为栈溢出。（在V8
    JavaScript引擎中，它有不同的名称，但理论是相同的。）
- en: This can happen, for example, when developers are trying to write a recursive
    function but fail to code in a base case and/or a termination condition, at which
    point the recursion should stop. It can be tricky – especially for new developers
    – to account for every edge case that may bypass these points.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当开发者尝试编写一个递归函数但未能编写基例和/或终止条件时，这种情况就会发生。此时，递归应该停止。对于新开发者来说，考虑到可能绕过这些点的每个边缘情况可能很棘手。
- en: Let's take a look at a simple example of a stack overflow first, after which
    we'll explore a more true-to-life example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个简单的栈溢出例子，之后我们将探讨一个更贴近实际的例子。
- en: 'Given the following code, let''s take a look at what will happen in the JavaScript
    engine when we call the `callMe()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下代码，让我们看看在调用`callMe()`函数时，JavaScript引擎会发生什么：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It should be fairly obvious what will happen with this code, but still, let's
    look through a few steps of the process on the call stack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会发生什么应该是相当明显的，但仍然，让我们看看调用栈中这个过程的一些步骤。
- en: 'When we call `callMe()`, a new stack frame is added to the call stack for that
    invocation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`callMe()`时，一个新的栈帧被添加到该调用的调用栈中：
- en: '![Figure 7.10: The first stack frame is added to the call stack'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：第一个栈帧被添加到调用栈中'
- en: '](img/C14377_07_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_10.jpg)'
- en: 'Figure 7.10: The first stack frame is added to the call stack'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：第一个栈帧被添加到调用栈中
- en: 'Inside `callMe()`, the other function, `nowCallMe()`, is called, adding a stack
    frame for that function invocation to the stack. `nowCallMe()` in turn calls `callMe()`,
    adding a new stack frame to the call stack, and on and on it goes, with both functions
    calling each other in turn, and a new stack frame is added to the stack every
    time. In this scenario, the JavaScript execution thread has nowhere else to go
    – there is no condition in the code that will cause the thread to move on from
    this loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callMe()`内部，另一个函数`nowCallMe()`被调用，为该函数调用添加一个栈帧到栈中。`nowCallMe()`反过来调用`callMe()`，向调用栈中添加一个新的栈帧，以此类推，两个函数依次调用对方，每次调用都会在栈中添加一个新的栈帧。在这种情况下，JavaScript执行线程没有其他地方可去——代码中没有条件会导致线程从这个循环中移动：
- en: '![Figure 7.11: The call stack is filling with stack frames'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11：调用栈正在填充栈帧'
- en: '](img/C14377_07_11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_11.jpg)'
- en: 'Figure 7.11: The call stack is filling with stack frames'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：调用栈正在填充栈帧
- en: 'This loop will continue to add stack frames to the call stack until the stack''s
    limit is reached. In the V8 implementation of the JavaScript engine, the limit
    for the number of frames in the stack is often somewhere around 16,000, although
    it can be higher or lower, depending on the content of each frame, the variables
    being used, and other factors. (At the end of this chapter, we''ll write a function
    to calculate the stack limit for different JavaScript engines and environments.)
    If this limit is exceeded, the engine throws a stack overflow error, referred
    to by V8 as `Maximum call stack size exceeded`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会继续向调用栈中添加栈帧，直到栈的极限。在V8 JavaScript引擎的实现中，栈中帧数的限制通常在16,000左右，尽管它可以更高或更低，这取决于每个帧的内容、使用的变量和其他因素。（在本章末尾，我们将编写一个函数来计算不同JavaScript引擎和环境的栈限制。）如果超过这个限制，引擎会抛出一个栈溢出错误，V8将其称为`Maximum
    call stack size exceeded`：
- en: '![Figure 7.12: Stack overflow error'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12：栈溢出错误'
- en: '](img/C14377_07_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_12.jpg)'
- en: 'Figure 7.12: Stack overflow error'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：栈溢出错误
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to change the call stack size limit in the V8 JavaScript engine.
    To do so, simply launch the environment – be it Node, Chrome, or another implementation
    – with the `stack-size=[value]` flag. Bear in mind, though, that this should only
    be used for debugging or for experimentation – you certainly don't want to write
    code with the expectation that it will be run with anything other than the default
    call stack size.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 V8 JavaScript 引擎中更改调用栈大小限制。要做到这一点，只需使用带有 `stack-size=[value]` 标志启动环境——无论是
    Node、Chrome 还是其他实现——但请注意，这仅应用于调试或实验——你当然不希望编写期望以除默认调用栈大小之外的任何大小运行的代码。
- en: 'Now, let''s take a look at a more real-life example, and later see how we can
    fix it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更贴近现实生活的例子，稍后我们将看看如何修复它：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function is an example of **recursion**, which we'll look at in more detail
    later on in this book. It may not be immediately obvious what this function is
    doing, so let's break it down into steps.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是 **递归** 的一个例子，我们将在本书的后面部分更详细地探讨。这个函数的作用可能一开始并不明显，所以让我们将其分解成几个步骤。
- en: 'The function takes in a number and calls itself recursively, subtracting 2
    from the `num` argument for each call. Let''s say we call it with the argument
    of `10`, like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收一个数字并递归地调用自身，每次调用从 `num` 参数中减去 2。假设我们用 `10` 作为参数调用它，如下所示：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function first checks to see whether `num` is equal to `0`, and if it is,
    it will return a console log with the value of `0`, and this function's execution
    will finish (this line is our termination condition). Right now, `num` is equal
    to `10`, so this `if` statement is `false`, and the execution proceeds to the
    next line.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先检查 `num` 是否等于 `0`，如果是，它将返回一个包含 `0` 值的控制台日志，并且此函数的执行将结束（这是我们的终止条件）。目前，`num`
    等于 `10`，所以这个 `if` 语句是 `false`，执行继续到下一行。
- en: The next line logs the value of `num` to the console and then proceeds to the
    next line.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条记录将 `num` 的值记录到控制台，然后继续到下一行。
- en: Now, the function calls itself again, with the value of `num` `minus 2` – so
    `8`, in our case. This continues.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数再次调用自身，这次 `num` 的值减去 2——在我们的例子中是 `8`。这个过程会继续。
- en: By calling the preceding function with the argument of `10`, we'll see the numbers
    `10`, `8`, `6`, `4`, `2`, and `0` are logged to the console, as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `10` 作为参数调用前面的函数，我们将看到 `10`、`8`、`6`、`4`、`2` 和 `0` 这些数字按预期记录到控制台。
- en: But what happens if we call the function with an odd number? Try calling the
    same function with `11` as the input. You'll see that our termination condition
    of `num=== 0` never occurs since `num` goes from `1` to `-1`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们用奇数调用这个函数会发生什么？尝试用 `11` 作为输入调用相同的函数。你会看到我们的终止条件 `num=== 0` 永远不会发生，因为 `num`
    从 `1` 变到 `-1`。
- en: 'Exercise 7.02: Stack Overflow'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：Stack Overflow
- en: 'The goal of this exercise is to rewrite the stack overflow function so that
    it accounts for as many other inputs as it can. Think about all the possible arguments
    this function could be called with, and how the function will handle each one.
    Let''s get started:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是重写栈溢出函数，使其能够处理尽可能多的其他输入。考虑所有可能被调用此函数的参数，以及函数将如何处理每一个。让我们开始：
- en: 'Let''s go through a few possible inputs to make sure we''re accounting for
    all eventualities, thereby minimizing the risk of an error occurring. Here are
    some of the edge cases we need to be careful of:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过一些可能的输入来确保我们考虑到所有可能的情况，从而最大限度地减少错误发生的风险。以下是我们需要小心的一些边缘情况：
- en: The `num` input is odd.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num` 输入是奇数。'
- en: The input is 0.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入为 0。
- en: This input is less than 0.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此输入小于 0。
- en: The input is null or is not of a `number` type.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入为空或不是 `number` 类型。
- en: 'For now, let''s assume that we want the function to return whenever the input
    is not a number or is a negative number, and if it''s 0, then we want the function
    to log 0 to the console and return. Write the function as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，让我们假设我们希望函数在输入不是数字或为负数时返回，如果输入为 0，则希望函数将 0 记录到控制台并返回。请按以下方式编写函数：
- en: '[PRE14]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we've added a termination condition using the `typeof` operator to determine
    whether the input, `num`, is a number as expected. We will return `undefined`
    if it's not of a `number` type or if it's a number less than `0`. If `num` is
    a number, and it's greater than or equal to `0`, then the function will log the
    value of `num` and call itself again with `num` `–2`, and so the cycle repeats.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By making these changes to the function, we are accounting for the initial
    input of an odd number, which would have bypassed our termination condition in
    the original function. We''re also accounting for inputs where `num` is not of
    type `number`; say, a string or an object. But there are also some less obvious
    edge cases we need to be aware of. Let''s see what happens when we call a function
    like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It turns out that multiplying `bananas` by `2` doesn''t make any sense: JavaScript
    cannot coerce the result to a numerical value, and therefore it results in a value
    of `NaN`.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what does this mean for our function? To answer that question, we need to
    establish what data type the `NaN` property is. You'd be forgiven for assuming
    that running `typeof` `NaN` would return something – anything – other than `number`,
    but you'd be wrong. As we saw in the previous chapter, `NaN` is a property of
    the `Number` object and is indeed of the `number` type. This results in yet another
    stack overflow, with the function logging `NaN` repeatedly until the maximum call
    stack size is reached.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A similar problem would also occur when calling the function with Infinity,
    so it''s clear that we need to add another check in our `isFinite()` function
    that returns true if its input is a finite and legal number to handle these edge
    cases:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This function is used so that we can remove the `typeof` operator check. Now,
    we have a fairly robust set of termination cases for this function. There may
    still be other checks we would want to implement, such as limiting the size of
    the number that the function will count down from. For example, if we wanted to
    make sure the input is less than `10,000`, we could amend our `if` statement to
    the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Outputs from various inputs to countdownByTwo()'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_07_13.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Outputs from various inputs to countdownByTwo()'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we've seen a basic example of how we may inadvertently write
    code that works poorly with the JavaScript engine, and that we should handle as
    many different edge cases that our code may be presented with as possible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we've looked at the JavaScript runtime, what it is conceptually,
    and the processes and components it comprises. We've looked at the JavaScript
    engine in detail – particularly the V8 implementation – and how its call stack
    and memory heap interact with the other elements of the runtime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at a common call stack error that developers face, and at
    the ways, we can ensure our code doesn't reach the maximum call stack size.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一种常见的调用栈错误，以及确保我们的代码不会达到最大调用栈大小的办法。
- en: Memory Management
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: We'll now move our attention to another core aspect of a computer's hardware
    – its memory. Memory management is an important, but often overlooked, aspect
    of developing software in JavaScript. Memory management simply refers to the allocation,
    use, and deallocation of system memory for the various data structures that make
    up our programs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向计算机硬件的另一个核心方面——它的内存。内存管理是JavaScript中软件开发的一个重要但常常被忽视的方面。内存管理简单来说就是为构成我们程序的各个数据结构分配、使用和释放系统内存。
- en: 'There are two main approaches that are used by different programming languages
    to handle memory management: **explicit allocation and deallocation** and **automatic
    allocation and deallocation**. When writing software in an explicit memory management
    language, such as C-like languages, it''s the software developer''s job to tell
    the compiler when to allocate memory and how much to allocate to the software
    at any given stage. The developer also has to decide when that memory is no longer
    needed and explicitly tell the compiler to deallocate it. This increases the workload
    for the developer and can lead to frustrating bugs being introduced.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言在处理内存管理时采用两种主要方法：**显式分配和释放**以及**自动分配和释放**。当用像C语言这样的显式内存管理语言编写软件时，软件开发者的任务是告诉编译器何时分配内存以及在任何给定阶段为软件分配多少内存。开发者还必须决定何时该内存不再需要，并明确告诉编译器释放它。这增加了开发者的工作量，并可能导致令人沮丧的错误被引入。
- en: 'Automatic memory management, on the other hand, removes the need for developers
    to explicitly allocate and deallocate memory, which, for the most part, makes
    the developer''s job easier. The compiler requests memory from the operating system
    in two main stages: static allocation at compilation time and dynamic allocation
    at runtime. Modern JavaScript engines use **Just-in-Time compilation**, which
    makes use of more than one compiler – a baseline compiler – and one or more optimization
    compilers, which recompile and cache parts of the code so that it''s more efficient.
    This forms a continuous loop of compilation, optimization, and decompilation/recompilation.
    The result of this is that JavaScript code is compiled and recompiled continuously
    at runtime, somewhat blurring the static and dynamic memory allocation stages.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 自动内存管理另一方面消除了开发者显式分配和释放内存的需求，这在很大程度上使得开发者的工作变得更简单。编译器在两个主要阶段从操作系统请求内存：编译时的静态分配和运行时的动态分配。现代JavaScript引擎使用**即时编译**，它利用了不止一个编译器——一个基线编译器——和一个或多个优化编译器，这些编译器重新编译并缓存代码的部分，使其更高效。这形成了一个编译、优化和反编译/重新编译的连续循环。结果是JavaScript代码在运行时持续编译和重新编译，这在一定程度上模糊了静态和动态内存分配阶段。
- en: 'The memory allocation step is basically straightforward: the JavaScript engine
    identifies the amount of memory it needs and requests it from the operating system.
    Memory is then read from and written to as required by the program. The final
    stage of memory management, that is, deallocation, is the stage we need to focus
    on here.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配步骤基本上是直接的：JavaScript 引擎确定它需要的内存量，并从操作系统请求它。然后根据程序的需求读取和写入内存。内存管理的最后阶段，即释放，是我们需要在此处关注的。
- en: The Garbage Collector
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收器
- en: 'JavaScript engines have an additional application called a garbage collector,
    which deals with the automatic deallocation of memory at runtime. The garbage
    collector uses a process called mark-and-sweep to identify objects that are no
    longer needed and remove them from memory. It does this by starting at a root
    object – for example, the global window object – and traversing each object that
    is referenced by the root. It then checks all child and grandchild objects referenced
    by those objects, and thus maps out all the objects that are reachable from the
    root. Anything that is cut off from this map, thus being unreachable by the root
    object, is marked for deletion and subsequently removed from memory:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎有一个额外的应用称为垃圾收集器，它处理运行时的内存自动释放。垃圾收集器使用一个称为标记-清除的过程来识别不再需要的对象并将它们从内存中移除。它是通过从一个根对象开始——例如，全局的window对象——遍历由根引用的每个对象来完成的。然后它检查那些对象引用的所有子对象和孙对象，从而绘制出从根可访问的所有对象。任何从这个图中断开连接的，因此无法由根对象访问的，都会被标记为删除，并随后从内存中移除：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look at the following diagram:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 7.14: References between objects'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：对象之间的引用'
- en: '](img/C14377_07_14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_14.jpg)'
- en: 'Figure 7.14: References between objects'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：对象之间的引用
- en: In this simple case, the root object has a reference to the `cat` object, and
    the `cat` object has a reference to its `name` property, which is a string with
    the `Professor Meow` value. The garbage collector will see these references and
    will mark the `cat` object and its `name` property as reachable, and they will
    not be collected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，根对象有一个对`cat`对象的引用，而`cat`对象有一个对其`name`属性的引用，该属性是一个值为`Professor Meow`的字符串。垃圾收集器将看到这些引用，并将`cat`对象及其`name`属性标记为可访问的，它们不会被收集。
- en: 'If we now reassign `cat` to `null`, we will have removed the reference chain
    between the root object and the `name` property of `cat`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将`cat`重新赋值为`null`，我们将移除根对象和`cat`的`name`属性之间的引用链：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look at the following diagram:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 7.15: The reference is lost, and the memory is freed'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15：引用丢失，内存释放'
- en: '](img/C14377_07_15.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_15.jpg)'
- en: 'Figure 7.15: The reference is lost, and the memory is freed'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：引用丢失，内存释放
- en: The `cat` object remains property of the global object, with a value of `null`,
    but any properties of `cat` that are not also referenced by another object linked
    to the root are removed from memory by the garbage collector.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`对象仍然是全局对象的属性，值为`null`，但任何不是由另一个链接到根对象的`cat`属性引用的`cat`属性都将被垃圾收集器从内存中移除。'
- en: 'We can expand on this example to show how referencing an object from more than
    one other object can preserve its place in memory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这个例子来展示从多个其他对象引用一个对象如何保留其在内存中的位置：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 7.16: Multiple references to the same object'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16：同一对象的多个引用'
- en: '](img/C14377_07_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_07_16.jpg)'
- en: 'Figure 7.16: Multiple references to the same object'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：同一对象的多个引用
- en: The `cat`, `dog`, and `mammal` objects are all properties of the global object
    (the `root`, in garbage collector speak), and the `cat` and `dog` objects reference
    the `mammal` object through their **class** property.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`、`dog`和`mammal`对象都是全局对象（在垃圾收集器中称为`root`）的属性，`cat`和`dog`对象通过它们的**类**属性引用`mammal`对象。'
- en: If we now reassign the `mammal` object to `null`, and once again the `cat` object
    to `null`, the reference from the `global` object to the `mammal` object via the
    `cat` object will be broken, as will its direct reference. However, since we have
    another reference to the `mammal` object via the `dog` object, the `mammal` object
    is still 'reachable" from the `global` object and is not collected by the garbage
    collector.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将`mammal`对象重新赋值为`null`，然后再将`cat`对象重新赋值为`null`，那么通过`cat`对象从`global`对象到`mammal`对象的引用以及它的直接引用都将被断开。然而，由于我们通过`dog`对象对`mammal`对象还有另一个引用，`mammal`对象仍然可以从`global`对象访问，并且不会被垃圾收集器收集。
- en: You can see that, by inadvertently maintaining object references, you can make
    a program take up more memory than it needs. This is especially troubling for
    large datasets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，通过无意中保持对象引用，程序可能会占用比所需更多的内存。这对于大数据集来说尤其令人烦恼。
- en: Memory Leaks
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: 'Garbage collection is a handy process for us developers since it reduces the
    workload that comes with manually managing memory. But it''s a double-edged sword;
    garbage collection happens automatically – we have no way of triggering the garbage
    collection process, nor do we know when the JavaScript engine will decide to do
    a garbage collection run – so it''s easy for us to forget all about the potential
    pitfalls of memory management. But garbage collection is not a perfect process,
    or at least it doesn''t always behave as we may expect it to. It will often fail
    to free up memory which, in actuality, is no longer needed. This is not a bug
    or mistake in the garbage collection process, it''s just a symptom of a problem:
    the question of whether an object will be needed again later on during execution
    can only be answered with certainty by the developer.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收对我们开发者来说是一个方便的过程，因为它减少了手动管理内存的工作量。但它是一把双刃剑；垃圾回收是自动发生的——我们无法触发垃圾回收过程，也不知道JavaScript引擎何时会决定进行垃圾回收运行——因此我们很容易忘记内存管理的潜在陷阱。但是垃圾回收并不是一个完美的过程，或者至少它并不总是按我们可能期望的方式运行。它通常会失败，无法释放实际上不再需要的内存。这不是垃圾回收过程中的错误或错误，这只是问题的一个症状：在执行过程中，一个对象是否会被再次需要的确定性只能由开发者来回答。
- en: When a piece of memory is allocated but maintains a link to the root object,
    even after it's no longer needed in the program, it will never be freed and will
    remain allocated, thereby taking up system memory until the software's execution
    ends. This is a memory leak, and it's not hard to imagine that they can become
    big issues with large objects, or frequent reoccurrences. It's not always obvious
    when our application is suffering from a memory leak, especially if we're developing
    our applications on a powerful machine, so it's important to avoid the common
    mistakes and to keep an eye on our application's memory usage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当一块内存被分配但保持对根对象的链接，即使在程序中不再需要时，它也永远不会被释放，并且将保持分配状态，从而占用系统内存，直到软件执行结束。这是一个内存泄漏，不难想象它们可以成为大问题，或者频繁发生。当我们在功能强大的机器上开发应用程序时，我们可能不会明显地发现我们的应用程序正在遭受内存泄漏，因此避免常见的错误并密切关注应用程序的内存使用情况是很重要的。
- en: Let's look at a few common memory leak scenarios and look at how we can avoid
    them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的内存泄漏场景，并看看我们如何避免它们。
- en: Event Listeners
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件监听器
- en: 'One of the most common ways in which memory leaks occur comes from event listeners.
    Consider the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏最常见的方式之一来自事件监听器。考虑以下代码：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s quite common to see event listeners being added with an anonymous callback
    function, and it will work as expected (as long as there is an element with an
    ID of `scrollable`). However, by using an anonymous function, we are unable to
    remove the event listener at a later date should we need to, meaning that once
    this event listener is added, it will remain in place for the entirety of the
    program''s execution, and, depending on the function, could be adding objects
    to memory every time it''s called. To tackle this, let''s declare a named function
    and then pass that function to the event listener:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件监听器中使用匿名回调函数是很常见的，并且它会按预期工作（只要有一个ID为`scrollable`的元素）。然而，通过使用匿名函数，我们无法在稍后需要时移除事件监听器，这意味着一旦添加了这个事件监听器，它将在整个程序执行期间保持原位，并且根据函数的不同，每次调用都可能向内存中添加对象。为了解决这个问题，让我们声明一个命名函数，然后将该函数传递给事件监听器：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have the handler function instead of an anonymous function, we
    can make use of the `removeEventListener` method if we want to remove the event
    listener later on in our program:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理函数而不是匿名函数，如果我们想在程序中稍后移除事件监听器，我们可以使用`removeEventListener`方法：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Detached DOM Nodes
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离的DOM节点
- en: Any reference to a DOM node that's made by JavaScript will prevent that node's
    memory allocation from being freed, even if the node is subsequently removed from
    the DOM.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对DOM节点所做的任何引用都将阻止该节点的内存分配被释放，即使该节点随后被从DOM中移除。
- en: 'For example, let''s say we have an array of image sources that we want to add
    to the DOM. It would make sense to store the parent DOM node in a variable and
    add the images via this variable reference:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个想要添加到DOM中的图像源数组。将父DOM节点存储在一个变量中并通过这个变量引用添加图像是有意义的：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, now, we have all of the images attached to the DOM, but we have also created
    an additional reference to the image parent element; there is one reference in
    the DOM tree, and one via the JavaScript variable, that is, `imageParent`. Let''s
    say that, later on in the program, we need to remove the image parent element:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们已经将所有附加到DOM上的图像都处理完毕，但我们还创建了对图像父元素的额外引用；在DOM树中有一个引用，通过JavaScript变量，即`imageParent`。假设在程序稍后我们需要删除图像父元素：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This would remove the DOM node with the ID of `image-wrapper` from the DOM tree,
    but the variable, along with all its appended child `img` elements, is still referenced
    by the `imageParent` variable, and will still occupy memory, never to be collected
    by the garbage collector.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除具有ID为`image-wrapper`的DOM节点，但变量及其所有附加的子`img`元素仍然被`imageParent`变量引用，并且仍然会占用内存，永远不会被垃圾回收器收集。
- en: The simple solution in this situation is to reassign the `imageParent` variable
    an `undefined` value after removing `imageParent` from the DOM.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，简单的解决方案是在从DOM中删除`imageParent`之后，将`imageParent`变量重新赋值为`undefined`。
- en: Global Variables
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: Since the mark-and-sweep algorithm looks for all the references connected to
    the roots of the memory object graph, any variables of the global object (the
    `window` object, in browser-based JavaScript, or the `global` object, in Node.js),
    will always be referenced and will therefore never be collected by the garbage
    collector.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标记-清除算法会寻找与内存对象图根节点相关联的所有引用，因此全局对象的任何变量（在基于浏览器的JavaScript中是`window`对象，在Node.js中是`global`对象），都将始终被引用，因此永远不会被垃圾回收器收集。
- en: It's good practice to avoid declaring variables on the global object wherever
    possible, in other words, don't pollute the global namespace. There are a few
    good reasons for avoiding this, one of which is to avoid the resulting memory
    leaks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免在全局对象上声明变量是一种良好的实践，换句话说，不要污染全局命名空间。避免这样做有几个很好的理由，其中之一是避免由此产生的内存泄漏。
- en: 'It''s fairly obvious when variables are explicitly declared on the global object,
    but there are a couple of situations that can lead to unexpected global variables:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量在全局对象上显式声明时，这通常是相当明显的，但有一些情况可能导致意外的全局变量：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function creates an undeclared variable called `cat` that will implicitly
    be a property of the `global` object, even though it was created inside the function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个未声明的变量`cat`，它将隐式地成为`global`对象的一个属性，即使它是在函数内部创建的：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Likewise, using the `this` keyword will create a global variable. You can declare
    a variable with `var`, `let`, or `const` inside a function, and it will have a
    function-level scope of that function, instead of having global scope, like it
    would with an undeclared variable. It's also a good idea to use the `use strict`
    statement at the top of your JavaScript files, which will result in an error being
    thrown if you try to create an undeclared variable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用`this`关键字将创建一个全局变量。你可以在函数内部使用`var`、`let`或`const`声明一个变量，它将具有该函数的函数级作用域，而不是具有全局作用域，就像未声明的变量那样。在JavaScript文件顶部使用`use
    strict`语句也是一个好主意，这将导致在尝试创建未声明的变量时抛出错误。
- en: Identifying Memory Leaks
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别内存泄漏
- en: Despite our best efforts, memory leaks can creep into our code. They're often
    not obvious because the amount of memory they consume can be small, and they may
    grow relatively slowly, meaning they may not impact an application's performance
    unless they're kept running over many hours or days. And even when you find that
    you have a memory leak, it can be tricky to find the root cause.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尽了最大努力，内存泄漏仍然可能悄悄地进入我们的代码。它们通常并不明显，因为它们消耗的内存量可能很小，它们可能增长相对较慢，这意味着除非它们在许多小时或几天内持续运行，否则它们可能不会影响应用程序的性能。即使当你发现你有内存泄漏时，找到根本原因也可能很棘手。
- en: 'Exercise 7.03: Identifying Memory Leaks'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：识别内存泄漏
- en: Let's take a simple example and see how Chrome's developer tools can help us
    identify that we have a memory leak. Let's get started.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来看看Chrome的开发者工具如何帮助我们识别我们是否有内存泄漏。让我们开始吧。
- en: 'Open a new tab in Chrome, open `Menu` > `More Tools` > `Developer tools`, and
    go to the `Sources` tab:![Figure 7.17: An empty code snippet'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome中打开一个新标签页，打开`菜单` > `更多工具` > `开发者工具`，然后转到`源`标签页：![图7.17：一个空的代码片段
- en: '](img/C14377_07_17.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_07_17.jpg)'
- en: 'Figure 7.17: An empty code snippet'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17：一个空的代码片段
- en: 'Click `''+ New snippet''` at the top left of this window and add the following
    code to set up our memory leak: First of all, we are creating a new DOM element
    of the `div` type and assigning it to a variable called `imageWrappe`r:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口的左上角点击 `'+ New snippet'` 并添加以下代码以设置我们的内存泄漏：首先，我们创建一个新的 `div` 类型的 DOM 元素并将其分配给名为
    `imageWrapper` 的变量：
- en: '[PRE28]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Every modern browser has its own set of developer tools. However, for dealing
    with memory leaks, Chrome's developer tools are the most useful.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个现代浏览器都有自己的开发者工具集。然而，对于处理内存泄漏，Chrome 的开发者工具最为有用。
- en: 'Next, we declare three functions that simulate some user interaction with our
    page. The first function, `loadImages()`, creates 50 new image elements and adds
    a data property to them of a string containing `1,024 b` characters. This is analogous
    to loading images and adding them to `imageWrapper`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明三个函数来模拟一些用户与我们的页面交互。第一个函数 `loadImages()` 创建 50 个新的图像元素，并给它们添加一个包含 `1,024
    b` 字符串的数据属性。这类似于加载图像并将它们添加到 `imageWrapper`：
- en: '[PRE29]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next function, `add()`, simply adds the `imageWrapper` element to the end
    of the document body, and our third function `remove()` will be used to remove
    that image wrapper.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数 `add()` 简单地将 `imageWrapper` 元素添加到文档体的末尾，我们的第三个函数 `remove()` 将用于移除该图像包装器。
- en: '[PRE30]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s write one last function to tie these three together:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写最后一个函数来将这些三个函数结合起来：
- en: '[PRE31]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This last function simulates adding and removing the image wrapper multiple
    times, thus loading 50 new images to it each time. A real-world example may be
    that we have a gallery of images and the user is clicking the ''`next`" button
    to load the next set of images (in our scenario, they''d be clicking it 1,000
    times!). Clearly, this would be a rather poor implementation of such a feature,
    but our aim here is to demonstrate how memory leaks can occur in a simple way.
    Your final code snippet should look something like this:![Figure 7.18: Code snippet
    with all the process() code'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个最后的函数模拟多次添加和移除图像包装器，因此每次添加 50 张新图像。一个现实世界的例子可能是有图像画廊，用户点击“'next'”按钮来加载下一组图像（在我们的场景中，他们会点击它
    1,000 次！）！显然，这将是这样一个功能的相当糟糕的实现，但我们的目的是以简单的方式演示内存泄漏是如何发生的。你的最终代码片段应该看起来像这样：![图
    7.18：包含所有 process() 代码的代码片段
- en: '](img/C14377_07_18.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_07_18.jpg)'
- en: 'Figure 7.18: Code snippet with all the process() code'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.18：包含所有 process() 代码的代码片段
- en: Now, click the `run snippet` button to execute the code.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 `run snippet` 按钮执行代码。
- en: 'Next, we will go to the performance tab of the dev tools and have a look at
    what''s happening in the memory heap as we add and remove our images. From the
    performance tab, click the record button to start recording a performance profile.
    While it''s recording, in the console, call the `process()` function, say, three
    times, and then hit the `stop` button. You should now see a screen that looks
    something like this:![Figure 7.19: Memory heap of the performance tab of the developer
    tools'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转到开发者工具的性能标签页，查看我们在添加和移除图像时内存堆中发生的情况。从性能标签页，点击记录按钮开始记录性能配置文件。在记录过程中，在控制台中调用
    `process()` 函数，比如三次，然后点击停止按钮。你现在应该会看到一个类似这样的屏幕：![图 7.19：开发者工具性能标签页的内存堆
- en: '](img/C14377_07_19.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_07_19.jpg)'
- en: 'Figure 7.19: Memory heap of the performance tab of the developer tools'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19：开发者工具性能标签页的内存堆
- en: This is the performance profile we have just recorded. It can tell us lots of
    information about the system resources that are being used by our application
    over the duration of the recording. The blue line here shows us how much of JavaScript's
    memory heap is being used over time. In an application without memory leaks, we
    would expect the memory usage to repeatedly go up with memory allocation and back
    down again to a base level with memory deallocation, giving us a `images` we've
    loaded are no longer needed after each call of `process()`, and so they stay in
    the memory heap. If you notice a real-life application becoming less performant
    over time, or using higher than expected system resources, then this is a good
    place to come to check for a memory leak.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们刚刚记录的性能配置文件。它可以告诉我们关于我们的应用程序在记录期间使用的系统资源的许多信息。这里蓝色的线条显示了 JavaScript 内存堆随时间使用的情况。在一个没有内存泄漏的应用程序中，我们期望内存使用量随着内存分配而反复上升，并在内存释放后回到一个基本水平，给我们一个
    `images`，我们在每次调用 `process()` 后不再需要的图像，因此它们留在内存堆中。如果你注意到一个实际的应用程序随着时间的推移性能下降，或者使用高于预期的系统资源，那么这是一个检查内存泄漏的好地方。
- en: 'Exercise 7.04: Fixing the Memory Leak'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.04：修复内存泄漏
- en: 'Now that we''ve established that we have a memory leak – as shown by the JavaScript
    memory heap graph in the preceding screenshot – our next task is to fix our code
    so that it no longer contains the leak. Given what you know of the garbage collector
    and the reason for our leak, try to implement a fix for the previous code so that
    the garbage collector can see when our objects are no longer needed. After each
    function call, record a performance profile to see whether the garbage collector
    is able to free up the memory. What you''re looking for is that the blue heap-memory
    allocation line goes up with memory allocation, but then comes back down again
    at regular intervals, showing that the memory is being deallocated. This is a
    sign of a garbage collector being able to deallocate the memory after each execution
    of the `process()` function. Let''s get started:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定存在内存泄漏——如前一个屏幕截图中的JavaScript内存堆图所示——我们的下一个任务是修复我们的代码，使其不再包含泄漏。根据你对垃圾回收器和泄漏原因的了解，尝试对之前的代码进行修复，以便垃圾回收器可以看到我们的对象何时不再需要。在每次函数调用后，记录一个性能分析，以查看垃圾回收器是否能够释放内存。你所寻找的是蓝色堆内存分配线随着内存分配而上升，但随后在规律的时间间隔内再次下降，表明内存正在被释放。这是垃圾回收器能够在每次`process()`函数执行后释放内存的迹象。让我们开始吧：
- en: 'Write a function and add it to the existing three functions that are called
    in the `process`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数并将其添加到在`process`中调用的现有三个函数：
- en: '[PRE32]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we've added one more function that is called `resetImageWrapper()`, which
    resets the `imageWrapper` object to an empty `div` element and added the function
    to our `process()` function's `for…loop`. Now, each time a set of images is removed
    from the DOM, its reference in JavaScript is also removed, and it can be marked
    by the garbage collector for deletion.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`resetImageWrapper()`的函数，该函数将`imageWrapper`对象重置为空的`div`元素，并将其添加到`process()`函数的`for…loop`中。现在，每次从DOM中移除一组图像时，其JavaScript中的引用也会被移除，并且可以被垃圾回收器标记为删除。
- en: 'The next step is to call this new function each time we process our images,
    so we will add it to our main `process()` function:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在每次处理我们的图像时调用这个新函数，因此我们将它添加到我们的主`process()`函数中：
- en: '[PRE33]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once again, we''ll run the performance profiler. Go to the dev tools, then
    to the `Performance` tab, and click the record button to begin a performance profile
    recording. Then, call the `process()` function a few times and take a look at
    the memory heap usage:![Figure 7.20: Memory heap usage'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将运行性能分析器。前往开发者工具，然后点击“性能”标签页，并点击记录按钮开始性能分析记录。然后，多次调用`process()`函数，并查看内存堆的使用情况：![图7.20：内存堆使用情况
- en: '](img/C14377_07_20.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_07_20.jpg)'
- en: 'Figure 7.20: Memory heap usage'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：内存堆使用情况
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you probably noticed, the problem with our code was that we were storing
    references to each image element, and, therefore, the contents of its data attribute,
    inside the `imageWrapper` variable. The simple solution to this problem is to
    reassign the `imageWrapper` variable each time we remove it from the DOM.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许注意到的，我们代码的问题是我们将每个图像元素的引用及其数据属性的值存储在`imageWrapper`变量中。解决这个问题的一个简单方法是在每次从DOM中移除它时重新分配`imageWrapper`变量。
- en: This is a much healthier memory heap profile. After each of the three `process()`
    function calls, the garbage collector could see that the images were no longer
    referenced by either the DOM or by JavaScript, and the space they were allocated
    in memory was freed up and given back to the memory pool.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更健康的内存堆分析图。在每次三个`process()`函数调用之后，垃圾回收器可以看到图像不再被DOM或JavaScript引用，它们在内存中分配的空间被释放并归还给内存池。
- en: In this section, we've covered the two main techniques for dealing with memory
    management in different programming languages – manual and automatic – and looked
    at the browser's garbage collector processes. We then looked at the major con
    of automatic memory management and modern browsers' garbage collection algorithms,
    namely memory leaks, in more detail. Finally, we had an overview of one of the
    techniques we can use to identify when our application has such a leak.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了处理不同编程语言中内存管理的两种主要技术——手动和自动——并探讨了浏览器的垃圾回收器过程。然后，我们更详细地讨论了自动内存管理的重大缺点和现代浏览器的垃圾收集算法，即内存泄漏。最后，我们概述了我们可以用来识别我们的应用程序何时出现此类泄漏的技术之一。
- en: 'Activity 7.01: Finding out the Number of Stack Frames'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：找出堆栈帧的数量
- en: Earlier in this chapter, we learned about JavaScript's call stack and saw that
    it's possible to generate an error if too many stack frames are added to the stack.
    Each implementation of a JavaScript engine can have a different limit regarding
    the size of the stack. In this activity, we'll write a function that will tell
    us when the maximum number of stack frames has been reached in the stack before
    the stack overflow error is triggered.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们学习了 JavaScript 的调用栈，并了解到如果向栈中添加过多的栈帧，则可能会生成错误。JavaScript 引擎的每个实现都可以有不同的栈大小限制。在这个活动中，我们将编写一个函数，它将告诉我们何时在触发栈溢出错误之前栈中达到最大数量的栈帧。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的概述步骤如下：
- en: Add a function that calls itself repeatedly, causing the stack overflow.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，该函数会反复调用自身，导致栈溢出。
- en: Keep count of the number of times the function calls itself. (This is like counting
    the number of stack frames getting pushed to the call stack.)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数函数自我调用的次数。（这就像计算推送到调用栈的栈帧数量。）
- en: Display the final number after the stack overflow error has occurred. Remember
    that no new functions can be called after a stack overflow error!
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在栈溢出错误发生后显示最终数字。记住，在栈溢出错误之后不能调用任何新函数！
- en: 'The output of this activity will be as follows:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的输出将如下所示：
- en: '![Figure 7.21: Showing the number of stack frames pushed before a stack overflow
    was triggered'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.21：显示在触发栈溢出之前推送到栈中的栈帧数量'
- en: '](img/C14377_07_21.jpg)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_07_21.jpg)'
- en: 'Figure 7.21: Showing the number of stack frames pushed before a stack overflow
    was triggered'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21：显示在触发栈溢出之前推送到栈中的栈帧数量
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 731.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 731 页找到。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have seen how the blocks of code many people think of as
    just ''JavaScript" can actually be broken down into separate components: the JavaScript
    engine, consisting of the call stack, memory heap, and the garbage collector (as
    well as other important components not covered by this chapter); and the JavaScript
    runtime environment, such as a browser, or Node.js, which contains the JavaScript
    engine, and gives the engine access to additional functions and interfaces, such
    as `setTimeout()` or a filesystem interface.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了许多人认为只是“JavaScript”的代码块实际上可以被分解成单独的组件：JavaScript 引擎，包括调用栈、内存堆和垃圾回收器（以及本章未涵盖的其他重要组件）；以及
    JavaScript 运行时环境，如浏览器或 Node.js，它包含 JavaScript 引擎，并为引擎提供访问额外的函数和接口，例如 `setTimeout()`
    或文件系统接口。
- en: We also looked at how JavaScript manages memory allocation and deallocation,
    and how even though it is managed automatically, it's important for developers
    to bear the processes involved in mind in order to write code that enables the
    garbage collector to work correctly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 JavaScript 如何管理内存分配和释放，尽管它是自动管理的，但开发者仍然需要记住涉及的过程，以便编写能够使垃圾回收器正确工作的代码。
- en: In the next chapter, we will look at different aspects of the environment API
    in more detail so that we can learn about some of the less commonly used features
    we can find in the browser and in Node.js.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨环境 API 的不同方面，以便我们可以了解在浏览器和 Node.js 中可以找到的一些不太常用的功能。
