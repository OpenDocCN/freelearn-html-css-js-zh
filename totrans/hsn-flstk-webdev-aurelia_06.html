<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Storing Our Data in MongoDB</h1>
                </header>
            
            <article>
                
<p>All the applications that you use on a daily basis store their information in databases. Databases allow you to provide the best experience to your users. Just imagine how hard it might be for your users without a database. For example, imagine you have bought a new iPhone and need to have all your contacts from your Instagram account added to your new phone. If databases did not exist, you would need to copy all of your contact information and add it locally to your new device. This may sound ridiculous, but this is how a world without databases might be.</p>
<p>It is important to learn how to create applications that are able to connect and store information into a database. So, now you will learn how to use MongoDB as your NoSQL database and how to integrate our backend with it using one of the most popular libraries called Mongoose.js.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>NoSQL databases</li>
<li>Introducing MongoDB</li>
<li>MongooseJS</li>
<li>Integrating our API with MongoDB</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NoSQL databases</h1>
                </header>
            
            <article>
                
<p>Big companies around the globe are using NoSQL Databases to provide the velocity that the users expect when using their <span>applications; companies</span> such as Facebook, Amazon, and Google all use them. However, why are these databases so special? To answer this question, let's see what is the difference between SQL and NoSQL databases:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>SQL databases</strong></td>
<td><strong>NoSQL databases</strong></td>
</tr>
<tr>
<td>Table-based and hard structured</td>
<td>Not table-based</td>
</tr>
<tr>
<td>Encourage normalization</td>
<td>Encourage denormalization</td>
</tr>
<tr>
<td>Require a schema</td>
<td>Are schema-less</td>
</tr>
<tr>
<td>Fast</td>
<td>Superfast</td>
</tr>
<tr>
<td>Scalability is difficult to achieve</td>
<td>Scalability is extremely easy to achieve</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Of course, there are more differences and benefits, but talking about all the advantages and the science behind them is beyond the scope of this book.</p>
<p>It is important to know that there are different types of NoSQL databases to solve different types of challenges. Let's learn about them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Document databases</h1>
                </header>
            
            <article>
                
<p>This is one of the most popular databases, thanks to MongoDB and CouchDB. This type of database stores the information in a JSON-based document. As this is a key-value store, you can save complex objects that contain arrays, nested documents, and other different data types. For example, you can save the following <em>person</em> in the JSON document:</p>
<pre>{<br/>  "identification" : "PE0022458197",<br/>  "name": {<br/>    "firstName": "Jack",<br/>    "LastName": "Ma"<br/>  },<br/>  "age": 45,<br/>  "addresses": [ <br/>    {"country": "Peru", "address": "MyTown PE#32"},<br/>    {"country": "China", "address": "OtherTown CH#44"}<br/>  ]<br/>  ...<br/>}</pre>
<p>As you can see, you don't need to store the addresses in a different document (or a table in SQL databases); you can perfectly store them in the same document (or a table in SQL databases).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing MongoDB</h1>
                </header>
            
            <article>
                
<p>As stated on its official website, MongoDB is an open source document database with the scalability and flexibility that you want and the querying and indexing that you need.</p>
<p>MongoDB uses collections to persist a set of JSON documents, and the schema for the documents can change over time without affecting the other documents stored in the collection. The schema-less feature is great when you are working on applications that have different kind of roles and users. A user might utilize some fields, while other users might require some other fields but without the need to fill the unused fields with null values. Instead, fields that are not required are not persisted in the JSON document.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing MongoDB</h1>
                </header>
            
            <article>
                
<p>You can learn how to install MongoDB on its official site at <a href="https://www.mongodb.com">https://www.mongodb.com</a>. We strongly recommend you to use Docker for your development environment instead of installing MongoDB on your local machine. So, let's see how you can install MongoDB using Docker containers.</p>
<p>First, you will need to download Docker from its official site, <a href="https://www.docker.com">https://www.docker.com</a>. Once the download is completed, go ahead and install it. If you are working on MacOS or Windows, <span>Docker will also install another tool called</span> <strong>Kitematic</strong>. <span>When the installation is done, look for</span> <span class="packt_screen">mongo</span> <span>in the <span class="packt_screen">C</span><span class="packt_screen">ontainers</span></span> section. <span>Then, hit</span> <span class="packt_screen">CREATE</span>. Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c999c7a-6285-41ed-866a-d4a4a7b593cc.png"/></div>
<p>The tool will download the image and once it is done, it will run the MongoDB container and provide us the host and port where MongoDB is running, as illustrated:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d3aa4e49-68c3-415c-bdf9-f67934799bc3.png"/></div>
<p>For users who are using Linux, execute the following command to create a MongoDB container:</p>
<pre><strong>&gt; docker run -p 27017:27017 -v $(pwd)/data:data/db mongo</strong></pre>
<p>The previous command will start a new container and exposes its internal port <kbd>27017</kbd> and will share a directory called <kbd>data</kbd> from your host to the container. By doing this, we can persist the container information into our host file system.</p>
<p>Once we have our MongoDB database running on top of Docker, we need to practice a little bit with MongoDB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD operations</h1>
                </header>
            
            <article>
                
<p>Before we integrate our API with MongoDB, it is important to learn how to interact with MongoDB directly. So, let's learn how to perform the basic CRUD operations using the MongoDB command-line tool. To do this, we will need to access the MongoDB container Terminal, but it is extremely easy using Kitematic. In the container's toolbar, click on the <span class="packt_screen">exec</span> options. This will launch a Terminal window connected to the MongoDB container Terminal.</p>
<p>When it is launched, type <kbd>mongo</kbd> to get into the MongoDB CLI. <span>Take a look at the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a79c1485-e01e-4ef5-a775-46e001de3ee1.png" style="width:34.50em;height:26.75em;"/></div>
<p>For users who are using Linux. You can get into the container by running the following command:</p>
<pre><strong>$ docker exec -it mongo sh</strong></pre>
<p>Cool! Now we are ready to play with MongoDB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a document</h1>
                </header>
            
            <article>
                
<p>To insert a document, first we specify the <kbd>collection</kbd> name and pass the JSON document by calling the <kbd>insert</kbd> method as the following syntax:</p>
<pre>&gt; db.collection_name.insert(JSON_Object)</pre>
<p>Let's insert the first team to our <kbd>teams</kbd> collection:</p>
<pre>&gt; db.<strong>teams.insert</strong>({"code": "PER", <br/>  ... "name": "Peru", <br/>  ... "ranking": 11, <br/>  ... "captain": "Paolo Guerreo", <br/>  ... "Trainer": "Ricardo Gareca", <br/>  ... "confederation": "Conmebol"})<br/><br/>WriteResult({ "nInserted" : 1 })<br/>        </pre>
<div class="packt_tip">The three dots at the beginning of the lines refer to new lines or the <em>Enter</em> key.</div>
<p>If the insertion was executed correctly, you should receive the <kbd>writeResult</kbd> response that contains the number of documents inserted into its <kbd>nInserted</kbd> property.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving documents</h1>
                </header>
            
            <article>
                
<p>To retrieve the list of documents, we use the <kbd>find</kbd> method. For example, run the following query to retrieve the full list of teams:</p>
<pre>&gt; db.teams.<strong>find</strong>()<br/><br/><strong>{ "_id" : ObjectId("5a5cf1419afc8af268b9bb21"), "code" : "PER", "name" : "Peru", "ranking" : 11, "captain" : "Paolo Guerreo", "Trainer" : "Ricardo Gareca", "confederation" : "Conmebol" }</strong></pre>
<p>As you can see, a new <kbd>_id</kbd> property has been added automatically. This property is known as the primary key of the JSON document. This is an autogenerated value, so you will have a different value when you run the command.</p>
<p>The teams' collection over time will have more than just a single team. So, how could we retrieve a single team from the collection? Do you remember the <kbd>{}</kbd> JSON object we passed to the <kbd>find</kbd> method? This JSON object is used to query the collection. So, if we want to retrieve the <kbd>Peru</kbd> team, we have to execute the following query:</p>
<pre>&gt; db.teams.find(<strong>{"code": "PER"}</strong>)<br/><br/><strong>{ "_id" : ObjectId("5a5cf1419afc8af268b9bb21"), "code" : "PER", "name" : "Peru", "ranking" : 11, "captain" : "Paolo Guerreo", "Trainer" : "Ricardo Gareca", "confederation" : "Conmebol" }</strong></pre>
<p>Note that we can pass any field used in the JSON document. For example, you can use <kbd>name</kbd>, <kbd>ranking</kbd>, <kbd>captain</kbd>, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating documents</h1>
                </header>
            
            <article>
                
<p>To update a document, we use the <kbd>updateOne</kbd> or <kbd>updateMany</kbd> methods. For example, let's update the <kbd>ranking</kbd> property of the <kbd>Peru</kbd> team. Execute the following code:</p>
<pre>&gt; db.teams.<strong>updateOne</strong>({"code": "PER"}, {<strong>$set</strong>: {"ranking": 1}})<br/><br/><strong>{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }</strong></pre>
<p>The syntax looks a little weird, but it is not. The first question you might have is why do we need <kbd>$set</kbd>? We need <kbd>$set</kbd> to specify the fields that we are interested to update. Otherwise, you will replace the document. Consider this example:</p>
<p>First, let's list our teams' collection to see the first update reflected:</p>
<pre>&gt; db.teams.find(<strong>{"code": "PER"}</strong>)<br/><br/><strong>{ "_id" : ObjectId("5a5cf1419afc8af268b9bb21"), "code" : "PER", "name" : "Peru", "ranking" : 1, "captain" : "Paolo Guerreo", "Trainer" : "Ricardo Gareca", "confederation" : "Conmebol" }</strong></pre>
<p>Also, yes, the <kbd>ranking</kbd> field has been updated to <kbd>1</kbd>. Now let's try to update this document without the <kbd>$set</kbd> operator:</p>
<pre>&gt; db.teams.updateOne({"code": "PER"}, <strong>{"ranking": 1}</strong>)<br/><br/><strong>[thread1] Error: the update operation document must contain atomic operators :</strong></pre>
<p>Note that an error is thrown and no changes have been made. That is helpful for us because we are using the <kbd>updateOne</kbd> method, but there is another method called <kbd>update</kbd>, which will give us headaches if we don't use it properly. For example, run the following code:</p>
<pre>&gt; db.teams.<strong>update</strong>({"code": "PER"}, {"ranking": 1})<br/><br/><strong>WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })</strong></pre>
<p>At this moment, when you note that you forgot the <kbd>$set</kbd> operator, you have lost your team's data. Try to find the <kbd>Peru</kbd> team:</p>
<pre>&gt; db.teams.<strong>find</strong>({"code": "PER"})</pre>
<p>No results are shown. Now a tear might be rolling down your cheek. Funny, right?</p>
<p>Be careful when you are updating or deleting documents. A production error of this type can cost you the post.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting documents</h1>
                </header>
            
            <article>
                
<p>Lastly, to delete a document, we use the <kbd>deleteOne</kbd> or <kbd>deleteMany</kbd> methods. For example, again <span>insert</span> the <kbd>Peru</kbd> team and run the following code:</p>
<pre>&gt; db.teams.<strong>deleteOne</strong>({"code": "PER"})<br/><br/><strong>{ "acknowledged" : true, "deletedCount" : 1 }</strong></pre>
<p>Cool! Now we are in a good shape to learn about Mongoose and how to integrate our API with MongoDB. Keep reading!!</p>
<div class="packt_infobox">We recommend that you use a GUI tool to explore your MongoDB data. We use <strong>Robo 3T</strong> or Robomongo. You can download it from its official page at <a href="https://robomongo.org">https://robomongo.org</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongooseJS</h1>
                </header>
            
            <article>
                
<p>Mongoose.js is one of the most popular NPM modules to integrate a Node.js application with a MongoDB database. It provides an easy way to model our application data and comes along with different built-in features to validate, cast, and query our database, avoiding boilerplate code.</p>
<p>We will use our MongoDB container that we installed in the previous section. The two pieces of information that we need are the host and port where MongoDB is running. That information is shown in the Kitematic tool in the <kbd>Home/IP &amp; Ports/Access URL</kbd> section. For example, in my case, these are <kbd>localhost</kbd> and <kbd>32768</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/edf8840c-9f0a-4ac1-974c-77ed971705ee.png" style="width:49.42em;height:30.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Mongoose</h1>
                </header>
            
            <article>
                
<p>To install Mongoose, we will use NPM. So, in your Terminal, navigate to the <kbd>wc-backend</kbd> project and run the following command:</p>
<pre><strong>$ npm install --save mongoose</strong></pre>
<p>Once the installation is done, we need to get into the <kbd>src</kbd> folder and create a new folder called <kbd>config</kbd><em>.</em> In the <kbd>config</kbd> folder, now create a new file called <kbd>mongoose-connection.js</kbd><em>:</em></p>
<pre><strong>$ cd src</strong><br/><strong>$ mkdir config</strong><br/><strong>$ touch config/mongoose-connection.js</strong></pre>
<p>Now that we have Mongoose installed and we have created our configuration file, it is time to write some code to establish the connection to MongoDB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Mongoose</h1>
                </header>
            
            <article>
                
<p>This is where the best part starts. So, we will need to create a connection to the <em>database</em>; to do this, open the <kbd>mongoose-connection.js</kbd> file and apply the following changes:</p>
<pre>const mongoose = require('<strong>mongoose</strong>')<br/><br/>mongoose.<strong>connect</strong>('mongodb://<strong>localhost</strong>:<strong>32768</strong>/<strong>wcDb</strong>')<br/><br/>mongoose.Promise = global.Promise<br/><br/>mongoose.connection.<strong>on</strong>('connected', () =&gt; {<br/>  console.log('connection is ready')<br/>})<br/><br/>mongoose.connection.on('error', () =&gt; {<br/>  console.log(err)<br/>})<br/><br/></pre>
<p>First, we import the Mongoose module and host it into the <kbd>mongoose</kbd> constant. Then, we call the <kbd>connect</kbd> function and pass the connection URL using the <em>host</em> and <em>port</em> that points to our MongoDB docker container. Lastly, we tell mongoose that our database name will be <kbd>wcDb</kbd>. If the connection was successful, the <kbd>connected</kbd> event will be called and the <kbd>connection is ready</kbd> message should be printed. Let's test things out; execute the following command:</p>
<pre><strong>$ node src/config/mongoose-connection.js</strong><br/><br/><strong>connection is ready</strong></pre>
<p>Cool! Our Node.js module is able to establish a successful connection with MongoDB using Mongoose. Now we will need to define schemas, models, and collections. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining schemas</h1>
                </header>
            
            <article>
                
<p>To store information in our database we need to create a model, this model is created based on a initial schema definition. This schema definition contains the attributes and datatypes of the information we want to store. Let's define the schema for our collections of teams. In the same <kbd>mongoose-connection.js</kbd> file, add the following code:</p>
<pre>...<br/>const TeamSchema = new <strong>mongoose.Schema</strong>({<br/>  name: String,<br/>  ranking: Number,<br/>  captain: String,<br/>  trainer: String,<br/>  confederation: String<br/>})</pre>
<p>As you can see, defining schemas is straightforward. We use the <kbd>mongoose.Schema</kbd> object and define the fields we want for our schema as a JSON object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data types</h1>
                </header>
            
            <article>
                
<p>As in other database engines, the fields should be defined with a data type. The following are all valid types:</p>
<ul>
<li><kbd>String</kbd></li>
<li><kbd>Date</kbd></li>
<li><kbd>Number</kbd></li>
<li><kbd>Boolean</kbd></li>
<li><kbd>Array</kbd></li>
<li><kbd>ObjectId</kbd></li>
<li><kbd>Buffer</kbd></li>
<li><kbd>Mixed</kbd></li>
</ul>
<p>Perhaps, you are familiar will almost all the data types listed. The <kbd>Mixed</kbd> data type basically allows you to define a field whose value can be of any data type. Personally, we don't recommend the use of this data type because maintaining a <kbd>Mixed</kbd> field can become hard, and you may want to write boilerplate code to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validation</h1>
                </header>
            
            <article>
                
<p>Mongoose comes with several built-in validators. Some validators are present in all data types and some are exclusive for a data type. For example, a <kbd>String</kbd> field will have the <kbd>min</kbd> and <kbd>max</kbd> validators but a <kbd>Boolean</kbd> type will not.</p>
<p class="mce-root">Let's add some validations to our <kbd>Team</kbd> schema. Open the <kbd>mongoose-connection.js</kbd> file and apply the following changes:</p>
<pre>...<br/>const TeamSchema = new mongoose.Schema({<br/>  name: {<br/>    <strong>type</strong>: String,<br/>    <strong>min</strong>: 3,<br/>    <strong>max</strong>: 100,<br/>    <strong>required</strong>: true,<br/>    <strong>unique</strong>: true<br/>  },<br/>  ranking: {<br/>    type: Number,<br/>    min: 1<br/>  },<br/>  captain: {<br/>    type: String,<br/>    required: true<br/>  },<br/>  Trainer: {<br/>    type: String,<br/>    required: true<br/>  },<br/>  confederation: {<br/>    type: String,<br/>    required: true,<br/>    <strong>uppercase</strong>: true<br/>  }<br/>})</pre>
<p>Now, our schema looks more professional and will help us validate the data before it is persisted in MongoDB. Most of the validators are self-explanatory. As you might have noticed, when you want to apply validators, the syntax to declare a field changes a little bit; in this case, a JavaScript object should be passed to define the data type and validators. To find more information about validators, visit <a href="http://mongoosejs.com/docs/validation.html">http://mongoosejs.com/docs/validation.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating models</h1>
                </header>
            
            <article>
                
<p>Now that we have our schema, it is time to tell Mongoose that we want to use that Schema to create new objects in order to send them to MongoDB. To do this, we need to create a model by passing the schema already defined. Open the <kbd>mongoose-connection.js</kbd> file and add the following code:</p>
<pre>...<br/>const <strong>Team</strong> = mongoose.<strong>model</strong>('team', <strong>TeamSchema</strong>)</pre>
<p>Believe it or not, we just need this line to interface our schema to MongoDB. In this line, we tell Mongoose that we want to call our collection as <kbd>team</kbd>. The result of calling <kbd>mongoose.model</kbd> will be an object that is the model; we will use this object to create new instances. The <kbd>Team</kbd> object also contains built-in CRUD methods, so we will use them to create CRUD operations to the database.</p>
<p>To test things out, let's create the <kbd>Peru</kbd> team and save it in our database. In the same file, add the following changes:</p>
<pre>...<br/>const peruTeam = <strong>new Team</strong>({<br/>  name: 'Peru',<br/>  ranking: 11,<br/>  captain: 'Paolo Guerrero',<br/>  Trainer: 'Ricardo Gareca',<br/>  confederation: 'Conmebol'<br/>})<br/><br/>peruTeam.<strong>save</strong>((err, data) =&gt; {<br/>  if (err)<br/>    throw err<br/><br/>  console.log("Team was created with the Id", data._id)<br/>})</pre>
<p>First, we create the <kbd>peruTeam</kbd> object using the <kbd>Team</kbd> model instance we created earlier. Each new instance contains built-in functions. The <kbd>save</kbd> built-in function is called to save the <kbd>peruTeam</kbd> in the database. A callback is defined to process the result of the operation. If everything goes right, a message showing the new generated ID will be shown. So, execute the following command to test things out:</p>
<pre><strong>$ node src/config/mongoose-connection.js</strong><br/><br/><strong>connection is ready</strong><br/><strong>Team was created with the Id 5a5f8e5c34a28e049c026ed6</strong></pre>
<p>Cool! Now we are ready to start the integration between our database module and our RESTful API. Keep reading!!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating our API with MongoDB</h1>
                </header>
            
            <article>
                
<p>Here we are! It's time to implement our Teams Rest controller. To do this, we will start decoupling the Team model that has all the logic to communicate with the MongoDB database. Once the Team model is refactored, we will start implementing the code in the Team Rest Controller to implement the CRUD operations to do the following:</p>
<ul>
<li>List all the teams</li>
<li>Create new teams</li>
<li>Update the existing teams</li>
<li>Delete teams</li>
</ul>
<p>Let's get our hands dirty!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoupling the Team Model</h1>
                </header>
            
            <article>
                
<p>We have created a <kbd>models</kbd> folder in the root project directory. In this folder, we will create all the models for our application. Start creating the <kbd>team.js</kbd> file in the <kbd>src</kbd>/<kbd>models</kbd> folders:</p>
<pre><strong>$ touch src/models/team.js</strong></pre>
<p>Remember that we use the <kbd>touch</kbd> command to create a new file. Then, open this file, and from the <kbd>src/config/mongoose-connection.js</kbd> file, cut the following lines and copy them into the <kbd>src/models/team.js</kbd> file, as follows:</p>
<pre>const <strong>mongoose</strong> = require('mongoose')<br/><br/>const <strong>TeamSchema</strong> = new mongoose.Schema({<br/>    name: {<br/>      type: String,<br/>      min: 3,<br/>      max: 100,<br/>      required: true,<br/>      unique: true<br/>    },<br/>    ranking: {<br/>      type: Number,<br/>      min: 1<br/>    },<br/>    captain: {<br/>      type: String,<br/>      required: true<br/>    },<br/>    Trainer: {<br/>      type: String,<br/>      required: true<br/>    },<br/>    confederation: {<br/>      type: String,<br/>      required: true,<br/>      uppercase: true<br/>    }<br/>  })<br/><br/>  <strong>module.exports</strong> = mongoose.model('team', TeamSchema)</pre>
<p>We just need to isolate the <kbd>TeamSchema</kbd> definition, and we are exporting the model created by mongoose to be accessed later by the Rest Controller. Be sure that your <kbd>src/config/mongoose-connection</kbd> file looks like the following:</p>
<pre>const mongoose = require('mongoose')<br/>mongoose.connect('mongodb://localhost:32768/wcDb', { useMongoClient: true })<br/>mongoose.Promise = global.Promise<br/><br/>mongoose.connection.on('connected',() =&gt; {<br/>  console.log('connection is ready')<br/>})<br/><br/>mongoose.connection.on('error', err =&gt; {<br/>  console.log(err)<br/>})</pre>
<p>Cool! So far, so good. Now it is time to implement our Rest Controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Rest Controller</h1>
                </header>
            
            <article>
                
<p>Isolating the business logic is always a good practice; for that reason, we won't be calling the model directly from the Rest Controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting the app</h1>
                </header>
            
            <article>
                
<p>Let's start by calling the <kbd>mongoose-connection</kbd> module to open a connection to MongoDB. Open the <kbd>server.js</kbd> file and apply the following changes:</p>
<pre>const express = require('express')<br/>const bodyParser = require('body-parser')<br/>const teamsApi = require('./src/routes/teams-api')<br/><strong>const mongooseConfig = require('./src/config/mongoose-connection')</strong><br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/>app.use(teamsApi)<br/>...</pre>
<p>That's all we need to establish a new connection. The <kbd>mongoose-connection</kbd> file contains the logic to open a connection to MongoDB, so we don't need to type more code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new team</h1>
                </header>
            
            <article>
                
<p>To create a new team, we need to call the model's built-in methods provided by Mongoose. The <kbd>save</kbd> function is used to create and update the fields for any model. So, first we will start importing the <kbd>Team</kbd> model into the <kbd>src/routes/teams-api.js</kbd> file, as follows:</p>
<div>
<pre>const express = require('express')<br/>const api = express.Router()<br/><strong>const Team = require('../models/team')</strong><br/><br/>let teams = [<br/>    { id: 1, name: "Peru"},<br/>    { id: 2, name: "Russia"}<br/>]<br/>...</pre></div>
<p>Now that we have imported the module with the <kbd>require</kbd> function and stored it into the <kbd>Team</kbd> constant, we can use it to create a new team. Let's modify the <kbd>POST HTTP</kbd> method of the Rest Controller:</p>
<pre>...<br/>api<br/>  .route('/teams')<br/>  .get((req, res) =&gt; {<br/>    res.json(teams)<br/>  })<br/>  .post((req, res, <strong>next</strong>) =&gt; {<br/>    <strong>let team = new Team(req.body)</strong><br/><br/><strong>    team.save()</strong><br/><strong>    .then(data =&gt; res.json(data))</strong><br/><strong>    .catch(err =&gt; next(err) )</strong><br/>  })<br/>...</pre>
<p>The first change to note is the <kbd>next</kbd> param into the function. This param is used to throw an error to express in case Mongoose is not able to create a new team. Then, we create a new team, passing the <kbd>body</kbd> param from the <kbd>req</kbd> object and calling the <kbd>save</kbd> function. The <kbd>save</kbd> function returns a <kbd>Promise</kbd> that is just an asynchronous call, which, when finished successfully, will return the information of the new team saved into the <kbd>then</kbd> method. Once we have the data, we send the information as a <kbd>JSON</kbd> type to the client.</p>
<p>Let's test things out. First, we need to get the server up by executing <kbd>node server.js</kbd> and then we will use cURL to test this endpoint. Open your Terminal and run the following command:</p>
<pre><strong>$ curl -X POST -H 'Content-type: application/json' -d '{"code": "GER", "name": "Germany", "ranking": 8, "captain": "Paolo Guerreo", "Trainer": "Ricardo Gareca", "confederation": "Conmebol"}' http://localhost:3000/teams</strong><br/><br/><strong>{"__v":0,"name":"Germany","ranking":8,"captain":"Paolo Guerreo","Trainer":"Ricardo Gareca","confederation":"CONMEBOL","_id":"5a662fbf728726072c6298fc"}</strong></pre>
<p>If everything went right, you should see the JSON object responding with the autogenerated <kbd>_id</kbd> attribute. Let's see what happens if we run it again:</p>
<pre><strong>$ curl -X POST -H 'Content-type: application/json' -d '{"code": "PER", "name": "Peru", "ranking": 11, "captain": "Paolo Guerreo", "Trainer": "Ricardo Gareca", "confederation": "Conmebol"}' </strong><br/><br/><strong>http://localhost:3000/teams</strong><br/><br/><strong>MongoError: E11000 duplicate key error collection: wcDb.teams index:</strong> name_1 dup key: { :\"Peru\" }<br/>...<br/><br/></pre>
<p>Now we receive an ugly error that says we are falling in a duplication key error. Why is this happening? Let's get answers from the model schema that we defined earlier. Open the <kbd>src/models/team.js</kbd> file:</p>
<pre>const mongoose = require('mongoose')<br/><br/>const TeamSchema = new mongoose.Schema({<br/>    name: {<br/>      type: String,<br/>      min: 3,<br/>      max: 100,<br/>      required: true,<br/>      <strong>unique: true</strong><br/>    },<br/><br/>...</pre>
<p>Hot dog! You have the answer. The error we are facing, is because we defined the <kbd>name</kbd> property as <kbd>unique:true</kbd>.</p>
<p>We will need to fix something in the message. We expect a JSON response from the REST <span><span>API</span></span>, so let's configure a global exception handler in our backend to send the error as a JSON object instead of an ugly and incomprehensible HTML page. Open the <kbd>server.js</kbd> file and apply the following change:</p>
<pre>const express = require('express')<br/>const bodyParser = require('body-parser')<br/>const teamsApi = require('./src/routes/teams-api')<br/>const mongooseConfig = require('./src/config/mongoose-connection')<br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/>app.use(teamsApi)<br/><br/><strong>app.use((err, req, res, next) =&gt; {</strong><br/><strong>    return res.status(500).send({ message: err.message })</strong><br/><strong>})</strong><br/><br/><br/>app.listen(3000, () =&gt; {<br/>    console.log('running on port: 3000')<br/>})</pre>
<p>We defined a global middleware, which is a function that expects four params:</p>
<ul>
<li><kbd>err</kbd>: Contains null if no error is thrown; otherwise, it's an instance of error or another value</li>
<li><kbd>req</kbd>: The source request sent by the client</li>
<li><kbd>res</kbd>: The response property</li>
<li><kbd>next</kbd>: The reference to the next action that Express.js will call</li>
</ul>
<p>As is expected, all the errors return an HTTP status different than <kbd>200</kbd>. Until we define the correct status of the other CRUD operations, let's leave it with <kbd>status(500)</kbd> by default. Now, let's run it again and see what happens:</p>
<pre><strong>$ curl -X POST -H 'Content-type: application/json' -d '{"code": "PER", "name": "Peru", "ranking": 11, "captain": "Paolo Guerreo", "Trainer": "Ricardo Gareca", "confederation": "Conmebol"}' http://localhost:3000/teams</strong><br/><br/><strong>{"error":"E11000 duplicate key error collection: wcDb.teams index: name_1 dup key: { : \"Peru\" }"}</strong></pre>
<p>As you can see, we receive a JSON object with a single <kbd>error</kbd> attribute. Cool! Let's continue and learn how to retrieve the full list of teams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing the teams</h1>
                </header>
            
            <article>
                
<p><span>To retrieve the full list of teams, we will make use of the GET HTTP method</span>. Let's start by cleaning up our code a little bit. Until now, we have been using an array of teams; we won't need it anymore, so let's remove it. In <kbd>src/routes/teams-api.js</kbd>, apply the following changes:</p>
<pre>...<br/><br/>api<br/>  .route('/teams')<br/>  .get((req, res) =&gt; {<br/>    <strong>// TODO</strong><br/>  })<br/>  .post((req, res, next) =&gt; {<br/>    let team = new Team(req.body)<br/>    team.save()<br/>      .then(data =&gt; res.json(data))<br/>      .catch(err =&gt; next(err) )<br/>  })<br/><br/>api<br/>  .route('/teams/:id')<br/>  .get((req, res) =&gt; {<br/>      <strong>// TODO</strong><br/>  })<br/>  .put((req, res) =&gt; {<br/>    <strong>// TODO</strong><br/><br/>  })<br/>  .delete((req, res) =&gt; {<br/>    <strong>// TODO</strong><br/>  })<br/><br/>...</pre>
<p>Now that we have our code cleaned, add the following change to implement the logic to retrieve the full list of teams:</p>
<pre>...<br/>api<br/>  .route('/teams')<br/>  .get((req, res<strong>, next</strong>) =&gt; {<br/>    <strong>Team.find()</strong><br/><strong>      .then(data =&gt; res.json(data))</strong><br/><strong>      .catch(err =&gt; { next(err) })</strong><br/>  })<br/>  .post((req, res, next) =&gt; {<br/>    let team = new Team(req.body)<br/>    team.save()<br/>      .then(data =&gt; res.json(data))<br/>      .catch(err =&gt; { next(err) } )<br/>  })<br/>...</pre>
<p>First, we call the <kbd>find</kbd> method to return a <kbd>Promise</kbd> as the <kbd>save</kbd> function used to create new teams. As it is a <kbd>Promise</kbd>, we will receive the data returned from the database into the <strong><kbd>then</kbd></strong> function and if something goes wrong, it will return an error in the <kbd>catch</kbd> function. Let's test it:</p>
<pre><strong>$ curl http://localhost:3000/teams</strong><br/><br/>[{<strong>"_id":"5a662fbf728726072c6298fc"</strong>,"name":"Peru","ranking":11,"captain":"Paolo Guerreo","Trainer":"Ricardo Gareca","confederation":"CONMEBOL","__v":0}]</pre>
<p>Awesome! Now we are able to retrieve the list of teams using the <kbd>api</kbd> we just implemented. Let's continue!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding a single team</h1>
                </header>
            
            <article>
                
<p>To find a single team, we will make use of the <kbd>findById</kbd> built-in method, and we will pass a valid ID to it. So, apply the following changes:</p>
<pre><span>api<br/>  .route('/teams/:id')<br/>  .get((req, res, <strong>next</strong>) =&gt; {<br/>      <strong>let id = req.params.id</strong><br/><br/><strong>      Team.findById(id)</strong><br/><strong>        .then(data =&gt; res.json(data))</strong><br/><strong>        .catch(err =&gt; next(err))</strong><br/>  })<br/>  .put((req, res) =&gt; {<br/>    // TODO<br/><br/>  })<br/>  .delete((req, res) =&gt; {<br/>    // TODO<br/>  })</span></pre>
<p>First, we extract the ID from the <kbd>req.params</kbd> object. Note that we are not using the <kbd>/teams</kbd> route. Instead, we are using the <kbd>/teams/:id</kbd> route. It means that Express.js will inject the <kbd>id</kbd> attribute as an element of the <kbd>params</kbd> object. Then, we call the <kbd>findById</kbd> method and send the response to the client. Let's test it:</p>
<pre><strong>$ curl http://localhost:3000/teams/5a662fbf728726072c6298fc</strong><br/><br/><strong>{"_id":"5a662fbf728726072c6298fc","name":"Peru","ranking":11,"captain":"Paolo Guerreo","Trainer":"Ricardo Gareca","confederation":"CONMEBOL","__v":0}</strong></pre>
<p>Cool! It is working. Note that we are using an existing IDâ<kbd>5a662fbf728726072c6298fc</kbd>. This value will be different for you. To get a valid value, just call the <kbd>/teams</kbd> endpoint to list all your teams, and copy and replace it with the value in the <kbd>_id</kbd> attribute.</p>
<p>Now, what would happen if we pass an invalid ID? Let's test it:</p>
<pre><strong>$ curl http://localhost:3000/teams/5a662fbf728726072c629233</strong><br/><br/><strong>null</strong></pre>
<p>A <kbd>null</kbd> value is retrieved now. According to our API Documentation, we have to return the <kbd>HTTP 404</kbd> status to represent a <span class="packt_screen">Not found</span> response. So, to do this, we need to validate the result from the <kbd>findById</kbd> method and raise an error if we receive a null as a response. Go ahead and apply the following changes:</p>
<pre>...<br/>api<br/>  .route('/teams/:id')<br/>  .get((req, res, next) =&gt; {<br/>      let id = req.params.id<br/>      Team.findById(id)<br/>        .then(data =&gt; {<br/>         <strong> if (data === null) {</strong><br/><strong>            throw new Error("Team not found")</strong><br/><strong>          }</strong><br/><br/>          res.json(data)<br/>        })<br/>        .catch(err =&gt; { next(err) })<br/>  })<br/>  ...</pre>
<p>Now with this implementation, if we receive a <kbd>null</kbd>, we will raise an error that will be handled by our global error handler, which will send a JSON object with the error message. Let's test it:</p>
<pre><strong>$ curl http://localhost:3000/teams/5a662fbf728726072c629233</strong><br/><br/><strong>{"error":"Team not found"}</strong></pre>
<p>Lastly, we need to modify our error handler to change the HTTP status code to <kbd>404</kbd>. In the <kbd>server.js</kbd> file, apply the following change:</p>
<pre>...<br/>app.use((err, req, res, next) =&gt; {<br/>    <strong>let status = 500</strong><br/><br/><strong>    if (err.message.match(/not found/)) {</strong><br/><strong>        status = 404</strong><br/><strong>    }</strong><br/><br/><strong>    return res.status(status).send({ error: err.message })</strong><br/>})<br/>...</pre>
<p>First, we declare the <kbd>STATUS</kbd> variable and assign <kbd>500</kbd> as its default value. Then, we apply a regular expression validation to <span><span>check whether</span></span> the message contains the <kbd>not found</kbd> string. If so, <kbd>STATUS</kbd> is changed to <kbd>404</kbd>. So, let's test it again, adding the <kbd>-v</kbd> flag in the <kbd>curl</kbd> command to see the HTTP status:</p>
<pre><strong>curl http://localhost:3000/teams/5a662fbf728726072c629233 -v</strong><br/><strong>...</strong><br/><strong>&gt;</strong><br/><strong>&lt; HTTP/1.1 404 Bad Request</strong><br/><strong>...</strong><br/><strong>{"error":"Team not found"}</strong></pre>
<p>That's it! Now with this, we are ready to learn how to update a <kbd>team</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating teams</h1>
                </header>
            
            <article>
                
<p>To update our <kbd>teams</kbd>, first we will need to look for an existing team in our database using the <kbd>ID</kbd> provided in the path. If a team is found, we apply the changes to the <kbd>team</kbd> object. So, let's start adding the following code:</p>
<pre>api<br/>  .route('/teams/:id')<br/>  .get((req, res, next) =&gt; {<br/>     ...<br/>  })<br/>  .put((req, res, next) =&gt; {<br/>    <strong>let id = req.params.id    </strong><br/><br/><strong>    Team.findById(id)</strong><br/><strong>      .then(data =&gt; {</strong><br/><strong>        if (data == null) {</strong><br/><strong>          throw new Error("Team not found")</strong><br/><strong>        }</strong><br/><strong>        return data</strong><br/><strong>      })</strong><br/><strong>      .then(team =&gt; {</strong><br/><strong>        // We found the team. </strong><br/><strong>        // Code to update goes here!</strong><br/><strong>      })</strong><br/><strong>      .catch(err =&gt; </strong><strong>next(err)</strong><strong>)</strong><br/><br/>  })<br/>  .delete((req, res) =&gt; {</pre>
<pre>    // TODO<br/>  })<br/>...</pre>
<p>First, we extract the <kbd>id</kbd> passed in the endpoint. Then, we call the <kbd>findById</kbd> method to look for an existing team. If a valid team is found, we will have a <kbd>team</kbd> object as a parameter. Otherwise, an error will be thrown.</p>
<p>As you can see, there are more lines of code to add to our logic. Now it's time to extract the values from the <kbd>req.body</kbd> object and modify the <kbd>team</kbd> found:</p>
<pre>...<br/>  .put((req, res, next) =&gt; {<br/>    let id = req.params.id<br/>    <strong>let teamBody = req.body</strong><br/><br/>    Team.findById(id)<br/>      .then(data =&gt; {<br/>        if (data == null) {<br/>          throw new Error("Team not found")<br/>        }<br/>        return data<br/>      })<br/>      .then(team =&gt; {<br/>         <strong>team.code = teamBody.code || team.code</strong><br/><strong>        team.name = teamBody.name || team.name</strong><br/><strong>        team.ranking = teamBody.ranking || team.ranking</strong><br/><strong>        team.captain = teamBody.captain || team.captain</strong><br/><strong>        team.trainer = teamBody.trainer || team.trainer</strong><br/><strong>        team.confederation = teamBody.confederation || team.confederation</strong><br/><br/>      })<br/>      .catch(err =&gt; {<br/>        next(err)<br/>      })<br/><br/>  })<br/>...</pre>
<p>We have created a <kbd>teamBody</kbd> <span>variable</span> to host the <kbd>req.body</kbd> data. Then, we change the values into the <kbd>team</kbd> object. We are using the <kbd>||</kbd> operator; this operator will assign <kbd>teamBody.code</kbd> if this value is sent in the body object. Otherwise, it will assign the same value to the <kbd>team</kbd> object. With this, we are able to change the values only if they are sent.</p>
<p>Now, to save it to the database, we will call the save method as we did when we coded the logic to create a new <kbd>Team</kbd>:</p>
<pre>... <br/>.put((req, res, next) =&gt; {<br/>    let id = req.params.id<br/>    let teamBody = req.body<br/><br/>    Team.findById(id)<br/>      .then(data =&gt; {<br/>        if (data == null) {<br/>          throw new Error("Team not found")<br/>        }<br/>        return data<br/>      })<br/>      .then(team =&gt; {<br/>        team.code = teamBody.code || team.code<br/>        team.name = teamBody.name || team.name<br/>        team.ranking = teamBody.ranking || team.ranking<br/>        team.captain = teamBody.captain || team.captain<br/>        team.trainer = teamBody.trainer || team.trainer<br/>        team.confederation = teamBody.confederation || team.confederation<br/><br/>       <strong> return team.save()</strong><br/>      })<br/>      .then(result =&gt; res.json(result))<br/>      .catch(err =&gt; next(err))<br/><br/>  })<br/>...</pre>
<p>Cool! Now we have implemented the logic to update our <kbd>Team</kbd> entities. Let's test things out. Execute the following command:</p>
<pre><strong>$ curl -X PUT -H 'Content-type: application/json' -d '{"ranking": 1}' http://localhost:3000/teams/5a662fbf728726072c6298fc</strong><br/><br/>{"_id":"5a662fbf728726072c6298fc","name":"Peru",<strong>"ranking":1</strong>,"captain":"Paolo Guerreo","Trainer":"Ricardo Gareca","confederation":"CONMEBOL","__v":0}</pre>
<p>Excellent! Now we are able to update <kbd>Team</kbd> entities. However, have you noticed that our code is a little difficult to organize? We are using multiple <kbd>Promise</kbd> entities to find and save a product. What will happen if we need to perform more asynchronous operations? Sooner or later, we will end up having code that contains a lot of <kbd>then</kbd> instructions that might be difficult to maintain and understand. However, don't worry! The async/await comes to save the day! Keep reading.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The async/await instruction</h1>
                </header>
            
            <article>
                
<p>The async and await are two instructions that come to save our life from the <kbd>Promise</kbd> chaos. This will allows us to write asynchronous code using asynchronous syntax. Let's organize our code to see how this works!</p>
<p>First, we will need to create a new function for the update process, as follows:</p>
<pre>...<br/>const Team = require('../models/team')<br/><br/><strong>const updateTeam = async (id, teamBody) =&gt; {</strong><br/>  try {<br/>    let team = await Team.findById(id)<br/><br/>    if (team == null) throw new Error("Team not found")<br/><br/>    team.code = teamBody.code || team.code<br/>    team.name = teamBody.name || team.name<br/>    team.ranking = teamBody.ranking || team.ranking<br/>    team.captain = teamBody.captain || team.captain<br/>    team.trainer = teamBody.trainer || team.trainer<br/>    team.confederation = teamBody.confederation || team.confederation<br/><br/>    team = await team.save()<br/>    return team<br/><br/>  } catch (err) {<br/>    throw err<br/>  }<br/><strong>}</strong><br/><br/>api<br/>  .route('/teams')<br/>...</pre>
<p>The first thing to note in the preceding code is the <kbd>async</kbd> keyword. This keyword will wrap the returning result into a <kbd>Promise</kbd> and will allow us to use the <kbd>await</kbd> keyword. You cannot use <kbd>await</kbd> keyword in a non-async function. The <kbd>await</kbd> keyword will wait for the asynchronous call <kbd>Team.findById(id)</kbd> to end and will return the result. The same happens when we call the <kbd>team.save()</kbd> method.</p>
<p>Using async-await helps us avoid the <kbd>Promise</kbd> chaos. It provides us with an execution flow that might look like an asynchronous execution.</p>
<p>Once we have defined the <kbd>updateTeam</kbd> async function, we need to modify our <kbd>PUT</kbd> endpoint to call this new function:</p>
<pre>...<br/>  })<br/>  .put((req, res, next) =&gt; {<br/><strong>    updateTeam(req.params.id, req.body)</strong><br/><strong>      .then(team =&gt; res.json(team))</strong><br/><strong>      .catch(err =&gt; next(err))</strong><br/><br/>  })<br/>  .delete((req, res) =&gt; {<br/>    // TODO<br/>  })<br/>...</pre>
<p>We said that <kbd>async</kbd> will wrap the result into a <kbd>Promise</kbd>, so to use the result, we will need to use the <kbd>then</kbd> and <kbd>catch</kbd> methods to process the returning <kbd>Promise</kbd>.</p>
<p>That's it! Now we are ready to learn how to delete an existing object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting teams</h1>
                </header>
            
            <article>
                
<p>Deleting a team is extremely easy. To do this, we will call the remove built-in method of the <kbd>Team</kbd> model. Add the following code:</p>
<pre>...<br/>.delete((req, res, <strong>next</strong>) =&gt; {<br/>    <strong>let id = req.params.id</strong><br/><br/><strong>    Team.remove({_id: id})</strong><br/><strong>      .then(result =&gt; res.json(result))</strong><br/><strong>      .catch(err =&gt; next(err))</strong><br/>  })<br/><br/><br/>module.exports = api</pre>
<p>Now, let's test things out. Execute the following command:</p>
<pre><strong>$ curl -X DELETE http://localhost:3000/teams/5a662fbf728726072c6298fc</strong><br/><br/>{"n":1,"ok":1}</pre>
<p>The output is a bit different now; we received a JSON object with two params:</p>
<ul>
<li><kbd>n</kbd>: The number of documents removed</li>
<li><kbd>ok</kbd>: <kbd>1</kbd> if the operations were successful or <kbd>0</kbd> if not</li>
</ul>
<p>Awesome! Now we have our Rest API to manage our teams ready, but there is a key missing piece in our API that we did not take care of, and that is security. We will make our API secure by adding an authentication and authorization layer in subsequent chapters. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned what a database is and the difference between SQL and NoSQL databases. Also, we implemented the API to manage teams that is able to persist the information into a MongoDB database.</p>
<p>You also learned about async/await, and we were able to code a more easy-to-read and maintainable asynchronous logic.</p>
<p>In the next chapter, we will explore advanced features ofÂ <span>Aurelia</span> to integrate our REST API with our Aurelia web application.</p>


            </article>

            
        </section>
    </body></html>