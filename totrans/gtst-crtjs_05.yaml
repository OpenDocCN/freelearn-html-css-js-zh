- en: Chapter 5. Utilizing Caching in EaselJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：在 EaselJS 中利用缓存
- en: As you know, after developing an animation, it's very important to work on the
    performance issues to make it smooth. The performance of rendering animations
    varies between browsers but there are some techniques like caching that can simply
    improve the performance. In this chapter, we will learn how to make better and
    smooth animations or drawings using the *EaselJS* caching system of `DisplayObject`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，在开发动画后，解决性能问题以使其平滑运行非常重要。渲染动画的性能在不同浏览器之间有所不同，但有一些技术，如缓存，可以简单地提高性能。在本章中，我们将学习如何使用
    `DisplayObject` 的 *EaselJS* 缓存系统制作更好、更平滑的动画或绘图。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the caching feature of EaselJS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 EaselJS 的缓存功能
- en: Understanding the cache method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存方法
- en: Example of using cache
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存使用示例
- en: Using cache in animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动画中使用缓存
- en: Using cache with Bitmap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位图缓存
- en: Exploring the caching feature of EaselJS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 EaselJS 的缓存功能
- en: In EaselJS, when you have a shape, or even better, an instance of the `DisplayObject`
    that doesn't change frequently, it's better to use the *cache* function to cache
    it in a different `Canvas` element. This technique will help you use EaselJS in
    the drawing process to animate and render animations or drawings smoothly, as
    the shapes don't need to be rendered with every tick.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EaselJS 中，当你有一个形状，或者更好的是，一个不经常改变的 `DisplayObject` 实例时，最好使用 *缓存* 函数将其缓存到一个不同的
    `Canvas` 元素中。这种技术将帮助你使用 EaselJS 在绘图过程中平滑地动画化和渲染动画或绘图，因为形状不需要在每一帧中重新渲染。
- en: It is basically the main idea of using the `cache` method in the `DisplayObject`
    class. All you need to do is learn more about using the cache method in EaselJS.
    In further sections, we will go through methods, their usage, and how to create
    animations with caching.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是使用 `DisplayObject` 类中的 `cache` 方法的核心思想。你所需要做的就是更多地了解如何在 EaselJS 中使用缓存方法。在接下来的章节中，我们将介绍方法、它们的用法以及如何使用缓存创建动画。
- en: Understanding the cache method
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓存方法
- en: In order to understand how caching a `DisplayObject` works in EaselJS, we take
    the example of an imaginary canvas area so that the cached elements get rendered
    into it and each time you need to update the target shape, you call the `cache`
    method again.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解在 EaselJS 中缓存 `DisplayObject` 的工作原理，我们以一个假想的画布区域为例，这样缓存的元素就会被渲染到其中，每次你需要更新目标形状时，你再次调用
    `cache` 方法。
- en: 'You can see the definition of the `cache` method inside the `DisplayObject`
    class in the following piece of code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码片段中看到 `DisplayObject` 类中 `cache` 方法的定义：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Draws the display object into a new canvas, which is then used for subsequent
    draws. For complex content that does not change frequently (ex. a Container with
    many children that do not move, or a complex vector Shape), this can provide for
    much faster rendering because the content does not need to be re-rendered each
    tick. The cached display object can be moved, rotated, faded, etc freely, however
    if its content changes, you must manually update the cache by calling `updateCache()`
    or `cache()` again. You must specify the cache area via the x, y, w, and h parameters.
    This defines the rectangle that will be rendered and cached using this display
    object's coordinates.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将显示对象绘制到一个新的画布上，然后用于后续的绘制。对于不经常改变的内容（例如，一个包含许多不移动的子项的容器，或一个复杂的矢量形状），这可以提供更快的渲染速度，因为内容不需要在每一帧中重新渲染。缓存的显示对象可以自由移动、旋转、淡入淡出等，然而如果其内容发生变化，你必须手动通过调用
    `updateCache()` 或再次调用 `cache()` 来更新缓存。你必须通过 x、y、w 和 h 参数指定缓存区域。这定义了将使用此显示对象的坐标渲染和缓存的矩形。
- en: 'This has been taken from:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从以下内容摘录的：
- en: '[http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache](http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache](http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache)'
- en: As you can see, the `cache` method accepts four mandatory and one optional parameter.
    The first and second parameters define the *coordinate* of the cache area; the
    third and fourth parameters define the *width* and *height* of the cache area.
    Using the last parameter, you can define the *scale of shape* inside the cache
    area. By default it is set as `1`, but you can change it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`cache` 方法接受四个强制参数和一个可选参数。第一个和第二个参数定义了缓存区域的 *坐标*；第三个和第四个参数定义了缓存区域的 *宽度*
    和 *高度*。使用最后一个参数，你可以在缓存区域内定义形状的 *缩放比例*。默认设置为 `1`，但你也可以更改它。
- en: Example of using cache
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存使用示例
- en: 'Now it''s time to see an example of using the `cache` method in EaselJS. The
    following piece of code uses the `cache` method to render a circle into a canvas
    element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看在EaselJS中使用`cache`方法的示例了。以下代码片段使用`cache`方法将一个圆渲染到画布元素中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line, we created a shape using the `Shape` class, filled it with
    red color, and then rendered it at `(0, 0)` with a radius of `25`. In the third
    line, you will notice the use of the `cache` method. In this line, a *cache area*
    is created at `-25`, `-25` with a width and height of `50`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们使用`Shape`类创建了一个形状，用红色填充，然后在`(0, 0)`位置以`25`的半径渲染它。在第三行中，你会注意到`cache`方法的使用。在这一行中，创建了一个位于`-25`，`-25`的*缓存区域*，宽度和高度为`50`。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to update the target shape (the shape variable in the above example),
    you need to call the `cache` or `updateCache` method with all new parameters again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新目标形状（如上述示例中的形状变量），你需要再次调用`cache`或`updateCache`方法，并带上所有新的参数。
- en: 'The complete source code and result is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码和结果如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above source code is the completed example of using the cache method in
    EaselJS. The result of this source code is as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述源代码是使用EaselJS中缓存方法完成的示例。此源代码的结果如下面的截图所示：
- en: '![Example of using cache](img/0260OS_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用缓存的示例](img/0260OS_05_01.jpg)'
- en: Using cache in complex shapes and animations
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复杂形状和动画中使用缓存
- en: Caching in EaselJS comes in handy when you have a complex shape or animation
    in your canvas. In most cases, complex shapes with details shouldn't get rendered
    in every tick. So you can simply use the cache method to cache it in order to
    prevent rendering overhead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在EaselJS中，当你画布中有复杂形状或动画时，缓存非常有用。在大多数情况下，带有细节的复杂形状不应该在每个tick中渲染。因此，你可以简单地使用缓存方法来缓存它，以防止渲染开销。
- en: 'Now we will see a complex example from the EaselJS library (source: [https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html](https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html))
    and the effect of using a cache technique on that. In this animation, we will
    create about *200* complex circles and move them on each tick. There is a checkbox
    on the page that controls the enabling or disabling of caching for all shapes
    inside the canvas area using `cache` and `uncache` methods.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到一个来自EaselJS库的复杂示例（来源：[https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html](https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html)）以及使用缓存技术在其中的效果。在这个动画中，我们将创建大约*200*个复杂的圆圈并在每个tick上移动它们。页面上有一个复选框，用于通过`cache`和`uncache`方法启用或禁用画布区域内所有形状的缓存。
- en: 'The following screenshot shows us a preview of our animation (notice the checkbox):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们动画的预览（注意复选框）：
- en: '![Using cache in complex shapes and animations](img/0260OS_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![在复杂形状和动画中使用缓存](img/0260OS_05_02.jpg)'
- en: There are three main functions that handle this animation and all the logics;
    `init`, `tick`, and `toggleCache`. We will discuss each one of them separately.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要函数处理这个动画和所有逻辑；`init`、`tick`和`toggleCache`。我们将分别讨论每一个。
- en: 'In the first lines of the code, we will use the following variables:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行中，我们将使用以下变量：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first variable holds the canvas element, the second one is used for the
    `Stage` object, the `shape` variable is used to draw shapes on the stage, and
    `circleRadius` and `rings` are used for basic settings of circles. `circleRadius`
    is used to define the radius of each circle and `rings` is used to define the
    number of rings inside each circle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量持有画布元素，第二个用于`Stage`对象，`shape`变量用于在舞台上绘制形状，而`circleRadius`和`rings`用于圆的基本设置。`circleRadius`用于定义每个圆的半径，而`rings`用于定义每个圆内环的数量。
- en: 'The following code shows the the basic `init` method that draws all shapes
    and prepares the stage:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了绘制所有形状并准备舞台的基本`init`方法：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is used to create the stage and all shape objects. In lines 3 and
    4, the `Stage` object is created. In line 8, we defined random colors for circle
    rings. After that, we have used a *for-loop*, which draws 200 different circles
    with random positions on the stage. We have another for-loop to draw rings inside
    the circles in line 12.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码用于创建舞台和所有形状对象。在第3和第4行中，创建了`Stage`对象。在第8行中，我们为圆环定义了随机颜色。之后，我们使用了一个*for循环*，在舞台上绘制了200个不同位置的随机圆圈。在第12行中，我们还有一个for循环来绘制圆圈内部的环。
- en: In our animation, we have a label that indicates the **Frames per Second** (**FPS)**
    rate on each tick. So, in lines 28 to 31, we have defined our label properties.
    In line 34, the `Ticker` class is created and in line 36, the FPS of the animation
    is set to `50`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的动画中，有一个标签指示每次tick的**每秒帧数**（**FPS**）。因此，在第28到31行，我们定义了我们的标签属性。在第34行，创建了`Ticker`类，在第36行，动画的FPS被设置为`50`。
- en: 'After the `init` function, we have a tick function that will be called on each
    tick by EaselJS:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数之后，我们有一个tick函数，它将由EaselJS在每次tick时调用：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The main job of the above `init` function is to change the position of all the
    circles on the stage on each tick, set the current FPS rate to the label, and
    then update the stage. The reason there is `-1` in line 4 is to exclude the label
    object from `children`; keep in mind that we only need to change the position
    of all the circles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`init`函数的主要任务是每次tick时改变舞台上的所有圆的位置，将当前FPS速率设置为标签，然后更新舞台。第4行中的`-1`的原因是排除标签对象从`children`中；请记住，我们只需要改变所有圆的位置。
- en: 'The last function is the `toggleCache` function. This method enables or disables
    caching for all circles:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是`toggleCache`函数。此方法为所有圆形启用或禁用缓存：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function is called only when you check or uncheck the checkbox on the page
    so it enables or disables caching for all circle objects on `stage`. There is
    a for-loop that iterates over all circle shapes and calls the `cache` or `uncache`
    method according to the status of the checkbox. Consequently, the caching for
    circle shapes will be enabled or disabled.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数仅在你在页面上勾选或取消勾选复选框时被调用，因此它为`stage`上所有圆形对象启用或禁用缓存。有一个for循环遍历所有圆形形状，并根据复选框的状态调用`cache`或`uncache`方法。因此，圆形形状的缓存将被启用或禁用。
- en: By clicking on the checkbox, you can obviously see that the animation rendering
    gets smoother when caching is enabled.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击复选框，你可以明显看到当启用缓存时，动画渲染变得更加平滑。
- en: Finally, you can find the complete source code of our animation on the Packt
    website.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在 Packt 网站上找到我们动画的完整源代码。
- en: Caching Bitmap
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存位图
- en: In this section, we will utilize the `cache` method with Bitmap and `AlphaMaskFilter`
    to develop a reflection effect in EaselJS. The target is to load an image and
    create a `Bitmap` class to draw the image. Then, clone the `Bitmap` image, change
    the rotation and add a gradient background, and use `AlphaMaskFilter` to create
    the reflection effect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用`cache`方法和`AlphaMaskFilter`在EaselJS中开发反射效果。目标是加载一个图像并创建一个`Bitmap`类来绘制图像。然后，克隆`Bitmap`图像，改变旋转并添加渐变背景，并使用`AlphaMaskFilter`创建反射效果。
- en: 'The following screenshot is a preview of the result:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是结果的预览：
- en: '![Caching Bitmap](img/0260OS_05_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![缓存位图](img/0260OS_05_03.jpg)'
- en: 'The following is the source code of this example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是这个示例的源代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As seen in previous examples, firstly, we created the `Stage` class. Then, in
    order to load the image, we used the `Image` class and passed the address of the
    image to the `src` property. The `Image` class has an `onload` event, which helps
    developers know when the image is loaded completely. We used this event to execute
    other parts of the application correctly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，首先我们创建了`Stage`类。然后，为了加载图像，我们使用了`Image`类并将图像的地址传递给`src`属性。`Image`类有一个`onload`事件，这有助于开发人员知道图像是否已完全加载。我们使用此事件来正确执行应用程序的其他部分。
- en: After that, we used a `Bitmap` class and passed the image parameter from the
    `Image` class to it. Because we need the width and height of the picture, we saved
    them into two different variables called `width` and `height`. At this moment,
    we have the first picture but we should have one more picture to create the reflection
    effect. So, we used the `clone` function to duplicate the image. In order to change
    the rotation, scale, and coordination of the second image, we changed the `regY`,
    `rotation`, `y`, and `scaleX` properties.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`Bitmap`类并将`Image`类的图像参数传递给它。因为我们需要图片的宽度和高度，我们将它们保存到两个不同的变量中，分别称为`width`和`height`。此时，我们已经有了一幅图片，但我们还需要另一幅图片来创建反射效果。因此，我们使用了`clone`函数来复制图像。为了改变第二幅图像的旋转、缩放和坐标，我们改变了`regY`、`rotation`、`y`和`scaleX`属性。
- en: After that, a new shape is created using the `Shape` class. This is the mask
    layer that will be used for the `AlphaMaskFilter`. Then, we added a linear background
    to it to create the reflection effect and cached it using the `cache` function.
    Finally, an `AlphaMaskFilter` is added to the second picture (a cloned `Bitmap`
    class) and this shape is used as the mask layer. The second picture is also cached
    again. Both pictures are added to `Stage` using the `addChild` function and `Stage`
    is also updated with the `update` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `Shape` 类创建了一个新的形状。这是将要用于 `AlphaMaskFilter` 的遮罩层。然后，我们向其添加了线性背景以创建反射效果，并使用
    `cache` 函数进行了缓存。最后，将 `AlphaMaskFilter` 添加到第二张图片（一个克隆的 `Bitmap` 类）上，并将此形状用作遮罩层。第二张图片也再次进行了缓存。这两张图片都通过
    `addChild` 函数添加到 `Stage` 中，并且 `Stage` 也通过 `update` 函数进行了更新。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to work with the `cache` method in EaselJS
    to create better drawings and animations on the canvas. The reason we use caching
    in EaselJS is to provide better and faster animation rendering in browsers and
    also use fewer resources while rendering the animations or drawings. In the next
    section, we discussed about using the cache method with the `Bitmap` class to
    create the reflection effect.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 EaselJS 中使用 `cache` 方法来创建更好的画布绘制和动画。我们在 EaselJS 中使用缓存的原因是为了在浏览器中提供更好的动画渲染速度，同时在渲染动画或绘图时使用更少的资源。在下一节中，我们讨论了如何使用
    `cache` 方法与 `Bitmap` 类结合来创建反射效果。
- en: In the next chapter, we will talk about applying filters in canvas with EaselJS,
    which is one of the best features of EaselJS, and you can make fantastic stuff
    with this feature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在 EaselJS 中应用滤镜于画布，这是 EaselJS 的最佳特性之一，你可以利用这个特性制作出令人惊叹的作品。
