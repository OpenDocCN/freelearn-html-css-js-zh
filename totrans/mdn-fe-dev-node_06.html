<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor057"/>6</h1>
<h1 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor058"/>Building Web Apps with Bundlers</h1>
<p lang="en-GB">In the previous chapter, we covered an important set of auxiliary tooling – linters and formatters. While code quality is important, the undoubtedly most important aspect of every project is what is shipped and used by the customer. This is the area where a special kind of tooling – called bundlers – shines.</p>
<p lang="en-GB">A bundler is a tool that understands and processes source code to produce files that can be placed on a web server and are ready to be consumed by web browsers. It takes HTML, CSS, JavaScript, and related files into consideration to make them more efficient and readable. In this process, a bundler would merge, split, minify, and even translate code from one standard such as ES2020 into another standard such as ES5.</p>
<p lang="en-GB">Today, bundlers are no longer nice to have, but necessarily used for most projects directly or indirectly. Pretty much every web framework offers tooling that is built upon a bundler. Often, the challenge is to configure a bundler so that it understands our code base and does exactly what we’d expect it to do. Since web code bases are quite different, bundlers need to be flexible in many directions.</p>
<p lang="en-GB">In this chapter, you’ll build up an understanding of what bundlers do and how you can control their inner processes. We’ll also introduce the most important bundlers as of today, and see how they can be used and configured to work efficiently for us. This will help you get your web project from raw source code to production-ready artifacts.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Understanding bundlers</li>
<li lang="en-GB">Comparing the available bundlers</li>
<li lang="en-GB">Using Webpack</li>
<li lang="en-GB">Using esbuild</li>
<li lang="en-GB">Using Parcel</li>
<li lang="en-GB">Using Vite</li>
</ul>
<h1 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor059"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3G0NiMX">https://bit.ly/3G0NiMX</a>.</p>
<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor060"/>Understanding bundlers</h1>
<p lang="en-GB">Writing a modern web<a id="_idIndexMarker191"/> application is quite difficult. One of the reasons for the level of difficulty is the large variety of different technologies that need to be involved in the process. Let’s just mention a few:</p>
<ul>
<li lang="en-GB">HTML for writing documents</li>
<li lang="en-GB">CSS for styling those documents</li>
<li lang="en-GB">JavaScript with the DOM API to bring some interactivity</li>
<li lang="en-GB">A JavaScript UI framework to create interactive components</li>
<li lang="en-GB">A CSS preprocessor to use variables, nesting, and more features for CSS</li>
<li lang="en-GB">Potentially TypeScript or some other typed system to improve reliability in certain source code areas</li>
<li lang="en-GB">Service and web workers need to be mastered</li>
<li lang="en-GB">All static files should be easy to cache</li>
</ul>
<p lang="en-GB">Before the introduction of a new class of tooling that was capable of building up module graphs, dedicated<a id="_idIndexMarker192"/> task runners such as <strong class="bold" lang="">Grunt</strong> or <strong class="bold" lang="">Gulp</strong> were used. These runners were inspired by<a id="_idIndexMarker193"/> more generic<a id="_idIndexMarker194"/> approaches such as <strong class="bold" lang="">Makefiles</strong>. The problem, however, was that two aspects – the build process and the source code – needed to be kept in sync. Just adding one file to the source code was not sufficient; the build process had to be informed about this new file. With bundlers, this all changed.</p>
<p lang="en-GB">At its core, a bundler is a tool that leverages other tools. The most important addition is that a bundler understands the module graph – that is, the relationships (imports and exports) of code modules such as the CommonJS or ESM modules we discussed in the previous chapters. It can build up a module graph and use that to let other tools such as Babel work.</p>
<p lang="en-GB">To get started, a bundler<a id="_idIndexMarker195"/> requires so-called entry points – quite often, these are referred to as entries. These are files that are used as roots in the module graph. These files may depend on other files, in which case the bundler will continue in these files to build up the module graph.</p>
<p lang="en-GB"><em class="italic" lang="">Figure 6</em><em class="italic" lang="">.1</em> shows an <a id="_idIndexMarker196"/>example module graph constructed from two entry points. The interesting property of this graph is that the content of <strong class="bold" lang="">Entry 2</strong> is fully contained in <strong class="bold" lang="">Entry 1</strong>, too. In many situations, there won’t be any significant overlap between the module graphs of multiple entry points:</p>
<div><div><img alt="Figure 6.1 – Example module graph constructed from two entry points " src="img/Figure_6.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Example module graph constructed from two entry points</p>
<p lang="en-GB">Most bundlers work in phases. While each bundler uses slightly different terminology, they almost always come with the following high-level phases:</p>
<ol>
<li lang="en-GB">Module resolution</li>
<li lang="en-GB">Module transformation</li>
<li lang="en-GB">Chunk and asset generation</li>
<li lang="en-GB">Applying optimizations</li>
</ol>
<p lang="en-GB">The module<a id="_idIndexMarker197"/> transformation is often necessary. On the one hand, the bundler needs to understand the module to find imported modules to build up the module graph; on the other hand, the chunk generation must rely on normalized input modules.</p>
<p lang="en-GB">While the transformation phase needs to work hand-in-hand with a resolver to continuously build up the module graph, all other phases are pretty much independent. Quite often, the optimization phase is either reduced or fully disabled during development. This reduction helps speed up the bundling process by a fair margin. Additionally, further instructions that are quite helpful during debugging will be kept.</p>
<p class="callout-heading" lang="en-GB">Minification</p>
<p class="callout" lang="en-GB">One of the most common optimizations<a id="_idIndexMarker198"/> is minification. The goal of minification is to make the files as small as possible without using active compression. While minification on the surface is rather easy and efficient in a language such as JavaScript, other languages such as CSS or HTML are a bit more problematic. Especially minification of HTML has been proven to be a hard problem without as many gains compared to the minification of JavaScript. After minification, files are usually not as readable as they were previously. One reason is the removal of unnecessary whitespace, which was introduced to give the original code readability and structure.</p>
<p lang="en-GB">The whole bundling process can be sketched in a diagram. <em class="italic" lang="">Figure 6</em><em class="italic" lang="">.2</em> shows how the different entries enter the different phases:</p>
<div><div><img alt="Figure 6.2 – High-level phases of a modern web bundler " src="img/Figure_6.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – High-level phases of a modern web bundler</p>
<p lang="en-GB">Another thing to consider is that the chunk generation will mostly also introduce some kind of JavaScript runtime. This can<a id="_idIndexMarker199"/> be as lightweight as teaching the resulting code how to load additional bundles that have been created as script files, but it can also include full support for loading shared dependencies from foreign code and more. The introduced code is fully bundler-specific.</p>
<p lang="en-GB">With that in mind, let’s see what kind of bundlers are out there and how they compare.</p>
<h1 id="_idParaDest-62" lang="en-GB"><a id="_idTextAnchor061"/>Comparing available bundlers</h1>
<p lang="en-GB">There are multiple<a id="_idIndexMarker200"/> generations of bundlers. The first generation was centered around the belief that Node.js applications are the only kind of applications that should be written. Therefore, changing these applications into JavaScript files that work in the browser has been the primary concern of the bundlers from that generation. The most <a id="_idIndexMarker201"/>popular one in that category is <strong class="bold" lang="">Browserify</strong>.</p>
<p lang="en-GB">The second generation went on to extend the idea from the first generation to pretty much all JavaScript code. Here, even HTML and CSS assets could be understood. For instance, using <code>@import</code> rules in CSS would extend the module graph to another CSS module. Importantly, while the <em class="italic" lang="">CommonJS</em> (or later on, <em class="italic" lang="">ESM</em>) syntax was still used to derive the JavaScript module graph, these second-generation bundlers did not care about Node.js. They always assumed that the code was written for the browser. Quite often, however, you could change the target and also bundle code for Node.js with them. The most popular one in<a id="_idIndexMarker202"/> this category is <strong class="bold" lang="">Webpack</strong>, even though Webpack always tried to go with the times and adapt.</p>
<p lang="en-GB">Third-generation bundlers introduced a much-improved user experience. They tried to find a native or obvious way of handling things and often did not even require any configuration. The most popular tool in this category is the original <em class="italic" lang="">Parcel</em> bundler.</p>
<p lang="en-GB">The current fourth-generation bundlers are all about performance. They either come with a dedicated runtime or sit on top of natively written tooling, which usually outperforms their older JavaScript-written <a id="_idIndexMarker203"/>counterparts. Here, we see tools such as <strong class="bold" lang="">esbuild</strong> or experimental<a id="_idIndexMarker204"/> runtimes such as <strong class="bold" lang="">Bun</strong>.</p>
<p lang="en-GB">The big question is: When should you use what? With half a dozen popular bundlers and more available, the question is not easy to answer. Surely, if a team is already really familiar with one of the options, then going with it for a project is very often the right choice. Otherwise, look for similar projects and try to understand what bundler they picked – and why. In any other case, you could use the following catalog of questions to identify which bundler might be the best option:</p>
<ul>
<li lang="en-GB">What kind of assets are involved? If only JavaScript is involved, then Webpack might be good. If you have<a id="_idIndexMarker205"/> multiple HTML pages that all need to be processed, then <strong class="bold" lang="">Vite</strong> might be a great option.</li>
<li lang="en-GB">How many dependencies are you using? Especially when you use older libraries from npm, a bundler with a broad range of support – such as Webpack – may be the best choice. Otherwise, look for faster options, such as esbuild.</li>
<li lang="en-GB">How familiar is the team with bundlers and their options? If the team is not familiar with bundling at all, then Parcel could be a great way to get started. Otherwise, Webpack potentially has the most documentation out there. A community that is rather new and very active and helpful can be found with Vite.</li>
<li lang="en-GB">Are you building<a id="_idIndexMarker206"/> an application or just want to optimize the assets of a library? Especially for a library, something smaller, such as esbuild, might be useful. On the other hand, Parcel has a lot to offer here, too. In general, Vite should be avoided for libraries. Support is there, but it just does not feel to be ready yet for building libraries more efficiently than Rollup.js and esbuild.</li>
<li lang="en-GB">Do you need support for advanced scenarios such as offline mode or web workers? In these cases, the ecosystem of Webpack is very often hard to beat. Parcel also does a good job of offering helpers in this area. esbuild should be avoided for such scenarios.</li>
<li lang="en-GB">How important is performance? If you have a larger code base (above 1,000 modules or 100,000 lines of code), then Webpack is known to be a performance killer, taking easily 30 seconds to minutes. Picking something such as Vite or – if possible – esbuild will certainly help speed up the process. While the former is more developer friendly, it also <a id="_idIndexMarker207"/>comes with a lot of hidden complexity. The<a id="_idIndexMarker208"/> latter is more direct but lacks standard features such as <strong class="bold" lang="">hot-module </strong><strong class="bold" lang="">reloading</strong> (<strong class="bold" lang="">HMR</strong>).</li>
<li lang="en-GB">How much maintenance is acceptable? Bundlers that rely on a lot of plugins are traditionally much harder to maintain. Upgrading Webpack to the next major version has been notoriously difficult. From missing plugins to breaking changes in the plugin’s API – everything that can happen will also happen in such cases. Prefer bundlers such as Parcel or Vite that try to come with everything necessary out of the box.</li>
<li lang="en-GB">How important are additional development features such as bundle insights? If these are supercritical, then nothing is better than Webpack. As the Webpack ecosystem is super large, you’ll find additional tools, libraries, and guides easily. On the other hand, choosing something with a growing community such as Vite might also work <a id="_idIndexMarker209"/>fine. If something is missing, the community should be capable of picking it up quickly, too.</li>
</ul>
<p lang="en-GB">In the following sections, we’ll go over an example project to see how some of the most popular bundlers can be used to build it. We’ll use a project with a small, but non-trivial code base. For this<a id="_idIndexMarker210"/> example, we’ll use <strong class="bold" lang="">React</strong> – but don’t worry, you don’t need to know React to follow this chapter.</p>
<p class="callout-heading" lang="en-GB">React</p>
<p class="callout" lang="en-GB">React is arguably the most popular UI library for web frontend development. It allows developers to build UIs quickly in JavaScript by leveraging a language extension known as <code>Button</code> or <code>Carousel</code>.</p>
<p lang="en-GB">The code base for the example we’ll cover consists of the following:</p>
<ul>
<li lang="en-GB">The source <a id="_idIndexMarker212"/>code of a <strong class="bold" lang="">single-page </strong><strong class="bold" lang="">application</strong> (<strong class="bold" lang="">SPA</strong>)</li>
<li lang="en-GB">An <code>index.html</code>) of the SPA</li>
<li lang="en-GB">Several asset files (videos, images in different formats, audio)</li>
<li lang="en-GB">Several non-trivial dependencies</li>
<li lang="en-GB">Some files that use TypeScript instead of JavaScript</li>
<li lang="en-GB">A special <strong class="bold" lang="">CSS</strong> preprocessor called <strong class="bold" lang="">SASS</strong></li>
<li lang="en-GB">A web framework (React with React Router) is being used</li>
<li lang="en-GB">Different virtual routes should lead to different pieces of the page that have to be lazy loaded</li>
</ul>
<p lang="en-GB">All in all, this example <a id="_idIndexMarker213"/>should produce a small demo application that contains a video and audio player that uses third-party dependencies.</p>
<p class="callout-heading" lang="en-GB">Lazy loading</p>
<p class="callout" lang="en-GB">Lazy loading describes a technique <a id="_idIndexMarker214"/>where not all parts required by an application are loaded immediately. For a SPA, this makes sense – after all, not every component or part of the SPA will be required for the current user interaction. And even if it isn’t required, it could be at some later point in time. Lazy loading usually involves loading additional script (or other) files when some action such as a user clicking on a button or following some internal link is performed. The implementation of lazy loading needs to be supported by the respective UI framework (for example, React has a function called <code>lazy</code>) but is done by the bundler.</p>
<p lang="en-GB">The boilerplate for this example can be created by initializing a new Node.js project:</p>
<pre class="console" lang="en-GB">
$ npm init -y</pre>
<p lang="en-GB">Now, we’ll add all the runtime dependencies – that is, the packages that will be required when our application runs in the browser:</p>
<pre class="console" lang="en-GB">
$ npm i react react-dom react-router-dom video.js --save</pre>
<p lang="en-GB">At the end of the day, it will be the job of the bundler to add the preceding dependencies to scripts that can be run in the browser. However, for us, it makes sense to do this to get a clear view of which packages are just required for the tooling, and which dependencies are needed for the code to run.</p>
<p lang="en-GB">The basic <code>devDependencies</code> – that is, the ones that are required for the tooling – are as follows:</p>
<pre class="console" lang="en-GB">
$ npm i typescript sass @types/react @types/react-dom --save-dev</pre>
<p lang="en-GB">Additional tooling dependencies are required, too, but will be bundler-specific.</p>
<p lang="en-GB">The example application contains the following source files:</p>
<ul>
<li lang="en-GB"><code>index.html</code>: Template for the SPA website</li>
<li lang="en-GB"><code>script.tsx</code>: Starts to run the application</li>
<li lang="en-GB"><code>App.tsx</code>: The application root</li>
<li lang="en-GB"><code>Layout.tsx</code>: The layout of the application</li>
<li lang="en-GB"><code>Home.tsx</code>: The home page containing links to all pages</li>
<li lang="en-GB"><code>Video.tsx</code>: The page containing the video player</li>
<li lang="en-GB"><code>Audio.tsx</code>: The page containing the audio player</li>
<li lang="en-GB"><code>Player.jsx</code>: The React component for the video and audio player</li>
<li lang="en-GB"><code>earth.mp4</code>: Video file to play</li>
<li lang="en-GB"><code>river.webp</code>: Preview image (<code>.webp</code> format) for the video file</li>
<li lang="en-GB"><code>snow.jpg</code>: Preview image (<code>.jpg</code> format) for the sound file</li>
<li lang="en-GB"><code>sound.mp3</code>: Audio file to play</li>
</ul>
<p lang="en-GB">The process of showing a UI is <a id="_idIndexMarker215"/>usually called rendering. When React first renders the application, it needs to mount its component tree on the DOM tree. This is done in the <code>script.tsx</code> file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">script.tsx</p>
<pre class="source-code" lang="en-GB">import * as React from 'react';
import { createRoot } from 'react-dom/client';
import './style.scss';
import App from './App';
const root = createRoot(document.querySelector('#app')!);
root.render(&lt;App /&gt;);</pre>
<p lang="en-GB">The usage of angle brackets for initiating <code>App</code> is referred to as JSX. Under the hood, the additional <code>x</code> in the file extension (<code>tsx</code>) enables such expressions to be processed, where <code>&lt;App /&gt;</code> will be transformed into <code>React.createElement(App)</code>.</p>
<p lang="en-GB">The <code>App</code> component <a id="_idIndexMarker216"/>itself is defined as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">App.tsx</p>
<pre class="source-code" lang="en-GB">import * as React from "react";
import { BrowserRouter, Route, Routes } from
  "react-router-dom";
import Layout from "./Layout";
const Home = React.lazy(() =&gt; import("./Home"));
const Video = React.lazy(() =&gt; import("./Video"));
const Audio = React.lazy(() =&gt; import("./Audio"));
const App = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path="video" element={&lt;Video /&gt;} /&gt;
        &lt;Route path="audio" element={&lt;Audio /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);
export default App;</pre>
<p lang="en-GB">This kind of structure is<a id="_idIndexMarker217"/> typical for a SPA. All the different routes come together in a router or root component to be displayed when a certain path is found. For instance, in our application, the <code>/video</code> path would show the <code>Video</code> component, while the <code>/audio</code> path would show the <code>Audio</code> component. All these components will be embedded in a <code>Layout</code> component, which is responsible for the general layout, such as showing the header and the footer, of the application.</p>
<p lang="en-GB">In the <code>App.tsx</code> file, lazy loading is initiated by using the ESM <code>import</code> function. Bundlers should be capable of transforming that into loading another script and returning a <code>Promise</code> at that location.</p>
<p class="callout-heading" lang="en-GB">Promises</p>
<p class="callout" lang="en-GB">The specification describes an <code>import</code> function to return a <code>Promise</code>. A <code>Promise</code> is an object that can be used to determine when an asynchronous operation is finished. The object exposes functions, which are called with the result of the asynchronous operation or with an error that was thrown during the operation. The most important functions are <code>then</code> and <code>catch</code>. The former can be used to define what to do when something is successfully returned, while the latter can be used to handle errors.</p>
<p lang="en-GB">In a SPA, it makes sense to put every page in a router into lazy loading. <em class="italic" lang="">Figure 6</em><em class="italic" lang="">.3</em> shows a high-level overview of the example application’s modules. The dashed boxes indicate bundling areas – that is, source files that can be grouped into combined output files. This bundling is one of the most crucial aspects of any bundler:</p>
<div><div><img alt="Figure 6.3 – The example application’s modules " src="img/Figure_6.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The example application’s modules</p>
<p lang="en-GB">While some of the given<a id="_idIndexMarker218"/> aspects should be rather simple to implement in a bundler, other properties of the example application might be challenging. For instance, what is the behavior of a bundler when duplicate modules are found? Some bundlers may duplicate the generated code while others may create a shared bundle that is a loading prerequisite for the generated side bundles.</p>
<p lang="en-GB">In the case of this example, we can see that <code>Player.jsx</code> appears twice. We’ll use this to answer the question for <a id="_idIndexMarker219"/>each bundler. Furthermore, pretty much every module requires <code>react</code>; however, since it is already required in the initial script module (<code>script.tsx</code>), it should not be duplicated.</p>
<p lang="en-GB">Without further ado, let’s see how this example application can be bundled using Webpack.</p>
<h1 id="_idParaDest-63" lang="en-GB"><a id="_idTextAnchor062"/>Using Webpack</h1>
<p lang="en-GB">Webpack is presumably the most <a id="_idIndexMarker220"/>popular option among the available bundlers. It is also among the oldest bundlers – dating back to a time when Node.js was still young and the whole idea of bundling was rather new. At this time, task runners were still dominantly used. However, the increasing complexity of frontend development opened the door for much more elaborate tooling.</p>
<p lang="en-GB">One thing that makes Webpack stand out is its ecosystem. From the very beginning, Webpack decided to develop only a very shallow core focusing on module resolution. In some sense, Webpack is just the wrapper holding all these plugins together with a fixed plan of execution. It pretty much combines the configuration that was thrown in by the user, with the power of all the selected plugins.</p>
<p lang="en-GB">Today, Webpack can also work without plugins or a configuration. At least in theory. In practice, every project that goes beyond some simple examples will require a bit of configuration. Also, interesting features such as support for other languages such as TypeScript will require a plugin.</p>
<p lang="en-GB">To get started with Webpack, we need to install the <code>webpack</code> and <code>webpack-cli</code> packages using npm:</p>
<pre class="console" lang="en-GB">
$ npm install webpack webpack-cli --save-dev</pre>
<p lang="en-GB">If we only wanted to use Webpack programmatically, such as from a Node.js script, then we could also spare the <code>webpack-cli</code> package installation.</p>
<p lang="en-GB">To run Webpack from the command line, you can use <code>npx</code> together with the <code>webpack</code> executable:</p>
<pre class="console" lang="en-GB">
$ npx webpack</pre>
<p lang="en-GB">Just running Webpack like this will not be successful:</p>
<pre class="console" lang="en-GB">
assets by status 0 bytes [cached] 1 asset

WARNING in configuration

The 'mode' option has not been set, webpack will fallback to 'production' for this value.

Set 'mode' option to 'development' or 'production' to enable defaults for each environment.

You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/

ERROR in main

Module not found: Error: Can't resolve './src' in '/home/node/examples/Chapter06/example01'

[...]

webpack 5.74.0 compiled with 1 error and 1 warning in 116 ms</pre>
<p lang="en-GB">Fixing the warning about <code>mode</code> is rather simple – all we need to do is to provide a CLI flag such as <code>--mode production</code>. The more problematic issue is that Webpack does not find any entry point.</p>
<p lang="en-GB">As mentioned already, there<a id="_idIndexMarker221"/> is a chance that Webpack may just work, but usually, we’ll be forced to create a configuration file. Webpack uses real Node.js modules to provide the configuration, which gives us the full power of the Node.js ecosystem. A Webpack configuration is called <code>webpack.config.js</code> and should be placed next to the <code>package.json</code> file.</p>
<p lang="en-GB">Let’s create a rather lightweight one. The highlighted property is one of Webpack’s fundamental configuration sections, telling the bundler what entry points to use:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
<pre class="source-code" lang="en-GB">module.exports = {
  <strong class="bold" lang="">entry</strong>: {
    app: "./src/script.tsx",
  },
};</pre>
<p lang="en-GB">Now, we can try running <a id="_idIndexMarker222"/>Webpack again:</p>
<pre class="console" lang="en-GB">
$ npx webpack --mode production

assets by status 360 bytes [cached] 1 asset

./src/script.tsx 185 bytes [built] [code generated] [1 error]

ERROR in ./src/script.tsx 5:54

Module parse failed: Unexpected token (5:54)

You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders

| import App from './App';

|

&gt; const root = createRoot(document.querySelector('#app')!);

| root.render(&lt;App /&gt;);

|

webpack 5.74.0 compiled with 1 error in 145 ms</pre>
<p lang="en-GB">This is better, but we’re still not there yet. Webpack requires a plugin to understand special files such as TypeScript or SASS sources. Therefore, we need to install these development dependencies, too. In this case, we require quite a list of plugins to make everything work:</p>
<ul>
<li lang="en-GB"><code>ts-loader</code> is a plugin for handling TypeScript files by transforming them into JavaScript</li>
<li lang="en-GB"><code>sass-loader</code> is a plugin for handling SASS files by transforming them into CSS</li>
<li lang="en-GB"><code>css-loader</code> is a plugin for handling CSS by transforming it into a text module</li>
<li lang="en-GB"><code>style-loader</code> is a plugin for handling CSS by transforming it into a JavaScript module</li>
<li lang="en-GB"><code>babel-loader</code> is a plugin for using Babel to transform JavaScript files with additional syntax (such as JSX) into plain JS</li>
<li lang="en-GB"><code>html-webpack-plugin</code> is a plugin for loading an HTML file as a template for the output HTML file</li>
</ul>
<p lang="en-GB">The big disadvantage of <a id="_idIndexMarker223"/>Webpack is that everything must be a JavaScript module in the end. Quite often, plugins perform some tricks to end up with empty modules, but they still emit the result (such as a separate image or CSS file) to the filesystem.</p>
<p lang="en-GB">You can install the remaining dependencies can be done from the command line:</p>
<pre class="console" lang="en-GB">
$ npm i ts-loader sass-loader css-loader style-loader babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin --save-dev</pre>
<p lang="en-GB">One thing we also need to supply is a proper <code>tsconfig.json</code>. Without this file, TypeScript won’t be configured correctly. The <code>ts-loader</code> plugin of Webpack works quite closely together with TypeScripts, so it requires this file to know what files to consider and which files to drop. It also uses this to properly transform the file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">tsconfig.json</p>
<pre class="source-code" lang="en-GB">{
  "compilerOptions": {
    "jsx": "react",
    <strong class="bold" lang="">"module": "ESNext"</strong>
  },
  "include": ["./src"],
  "exclude": ["./node_modules"]
}</pre>
<p lang="en-GB">In this configuration, TypeScript has been set up to process JSX in the default React way (that is, transforming JSX into <code>React.createElement</code> calls). The configuration will also output ESM module syntax (the highlighted option), which is important for Webpack to correctly<a id="_idIndexMarker224"/> identify imports and exports. Without this, bundle splitting won’t work if triggered from TypeScript files. Finally, we include all the files in the <code>src</code> folder and exclude the <code>node_modules</code> folder. The latter is a common practice to save a substantial amount of processing time.</p>
<p lang="en-GB">Now, to get all these things working together, we need to extend the Webpack configuration quite a bit. First, we need to import (that is, <code>require</code>) all the plugins that we’d like to use. In this case, we only want to use <code>html-webpack-plugin</code>. Next, we need to set up the rules for all the loaders we need to include. This is done via the <code>module.rules</code> array. Finally, we need to define what to do with the remaining assets.</p>
<p lang="en-GB">Let’s see how the Webpack configuration could be written to successfully bundle our example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
<pre class="source-code" lang="en-GB">const HtmlWebpackPlugin = require("html-webpack-plugin");
const babelLoader = { // make the config reusable
  loader: "babel-loader", // name of the loader
  options: { // the specific Babel options
    presets: ["@babel/preset-env", "@babel/preset-react"],
  },
};
const tsLoader = {
  loader: "ts-loader", // name of the loader
  options: { // the specific TypeScript loader options
    transpileOnly: true,
  },
};
module.exports = {
  entry: { // defines the entry points
    app: "./src/script.tsx", // named ("app") entry point
  },
  resolve: {
    // defines what extensions to try out for resolving
    extensions: [".ts", ".tsx", ".js", ".jsx", ".json"],
  },
  module: {
    // defines the rules for transforming modules
    rules: [
      { // applied for all *.scss files
        test: /\.scss$/i,
        use: ["style-loader", "css-loader", "sass-loader"],
      },
      { // applied for all *.css files
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
      { // applied for all *.js and *.jsx files
        test: /\.jsx?$/i,
        use: [babelLoader],
        exclude: /node_modules/,
      },
      { // applied for all *.ts and *.tsx files
        test: /\.tsx?$/i,
        use: [babelLoader, tsLoader],
      },
      { // applied for anything other than *.js, *.jsx, ...
        exclude: [/^$/, /\.(js|jsx|ts|tsx)$/i, /\.s?css$/i,
          /\.html$/i, /\.json$/i],
        <strong class="bold" lang="">type: "asset/resource"</strong>,
      },
    ],
  },
  // defines plugins to use for extending Webpack
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
  ],
};</pre>
<p lang="en-GB">The preceding code is quite lengthy. One of the often-heard criticisms of Webpack is that its configuration tends to become quite complex quickly.</p>
<p lang="en-GB">An important part of a Webpack configuration is the use of regular expressions. The <code>test</code> and <code>exclude</code> parts of a rule work best with a regular expression. Therefore, instead of having a string with some magic behavior or a very explicit and repetitive function, a regular expression is supplied that will check if the current module should be processed by this rule or not.</p>
<p lang="en-GB">The options for each<a id="_idIndexMarker225"/> loader or plugin are determined by the respective loader or plugin. Therefore, knowing Webpack is not sufficient to successfully write a Webpack configuration. You’ll always need to look up the documentation of the different parts that are used in the configuration. In the preceding configuration, this has been the case with the <code>ts-loader</code> and <code>babel-loader</code> configurations.</p>
<p lang="en-GB">Loaders are evaluated from right to left. For instance, in the case of <code>*.scss</code> files, the content is first transformed by <code>sass-loader</code>, which then hands over to <code>css-loader</code>. In the end, all the content is packaged up as a <code>style</code> tag by <code>style-loader</code>.</p>
<p lang="en-GB">We don’t always need to use a dedicated package for loaders. Using the <code>type</code> property highlighted in the previous code, we can use some premade loaders from Webpack, such as the resource loader (<code>asset/resource</code>) to return the paths to referenced files. Other options include data URIs (<code>asset/inline</code>) and accessing a file’s raw content (<code>asset/source</code>).</p>
<p lang="en-GB">Another way to use Webpack is to start a small server during development. Whenever we make updates to the code, the bundler can reprocess the changed parts and automatically update any active browsing sessions. All in all, this is a very convenient and quite productive way of writing a frontend application.</p>
<p lang="en-GB">For Webpack’s live server to work, we’ll need to install yet another tooling dependency:</p>
<pre class="console" lang="en-GB">
$ npm install webpack-dev-server --save-dev</pre>
<p lang="en-GB">This allows us to run the <code>serve</code> command:</p>
<pre class="console" lang="en-GB">
$ npx webpack serve --mode development

&lt;i&gt; [webpack-dev-server] Project is running at:

&lt;i&gt; [webpack-dev-server] Loopback: http://localhost:8081/

&lt;i&gt; [webpack-dev-server] On Your Network (IPv4): http://172.25.98.248:8081/

&lt;i&gt; [webpack-dev-server] Content not from webpack is served from '/home/node/examples/Chapter06/example01/public' directory

[...]

webpack 5.74.0 compiled successfully in 1911 ms</pre>
<p lang="en-GB">The live server will keep on running until it is forcefully shut down. On the command line, this can be done by pressing <em class="italic" lang="">Ctrl</em> + <em class="italic" lang="">C</em>.</p>
<p lang="en-GB">One thing to add to <code>webpack.config.js</code> would be the history API fallback for the development server (the <code>devServer</code> section in a Webpack configuration). This will improve the<a id="_idIndexMarker226"/> development experience of a SPA by a fair margin:</p>
<pre class="source-code" lang="en-GB">// ... like beforehand
module.exports = {
  // ... like beforehand
  devServer: {
    <strong class="bold" lang="">historyApiFallback: true</strong>,
  },
};</pre>
<p lang="en-GB">This setting will respond to all 404 URLs with <code>index.html</code> of the root directory – just like a SPA should be configured in production mode. This way, refreshing when being on a page with a different path than <code>/</code> will still work. Without the shown configuration, the 404 error will be shown in the browser – no SPA will load and handle the route.</p>
<p lang="en-GB">Now that we know how bundling the example application works in Webpack, it’s time to look at a more lightweight alternative named esbuild.</p>
<h1 id="_idParaDest-64" lang="en-GB"><a id="_idTextAnchor063"/>Using esbuild</h1>
<p lang="en-GB">esbuild is quite a new tool that <a id="_idIndexMarker227"/>focuses on performance. The key to esbuild’s enhanced performance is that it was written from the ground up in the Go programming language. The result is a native binary that has certain advantages over pure JavaScript solutions.</p>
<p lang="en-GB">If esbuild stopped at providing a native solution, it would potentially not be qualified to make this list. After all, flexibility and the option to extend the original functionality are key for any kind of bundler. Luckily, the creator of esbuild has thought about this and come up with an elegant solution. While the core of esbuild remains native – that is, written in Go and provided as a binary – plugins can be written using JavaScript. This way, we get the best of both worlds.</p>
<p lang="en-GB">To get started with esbuild, we need to install the <code>esbuild</code> package using npm:</p>
<pre class="console" lang="en-GB">
$ npm install esbuild --save-dev</pre>
<p lang="en-GB">With this one installation, you can use esbuild programmatically, as well as directly from the command line.</p>
<p lang="en-GB">To run esbuild from the command line, you can use <code>npx</code> together with the <code>esbuild</code> executable:</p>
<pre class="console" lang="en-GB">
$ npx esbuild</pre>
<p lang="en-GB">This will show all the CLI options. To do something, at least one entry point needs to be supplied:</p>
<pre class="console" lang="en-GB">
$ npx esbuild --bundle src/script.tsx --outdir=dist --minify

<img alt="" src="img/013.png"/> [ERROR] No loader is configured for ".scss" files: src/style.scss

    src/script.tsx:3:7:

      3 │ import './style.scss';

        <img alt="" src="img/02.png"/>        ~~~~~~~~~~~~~~

<img alt="" src="img/013.png"/> [ERROR] No loader is configured for ".mp3" files: src/sound.mp3

    src/Audio.tsx:4:22:

      4 │ import audioPath from "./sound.mp3";

        <img alt="" src="img/02.png"/>                       ~~~~~~~~~~~~~

[...]

5 errors</pre>
<p lang="en-GB">As expected, we miss a few configuration steps. As with Webpack, the best way to teach esbuild about these extra bits is by creating a configuration. Unlike Webpack, we do not have a predefined <a id="_idIndexMarker228"/>configuration file – instead, the way to configure esbuild is by using it programmatically.</p>
<p lang="en-GB">To do that, we must create a new file called <code>build.js</code> and import the <code>esbuild</code> package. We can use the <code>build</code> and <code>buildSync</code> functions to trigger the bundling process via esbuild.</p>
<p lang="en-GB">The previous CLI command can be written programmatically like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">build.js</p>
<pre class="source-code" lang="en-GB">const { build } = require("esbuild");
build({ // provide options to trigger esbuild's build
  entryPoints: ["./src/script.tsx"], // where to start from
  outdir: "./dist", // where to write the output to
  bundle: true, // bundle the resulting files
  minify: true, // turn on minification
});</pre>
<p lang="en-GB">Of course, the given script will essentially give us the same error as using the CLI directly. Therefore, let’s add a few things:</p>
<ul>
<li lang="en-GB"><code>esbuild-sass-plugin</code> integrates the transformation of SASS into CSS files</li>
<li lang="en-GB"><code>@craftamap/esbuild-plugin-html</code> allows us to use template HTML files</li>
</ul>
<p lang="en-GB">Before we can use these two plugins, we need to install them:</p>
<pre class="console" lang="en-GB">
$ npm i esbuild-sass-plugin @craftamap/esbuild-plugin-html ––save-dev</pre>
<p lang="en-GB">Once the plugins are installed, we can<a id="_idIndexMarker229"/> extend the <code>build.js</code> file so that it includes these two plugins:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">build.js</p>
<pre class="source-code" lang="en-GB">const { build } = require("esbuild");
const { sassPlugin } = require("esbuild-sass-plugin");
const { htmlPlugin } = require("@craftamap/esbuild-plugin-
  html");
build({
  entryPoints: ["./src/script.tsx"],
  outdir: "./dist",
  format: "esm", // use modern esm format for output
  bundle: true,
  minify: true,
  metafile: true, // required for htmlPlugin
  splitting: true, // allow lazy loading
  loader: {
    ".jpg": "file",
    ".webp": "file",
    ".mp3": "file",
    ".mp4": "file",
  },
  plugins: [
    sassPlugin(),
    htmlPlugin({
      files: [
        {
          entryPoints: ["./src/script.tsx"],
          filename: "index.html",
          scriptLoading: "module", // because of esm
          htmlTemplate: "./src/index.html",
        },
      ],
    }),
  ],
});</pre>
<p lang="en-GB">Along the way, we taught esbuild about our preference for the given file extensions. With the <code>loader</code> section, we map extensions to specific file loaders. The <code>file</code> type refers to a loader that <a id="_idIndexMarker230"/>will produce an external file. The import of that file will result in a reference to the file’s relative output path.</p>
<p lang="en-GB">To enable bundle splitting, the <code>splitting</code> option needs to be set. This also makes the use of the <code>esm</code> format necessary. It’s the only format where esbuild knows how to produce scripts that can lazy load something. Additionally, <code>htmlPlugin</code> requires esbuild to produce a metafile to reflect the build artifacts. Therefore, the <code>metafile</code> option needs to be set to <code>true</code>.</p>
<p lang="en-GB">Like Webpack, the ecosystem of esbuild is what makes this tool so flexible, yet hard to master. The options for the different plugins need to be collected from the different plugin documentation. Like the Webpack ecosystem beforehand, the quality of these plugins, as well as their maturity and the community behind them, varies a lot.</p>
<p lang="en-GB">If you want to have a development server – just like the one we added to Webpack in the previous section – you can use the <code>serve</code> function, which can be imported from <code>esbuild</code>. The first argument describes server-specific settings such as the port where the service should be listening. The second argument comprises the build options – that is, the options we are<a id="_idIndexMarker231"/> supplying right now – as the only argument to the <code>build</code> function.</p>
<p lang="en-GB">Let’s write another script called <code>serve.js</code> to illustrate this usage:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">serve.js</p>
<pre class="source-code" lang="en-GB">const { serve } = require("esbuild");
const { sassPlugin } = require("esbuild-sass-plugin");
const { htmlPlugin } = require("@craftamap/esbuild-plugin-
  html");
// use helper from esbuild to open a dev server
serve(
  {
    // will be reachable at http://localhost:1234
    port: 1234,
  },
  {
    // same options as beforehand (supplied to build())
    // ...
  }
);</pre>
<p lang="en-GB">One thing that esbuild does not do at the moment is HMR. Consequently, the developer’s experience of just using esbuild may be a little bit underwhelming in that area when compared to similar tools.</p>
<p lang="en-GB">With this in mind, let’s explore<a id="_idIndexMarker232"/> yet another option that is widely used for bundling – let’s have a look at the configuration-less Parcel bundler.</p>
<h1 id="_idParaDest-65" lang="en-GB"><a id="_idTextAnchor064"/>Using Parcel</h1>
<p lang="en-GB">When Parcel arrived in the community, the hype around it was massive. The reason for this was to be found in one<a id="_idIndexMarker233"/> new feature: configuration-free bundling. Parcel tried to leverage information that was already given in <code>package.json</code> – or configuration files written for specific tools such as Babel. Using this mechanism, the creators of Parcel thought to remove the complexity of configuring a bundler.</p>
<p lang="en-GB">Ultimately, however, the whole aspect backfired in some sense. As mentioned previously, a bundler requires some flexibility. To achieve this kind of flexibility, a sound configuration system is necessary. While the configuration system of Webpack is a bit too verbose and complex, the one provided with esbuild might be a bit too low-level.</p>
<p lang="en-GB">The successor of the original Parcel now also offers an optional configuration system, which tries to be right between the verbosity of Webpack and the low-level one of esbuild. This makes Parcel no longer configuration-free, but rather a configuration-less bundler.</p>
<p lang="en-GB">To get started with Parcel, we need to install the <code>parcel</code> package using npm:</p>
<pre class="console" lang="en-GB">
$ npm install parcel ––save-dev</pre>
<p lang="en-GB">With this installation, you can use Parcel programmatically, as well as directly from the command line.</p>
<p lang="en-GB">To run Parcel from the command line, you can use <code>npx</code> together with the <code>parcel</code> executable. For Parcel, the entry point can be the HTML file:</p>
<pre class="console" lang="en-GB">
$ npx parcel src/index.html</pre>
<p lang="en-GB">In our case, we still need to modify the HTML so that it also points to the other source files to continue building up the module graph. A version of the <code>index.html</code> file that fits much better with Parcel would look as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.html</p>
<pre class="source-code" lang="en-GB">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0"&gt;
    &lt;title&gt;Bundler Example&lt;/title&gt;
    &lt;link rel="stylesheet" href="./style.scss"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script type="module" src="img/script.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p lang="en-GB">Importantly, we’ve added<a id="_idIndexMarker234"/> the stylesheet and script entry points. These will be detected by Parcel and properly bundled. In the end, the HTML file will be used as a template – with the entry points being replaced by the bundled stylesheet and script file references.</p>
<p lang="en-GB">Starting Parcel right now will already partially work, but at this time, Parcel still has some problems with our audio and video files. While Parcel knows most image files (such as <code>*.webp</code> or <code>*.png</code>) already, some other assets need to be configured first. In Parcel, this means creating a <code>.parcelrc</code> file and adding a section about the transformers to use:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.parcelrc</p>
<pre class="source-code" lang="en-GB">{
  "extends": "@parcel/config-default",
  "transformers": {
    "*.{mp3,mp4}": ["@parcel/transformer-raw"]
  }
}</pre>
<p lang="en-GB">The configuration instructs Parcel to still rely on the very well-chosen defaults. However, we also added the definitions for the two file types in question to the section that handles the transformation logic. Like Webpack or esbuild, Parcel also has an in-built type to handle such imports by returning a filename that can be used within the code. In the case of Parcel, this type is called <code>@parcel/transformer-raw</code>.</p>
<p lang="en-GB">Now, let’s see if Parcel is already running:</p>
<pre class="console" lang="en-GB">
$ npx parcel src/index.html

Server running at http://localhost:1234

<img alt="" src="img/03.png"/> Built in 12ms</pre>
<p lang="en-GB">By default, Parcel will start a development server. This already contains everything that is needed for developing<a id="_idIndexMarker235"/> an application. Quite convenient. If we want to build the files – for example, to place the output artifacts on a server – we can use the <code>build</code> subcommand:</p>
<pre class="console" lang="en-GB">
$ npx parcel build src/index.html

<img alt="" src="img/03.png"/> Built in 6.11s

dist/index.html                  402 B    4.73s

dist/index.3429125f.css       39.02 KB    149ms

dist/index.cb13c36e.js       156.34 KB    1.90s

dist/Home.bf847a6b.js          1.05 KB    148ms

dist/river.813c1909.webp      29.61 KB    150ms

dist/snow.390b5a72.jpg        13.28 KB    138ms

dist/Video.987eca2d.js           908 B    1.90s

dist/earth.4475c69d.mp4     <img alt="" src="img/04.png"/>  1.5 MB     61ms

dist/Video.61df35c5.js       611.76 KB    4.62s

dist/Audio.677f10c0.js           908 B    149ms

dist/sound.6bdd55a4.mp3      746.27 KB     92ms</pre>
<p lang="en-GB">There are CLI flags and options to set almost everything, such as the output directory. Nevertheless, by default, the quite common <code>dist</code> folder is chosen.</p>
<p lang="en-GB">Last, but not least, let’s have<a id="_idIndexMarker236"/> a look at the quite trendy Vite bundler, which tries to combine the advantages of all previous approaches into a single tool.</p>
<h1 id="_idParaDest-66" lang="en-GB"><a id="_idTextAnchor065"/>Using Vite</h1>
<p lang="en-GB">The latest addition to the set of <a id="_idIndexMarker237"/>popular bundlers is Vite. It combines a few existing tools – such as Rollup.js and esbuild – together with a unified plugin system to allow rapid development. Vite’s approach is to give you the power of Webpack at the speed of esbuild.</p>
<p lang="en-GB">Originally, Vite was built by the creator of the frontend framework Vue. However, as time went on, Vite’s plugin system became a lot more powerful. With its increased API surface, other frontend frameworks such as React or Svelte could be supported. Now, Vite has evolved from a single-purpose tool to a real Swiss Army knife – thanks to a well-thought-out plugin mechanism with an active community.</p>
<p lang="en-GB">To get started with Vite, we need to install the <code>vite</code> package using npm:</p>
<pre class="console" lang="en-GB">
$ npm install vite --save-dev</pre>
<p lang="en-GB">With this installation, you can use Vite programmatically, as well as directly from the command line.</p>
<p lang="en-GB">One thing to know about Vite is that it embraces having an <code>index.html</code> file as an entry point even more than Parcel. For Vite to work as intended, we need to move the <code>index.html</code> file from the <code>src</code> folder to the parent directory – that is, the project’s root folder.</p>
<p lang="en-GB">As we did previously, we should set the references properly:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.html</p>
<pre class="source-code" lang="en-GB">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0"&gt;
    &lt;title&gt;Bundler Example&lt;/title&gt;
    &lt;link rel="stylesheet" href="./src/style.scss"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script type="module" src="img/script.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p lang="en-GB">To run Vite from<a id="_idIndexMarker238"/> the command line, you can use <code>npx</code> together with the <code>vite</code> executable:</p>
<pre class="console" lang="en-GB">
$ npx vite

  VITE v3.0.5  ready in 104 ms

  <img alt="" src="img/05.png"/>  Local:   http://localhost:5173/

  <img alt="" src="img/05.png"/>  Network: use --host to expose</pre>
<p lang="en-GB">This starts quickly as nothing has been bundled or transformed yet. Only when we hit the server will Vite start to transform things – and only the things that we are currently looking at. If you are interested in a more realistic picture, then the <code>preview</code> subcommand can be handy. It does a production build but exposes the outcome via the development server.</p>
<p lang="en-GB">Of course, like with <a id="_idIndexMarker239"/>Parcel, we can still produce files that can be placed on a server. Very similar to Parcel, we can do this with the <code>build</code> subcommand:</p>
<pre class="console" lang="en-GB">
$ npx vite build

vite v3.0.5 building for production...

<img alt="" src="img/06.png"/> 110 modules transformed.

dist/assets/river.4a5afeaf.webp   29.61 KiB

dist/assets/snow.cbc8141d.jpg     13.96 KiB

dist/assets/sound.fa282025.mp3    746.27 KiB

dist/assets/earth.71944d74.mp4    1533.23 KiB

dist/index.html                   0.42 KiB

dist/assets/Home.82897af9.js      0.45 KiB / gzip: 0.23 KiB

dist/assets/Video.ce9d6500.js     0.36 KiB / gzip: 0.26 KiB

[...]

dist/assets/index.404f5c02.js     151.37 KiB / gzip: 49.28 KiB

dist/assets/Player.c1f283e6.js    585.26 KiB / gzip: 166.45 KiB</pre>
<p lang="en-GB">For this example, Vite is the only bundler that just works – at least once all the prerequisites have been fulfilled. If you require a custom configuration, such as for adding some plugins, then you can follow Webpack’s approach and create a <code>vite.config.js</code> file in the project’s root folder.</p>
<p lang="en-GB">Now, let’s recap what you’ve learned in this chapter.</p>
<h1 id="_idParaDest-67" lang="en-GB"><a id="_idTextAnchor066"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned what a bundler is, why you need it, what bundlers exist, and how you can configure and use them. You are now able to take your web projects from their raw source code to build production-ready assets.</p>
<p lang="en-GB">Equipped with detailed knowledge about bundlers, you can create very reliable code bases that are tailored toward efficiency. Not only will unnecessary code be removed upon bundling, but also all referenced files will be processed and taken into consideration. Therefore, you’ll never have to worry about missing a file.</p>
<p lang="en-GB">The large variety of existing bundlers can be intimidating at first. While there are some obvious choices, such as the very popular Webpack bundler, other options may be even better due to less complexity or better performance, depending on the project you have at hand. If in doubt, you can refer to the <em class="italic" lang="">Comparing available bundlers</em> section of this chapter to ascertain which bundler might be the best fit for you.</p>
<p lang="en-GB">In the next chapter, we will take closer look at another category of crucial development tools. We’ll see how testing tools give us confidence that our code works as it should, both today and in the future.</p>
</div>
</body></html>