<html><head></head><body>
<div id="_idContainer070">
<h1 class="chapter-number" id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.2.1">Building Web Apps with Bundlers</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">In the previous chapter, we covered an important set of auxiliary tooling – linters and formatters. </span><span class="koboSpan" id="kobo.3.2">While code quality is important, the undoubtedly most important aspect of every project is what is shipped and used by the customer. </span><span class="koboSpan" id="kobo.3.3">This is the area where a special kind of tooling – called bundlers – </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">shines.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.5.1">A bundler is a tool that understands and processes source code to produce files that can be placed on a web server and are ready to be consumed by web browsers. </span><span class="koboSpan" id="kobo.5.2">It takes HTML, CSS, JavaScript, and related files into consideration to make them more efficient and readable. </span><span class="koboSpan" id="kobo.5.3">In this process, a bundler would merge, split, minify, and even translate code from one standard such as ES2020 into another standard such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.6.1">as ES5.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.7.1">Today, bundlers are no longer nice to have, but necessarily used for most projects directly or indirectly. </span><span class="koboSpan" id="kobo.7.2">Pretty much every web framework offers tooling that is built upon a bundler. </span><span class="koboSpan" id="kobo.7.3">Often, the challenge is to configure a bundler so that it understands our code base and does exactly what we’d expect it to do. </span><span class="koboSpan" id="kobo.7.4">Since web code bases are quite different, bundlers need to be flexible in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.8.1">many directions.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.9.1">In this chapter, you’ll build up an understanding of what bundlers do and how you can control their inner processes. </span><span class="koboSpan" id="kobo.9.2">We’ll also introduce the most important bundlers as of today, and see how they can be used and configured to work efficiently for us. </span><span class="koboSpan" id="kobo.9.3">This will help you get your web project from raw source code to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.10.1">production-ready artifacts.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.11.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.12.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.13.1">Understanding bundlers</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.14.1">Comparing the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.15.1">available bundlers</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.16.1">Using Webpack</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.17.1">Using esbuild</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.18.1">Using Parcel</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.19.1">Using Vite</span></span></li>
</ul>
<h1 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.21.1">The complete source code for this chapter is available </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.22.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.25.1">The CiA videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://bit.ly/3G0NiMX"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.27.1">https://bit.ly/3G0NiMX</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.29.1">Understanding bundlers</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.30.1">Writing a modern web</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.31.1"> application is quite difficult. </span><span class="koboSpan" id="kobo.31.2">One of the reasons for the level of difficulty is the large variety of different technologies that need to be involved in the process. </span><span class="koboSpan" id="kobo.31.3">Let’s just mention </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.32.1">a few:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.33.1">HTML for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.34.1">writing documents</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.35.1">CSS for styling </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.36.1">those documents</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.37.1">JavaScript with the DOM API to bring </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.38.1">some interactivity</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.39.1">A JavaScript UI framework to create </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.40.1">interactive components</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.41.1">A CSS preprocessor to use variables, nesting, and more features </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.42.1">for CSS</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.43.1">Potentially TypeScript or some other typed system to improve reliability in certain source </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.44.1">code areas</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.45.1">Service and web workers need to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.46.1">be mastered</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.47.1">All static files should be easy </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.48.1">to cache</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.49.1">Before the introduction of a new class of tooling that was capable of building up module graphs, dedicated</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.50.1"> task runners such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.51.1">Grunt</span></strong><span class="koboSpan" id="kobo.52.1"> or </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.53.1">Gulp</span></strong><span class="koboSpan" id="kobo.54.1"> were used. </span><span class="koboSpan" id="kobo.54.2">These runners were inspired by</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.55.1"> more generic</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.56.1"> approaches such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.57.1">Makefiles</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">The problem, however, was that two aspects – the build process and the source code – needed to be kept in sync. </span><span class="koboSpan" id="kobo.58.3">Just adding one file to the source code was not sufficient; the build process had to be informed about this new file. </span><span class="koboSpan" id="kobo.58.4">With bundlers, this </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.59.1">all changed.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.60.1">At its core, a bundler is a tool that leverages other tools. </span><span class="koboSpan" id="kobo.60.2">The most important addition is that a bundler understands the module graph – that is, the relationships (imports and exports) of code modules such as the CommonJS or ESM modules we discussed in the previous chapters. </span><span class="koboSpan" id="kobo.60.3">It can build up a module graph and use that to let other tools such as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.61.1">Babel work.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.62.1">To get started, a bundler</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.63.1"> requires so-called entry points – quite often, these are referred to as entries. </span><span class="koboSpan" id="kobo.63.2">These are files that are used as roots in the module graph. </span><span class="koboSpan" id="kobo.63.3">These files may depend on other files, in which case the bundler will continue in these files to build up the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.64.1">module graph.</span></span></p>
<p lang="en-GB"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.65.1">Figure 6</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.66.1">.1</span></em><span class="koboSpan" id="kobo.67.1"> shows an </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.68.1">example module graph constructed from two entry points. </span><span class="koboSpan" id="kobo.68.2">The interesting property of this graph is that the content of </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.69.1">Entry 2</span></strong><span class="koboSpan" id="kobo.70.1"> is fully contained in </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.71.1">Entry 1</span></strong><span class="koboSpan" id="kobo.72.1">, too. </span><span class="koboSpan" id="kobo.72.2">In many situations, there won’t be any significant overlap between the module graphs of multiple </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.73.1">entry points:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.74.1"><img alt="Figure 6.1 – Example module graph constructed from two entry points " src="image/Figure_6.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1">Figure 6.1 – Example module graph constructed from two entry points</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.76.1">Most bundlers work in phases. </span><span class="koboSpan" id="kobo.76.2">While each bundler uses slightly different terminology, they almost always come with the following </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.77.1">high-level phases:</span></span></p>
<ol>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.78.1">Module resolution</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.79.1">Module transformation</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.80.1">Chunk and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.81.1">asset generation</span></span></li>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.82.1">Applying optimizations</span></span></li>
</ol>
<p lang="en-GB"><span class="koboSpan" id="kobo.83.1">The module</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.84.1"> transformation is often necessary. </span><span class="koboSpan" id="kobo.84.2">On the one hand, the bundler needs to understand the module to find imported modules to build up the module graph; on the other hand, the chunk generation must rely on normalized </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.85.1">input modules.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.86.1">While the transformation phase needs to work hand-in-hand with a resolver to continuously build up the module graph, all other phases are pretty much independent. </span><span class="koboSpan" id="kobo.86.2">Quite often, the optimization phase is either reduced or fully disabled during development. </span><span class="koboSpan" id="kobo.86.3">This reduction helps speed up the bundling process by a fair margin. </span><span class="koboSpan" id="kobo.86.4">Additionally, further instructions that are quite helpful during debugging will </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.87.1">be kept.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.88.1">Minification</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.89.1">One of the most common optimizations</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.90.1"> is minification. </span><span class="koboSpan" id="kobo.90.2">The goal of minification is to make the files as small as possible without using active compression. </span><span class="koboSpan" id="kobo.90.3">While minification on the surface is rather easy and efficient in a language such as JavaScript, other languages such as CSS or HTML are a bit more problematic. </span><span class="koboSpan" id="kobo.90.4">Especially minification of HTML has been proven to be a hard problem without as many gains compared to the minification of JavaScript. </span><span class="koboSpan" id="kobo.90.5">After minification, files are usually not as readable as they were previously. </span><span class="koboSpan" id="kobo.90.6">One reason is the removal of unnecessary whitespace, which was introduced to give the original code readability </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.91.1">and structure.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.92.1">The whole bundling process can be sketched in a diagram. </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.93.1">Figure 6</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.94.1">.2</span></em><span class="koboSpan" id="kobo.95.1"> shows how the different entries enter the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.96.1">different phases:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.97.1"><img alt="Figure 6.2 – High-level phases of a modern web bundler " src="image/Figure_6.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.98.1">Figure 6.2 – High-level phases of a modern web bundler</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.99.1">Another thing to consider is that the chunk generation will mostly also introduce some kind of JavaScript runtime. </span><span class="koboSpan" id="kobo.99.2">This can</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.100.1"> be as lightweight as teaching the resulting code how to load additional bundles that have been created as script files, but it can also include full support for loading shared dependencies from foreign code and more. </span><span class="koboSpan" id="kobo.100.2">The introduced code is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.101.1">fully bundler-specific.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.102.1">With that in mind, let’s see what kind of bundlers are out there and how </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.103.1">they compare.</span></span></p>
<h1 id="_idParaDest-62" lang="en-GB"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.104.1">Comparing available bundlers</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.105.1">There are multiple</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.106.1"> generations of bundlers. </span><span class="koboSpan" id="kobo.106.2">The first generation was centered around the belief that Node.js applications are the only kind of applications that should be written. </span><span class="koboSpan" id="kobo.106.3">Therefore, changing these applications into JavaScript files that work in the browser has been the primary concern of the bundlers from that generation. </span><span class="koboSpan" id="kobo.106.4">The most </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.107.1">popular one in that category </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.108.1">is </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.109.1">Browserify</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.110.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.111.1">The second generation went on to extend the idea from the first generation to pretty much all JavaScript code. </span><span class="koboSpan" id="kobo.111.2">Here, even HTML and CSS assets could be understood. </span><span class="koboSpan" id="kobo.111.3">For instance, using </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.112.1">@import</span></strong><span class="koboSpan" id="kobo.113.1"> rules in CSS would extend the module graph to another CSS module. </span><span class="koboSpan" id="kobo.113.2">Importantly, while the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.114.1">CommonJS</span></em><span class="koboSpan" id="kobo.115.1"> (or later on, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.116.1">ESM</span></em><span class="koboSpan" id="kobo.117.1">) syntax was still used to derive the JavaScript module graph, these second-generation bundlers did not care about Node.js. </span><span class="koboSpan" id="kobo.117.2">They always assumed that the code was written for the browser. </span><span class="koboSpan" id="kobo.117.3">Quite often, however, you could change the target and also bundle code for Node.js with them. </span><span class="koboSpan" id="kobo.117.4">The most popular one in</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.118.1"> this category is </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.119.1">Webpack</span></strong><span class="koboSpan" id="kobo.120.1">, even though Webpack always tried to go with the times </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.121.1">and adapt.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.122.1">Third-generation bundlers introduced a much-improved user experience. </span><span class="koboSpan" id="kobo.122.2">They tried to find a native or obvious way of handling things and often did not even require any configuration. </span><span class="koboSpan" id="kobo.122.3">The most popular tool in this category is the original </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.123.1">Parcel</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.124.1"> bundler.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.125.1">The current fourth-generation bundlers are all about performance. </span><span class="koboSpan" id="kobo.125.2">They either come with a dedicated runtime or sit on top of natively written tooling, which usually outperforms their older JavaScript-written </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.126.1">counterparts. </span><span class="koboSpan" id="kobo.126.2">Here, we see tools such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.127.1">esbuild</span></strong><span class="koboSpan" id="kobo.128.1"> or experimental</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.129.1"> runtimes such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.130.1">as </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.131.1">Bun</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.132.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.133.1">The big question is: When should you use what? </span><span class="koboSpan" id="kobo.133.2">With half a dozen popular bundlers and more available, the question is not easy to answer. </span><span class="koboSpan" id="kobo.133.3">Surely, if a team is already really familiar with one of the options, then going with it for a project is very often the right choice. </span><span class="koboSpan" id="kobo.133.4">Otherwise, look for similar projects and try to understand what bundler they picked – and why. </span><span class="koboSpan" id="kobo.133.5">In any other case, you could use the following catalog of questions to identify which bundler might be the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.134.1">best option:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.135.1">What kind of assets are involved? </span><span class="koboSpan" id="kobo.135.2">If only JavaScript is involved, then Webpack might be good. </span><span class="koboSpan" id="kobo.135.3">If you have</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.136.1"> multiple HTML pages that all need to be processed, then </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.137.1">Vite</span></strong><span class="koboSpan" id="kobo.138.1"> might be a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.139.1">great option.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.140.1">How many dependencies are you using? </span><span class="koboSpan" id="kobo.140.2">Especially when you use older libraries from npm, a bundler with a broad range of support – such as Webpack – may be the best choice. </span><span class="koboSpan" id="kobo.140.3">Otherwise, look for faster options, such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.141.1">as esbuild.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.142.1">How familiar is the team with bundlers and their options? </span><span class="koboSpan" id="kobo.142.2">If the team is not familiar with bundling at all, then Parcel could be a great way to get started. </span><span class="koboSpan" id="kobo.142.3">Otherwise, Webpack potentially has the most documentation out there. </span><span class="koboSpan" id="kobo.142.4">A community that is rather new and very active and helpful can be found </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.143.1">with Vite.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.144.1">Are you building</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.145.1"> an application or just want to optimize the assets of a library? </span><span class="koboSpan" id="kobo.145.2">Especially for a library, something smaller, such as esbuild, might be useful. </span><span class="koboSpan" id="kobo.145.3">On the other hand, Parcel has a lot to offer here, too. </span><span class="koboSpan" id="kobo.145.4">In general, Vite should be avoided for libraries. </span><span class="koboSpan" id="kobo.145.5">Support is there, but it just does not feel to be ready yet for building libraries more efficiently than Rollup.js </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.146.1">and esbuild.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.147.1">Do you need support for advanced scenarios such as offline mode or web workers? </span><span class="koboSpan" id="kobo.147.2">In these cases, the ecosystem of Webpack is very often hard to beat. </span><span class="koboSpan" id="kobo.147.3">Parcel also does a good job of offering helpers in this area. </span><span class="koboSpan" id="kobo.147.4">esbuild should be avoided for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.148.1">such scenarios.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.149.1">How important is performance? </span><span class="koboSpan" id="kobo.149.2">If you have a larger code base (above 1,000 modules or 100,000 lines of code), then Webpack is known to be a performance killer, taking easily 30 seconds to minutes. </span><span class="koboSpan" id="kobo.149.3">Picking something such as Vite or – if possible – esbuild will certainly help speed up the process. </span><span class="koboSpan" id="kobo.149.4">While the former is more developer friendly, it also </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.150.1">comes with a lot of hidden complexity. </span><span class="koboSpan" id="kobo.150.2">The</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.151.1"> latter is more direct but lacks standard features such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.152.1">hot-module </span></strong><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.153.1">reloading</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.154.1"> (</span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.155.1">HMR</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.156.1">).</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.157.1">How much maintenance is acceptable? </span><span class="koboSpan" id="kobo.157.2">Bundlers that rely on a lot of plugins are traditionally much harder to maintain. </span><span class="koboSpan" id="kobo.157.3">Upgrading Webpack to the next major version has been notoriously difficult. </span><span class="koboSpan" id="kobo.157.4">From missing plugins to breaking changes in the plugin’s API – everything that can happen will also happen in such cases. </span><span class="koboSpan" id="kobo.157.5">Prefer bundlers such as Parcel or Vite that try to come with everything necessary out of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.158.1">the box.</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.159.1">How important are additional development features such as bundle insights? </span><span class="koboSpan" id="kobo.159.2">If these are supercritical, then nothing is better than Webpack. </span><span class="koboSpan" id="kobo.159.3">As the Webpack ecosystem is super large, you’ll find additional tools, libraries, and guides easily. </span><span class="koboSpan" id="kobo.159.4">On the other hand, choosing something with a growing community such as Vite might also work </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.160.1">fine. </span><span class="koboSpan" id="kobo.160.2">If something is missing, the community should be capable of picking it up </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.161.1">quickly, too.</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.162.1">In the following sections, we’ll go over an example project to see how some of the most popular bundlers can be used to build it. </span><span class="koboSpan" id="kobo.162.2">We’ll use a project with a small, but non-trivial code base. </span><span class="koboSpan" id="kobo.162.3">For this</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.163.1"> example, we’ll use </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.164.1">React</span></strong><span class="koboSpan" id="kobo.165.1"> – but don’t worry, you don’t need to know React to follow </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.166.1">this chapter.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.167.1">React</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.168.1">React is arguably the most popular UI library for web frontend development. </span><span class="koboSpan" id="kobo.168.2">It allows developers to build UIs quickly in JavaScript by leveraging a language extension known as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.169.1">JSX</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">By using JSX, we can write</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.171.1"> code that looks quite similar to HTML but is transpiled to JavaScript function calls. </span><span class="koboSpan" id="kobo.171.2">In React, the basic building block of the UI is a component, which is very often just a plain JavaScript function. </span><span class="koboSpan" id="kobo.171.3">By convention, the names of components usually start with an uppercase letter; for example, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.172.1">Button</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.173.1">or </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.174.1">Carousel</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.175.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.176.1">The code base for the example we’ll cover consists of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.177.1">the following:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.178.1">The source </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.179.1">code of a </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.180.1">single-page </span></strong><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.181.1">application</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.182.1"> (</span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.183.1">SPA</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.184.1">)</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.185.1">An </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.186.1">HTML</span></strong><span class="koboSpan" id="kobo.187.1"> file as the entry point (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.188.1">index.html</span></strong><span class="koboSpan" id="kobo.189.1">) of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.190.1">the SPA</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.191.1">Several asset files (videos, images in different </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.192.1">formats, audio)</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.193.1">Several </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.194.1">non-trivial dependencies</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.195.1">Some files that use TypeScript instead </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.196.1">of JavaScript</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.197.1">A special </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.198.1">CSS</span></strong><span class="koboSpan" id="kobo.199.1"> preprocessor </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.200.1">called </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.201.1">SASS</span></strong></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.202.1">A web framework (React with React Router) is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.203.1">being used</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.204.1">Different virtual routes should lead to different pieces of the page that have to be </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.205.1">lazy loaded</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.206.1">All in all, this example </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.207.1">should produce a small demo application that contains a video and audio player that uses </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.208.1">third-party dependencies.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.209.1">Lazy loading</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.210.1">Lazy loading describes a technique </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.211.1">where not all parts required by an application are loaded immediately. </span><span class="koboSpan" id="kobo.211.2">For a SPA, this makes sense – after all, not every component or part of the SPA will be required for the current user interaction. </span><span class="koboSpan" id="kobo.211.3">And even if it isn’t required, it could be at some later point in time. </span><span class="koboSpan" id="kobo.211.4">Lazy loading usually involves loading additional script (or other) files when some action such as a user clicking on a button or following some internal link is performed. </span><span class="koboSpan" id="kobo.211.5">The implementation of lazy loading needs to be supported by the respective UI framework (for example, React has a function called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.212.1">lazy</span></strong><span class="koboSpan" id="kobo.213.1">) but is done by </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.214.1">the bundler.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.215.1">The boilerplate for this example can be created by initializing a new </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.216.1">Node.js project:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.217.1">
$ npm init -y</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.218.1">Now, we’ll add all the runtime dependencies – that is, the packages that will be required when our application runs in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.219.1">the browser:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.220.1">
$ npm i react react-dom react-router-dom video.js --save</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.221.1">At the end of the day, it will be the job of the bundler to add the preceding dependencies to scripts that can be run in the browser. </span><span class="koboSpan" id="kobo.221.2">However, for us, it makes sense to do this to get a clear view of which packages are just required for the tooling, and which dependencies are needed for the code </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.222.1">to run.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.223.1">The basic </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.224.1">devDependencies</span></strong><span class="koboSpan" id="kobo.225.1"> – that is, the ones that are required for the tooling – are </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.226.1">as follows:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.227.1">
$ npm i typescript sass @types/react @types/react-dom --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.228.1">Additional tooling dependencies are required, too, but will </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.229.1">be bundler-specific.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.230.1">The example application contains the following </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.231.1">source files:</span></span></p>
<ul>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.232.1">index.html</span></strong><span class="koboSpan" id="kobo.233.1">: Template for the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.234.1">SPA website</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.235.1">script.tsx</span></strong><span class="koboSpan" id="kobo.236.1">: Starts to run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.237.1">the application</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.238.1">App.tsx</span></strong><span class="koboSpan" id="kobo.239.1">: The </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.240.1">application root</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.241.1">Layout.tsx</span></strong><span class="koboSpan" id="kobo.242.1">: The layout of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.243.1">the application</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.244.1">Home.tsx</span></strong><span class="koboSpan" id="kobo.245.1">: The home page containing links to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.246.1">all pages</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.247.1">Video.tsx</span></strong><span class="koboSpan" id="kobo.248.1">: The page containing the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.249.1">video player</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.250.1">Audio.tsx</span></strong><span class="koboSpan" id="kobo.251.1">: The page containing the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.252.1">audio player</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.253.1">Player.jsx</span></strong><span class="koboSpan" id="kobo.254.1">: The React component for the video and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.255.1">audio player</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.256.1">earth.mp4</span></strong><span class="koboSpan" id="kobo.257.1">: Video file </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.258.1">to play</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.259.1">river.webp</span></strong><span class="koboSpan" id="kobo.260.1">: Preview image (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.261.1">.webp</span></strong><span class="koboSpan" id="kobo.262.1"> format) for the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.263.1">video file</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.264.1">snow.jpg</span></strong><span class="koboSpan" id="kobo.265.1">: Preview image (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.266.1">.jpg</span></strong><span class="koboSpan" id="kobo.267.1"> format) for the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.268.1">sound file</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.269.1">sound.mp3</span></strong><span class="koboSpan" id="kobo.270.1">: Audio file </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.271.1">to play</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.272.1">The process of showing a UI is </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.273.1">usually called rendering. </span><span class="koboSpan" id="kobo.273.2">When React first renders the application, it needs to mount its component tree on the DOM tree. </span><span class="koboSpan" id="kobo.273.3">This is done in the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.274.1">script.tsx</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.275.1"> file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">script.tsx</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.277.1">import * as React from 'react';
import { createRoot } from 'react-dom/client';
import './style.scss';
import App from './App';
const root = createRoot(document.querySelector('#app')!);
root.render(&lt;App /&gt;);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.278.1">The usage of angle brackets for initiating </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.279.1">App</span></strong><span class="koboSpan" id="kobo.280.1"> is referred to as JSX. </span><span class="koboSpan" id="kobo.280.2">Under the hood, the additional </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.281.1">x</span></strong><span class="koboSpan" id="kobo.282.1"> in the file extension (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.283.1">tsx</span></strong><span class="koboSpan" id="kobo.284.1">) enables such expressions to be processed, where </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.285.1">&lt;App /&gt;</span></strong><span class="koboSpan" id="kobo.286.1"> will be transformed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.287.1">into </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.288.1">React.createElement(App)</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.289.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.290.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.291.1">App</span></strong><span class="koboSpan" id="kobo.292.1"> component </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.293.1">itself is defined </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.294.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.295.1">App.tsx</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.296.1">import * as React from "react";
import { BrowserRouter, Route, Routes } from
  "react-router-dom";
import Layout from "./Layout";
const Home = React.lazy(() =&gt; import("./Home"));
const Video = React.lazy(() =&gt; import("./Video"));
const Audio = React.lazy(() =&gt; import("./Audio"));
const App = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
        &lt;Route index element={&lt;Home /&gt;} /&gt;
        &lt;Route path="video" element={&lt;Video /&gt;} /&gt;
        &lt;Route path="audio" element={&lt;Audio /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);
export default App;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.297.1">This kind of structure is</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.298.1"> typical for a SPA. </span><span class="koboSpan" id="kobo.298.2">All the different routes come together in a router or root component to be displayed when a certain path is found. </span><span class="koboSpan" id="kobo.298.3">For instance, in our application, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.299.1">/video</span></strong><span class="koboSpan" id="kobo.300.1"> path would show the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.301.1">Video</span></strong><span class="koboSpan" id="kobo.302.1"> component, while the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.303.1">/audio</span></strong><span class="koboSpan" id="kobo.304.1"> path would show the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.305.1">Audio</span></strong><span class="koboSpan" id="kobo.306.1"> component. </span><span class="koboSpan" id="kobo.306.2">All these components will be embedded in a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.307.1">Layout</span></strong><span class="koboSpan" id="kobo.308.1"> component, which is responsible for the general layout, such as showing the header and the footer, of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.309.1">the application.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.310.1">In the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.311.1">App.tsx</span></strong><span class="koboSpan" id="kobo.312.1"> file, lazy loading is initiated by using the ESM </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.313.1">import</span></strong><span class="koboSpan" id="kobo.314.1"> function. </span><span class="koboSpan" id="kobo.314.2">Bundlers should be capable of transforming that into loading another script and returning a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.315.1">Promise</span></strong><span class="koboSpan" id="kobo.316.1"> at </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.317.1">that location.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.318.1">Promises</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.319.1">The specification describes an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.320.1">import</span></strong><span class="koboSpan" id="kobo.321.1"> function to return a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.322.1">Promise</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">A </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.324.1">Promise</span></strong><span class="koboSpan" id="kobo.325.1"> is an object that can be used to determine when an asynchronous operation is finished. </span><span class="koboSpan" id="kobo.325.2">The object exposes functions, which are called with the result of the asynchronous operation or with an error that was thrown during the operation. </span><span class="koboSpan" id="kobo.325.3">The most important functions are </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.326.1">then</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.328.1">catch</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">The former can be used to define what to do when something is successfully returned, while the latter can be used to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.330.1">handle errors.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.331.1">In a SPA, it makes sense to put every page in a router into lazy loading. </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.332.1">Figure 6</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.333.1">.3</span></em><span class="koboSpan" id="kobo.334.1"> shows a high-level overview of the example application’s modules. </span><span class="koboSpan" id="kobo.334.2">The dashed boxes indicate bundling areas – that is, source files that can be grouped into combined output files. </span><span class="koboSpan" id="kobo.334.3">This bundling is one of the most crucial aspects of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.335.1">any bundler:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.336.1"><img alt="Figure 6.3 – The example application’s modules " src="image/Figure_6.3_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.337.1">Figure 6.3 – The example application’s modules</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.338.1">While some of the given</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.339.1"> aspects should be rather simple to implement in a bundler, other properties of the example application might be challenging. </span><span class="koboSpan" id="kobo.339.2">For instance, what is the behavior of a bundler when duplicate modules are found? </span><span class="koboSpan" id="kobo.339.3">Some bundlers may duplicate the generated code while others may create a shared bundle that is a loading prerequisite for the generated </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.340.1">side bundles.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.341.1">In the case of this example, we can see that </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.342.1">Player.jsx</span></strong><span class="koboSpan" id="kobo.343.1"> appears twice. </span><span class="koboSpan" id="kobo.343.2">We’ll use this to answer the question for </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.344.1">each bundler. </span><span class="koboSpan" id="kobo.344.2">Furthermore, pretty much every module requires </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.345.1">react</span></strong><span class="koboSpan" id="kobo.346.1">; however, since it is already required in the initial script module (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.347.1">script.tsx</span></strong><span class="koboSpan" id="kobo.348.1">), it should not </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.349.1">be duplicated.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.350.1">Without further ado, let’s see how this example application can be bundled </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.351.1">using Webpack.</span></span></p>
<h1 id="_idParaDest-63" lang="en-GB"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.352.1">Using Webpack</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.353.1">Webpack is presumably the most </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.354.1">popular option among the available bundlers. </span><span class="koboSpan" id="kobo.354.2">It is also among the oldest bundlers – dating back to a time when Node.js was still young and the whole idea of bundling was rather new. </span><span class="koboSpan" id="kobo.354.3">At this time, task runners were still dominantly used. </span><span class="koboSpan" id="kobo.354.4">However, the increasing complexity of frontend development opened the door for much more </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.355.1">elaborate tooling.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.356.1">One thing that makes Webpack stand out is its ecosystem. </span><span class="koboSpan" id="kobo.356.2">From the very beginning, Webpack decided to develop only a very shallow core focusing on module resolution. </span><span class="koboSpan" id="kobo.356.3">In some sense, Webpack is just the wrapper holding all these plugins together with a fixed plan of execution. </span><span class="koboSpan" id="kobo.356.4">It pretty much combines the configuration that was thrown in by the user, with the power of all the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.357.1">selected plugins.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.358.1">Today, Webpack can also work without plugins or a configuration. </span><span class="koboSpan" id="kobo.358.2">At least in theory. </span><span class="koboSpan" id="kobo.358.3">In practice, every project that goes beyond some simple examples will require a bit of configuration. </span><span class="koboSpan" id="kobo.358.4">Also, interesting features such as support for other languages such as TypeScript will require </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.359.1">a plugin.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.360.1">To get started with Webpack, we need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.361.1">webpack</span></strong><span class="koboSpan" id="kobo.362.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.363.1">webpack-cli</span></strong><span class="koboSpan" id="kobo.364.1"> packages </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.365.1">using npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.366.1">
$ npm install webpack webpack-cli --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.367.1">If we only wanted to use Webpack programmatically, such as from a Node.js script, then we could also spare the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.368.1">webpack-cli</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.369.1">package installation.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.370.1">To run Webpack from the command line, you can use </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.371.1">npx</span></strong><span class="koboSpan" id="kobo.372.1"> together with the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.373.1">webpack</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.374.1"> executable:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.375.1">
$ npx webpack</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.376.1">Just running Webpack like this will not </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.377.1">be successful:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.378.1">
assets by status 0 bytes [cached] 1 asset

WARNING in configuration

The 'mode' option has not been set, webpack will fallback to 'production' for this value.

</span><span class="koboSpan" id="kobo.378.2">Set 'mode' option to 'development' or 'production' to enable defaults for each environment.

</span><span class="koboSpan" id="kobo.378.3">You can also set it to 'none' to disable any default behavior. </span><span class="koboSpan" id="kobo.378.4">Learn more: https://webpack.js.org/configuration/mode/

ERROR in main

Module not found: Error: Can't resolve './src' in '/home/node/examples/Chapter06/example01'

[...]

webpack 5.74.0 compiled with 1 error and 1 warning in 116 ms</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.379.1">Fixing the warning about </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.380.1">mode</span></strong><span class="koboSpan" id="kobo.381.1"> is rather simple – all we need to do is to provide a CLI flag such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.382.1">--mode production</span></strong><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">The more problematic issue is that Webpack does not find any </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.384.1">entry point.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.385.1">As mentioned already, there</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.386.1"> is a chance that Webpack may just work, but usually, we’ll be forced to create a configuration file. </span><span class="koboSpan" id="kobo.386.2">Webpack uses real Node.js modules to provide the configuration, which gives us the full power of the Node.js ecosystem. </span><span class="koboSpan" id="kobo.386.3">A Webpack configuration is called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.387.1">webpack.config.js</span></strong><span class="koboSpan" id="kobo.388.1"> and should be placed next to the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.389.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.390.1"> file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.391.1">Let’s create a rather lightweight one. </span><span class="koboSpan" id="kobo.391.2">The highlighted property is one of Webpack’s fundamental configuration sections, telling the bundler what entry points </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.392.1">to use:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.393.1">webpack.config.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.394.1">module.exports = {
  </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.395.1">entry</span></strong><span class="koboSpan" id="kobo.396.1">: {
    app: "./src/script.tsx",
  },
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.397.1">Now, we can try running </span><a id="_idIndexMarker222"/><span class="No-Break" lang=""><span class="koboSpan" id="kobo.398.1">Webpack again:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.399.1">
$ npx webpack --mode production

assets by status 360 bytes [cached] 1 asset

./src/script.tsx 185 bytes [built] [code generated] [1 error]

ERROR in ./src/script.tsx 5:54

Module parse failed: Unexpected token (5:54)

You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. </span><span class="koboSpan" id="kobo.399.2">See https://webpack.js.org/concepts#loaders

| import App from './App';

|

&gt; const root = createRoot(document.querySelector('#app')!);

| root.render(&lt;App /&gt;);

|

webpack 5.74.0 compiled with 1 error in 145 ms</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.400.1">This is better, but we’re still not there yet. </span><span class="koboSpan" id="kobo.400.2">Webpack requires a plugin to understand special files such as TypeScript or SASS sources. </span><span class="koboSpan" id="kobo.400.3">Therefore, we need to install these development dependencies, too. </span><span class="koboSpan" id="kobo.400.4">In this case, we require quite a list of plugins to make </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.401.1">everything work:</span></span></p>
<ul>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.402.1">ts-loader</span></strong><span class="koboSpan" id="kobo.403.1"> is a plugin for handling TypeScript files by transforming them </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.404.1">into JavaScript</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.405.1">sass-loader</span></strong><span class="koboSpan" id="kobo.406.1"> is a plugin for handling SASS files by transforming them </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.407.1">into CSS</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.408.1">css-loader</span></strong><span class="koboSpan" id="kobo.409.1"> is a plugin for handling CSS by transforming it into a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.410.1">text module</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.411.1">style-loader</span></strong><span class="koboSpan" id="kobo.412.1"> is a plugin for handling CSS by transforming it into a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.413.1">JavaScript module</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.414.1">babel-loader</span></strong><span class="koboSpan" id="kobo.415.1"> is a plugin for using Babel to transform JavaScript files with additional syntax (such as JSX) into </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.416.1">plain JS</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.417.1">html-webpack-plugin</span></strong><span class="koboSpan" id="kobo.418.1"> is a plugin for loading an HTML file as a template for the output </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.419.1">HTML file</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.420.1">The big disadvantage of </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.421.1">Webpack is that everything must be a JavaScript module in the end. </span><span class="koboSpan" id="kobo.421.2">Quite often, plugins perform some tricks to end up with empty modules, but they still emit the result (such as a separate image or CSS file) to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.422.1">the filesystem.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.423.1">You can install the remaining dependencies can be done from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.424.1">command line:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.425.1">
$ npm i ts-loader sass-loader css-loader style-loader babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.426.1">One thing we also need to supply is a proper </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.427.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">Without this file, TypeScript won’t be configured correctly. </span><span class="koboSpan" id="kobo.428.3">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.429.1">ts-loader</span></strong><span class="koboSpan" id="kobo.430.1"> plugin of Webpack works quite closely together with TypeScripts, so it requires this file to know what files to consider and which files to drop. </span><span class="koboSpan" id="kobo.430.2">It also uses this to properly transform </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.431.1">the file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">tsconfig.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.433.1">{
  "compilerOptions": {
    "jsx": "react",
    </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.434.1">"module": "ESNext"</span></strong><span class="koboSpan" id="kobo.435.1">
  },
  "include": ["./src"],
  "exclude": ["./node_modules"]
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.436.1">In this configuration, TypeScript has been set up to process JSX in the default React way (that is, transforming JSX into </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.437.1">React.createElement</span></strong><span class="koboSpan" id="kobo.438.1"> calls). </span><span class="koboSpan" id="kobo.438.2">The configuration will also output ESM module syntax (the highlighted option), which is important for Webpack to correctly</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.439.1"> identify imports and exports. </span><span class="koboSpan" id="kobo.439.2">Without this, bundle splitting won’t work if triggered from TypeScript files. </span><span class="koboSpan" id="kobo.439.3">Finally, we include all the files in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.440.1">src</span></strong><span class="koboSpan" id="kobo.441.1"> folder and exclude the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.442.1">node_modules</span></strong><span class="koboSpan" id="kobo.443.1"> folder. </span><span class="koboSpan" id="kobo.443.2">The latter is a common practice to save a substantial amount of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.444.1">processing time.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.445.1">Now, to get all these things working together, we need to extend the Webpack configuration quite a bit. </span><span class="koboSpan" id="kobo.445.2">First, we need to import (that is, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.446.1">require</span></strong><span class="koboSpan" id="kobo.447.1">) all the plugins that we’d like to use. </span><span class="koboSpan" id="kobo.447.2">In this case, we only want to use </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.448.1">html-webpack-plugin</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">Next, we need to set up the rules for all the loaders we need to include. </span><span class="koboSpan" id="kobo.449.3">This is done via the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.450.1">module.rules</span></strong><span class="koboSpan" id="kobo.451.1"> array. </span><span class="koboSpan" id="kobo.451.2">Finally, we need to define what to do with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.452.1">remaining assets.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.453.1">Let’s see how the Webpack configuration could be written to successfully bundle </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.454.1">our example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">webpack.config.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.456.1">const HtmlWebpackPlugin = require("html-webpack-plugin");
const babelLoader = { // make the config reusable
  loader: "babel-loader", // name of the loader
  options: { // the specific Babel options
    presets: ["@babel/preset-env", "@babel/preset-react"],
  },
};
const tsLoader = {
  loader: "ts-loader", // name of the loader
  options: { // the specific TypeScript loader options
    transpileOnly: true,
  },
};
module.exports = {
  entry: { // defines the entry points
    app: "./src/script.tsx", // named ("app") entry point
  },
  resolve: {
    // defines what extensions to try out for resolving
    extensions: [".ts", ".tsx", ".js", ".jsx", ".json"],
  },
  module: {
    // defines the rules for transforming modules
    rules: [
      { // applied for all *.scss files
        test: /\.scss$/i,
        use: ["style-loader", "css-loader", "sass-loader"],
      },
      { // applied for all *.css files
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
      { // applied for all *.js and *.jsx files
        test: /\.jsx?$/i,
        use: [babelLoader],
        exclude: /node_modules/,
      },
      { // applied for all *.ts and *.tsx files
        test: /\.tsx?$/i,
        use: [babelLoader, tsLoader],
      },
      { // applied for anything other than *.js, *.jsx, ...
</span><span class="koboSpan" id="kobo.456.2">        exclude: [/^$/, /\.(js|jsx|ts|tsx)$/i, /\.s?css$/i,
          /\.html$/i, /\.json$/i],
        </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.457.1">type: "asset/resource"</span></strong><span class="koboSpan" id="kobo.458.1">,
      },
    ],
  },
  // defines plugins to use for extending Webpack
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html",
    }),
  ],
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.459.1">The preceding code is quite lengthy. </span><span class="koboSpan" id="kobo.459.2">One of the often-heard criticisms of Webpack is that its configuration tends to become quite </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.460.1">complex quickly.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.461.1">An important part of a Webpack configuration is the use of regular expressions. </span><span class="koboSpan" id="kobo.461.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.462.1">test</span></strong><span class="koboSpan" id="kobo.463.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.464.1">exclude</span></strong><span class="koboSpan" id="kobo.465.1"> parts of a rule work best with a regular expression. </span><span class="koboSpan" id="kobo.465.2">Therefore, instead of having a string with some magic behavior or a very explicit and repetitive function, a regular expression is supplied that will check if the current module should be processed by this rule </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.466.1">or not.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.467.1">The options for each</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.468.1"> loader or plugin are determined by the respective loader or plugin. </span><span class="koboSpan" id="kobo.468.2">Therefore, knowing Webpack is not sufficient to successfully write a Webpack configuration. </span><span class="koboSpan" id="kobo.468.3">You’ll always need to look up the documentation of the different parts that are used in the configuration. </span><span class="koboSpan" id="kobo.468.4">In the preceding configuration, this has been the case with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.469.1">ts-loader</span></strong><span class="koboSpan" id="kobo.470.1"> and </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.471.1">babel-loader</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.472.1"> configurations.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.473.1">Loaders are evaluated from right to left. </span><span class="koboSpan" id="kobo.473.2">For instance, in the case of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.474.1">*.scss</span></strong><span class="koboSpan" id="kobo.475.1"> files, the content is first transformed by </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.476.1">sass-loader</span></strong><span class="koboSpan" id="kobo.477.1">, which then hands over to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.478.1">css-loader</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">In the end, all the content is packaged up as a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.480.1">style</span></strong><span class="koboSpan" id="kobo.481.1"> tag </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.482.1">by </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.483.1">style-loader</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.484.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.485.1">We don’t always need to use a dedicated package for loaders. </span><span class="koboSpan" id="kobo.485.2">Using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.486.1">type</span></strong><span class="koboSpan" id="kobo.487.1"> property highlighted in the previous code, we can use some premade loaders from Webpack, such as the resource loader (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.488.1">asset/resource</span></strong><span class="koboSpan" id="kobo.489.1">) to return the paths to referenced files. </span><span class="koboSpan" id="kobo.489.2">Other options include data URIs (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.490.1">asset/inline</span></strong><span class="koboSpan" id="kobo.491.1">) and accessing a file’s raw </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.492.1">content (</span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.493.1">asset/source</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.494.1">).</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.495.1">Another way to use Webpack is to start a small server during development. </span><span class="koboSpan" id="kobo.495.2">Whenever we make updates to the code, the bundler can reprocess the changed parts and automatically update any active browsing sessions. </span><span class="koboSpan" id="kobo.495.3">All in all, this is a very convenient and quite productive way of writing a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.496.1">frontend application.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.497.1">For Webpack’s live server to work, we’ll need to install yet another </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.498.1">tooling dependency:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.499.1">
$ npm install webpack-dev-server --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.500.1">This allows us to run the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.501.1">serve</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.502.1"> command:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.503.1">
$ npx webpack serve --mode development

&lt;i&gt; [webpack-dev-server] Project is running at:

&lt;i&gt; [webpack-dev-server] Loopback: http://localhost:8081/

&lt;i&gt; [webpack-dev-server] On Your Network (IPv4): http://172.25.98.248:8081/

&lt;i&gt; [webpack-dev-server] Content not from webpack is served from '/home/node/examples/Chapter06/example01/public' directory

[...]

webpack 5.74.0 compiled successfully in 1911 ms</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.504.1">The live server will keep on running until it is forcefully shut down. </span><span class="koboSpan" id="kobo.504.2">On the command line, this can be done by pressing </span><em class="italic" lang=""><span class="koboSpan" id="kobo.505.1">Ctrl</span></em><span class="koboSpan" id="kobo.506.1"> + </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.507.1">C</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.508.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.509.1">One thing to add to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.510.1">webpack.config.js</span></strong><span class="koboSpan" id="kobo.511.1"> would be the history API fallback for the development server (the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.512.1">devServer</span></strong><span class="koboSpan" id="kobo.513.1"> section in a Webpack configuration). </span><span class="koboSpan" id="kobo.513.2">This will improve the</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.514.1"> development experience of a SPA by a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.515.1">fair margin:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.516.1">// ... </span><span class="koboSpan" id="kobo.516.2">like beforehand
module.exports = {
  // ... </span><span class="koboSpan" id="kobo.516.3">like beforehand
  devServer: {
    </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.517.1">historyApiFallback: true</span></strong><span class="koboSpan" id="kobo.518.1">,
  },
};</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.519.1">This setting will respond to all 404 URLs with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.520.1">index.html</span></strong><span class="koboSpan" id="kobo.521.1"> of the root directory – just like a SPA should be configured in production mode. </span><span class="koboSpan" id="kobo.521.2">This way, refreshing when being on a page with a different path than </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.522.1">/</span></strong><span class="koboSpan" id="kobo.523.1"> will still work. </span><span class="koboSpan" id="kobo.523.2">Without the shown configuration, the 404 error will be shown in the browser – no SPA will load and handle </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.524.1">the route.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.525.1">Now that we know how bundling the example application works in Webpack, it’s time to look at a more lightweight alternative </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.526.1">named esbuild.</span></span></p>
<h1 id="_idParaDest-64" lang="en-GB"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.527.1">Using esbuild</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.528.1">esbuild is quite a new tool that </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.529.1">focuses on performance. </span><span class="koboSpan" id="kobo.529.2">The key to esbuild’s enhanced performance is that it was written from the ground up in the Go programming language. </span><span class="koboSpan" id="kobo.529.3">The result is a native binary that has certain advantages over pure </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.530.1">JavaScript solutions.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.531.1">If esbuild stopped at providing a native solution, it would potentially not be qualified to make this list. </span><span class="koboSpan" id="kobo.531.2">After all, flexibility and the option to extend the original functionality are key for any kind of bundler. </span><span class="koboSpan" id="kobo.531.3">Luckily, the creator of esbuild has thought about this and come up with an elegant solution. </span><span class="koboSpan" id="kobo.531.4">While the core of esbuild remains native – that is, written in Go and provided as a binary – plugins can be written using JavaScript. </span><span class="koboSpan" id="kobo.531.5">This way, we get the best of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.532.1">both worlds.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.533.1">To get started with esbuild, we need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.534.1">esbuild</span></strong><span class="koboSpan" id="kobo.535.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.536.1">using npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.537.1">
$ npm install esbuild --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.538.1">With this one installation, you can use esbuild programmatically, as well as directly from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.539.1">command line.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.540.1">To run esbuild from the command line, you can use </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.541.1">npx</span></strong><span class="koboSpan" id="kobo.542.1"> together with the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.543.1">esbuild</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.544.1"> executable:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.545.1">
$ npx esbuild</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.546.1">This will show all the CLI options. </span><span class="koboSpan" id="kobo.546.2">To do something, at least one entry point needs to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.547.1">be supplied:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.548.1">
$ npx esbuild --bundle src/script.tsx --outdir=dist --minify

</span><span class="koboSpan" id="kobo.549.1"><img alt="" src="image/013.png"/></span><span class="koboSpan" id="kobo.550.1"> [ERROR] No loader is configured for ".scss" files: src/style.scss

    src/script.tsx:3:7:

      3 │ import './style.scss';

        </span><span class="koboSpan" id="kobo.551.1"><img alt="" src="image/02.png"/></span><span class="koboSpan" id="kobo.552.1">        ~~~~~~~~~~~~~~

</span><span class="koboSpan" id="kobo.553.1"><img alt="" src="image/013.png"/></span><span class="koboSpan" id="kobo.554.1"> [ERROR] No loader is configured for ".mp3" files: src/sound.mp3

    src/Audio.tsx:4:22:

      4 │ import audioPath from "./sound.mp3";

        </span><span class="koboSpan" id="kobo.555.1"><img alt="" src="image/02.png"/></span><span class="koboSpan" id="kobo.556.1">                       ~~~~~~~~~~~~~

[...]

5 errors</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.557.1">As expected, we miss a few configuration steps. </span><span class="koboSpan" id="kobo.557.2">As with Webpack, the best way to teach esbuild about these extra bits is by creating a configuration. </span><span class="koboSpan" id="kobo.557.3">Unlike Webpack, we do not have a predefined </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.558.1">configuration file – instead, the way to configure esbuild is by using </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.559.1">it programmatically.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.560.1">To do that, we must create a new file called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.561.1">build.js</span></strong><span class="koboSpan" id="kobo.562.1"> and import the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.563.1">esbuild</span></strong><span class="koboSpan" id="kobo.564.1"> package. </span><span class="koboSpan" id="kobo.564.2">We can use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.565.1">build</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.567.1">buildSync</span></strong><span class="koboSpan" id="kobo.568.1"> functions to trigger the bundling process </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.569.1">via esbuild.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.570.1">The previous CLI command can be written programmatically </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.571.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.572.1">build.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.573.1">const { build } = require("esbuild");
build({ // provide options to trigger esbuild's build
  entryPoints: ["./src/script.tsx"], // where to start from
  outdir: "./dist", // where to write the output to
  bundle: true, // bundle the resulting files
  minify: true, // turn on minification
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.574.1">Of course, the given script will essentially give us the same error as using the CLI directly. </span><span class="koboSpan" id="kobo.574.2">Therefore, let’s add a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.575.1">few things:</span></span></p>
<ul>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.576.1">esbuild-sass-plugin</span></strong><span class="koboSpan" id="kobo.577.1"> integrates the transformation of SASS into </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.578.1">CSS files</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.579.1">@craftamap/esbuild-plugin-html</span></strong><span class="koboSpan" id="kobo.580.1"> allows us to use template </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.581.1">HTML files</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.582.1">Before we can use these two plugins, we need to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.583.1">install them:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.584.1">
$ npm i esbuild-sass-plugin @craftamap/esbuild-plugin-html ––save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.585.1">Once the plugins are installed, we can</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.586.1"> extend the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.587.1">build.js</span></strong><span class="koboSpan" id="kobo.588.1"> file so that it includes these </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.589.1">two plugins:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.590.1">build.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.591.1">const { build } = require("esbuild");
const { sassPlugin } = require("esbuild-sass-plugin");
const { htmlPlugin } = require("@craftamap/esbuild-plugin-
  html");
build({
  entryPoints: ["./src/script.tsx"],
  outdir: "./dist",
  format: "esm", // use modern esm format for output
  bundle: true,
  minify: true,
  metafile: true, // required for htmlPlugin
  splitting: true, // allow lazy loading
  loader: {
    ".jpg": "file",
    ".webp": "file",
    ".mp3": "file",
    ".mp4": "file",
  },
  plugins: [
    sassPlugin(),
    htmlPlugin({
      files: [
        {
          entryPoints: ["./src/script.tsx"],
          filename: "index.html",
          scriptLoading: "module", // because of esm
          htmlTemplate: "./src/index.html",
        },
      ],
    }),
  ],
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.592.1">Along the way, we taught esbuild about our preference for the given file extensions. </span><span class="koboSpan" id="kobo.592.2">With the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.593.1">loader</span></strong><span class="koboSpan" id="kobo.594.1"> section, we map extensions to specific file loaders. </span><span class="koboSpan" id="kobo.594.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.595.1">file</span></strong><span class="koboSpan" id="kobo.596.1"> type refers to a loader that </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.597.1">will produce an external file. </span><span class="koboSpan" id="kobo.597.2">The import of that file will result in a reference to the file’s relative </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.598.1">output path.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.599.1">To enable bundle splitting, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.600.1">splitting</span></strong><span class="koboSpan" id="kobo.601.1"> option needs to be set. </span><span class="koboSpan" id="kobo.601.2">This also makes the use of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.602.1">esm</span></strong><span class="koboSpan" id="kobo.603.1"> format necessary. </span><span class="koboSpan" id="kobo.603.2">It’s the only format where esbuild knows how to produce scripts that can lazy load something. </span><span class="koboSpan" id="kobo.603.3">Additionally, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.604.1">htmlPlugin</span></strong><span class="koboSpan" id="kobo.605.1"> requires esbuild to produce a metafile to reflect the build artifacts. </span><span class="koboSpan" id="kobo.605.2">Therefore, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.606.1">metafile</span></strong><span class="koboSpan" id="kobo.607.1"> option needs to be set </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.608.1">to </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.609.1">true</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.610.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.611.1">Like Webpack, the ecosystem of esbuild is what makes this tool so flexible, yet hard to master. </span><span class="koboSpan" id="kobo.611.2">The options for the different plugins need to be collected from the different plugin documentation. </span><span class="koboSpan" id="kobo.611.3">Like the Webpack ecosystem beforehand, the quality of these plugins, as well as their maturity and the community behind them, varies </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.612.1">a lot.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.613.1">If you want to have a development server – just like the one we added to Webpack in the previous section – you can use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.614.1">serve</span></strong><span class="koboSpan" id="kobo.615.1"> function, which can be imported from </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.616.1">esbuild</span></strong><span class="koboSpan" id="kobo.617.1">. </span><span class="koboSpan" id="kobo.617.2">The first argument describes server-specific settings such as the port where the service should be listening. </span><span class="koboSpan" id="kobo.617.3">The second argument comprises the build options – that is, the options we are</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.618.1"> supplying right now – as the only argument to the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.619.1">build</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.620.1"> function.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.621.1">Let’s write another script called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.622.1">serve.js</span></strong><span class="koboSpan" id="kobo.623.1"> to illustrate </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.624.1">this usage:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.625.1">serve.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.626.1">const { serve } = require("esbuild");
const { sassPlugin } = require("esbuild-sass-plugin");
const { htmlPlugin } = require("@craftamap/esbuild-plugin-
  html");
// use helper from esbuild to open a dev server
serve(
  {
    // will be reachable at http://localhost:1234
    port: 1234,
  },
  {
    // same options as beforehand (supplied to build())
    // ...
</span><span class="koboSpan" id="kobo.626.2">  }
);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.627.1">One thing that esbuild does not do at the moment is HMR. </span><span class="koboSpan" id="kobo.627.2">Consequently, the developer’s experience of just using esbuild may be a little bit underwhelming in that area when compared to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.628.1">similar tools.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.629.1">With this in mind, let’s explore</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.630.1"> yet another option that is widely used for bundling – let’s have a look at the configuration-less </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.631.1">Parcel bundler.</span></span></p>
<h1 id="_idParaDest-65" lang="en-GB"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.632.1">Using Parcel</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.633.1">When Parcel arrived in the community, the hype around it was massive. </span><span class="koboSpan" id="kobo.633.2">The reason for this was to be found in one</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.634.1"> new feature: configuration-free bundling. </span><span class="koboSpan" id="kobo.634.2">Parcel tried to leverage information that was already given in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.635.1">package.json</span></strong><span class="koboSpan" id="kobo.636.1"> – or configuration files written for specific tools such as Babel. </span><span class="koboSpan" id="kobo.636.2">Using this mechanism, the creators of Parcel thought to remove the complexity of configuring </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.637.1">a bundler.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.638.1">Ultimately, however, the whole aspect backfired in some sense. </span><span class="koboSpan" id="kobo.638.2">As mentioned previously, a bundler requires some flexibility. </span><span class="koboSpan" id="kobo.638.3">To achieve this kind of flexibility, a sound configuration system is necessary. </span><span class="koboSpan" id="kobo.638.4">While the configuration system of Webpack is a bit too verbose and complex, the one provided with esbuild might be a bit </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.639.1">too low-level.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.640.1">The successor of the original Parcel now also offers an optional configuration system, which tries to be right between the verbosity of Webpack and the low-level one of esbuild. </span><span class="koboSpan" id="kobo.640.2">This makes Parcel no longer configuration-free, but rather a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.641.1">configuration-less bundler.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.642.1">To get started with Parcel, we need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.643.1">parcel</span></strong><span class="koboSpan" id="kobo.644.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.645.1">using npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.646.1">
$ npm install parcel ––save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.647.1">With this installation, you can use Parcel programmatically, as well as directly from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.648.1">command line.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.649.1">To run Parcel from the command line, you can use </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.650.1">npx</span></strong><span class="koboSpan" id="kobo.651.1"> together with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.652.1">parcel</span></strong><span class="koboSpan" id="kobo.653.1"> executable. </span><span class="koboSpan" id="kobo.653.2">For Parcel, the entry point can be the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.654.1">HTML file:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.655.1">
$ npx parcel src/index.html</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.656.1">In our case, we still need to modify the HTML so that it also points to the other source files to continue building up the module graph. </span><span class="koboSpan" id="kobo.656.2">A version of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.657.1">index.html</span></strong><span class="koboSpan" id="kobo.658.1"> file that fits much better with Parcel would look </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.659.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.660.1">index.html</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.661.1">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0"&gt;
    &lt;title&gt;Bundler Example&lt;/title&gt;
    &lt;link rel="stylesheet" href="./style.scss"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script type="module" src="./script.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.662.1">Importantly, we’ve added</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.663.1"> the stylesheet and script entry points. </span><span class="koboSpan" id="kobo.663.2">These will be detected by Parcel and properly bundled. </span><span class="koboSpan" id="kobo.663.3">In the end, the HTML file will be used as a template – with the entry points being replaced by the bundled stylesheet and script </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.664.1">file references.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.665.1">Starting Parcel right now will already partially work, but at this time, Parcel still has some problems with our audio and video files. </span><span class="koboSpan" id="kobo.665.2">While Parcel knows most image files (such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.666.1">*.webp</span></strong><span class="koboSpan" id="kobo.667.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.668.1">*.png</span></strong><span class="koboSpan" id="kobo.669.1">) already, some other assets need to be configured first. </span><span class="koboSpan" id="kobo.669.2">In Parcel, this means creating a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.670.1">.parcelrc</span></strong><span class="koboSpan" id="kobo.671.1"> file and adding a section about the transformers </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.672.1">to use:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.673.1">.parcelrc</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.674.1">{
  "extends": "@parcel/config-default",
  "transformers": {
    "*.{mp3,mp4}": ["@parcel/transformer-raw"]
  }
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.675.1">The configuration instructs Parcel to still rely on the very well-chosen defaults. </span><span class="koboSpan" id="kobo.675.2">However, we also added the definitions for the two file types in question to the section that handles the transformation logic. </span><span class="koboSpan" id="kobo.675.3">Like Webpack or esbuild, Parcel also has an in-built type to handle such imports by returning a filename that can be used within the code. </span><span class="koboSpan" id="kobo.675.4">In the case of Parcel, this type is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.676.1">called </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.677.1">@parcel/transformer-raw</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.678.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.679.1">Now, let’s see if Parcel is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.680.1">already running:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.681.1">
$ npx parcel src/index.html

Server running at http://localhost:1234

</span><span class="koboSpan" id="kobo.682.1"><img alt="" src="image/03.png"/></span><span class="koboSpan" id="kobo.683.1"> Built in 12ms</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.684.1">By default, Parcel will start a development server. </span><span class="koboSpan" id="kobo.684.2">This already contains everything that is needed for developing</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.685.1"> an application. </span><span class="koboSpan" id="kobo.685.2">Quite convenient. </span><span class="koboSpan" id="kobo.685.3">If we want to build the files – for example, to place the output artifacts on a server – we can use the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.686.1">build</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.687.1"> subcommand:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.688.1">
$ npx parcel build src/index.html

</span><span class="koboSpan" id="kobo.689.1"><img alt="" src="image/03.png"/></span><span class="koboSpan" id="kobo.690.1"> Built in 6.11s

dist/index.html                  402 B    4.73s

dist/index.3429125f.css       39.02 KB    149ms

dist/index.cb13c36e.js       156.34 KB    1.90s

dist/Home.bf847a6b.js          1.05 KB    148ms

dist/river.813c1909.webp      29.61 KB    150ms

dist/snow.390b5a72.jpg        13.28 KB    138ms

dist/Video.987eca2d.js           908 B    1.90s

dist/earth.4475c69d.mp4     </span><span class="koboSpan" id="kobo.691.1"><img alt="" src="image/04.png"/></span><span class="koboSpan" id="kobo.692.1">  1.5 MB     61ms

dist/Video.61df35c5.js       611.76 KB    4.62s

dist/Audio.677f10c0.js           908 B    149ms

dist/sound.6bdd55a4.mp3      746.27 KB     92ms</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.693.1">There are CLI flags and options to set almost everything, such as the output directory. </span><span class="koboSpan" id="kobo.693.2">Nevertheless, by default, the quite common </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.694.1">dist</span></strong><span class="koboSpan" id="kobo.695.1"> folder </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.696.1">is chosen.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.697.1">Last, but not least, let’s have</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.698.1"> a look at the quite trendy Vite bundler, which tries to combine the advantages of all previous approaches into a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.699.1">single tool.</span></span></p>
<h1 id="_idParaDest-66" lang="en-GB"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.700.1">Using Vite</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.701.1">The latest addition to the set of </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.702.1">popular bundlers is Vite. </span><span class="koboSpan" id="kobo.702.2">It combines a few existing tools – such as Rollup.js and esbuild – together with a unified plugin system to allow rapid development. </span><span class="koboSpan" id="kobo.702.3">Vite’s approach is to give you the power of Webpack at the speed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.703.1">of esbuild.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.704.1">Originally, Vite was built by the creator of the frontend framework Vue. </span><span class="koboSpan" id="kobo.704.2">However, as time went on, Vite’s plugin system became a lot more powerful. </span><span class="koboSpan" id="kobo.704.3">With its increased API surface, other frontend frameworks such as React or Svelte could be supported. </span><span class="koboSpan" id="kobo.704.4">Now, Vite has evolved from a single-purpose tool to a real Swiss Army knife – thanks to a well-thought-out plugin mechanism with an </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.705.1">active community.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.706.1">To get started with Vite, we need to install the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.707.1">vite</span></strong><span class="koboSpan" id="kobo.708.1"> package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.709.1">using npm:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.710.1">
$ npm install vite --save-dev</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.711.1">With this installation, you can use Vite programmatically, as well as directly from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.712.1">command line.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.713.1">One thing to know about Vite is that it embraces having an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.714.1">index.html</span></strong><span class="koboSpan" id="kobo.715.1"> file as an entry point even more than Parcel. </span><span class="koboSpan" id="kobo.715.2">For Vite to work as intended, we need to move the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.716.1">index.html</span></strong><span class="koboSpan" id="kobo.717.1"> file from the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.718.1">src</span></strong><span class="koboSpan" id="kobo.719.1"> folder to the parent directory – that is, the project’s </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.720.1">root folder.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.721.1">As we did previously, we should set the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.722.1">references properly:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.723.1">index.html</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.724.1">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1.0"&gt;
    &lt;title&gt;Bundler Example&lt;/title&gt;
    &lt;link rel="stylesheet" href="./src/style.scss"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script type="module" src="./src/script.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.725.1">To run Vite from</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.726.1"> the command line, you can use </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.727.1">npx</span></strong><span class="koboSpan" id="kobo.728.1"> together with the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.729.1">vite</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.730.1"> executable:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.731.1">
$ npx vite

  VITE v3.0.5  ready in 104 ms

  </span><span class="koboSpan" id="kobo.732.1"><img alt="" src="image/05.png"/></span><span class="koboSpan" id="kobo.733.1">  Local:   http://localhost:5173/

  </span><span class="koboSpan" id="kobo.734.1"><img alt="" src="image/05.png"/></span><span class="koboSpan" id="kobo.735.1">  Network: use --host to expose</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.736.1">This starts quickly as nothing has been bundled or transformed yet. </span><span class="koboSpan" id="kobo.736.2">Only when we hit the server will Vite start to transform things – and only the things that we are currently looking at. </span><span class="koboSpan" id="kobo.736.3">If you are interested in a more realistic picture, then the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.737.1">preview</span></strong><span class="koboSpan" id="kobo.738.1"> subcommand can be handy. </span><span class="koboSpan" id="kobo.738.2">It does a production build but exposes the outcome via the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.739.1">development server.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.740.1">Of course, like with </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.741.1">Parcel, we can still produce files that can be placed on a server. </span><span class="koboSpan" id="kobo.741.2">Very similar to Parcel, we can do this with the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.742.1">build</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.743.1"> subcommand:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.744.1">
$ npx vite build

vite v3.0.5 building for production...

</span><span class="koboSpan" id="kobo.745.1"><img alt="" src="image/06.png"/></span><span class="koboSpan" id="kobo.746.1"> 110 modules transformed.

</span><span class="koboSpan" id="kobo.746.2">dist/assets/river.4a5afeaf.webp   29.61 KiB

dist/assets/snow.cbc8141d.jpg     13.96 KiB

dist/assets/sound.fa282025.mp3    746.27 KiB

dist/assets/earth.71944d74.mp4    1533.23 KiB

dist/index.html                   0.42 KiB

dist/assets/Home.82897af9.js      0.45 KiB / gzip: 0.23 KiB

dist/assets/Video.ce9d6500.js     0.36 KiB / gzip: 0.26 KiB

[...]

dist/assets/index.404f5c02.js     151.37 KiB / gzip: 49.28 KiB

dist/assets/Player.c1f283e6.js    585.26 KiB / gzip: 166.45 KiB</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.747.1">For this example, Vite is the only bundler that just works – at least once all the prerequisites have been fulfilled. </span><span class="koboSpan" id="kobo.747.2">If you require a custom configuration, such as for adding some plugins, then you can follow Webpack’s approach and create a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.748.1">vite.config.js</span></strong><span class="koboSpan" id="kobo.749.1"> file in the project’s </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.750.1">root folder.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.751.1">Now, let’s recap what you’ve learned in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.752.1">this chapter.</span></span></p>
<h1 id="_idParaDest-67" lang="en-GB"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.753.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.754.1">In this chapter, you learned what a bundler is, why you need it, what bundlers exist, and how you can configure and use them. </span><span class="koboSpan" id="kobo.754.2">You are now able to take your web projects from their raw source code to build </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.755.1">production-ready assets.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.756.1">Equipped with detailed knowledge about bundlers, you can create very reliable code bases that are tailored toward efficiency. </span><span class="koboSpan" id="kobo.756.2">Not only will unnecessary code be removed upon bundling, but also all referenced files will be processed and taken into consideration. </span><span class="koboSpan" id="kobo.756.3">Therefore, you’ll never have to worry about missing </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.757.1">a file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.758.1">The large variety of existing bundlers can be intimidating at first. </span><span class="koboSpan" id="kobo.758.2">While there are some obvious choices, such as the very popular Webpack bundler, other options may be even better due to less complexity or better performance, depending on the project you have at hand. </span><span class="koboSpan" id="kobo.758.3">If in doubt, you can refer to the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.759.1">Comparing available bundlers</span></em><span class="koboSpan" id="kobo.760.1"> section of this chapter to ascertain which bundler might be the best fit </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.761.1">for you.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.762.1">In the next chapter, we will take closer look at another category of crucial development tools. </span><span class="koboSpan" id="kobo.762.2">We’ll see how testing tools give us confidence that our code works as it should, both today and in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.763.1">the future.</span></span></p>
</div>
</body></html>