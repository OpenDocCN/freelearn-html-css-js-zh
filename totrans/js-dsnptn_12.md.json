["```js\n<div id=\"app\"></div>\n<script src=\"img/main.js\" type=\"module\"></script>\n```", "```js\ndocument.querySelector('#app').textContent = 'Hello from main.js';\nconst { hello } = await import('./dynamic.js');\ndynamic.js implementation of the hello function:\n\n```", "```js\n\n When running the Vite dev server using `npx vite`, we can see that the dynamically imported `hello` function contents are displayed on the page. Notice that `dynamic.js` is loaded as a separate request to `main.js`; that is code splitting at play.\n![Figure 9.1: “Hello from dynamic.js” on the page with network requests, including a request specifically for dynamic.js](img/B19109_09_1.jpg)\n\nFigure 9.1: “Hello from dynamic.js” on the page with network requests, including a request specifically for dynamic.js\nThis pattern can be useful to defer loading JavaScript until it’s required – for example, if we want to add client-side tracking of button clicks using `fetch` requests.\nWe have the following HTML, with two buttons that have a `data-track` property:\n\n```", "```js\n\n We’ll add a `trackInteraction.js` module with a `trackInteraction` function, which will use `fetch` and the `POST` HTTP method to send interaction data to `jsonplaceholder`. If this were a live implementation, we could realistically replace `jsonplaceholder` with Google Analytics or another equivalent service that exposes a client-side JavaScript accessible endpoint:\n\n```", "```js\n\n Now, the `trackInteraction` module has nothing to do with the page functionality so we want to avoid loading it until it’s needed.\nIn this case, we’ll attach a click event listener to each element that has a `data-track` attribute. Only when the listener is triggered does the `import('./trackInteraction.js')` statement run:\n\n```", "```js\n\n If we load the Vite dev server and click the **With tracked click** button and the **Other tracked click** button once and then the **With tracked click** button once again, we’ll get the following network requests:\n![Figure 9.2: Network requests after clicking the “With tracked click,” “Other tracked click,” and “With tracked click” buttons in sequence](img/B19109_09_2.jpg)\n\nFigure 9.2: Network requests after clicking the “With tracked click,” “Other tracked click,” and “With tracked click” buttons in sequence\nOn the first click of either button, the `trackInteraction.js` file is loaded and then a `fetch` request is triggered. On subsequent clicks, `trackInteraction.js` is already loaded so the `fetch` requests to `jsonplaceholder` are the only network requests we see.\nNote that each `POST` request to `jsonplaceholder` is preceded by an `OPTIONS` request due to browser `OPTIONS` response includes `Access-Control-Allow-…` headers that allow our origin and method.\nWe’ve now seen what dynamic imports in JavaScript look like and how Vite automatically code splits dynamic imports, which allows us to only load modules that are required “just in time,” thereby allowing us to reduce the upfront JavaScript load/parse/evaluation cost.\nNext, we’ll cover route-based code splitting in Next.js and how to inspect generated chunks with the Next.js Bundle Analyzer plugin.\nRoute-based code splitting and bundling\nLet’s begin by defining a **route** in a general web application context and then in a Next.js context.\nIn a web application, a route comes from the **router** concept; in simple terms, it’s an entry in the router. An entry in the router mechanism can take multiple shapes – for example, in an nginx/Apache/Caddy web server setup, we can have a path to file forwarding or a wildcard forwarding approach. In backend MVC frameworks such as Ruby on Rails, Laravel (PHP), and Django (Python), a route associates a request path to the specific code to be run. The *request path to code to be run* concept also applies to Node.js backend applications using libraries such as Express, Koa, Fastify, and Adonis.js.\nLet’s now see how the *route* concept is used in the Next.js filesystem router.\nA minimal Next.js project as initialized with `create-next-app` is laid out as follows. Each file in the `pages` directory corresponds to a route. For example, `index.js` is used to render the `/` path of the application. If we had an `about.js` or `about/index.js` file, that would be used to render the `/about` path of the application:\n\n```", "```js\n\n We defined code splitting in the previous section, *Dynamic imports and code splitting with Vite*. Since a core Next.js feature is the router, it can do what’s called **route-based code splitting**, which is automatic code splitting based on a route or page contents.\nA naive route-based code-splitting approach would be to create completely separate sets of bundles for each route. In the context of a React or Next.js application, this is inefficient since we would end up with shared libraries (for example, React and Next.js) in each of the per-page bundles.\nWhat Next.js can do in this case is identify shared code and classify it as `First Load JS shared` `by all`.\nThis is the sample build output:\n\n```", "```js\n\n We can add the Next.js Bundle Analyzer to check the contents of each chunk:\n\n```", "```js\n\n Then, we can configure `next.config.js` to use it. In our case, it looks as follows:\n\n```", "```js\n\n To use the bundle analyzer, we can add an `analyze` script to our `package.json file`:\n\n```", "```js\n\n This can be run with `npm run analyze`. Its shell output is the same as `npm run build` but it opens a browser window with the bundle analysis file – for example, `.next/analyze/client.html`:\n\n```", "```js\n\n We can use this to inspect the contents of the `shared` JavaScript in the `framework`, `main`, `pages/_app`, and `webpack` chunks as well as page-specific chunks:\n![Figure 9.3: The client.html Bundle Analyzer output in the browser](img/B19109_09_3.jpg)\n\nFigure 9.3: The client.html Bundle Analyzer output in the browser\nThe `framework` bundle includes the following packages from `node_modules`: `react`, `react-dom`, and `scheduler`. Meanwhile, the `main` bundle includes `next` and its submodules such as `shared/lib`, which includes a large `router` chunk, or `next/client`, which is the client-side section of Next.js. Also, it is harder to see in the preceding screenshot, but `main` includes `@swc/helpers/esm`, which is probably an artifact of the Next.js build using the SWC compiler.\nWe’ve now seen how Next.js supports route-based code splitting and how to inspect the contents of the Next.js-generated bundles using the Next.js Bundle Analyzer report. Next, we’ll see dynamic import patterns to load additional JavaScript under different element visibility and interaction conditions.\nLoading JavaScript on element visibility and interaction\nIn this section, we’ll look at four different scenarios where dynamic or lazy loading of React components and JavaScript modules can be applied in the context of a Next.js application.\nThe first instance will be whether the component is in the component tree or not – in other words, whether it’s considered to be rendered or not. Next, we’ll look at dynamic imports based on user interaction. We’ll also cover how to handle an interaction that potentially requires a dynamic import of a JavaScript resource. Finally, we’ll show how to dynamically load a React component when an element is visible in the viewport.\nNext.js provides a `dynamic` utility (see the documentation at [https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading](https://nextjs.org/docs/pages/building-your-application/optimizing/lazy-loading)) that allows us to lazily and dynamically load a React component.\nIn our case, we have a `components/Hello.jsx` component with a `Hello` component that is a named export:\n\n```", "```js\n\n We can dynamically load it using `dynamic()` and `import()`. Due to `Hello` being a named export, we need to extract the `Hello` property of the `import()` promise using `.then()`. We set `ssr: false` to showcase how `next/dynamic` allows us to control whether a dynamically loaded component is included in the server-rendered output or not:\n\n```", "```js\n\n By using `npm run analyze` as configured in the *Route-based code splitting and bundling* section (using the `@next/bundle-analyzer` module), we can inspect the contents of the `chunks/pages/index` chunk; you’ll note that `Hello.jsx` is in a different chunk.\n![Figure 9.4: Bundle analyzer filtered to “chunks/pages/index” and the chunk containing Hello.jsx](img/B19109_09_4.jpg)\n\nFigure 9.4: Bundle analyzer filtered to “chunks/pages/index” and the chunk containing Hello.jsx\nWhen we run the Next.js dev server using `next dev` and load up the `/` path, we see the following page and network requests. `_next/static/chunks/components_Hello_jsx.js` is loaded last and separately to `_next/static/chunks/pages/index.js`, which means that we are in fact doing a dynamic load of the `Hello.jsx` component.\n![Figure 9.5: Dynamic loading of the Hello.jsx page contents and Network tab](img/B19109_09_5.jpg)\n\nFigure 9.5: Dynamic loading of the Hello.jsx page contents and Network tab\nWe’ll now showcase using `next/dynamic` inside of the `Index` component based on the component state.\nOur example is a *Terms and Conditions* selector that allows the user to select between three options: `NoRender` component (which simply returns `null`), and **Short** and **Long** will dynamically load a component to display.\nWe’ll start by adding a `components/TermsAndConditionsShort.jsx` component, which contains an `h3` element and a single paragraph of content:\n\n```", "```js\n\n We’ll also add a `components/TermsAndConditionsLong.jsx` component, which contains the same `h3` and content but has five paragraphs of content instead of one:\n\n```", "```js\n\n Finally, we’ll add a `select` field with relevant `option` values (`None`, `Short`, and `Long`) to `pages/index.js`. We’ll use `useState` to keep track of the currently selected option:\n\n```", "```js\n\n Finally, we’ll add a `NoRender` component and, based on `selectedTermsAndConditions`, either render `NoRender` or the dynamically loaded `TermsAndConditions` component:\n\n```", "```js\n\n When we run the next dev server and load the index page, we initially see the `Hello.jsx` one from the previous example.\n![Figure 9.6: Terms and conditions selector initial state with None selected; therefore, no dynamic imports apart from the existing Hello.jsx one](img/B19109_09_6.jpg)\n\nFigure 9.6: Terms and conditions selector initial state with None selected; therefore, no dynamic imports apart from the existing Hello.jsx one\nOn selection of `_next/static/chunks/components_TermsAndConditionsShort_jsx.js`.\n![Figure 9.7: Terms and conditions selector when Short is selected; TermsAndConditionsShort.jsx has been dynamically loaded and is displayed](img/B19109_09_7.jpg)\n\nFigure 9.7: Terms and conditions selector when Short is selected; TermsAndConditionsShort.jsx has been dynamically loaded and is displayed\nWhen we select `/_next/static/chunks/components_TermsAndConditionsLong_jsx.js`.\n![Figure 9.8: Terms and conditions selector when Long is selected; TermsAndConditionsLong.jsx has been dynamically loaded and is displayed](img/B19109_09_8.jpg)\n\nFigure 9.8: Terms and conditions selector when Long is selected; TermsAndConditionsLong.jsx has been dynamically loaded and is displayed\nWe can also look at the Bundle Analyzer’s `client.html` output using `npm run analyze`; the following has been filtered to the relevant chunks to illustrate how `TermsAndConditionsShort` and `TermsAndConditionsLong` are not included in `chunks/pages/index.js`. There are three “dynamic” chunks (which correlates with our findings from the network requests we observe in the browser): one for `components/Hello.jsx`, one for `components/TermsAndConditionsShort.jsx`, and one for `components/TermsAndConditionsLong.jsx`.\n![Figure 9.9: Bundle Analyzer output for the page chunk as well as the dynamic chunks (which include the TermsAndConditionsShort and TermsAndConditionsLong components)](img/B19109_09_9.jpg)\n\nFigure 9.9: Bundle Analyzer output for the page chunk as well as the dynamic chunks (which include the TermsAndConditionsShort and TermsAndConditionsLong components)\nWe’ve now seen how `dynamic` can be used in response to a user action to dynamically load content based on user-provided data. Next, we’ll revisit dynamic imports of a JavaScript resource (as opposed to React components) while handling a user action in the context of a Next.js application.\nWe’ll start with a new component, `TermsAndConditionsLongScroll.jsx`, which is functionally the same as `TermsAndCondtionsShort.jsx` or `TermsAndCondtionsLong.jsx` but with 10 paragraphs:\n\n```", "```js\n\n We’ll now add a form at the bottom of the page to accept the terms and conditions. We have a long form so it’s nice to be able to go directly to the bottom. To this end, we add a button that, on click, scrolls us to the input checkbox element using a ref.\nIn our *scroll-to-bottom* handler, we ensure that smooth scrolling is available (some older Safari versions don’t natively support it) by conditionally importing the `scroll-behavior-polyfill` package if `scrollBehavior` is not detected.\nFinally, we scroll using the `scrollTargetRef.current.scrollIntoView()` function. `scrollTargetRef` is attached to the checkbox input using the `ref` property:\n\n```", "```js\n\n Back in `pages/index.js`, we’ll allow `option`) and to be dynamically imported:\n\n```", "```js\n\n When we run the next dev server, load the index page, and select `TermsAndConditionsLongScroll.jsx`.\n![Figure 9.10: TermsAndConditionsLongScroll.jsx selection with dynamic import](img/B19109_09_10.jpg)\n\nFigure 9.10: TermsAndConditionsLongScroll.jsx selection with dynamic import\nIn browsers where `behavior: 'smooth'` is supported, when the **Scroll to bottom** button is clicked, no additional JavaScript chunks are loaded and we’re scrolled to the checkbox input after the multiple paragraphs.\n![Figure 9.11: TermsAndConditionsLongScroll.jsx selection with dynamic import](img/B19109_09_11.jpg)\n\nFigure 9.11: TermsAndConditionsLongScroll.jsx selection with dynamic import\nOn browsers that don’t support `behavior: 'smooth'` for scrolling, `scroll-behavior-polyfill` will be loaded allowing for smooth scrolling to the checkbox.\n![Figure 9.12: TermsAndConditionsLongScroll.jsx selection with dynamic import of the component and of the scroll-behavior-polyfill module](img/B19109_09_12.jpg)\n\nFigure 9.12: TermsAndConditionsLongScroll.jsx selection with dynamic import of the component and of the scroll-behavior-polyfill module\nBased on the Bundle Analyzer output (using `npm run analyze` and the `@next/bundle-analyzer` plugin), we can see that there is a chunk that contains `scroll-behavior-polyfill`, along with chunks for `pages/index.js` and one each for `TermsAndConditionsShort.jsx`, `TermsAndConditionsLong.jsx`, and `TermsAndConditionsLongScroll.jsx`.\n![Figure 9.13: Bundle Analyzer output for the pages/index.js chunk as well as relevant dynamic chunks (TermsAndConditionsShort, TermsAndConditionsLong, TermsAndConditionsLongScroll, and scroll-behavior-polyfill)](img/B19109_09_13.jpg)\n\nFigure 9.13: Bundle Analyzer output for the pages/index.js chunk as well as relevant dynamic chunks (TermsAndConditionsShort, TermsAndConditionsLong, TermsAndConditionsLongScroll, and scroll-behavior-polyfill)\nWe’ve now seen that Next.js code splits effectively on native `import()` as well as the provided `dynamic()` utility.\nFinally, we’ll see how to use `dynamic()` and the `react-intersection-observer` package to dynamically load content when it is visible.\nOne other variant of a Terms and Conditions form or similar would be to include additional fields that should be captured when the customer accepts the terms.\nIn this example, we’ll add a `components/TermsForm.jsx` component with an input for the user’s name and a label for it:\n\n```", "```js\n\n Next, we’ll want to include it in `components/TermsAndConditionsLongScrollAcceptForm.jsx`. We’ll use `dynamic()` to load the `TermsForm` component.\nThe rest of our code is similar to the end state of the `TermsAndConditionsLongScroll` components, with a heading, 10 paragraphs, and an `accept` input.\nThe key exception is the import and usage of the `InView` component from `react-intersection-observer`.\nThe `InView` component has a children render property that receives, among other properties, the `ref` property, which we can attach to elements whose visibility we’re interested in. Another property of interest to us is the `inView` Boolean, which tells us whether the element on which we put the `ref` prop is in the viewport.\nAs the rendered output of the `InView` children function, we return a `div` element to which we attach the `ref` property. Inside of the `div`, we render `TermsForm` but only if `inView` is `true`:\n\n```", "```js\n\n Finally, we need to add `TermsAndConditionsLongScrollAcceptForm` as a selectable option and a dynamically loaded component:\n\n```", "```js\n\n Now, when we run the next dev server and load the index page, `LongScrollAcceptForm` is available. When we select it, the `TermsAndConditionsLongScrollAcceptForm.jsx` component is loaded.\n![Figure 9.14: LongScrollAcceptForm selected and TermsAndConditionsLongScrollAcceptForm.jsx dynamically loaded](img/B19109_09_14.jpg)\n\nFigure 9.14: LongScrollAcceptForm selected and TermsAndConditionsLongScrollAcceptForm.jsx dynamically loaded\nWhen `TermsAndConditionsLongScrollAcceptForm` is scrolled to the bottom (to the point where the checkbox is visible), the `TermsForm.jsx` component is dynamically loaded and is shown on the page.\n![Figure 9.15: TermsAndConditionsLongScrollAcceptForm scrolled to the bottom and TermsForm.jsx dynamically loaded](img/B19109_09_14.jpg)\n\nFigure 9.15: TermsAndConditionsLongScrollAcceptForm scrolled to the bottom and TermsForm.jsx dynamically loaded\nWe’ve now seen how to load JavaScript and React components on component visibility and interaction with Next.js.\nSummary\nIn this chapter, we’ve covered various approaches for maximizing the performance of your JavaScript, React, and Next.js applications with lazy loading approaches and code splitting.\nFirst, we showcased how to use the dynamic import syntax in a Vite-powered setup to cause code splitting and illustrated it by importing additional code only when it’s required (during an interaction handler).\nNext, we saw how Next.js provides out-of-the-box route-based code splitting while also ensuring modules shared across pages don’t get loaded or output more than once. We also delved into how to validate this using the Next.js Bundle Analyzer plugin.\nFinally, we covered how to implement different lazy loading scenarios in Next.js: on presence in the component tree, on change caused by user interaction, importing a JavaScript module during an event handler, and lazy loading on an element entering the viewport.\nWe now know how to leverage lazy loading and code splitting to maximize application load performance. In the next chapter, we’ll cover asset-loading strategies and how to execute code off the main thread.\n\n```"]