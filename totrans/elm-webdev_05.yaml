- en: Completing the Unit Conversion Website in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml), *Completing
    the Unit Conversion Website in Elm*. The goal of this chapter is to complete the
    unit conversion website while discussing the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Html.map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with complex relationships between different views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining everything we learned in a relatively complex app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build Elm applications that have multiple models separated into modules, while
    following best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll begin this chapter by looking at the completed functionality for our unit
    converter app. The reason for this is to be able to see the bigger picture and
    understand what is going on in the two modules of our updated app before continuing
    to improve the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Unit Converter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this iteration of our app, we have two separate files that work together
    to produce our unit conversion app. At this point, there are no styles in our
    app at all, since the focus is on functionality. Now, let's rebuild our unit converter
    app from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the barebones Elm app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will improve it so that it can take multiple input fields. The first
    improvement has to do with separating the current unit converter into a different
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Separating UnitConverter into a different module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file, call it `UnitConverter.elm`, and save it inside the `src`
    folder. Next, copy and paste the barebones app there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `Main.elm`, change its imports section so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `UnitConverter.elm`, change the imports section so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in `UnitConverter.elm`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the preceding code looks almost identical to what we had at the
    end of [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing a Unit
    Conversion Website in Elm*, except that there is no call to `main` anymore, and
    the `init` function has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can update the `Main.elm` file so that it works with multiple input
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Adding type alias Model, initModel, and Main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start updating `Main.elm` by adding a new type alias `Model`. Place
    the type alias `Model` just above the `initModel`. The code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s update the `initModel` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our type alias `Model` consists of a `lengthConverter` and a `weightConverter`,
    both of which take the value of `UnitConverter.Model`. Looking at type alias `UnitConverter.Model`,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `initModel` function, we have the `lengthConverter` take the value from
    `UnitConverter.init`, with three arguments passed to it: "Miles", "Kilometers",
    and 1.608, which is in accordance with the type annotation of the `init` function
    in the `UnitConverter` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we set up the values of `initialModel` for the `weightConverter`,
    populating it with the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with code in `Main.elm`, we can add it to the `main` function, which
    has not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we run our app now, we'll get the `Everything will go here` text in the browser.
    This means that everything is working and ready for us to improve it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll update the `view` function.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Main.view function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the `view` function, we''ll use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a compiler-suggested type annotation for the `Main.view` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `view` function takes a record. The values of the record will be that of
    the current model, plus the update made to `lengthConverter` or `weightConverter`.
    The `lengthConverter` function will return *either* its current value, signified
    by type variable `b`, *or* the updated value which sets the `convertedValue`,
    `unit1`, and `unit2` to their respective values. The same goes for `weightConverter`—it
    will return *either* as is, *or* its updated values for `convertedValue`, `unit1`,
    and `unit2`.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `view` function takes a record and returns an `Html.Html Msg`. Why is
    the `Html` module listed here? Because we have not exposed it explicitly when
    importing the `Html` module. This way of referencing it is known as the fully
    qualified style. Had we exposed the `Html` function explicitly in the `Html` import
    expression at the top of our `Main.elm`, we could have just used `-> Html Msg`,
    which is referred to as an unqualified style.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our app now, the compiler will throw these two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course it cannot. We have not set it anywhere.  Let''s start doing that.
    We''ll begin by adding the union `type Msg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `type Msg` in `Main.elm` can be either a `LengthConverterMsg` type constructor
    function, taking the `UnitConverter.Msg` as its argument, or it can be a `WeightConverterMsg`
    type constructor function, also taking the `UnitConverter.Msg`. Both of these
    type constructor functions take in the same value as its single argument. Why
    is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is easy: if you look at the `UnitConverter.update` function, you''ll
    see that if its Swap pattern gets matched, the expression that evaluates will
    do exactly that, swap the values, just as it did in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml),
    *Preparing a Unit Conversion Website in Elm*.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `UnitConverter.update` function's `Convert` pattern gets matched, it
    will return the `model` as it received it, *plus* the updated `convertedValue`.
    Again, this is the same as what we had in [Chapter 4](http://prepat), *Preparing
    a Unit Conversion Website in Elm*, which means that the logic is the same.
  prefs: []
  type: TYPE_NORMAL
- en: What changed then? What changed is the `view` function in `Main.elm`. Let's
    pick it apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Main.view` is just a `div` function. The first `List` we pass to it is
    empty. The second `List` has two parameters. The first one looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the piping syntax that we already discussed. Another way to write it
    is to use parentheses, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the expression inside parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that on line 22 of `UnitConverter.elm`, we can see that its `view`
    function takes a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the parameter `model.lengthConverter` we pass to `UnitConverter.view`
    inside `Main.elm` is, in fact, the model, more specifically, the `lengthConverter`
    flavor of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Where does `lengthConverter` come from? We can find the answer if we look at
    the flow of data in `Main.elm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `Main.elm` entry point, the `main` function, receives the value
    that''s computed by evaluating the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to focus on the first line of the preceding Record: `model = initModel`.
    It means that `model` will get populated with the `initModel` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This record will get stored in our `Main.model`. Next, the `Main.view` function
    takes the values from the model and gives them to the `div` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We ended up where we began, but now we know that on the first run, our app
    will give our `UnitConverter.view` the `model.lengthConverter` parameter that
    has the following initial values: "Miles", "Kilometers", and 1.608.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, our app will give our `UnitConverter.view` the `model.weightConverter`
    parameter that has the following initial values: "Kilograms", "Pounds", and 2.2046.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s only the first part of the rendering process. What happens next
    is this bit of code: `Html.map LenghtConverterMsg`, and `Html.map WeightConverterMsg`,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the `Html.map` function now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Html.map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding `Html.map` is simple. Let''s start with the official documentation,
    available at [http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map).
    The documentation says that `Html.map` is used to:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Transform the messages produced by some Html."'
  prefs: []
  type: TYPE_NORMAL
- en: That's all it does!
  prefs: []
  type: TYPE_NORMAL
- en: Now, why do we need to transform messages produced by `UnitConverter.view model.lengthConverter`
    in our `Main.elm` file? Because in order to use the Html Msg that gets returned
    from the `UnitConverter.view model.lengthConverter` expression, we need to match
    it to the `LengthConverterMsg` type that the `Main.update` function will be using.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll add the `update` function to our app and then remove
    the `Html.map` from the `Main.view` function to see what kind of error will be
    thrown by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Main.update function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start off, let''s add the following code to our `Main.update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to what you might think the first time you look at the preceding code,
    there is not a lot going on there. As usual, our update function takes a message
    and a model. The message comes from the `Model.view` function, and it can either
    be `LengthConverterMsg` or `WeightConverterMsg`, as determined in the `Msg` union
    type above the update function.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing
    a Unit Conversion Website in Elm*, for the `case` expression to compile successfully,
    it needs to cover all possible options, and `LengthConverterMsg` and `WeightConverterMsg`
    patterns do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Going into a `LenghtConverterMsg` pattern, we can see that it takes a parameter
    we called `msg_`. This name was given in order to distinguish between the first
    argument passed to the `update` function, which is just called `msg` (without
    the underscore).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `LenghtConverterMsg` pattern, we have a `let` expression, and inside
    of its `let` part, we specify a locally-scoped `newLengthConverter`, which gets
    the value evaluated from the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the let-expression''s `in` part, we return this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is straightforward: the `lenghtConverter` gets updated with
    the value returned from the computation of the expression saved in `newLengthConverter`.'
  prefs: []
  type: TYPE_NORMAL
- en: In case our `Main.update` function's case statement pattern matches the `WeightConverterMsg` pattern,
    the operations performed are almost identical—the only difference is that `model.weightConverter` is
    being passed as the second argument to the `UnitConverter.update` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this section, let''s look at the `Main.update` function''s type
    annotation, as suggested by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The update function takes a `Msg` and a `Record` and returns a `Record`.
  prefs: []
  type: TYPE_NORMAL
- en: If we save all the files and run the app at this point, we'd get a fully functional
    unit converter. However, we still need to remove the `Html.map` from the `Main.view`
    function, as announced a few pages back, since we want to see what kind of error
    the compiler will throw.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with error messages in Elm is a great way to learn more advanced concepts,
    or reinforce concepts that are somewhat familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Learning from compiler error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by removing a single `Html.map` function from `Main.view`, so
    that its updated code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to remove the type annotation as well, to avoid additional error
    messages. Saving and running the app after these changes will produce the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed previously, the first entry, since it's not being converted
    to `lengthConverterMsg` via `Html.map`, has the type of `Html UnitConverter.Msg`.
    Looking at the `Msg` union type of the `UnitConverter` type, we can see that it
    can be either `Swap` or `Convert String`.
  prefs: []
  type: TYPE_NORMAL
- en: However, looking at Main's `Msg` union type, we can see that it can be either
    `LengthConverterMsg UnitConverter.Msg`, or `WeightConverterMsg UnitConverter.Msg`.
    In other words, it can be either of these two function constructors, taking `UnitConverter.Msg`
    as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the point home, let''s erase the other piped function from `Main.view`
    as well. Doing that will produce the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the changes made to our code's logic. However, there is still
    quite a lot of work to be done. We will make our app look a lot nicer by using
    a free Bootstrap 4 template as our starting point and then adjusting it to our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: A Bootstrap-based HTML layout for our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the completed layout for our app. The layout is based on the Cover
    template provided by the official Bootstrap docs, and has several sections. We'll
    cover them in the order in which they appear in the code, top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we have the `DOCTYPE` and the `head` tag. This code sets the
    Bootstrap 4 template as an HTML5 page, provides some meta information, gives our
    page a title, and calls the Bootstrap 4 CSS from a CDN (content delivery network):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just above the closing `head` tag, we have a relatively lengthy `style` tag.
    This tag provides custom CSS styles on top of the regular Bootstrap 4 styles we
    imported from a CDN, as explained in the preceding code. The custom styles have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `body` tag, which holds the page title and the input fields
    for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we put all of the preceding sections together and save them as an HTML
    file, then run that file in a browser, the browser will render a page that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83a220b7-9874-48b2-9dbd-4c02374a0f66.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a nice layout to work with, let's convert it into an Elm `view`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an HTML layout into an Elm view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve completed the previous section of this chapter, it''s time
    to take a break from Unit Converter App''s functionality, and look at our app
    from an entirely different angle: design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fully understand the process of creating a design for our app,
    we''ll take a drastic approach: we''ll build a new app from scratch, this time
    focusing on design only. After we''ve finished our design, we''ll add the changes
    to our Unit Converter''s functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to follow along, you should create a completely new app. Let''s
    call it design-focused. Point your console to a folder in which you want to save
    your design-focused app, and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen so many times before, this will run a brand new Elm app, displaying
    only a navy blue-colored Elm logo at the upper-center section of our browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start building our app''s design. To begin, we''ll remind ourselves
    of the bare-bones template we used in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our bare-bones app, it''s time to add custom styles to it.
    In our HTML template, we served them from the head of the HTML document. This
    time, we''ll do something different. Just under the imports in the bare-bones
    app, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What this does is create a style tag that calls the minified Bootstrap CSS file
    from a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll update our app''s `view` function so that its code is the same
    as the one we have in our HTML layout. Once converted from HTML to Elm (using
    the online converter at [https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/)),
    we''ll just add the `stylesheet` function, as follows. The layout''s HTML, in
    the form of an Elm `view` function, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have given our app a static view that gets rendered to our web page.
    However, we are serving no custom styles from the Cover template we got from the
    official Bootstrap site.
  prefs: []
  type: TYPE_NORMAL
- en: There is a great CDN that can help us with that, called RawGit, available at [https://rawgit.com/](https://rawgit.com/).
    What RawGit does is let you use any raw file from GitHub, paste in its address,
    and get back a CDN link that you can use in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: So, for our custom Cover template's CSS to be included in our app, we can just
    locate its raw address on GitHub, which is as follows: [https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css). Now
    that we have the raw link, we can just paste it into RawGit, and use the following
    link that it gives us: [https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the Cover template styles too, just under the `bootstrapCss`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to call these styles in our `view` function. The update will occur
    at the beginning of the `view` function so that its first few lines look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have saved everything and run our app, we'll see the static view
    with all the styles served. There is just a slight improvement that needs to be
    made, and that is that the `div` with the class of `site-wrapper-inner needs`
    to be set to the width of 100vh. Let's do that now in our view function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the following line of code in the `view` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace that line of code with the improved code that adds the inline
    style using the `style` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's change the buttons on our app by giving them a different class.
    In Main.elm's `view` function, find all the instances of `btn-secondary` and replace
    them with `btn-warning`.
  prefs: []
  type: TYPE_NORMAL
- en: You also might want to change that dark background color to something more pleasing.
    Unfortunately, we cannot just replace one class with another, since the background
    color is specified in the custom cover.css file that we are serving from the CDN.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, we''ll use an online CSS gradient generator,
    available at [https://uigradients.com/#VeryBlue](https://uigradients.com/#VeryBlue).
    This link points to their #VeryBlue gradient, but feel free to use another that
    suits you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS we generated from the gradient website is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can convert it to inline Elm styles and update the outermost `div`
    of our `view` function so that the first dozen lines of our `view` function look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update the input fields now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s introduce the append `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code produces a nice-looking site. However, we still need to add
    the preceding `view` information to our functioning app. We'll do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the improved view to our functioning app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we built our app's functionality. After that,
    we built a design from scratch, based on a free Bootstrap 4 template. Now, it's
    time to get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, switch back to the app we called **unit-converter-complex**. Next,
    simply copy and paste the slightly-improved code into the updated `UnitConverter.elm`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll focus on changing the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first improvement we will make will be a simple replacement of other function
    calls with button functions where needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll slowly start building our more Bootstrap-like look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll pull in everything inside the wrapping `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s pull in the append buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After building up the site slowly from the inside out, the final code will
    be as follows. The `Main.elm` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UnitConverter.elm` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot of code, but we have discussed all of it already. Even though
    there are some changes from what we had in the original design-focused file, the
    important thing is that we have finally built a fully functional, beautiful Unit
    Conversion website in Elm.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml), *Completing the
    Unit Conversion Website in Elm*, we improved our Unit Converter app so that it
    works with multiple inputs, that is, it can convert more than a single unit of
    measurement. Along the way, we learned a number of important concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Html.map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with complex relationships between different views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple messages in views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining everything we learned in a relatively complex app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first five chapters of this book, we have followed a hands-on approach
    which has involved a lot of coding and app building. For the most part, we have
    briefly touched on theory only where it was absolutely necessary. In the next
    chapter, we'll fill in the gaps in our knowledge by exploring the Elm language
    in more detail.
  prefs: []
  type: TYPE_NORMAL
