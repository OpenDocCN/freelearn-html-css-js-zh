- en: Chapter 3. Front-end Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover a useful set of patterns that will speed up your frontend
    workflow. Meteor makes it easy to build rich frontend experiences, but we have
    to be careful with the number of computations our interface requires to function.
    Too many computations will slow down mobile devices. In this chapter, we are going
    to learn how to keep our computations short, DOM simple, and animations effective.
    You will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Super helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search engine optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application is always judged by how it looks. Now that we know how to make
    it perform, we need to learn how to make it look good. Nowadays, it is common
    practice to build the frontend while keeping the following two things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimalism**: This style of design makes your site concise by exposing only
    the necessary elements to have the site functioning. Less is more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive**: This style of programming makes your site usable everywhere,
    no matter how big the screen is. The HTML markup will always adapt depending on
    the width of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we are only going to cover how to program a responsive frontend because
    minimalism is a vast and highly debatable topic.
  prefs: []
  type: TYPE_NORMAL
- en: General settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first layer of customization begins with the `kyleking:customizable-bootstrap-stylus`
    package that we have already installed. Follow these steps to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/_globals/client/bootstrap/custom.bootstrap.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: (Leave the JSON file empty.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Meteor project using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice three new files have been added. These files will compile at
    runtime to produce your version of Twitter Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `/_globals/client/bootstrap/custom.bootstrap.json`, and make sure that
    all variables are set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By setting all the variables to `true`, we are reeling in all the functionality
    that `bootstrap` has. If there is anything you do not want to use from the framework,
    you can deactivate it by setting it to `false` in this file.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to manually restart Meteor for these changes to take effect. So
    press *Ctrl* + *C* on your terminal to stop Meteor and run the `meteor` command
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can edit `bootstrap`. Start by opening the `/_globals/client/bootstrap/custom.bootstrap.import.styl`
    directory. Here, you are going to find a library of the Stylus variables that
    we can play with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove rounded corners and modify button border colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we need to use bootstrap mixins and variables for custom style sheets?
    We can use the `@import` command whenever we need to gain access to everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s customize our products page by adding a large promoter. Rewrite the
    products template with a new `#promoter` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we write our product styles, let''s create a global style sheet for
    any application-wide styling at `/_globals/client/main.styl`. Here, we are going
    to make sure that our initial views are set correctly so that we may properly
    make use of relative units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this set of rules, we are basically making sure that everything has the
    height of the viewport including our first `.template` DOM element. This technique
    allows us to have relative percentage heights work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set the root DOM element for BlazeLayout. Let''s do this in
    a client/server configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the directory for the `products` styles: `/products/client/products.styl`.
    We will start by importing our variables into the file and setting some simple
    rules to make the promoter look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Great, this sets up our `promoter` section for any promotional images that we
    may want to add, and the site looks decent (but not good enough yet) on mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap is a library of CSS rules that makes development of simple layouts
    quick, thanks to the library of classes that it includes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend our products template to upgrade our `#promoter` header and add
    a `#features` section. We will use bootstrap to manage the grid in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are doing quite a few things here but nothing complex. First, we wrapped
    the contents of our `#promoter` header in bootstraps' grid. Bootstrap grids work
    only as advertised when they are under a `row` class. The `container` class controls
    our page-wide breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap columns are set using the `col-` class prefix followed by the target
    screen size, then an optional offset indicator, and finally, the number of columns
    that the element will span or offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| Class | Breakpoint | Offset |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `col-xs-*` | <768px | `col-xs-offset-*` |'
  prefs: []
  type: TYPE_TB
- en: '| `col-sm-*` | ≥768px | `col-sm-offset-*` |'
  prefs: []
  type: TYPE_TB
- en: '| `col-md-*` | ≥992px | `col-md-offset-*` |'
  prefs: []
  type: TYPE_TB
- en: '| `col-lg-*` | ≥1200px | `col-lg-offset-*` |'
  prefs: []
  type: TYPE_TB
- en: Bootstrap has a total of 12 columns (this can be modified in our `variables`
    file); each column supports offsetting and nesting too. Remember, the smallest
    screen size will override all other screen sizes if the other screen sizes are
    not defined. So, if you want three columns of every size, you will only need to
    define it for the smallest size screen. In this example, we are separating our
    `#features` section into three columns of every size above 768 px and treating
    this as a single column in anything below 768 px.
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any point you need to nest bootstrap columns, then you will need to place
    these new columns under a `row` class. The following example centers a six-column
    long `div` inside another six-column long `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are using Font Awesome to create some icons for our `#features` section as
    well. Here, we are using one of the Font Awesome's lesser known **icon stacking**
    feature. To use this feature, you only need to wrap a set of Font Awesome icons
    with a `span.fa-stack` element.
  prefs: []
  type: TYPE_NORMAL
- en: Font Awesome has a list of about 500 icons. If you want to use a different set
    of icons, feel free to check out the list of icons online at [http://fortawesome.github.io/Font-Awesome/icons](http://fortawesome.github.io/Font-Awesome/icons).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add a little bit of Jeet and Rupture to our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Jeet grid systems with Rupture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version of Stylus that we have installed (`mquandalle:stylus`) comes packaged
    with a lot of useful mixins, the most notable ones being **Jeet** and **Rupture**.
    Jeet is a grid system that is superior to Twitter Bootstrap because it is more
    flexible, and Rupture is a set of functions that simplifies media queries. Knowing
    how to leverage both Jeet and Twitter Bootstrap will increase the quality of your
    frontend designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s patch up our `#promoter` header to make our page more user friendly
    for users that are in landscape mode on smaller devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Rupture adds several mixins to easily control the `@media` queries: `below`,
    `above`, `between`, `landscape`, `portrait` and many more. You will find yourself
    using `below`, `landscape`, and `portrait` more often than the rest. To use these
    mixins in Stylus, we simply prefix a plus sign (`+`) before the command.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using `+below($screen-sm-min)` to define the CSS rules
    for all the devices whose widths are below bootstrap's `-sm` breakpoint. Then
    we will use `+portrait()` and `+landscape()` to define CSS rules for portrait
    and landscape modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use Jeet to control master columns using the `col()` mixin. This
    mixin takes in a fraction that defines the width of the element as a fraction.
    Consider the numerator as the number of columns that you want the element to take
    up and the denominator as the total number of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when we switch to landscape mode on a small device, our `#promoter`
    header is one column wide out of three, while our `#features` section is two columns
    wide out of three.
  prefs: []
  type: TYPE_NORMAL
- en: Super helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Meteor, you will quickly find yourself repeating helpers among templates
    for simple things such as formatting. We can prevent repetition by creating a
    global dictionary of functions—this is what we call a super helper. To do this,
    we are going to tap into Meteor's rendering engine—Blaze.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that Blaze is deeply integrated with Spacebars,
    and Spacebars is Meteor's updated version of HandlebarsJS. HandlebarsJS is a JavaScript
    templating engine that enables the use of helpers and components on the frontend
    using `{{}}`. This legacy means that Spacebars has a lot of the HandlebarsJS functionality.
    So, much of the documentation found in HandlebarsJS applies to Meteor helpers
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Blaze helper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meteor exposes the `Template.registerHelper` function to create global helpers.
    Let''s create something to help us format money:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax for a global helper is exactly the same as it would
    be for a template helper. Now, we can use this helper in any template. Let''s
    create a product template under our `/products` directory for our `products` template
    and try it out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to patch our products template as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some temporary entries to our products collection. We will use these
    entries throughout the rest of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in this data schema we are defining `price` in cents. This is a common
    practice when dealing with money in JavaScript to avoid arithmetic floating point
    issues. What does this mean? Go to your web browser''s console, and run the following
    operation: `0.1 + 0.2`. Oddly enough, JavaScript does not respond with `0.3`;
    it responds with `0.3000000000004` instead. The reason for this is JavaScript''s
    internal 64-bit floating point representation of decimal numbers. This means that
    JavaScript does not fully understand what a decimal number is. This is why, we
    do not use decimal numbers when we deal with money, we just use the smallest available
    denomination.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a global dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wait, we can still make this formatter more widely available in our application.
    Let''s turn this into a dictionary and share it with our controllers. In other
    words, we want to be able to use a helper such as `{{format.money amount}}` and
    use this in our CoffeeScript in the form of `format.money amount` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an object that holds our definitions, and we make it global
    using `@` (which is equal to `this`). Then we place this object of definitions
    inside a global helper. Simple! Now we know how to build a super helper that we
    can use anywhere. To test this, type `format.money(1099)` in your browser's console;
    this should return **"$10.99"**.
  prefs: []
  type: TYPE_NORMAL
- en: Variable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four types of variables that we need to understand to optimize our
    frontend workflow: **session**, **persistent**, **file scope**, and **ReactiveVar**.
    With these variables, we can build dynamic sites easily based on how the user
    is interacting with the view.'
  prefs: []
  type: TYPE_NORMAL
- en: The session variables are variables that exist only during a session. A session
    begins whenever a user hits the site. These variables can be shared across routes
    and are reactive.
  prefs: []
  type: TYPE_NORMAL
- en: The persistent variables are variables that are stored in local storage so that
    they can be read even after the session closes.
  prefs: []
  type: TYPE_NORMAL
- en: The file scoped variables are variables that only exist within the scope of
    the file. These are generally not reactive.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveVar variables can be scoped to the file or globally and are reactive.
    These variables do not persist the way session variables do.
  prefs: []
  type: TYPE_NORMAL
- en: Session variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Meteor developers believe that session variables are overused. This is
    definitely true, if you are not managing them. For the most part, session variables
    should be used to handle data that is shared across multiple routes in your application,
    have no place in your database, need reactivity, and persist through a hot code
    reload.
  prefs: []
  type: TYPE_NORMAL
- en: If you stop and think about it, not many things require all of these attributes.
    At first, you may rely on them heavily to control your frontend, but as your frontend
    becomes more minimal, you will realize there is no need for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, if you are going to use them, you should follow two rules to maintain
    them, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Template-based taxonomy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear them if you are not going to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The taxonomy of session variables should always follow the `<template.variable>`
    pattern to keep them from polluting each other. Suppose we want to control a global
    alert using session variables, the session variable would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our user leaves the view, we should clear the session variable. The `clear`
    function is added by the `u2622:persistent-session` package that we installed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with Meteor"),
    *Getting Started with Meteor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use session variables along with Meteor methods to obtain server data.
    While the method works, it makes your data vulnerable and easy to modify on the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Also, try to stay away from using session variables that are composed of complex
    objects with multiple keys or arrays. You will quickly find yourself using lesser
    lookup tools such as `_.find` and `_.findWhere` to use the data.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Persistent variables are session variables that persist through a session. In
    Meteor, a common session variable will reset if the user refreshes the page. Persistent
    variables leverage AmplifyJS, which in turn uses HTML5 local storage and fallbacks
    to store the variable inside the user's browser. These types of variables exist
    because of the `u2622:persistent-session` package.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this variable to keep track of our users' orders, in case they leave
    the site and are not logged in. So, if the user opens up an order and fills it
    with items, they can come back to it later without making a user account on our
    site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `add-to-cart` button that will leverage the persistent variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to build a publisher for this to work, but we have to make a choice.
    As we have both `products` and `product` template, each one could subscribe to
    a publisher and pull in the same data. Should we subscribe from the `product`
    or the `products` template? Let''s do both! Extending the products publisher will
    ensure that we get all the data that the template needs while the attached publisher
    will help us manage our "product details" page and promos when we need it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we wire up our subscriber with the order key on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, now we can add products to an order, refresh the site, and still
    come back to our order. Let''s finish building the publisher for the `product`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our product is bringing in only the data that is pertinent to that
    product and for that order. Now we can program our subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: File scope variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the types of variables you will want to use most of the time. What
    are they? They are regular variables! This means that they are not reactive, so
    watch out. Regular variables are scoped for the file only, so you do not need
    to worry about interfering with the variables that are named the same in other
    files.
  prefs: []
  type: TYPE_NORMAL
- en: These variables are useful for things such as lists that you know will not change
    and that you will not need anywhere else in the application. To use one, simply
    type out a variable outside your Meteor-specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveVar variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ReactiveVar variables are reactive variables that are not available to the
    console in the way that session variables are. This makes them great for things
    that are reactive and that we want to keep relatively difficult to access for
    the user from the console.
  prefs: []
  type: TYPE_NORMAL
- en: If at any point you are creating a highly reactive interface, you should fill
    it up with these variables so that you do not have to worry about managing them.
    These variables cleared automatically if there is a hot code reload or a page
    refresh.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a reactive variable, you simply define a variable with its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable will expose setter and getter functions. This means that you
    use the `.get` command to see the value of the variable and the `.set` command
    to change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the ReactiveVar variables to create a rich number input interface
    for our quantity field. We will start by defining a route name as `order_quantity`
    with a `product` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can wire up our product with a new button that will take us to the modify
    quantity view and passes to our product ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to design a responsive number pad. First, let''s add a global `vertical-align`
    class to our `/_globals/client/main.styl` directory so that we can easily align
    things vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use Jeet to control this design since it requires more specific control
    of our DOM elements. Let''s start by creating the layout of the page in our `order_quantity`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are using the `vertical-align` class on the element that we
    want to align vertically. We are going to make each of these elements a large
    button. Also, we will create a `numbers` helper to write out our numbers to the
    number pad, and the `total` helper will be our reactive variable. Let''s have
    a look at our styles before we create our helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have passed the parameters to Jeet: `gutter` and `cycle`.
    Gutter makes sure that there are no margins, while cycle makes sure that the elements
    can only make rows with a maximum of 3 elements per row. We have made each section
    take up exactly 50 percent of the height of the screen but ensured that scrolling
    wouldn''t happen by setting `overflow` to hidden. Knowing that we are always going
    to have four rows of numbers, we set our height for each number to 25 percent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s put our `ReactiveVar` variable knowledge to work. First, we set
    up our variable and attach it to the template instance using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the `numbers` helper and the helper that will render our (`total`)
    reactive variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to handle the events to update our `ReactiveVar` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you take a good look at how the `add-to-cart` event works, you will notice
    that it is almost identical to the event that we wrote for the products template.
    We are effectively repeating ourselves at this moment, but we will make our code
    less repetitive through `Meteor.methods` later.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we are using ReactiveVar the same way as we would use a session variable
    with the difference that we are not exposing the variable to the console. This
    helps to make the interface a bit more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not forget to add our publishers for this view to work, we will need
    `Products`, `Orders`, and `OrderDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We learned how to build a custom form using ReactiveVar variables. The topic
    covers ReactiveVar and touches on Jeet. We learned how to use reactive variables
    to create rich UX.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our buttons and forms have been highly inefficient because they are
    not easy to repeat, and therefore, not easy to maintain. There are two ways that
    we can use to make our code easier to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: Meteor Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Meteor Methods, we can easily create **repeatable** and **secure** functions
    while autoforms can identify the structure of a collection and generate form elements
    from it. This provides a decent layer of security without much effort as well.
    Autoform and Meteor Methods can be used together as well for further security.
  prefs: []
  type: TYPE_NORMAL
- en: The autoform method can be implemented through the `aldeed:autoform` and `aldeed:collection2`
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Meteor Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meteor Methods can be used on the client or the server. They are created by
    using the `Meteor.methods(<object-of-functions>)` function and run with the `Meteor.call(<function-name>,
    <callback function>)` function. Running a meteor method from the client causes
    2 versions of the same function to run. One runs on the server and manipulates
    data while the other runs on the client and simulates data manipulation. This
    is what we call a Method Stub. Let''s look at some example code to understand
    this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the function, the Meteor Method activates both the server-side
    and client-side functions. So the server in this case will log "I don't want to
    say hello" to the console while the client will log "hello". This is a special
    feature that Meteor provides to help validate code or run other functions in parallel
    on the server without exposing sensitive data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Still, it is important to note that the client-side method will run immediately
    while the server-side method will take longer. The client-side code should, therefore,
    be used for simulation while the server-side code should be used for validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define and use a Meteor Method that runs on both the client and the
    server. Let''s start by redefining the `add-to-cart` events that we had programmed
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we added a line at the end of the method to check for a callback function
    and run it, if it exists. Observe how we have accepted a function as one of our
    parameters in the beginning of the function. To follow in Meteor''s footsteps,
    we return `null` as the error object and `true` as the result after the function
    has completed. Now let''s replace the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Meteor Methods are great to create rich and easily repeatable user interfaces,
    but you will eventually find yourself repeating certain patterns if you are only
    updating a single collection. This is where autoforms come in.
  prefs: []
  type: TYPE_NORMAL
- en: Autoform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `autoform` plugin was installed together with the `collection2` plugin.
    Both of these work together to quickly create forms that support error handling
    for you. Documentation on these plugins is vast, but it is necessary to read this
    to make your views safe and easy to build. You can find this documentation at
    [https://github.com/aldeed/meteor-autoform](https://github.com/aldeed/meteor-autoform).
    We are going to cover a simple pattern to show you how to easily manipulate autoforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use autoform, you need to first create a `collection2` schema for your collection.
    This defines the rules that autoform is going to use to validate and generate
    our input fields. Let''s populate our products schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Attaching a schema to our collections makes sure that the client-side console
    commands cannot add information to the database that is not a part of the schema.
    Let''s reset our project to make sure our new products adapt to the new schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a simple insert form for our products collection using autoforms.
    Let''s create the template and route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we do not need to write a controller to make this work. There are
    two critical components that we need to understand in this case: `autoForm` and
    `afQuickField`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use `autoForm` with a collection, we have to declare the name of the
    collection using the `collection` parameter. Also, we need to define whether the
    form is doing an insert, update, or method call using the `type` parameter, and
    finally, we give the form an `id` that will be used as the HTML `id` attribute
    for the form. Additionally, we pass the `preserveForm` parameter to make sure
    that the data persists through hot code reloads. There are several other parameters
    that autoform takes, but these are the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `afQuickField` component specifically creates a `bootstrap3` input field
    that can easily handle errors. Notice that we can add HTML attributes (such as
    `autocorrect` and `autocomplete`) to these components as well as parameters. There
    are a variety of ways to customize these inputs but we recommend only two: modifying
    the CSS directly or leveraging `afFieldInput` and `afFieldIsInvalid` to build
    new elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s customize our `price` field a little bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, we are very easily adding a `glyphicon` to our field using bootstraps'
    classes, but this can be useful for adapting our forms to any framework, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still a bit of an issue with this form though, people input prices
    in dollars instead of cents, but our schema only accepts cents. Let''s transform
    this data before it is submitted using autoform''s **hooks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Autoform has a long list of hooks, but by far the most useful one for transformations
    is `formToDoc`. This function runs every time the form is converted to a document
    for processing, this includes before the errors are processed. We do not use the
    "before hook" because this hook will run after processing errors. Also, we are
    using a `docToForm` hook to make sure that our `price` field stays intact after
    a code reload. Autoform has the following hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can quickly create forms and modify them to the way we like while
    preserving usability. Stay away from fields that require arrays! They are difficult
    to manage in our application and can always be expressed as a new collection in
    our models.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance of our frontend can suffer if we do not load data correctly
    because it can make the DOM redraw quickly multiple times. If the calculations
    are complex, then we need to wait for all our data to be available and calculate
    everything in one single sweep. If we do not wait for data, then calculations
    will run as the data is received, which in turn will cause the DOM to redraw multiple
    times very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, we can easily check whether our subscribers are ready and
    show a loading symbol until they are.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the loading indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating a loading template. Let''s use font awesome to handle
    our animations and make sure that we can easily change the color of the loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using the `fa-spin` class to make the cog spin and adding
    a `color_class` helper that will take bootstraps' `text-` classes to define colors.
    Also, we made sure that the loader fills the contents of whatever is holding it
    so that everything aligns nicely when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the loading indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's implement the loading indicator for our list of products. Due to the way
    we are going to implement this, we could easily have our interface show the loading
    indicator for each product or the list of products. It will be more efficient
    to control the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s modify our products template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Meteor core exposes a special `Template.subscriptionsReady` helper that checks
    whether the subscriptions made in that template instance are all in the ready
    state. This is one of the hidden advantages of using `@subscribe` from our `Template.created`
    function instead of `Meteor.subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we only run the `each` iteration on the `products` variable until
    all subscriptions are ready. Before this happens, we render our `loader` component
    in our primary color.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to this pattern is that we can control exactly where we want our
    loader to be and when we want it to appear.
  prefs: []
  type: TYPE_NORMAL
- en: Animations and transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation for the web is a vast field that is still growing and can get highly
    complex if you want it to be. At the end of the day though, efficient animations
    are what make a real difference. How do you make an animation efficient? You keep
    it simple, and you let the browser animate it for you. Stay away from using JavaScript
    to identify positions and change colors. Animations that are heavy on JavaScript
    will always have terrible performance. This poor performance happens because JavaScript
    cannot run effectively in all devices, so multiple changes to the DOM occur at
    the maximum allowed speed of the device without using video memory.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas is an HTML element that is designed to render changes using JavaScript
    and WebGL. Animating anything through canvas will boost performance, but it is
    meant more for applications that want to do graphically intensive work such as
    3D rendering or sprite animations for a game. We will not cover canvas in this
    book because you will probably never need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignoring the power of canvas leaves us with two CSS tools to make rich animations:
    `animation` and `transition`. The `animation` property is meant for complex animations
    that require keyframes, while the `transition` property is meant for simple change-of-state
    animations. Let''s look at an example of each to first understand how they work,
    then we will apply them to Meteor.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating with CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `transition` property is the easiest property to understand. You basically
    define which property you are going to animate and how, within a CSS property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to realize that because of **Stylus Nib** (another useful Stylus
    plugin included in this package), we do not have to worry about vendor prefixes
    for this particular property. Nib will handle this for us automatically. By adding
    the transition property to the `box` class, we are telling the browser to animate
    any change that occurs on the defined property. How do these changes occur? With
    new classes. Let''s look at a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this set of CSS rules, we are making the box invisible until the `.in`
    class is dynamically added. Once the class is added, then the DOM element will
    fade in. The available timing functions are: `ease`, `linear`, `ease-in`, `ease-out`,
    `ease-in-out`, `step-start`, and `step-end`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `animation` property is a bit more complex because it does not require
    a dynamic class to activate the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the difference between a transition and an animation is the
    level of control you can have over the animation. By using an `animation name`
    and the `@keyframes` selector, we can control at which point of the animation
    we want our properties to change and to what. You can change the number on the
    keyframe to whatever number you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `animation` property has a few new parameters: `iteration count`,
    `fill mode`, and `play state`. The `iteration count` parameter defines how many
    times an animation is going to play; you can set this to infinite or a specific
    number. The `fill mode` defines the state at which you want the element to be
    when it is not animating: `forwards` sets values to the last defined keyframe,
    `backwards` to the first defined keyframe, both sets to `first` and `last`, and
    `none` will do nothing (default). The `play state` controls whether an animation
    is playing or not (paused or running).'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a second CSS selector to control our `play state`, if we need to
    in the same way that we did for our `transition` property.
  prefs: []
  type: TYPE_NORMAL
- en: Executing animations in Meteor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Meteor, it is very easy to control the classes that are rendered on the DOM
    using helpers, so we can quickly inject a class that will trigger our CSS animation.
    We will have issues when we want to trigger animations on elements that do not
    exist in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For example, once our products have loaded, they just pop in. What if we want
    to make the list fade in and the loader fade out instead? This is where Meteor's
    hidden `@_uihooks` function comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, this feature is in beta and is still a bit buggy. The
    best way to handle all the issues that this is causing is through the `percolate:momentum`
    package. This avoids the need to understand the issues that `uihooks` currently
    has and how to get around them.
  prefs: []
  type: TYPE_NORMAL
- en: The `momentum` package is designed to intercept Blaze by using the `@_uihooks`
    function that is made available in the context of the `Template.rendered` function.
    It is very easy to use and comes packaged with VelocityJS, a jQuery plugin that
    handles transitions somewhat effectively. We can use a combination of both to
    help keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'To customize momentum, we need to register momentum plugins that handle the
    three hooks that can occur in our DOM: `insertElement`, `removeElement`, and `moveElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| `insertElement` | Occurs when a DOM element is created |'
  prefs: []
  type: TYPE_TB
- en: '| `removeElement` | Occurs when a DOM element is destroyed |'
  prefs: []
  type: TYPE_TB
- en: '| `moveElement` | Occurs when a DOM element is moved from it''s DOM location
    (sorting can cause this to be triggered) |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s build the plugin named `fade-fast` that will control the fading in and
    out of our loading indicator of our products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We use the `node` variable to modify the elements that we are going to inject
    into the DOM, and we always use `insertBefore` with the `next` variable as a parameter
    to render. Notice that in this case, when we insert, we are adding three classes
    before the items are rendered to the DOM, and then after 250 milliseconds, we
    remove the invisible class.
  prefs: []
  type: TYPE_NORMAL
- en: When an element is removed, we will use `velocity` to modify `opacity` and bring
    this down to `0` in exactly `250` milliseconds. Velocity takes in a callback command
    that we will use to finally remove the element from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add our styles and place the helper inside our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have added a `momentum(plugin="fade-fast")` component that defines
    which plugin to use around the area that is going to render elements with animations.
    Then we create the classes that will use CSS transition to make each DOM element
    fade in.
  prefs: []
  type: TYPE_NORMAL
- en: SEO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meteor has one big problem. It does not support server-side rendering out of
    the box. This means that robots don't know how to parse our pages because the
    server does not render the page, the client does! There are many ways to solve
    this issue. You can try using `meteorhacks:ssr` to enable server-side rendering
    or you can let a service automate this for you for free. We are going to use a
    service to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Prerender.io
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meet prerender.io, the easiest way to get your site parsed. Prerender.io is
    mostly a free service that understands exactly how to parse your page. It basically
    navigates to your `webapp` and parses each page, and then when a bot hits our
    `webapp`, our server will fetch the parsed page from prerender.io and respond
    with this instead.
  prefs: []
  type: TYPE_NORMAL
- en: The service is free for the webapps that have a minimal number of pages that
    get hit by bots. The more dynamic and the more pages you have, the higher the
    price will be, but this is unlikely unless you are building a highly dynamic public
    web page. Even then, the `prerender.io` project can be downloaded and set up personally
    (so it's still free).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have installed the `dfischer:prerenderio` package to easily set up the service.
    The only thing that is left is for us is to authorize. First, go to [www.prerender.io](http://www.prerender.io)
    and open an account, then click the **INSTALL TOKEN** tab on their navbar, and
    copy your token. Now paste your token under the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple! Your site is now crawl-able. Now let''s configure our router to work
    with prerender and add a 404 page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are creating a global `Template.created` hook function and setting
    `prerenderReady` to `false` by default. Then, we check whether our subscriptions
    are ready using `@subscriptionsReady()` and set `prerenderReady` to `true`. It's
    important to understand that `@subscriptionsReady()` only checks for subscriptions
    made through `@subscribe` within the template!
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that we are creating a list of exceptions. This is to ensure that
    we only check for subscribers on templates that need them.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern ensures prerender does not cache the page until it has actually
    loaded all the data. Why not use `FlowRouter` global triggers? Sadly, these triggers
    do not have access to the template instance that is being rendered (since there
    can be many). If you need more control, you can set this per route/template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work on our 404 page template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To make sure our 404 page prints out the correct 404 response, we are going
    to have to use `Meta`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Meta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control prerender, we need to use the `yasinuslu:blaze-meta` package. This
    package basically injects a template to our `head` HTML tag so that we can easily
    set tags. Prerender uses tags to identify whether the page should respond with
    a 404\. We can use Meta to set our title, description, keywords, and robots properties
    as well. Let''s start by making our 404 page respond with a 404:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Meta` object has only four functions: `set`, `setTitle`, `unset`, and
    `config`. It is unlikely that you will use `unset` because metatags do not persist
    through routes. Both the `set` and `unset` functions require an array of objects,
    and each object requires all the three keys: `name`, `property`, and `content`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we are setting `prerender-status-code` to `404` and
    `robots` to `noindex, nofollow`. With this, we ensure that our 404 page in fact
    returns a 404 error and that crawlers do not index the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to configure `Meta` so that the name of the page is always correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since `Meta` is controlling our `title` tag, we need to remove that tag from
    `layout.jade`.
  prefs: []
  type: TYPE_NORMAL
- en: Schema.org
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our site is crawl-able, we want our products to shine for search engines.
    Let's upgrade our products to enable Rich Snippets. Rich Snippets follow schema.org
    standards to build structured data for search engine crawlers such as Google to
    interpret. With this information, search engines can present your data on their
    site more prominently, make searches more effective, and even use it in other
    services. Following their guidelines is a good idea because Google uses these
    guidelines for its crawler.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, all we need to do is set as many schema.org''s properties as possible
    on our product page. Visit [http://schema.org/Product](http://schema.org/Product)
    for a full list of the available properties. The properties that are most used
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` (required) | `Text` | The name of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | `URL` | The URL of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | `Text` | The description of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `offers` | `OFFER OBJECT` | This includes multiple parameters that define
    the price of the object |'
  prefs: []
  type: TYPE_TB
- en: '| `price` (required) | `Number` | The price of the product |'
  prefs: []
  type: TYPE_TB
- en: '| `priceCurrency` (required) | `Text (ISO 4217) [ex: USD]` | The currency of
    the price |'
  prefs: []
  type: TYPE_TB
- en: 'Now let''s put this to practice using the `MicroData` spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to use the `MicroData` spec, you need to add a variety of custom
    attributes to your view. For the most part, anytime you are going to declare what
    a particular thing is, you need to express this via the `itemscope` and `itemtype`
    attributes. When we want to declare properties under this declaration, we need
    to make sure our DOM elements are children of this declaration and that the property
    is declared through the `itemprop` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered several useful patterns that make the implementation of
    rich and minimal interfaces easy. First, we learned how to use the Twitter Bootstrap
    framework together with Jeet and Rupture; this improved the way we organize our
    DOM. Also, we learned how to make super helpers—functions that we can call in
    both views and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: We took a dive into the different kinds of variables that we can use to keep
    our code safe and to create rich interfaces. Also, we learned how to use Meteor
    Methods and autoform to easily save information. We covered how to implement a
    simple loading indicator and how to get animations working in Meteor. To finish
    up, we learned how to implement a little SEO using prerender.io and the `Meta`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover application-wide patterns. [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns* will teach us how to
    filter and page through collections, how to fully secure our application, and
    how to integrate with external APIs.
  prefs: []
  type: TYPE_NORMAL
