- en: Chapter 3. Front-end Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。前端模式
- en: 'This chapter will cover a useful set of patterns that will speed up your frontend
    workflow. Meteor makes it easy to build rich frontend experiences, but we have
    to be careful with the number of computations our interface requires to function.
    Too many computations will slow down mobile devices. In this chapter, we are going
    to learn how to keep our computations short, DOM simple, and animations effective.
    You will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一组有用的模式，这将加快您的前端工作流程。Meteor 使构建丰富的前端体验变得容易，但我们必须注意我们的界面需要多少计算才能运行。过多的计算会减慢移动设备。在本章中，我们将学习如何使我们的计算简短、DOM
    简单和动画有效。您将学习以下主题：
- en: Responsive design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式设计
- en: Super helpers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超级助手
- en: Variable types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量类型
- en: Quick forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速表单
- en: Loading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载
- en: Animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Search engine optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎优化
- en: Responsive design
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式设计
- en: 'An application is always judged by how it looks. Now that we know how to make
    it perform, we need to learn how to make it look good. Nowadays, it is common
    practice to build the frontend while keeping the following two things in mind:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序总是根据其外观来评判。现在我们知道了如何让它表现良好，我们需要学习如何让它看起来很好。如今，在构建前端时，同时考虑以下两点是一种常见的做法：
- en: '**Minimalism**: This style of design makes your site concise by exposing only
    the necessary elements to have the site functioning. Less is more.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**极简主义**：这种设计风格通过仅显示使网站正常运行的必要元素来使您的网站简洁。少即是多。'
- en: '**Responsive**: This style of programming makes your site usable everywhere,
    no matter how big the screen is. The HTML markup will always adapt depending on
    the width of the screen.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：这种编程风格使您的网站无论屏幕大小如何都能使用。HTML 标记将始终根据屏幕宽度进行调整。'
- en: Here, we are only going to cover how to program a responsive frontend because
    minimalism is a vast and highly debatable topic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只将介绍如何编写响应式前端，因为极简主义是一个广泛且高度争议的话题。
- en: General settings
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用设置
- en: 'The first layer of customization begins with the `kyleking:customizable-bootstrap-stylus`
    package that we have already installed. Follow these steps to set this up:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定制化的第一层开始于我们已安装的 `kyleking:customizable-bootstrap-stylus` 包。按照以下步骤设置此包：
- en: 'Create the following directory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下目录：
- en: '`/_globals/client/bootstrap/custom.bootstrap.json`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`/_globals/client/bootstrap/custom.bootstrap.json`。'
- en: (Leave the JSON file empty.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: （保留 JSON 文件为空。）
- en: 'Run the Meteor project using this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式运行 Meteor 项目：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice three new files have been added. These files will compile at
    runtime to produce your version of Twitter Bootstrap.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到已添加了三个新文件。这些文件将在运行时编译以生成您版本的 Twitter Bootstrap。
- en: 'Open `/_globals/client/bootstrap/custom.bootstrap.json`, and make sure that
    all variables are set to `true`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `/_globals/client/bootstrap/custom.bootstrap.json`，并确保所有变量都设置为 `true`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By setting all the variables to `true`, we are reeling in all the functionality
    that `bootstrap` has. If there is anything you do not want to use from the framework,
    you can deactivate it by setting it to `false` in this file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有变量设置为 `true`，我们正在引入 `bootstrap` 所有的功能。如果您不想使用框架中的任何功能，您可以通过在此文件中将它设置为 `false`
    来禁用它。
- en: You will need to manually restart Meteor for these changes to take effect. So
    press *Ctrl* + *C* on your terminal to stop Meteor and run the `meteor` command
    again.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要手动重新启动 Meteor 以使这些更改生效。因此，请在您的终端上按 *Ctrl* + *C* 停止 Meteor 并再次运行 `meteor`
    命令。
- en: Now we can edit `bootstrap`. Start by opening the `/_globals/client/bootstrap/custom.bootstrap.import.styl`
    directory. Here, you are going to find a library of the Stylus variables that
    we can play with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编辑 `bootstrap`。首先打开 `/_globals/client/bootstrap/custom.bootstrap.import.styl`
    目录。在这里，您将找到一个我们可以玩转的 Stylus 变量库。
- en: 'Let''s remove rounded corners and modify button border colors:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除圆角并修改按钮边框颜色：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if we need to use bootstrap mixins and variables for custom style sheets?
    We can use the `@import` command whenever we need to gain access to everything:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为自定义样式表使用 bootstrap 混合和变量怎么办？我们可以在需要访问一切时使用 `@import` 命令：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s customize our products page by adding a large promoter. Rewrite the
    products template with a new `#promoter` header:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个大型推广者来自定义我们的产品页面。用新的 `#promoter` 标题重写产品模板：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we write our product styles, let''s create a global style sheet for
    any application-wide styling at `/_globals/client/main.styl`. Here, we are going
    to make sure that our initial views are set correctly so that we may properly
    make use of relative units:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写产品样式之前，让我们在 `/_globals/client/main.styl` 中创建一个全局样式表，用于任何应用程序范围内的样式。在这里，我们要确保我们的初始视图设置正确，以便我们可以正确地使用相对单位：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this set of rules, we are basically making sure that everything has the
    height of the viewport including our first `.template` DOM element. This technique
    allows us to have relative percentage heights work as expected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这组规则，我们基本上确保了包括我们的第一个 `.template` DOM 元素在内的所有内容都具有视口的高度。这种技术使我们能够使相对百分比高度按预期工作。
- en: 'We also need to set the root DOM element for BlazeLayout. Let''s do this in
    a client/server configuration file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为 BlazeLayout 设置根 DOM 元素。让我们在客户端/服务器配置文件中完成这项操作：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create the directory for the `products` styles: `/products/client/products.styl`.
    We will start by importing our variables into the file and setting some simple
    rules to make the promoter look good:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建 `products` 样式的目录：`/products/client/products.styl`。我们将首先将变量导入到文件中，并设置一些简单的规则，使促销看起来更好：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Great, this sets up our `promoter` section for any promotional images that we
    may want to add, and the site looks decent (but not good enough yet) on mobile.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，这为我们可能想要添加的任何促销图片设置了 `promoter` 部分，并且网站在移动设备上的外观相当不错（但还不够好）。
- en: Bootstrap
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap
- en: Bootstrap is a library of CSS rules that makes development of simple layouts
    quick, thanks to the library of classes that it includes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个包含 CSS 规则的库，它通过包含的类库使简单布局的开发变得快速。
- en: 'Let''s extend our products template to upgrade our `#promoter` header and add
    a `#features` section. We will use bootstrap to manage the grid in this case:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的产品模板，升级我们的 `#promoter` 标题并添加一个 `#features` 部分。在这种情况下，我们将使用 Bootstrap
    来管理网格：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are doing quite a few things here but nothing complex. First, we wrapped
    the contents of our `#promoter` header in bootstraps' grid. Bootstrap grids work
    only as advertised when they are under a `row` class. The `container` class controls
    our page-wide breakpoints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了很多事情，但没有什么复杂的。首先，我们将 `#promoter` 标题的内容包装在 Bootstrap 的网格中。Bootstrap 网格只有在具有
    `row` 类的情况下才会按预期工作。`container` 类控制我们的页面宽度断点。
- en: 'Bootstrap columns are set using the `col-` class prefix followed by the target
    screen size, then an optional offset indicator, and finally, the number of columns
    that the element will span or offset:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 列的设置使用 `col-` 类前缀，后跟目标屏幕尺寸，然后是一个可选的偏移指示符，最后是元素将跨越或偏移的列数：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Class | Breakpoint | Offset |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Class | Breakpoint | Offset |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `col-xs-*` | <768px | `col-xs-offset-*` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `col-xs-*` | <768px | `col-xs-offset-*` |'
- en: '| `col-sm-*` | ≥768px | `col-sm-offset-*` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `col-sm-*` | ≥768px | `col-sm-offset-*` |'
- en: '| `col-md-*` | ≥992px | `col-md-offset-*` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `col-md-*` | ≥992px | `col-md-offset-*` |'
- en: '| `col-lg-*` | ≥1200px | `col-lg-offset-*` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `col-lg-*` | ≥1200px | `col-lg-offset-*` |'
- en: Bootstrap has a total of 12 columns (this can be modified in our `variables`
    file); each column supports offsetting and nesting too. Remember, the smallest
    screen size will override all other screen sizes if the other screen sizes are
    not defined. So, if you want three columns of every size, you will only need to
    define it for the smallest size screen. In this example, we are separating our
    `#features` section into three columns of every size above 768 px and treating
    this as a single column in anything below 768 px.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 总共有 12 列（这可以在我们的 `variables` 文件中修改）；每一列都支持偏移和嵌套。记住，如果未定义其他屏幕尺寸，则最小的屏幕尺寸将覆盖所有其他屏幕尺寸。因此，如果您想为每个尺寸定义三个列，您只需为最小尺寸的屏幕定义它即可。在这个例子中，我们将我们的
    `#features` 部分分成三个列，每个列的尺寸都大于 768 px，并在小于 768 px 的任何地方将其视为单列。
- en: 'If at any point you need to nest bootstrap columns, then you will need to place
    these new columns under a `row` class. The following example centers a six-column
    long `div` inside another six-column long `div`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候需要嵌套 Bootstrap 列，那么您需要将这些新列放置在 `row` 类下。以下示例在一个六列长的 `div` 内部中心对另一个六列长的
    `div`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using Font Awesome to create some icons for our `#features` section as
    well. Here, we are using one of the Font Awesome's lesser known **icon stacking**
    feature. To use this feature, you only need to wrap a set of Font Awesome icons
    with a `span.fa-stack` element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 Font Awesome 为我们的 `#features` 部分创建了一些图标。在这里，我们使用 Font Awesome 的不太为人所知的
    **图标堆叠** 功能。要使用此功能，您只需将一组 Font Awesome 图标包装在一个 `span.fa-stack` 元素中。
- en: Font Awesome has a list of about 500 icons. If you want to use a different set
    of icons, feel free to check out the list of icons online at [http://fortawesome.github.io/Font-Awesome/icons](http://fortawesome.github.io/Font-Awesome/icons).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome有一份大约500个图标的列表。如果你想使用不同的图标集，请随意查看在线图标列表[http://fortawesome.github.io/Font-Awesome/icons](http://fortawesome.github.io/Font-Awesome/icons)。
- en: Now let's add a little bit of Jeet and Rupture to our frontend.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的前端添加一点Jeet和Rupture。
- en: Jeet grid systems with Rupture
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Rupture的Jeet网格系统
- en: The version of Stylus that we have installed (`mquandalle:stylus`) comes packaged
    with a lot of useful mixins, the most notable ones being **Jeet** and **Rupture**.
    Jeet is a grid system that is superior to Twitter Bootstrap because it is more
    flexible, and Rupture is a set of functions that simplifies media queries. Knowing
    how to leverage both Jeet and Twitter Bootstrap will increase the quality of your
    frontend designs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装的Stylus版本（`mquandalle:stylus`）附带了许多有用的混合函数，其中最显著的是**Jeet**和**Rupture**。Jeet是一个比Twitter
    Bootstrap更优越的网格系统，因为它更灵活，而Rupture是一组简化媒体查询的函数。了解如何利用Jeet和Twitter Bootstrap将提高你前端设计的质量。
- en: 'Let''s patch up our `#promoter` header to make our page more user friendly
    for users that are in landscape mode on smaller devices:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复我们的`#promoter`标题，使我们的页面对在较小设备上以横幅模式浏览的用户更加友好：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Rupture adds several mixins to easily control the `@media` queries: `below`,
    `above`, `between`, `landscape`, `portrait` and many more. You will find yourself
    using `below`, `landscape`, and `portrait` more often than the rest. To use these
    mixins in Stylus, we simply prefix a plus sign (`+`) before the command.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rupture添加了几个混合函数来轻松控制`@media`查询：`below`、`above`、`between`、`landscape`、`portrait`以及更多。你会发现自己在使用`below`、`landscape`和`portrait`时比其他情况更频繁。要在Stylus中使用这些混合函数，我们只需在命令前加上一个加号（`+`）。
- en: In this example, we are using `+below($screen-sm-min)` to define the CSS rules
    for all the devices whose widths are below bootstrap's `-sm` breakpoint. Then
    we will use `+portrait()` and `+landscape()` to define CSS rules for portrait
    and landscape modes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`+below($screen-sm-min)`来定义所有宽度低于Bootstrap的`-sm`断点的设备的CSS规则。然后我们将使用`+portrait()`和`+landscape()`来定义横幅和横幅模式的CSS规则。
- en: 'Next, we will use Jeet to control master columns using the `col()` mixin. This
    mixin takes in a fraction that defines the width of the element as a fraction.
    Consider the numerator as the number of columns that you want the element to take
    up and the denominator as the total number of columns:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Jeet的`col()`混合函数来控制主列。这个混合函数接受一个分数，该分数定义了元素的宽度作为分数。考虑分子是你希望元素占用的列数，分母是总列数：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, when we switch to landscape mode on a small device, our `#promoter`
    header is one column wide out of three, while our `#features` section is two columns
    wide out of three.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们切换到小设备上的横幅模式时，我们的`#promoter`标题宽度为三列中的一列，而我们的`#features`部分宽度为三列中的两列。
- en: Super helpers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级辅助函数
- en: In Meteor, you will quickly find yourself repeating helpers among templates
    for simple things such as formatting. We can prevent repetition by creating a
    global dictionary of functions—this is what we call a super helper. To do this,
    we are going to tap into Meteor's rendering engine—Blaze.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meteor中，你很快会发现自己在模板中重复使用辅助函数，用于简单的格式化等任务。我们可以通过创建一个全局函数字典来防止重复，这就是我们所说的超级辅助函数。为此，我们将利用Meteor的渲染引擎——Blaze。
- en: It is important to understand that Blaze is deeply integrated with Spacebars,
    and Spacebars is Meteor's updated version of HandlebarsJS. HandlebarsJS is a JavaScript
    templating engine that enables the use of helpers and components on the frontend
    using `{{}}`. This legacy means that Spacebars has a lot of the HandlebarsJS functionality.
    So, much of the documentation found in HandlebarsJS applies to Meteor helpers
    as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解Blaze与Spacebars深度集成，而Spacebars是Meteor对HandlebarsJS的更新版本。HandlebarsJS是一个JavaScript模板引擎，它通过使用`{{}}`在前端启用辅助函数和组件的使用。这个遗留意味着Spacebars拥有很多HandlebarsJS的功能。因此，HandlebarsJS中的大部分文档也适用于Meteor辅助函数。
- en: Defining a Blaze helper
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Blaze辅助函数
- en: 'Meteor exposes the `Template.registerHelper` function to create global helpers.
    Let''s create something to help us format money:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor提供了`Template.registerHelper`函数来创建全局辅助函数。让我们创建一些帮助我们格式化货币的工具：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the syntax for a global helper is exactly the same as it would
    be for a template helper. Now, we can use this helper in any template. Let''s
    create a product template under our `/products` directory for our `products` template
    and try it out here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，全局辅助器的语法与模板辅助器的语法完全相同。现在，我们可以在任何模板中使用这个辅助器。让我们在我们的 `/products` 目录下创建一个产品模板，并在这里尝试它：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will need to patch our products template as well:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修补我们的产品模板：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s add some temporary entries to our products collection. We will use these
    entries throughout the rest of the chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的产品集合中添加一些临时条目。我们将在这章的其余部分使用这些条目：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that in this data schema we are defining `price` in cents. This is a common
    practice when dealing with money in JavaScript to avoid arithmetic floating point
    issues. What does this mean? Go to your web browser''s console, and run the following
    operation: `0.1 + 0.2`. Oddly enough, JavaScript does not respond with `0.3`;
    it responds with `0.3000000000004` instead. The reason for this is JavaScript''s
    internal 64-bit floating point representation of decimal numbers. This means that
    JavaScript does not fully understand what a decimal number is. This is why, we
    do not use decimal numbers when we deal with money, we just use the smallest available
    denomination.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个数据模式中，我们定义 `price` 为分。当在 JavaScript 中处理金钱时，这是一种常见的做法，以避免算术浮点问题。这意味着什么？请转到您的网络浏览器控制台，并运行以下操作：`0.1
    + 0.2`。奇怪的是，JavaScript 并没有响应 `0.3`；它响应的是 `0.3000000000004`。这是因为 JavaScript 对十进制数的内部
    64 位浮点表示。这意味着 JavaScript 并不完全理解十进制数是什么。这就是为什么，当我们处理金钱时，我们不使用十进制数，我们只使用最小的可用货币单位。
- en: Making a global dictionary
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作全局字典
- en: 'Wait, we can still make this formatter more widely available in our application.
    Let''s turn this into a dictionary and share it with our controllers. In other
    words, we want to be able to use a helper such as `{{format.money amount}}` and
    use this in our CoffeeScript in the form of `format.money amount` as well:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，我们还可以让这个格式化器在我们的应用程序中更广泛地可用。让我们将其转换成一个字典，并与我们的控制器共享。换句话说，我们希望能够使用一个如 `{{format.money
    amount}}` 的辅助器，并在我们的 CoffeeScript 中以 `format.money amount` 的形式使用它：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we create an object that holds our definitions, and we make it global
    using `@` (which is equal to `this`). Then we place this object of definitions
    inside a global helper. Simple! Now we know how to build a super helper that we
    can use anywhere. To test this, type `format.money(1099)` in your browser's console;
    this should return **"$10.99"**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含我们定义的对象，并使用 `@`（等于 `this`）将其设置为全局。然后我们将这个定义对象放入一个全局辅助器中。很简单！现在我们知道了如何构建一个可以在任何地方使用的超级辅助器。为了测试这个，请在浏览器控制台中输入
    `format.money(1099)`；这应该返回 **"$10.99"**。
- en: Variable types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量类型
- en: 'There are four types of variables that we need to understand to optimize our
    frontend workflow: **session**, **persistent**, **file scope**, and **ReactiveVar**.
    With these variables, we can build dynamic sites easily based on how the user
    is interacting with the view.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解四种类型的变量来优化我们的前端工作流程：**会话**、**持久**、**文件作用域**和 **ReactiveVar**。有了这些变量，我们可以根据用户与视图的交互轻松构建动态网站。
- en: The session variables are variables that exist only during a session. A session
    begins whenever a user hits the site. These variables can be shared across routes
    and are reactive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 会话变量是仅在会话期间存在的变量。每当用户访问网站时，会话就开始了。这些变量可以在不同的路由之间共享，并且是响应式的。
- en: The persistent variables are variables that are stored in local storage so that
    they can be read even after the session closes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 持久变量是存储在本地存储中的变量，这样即使在会话关闭后也可以读取。
- en: The file scoped variables are variables that only exist within the scope of
    the file. These are generally not reactive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 文件作用域变量是仅存在于文件作用域内的变量。这些变量通常不是响应式的。
- en: The ReactiveVar variables can be scoped to the file or globally and are reactive.
    These variables do not persist the way session variables do.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveVar 变量可以作用域到文件或全局，并且是响应式的。这些变量不会像会话变量那样持久化。
- en: Session variables
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话变量
- en: Some Meteor developers believe that session variables are overused. This is
    definitely true, if you are not managing them. For the most part, session variables
    should be used to handle data that is shared across multiple routes in your application,
    have no place in your database, need reactivity, and persist through a hot code
    reload.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Meteor开发者认为会话变量被过度使用。这绝对是正确的，如果你没有管理它们。大部分情况下，会话变量应该用于处理在应用程序中跨多个路由共享的数据，没有数据库中的位置，需要响应性，并且可以通过热代码重载持久存在。
- en: If you stop and think about it, not many things require all of these attributes.
    At first, you may rely on them heavily to control your frontend, but as your frontend
    becomes more minimal, you will realize there is no need for them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你停下来思考一下，不是很多事物都需要所有这些属性。一开始，你可能严重依赖它们来控制你的前端，但随着你的前端变得更加简约，你会意识到它们其实没有必要。
- en: 'Still, if you are going to use them, you should follow two rules to maintain
    them, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你打算使用它们，你应该遵循两条规则来维护它们，如下所示：
- en: Template-based taxonomy
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模板的分类法
- en: Clear them if you are not going to use them
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不会使用它们，请清除它们
- en: 'The taxonomy of session variables should always follow the `<template.variable>`
    pattern to keep them from polluting each other. Suppose we want to control a global
    alert using session variables, the session variable would look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 会话变量的分类法应该始终遵循`<template.variable>`模式，以防止它们相互污染。假设我们想使用会话变量来控制全局警告，会话变量看起来会是这样：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once our user leaves the view, we should clear the session variable. The `clear`
    function is added by the `u2622:persistent-session` package that we installed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with Meteor"),
    *Getting Started with Meteor*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户离开视图时，我们应该清除会话变量。`clear`函数是由我们在[第1章](part0014_split_000.html#page "第1章.
    使用Meteor入门")中安装的`u2622:persistent-session`包添加的，*使用Meteor入门*：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not use session variables along with Meteor methods to obtain server data.
    While the method works, it makes your data vulnerable and easy to modify on the
    client.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将会话变量与Meteor方法一起使用来获取服务器数据。虽然方法可以工作，但它会使你的数据容易受到攻击并在客户端被修改。
- en: Also, try to stay away from using session variables that are composed of complex
    objects with multiple keys or arrays. You will quickly find yourself using lesser
    lookup tools such as `_.find` and `_.findWhere` to use the data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽量远离使用由多个键或数组组成的复杂对象的会话变量。你很快会发现自己在使用像`_.find`和`_.findWhere`这样的较小查找工具来使用数据。
- en: Persistent variables
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久变量
- en: Persistent variables are session variables that persist through a session. In
    Meteor, a common session variable will reset if the user refreshes the page. Persistent
    variables leverage AmplifyJS, which in turn uses HTML5 local storage and fallbacks
    to store the variable inside the user's browser. These types of variables exist
    because of the `u2622:persistent-session` package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 持久变量是会话变量，它们在会话中持续存在。在Meteor中，一个常见的会话变量如果用户刷新页面将会重置。持久变量利用AmplifyJS，它反过来使用HTML5本地存储并回退到将变量存储在用户的浏览器中。这些类型的变量存在是因为`u2622:persistent-session`包。
- en: We can use this variable to keep track of our users' orders, in case they leave
    the site and are not logged in. So, if the user opens up an order and fills it
    with items, they can come back to it later without making a user account on our
    site.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个变量来跟踪用户的订单，以防他们离开网站且未登录。因此，如果用户打开一个订单并填充它，他们可以在稍后回来而不需要在我们的网站上创建用户账户。
- en: 'Let''s create an `add-to-cart` button that will leverage the persistent variables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`add-to-cart`按钮，它将利用持久变量：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will need to build a publisher for this to work, but we have to make a choice.
    As we have both `products` and `product` template, each one could subscribe to
    a publisher and pull in the same data. Should we subscribe from the `product`
    or the `products` template? Let''s do both! Extending the products publisher will
    ensure that we get all the data that the template needs while the attached publisher
    will help us manage our "product details" page and promos when we need it to:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一个发布者来实现这一点，但我们必须做出选择。因为我们既有`products`和`product`模板，每个都可以订阅一个发布者并拉取相同的数据。我们应该从`product`还是`products`模板订阅？让我们两者都做！扩展产品发布者将确保我们获得模板所需的所有数据，而附加的发布者将帮助我们管理在需要时“产品详情”页面和促销活动：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we wire up our subscriber with the order key on the client side:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在客户端使用订单键连接我们的订阅者：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this, now we can add products to an order, refresh the site, and still
    come back to our order. Let''s finish building the publisher for the `product`
    template:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，现在我们可以向订单中添加产品，刷新网站，并且仍然回到我们的订单。让我们完成 `product` 模板的发布者构建：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that our product is bringing in only the data that is pertinent to that
    product and for that order. Now we can program our subscriber:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的产品只带来了与该产品以及该订单相关的数据。现在我们可以编写我们的订阅者程序：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: File scope variables
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件作用域变量
- en: These are the types of variables you will want to use most of the time. What
    are they? They are regular variables! This means that they are not reactive, so
    watch out. Regular variables are scoped for the file only, so you do not need
    to worry about interfering with the variables that are named the same in other
    files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您在大多数情况下想要使用的变量类型。它们是什么？它们是常规变量！这意味着它们不是反应式的，所以要注意。常规变量仅在文件范围内有效，因此您不需要担心与其他文件中具有相同名称的变量发生冲突。
- en: These variables are useful for things such as lists that you know will not change
    and that you will not need anywhere else in the application. To use one, simply
    type out a variable outside your Meteor-specific functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量对于诸如列表等您知道将不会改变且不需要在应用程序的其他地方使用的项目非常有用。要使用一个，只需在您的 Meteor 特定函数之外输入一个变量。
- en: The ReactiveVar variables
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactiveVar 变量
- en: The ReactiveVar variables are reactive variables that are not available to the
    console in the way that session variables are. This makes them great for things
    that are reactive and that we want to keep relatively difficult to access for
    the user from the console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveVar 变量是反应式变量，它们在控制台中的可用性不同于会话变量。这使得它们非常适合那些需要保持相对难以从控制台访问的反应式事物。
- en: If at any point you are creating a highly reactive interface, you should fill
    it up with these variables so that you do not have to worry about managing them.
    These variables cleared automatically if there is a hot code reload or a page
    refresh.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候您正在创建一个高度反应式的界面，您应该用这些变量填充它，这样您就不必担心管理它们。如果有热代码重新加载或页面刷新，这些变量会自动清除。
- en: 'To create a reactive variable, you simply define a variable with its constructor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个反应式变量，您只需使用其构造函数定义一个变量：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This variable will expose setter and getter functions. This means that you
    use the `.get` command to see the value of the variable and the `.set` command
    to change it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将公开设置器和获取器函数。这意味着您使用 `.get` 命令来查看变量的值，使用 `.set` 命令来更改它：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s use the ReactiveVar variables to create a rich number input interface
    for our quantity field. We will start by defining a route name as `order_quantity`
    with a `product` parameter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 ReactiveVar 变量来为我们的数量字段创建一个丰富的数字输入界面。我们将首先定义一个路由名称为 `order_quantity` 并带有
    `product` 参数：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can wire up our product with a new button that will take us to the modify
    quantity view and passes to our product ID:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个新按钮将我们的产品连接起来，该按钮将带我们进入修改数量视图，并传递我们的产品 ID：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we need to design a responsive number pad. First, let''s add a global `vertical-align`
    class to our `/_globals/client/main.styl` directory so that we can easily align
    things vertically:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设计一个响应式的数字键盘。首先，让我们在我们的 `/_globals/client/main.styl` 目录中添加一个全局的 `vertical-align`
    类，这样我们就可以轻松地垂直对齐元素：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will use Jeet to control this design since it requires more specific control
    of our DOM elements. Let''s start by creating the layout of the page in our `order_quantity`
    template:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jeet 来控制这个设计，因为它需要对我们的 DOM 元素进行更具体的控制。让我们首先在我们的 `order_quantity` 模板中创建页面的布局：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that we are using the `vertical-align` class on the element that we
    want to align vertically. We are going to make each of these elements a large
    button. Also, we will create a `numbers` helper to write out our numbers to the
    number pad, and the `total` helper will be our reactive variable. Let''s have
    a look at our styles before we create our helpers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `vertical-align` 类来对齐我们想要垂直对齐的元素。我们将将这些元素中的每一个都做成一个大按钮。此外，我们将创建一个
    `numbers` 辅助器来将数字写入数字键盘，而 `total` 辅助器将是我们的反应式变量。在我们创建辅助器之前，让我们看看我们的样式：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we have passed the parameters to Jeet: `gutter` and `cycle`.
    Gutter makes sure that there are no margins, while cycle makes sure that the elements
    can only make rows with a maximum of 3 elements per row. We have made each section
    take up exactly 50 percent of the height of the screen but ensured that scrolling
    wouldn''t happen by setting `overflow` to hidden. Knowing that we are always going
    to have four rows of numbers, we set our height for each number to 25 percent.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向Jeet传递了参数：`gutter`和`cycle`。`gutter`确保没有边距，而`cycle`确保元素只能以每行最多3个元素的方式形成行。我们让每个部分恰好占据屏幕高度的50%，但通过将`overflow`设置为隐藏来确保不会发生滚动。因为我们总是会有四行数字，所以我们为每个数字设置了25%的高度。
- en: 'Now let''s put our `ReactiveVar` variable knowledge to work. First, we set
    up our variable and attach it to the template instance using this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的`ReactiveVar`变量知识付诸实践。首先，我们设置我们的变量并将其附加到模板实例上，如下所示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s build the `numbers` helper and the helper that will render our (`total`)
    reactive variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建`numbers`辅助函数和将渲染我们的(`total`)反应性变量的辅助函数：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to handle the events to update our `ReactiveVar` variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理事件来更新我们的`ReactiveVar`变量：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you take a good look at how the `add-to-cart` event works, you will notice
    that it is almost identical to the event that we wrote for the products template.
    We are effectively repeating ourselves at this moment, but we will make our code
    less repetitive through `Meteor.methods` later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看看`add-to-cart`事件的工作方式，你会注意到它与为产品模板编写的那个事件几乎相同。在这个时候，我们实际上是在重复自己，但我们将通过`Meteor.methods`来减少代码的重复性。
- en: Notice how we are using ReactiveVar the same way as we would use a session variable
    with the difference that we are not exposing the variable to the console. This
    helps to make the interface a bit more secure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用ReactiveVar的，就像我们使用会话变量一样，不同之处在于我们没有将变量暴露给控制台。这有助于使界面更加安全。
- en: 'Let''s not forget to add our publishers for this view to work, we will need
    `Products`, `Orders`, and `OrderDetails`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们别忘了添加这个视图所需的发布者，我们需要`Products`、`Orders`和`OrderDetails`：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We learned how to build a custom form using ReactiveVar variables. The topic
    covers ReactiveVar and touches on Jeet. We learned how to use reactive variables
    to create rich UX.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用ReactiveVar变量构建自定义表单。这个主题涵盖了ReactiveVar并触及了Jeet。我们学习了如何使用反应性变量来创建丰富的用户体验。
- en: Forms
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: 'So far, our buttons and forms have been highly inefficient because they are
    not easy to repeat, and therefore, not easy to maintain. There are two ways that
    we can use to make our code easier to manage:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的按钮和表单非常低效，因为它们不容易重复，因此也不容易维护。我们可以使用两种方法来使我们的代码更容易管理：
- en: Meteor Methods
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meteor Methods
- en: Autoform
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoform
- en: With Meteor Methods, we can easily create **repeatable** and **secure** functions
    while autoforms can identify the structure of a collection and generate form elements
    from it. This provides a decent layer of security without much effort as well.
    Autoform and Meteor Methods can be used together as well for further security.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Meteor方法，我们可以轻松创建**可重复**和**安全**的函数，而autoforms可以识别集合的结构并从中生成表单元素。这提供了相当一层的安全保障，而且不需要太多努力。Autoform和Meteor
    Methods也可以一起使用，以进一步增强安全性。
- en: The autoform method can be implemented through the `aldeed:autoform` and `aldeed:collection2`
    packages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: autoform方法可以通过`aldeed:autoform`和`aldeed:collection2`包实现。
- en: Meteor Methods
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meteor Methods
- en: 'Meteor Methods can be used on the client or the server. They are created by
    using the `Meteor.methods(<object-of-functions>)` function and run with the `Meteor.call(<function-name>,
    <callback function>)` function. Running a meteor method from the client causes
    2 versions of the same function to run. One runs on the server and manipulates
    data while the other runs on the client and simulates data manipulation. This
    is what we call a Method Stub. Let''s look at some example code to understand
    this concept:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor Methods可以在客户端或服务器上使用。它们是通过使用`Meteor.methods(<object-of-functions>)`函数创建的，并通过`Meteor.call(<function-name>,
    <callback function>)`函数运行。从客户端运行一个Meteor方法会导致同一函数运行两个版本。一个在服务器上运行并操作数据，另一个在客户端运行并模拟数据操作。这就是我们所说的方法占位符。让我们看看一些示例代码来理解这个概念：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once you run the function, the Meteor Method activates both the server-side
    and client-side functions. So the server in this case will log "I don't want to
    say hello" to the console while the client will log "hello". This is a special
    feature that Meteor provides to help validate code or run other functions in parallel
    on the server without exposing sensitive data to the client.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行函数，Meteor 方法将激活服务器端和客户端函数。因此，在这种情况下，服务器将在控制台输出 "我不想说你好"，而客户端将输出 "hello"。这是
    Meteor 提供的一个特殊功能，用于帮助验证代码或在服务器端并行运行其他函数，同时不向客户端暴露敏感数据。
- en: Still, it is important to note that the client-side method will run immediately
    while the server-side method will take longer. The client-side code should, therefore,
    be used for simulation while the server-side code should be used for validation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，客户端方法将立即运行，而服务器端方法将需要更长的时间。因此，客户端代码应该用于模拟，而服务器端代码应该用于验证。
- en: 'Let''s define and use a Meteor Method that runs on both the client and the
    server. Let''s start by redefining the `add-to-cart` events that we had programmed
    earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义并使用一个在客户端和服务器端都运行的 Meteor 方法。让我们首先重新定义我们之前编程的 `add-to-cart` 事件：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, we added a line at the end of the method to check for a callback function
    and run it, if it exists. Observe how we have accepted a function as one of our
    parameters in the beginning of the function. To follow in Meteor''s footsteps,
    we return `null` as the error object and `true` as the result after the function
    has completed. Now let''s replace the events:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在方法末尾添加了一行代码来检查回调函数，如果存在则执行它。观察我们如何在函数开始时将一个函数作为我们的参数之一接受。为了遵循 Meteor 的做法，函数执行完成后，我们返回
    `null` 作为错误对象，并返回 `true` 作为结果。现在让我们替换事件：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Meteor Methods are great to create rich and easily repeatable user interfaces,
    but you will eventually find yourself repeating certain patterns if you are only
    updating a single collection. This is where autoforms come in.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 方法非常适合创建丰富且易于重复的用户界面，但如果你只更新单个集合，你最终会发现自己在重复某些模式。这就是自动表单发挥作用的地方。
- en: Autoform
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动表单
- en: The `autoform` plugin was installed together with the `collection2` plugin.
    Both of these work together to quickly create forms that support error handling
    for you. Documentation on these plugins is vast, but it is necessary to read this
    to make your views safe and easy to build. You can find this documentation at
    [https://github.com/aldeed/meteor-autoform](https://github.com/aldeed/meteor-autoform).
    We are going to cover a simple pattern to show you how to easily manipulate autoforms.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoform` 插件是与 `collection2` 插件一起安装的。这两个插件协同工作，可以快速创建支持错误处理的表单。关于这些插件的文档非常丰富，但阅读这些文档对于确保你的视图安全且易于构建是必要的。你可以在
    [https://github.com/aldeed/meteor-autoform](https://github.com/aldeed/meteor-autoform)
    找到这些文档。我们将介绍一个简单的模式，以展示如何轻松地操作自动表单。'
- en: 'To use autoform, you need to first create a `collection2` schema for your collection.
    This defines the rules that autoform is going to use to validate and generate
    our input fields. Let''s populate our products schema:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自动表单，你首先需要为你的集合创建一个 `collection2` 架构。这定义了自动表单将要使用的规则来验证和生成我们的输入字段。让我们填充我们的产品架构：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Attaching a schema to our collections makes sure that the client-side console
    commands cannot add information to the database that is not a part of the schema.
    Let''s reset our project to make sure our new products adapt to the new schema:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将架构附加到我们的集合中确保客户端控制台命令不能添加不属于架构的信息到数据库。让我们重置我们的项目以确保我们的新产品适应新的架构：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can create a simple insert form for our products collection using autoforms.
    Let''s create the template and route:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用自动表单为我们的产品集合创建一个简单的插入表单。让我们创建模板和路由：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Notice that we do not need to write a controller to make this work. There are
    two critical components that we need to understand in this case: `autoForm` and
    `afQuickField`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要编写控制器来使这个功能工作。在这个情况下，我们需要理解两个关键组件：`autoForm` 和 `afQuickField`。
- en: When we use `autoForm` with a collection, we have to declare the name of the
    collection using the `collection` parameter. Also, we need to define whether the
    form is doing an insert, update, or method call using the `type` parameter, and
    finally, we give the form an `id` that will be used as the HTML `id` attribute
    for the form. Additionally, we pass the `preserveForm` parameter to make sure
    that the data persists through hot code reloads. There are several other parameters
    that autoform takes, but these are the most commonly used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `autoForm` 与一个集合一起时，我们必须使用 `collection` 参数声明集合的名称。此外，我们需要使用 `type` 参数定义表单是进行插入、更新还是方法调用，最后，我们给表单一个
    `id`，它将被用作表单的 HTML `id` 属性。此外，我们传递 `preserveForm` 参数以确保数据在热代码重新加载中保持持久。autoform
    还接受其他一些参数，但这些是最常用的。
- en: 'The `afQuickField` component specifically creates a `bootstrap3` input field
    that can easily handle errors. Notice that we can add HTML attributes (such as
    `autocorrect` and `autocomplete`) to these components as well as parameters. There
    are a variety of ways to customize these inputs but we recommend only two: modifying
    the CSS directly or leveraging `afFieldInput` and `afFieldIsInvalid` to build
    new elements.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`afQuickField` 组件专门创建了一个可以轻松处理错误的 `bootstrap3` 输入字段。请注意，我们还可以将这些组件以及参数添加 HTML
    属性（如 `autocorrect` 和 `autocomplete`）。有各种方法可以自定义这些输入，但我们建议只使用两种：直接修改 CSS 或利用 `afFieldInput`
    和 `afFieldIsInvalid` 来构建新元素。'
- en: 'Let''s customize our `price` field a little bit more:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步自定义我们的 `price` 字段：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By doing this, we are very easily adding a `glyphicon` to our field using bootstraps'
    classes, but this can be useful for adapting our forms to any framework, if needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们非常容易地使用 bootstraps 的类为我们的字段添加一个 `glyphicon`，但这在需要时可以用于适应任何框架。
- en: 'There is still a bit of an issue with this form though, people input prices
    in dollars instead of cents, but our schema only accepts cents. Let''s transform
    this data before it is submitted using autoform''s **hooks**:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个表单仍然存在一些问题，人们输入价格时使用的是美元而不是分，但我们的模式只接受分。让我们在提交之前使用 autoform 的 **钩子**
    来转换这些数据：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Autoform has a long list of hooks, but by far the most useful one for transformations
    is `formToDoc`. This function runs every time the form is converted to a document
    for processing, this includes before the errors are processed. We do not use the
    "before hook" because this hook will run after processing errors. Also, we are
    using a `docToForm` hook to make sure that our `price` field stays intact after
    a code reload. Autoform has the following hooks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Autoform 有一个很长的钩子列表，但到目前为止，对于转换来说最有用的是一个 `formToDoc` 钩子。这个函数在每次表单被转换为文档以进行处理时都会运行，这包括在错误处理之前。我们不使用“before
    hook”，因为这个钩子将在错误处理之后运行。此外，我们正在使用一个 `docToForm` 钩子来确保在代码重新加载后我们的 `price` 字段保持完整。Autoform
    有以下钩子：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this, we can quickly create forms and modify them to the way we like while
    preserving usability. Stay away from fields that require arrays! They are difficult
    to manage in our application and can always be expressed as a new collection in
    our models.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以快速创建和修改表单，使其符合我们的喜好，同时保持可用性。远离需要数组的字段！在我们的应用程序中，它们很难管理，并且总可以用我们模型中的新集合来表示。
- en: Loading data
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: The performance of our frontend can suffer if we do not load data correctly
    because it can make the DOM redraw quickly multiple times. If the calculations
    are complex, then we need to wait for all our data to be available and calculate
    everything in one single sweep. If we do not wait for data, then calculations
    will run as the data is received, which in turn will cause the DOM to redraw multiple
    times very quickly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有正确加载数据，我们的前端性能可能会受到影响，因为它可能会使 DOM 快速多次重绘。如果计算复杂，那么我们需要等待所有数据都可用，并在一次单独的扫描中计算一切。如果我们不等待数据，那么计算将在数据接收时运行，这反过来又会导致
    DOM 非常快地多次重绘。
- en: To solve this issue, we can easily check whether our subscribers are ready and
    show a loading symbol until they are.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以轻松地检查我们的订阅者是否已准备好，并在他们准备好之前显示一个加载符号。
- en: Designing the loading indicator
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计加载指示器
- en: 'We start by creating a loading template. Let''s use font awesome to handle
    our animations and make sure that we can easily change the color of the loader:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个加载模板。让我们使用 font awesome 来处理我们的动画，并确保我们可以轻松地更改加载器的颜色：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, we are using the `fa-spin` class to make the cog spin and adding
    a `color_class` helper that will take bootstraps' `text-` classes to define colors.
    Also, we made sure that the loader fills the contents of whatever is holding it
    so that everything aligns nicely when we use it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `fa-spin` 类来使齿轮旋转，并添加了一个 `color_class` 辅助类，它将接受 Bootstraps 的 `text-`
    类来定义颜色。同时，我们确保加载器填充了它所持有的内容的全部，这样当我们使用它时，一切都能整齐对齐。
- en: Implementing the loading indicator
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现加载指示器
- en: Let's implement the loading indicator for our list of products. Due to the way
    we are going to implement this, we could easily have our interface show the loading
    indicator for each product or the list of products. It will be more efficient
    to control the latter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的产品列表实现加载指示器。由于我们将要实现的方式，我们很容易让我们的界面为每个产品或产品列表显示加载指示器。控制后者将更有效率。
- en: 'So let''s modify our products template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改我们的产品模板：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Meteor core exposes a special `Template.subscriptionsReady` helper that checks
    whether the subscriptions made in that template instance are all in the ready
    state. This is one of the hidden advantages of using `@subscribe` from our `Template.created`
    function instead of `Meteor.subscribe`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 核心提供了一个特殊的 `Template.subscriptionsReady` 辅助函数，用于检查在该模板实例中创建的订阅是否都处于就绪状态。这是使用我们
    `Template.created` 函数中的 `@subscribe` 而不是 `Meteor.subscribe` 的隐藏优势之一。
- en: In this case, we only run the `each` iteration on the `products` variable until
    all subscriptions are ready. Before this happens, we render our `loader` component
    in our primary color.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只在 `products` 变量上运行 `each` 迭代，直到所有订阅都准备就绪。在此之前，我们使用我们的主色调渲染 `loader`
    组件。
- en: The advantage to this pattern is that we can control exactly where we want our
    loader to be and when we want it to appear.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的优点在于我们可以精确控制加载器想要放置的位置以及它何时出现。
- en: Animations and transitions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画和过渡
- en: Animation for the web is a vast field that is still growing and can get highly
    complex if you want it to be. At the end of the day though, efficient animations
    are what make a real difference. How do you make an animation efficient? You keep
    it simple, and you let the browser animate it for you. Stay away from using JavaScript
    to identify positions and change colors. Animations that are heavy on JavaScript
    will always have terrible performance. This poor performance happens because JavaScript
    cannot run effectively in all devices, so multiple changes to the DOM occur at
    the maximum allowed speed of the device without using video memory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 网页动画是一个庞大且仍在增长的领域，如果你想要它变得复杂，它确实可以变得非常复杂。然而，最终，高效的动画才是真正能产生影响的。你如何使动画高效？你让它保持简单，并让浏览器为你进行动画处理。远离使用
    JavaScript 来识别位置和改变颜色。过于依赖 JavaScript 的动画将始终有糟糕的性能。这种糟糕的性能发生是因为 JavaScript 无法在所有设备上有效运行，因此，在不需要使用视频内存的情况下，DOM
    的多次更改会在设备允许的最大速度下发生。
- en: Canvas is an HTML element that is designed to render changes using JavaScript
    and WebGL. Animating anything through canvas will boost performance, but it is
    meant more for applications that want to do graphically intensive work such as
    3D rendering or sprite animations for a game. We will not cover canvas in this
    book because you will probably never need it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 是一个设计用来通过 JavaScript 和 WebGL 渲染变化的 HTML 元素。通过 canvas 动画任何内容都能提升性能，但它更适合那些想要进行图形密集型工作，如
    3D 渲染或游戏精灵动画的应用程序。在这本书中，我们不会涉及 canvas，因为你可能永远不需要它。
- en: 'Ignoring the power of canvas leaves us with two CSS tools to make rich animations:
    `animation` and `transition`. The `animation` property is meant for complex animations
    that require keyframes, while the `transition` property is meant for simple change-of-state
    animations. Let''s look at an example of each to first understand how they work,
    then we will apply them to Meteor.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略 canvas 的强大功能，我们只剩下两个 CSS 工具来制作丰富的动画：`animation` 和 `transition`。`animation`
    属性旨在用于需要关键帧的复杂动画，而 `transition` 属性旨在用于简单的状态转换动画。让我们先看看每个属性的例子，以了解它们是如何工作的，然后我们将把它们应用到
    Meteor 中。
- en: Animating with CSS
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CSS 进行动画
- en: 'The `transition` property is the easiest property to understand. You basically
    define which property you are going to animate and how, within a CSS property:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`transition` 属性是最容易理解的属性。你基本上在 CSS 属性中定义你将要动画化的属性以及如何进行动画化：'
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It''s important to realize that because of **Stylus Nib** (another useful Stylus
    plugin included in this package), we do not have to worry about vendor prefixes
    for this particular property. Nib will handle this for us automatically. By adding
    the transition property to the `box` class, we are telling the browser to animate
    any change that occurs on the defined property. How do these changes occur? With
    new classes. Let''s look at a small example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，由于 **Stylus Nib**（此包中包含的另一个有用的 Stylus 插件），我们不必担心这个特定属性的供应商前缀。Nib 会自动为我们处理这个问题。通过将过渡属性添加到
    `box` 类中，我们告诉浏览器对定义的属性上发生的任何变化进行动画处理。这些变化是如何发生的呢？通过新的类。让我们看一个小例子：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this set of CSS rules, we are making the box invisible until the `.in`
    class is dynamically added. Once the class is added, then the DOM element will
    fade in. The available timing functions are: `ease`, `linear`, `ease-in`, `ease-out`,
    `ease-in-out`, `step-start`, and `step-end`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这组 CSS 规则，我们使盒子在 `.in` 类动态添加之前不可见。一旦添加了类，DOM 元素就会淡入。可用的时序函数有：`ease`、`linear`、`ease-in`、`ease-out`、`ease-in-out`、`step-start`
    和 `step-end`。
- en: 'The `animation` property is a bit more complex because it does not require
    a dynamic class to activate the animation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation` 属性稍微复杂一些，因为它不需要动态类来激活动画：'
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, the difference between a transition and an animation is the
    level of control you can have over the animation. By using an `animation name`
    and the `@keyframes` selector, we can control at which point of the animation
    we want our properties to change and to what. You can change the number on the
    keyframe to whatever number you want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，过渡和动画之间的区别在于你可以对动画有多少控制力。通过使用 `animation name` 和 `@keyframes` 选择器，我们可以控制动画的哪个点我们想要改变属性以及如何改变。你可以将关键帧上的数字更改为你想要的任何数字。
- en: 'Notice that the `animation` property has a few new parameters: `iteration count`,
    `fill mode`, and `play state`. The `iteration count` parameter defines how many
    times an animation is going to play; you can set this to infinite or a specific
    number. The `fill mode` defines the state at which you want the element to be
    when it is not animating: `forwards` sets values to the last defined keyframe,
    `backwards` to the first defined keyframe, both sets to `first` and `last`, and
    `none` will do nothing (default). The `play state` controls whether an animation
    is playing or not (paused or running).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `animation` 属性有几个新的参数：`迭代次数`、`填充模式`和`播放状态`。`迭代次数`参数定义了动画将要播放的次数；你可以将其设置为无限或一个特定的数字。`填充模式`定义了当元素不在动画状态时你希望元素处于的状态：`forwards`
    将值设置为最后一个定义的关键帧，`backwards` 设置为第一个定义的关键帧，两者都设置为 `first` 和 `last`，而 `none` 将不执行任何操作（默认）。`播放状态`控制动画是否播放（暂停或运行）。
- en: We can use a second CSS selector to control our `play state`, if we need to
    in the same way that we did for our `transition` property.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以使用第二个 CSS 选择器来控制我们的 `play state`，就像我们为 `transition` 属性所做的那样。
- en: Executing animations in Meteor
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Meteor 中执行动画
- en: In Meteor, it is very easy to control the classes that are rendered on the DOM
    using helpers, so we can quickly inject a class that will trigger our CSS animation.
    We will have issues when we want to trigger animations on elements that do not
    exist in the DOM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Meteor 中，使用助手控制渲染到 DOM 上的类非常容易，因此我们可以快速注入一个将触发我们的 CSS 动画的类。当我们想要在 DOM 中不存在的元素上触发动画时，我们会遇到问题。
- en: For example, once our products have loaded, they just pop in. What if we want
    to make the list fade in and the loader fade out instead? This is where Meteor's
    hidden `@_uihooks` function comes into play.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦我们的产品加载完成，它们就会突然出现。如果我们想使列表淡入，而加载器淡出呢？这就是 Meteor 的隐藏的 `@_uihooks` 函数发挥作用的地方。
- en: At the time of writing, this feature is in beta and is still a bit buggy. The
    best way to handle all the issues that this is causing is through the `percolate:momentum`
    package. This avoids the need to understand the issues that `uihooks` currently
    has and how to get around them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此功能处于测试阶段，并且仍然有些问题。处理由此引起所有问题的最佳方式是通过 `percolate:momentum` 包。这样可以避免理解
    `uihooks` 当前存在的问题以及如何绕过它们。
- en: The `momentum` package is designed to intercept Blaze by using the `@_uihooks`
    function that is made available in the context of the `Template.rendered` function.
    It is very easy to use and comes packaged with VelocityJS, a jQuery plugin that
    handles transitions somewhat effectively. We can use a combination of both to
    help keep things simple.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`momentum`包设计用来通过使用在`Template.rendered`函数上下文中提供的`@_uihooks`函数来拦截Blaze。它非常容易使用，并且与VelocityJS一起打包，这是一个处理过渡相当有效的jQuery插件。我们可以使用两者的组合来帮助保持事情简单。'
- en: 'To customize momentum, we need to register momentum plugins that handle the
    three hooks that can occur in our DOM: `insertElement`, `removeElement`, and `moveElement`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义动量，我们需要注册处理我们DOM中可能发生的三个钩子的动量插件：`insertElement`、`removeElement`和`moveElement`。
- en: '| `insertElement` | Occurs when a DOM element is created |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `insertElement` | 当一个DOM元素被创建时发生 |'
- en: '| `removeElement` | Occurs when a DOM element is destroyed |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `removeElement` | 当一个DOM元素被销毁时发生 |'
- en: '| `moveElement` | Occurs when a DOM element is moved from it''s DOM location
    (sorting can cause this to be triggered) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `moveElement` | 当一个DOM元素从其DOM位置移动时发生（排序可能会触发此事件） |'
- en: 'Let''s build the plugin named `fade-fast` that will control the fading in and
    out of our loading indicator of our products:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个名为`fade-fast`的插件，该插件将控制产品加载指示器的淡入和淡出：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We use the `node` variable to modify the elements that we are going to inject
    into the DOM, and we always use `insertBefore` with the `next` variable as a parameter
    to render. Notice that in this case, when we insert, we are adding three classes
    before the items are rendered to the DOM, and then after 250 milliseconds, we
    remove the invisible class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`node`变量来修改将要注入DOM的元素，并且我们总是使用`insertBefore`方法，将`next`变量作为参数来渲染。请注意，在这种情况下，当我们插入时，我们是在元素渲染到DOM之前添加三个类，然后在250毫秒后移除不可见类。
- en: When an element is removed, we will use `velocity` to modify `opacity` and bring
    this down to `0` in exactly `250` milliseconds. Velocity takes in a callback command
    that we will use to finally remove the element from the DOM.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素被移除时，我们将使用`velocity`来修改`opacity`属性，并在恰好250毫秒内将其降至`0`。Velocity接受一个回调命令，我们将使用它最终从DOM中移除元素。
- en: 'Now we can add our styles and place the helper inside our view:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加我们的样式并将助手放置在我们的视图中：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that we have added a `momentum(plugin="fade-fast")` component that defines
    which plugin to use around the area that is going to render elements with animations.
    Then we create the classes that will use CSS transition to make each DOM element
    fade in.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了一个`momentum(plugin="fade-fast")`组件，它定义了将要渲染具有动画的元素的区域的插件。然后我们创建将使用CSS过渡使每个DOM元素淡入的类。
- en: SEO
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SEO
- en: Meteor has one big problem. It does not support server-side rendering out of
    the box. This means that robots don't know how to parse our pages because the
    server does not render the page, the client does! There are many ways to solve
    this issue. You can try using `meteorhacks:ssr` to enable server-side rendering
    or you can let a service automate this for you for free. We are going to use a
    service to keep things simple.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor有一个大问题。它默认不支持服务器端渲染。这意味着爬虫不知道如何解析我们的页面，因为服务器没有渲染页面，而是客户端！有许多方法可以解决这个问题。你可以尝试使用`meteorhacks:ssr`来启用服务器端渲染，或者你可以让一个免费的服务为你自动化这个过程。我们将使用一个服务来简化事情。
- en: Prerender.io
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prerender.io
- en: Meet prerender.io, the easiest way to get your site parsed. Prerender.io is
    mostly a free service that understands exactly how to parse your page. It basically
    navigates to your `webapp` and parses each page, and then when a bot hits our
    `webapp`, our server will fetch the parsed page from prerender.io and respond
    with this instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下prerender.io，这是获取网站解析的最简单方法。Prerender.io主要是一个免费服务，它确切地知道如何解析你的页面。它基本上导航到你的`webapp`并解析每个页面，然后当爬虫击中我们的`webapp`时，我们的服务器将从prerender.io获取解析后的页面，并用这个页面进行响应。
- en: The service is free for the webapps that have a minimal number of pages that
    get hit by bots. The more dynamic and the more pages you have, the higher the
    price will be, but this is unlikely unless you are building a highly dynamic public
    web page. Even then, the `prerender.io` project can be downloaded and set up personally
    (so it's still free).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于页面数量最少且被爬虫访问的web应用，该服务是免费的。你拥有的页面越多，动态性越强，价格就越高，但除非你正在构建一个高度动态的公共网页，否则这种情况不太可能。即使如此，`prerender.io`项目可以下载并个人设置（因此仍然是免费的）。
- en: 'We have installed the `dfischer:prerenderio` package to easily set up the service.
    The only thing that is left is for us is to authorize. First, go to [www.prerender.io](http://www.prerender.io)
    and open an account, then click the **INSTALL TOKEN** tab on their navbar, and
    copy your token. Now paste your token under the configuration file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了`dfischer:prerenderio`包来轻松设置服务。我们唯一剩下的事情就是进行授权。首先，前往[www.prerender.io](http://www.prerender.io)并创建一个账户，然后点击他们导航栏上的**安装令牌**标签，并复制您的令牌。现在将您的令牌粘贴到配置文件下：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Simple! Your site is now crawl-able. Now let''s configure our router to work
    with prerender and add a 404 page:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！您的网站现在可被爬取。现在让我们配置我们的路由器以与预渲染一起工作，并添加一个404页面：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that we are creating a global `Template.created` hook function and setting
    `prerenderReady` to `false` by default. Then, we check whether our subscriptions
    are ready using `@subscriptionsReady()` and set `prerenderReady` to `true`. It's
    important to understand that `@subscriptionsReady()` only checks for subscriptions
    made through `@subscribe` within the template!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在创建一个全局的`Template.created`钩子函数，并将`prerenderReady`默认设置为`false`。然后，我们使用`@subscriptionsReady()`检查我们的订阅是否就绪，并将`prerenderReady`设置为`true`。重要的是要理解`@subscriptionsReady()`只检查在模板中通过`@subscribe`创建的订阅！
- en: Also, notice that we are creating a list of exceptions. This is to ensure that
    we only check for subscribers on templates that need them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们正在创建一个异常列表。这是为了确保我们只检查需要它们的模板上的订阅者。
- en: This pattern ensures prerender does not cache the page until it has actually
    loaded all the data. Why not use `FlowRouter` global triggers? Sadly, these triggers
    do not have access to the template instance that is being rendered (since there
    can be many). If you need more control, you can set this per route/template.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式确保预渲染在实际上已加载所有数据之前不会缓存页面。为什么不使用`FlowRouter`全局触发器呢？遗憾的是，这些触发器无法访问正在渲染的模板实例（因为可能有多个）。如果您需要更多控制，您可以按路由/模板设置此选项。
- en: 'Let''s work on our 404 page template:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们着手处理我们的404页面模板：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To make sure our 404 page prints out the correct 404 response, we are going
    to have to use `Meta`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的404页面打印出正确的404响应，我们不得不使用`Meta`。
- en: Using Meta
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Meta
- en: 'To control prerender, we need to use the `yasinuslu:blaze-meta` package. This
    package basically injects a template to our `head` HTML tag so that we can easily
    set tags. Prerender uses tags to identify whether the page should respond with
    a 404\. We can use Meta to set our title, description, keywords, and robots properties
    as well. Let''s start by making our 404 page respond with a 404:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制预渲染，我们需要使用`yasinuslu:blaze-meta`包。这个包基本上向我们的`head` HTML标签注入一个模板，这样我们就可以轻松地设置标签。预渲染使用标签来识别页面是否应该响应404。我们还可以使用Meta来设置我们的标题、描述、关键词和robots属性。让我们先从让我们的404页面响应404开始：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Meta` object has only four functions: `set`, `setTitle`, `unset`, and
    `config`. It is unlikely that you will use `unset` because metatags do not persist
    through routes. Both the `set` and `unset` functions require an array of objects,
    and each object requires all the three keys: `name`, `property`, and `content`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta`对象只有四个函数：`set`、`setTitle`、`unset`和`config`。您不太可能使用`unset`，因为元标签不会通过路由持久化。`set`和`unset`函数都需要一个对象数组，并且每个对象都需要所有三个键：`name`、`property`和`content`。'
- en: In the preceding example, we are setting `prerender-status-code` to `404` and
    `robots` to `noindex, nofollow`. With this, we ensure that our 404 page in fact
    returns a 404 error and that crawlers do not index the page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`prerender-status-code`设置为`404`，将`robots`设置为`noindex, nofollow`。通过这种方式，我们确保我们的404页面实际上返回了一个404错误，并且爬虫不会索引该页面。
- en: 'Also, we need to configure `Meta` so that the name of the page is always correct:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要配置`Meta`，以确保页面的名称始终正确：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since `Meta` is controlling our `title` tag, we need to remove that tag from
    `layout.jade`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Meta`控制着我们的`title`标签，我们需要从`layout.jade`中移除该标签。
- en: Schema.org
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Schema.org
- en: Now that our site is crawl-able, we want our products to shine for search engines.
    Let's upgrade our products to enable Rich Snippets. Rich Snippets follow schema.org
    standards to build structured data for search engine crawlers such as Google to
    interpret. With this information, search engines can present your data on their
    site more prominently, make searches more effective, and even use it in other
    services. Following their guidelines is a good idea because Google uses these
    guidelines for its crawler.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的网站可被爬取，我们希望我们的产品在搜索引擎中脱颖而出。让我们升级我们的产品以启用丰富片段。丰富片段遵循schema.org标准为搜索引擎爬虫（如Google）构建结构化数据。有了这些信息，搜索引擎可以在其网站上更突出地展示您的数据，使搜索更有效，甚至可以在其他服务中使用它。遵循他们的指南是个好主意，因为Google使用这些指南来指导其爬虫。
- en: 'To do this, all we need to do is set as many schema.org''s properties as possible
    on our product page. Visit [http://schema.org/Product](http://schema.org/Product)
    for a full list of the available properties. The properties that are most used
    are:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要在我们的产品页面上设置尽可能多的schema.org属性。访问[http://schema.org/Product](http://schema.org/Product)获取可用属性的完整列表。最常用的属性包括：
- en: '| Property | Type | Description |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `name` (required) | `Text` | The name of the product |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `name` (必需) | `Text` | 产品的名称 |'
- en: '| `image` | `URL` | The URL of the product |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `image` | `URL` | 产品链接 |'
- en: '| `description` | `Text` | The description of the product |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `description` | `Text` | 产品描述 |'
- en: '| `offers` | `OFFER OBJECT` | This includes multiple parameters that define
    the price of the object |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `offers` | `OFFER OBJECT` | 这包括多个定义对象价格的参数 |'
- en: '| `price` (required) | `Number` | The price of the product |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `price` (必需) | `Number` | 产品的价格 |'
- en: '| `priceCurrency` (required) | `Text (ISO 4217) [ex: USD]` | The currency of
    the price |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `priceCurrency` (必需) | `Text (ISO 4217) [ex: USD]` | 价格的货币 |'
- en: 'Now let''s put this to practice using the `MicroData` spec:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用`MicroData`规范来实践：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, to use the `MicroData` spec, you need to add a variety of custom
    attributes to your view. For the most part, anytime you are going to declare what
    a particular thing is, you need to express this via the `itemscope` and `itemtype`
    attributes. When we want to declare properties under this declaration, we need
    to make sure our DOM elements are children of this declaration and that the property
    is declared through the `itemprop` attribute.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要使用`MicroData`规范，您需要向您的视图添加各种自定义属性。在大多数情况下，每次您要声明某个特定事物时，您都需要通过`itemscope`和`itemtype`属性来表示这一点。当我们想要声明此声明下的属性时，我们需要确保我们的DOM元素是此声明的子元素，并且属性是通过`itemprop`属性声明的。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered several useful patterns that make the implementation of
    rich and minimal interfaces easy. First, we learned how to use the Twitter Bootstrap
    framework together with Jeet and Rupture; this improved the way we organize our
    DOM. Also, we learned how to make super helpers—functions that we can call in
    both views and controllers.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个有用的模式，使得实现丰富和最小化界面变得容易。首先，我们学习了如何结合使用Twitter Bootstrap框架、Jeet和Rupture；这改善了我们的DOM组织方式。我们还学习了如何创建超级助手——可以在视图和控制器中调用的函数。
- en: We took a dive into the different kinds of variables that we can use to keep
    our code safe and to create rich interfaces. Also, we learned how to use Meteor
    Methods and autoform to easily save information. We covered how to implement a
    simple loading indicator and how to get animations working in Meteor. To finish
    up, we learned how to implement a little SEO using prerender.io and the `Meta`
    package.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了我们可以使用的不同类型的变量，以保持我们的代码安全并创建丰富的界面。我们还学习了如何使用Meteor方法和使用autoform轻松保存信息。我们介绍了如何实现简单的加载指示器以及如何在Meteor中实现动画。最后，我们学习了如何使用prerender.io和`Meta`包实现一点SEO。
- en: The next chapter will cover application-wide patterns. [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns* will teach us how to
    filter and page through collections, how to fully secure our application, and
    how to integrate with external APIs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖应用范围内的模式。[第4章](part0035_split_000.html#page "第4章. 应用模式")，*应用模式*将教会我们如何过滤和分页浏览集合，如何全面保护我们的应用程序，以及如何与外部API集成。
