- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Superhero Landing – Setting Up Flexible Navigation Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The city our superhero framework lands in is always changing and they often
    don’t know what they are up against when on patrol. Our next step is to make the
    landing page URL more flexible. We will need to be able to switch from testing
    in the QA environment to staging. At the same time, they should be robust enough
    to be able to handle small differences. In this chapter, we’ll look at handling
    elements that exist in one release or environment but not in another. In addition,
    we will enhance the log wrapper to include colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using system variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration allure reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick tip
  prefs: []
  type: TYPE_NORMAL
- en: Avoid testing in the development environment because there will constantly be
    changes . Stay focused on the QA and staging environments. Promising to keep tests
    in a running state in dev will generate more maintenance time. More maintenance
    means less time creating new tests and analyzing existing results, which means
    more bugs slip into production, increasing the chance we have money leaving the
    bottom line. If the powers that be insist, make it clear a small subset of 4-10
    tests can be provided just to give the developers a “warm fuzzy” about the state
    of their environment. We do want to shift left, but spreading our team too thin
    will be counterproductive.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All test examples can be found in this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO).'
  prefs: []
  type: TYPE_NORMAL
- en: Using system variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running our tests from the command line, we can set up user variables
    easily to indicate which test environment to use or run. This can be done with
    an environment `{``process.env.ENV}` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable can then be read inside our framework and redirect our login
    method to the proper environment, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Quick tip
  prefs: []
  type: TYPE_NORMAL
- en: Be extra vigilant when testing in production. Discuss with leadership the potential
    impact it can have. Slowing down the production database with inefficient SQL
    calls that return a million results will overshadow any bugs that are found. Set
    up your job runs with a marker that indicates your production environment’s safe
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Legend has it that data files were created by a brilliant and enigmatic scientist
    whose name is whispered only in hushed tones by those who know of its existence.
    They are said to contain ancient knowledge, sacred algorithms, and hidden codes
    that can unravel the mysteries of the application under test.
  prefs: []
  type: TYPE_NORMAL
- en: Where data is stored for test use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding data files to your test code with TypeScript is exactly like how you
    do it for JavaScript, but with TypeScript, you have the added benefit of leveraging
    TypeScript’s static typing and modules that will help you catch type-related errors
    early, making your tests more robust and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing test data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a directory to store your test data files. You can name it something
    such as `test-data` or `shared-data`. Place your data files (e.g., JSON, CSV,
    etc.) in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up TypeScript configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure that your TypeScript configuration (`tsconfig.json`) includes the appropriate
    settings for test files and modules. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Include the `test-data` directory and the `tests` directory in the `include`
    section of the `tsconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we use the `fs` module to read data from the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a file system object, we can begin to build data-driven tests
  prefs: []
  type: TYPE_NORMAL
- en: Using test data in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your test files, you can import the necessary data and use it in your test
    cases, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are pulling some data from the `data.json` file
    in the shared-data directory. The input data is then compared to the actual result
    and asserting the values are matching.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond masking – making confidential data invisible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, superheroes often go to great lengths to protect their
    identity, such as by wearing masks or donning a pair of glasses. But if they truly
    want to be stealthy, nothing beats a vault of secrets.
  prefs: []
  type: TYPE_NORMAL
- en: The use of data files to keep confidential information such as usernames and
    access keys is very commonplace today. For security reasons, these should *never*
    be uploaded into your code repository. A good DevSecOps team will parse GitHub
    and GitLab repos for terms such as “password” and flag your team for being out
    of compliance with **System and Organization Controls 2** (**SOC II**) if they
    find any matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `.env` file at the base of your project to store all your confidential
    data, then add `dotenv` to your dependencies once done. This will give `process.env`
    access to all the data in the `.``env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we need another node package called `dotenv`. This package allows
    developers to store configuration data in a plain text file named `.env`. Each
    line in the `.env` file typically represents an environment variable in the form
    of `KEY=VALUE`, such as `API_KEY=your_api_key_here`. Installing it is simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we place this at the top of `wdio.config` file just below the `import`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are creating a system variable to hold `LT_USERNAME` and `LT_ACCESS_KEY`.
    This is how we pass sensitive data without storing our credentials in our repo.
  prefs: []
  type: TYPE_NORMAL
- en: Spec and Allure – cub reporter versus star journalist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many comic books, there are several reporters documenting the big events
    and crimes in the city. The cub reporter gives inside knowledge for our superhero
    to save the day and the star journalist provides flashy front-page headlines.
    Spec and Allure reporters are similar reporting mechanisms in WebdriverIO. They
    serve different functions and provide different levels of detail. The Spec reporter
    is best for SDETs to use to debug failing test runs on the fly. It tells you if
    the test passed or failed, shows the name of the test, and reports the time it
    took to run. If a test fails, the Spec reporter provides the error message and
    stack trace in the console. This provides you with an immediate understanding
    of what has happened, but it’s up to you to help provide in-depth contextual data
    about the test run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allure provides flashy historical graphs that are better suited for showing
    results to project managers and senior executives. It goes beyond the basics to
    give you a more complete picture. It produces a stylish and informative report
    with a lot of additional information, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test and suite descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach screenshots on failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach text/plain context to the test report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark your tests with BDD labels and severity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test case categorization for tests of a common application area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trend history and failure analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the Allure reporter provides a much richer, more detailed report than the
    Spec reporter. It allows for a better understanding of what is happening during
    testing and offers a more holistic view of your test suite. You can think of it
    as the difference between a simple headline (Spec reporter) and a full news article
    complete with photos, analysis, and context (Allure reporter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add Allure to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `wdio.conf.ts` file, we will add the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This section directs where the reporting detail will be stored and includes
    two options that can be enabled or disabled. Both options are enabled by default
    (`false`), allowing Allure to provide detailed step-by-step reporting and include
    relevant screenshots to enhance the visibility and understandability of your test
    results. The only reason to disable these options would be to save disk space,
    which is not recommended. Excluding Webdriver steps reporting and screenshots
    reporting from the generated report only makes our analysis job harder.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Allure reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you did not set `Allure` as a reporter previously, it can be done manually.
    This is a two-step process: `Allure`, skip to *step 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Allure, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install Allure as a `devDependancies`. We can verify the package is
    added to the `package.json` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Allure reporter dependency is added to package.json](img/B19395_Figure_2.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Allure reporter dependency is added to package.json
  prefs: []
  type: TYPE_NORMAL
- en: 'The Allure package is added to the dev dependencies. Next, the output directories
    for the HTML report and screen captures must be configured in `wdio.config.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Adding Allure configuration to the wdio.config.ts file](img/B19395_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Adding Allure configuration to the wdio.config.ts file
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `wdio.config.ts` file, `outputDir` directs where the HTML files and
    screen captures are to be stored. Let’s use `allure-results`. Now run the test
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the `example.e2e.ts` test. It also generates results in the
    `allure-results` folder for Allure to build a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – New support files created by Allure to create the HTML report
    page](img/B19395_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – New support files created by Allure to create the HTML report
    page
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the results, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Bash terminal can also execute combined statements like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have installed and configured both WebdriverIO and the Allure dashboard service
    to display pretty result graphs for our stakeholders. But there is one constant
    in test automation, and that is change. We need to keep the versions of all our
    support packages up to date. If there are conflicts, there is bound to be trouble.
    Fortunately, there is an easy solution for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This information does not need to be stored in the repository, so we will add
    it to our `.``gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of each test, we should be consistent with an Allure reporting tag
    to help organize and categorize our test cases in the report. This includes tags
    for test owners (authors), features, stories, and descriptions. Advanced reporting
    can include links back to Jira tickets using TMS links. Let us begin with the
    `Owner` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first question any caped crusader wants answered is, “Who did it?” In earlier
    chapters, we noted that code can be quickly traced back to its owner in VS Code
    with GitLens. Since the original author of the test knows the tests they wrote
    best, your team members should be in the habit of adding their names to each test
    they write. Next, we need to organize our tests by feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.4 – Allure report displaying one passing test under the “Automation
    Hello World“ feature'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19395_12_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Allure report displaying one passing test under the “Automation
    Hello World“ feature
  prefs: []
  type: TYPE_NORMAL
- en: A `Feature` tag describes what area of the application is being tested by this
    and other tests. Test cases can be grouped for more efficient execution. This
    could be a small subset of tests that relate to only one area. This would eliminate
    separating tests by smoke and regression suites. Tests also need some detail regarding
    the functionality of the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the command for adding a descriptive tag name to the test in the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This description can be seen in the following screenshot, highlighted in blue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Description indicating the test will assert the login functionality'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19395_12_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Description indicating the test will assert the login functionality
  prefs: []
  type: TYPE_NORMAL
- en: The `Description` tag is the summary of the validation performed by the test
    itself. This is generally copied word for word from the title of a ticket in an
    issue-tracking tool referencing an existing manual test. It could also be the
    title of a ticket in a separate automation project that links across to the manual
    test in a separate project. Those ticket numbers should be matched with a `Story`
    traceability tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we add a story description to a test report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This information is then attached as the name of the test.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The ”TA-001” story added with a Jira ticker reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19395_12_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – The ”TA-001” story added with a Jira ticker reference
  prefs: []
  type: TYPE_NORMAL
- en: Tests need traceability to individual story detail information. There is little
    point in duplicating the text in the actual story ticket, so just providing the
    ticket number can be sufficient. It can be appended to a saved URL in a browser
    for a quick lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom comments to the Allure report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B19395_08.xhtml#_idTextAnchor165), we discussed creating a
    wrapper for `Expect`. We can add custom reporting with the `addattachment()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we intentionally fail with an invalid assertion verb, `equa`.
    `expectAdv` reports a detailed error to the Allure report describing the cause.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The problem string “equa” is reported as an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19395_12_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – The problem string “equa” is reported as an error
  prefs: []
  type: TYPE_NORMAL
- en: 'The best advice is to be as efficient as possible. Traceability could be combined
    with a single description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `Log` wrapper, we can provide details to both reporters. But not
    everything. That would cause a high signal-to-noise ratio. So, let us just log
    errors and warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the Spec reporter can be made a little more flashy with some color.
    Let’s say we want any text that indicates a result passed to be displayed in the
    console in green, while a test that failed is displayed in red. The `Log` wrapper
    can be amended to watch for the `PASS:` and `FAIL:` text. These strings can be
    surrounded by lines with ANSI color markers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add `Allure` to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s identify the basic colors at the top of our helper file starting
    with green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The color escape sequence is broken down here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\x1b` is the escape character, which starts the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[` is the **Control Sequence Introducer** (**CSI**), which tells the terminal
    to interpret the following characters as a command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`38` is the `foreground` text to a custom ANSI color. `48` sets the background
    color. Use 30–37 to set the color to one of the eight default foreground colors
    and 40–47 for the eight default background colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` specifies that the color will be faint set using RGB values. Other options
    include `3` for italics, `5` and `6` for blinking text, `7` for inverse text,
    and `9` for crossed-out text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`140;225;50` are the red, green, and blue values, respectively, for the color
    to be set. In this case, they define a shade of green.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m` is the final character, which marks the end of the escape sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, we can get quite creative with the color and formatting of
    the text. Next, we add red for failing messages and yellow for warning messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we output locators, they should have their own color as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Any text encased in single quotes could be auto-formatted to its own color
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to reset any color settings back to the default so we can
    distinguish between messaging from our framework from that of WebdriverIO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These colors may not be perfect for everyone. You can find a palette of ANSI
    RGB color combinations to customize to your liking here: [https://github.com/hinell/palette-print.bash](https://github.com/hinell/palette-print.bash).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s enhance the log wrapper to get some color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When we output out strings using accent marks, we can uniquely identify them
    and colorize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We could embed color for our xPath locators from the log method too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for CSS locators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when passing a result, it could be displayed at runtime in color based
    on the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But it would be more reliable to do this from the `Click`, `Select`, `Enter`,
    and `Expect` method wrappers instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can redirect any error logging to an Allure report like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Webhooks and screen captures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final step is to add a screen capture at the end of our test cases. It
    is your decision whether you want to take a screen capture only on failing test
    cases. However, based on our experience, we think taking a screen capture regardless
    will give you the opportunity to see what the difference between a passing versus
    a failing test is when you’re looking at a historical run saved in Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is accomplished by adding the preceding lines of code to the `afterTest`
    hook of the `WDIO.config` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `onPrepare`, `onWorkerStart`, `onWorkerEnd`, and `onComplete` hooks are
    executed in a different process and therefore cannot share any global data with
    the other hooks that live in the worker process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embarked on a heroic journey akin to traversing the dynamic
    realms of a superhero multiverse. We mastered the art of directing our test scenarios
    to various domains of operation—be it QA, stage, or, when the situation demands
    it, dev and even production. Alongside this, we infused our console log with a
    spectrum of hues, akin to a caped crusader’s vibrant costume. Our Allure reports,
    much like a meticulously organized utility belt, now display information with
    precision and clarity. We also unlocked the power of data files, safeguarding
    the keys to our digital city—sensitive credentials—from the prying eyes of nefarious
    adversaries.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through these diverse environments mirrors the complex task of a
    guardian navigating through parallel universes—each familiar in contour but unique
    in content. As we prepare to soar into the next chapter, we will fortify our tests
    with the resilience of a superhero’s shield, ensuring they withstand the trials
    of missing elements that may have vanished into the ether. Furthermore, we will
    broaden our horizons into the vast expanse of cross-browser testing, ensuring
    our digital endeavors are as versatile as a shape-shifting hero’s array of abilities.
  prefs: []
  type: TYPE_NORMAL
