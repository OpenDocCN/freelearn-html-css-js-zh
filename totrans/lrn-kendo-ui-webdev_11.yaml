- en: Chapter 11. Web API Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the widgets that we explored in the previous chapters are most useful
    when paired with more advanced server-side code. For example, many web applications
    use databases and work with files. While the previous chapters showed the client-side
    code, such as HTML and JavaScript, that is necessary to use these widgets, they
    did not focus on the ASP.NET server-side C# code that many real-world applications
    utilize. To demonstrate how to use the Kendo UI Framework with these types of
    scenarios, this chapter will show some specialized examples of using the Kendo
    UI Framework with the ASP.NET Web API and with the Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unfamiliar with the ASP.NET Web API framework, you can visit [www.asp.net/web-api](http://www.asp.net/web-api)
    for some good examples, videos, and walkthroughs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the ASP.NET Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most recent release of the ASP.NET MVC Framework, MVC 4, included templates
    for a new feature known as **Web API controllers** . These controllers are specialized
    HTTP communication endpoints and allow for the creation of RESTful API services.
    A RESTful API service is a HTTP web service that allows clients to communicate
    using standard HTTP verbs (`Get`, `Post`, `Put`, `Delete`, and `Patch`) in order
    to perform operations on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, ASP.NET has had the ability to create web services as SOAP endpoints
    (as opposed to REST endpoints). SOAP web services use XML schemas and are very
    good at serializing and deserializing strongly-typed objects and have been widely
    adopted in production systems. Compared with RESTful services, SOAP services are
    very verbose and brittle, as a change to the schema is required to implement any
    new features. Additionally, the explosive growth around JavaScript has made RESTful
    services more appealing to developers since they can be easily accessed through
    HTML `script` blocks and common JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services are becoming more and more common on the Internet. Many
    popular web-based services expose public RESTful APIs to enable integration with
    mobile apps, web-based dashboards, and other software projects. This widespread
    adoption is due largely in part to the equally widespread adoption of **JavaScript
    Object Notation** (**JSON**) for serializing and deserializing objects. JSON makes
    it simple for any web client to interpret data from any web server without requiring
    specialized or proprietary licenses or algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A RESTful web request is very simple and you use them every day, if you did
    not already know it. Every time you type a URL into a web browser, you are issuing
    an HTTP GET request to the server at that URL address. Likewise, most web pages
    that include forms use the HTTP POST verb to post that data back to the web server
    to be saved. This may also jog your memory back to some of our code samples in
    previous chapters. Do you remember seeing the `[HttpGet]` and `[HttpPost]` attributes
    on some of the controller action methods? These attributes indicated to ASP.NET
    that only a specific type of HTTP verb (either a GET or a POST) is allowed for
    that action method. This does have security implications of course, but it is
    actually more useful for determining which method the server should use depending
    on which HTTP verb the client sent along with the request. In other words, a controller
    could have five different action methods with different HTTP verb attributes for
    each one, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the preceding code is that it creates a separate route for
    each of the different functions for the page. If this page were accessible from
    the route `http://mysite.com/movies`, we could use `http://mysite.com/movies/get/25`
    to see data for a specific movie, but we would have to use a completely different
    route in order to add a new movie or to delete a movie, such as `http://mysite.com/movies/put`.
    This may not seem like such a big problem for a website where URLs can be embedded
    in forms and links without much interaction from the user, but this is a big problem
    for developers trying to create a program to access the API from remote code.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET MVC Web API solves this problem by creating special controllers
    solely for the purpose of creating RESTful services. In a standard MVC controller,
    each action method creates a new route (or URL) that ultimately generates some
    web content inside a view. In a Web API controller, however, each action method
    specifies a single HTTP verb for the same route (or URL). In other words, a Web
    API controller serves only a single HTTP endpoint; it only operates for a single
    route. For an API developer, this is perfect. A single HTTP endpoint, such as
    `http://mysite.com/api/movies`, can respond to all of the HTTP verbs appropriately
    without having to use different URLs for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of the API controller, each of the HTTP verbs gets one or more action
    methods for serving that specific type of request. The route to the controller
    defaults to the controller''s name. So a controller called `MoviesController.cs`
    would default to the route `http://mysite.com/api/movies`. This is as far as the
    route goes; the only difference now between requests to this endpoint is in which
    HTTP verb the request includes and which parameters are passed in as arguments.
    The following is the default code generated by the ASP.NET Web API template for
    an API controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the names of the action methods are the names of HTTP verbs. This
    is not an accident, it is required that the action method names either match an
    HTTP verb name or begin with an HTTP verb name. So an action method can either
    be called `Get` or it could be called `GetMovie`. Also notice that there are two
    different versions of the `Get` action method in this controller. Just like in
    a standard controller, the same action method can be listed multiple times as
    long as the signature for each method is unique. In this case, it allows us to
    have a standard `Get` method that does not require any parameters and a more specialized
    `Get` method that returns information for a specific record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can visit [http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api](http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api)
    for a good overview of Web API routing rules and naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice that these action methods do not have the HTTP verb attributes
    on them. For an API controller, these attributes are not required. There is a
    new attribute in the code sample, however. You can see it in front of the parameters
    for the `Post` and `Put` action methods: `[FromBody]`. This special attribute
    is used to assist the model binder in locating the parameter in the body of the
    HTTP request. It is not always necessary, such as when you are binding a complex
    object that the model binder can clearly see is made up of specific properties
    with specific names. For a simple string value as in this code sample, however,
    it needs to know that you intend to bind the HTTP request body to that input parameter.
    There is also an attribute (`[FromUri]`) to indicate that a parameter comes from
    the URL. Most of the time, these parameters will be unnecessary but they are available
    to help solve problems that the model binder is unable to solve on its own. It
    is worth some more research if you unfamiliar with it. The basic rules that Web
    API uses for model binding work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple types are taken from the URL (URI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex types are taken from the request body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple types include all of the .NET Framework primitive types, plus `DateTime`,
    `Decimal`, `Guid`, `String`, and `TimeSpan`. For each action method, at most one
    parameter can read the request body. If you try to mark more than one parameter
    with `[FromBody]`, you will either get a runtime error or null values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can visit [http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx](http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx)
    for more information on parameter binding with Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept to understand about API controllers is that they do
    not return views like standard controllers do. Rather than generating HTML markup
    for a web browser to display, API controllers generate raw data that is intended
    for specialized client code, such as JavaScript, to consume. The format of this
    data is something that you do not have to worry about. Notice how the action methods
    in the previous code sample simply return string values without using the `Json()`
    method that we have seen in some of the previous chapters. We do not need to tell
    the API controller how to format its data because it will auto-negotiate the correct
    format with the client during the communication process. The most common format
    is JSON, but some clients may prefer XML or other data types that the ASP.NET
    framework understands how to serialize.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may be interested in knowing how this auto-negotiation works. Here is the
    answer: it is based largely on the `Accept` header from the client during the
    API call. You can even create your own content types to extend the API framework
    for customized scenarios. See this page for more information: [http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation](http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation).'
  prefs: []
  type: TYPE_NORMAL
- en: Since API controllers are not designed to render web pages with markup, you
    will need to create normal controllers for your web pages as you are used to doing.
    To interact with the API controllers, it is very common to utilize JavaScript,
    especially jQuery, to access the API endpoints with a specific HTTP verb to accomplish
    whatever task your page is designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with Entity Framework Code First
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications use a database to store information. Most databases, however,
    store information in a way that does not exactly match up with server-side object
    oriented programming. This is a very common problem and has given rise to the
    field of **Object Relational Mapping** (**ORM**) systems. Many of these exist,
    but Microsoft has created one specific to the .NET framework known as the **Entity
    Framework** (**EF**). It is basically a framework designed to more easily write
    code that stores information in a database but still behaves like an object oriented
    system. If you have downloaded the sample content for this chapter, go ahead and
    open the `Chapter 11` solution now to follow along. Otherwise, create a new ASP.NET
    MVC 4 project and choose the **Web API** template when asked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The particulars of the Entity Framework are numerous and there is not enough
    space here to explore them. We will go through a basic example of how to utilize
    the Entity Framework Code First model so that we can show this in the examples
    for this chapter. In order to use the Entity Framework, you must first install
    it into your Visual Studio project through NuGet. You can do this by right-clicking
    the project in the Solution Explorer in Visual Studio and choosing **Manage NuGet
    Packages…**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, you should make sure that you are viewing the **Online**
    catalogue. Type the text `Entity Framework` into the search box and choose **Install**
    when it appears in the results window. Once installed, it will display a green
    check mark indicating that it is ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will install all of the necessary components of the Entity Framework into
    your Visual Studio solution. We will be using a feature of the Entity Framework
    known as **Code First** . This feature allows us to create classes, or entities,
    for our data first before the database even exists. The biggest benefit from this
    model is that it guarantees that the database will be designed and the data will
    be stored in accordance with our object oriented architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have not already done so, now is a good time to download the sample content
    for this chapter. All of these examples and files will already be present there,
    so you can follow along with working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of illustration, we will create our entity classes in the `Models`
    folder inside of our Visual Studio project. Create a class called `Movie.cs` in
    the `Models` folder like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Entity Framework will infer from the properties here that the `Id` property
    should become the primary key inside the database. Now that we have our model,
    we need to tell the Entity Framework that we want to make a database that includes
    it. Create another class in the `Models` folder and call it `MoviesContext.cs`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code informs the Entity Framework that we want a `DbContext` context that
    includes a `DbSet` of `Movie` entities. Let's go ahead and add some movies to
    our database, so that we can make use of them in our examples. To get started,
    we need a page where we can type in the movie data and have the web server save
    that data to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `MoviesController` controller with these options selected; it will
    automatically scaffold action methods and views with basic operations for managing
    the `Movie` entity that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you cannot find your `Movie` entity or the `MoviesContext` class, try building
    your project and trying again.
  prefs: []
  type: TYPE_NORMAL
- en: Now go to the `Movies/Index` page and create some movies. The first time you
    run the project, it may be very slow. The reason for this is that Entity Framework
    is creating your database on-the-fly in the background from the model and the
    context that you provided earlier. By the time you see the web page, the database
    will be up and running. You can see how I have created a few in the following
    screenshot. Create at least ten so that the examples have some data later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although there is a lot more to learn about the Entity Framework, this brief
    example has taken you all the way from a single class to a fully working database.
    We will be using this movies database in the rest of the examples for this chapter.
    If you are not familiar with the Entity Framework and would like to learn more,
    I recommend inspecting the `MoviesController.cs` class that we just created with
    Visual Studio to see how it created the default actions; you can then visit [www.msdn.com](http://www.msdn.com)
    for the official documentation on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with OData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Web API framework supports data queries through a syntax known as
    **OData**. OData is a query language that is compatible with HTTP URLs so that
    it can appear in URL query strings. It provides two very powerful benefits to
    API action methods that are used to return lists of data. First, it automatically
    translates the OData query language into an actual data query on the data inside
    of your API action method. This is amazingly powerful and may be hard to believe
    until you can actually see it. Basically, it is a search engine for free. Second,
    the OData features allow the queries to occur on the server. This means that the
    server can query the data source for the specific elements that match and then
    return the result back to the client. The client does not have to query the full
    set of data and then filter on its own. This is a huge performance improvement
    and also simplifies both client and server code.
  prefs: []
  type: TYPE_NORMAL
- en: There are four ways by which you can enable the OData query features for your
    API controllers. Each providing more fine-grained control than its predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: Enable query support globally through `WebApiConfig.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `[Queryable]` attribute to specific API action methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherit from `ODataController` instead of `ApiController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherit from `EntitySetController` instead of `ODataController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first option will globally enable query support for any `ApiController`
    action method with an `IQueryable` return type. To enable this, open the `WebApiConfig.cs`
    file inside of the `App_Start` folder and un-comment the line of code with `config.EnableQuerySupport()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option will enable query support for specific action methods that
    you decorate with the `[Queryable]` attribute. This gives you more configuration
    choices than the previous option because the `[Queryable]` attribute has many
    properties that you can configure to fine-tune its behavior. An action method
    decorated with this attribute looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The third option involves inheriting your controller class from `ODataController`
    instead of `ApiController`. This will enable the full OData support that the Web
    API offers and also requires some more configuration to be done, so that the OData
    engine understands the **Entity Data Model** (**EDM**) for the entities that it
    is exposing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code needs to run as the web application starts, so it should
    be placed either in `Global.asax` or in one of the `App_Start` classes, such as
    `WebApiConfig.cs`. It reads the same type of entity model as the Entity Framework
    and loads this into an OData route so that Web API understands how each part of
    the model is related, what the primary keys are, and so on. This enables more
    advanced scenarios such as property navigation. For more information on this,
    you can visit [http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint)
    for an introduction.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth option is similar to the previous option, but it enables more OData
    functionality automatically that the `ODataController` class would have to do
    manually. It still requires the `ODataModelBuilder` class as in the last option.
    The URL just listed also covers information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: For our examples in this chapter, we will be using the `[Queryable]` attribute
    to enable query support for specific action methods. I encourage you to explore
    this technology more on your own, it is a powerful and extensible framework that
    can provide huge productivity boosts to your code. To learn more about OData,
    you can visit [www.odata.org](http://www.odata.org).
  prefs: []
  type: TYPE_NORMAL
- en: Using DataSourceRequest with Kendo Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the first chapter, the Kendo Grid widget is designed to allow a
    rich set of features such as paging, filtering, and sorting. We saw previously
    how this can be driven on the client side through JavaScript and the Kendo `DataSource`
    object. The Grid widget becomes even more powerful, however, when connected with
    server-side functionality to help drive its features.
  prefs: []
  type: TYPE_NORMAL
- en: The Kendo UI Framework for ASP.NET MVC includes a special object to help facilitate
    this functionality within standard MVC controllers. It does not require the Web
    API or OData, although you could use them if you want to configure the Kendo `DataSource`
    by hand. In this example, we will learn how to use the `DataSourceRequest` object
    and how it helps drive the functionality of a Kendo Grid widget.
  prefs: []
  type: TYPE_NORMAL
- en: First, add a new action method to the `MoviesController` class that we created
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should notice right away the special attribute in the signature of the action
    method called `[DataSourceRequest]`. This attribute comes from the `Kendo.Mvc.Extensions`
    namespace, so you will need to include that in a `using` statement at the top
    of the controller. This attribute is necessary for the Kendo UI Framework to properly
    understand the communication between the Grid widget and this server-side action
    method. It is also important that the `[DataSourceRequest]` attribute is decorating
    a `DataSourceRequest` object and that the return value from this action method
    is passed through the extension method called `ToDataSourceResult(request)`. These
    special methods drive the Kendo functionality for data binding, sorting, paging
    and filtering.
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, add a new action method to the `KendoController` called
    `Grid`, which will be the action method we use for the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a view for this method and place the following Razor code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen before, this `Html` helper method from the Kendo UI Framework
    generates a Grid widget on the view page. We have configured the columns and enabled
    the Grid to be `pageable`, `sortable`, and `filterable`. The significant part
    for this example is that we have set the `DataSource` object to point to the `MoviesGrid`
    action of the `Movies` controller, which we set up earlier with the special Kendo
    attribute and objects. When we run our project and navigate to this new view,
    we get a Kendo Grid widget like the following, which has working paging buttons,
    filter buttons, and sortable column headings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike in [Chapter 1](ch01.html "Chapter 1. Interacting with Data: DataSource,
    Templates, TabStrip, and Grid"), *Interacting with Data: DataSource, Templates,
    TabStrip, and Grid*, however, this Grid widget is asking the server to calculate
    the sort order, the pages, and the filtered results. It does this by sending special
    data instructions to the server that are interpreted by the special Kendo attribute
    and objects. To see these data instructions, you can turn on the Internet Explorer
    developer tools by pressing the *F12* key while the website is running. In the
    toolbar that appears, click on the **Network** tab and then click **Start Capturing**.
    After clicking these buttons, click on one of the Grid functions, such as the
    page arrow or one of the column headings. You will see some activity in the developer
    toolbar, which means that the Grid is communicating with the server through JavaScript
    AJAX calls. Double-click on the first item in the list that shows the address
    **/Movies/MoviesGrid**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-clicking this item will open up a detailed description of the HTTP request.
    Click on the **Request body** tab to see what the Grid sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see here that the Grid has asked for page number `2` with a page size
    of `5` records. This is how the Kendo Grid communicates with the server, through
    the HTTP request body.
  prefs: []
  type: TYPE_NORMAL
- en: Driving the ListView with Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Grid widget, the ListView widget is able to utilize the `[DataSourceRequest]`
    attribute to help drive special functionality for its operations. In this case,
    we will not simply be querying the data from the server, but also editing it with
    the Web API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an action method for our ListView example in the `KendoController` class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a view for this action method and add the following HTML markup inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This basic HTML and Kendo template will be used to build the page once the
    data has been retrieved. You can see how the template is simply showing each element
    of a `Movie` object and then providing the edit and delete buttons. Next, add
    the following MVC Razor code at the bottom of this view to wire everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a Kendo ListView, specified the ID of the template to
    use when rendering it on the page, marked it as editable, and specified the data
    source. Inside of the data source, we have indicated where to retrieve the data
    to display (the `Read` method) and where to send updated data (the `Update` method).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create an editor template for the `Movie` object, so that this
    ListView can edit our `Movie` objects. Make a new folder under the `Views/Shared`
    folder called `EditorTemplates`. Then, add a view to the `EditorTemplates` folder
    and call it `Movie.cshtml`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving the ListView with Web API](img/4346OT_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `Movie.cshtml` view file and add the following code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This view will be used by the ListView widget when the **Edit** button is clicked
    on a `Movie` item. The following is how the page looks by default (when viewing
    the movies). You can see the different elements of a move item and the buttons
    used to edit or delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving the ListView with Web API](img/4346OT_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how a movie item is rendered when you click on the **Edit** button.
    See how the fields are now rendered as we specified in the `EditorTemplate` folder
    for the `Movie` data type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving the ListView with Web API](img/4346OT_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have wired this up to the Web API, we can observe the changes being
    sent to the server for processing if we set a breakpoint in Visual Studio inside
    the API method that is being called. You can see that I have done this in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Driving the ListView with Web API](img/4346OT_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With Visual Studio set this way, the program will stop when an update is made
    and you can inspect the data to observe what is happening. For a production application,
    you would want to use the Entity Framework to edit the `movie` object and save
    the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use the Web API for some more realistic
    scenarios involving two of the Kendo widgets that deal with managing data. We
    also quickly explored the ASP.NET Web API fundamentals as well as Entity Framework
    and OData. These tools, used together, can be a very powerful set and can create
    nearly any custom solution that you need.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we just saw, both use a special attribute that Telerik has provided
    to help with model binding and server-side paging and filtering. It is nice to
    make use of special helpers like this when they are available. I encourage you
    to continue to explore these technologies on your own and see how you can create
    your own custom solutions on your own web pages.
  prefs: []
  type: TYPE_NORMAL
