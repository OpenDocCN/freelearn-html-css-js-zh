- en: Chapter 11. Web API Examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. Web API 示例
- en: Many of the widgets that we explored in the previous chapters are most useful
    when paired with more advanced server-side code. For example, many web applications
    use databases and work with files. While the previous chapters showed the client-side
    code, such as HTML and JavaScript, that is necessary to use these widgets, they
    did not focus on the ASP.NET server-side C# code that many real-world applications
    utilize. To demonstrate how to use the Kendo UI Framework with these types of
    scenarios, this chapter will show some specialized examples of using the Kendo
    UI Framework with the ASP.NET Web API and with the Entity Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中探讨的许多小部件在与更高级的服务器端代码搭配使用时最为有用。例如，许多 Web 应用程序使用数据库并处理文件。虽然前几章展示了使用这些小部件所需的客户端代码，如
    HTML 和 JavaScript，但它们并没有关注许多实际应用所使用的 ASP.NET 服务器端 C# 代码。为了展示如何在这些场景中使用 Kendo UI
    框架，本章将展示一些使用 Kendo UI 框架与 ASP.NET Web API 和 Entity Framework 一起使用的专业示例。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with the ASP.NET Web API framework, you can visit [www.asp.net/web-api](http://www.asp.net/web-api)
    for some good examples, videos, and walkthroughs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 ASP.NET Web API 框架不熟悉，可以访问 [www.asp.net/web-api](http://www.asp.net/web-api)
    了解一些优秀的示例、视频和教程。
- en: Getting familiar with the ASP.NET Web API
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 ASP.NET Web API
- en: The most recent release of the ASP.NET MVC Framework, MVC 4, included templates
    for a new feature known as **Web API controllers** . These controllers are specialized
    HTTP communication endpoints and allow for the creation of RESTful API services.
    A RESTful API service is a HTTP web service that allows clients to communicate
    using standard HTTP verbs (`Get`, `Post`, `Put`, `Delete`, and `Patch`) in order
    to perform operations on the server.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET MVC 框架的最新版本 MVC 4 包含了名为 **Web API 控制器** 的新功能模板。这些控制器是专门的 HTTP 通信端点，允许创建
    RESTful API 服务。RESTful API 服务是一种 HTTP 网络服务，允许客户端使用标准 HTTP 动词（`Get`、`Post`、`Put`、`Delete`
    和 `Patch`）与服务器进行通信，以执行操作。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Traditionally, ASP.NET has had the ability to create web services as SOAP endpoints
    (as opposed to REST endpoints). SOAP web services use XML schemas and are very
    good at serializing and deserializing strongly-typed objects and have been widely
    adopted in production systems. Compared with RESTful services, SOAP services are
    very verbose and brittle, as a change to the schema is required to implement any
    new features. Additionally, the explosive growth around JavaScript has made RESTful
    services more appealing to developers since they can be easily accessed through
    HTML `script` blocks and common JavaScript code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，ASP.NET 具有创建作为 SOAP 端点（而非 REST 端点）的 Web 服务的功能。SOAP Web 服务使用 XML 架构，在序列化和反序列化强类型对象方面非常出色，并且在生产系统中得到了广泛的应用。与
    RESTful 服务相比，SOAP 服务非常冗长且脆弱，因为任何新功能的实现都需要更改架构。此外，JavaScript 的爆炸性增长使得 RESTful 服务对开发者更具吸引力，因为它们可以通过
    HTML `script` 块和常见的 JavaScript 代码轻松访问。
- en: RESTful web services are becoming more and more common on the Internet. Many
    popular web-based services expose public RESTful APIs to enable integration with
    mobile apps, web-based dashboards, and other software projects. This widespread
    adoption is due largely in part to the equally widespread adoption of **JavaScript
    Object Notation** (**JSON**) for serializing and deserializing objects. JSON makes
    it simple for any web client to interpret data from any web server without requiring
    specialized or proprietary licenses or algorithms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web 服务在互联网上变得越来越普遍。许多流行的基于 Web 的服务公开 RESTful API 以实现与移动应用、基于 Web 的仪表板和其他软件项目的集成。这种广泛的应用主要归因于
    **JavaScript 对象表示法**（**JSON**）在序列化和反序列化对象方面的同样广泛的应用。JSON 使得任何 Web 客户端都能轻松解释来自任何
    Web 服务器的数据，而无需专门的或专有的许可证或算法。
- en: 'A RESTful web request is very simple and you use them every day, if you did
    not already know it. Every time you type a URL into a web browser, you are issuing
    an HTTP GET request to the server at that URL address. Likewise, most web pages
    that include forms use the HTTP POST verb to post that data back to the web server
    to be saved. This may also jog your memory back to some of our code samples in
    previous chapters. Do you remember seeing the `[HttpGet]` and `[HttpPost]` attributes
    on some of the controller action methods? These attributes indicated to ASP.NET
    that only a specific type of HTTP verb (either a GET or a POST) is allowed for
    that action method. This does have security implications of course, but it is
    actually more useful for determining which method the server should use depending
    on which HTTP verb the client sent along with the request. In other words, a controller
    could have five different action methods with different HTTP verb attributes for
    each one, as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络请求非常简单，如果你不知道的话，你每天都在使用它们。每次你在网络浏览器中输入一个URL，你就是在向该URL地址的服务器发出一个HTTP
    GET请求。同样，大多数包含表单的网页使用HTTP POST动词将数据发送回网络服务器以保存。这也许会让你回想起我们之前章节中的某些代码示例。你还记得在控制器的一些操作方法上看到过`[HttpGet]`和`[HttpPost]`属性吗？这些属性向ASP.NET指示，只有特定类型的HTTP动词（GET或POST）对该操作方法有效。当然，这确实有安全影响，但它实际上更有用，可以根据客户端随请求发送的HTTP动词来确定服务器应使用哪种方法。换句话说，一个控制器可以有五个不同的操作方法，每个方法有不同的HTTP动词属性，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The problem with the preceding code is that it creates a separate route for
    each of the different functions for the page. If this page were accessible from
    the route `http://mysite.com/movies`, we could use `http://mysite.com/movies/get/25`
    to see data for a specific movie, but we would have to use a completely different
    route in order to add a new movie or to delete a movie, such as `http://mysite.com/movies/put`.
    This may not seem like such a big problem for a website where URLs can be embedded
    in forms and links without much interaction from the user, but this is a big problem
    for developers trying to create a program to access the API from remote code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的问题在于它为页面的每个不同功能创建了单独的路由。如果这个页面可以通过路由`http://mysite.com/movies`访问，我们可以使用`http://mysite.com/movies/get/25`来查看特定电影的数据，但为了添加新电影或删除电影，我们必须使用完全不同的路由，例如`http://mysite.com/movies/put`。这可能对于一个用户交互不多的网站来说不是什么大问题，但对于试图从远程代码中创建访问API的程序的开发者来说，这是一个大问题。
- en: The ASP.NET MVC Web API solves this problem by creating special controllers
    solely for the purpose of creating RESTful services. In a standard MVC controller,
    each action method creates a new route (or URL) that ultimately generates some
    web content inside a view. In a Web API controller, however, each action method
    specifies a single HTTP verb for the same route (or URL). In other words, a Web
    API controller serves only a single HTTP endpoint; it only operates for a single
    route. For an API developer, this is perfect. A single HTTP endpoint, such as
    `http://mysite.com/api/movies`, can respond to all of the HTTP verbs appropriately
    without having to use different URLs for each operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET MVC Web API通过创建专门用于创建RESTful服务的特殊控制器来解决此问题。在一个标准的MVC控制器中，每个操作方法创建一个新的路由（或URL），最终在视图中生成一些网页内容。然而，在一个Web
    API控制器中，每个操作方法为相同的路由（或URL）指定一个单一的HTTP动词。换句话说，Web API控制器只为单个HTTP端点提供服务；它只针对单个路由操作。对于API开发者来说，这是完美的。例如，单个HTTP端点`http://mysite.com/api/movies`可以适当地响应所有HTTP动词，而无需为每个操作使用不同的URL。
- en: 'Inside of the API controller, each of the HTTP verbs gets one or more action
    methods for serving that specific type of request. The route to the controller
    defaults to the controller''s name. So a controller called `MoviesController.cs`
    would default to the route `http://mysite.com/api/movies`. This is as far as the
    route goes; the only difference now between requests to this endpoint is in which
    HTTP verb the request includes and which parameters are passed in as arguments.
    The following is the default code generated by the ASP.NET Web API template for
    an API controller:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在API控制器内部，每个HTTP动词都有一到多个操作方法来处理该特定类型的请求。控制器到路由的默认值是控制器的名称。因此，名为`MoviesController.cs`的控制器默认路由为`http://mysite.com/api/movies`。这就是路由的终点；现在，请求此端点之间的唯一区别在于请求包含的HTTP动词以及作为参数传递的哪些参数。以下是由ASP.NET
    Web API模板为API控制器生成的默认代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the names of the action methods are the names of HTTP verbs. This
    is not an accident, it is required that the action method names either match an
    HTTP verb name or begin with an HTTP verb name. So an action method can either
    be called `Get` or it could be called `GetMovie`. Also notice that there are two
    different versions of the `Get` action method in this controller. Just like in
    a standard controller, the same action method can be listed multiple times as
    long as the signature for each method is unique. In this case, it allows us to
    have a standard `Get` method that does not require any parameters and a more specialized
    `Get` method that returns information for a specific record.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到操作方法的名称是HTTP动词的名称。这不是偶然的，操作方法名称必须与HTTP动词名称匹配或以HTTP动词名称开头。因此，一个操作方法可以被称为`Get`，或者它可以被称为`GetMovie`。请注意，在这个控制器中，有两个不同的`Get`操作方法版本。就像在标准控制器中一样，只要每个方法的签名是唯一的，相同的操作方法可以多次列出。在这种情况下，它允许我们有一个不需要任何参数的标准`Get`方法，以及一个更专业的`Get`方法，该方法返回特定记录的信息。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can visit [http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api](http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api)
    for a good overview of Web API routing rules and naming conventions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api](http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api)以了解Web
    API路由规则和命名约定的良好概述。
- en: 'You will also notice that these action methods do not have the HTTP verb attributes
    on them. For an API controller, these attributes are not required. There is a
    new attribute in the code sample, however. You can see it in front of the parameters
    for the `Post` and `Put` action methods: `[FromBody]`. This special attribute
    is used to assist the model binder in locating the parameter in the body of the
    HTTP request. It is not always necessary, such as when you are binding a complex
    object that the model binder can clearly see is made up of specific properties
    with specific names. For a simple string value as in this code sample, however,
    it needs to know that you intend to bind the HTTP request body to that input parameter.
    There is also an attribute (`[FromUri]`) to indicate that a parameter comes from
    the URL. Most of the time, these parameters will be unnecessary but they are available
    to help solve problems that the model binder is unable to solve on its own. It
    is worth some more research if you unfamiliar with it. The basic rules that Web
    API uses for model binding work like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，这些操作方法上没有HTTP动词属性。对于API控制器，这些属性不是必需的。然而，代码示例中有一个新的属性。您可以在`Post`和`Put`操作方法的参数前看到它：`[FromBody]`。这个特殊属性用于帮助模型绑定器在HTTP请求体中定位参数。它并不总是必要的，例如，当您绑定一个模型绑定器可以清楚地看到由具有特定名称的特定属性组成的复杂对象时。然而，对于像本代码示例中的简单字符串值，它需要知道您打算将HTTP请求体绑定到那个输入参数。还有一个属性（`[FromUri]`）用来指示参数来自URL。大多数情况下，这些参数将是不必要的，但它们可用于帮助解决模型绑定器无法自行解决的问题。如果您不熟悉它，那么进行一些研究是值得的。Web
    API用于模型绑定的基本规则如下：
- en: Simple types are taken from the URL (URI)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单类型来自URL（URI）
- en: Complex types are taken from the request body
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂类型来自请求体
- en: Simple types include all of the .NET Framework primitive types, plus `DateTime`,
    `Decimal`, `Guid`, `String`, and `TimeSpan`. For each action method, at most one
    parameter can read the request body. If you try to mark more than one parameter
    with `[FromBody]`, you will either get a runtime error or null values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简单类型包括所有.NET Framework的原始类型，以及`DateTime`、`Decimal`、`Guid`、`String`和`TimeSpan`。对于每个操作方法，最多只能有一个参数可以读取请求体。如果您尝试用`[FromBody]`标记多个参数，您可能会遇到运行时错误或空值。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can visit [http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx](http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx)
    for more information on parameter binding with Web API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx](http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx)以获取有关Web
    API参数绑定的更多信息。
- en: Another important concept to understand about API controllers is that they do
    not return views like standard controllers do. Rather than generating HTML markup
    for a web browser to display, API controllers generate raw data that is intended
    for specialized client code, such as JavaScript, to consume. The format of this
    data is something that you do not have to worry about. Notice how the action methods
    in the previous code sample simply return string values without using the `Json()`
    method that we have seen in some of the previous chapters. We do not need to tell
    the API controller how to format its data because it will auto-negotiate the correct
    format with the client during the communication process. The most common format
    is JSON, but some clients may prefer XML or other data types that the ASP.NET
    framework understands how to serialize.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于API控制器，还有一个重要的概念需要理解，那就是它们不会像标准控制器那样返回视图。API控制器不是为浏览器显示生成HTML标记，而是生成原始数据，这些数据旨在供专门的客户端代码，如JavaScript，消费。这种数据格式是您不必担心的事情。注意，在前面的代码示例中，动作方法只是简单地返回字符串值，而没有使用我们在一些前面的章节中看到过的`Json()`方法。我们不需要告诉API控制器如何格式化其数据，因为它将在通信过程中与客户端自动协商正确的格式。最常用的格式是JSON，但某些客户端可能更喜欢XML或其他ASP.NET框架知道如何序列化的数据类型。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may be interested in knowing how this auto-negotiation works. Here is the
    answer: it is based largely on the `Accept` header from the client during the
    API call. You can even create your own content types to extend the API framework
    for customized scenarios. See this page for more information: [http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation](http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这种自动协商是如何工作的。以下是答案：它主要基于API调用期间客户端的`Accept`头。您甚至可以创建自己的内容类型来扩展API框架以适应定制场景。更多信息请参阅此页面：[http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation](http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation)。
- en: Since API controllers are not designed to render web pages with markup, you
    will need to create normal controllers for your web pages as you are used to doing.
    To interact with the API controllers, it is very common to utilize JavaScript,
    especially jQuery, to access the API endpoints with a specific HTTP verb to accomplish
    whatever task your page is designed for.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API控制器不是设计用来渲染带有标记的网页，因此您需要创建与您习惯相同的常规控制器来处理您的网页。为了与API控制器交互，使用JavaScript，尤其是jQuery，通过特定的HTTP动词访问API端点以完成页面设计的任何任务是非常常见的。
- en: Getting familiar with Entity Framework Code First
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉Entity Framework Code First
- en: Most applications use a database to store information. Most databases, however,
    store information in a way that does not exactly match up with server-side object
    oriented programming. This is a very common problem and has given rise to the
    field of **Object Relational Mapping** (**ORM**) systems. Many of these exist,
    but Microsoft has created one specific to the .NET framework known as the **Entity
    Framework** (**EF**). It is basically a framework designed to more easily write
    code that stores information in a database but still behaves like an object oriented
    system. If you have downloaded the sample content for this chapter, go ahead and
    open the `Chapter 11` solution now to follow along. Otherwise, create a new ASP.NET
    MVC 4 project and choose the **Web API** template when asked.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序使用数据库来存储信息。然而，大多数数据库存储信息的方式并不完全符合服务器端面向对象编程。这是一个非常普遍的问题，并催生了**对象关系映射**（**ORM**）系统领域。其中许多存在，但微软为.NET框架创建了一个特定的系统，称为**Entity
    Framework**（**EF**）。它基本上是一个框架，旨在更容易编写将信息存储在数据库中的代码，同时仍然像面向对象系统一样运行。如果您已经下载了本章的示例内容，请现在打开`Chapter
    11`解决方案以继续。否则，创建一个新的ASP.NET MVC 4项目，并在被询问时选择**Web API**模板。
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉Entity Framework Code First](img/4346OT_11_05.jpg)'
- en: 'The particulars of the Entity Framework are numerous and there is not enough
    space here to explore them. We will go through a basic example of how to utilize
    the Entity Framework Code First model so that we can show this in the examples
    for this chapter. In order to use the Entity Framework, you must first install
    it into your Visual Studio project through NuGet. You can do this by right-clicking
    the project in the Solution Explorer in Visual Studio and choosing **Manage NuGet
    Packages…**, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 的细节众多，这里没有足够的空间来探索它们。我们将通过一个基本的示例来展示如何利用 Entity Framework Code
    First 模型，以便我们可以在本章的示例中展示它。为了使用 Entity Framework，您必须首先通过 NuGet 将它安装到您的 Visual Studio
    项目中。您可以通过在 Visual Studio 的解决方案资源管理器中右键单击项目并选择 **管理 NuGet 包…** 来这样做，如图所示：
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Entity Framework Code First](img/4346OT_11_01.jpg)'
- en: 'On the next screen, you should make sure that you are viewing the **Online**
    catalogue. Type the text `Entity Framework` into the search box and choose **Install**
    when it appears in the results window. Once installed, it will display a green
    check mark indicating that it is ready for use:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏，您应该确保您正在查看 **在线** 目录。在搜索框中输入文本 `Entity Framework`，当它在结果窗口中出现时选择 **安装**。一旦安装，它将显示一个绿色的勾选标记，表示它已准备好使用：
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Entity Framework Code First](img/4346OT_11_02.jpg)'
- en: This will install all of the necessary components of the Entity Framework into
    your Visual Studio solution. We will be using a feature of the Entity Framework
    known as **Code First** . This feature allows us to create classes, or entities,
    for our data first before the database even exists. The biggest benefit from this
    model is that it guarantees that the database will be designed and the data will
    be stored in accordance with our object oriented architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有必要的 Entity Framework 组件到您的 Visual Studio 解决方案中。我们将使用 Entity Framework
    的一个名为 **Code First** 的功能。这个功能允许我们在数据库甚至存在之前首先创建类，或实体。从这个模型中获得的最大好处是，它保证了数据库的设计和数据存储将符合我们的面向对象架构。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have not already done so, now is a good time to download the sample content
    for this chapter. All of these examples and files will already be present there,
    so you can follow along with working code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，现在下载本章的示例内容是个好时机。所有这些示例和文件都已经存在那里，所以您可以跟随带有工作代码的示例。
- en: 'For the sake of illustration, we will create our entity classes in the `Models`
    folder inside of our Visual Studio project. Create a class called `Movie.cs` in
    the `Models` folder like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明起见，我们将在 Visual Studio 项目的 `Models` 文件夹中创建我们的实体类。在 `Models` 文件夹中创建一个名为 `Movie.cs`
    的类，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Entity Framework will infer from the properties here that the `Id` property
    should become the primary key inside the database. Now that we have our model,
    we need to tell the Entity Framework that we want to make a database that includes
    it. Create another class in the `Models` folder and call it `MoviesContext.cs`,
    as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 将从这个属性推断出 `Id` 属性应该在数据库内部成为主键。现在我们已经有了我们的模型，我们需要告诉 Entity Framework
    我们想要创建一个包含它的数据库。在 `Models` 文件夹中创建另一个类，并将其命名为 `MoviesContext.cs`，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code informs the Entity Framework that we want a `DbContext` context that
    includes a `DbSet` of `Movie` entities. Let's go ahead and add some movies to
    our database, so that we can make use of them in our examples. To get started,
    we need a page where we can type in the movie data and have the web server save
    that data to the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通知 Entity Framework 我们想要一个包含 `Movie` 实体 `DbSet` 的 `DbContext` 上下文。让我们继续添加一些电影到我们的数据库中，这样我们就可以在我们的示例中使用它们。为了开始，我们需要一个页面，我们可以输入电影数据，并且让网络服务器将数据保存到数据库中。
- en: Create a `MoviesController` controller with these options selected; it will
    automatically scaffold action methods and views with basic operations for managing
    the `Movie` entity that we just created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有以下选项选择的 `MoviesController` 控制器；它将自动生成用于管理我们刚刚创建的 `Movie` 实体的基本操作方法和视图。
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Entity Framework Code First](img/4346OT_11_03.jpg)'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you cannot find your `Movie` entity or the `MoviesContext` class, try building
    your project and trying again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到 `Movie` 实体或 `MoviesContext` 类，请尝试构建您的项目并再次尝试。
- en: Now go to the `Movies/Index` page and create some movies. The first time you
    run the project, it may be very slow. The reason for this is that Entity Framework
    is creating your database on-the-fly in the background from the model and the
    context that you provided earlier. By the time you see the web page, the database
    will be up and running. You can see how I have created a few in the following
    screenshot. Create at least ten so that the examples have some data later in the
    chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到`Movies/Index`页面并创建一些电影。第一次运行项目时，它可能非常慢。原因是Entity Framework正在后台根据你之前提供的模型和上下文动态创建你的数据库。在你看到网页的时候，数据库就已经启动并运行了。你可以在下面的屏幕截图中看到我是如何创建几个的。至少创建十个，以便在章节后面的示例中有一些数据。
- en: '![Getting familiar with Entity Framework Code First](img/4346OT_11_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉Entity Framework Code First](img/4346OT_11_04.jpg)'
- en: Although there is a lot more to learn about the Entity Framework, this brief
    example has taken you all the way from a single class to a fully working database.
    We will be using this movies database in the rest of the examples for this chapter.
    If you are not familiar with the Entity Framework and would like to learn more,
    I recommend inspecting the `MoviesController.cs` class that we just created with
    Visual Studio to see how it created the default actions; you can then visit [www.msdn.com](http://www.msdn.com)
    for the official documentation on the topic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有更多关于Entity Framework的知识需要学习，但这个简短的例子已经带你从单个类到完全工作的数据库。我们将在这个章节的其余示例中使用这个电影数据库。如果你对Entity
    Framework不熟悉并且想了解更多，我建议检查我们刚刚用Visual Studio创建的`MoviesController.cs`类，看看它是如何创建默认操作的；然后你可以访问[www.msdn.com](http://www.msdn.com)获取该主题的官方文档。
- en: Getting familiar with OData
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉OData
- en: The ASP.NET Web API framework supports data queries through a syntax known as
    **OData**. OData is a query language that is compatible with HTTP URLs so that
    it can appear in URL query strings. It provides two very powerful benefits to
    API action methods that are used to return lists of data. First, it automatically
    translates the OData query language into an actual data query on the data inside
    of your API action method. This is amazingly powerful and may be hard to believe
    until you can actually see it. Basically, it is a search engine for free. Second,
    the OData features allow the queries to occur on the server. This means that the
    server can query the data source for the specific elements that match and then
    return the result back to the client. The client does not have to query the full
    set of data and then filter on its own. This is a huge performance improvement
    and also simplifies both client and server code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Web API框架通过称为**OData**的语法支持数据查询。OData是一种与HTTP URL兼容的查询语言，因此它可以出现在URL查询字符串中。它为用于返回数据列表的API操作方法提供了两个非常强大的好处。首先，它自动将OData查询语言转换为API操作方法内部实际的数据查询。这非常强大，直到你真正看到它可能很难相信。基本上，它是一个免费的搜索引擎。其次，OData功能允许查询在服务器上执行。这意味着服务器可以查询数据源以找到匹配的特定元素，然后将结果返回给客户端。客户端不需要查询整个数据集然后自行过滤。这是一个巨大的性能提升，同时也简化了客户端和服务器端的代码。
- en: There are four ways by which you can enable the OData query features for your
    API controllers. Each providing more fine-grained control than its predecessor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过四种方式为你的API控制器启用OData查询功能。每个都比前一个提供了更细粒度的控制。
- en: Enable query support globally through `WebApiConfig.cs`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`WebApiConfig.cs`全局启用查询支持
- en: Add the `[Queryable]` attribute to specific API action methods
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`[Queryable]`属性添加到特定的API操作方法
- en: Inherit from `ODataController` instead of `ApiController`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ODataController`继承而不是`ApiController`
- en: Inherit from `EntitySetController` instead of `ODataController`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`EntitySetController`继承而不是`ODataController`
- en: 'The first option will globally enable query support for any `ApiController`
    action method with an `IQueryable` return type. To enable this, open the `WebApiConfig.cs`
    file inside of the `App_Start` folder and un-comment the line of code with `config.EnableQuerySupport()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项将全局启用任何具有`IQueryable`返回类型的`ApiController`操作方法的查询支持。要启用此功能，打开`App_Start`文件夹中的`WebApiConfig.cs`文件，取消注释带有`config.EnableQuerySupport()`的代码行：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second option will enable query support for specific action methods that
    you decorate with the `[Queryable]` attribute. This gives you more configuration
    choices than the previous option because the `[Queryable]` attribute has many
    properties that you can configure to fine-tune its behavior. An action method
    decorated with this attribute looks like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法将启用带有 `[Queryable]` 属性装饰的特定操作方法的查询支持。与前面的选项相比，它提供了更多的配置选择，因为 `[Queryable]`
    属性有许多属性可以配置以微调其行为。带有此属性装饰的操作方法看起来如下：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The third option involves inheriting your controller class from `ODataController`
    instead of `ApiController`. This will enable the full OData support that the Web
    API offers and also requires some more configuration to be done, so that the OData
    engine understands the **Entity Data Model** (**EDM**) for the entities that it
    is exposing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法涉及从 `ODataController` 继承您的控制器类而不是 `ApiController`。这将启用 Web API 提供的完整 OData
    支持，并且还需要进行一些额外的配置，以便 OData 引擎理解它所公开的实体的 **实体数据模型**（**EDM**）。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code needs to run as the web application starts, so it should
    be placed either in `Global.asax` or in one of the `App_Start` classes, such as
    `WebApiConfig.cs`. It reads the same type of entity model as the Entity Framework
    and loads this into an OData route so that Web API understands how each part of
    the model is related, what the primary keys are, and so on. This enables more
    advanced scenarios such as property navigation. For more information on this,
    you can visit [http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint)
    for an introduction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码需要在 Web 应用程序启动时运行，因此它应该放置在 `Global.asax` 或 `App_Start` 类之一中，例如 `WebApiConfig.cs`。它读取与
    Entity Framework 相同类型的实体模型，并将其加载到 OData 路由中，以便 Web API 理解模型各部分之间的关系，主键是什么，等等。这使更高级的场景，如属性导航成为可能。有关此信息，您可以访问
    [http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint)
    了解介绍。
- en: The fourth option is similar to the previous option, but it enables more OData
    functionality automatically that the `ODataController` class would have to do
    manually. It still requires the `ODataModelBuilder` class as in the last option.
    The URL just listed also covers information on this topic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方法与前面的方法类似，但它自动启用了 `ODataController` 类必须手动执行的更多 OData 功能。它仍然需要与上一个选项中的 `ODataModelBuilder`
    类。上面列出的 URL 也涵盖了此主题的信息。
- en: For our examples in this chapter, we will be using the `[Queryable]` attribute
    to enable query support for specific action methods. I encourage you to explore
    this technology more on your own, it is a powerful and extensible framework that
    can provide huge productivity boosts to your code. To learn more about OData,
    you can visit [www.odata.org](http://www.odata.org).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将使用 `[Queryable]` 属性来为特定的操作方法启用查询支持。我鼓励您自己更深入地探索这项技术，它是一个强大且可扩展的框架，可以为您的代码提供巨大的生产力提升。要了解更多关于
    OData 的信息，您可以访问 [www.odata.org](http://www.odata.org)。
- en: Using DataSourceRequest with Kendo Grid
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DataSourceRequest 与 Kendo Grid
- en: As we saw in the first chapter, the Kendo Grid widget is designed to allow a
    rich set of features such as paging, filtering, and sorting. We saw previously
    how this can be driven on the client side through JavaScript and the Kendo `DataSource`
    object. The Grid widget becomes even more powerful, however, when connected with
    server-side functionality to help drive its features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中看到的，Kendo Grid 小部件旨在允许丰富的功能，如分页、过滤和排序。我们之前看到，这可以通过客户端的 JavaScript 和
    Kendo `DataSource` 对象来实现。然而，当与服务器端功能连接时，Grid 小部件的功能变得更加强大，以帮助驱动其功能。
- en: The Kendo UI Framework for ASP.NET MVC includes a special object to help facilitate
    this functionality within standard MVC controllers. It does not require the Web
    API or OData, although you could use them if you want to configure the Kendo `DataSource`
    by hand. In this example, we will learn how to use the `DataSourceRequest` object
    and how it helps drive the functionality of a Kendo Grid widget.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI Framework for ASP.NET MVC 包含一个特殊对象，用于帮助在标准 MVC 控制器中实现此功能。它不需要 Web API
    或 OData，尽管如果您想手动配置 Kendo `DataSource`，则可以使用它们。在本例中，我们将学习如何使用 `DataSourceRequest`
    对象以及它是如何帮助驱动 Kendo Grid 小部件的功能的。
- en: First, add a new action method to the `MoviesController` class that we created
    earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向之前创建的`MoviesController`类中添加一个新的操作方法。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should notice right away the special attribute in the signature of the action
    method called `[DataSourceRequest]`. This attribute comes from the `Kendo.Mvc.Extensions`
    namespace, so you will need to include that in a `using` statement at the top
    of the controller. This attribute is necessary for the Kendo UI Framework to properly
    understand the communication between the Grid widget and this server-side action
    method. It is also important that the `[DataSourceRequest]` attribute is decorating
    a `DataSourceRequest` object and that the return value from this action method
    is passed through the extension method called `ToDataSourceResult(request)`. These
    special methods drive the Kendo functionality for data binding, sorting, paging
    and filtering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您应立即注意到操作方法签名的特殊属性`[DataSourceRequest]`。此属性来自`Kendo.Mvc.Extensions`命名空间，因此您需要在控制器顶部的`using`语句中包含它。此属性对于Kendo
    UI框架正确理解网格小部件和服务器端操作方法之间的通信是必要的。同样重要的是，`[DataSourceRequest]`属性装饰了一个`DataSourceRequest`对象，并且从此操作方法返回的值通过名为`ToDataSourceResult(request)`的扩展方法传递。这些特殊方法驱动Kendo的数据绑定、排序、分页和过滤功能。
- en: With this code in place, add a new action method to the `KendoController` called
    `Grid`, which will be the action method we use for the view.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码就绪后，向`KendoController`添加一个名为`Grid`的新操作方法，这将是用于视图的操作方法。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a view for this method and place the following Razor code inside it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为此方法创建一个视图，并在其中放置以下Razor代码：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you have seen before, this `Html` helper method from the Kendo UI Framework
    generates a Grid widget on the view page. We have configured the columns and enabled
    the Grid to be `pageable`, `sortable`, and `filterable`. The significant part
    for this example is that we have set the `DataSource` object to point to the `MoviesGrid`
    action of the `Movies` controller, which we set up earlier with the special Kendo
    attribute and objects. When we run our project and navigate to this new view,
    we get a Kendo Grid widget like the following, which has working paging buttons,
    filter buttons, and sortable column headings:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，此`Html`辅助方法来自Kendo UI框架，在视图页面上生成一个网格小部件。我们已配置了列并启用了网格的`pageable`、`sortable`和`filterable`功能。对于此示例来说，重要的是我们已经将`DataSource`对象设置为指向我们之前设置的`Movies`控制器的`MoviesGrid`操作，该操作具有特殊的Kendo属性和对象。当我们运行我们的项目并导航到这个新视图时，我们得到一个如下所示的Kendo网格小部件，它具有工作分页按钮、过滤按钮和可排序的列标题：
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用DataSourceRequest与Kendo Grid](img/4346OT_11_06.jpg)'
- en: 'Unlike in [Chapter 1](ch01.html "Chapter 1. Interacting with Data: DataSource,
    Templates, TabStrip, and Grid"), *Interacting with Data: DataSource, Templates,
    TabStrip, and Grid*, however, this Grid widget is asking the server to calculate
    the sort order, the pages, and the filtered results. It does this by sending special
    data instructions to the server that are interpreted by the special Kendo attribute
    and objects. To see these data instructions, you can turn on the Internet Explorer
    developer tools by pressing the *F12* key while the website is running. In the
    toolbar that appears, click on the **Network** tab and then click **Start Capturing**.
    After clicking these buttons, click on one of the Grid functions, such as the
    page arrow or one of the column headings. You will see some activity in the developer
    toolbar, which means that the Grid is communicating with the server through JavaScript
    AJAX calls. Double-click on the first item in the list that shows the address
    **/Movies/MoviesGrid**, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第1章](ch01.html "第1章. 与数据交互：数据源、模板、TabStrip和网格")不同，*与数据交互：数据源、模板、TabStrip和网格*，然而，这个网格小部件要求服务器计算排序顺序、页码和过滤后的结果。它是通过向服务器发送特殊的数据指令来完成的，这些指令由特殊的Kendo属性和对象解释。要查看这些数据指令，可以在网站运行时按*F12*键打开Internet
    Explorer开发者工具。在出现的工具栏中，点击**网络**标签，然后点击**开始捕获**。点击这些按钮后，点击网格功能之一，如页面箭头或列标题之一。你将在开发者工具栏中看到一些活动，这意味着网格正在通过JavaScript
    AJAX调用与服务器通信。双击列表中显示地址**/Movies/MoviesGrid**的第一项，如图所示：
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![使用DataSourceRequest与Kendo Grid](img/4346OT_11_07.jpg)'
- en: 'Double-clicking this item will open up a detailed description of the HTTP request.
    Click on the **Request body** tab to see what the Grid sent to the server:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 双击此项目将打开HTTP请求的详细描述。点击**请求体**标签以查看网格发送到服务器的信息：
- en: '![Using DataSourceRequest with Kendo Grid](img/4346OT_11_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用DataSourceRequest与Kendo Grid](img/4346OT_11_08.jpg)'
- en: You can see here that the Grid has asked for page number `2` with a page size
    of `5` records. This is how the Kendo Grid communicates with the server, through
    the HTTP request body.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Grid请求了页码`2`，每页大小为`5`条记录。这是Kendo Grid如何通过HTTP请求体与服务器通信的方式。
- en: Driving the ListView with Web API
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web API驱动ListView
- en: Similar to the Grid widget, the ListView widget is able to utilize the `[DataSourceRequest]`
    attribute to help drive special functionality for its operations. In this case,
    we will not simply be querying the data from the server, but also editing it with
    the Web API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与Grid小部件类似，ListView小部件能够利用`[DataSourceRequest]`属性来帮助驱动其操作的特殊功能。在这种情况下，我们不仅将从服务器查询数据，还将使用Web
    API进行编辑。
- en: 'Create an action method for our ListView example in the `KendoController` class,
    as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KendoController`类中为我们的ListView示例创建一个动作方法，如下所示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then add a view for this action method and add the following HTML markup inside:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为这个动作方法添加一个视图，并在其中添加以下HTML标记：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This basic HTML and Kendo template will be used to build the page once the
    data has been retrieved. You can see how the template is simply showing each element
    of a `Movie` object and then providing the edit and delete buttons. Next, add
    the following MVC Razor code at the bottom of this view to wire everything together:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据检索后，这个基本的HTML和Kendo模板将被用来构建页面。你可以看到模板只是简单地显示`Movie`对象的每个元素，然后提供编辑和删除按钮。接下来，在视图底部添加以下MVC
    Razor代码来连接一切：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have created a Kendo ListView, specified the ID of the template to
    use when rendering it on the page, marked it as editable, and specified the data
    source. Inside of the data source, we have indicated where to retrieve the data
    to display (the `Read` method) and where to send updated data (the `Update` method).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个Kendo ListView，指定了在页面上渲染时要使用的模板ID，将其标记为可编辑，并指定了数据源。在数据源内部，我们指明了要检索以显示数据的位置（`Read`方法）以及发送更新数据的位置（`Update`方法）。
- en: Next, we need to create an editor template for the `Movie` object, so that this
    ListView can edit our `Movie` objects. Make a new folder under the `Views/Shared`
    folder called `EditorTemplates`. Then, add a view to the `EditorTemplates` folder
    and call it `Movie.cshtml`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`Movie`对象创建一个编辑模板，以便这个ListView可以编辑我们的`Movie`对象。在`Views/Shared`文件夹下创建一个名为`EditorTemplates`的新文件夹。然后，在`EditorTemplates`文件夹中添加一个视图，并将其命名为`Movie.cshtml`。
- en: '![Driving the ListView with Web API](img/4346OT_11_11.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用Web API驱动ListView](img/4346OT_11_11.jpg)'
- en: 'Open the `Movie.cshtml` view file and add the following code there:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Movie.cshtml`视图文件，并在其中添加以下代码：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This view will be used by the ListView widget when the **Edit** button is clicked
    on a `Movie` item. The following is how the page looks by default (when viewing
    the movies). You can see the different elements of a move item and the buttons
    used to edit or delete it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Movie`项上点击**编辑**按钮时，ListView小部件将使用此视图。以下是在默认情况下（查看电影）的页面外观。你可以看到电影项的不同元素以及用于编辑或删除它的按钮：
- en: '![Driving the ListView with Web API](img/4346OT_11_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用Web API驱动ListView](img/4346OT_11_09.jpg)'
- en: This is how a movie item is rendered when you click on the **Edit** button.
    See how the fields are now rendered as we specified in the `EditorTemplate` folder
    for the `Movie` data type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**编辑**按钮时，这就是电影项的渲染方式。看看字段是如何现在按照我们在`EditorTemplate`文件夹中为`Movie`数据类型指定的方式渲染的。
- en: '![Driving the ListView with Web API](img/4346OT_11_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用Web API驱动ListView](img/4346OT_11_10.jpg)'
- en: 'Since we have wired this up to the Web API, we can observe the changes being
    sent to the server for processing if we set a breakpoint in Visual Studio inside
    the API method that is being called. You can see that I have done this in the
    following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将其连接到Web API，如果我们设置Visual Studio中API方法被调用时的断点，我们可以观察到发送到服务器进行处理的更改。你可以看到我在以下屏幕截图中所做的是：
- en: '![Driving the ListView with Web API](img/4346OT_11_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用Web API驱动ListView](img/4346OT_11_12.jpg)'
- en: With Visual Studio set this way, the program will stop when an update is made
    and you can inspect the data to observe what is happening. For a production application,
    you would want to use the Entity Framework to edit the `movie` object and save
    the changes to the database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置Visual Studio后，程序将在更新时停止，你可以检查数据以观察正在发生的事情。对于生产应用程序，你希望使用Entity Framework来编辑`movie`对象并将更改保存到数据库中。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use the Web API for some more realistic
    scenarios involving two of the Kendo widgets that deal with managing data. We
    also quickly explored the ASP.NET Web API fundamentals as well as Entity Framework
    and OData. These tools, used together, can be a very powerful set and can create
    nearly any custom solution that you need.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Web API 来处理一些更现实的场景，这些场景涉及到管理数据的两个 Kendo 组件。我们还快速探讨了 ASP.NET
    Web API 的基础知识，以及 Entity Framework 和 OData。这些工具结合使用，可以是一个非常强大的组合，几乎可以创建您需要的任何自定义解决方案。
- en: The examples we just saw, both use a special attribute that Telerik has provided
    to help with model binding and server-side paging and filtering. It is nice to
    make use of special helpers like this when they are available. I encourage you
    to continue to explore these technologies on your own and see how you can create
    your own custom solutions on your own web pages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的示例，都使用了 Telerik 提供的一个特殊属性，以帮助进行模型绑定和服务器端分页和筛选。当这些特殊助手可用时，使用它们是非常方便的。我鼓励您继续自行探索这些技术，看看您如何在自己的网页上创建自己的自定义解决方案。
