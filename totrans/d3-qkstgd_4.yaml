- en: Making a Basic Scatter Plot Interactive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个基本的散点图交互
- en: 'In the last chapter, we created a static scatter plot. In this chapter, we''ll
    make it interactive so that we can add, update, and delete runs. You''ll learn
    how to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个静态散点图。在本章中，我们将使其交互式，以便我们可以添加、更新和删除运行。你将学习如何执行以下操作：
- en: Create a click handler
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个点击处理器
- en: Remove data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数据
- en: Drag an element
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动一个元素
- en: Update data after a drag
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动后的数据更新
- en: Create a zoom behavior that scales elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个缩放行为以缩放元素
- en: Update axes when zooming/panning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放/平移时更新坐标轴
- en: Update click points after a transform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新变换后的点击点
- en: Avoid redrawing the entire screen during rendering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在渲染过程中重绘整个屏幕
- en: Hide elements beyond axes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏轴以外的元素
- en: 'The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)[.](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完整的代码可以在以下位置找到：[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)[.](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)
- en: Creating a click handler
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个点击处理器
- en: 'Let''s say that we want it so that when the user clicks on the `<svg>` element,
    it creates a new run. Add the following to the bottom of `app.js`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让用户点击 `<svg>` 元素时创建一个新的运行。将以下内容添加到 `app.js` 的底部：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's examine what we just wrote. Note that `d3.select('svg').on('click', function(){`
    sets up a click handler on the `svg` element. The anonymous function that gets
    passed in as the second parameter to `.on()` gets called each time the user clicks
    on the SVG. Once inside that callback function, we use `d3.event.offsetX` to get
    the *x* position of the mouse inside the SVG, and we use `d3.event.offsetY` to
    get the *y* position. We then use `xScale.invert()` and `yScale.invert()` to turn
    the *x*/*y* visual points into data values (date and distance, respectively).
    We then use those data values to create a new run object. We create an ID for
    the new run by getting the ID of the last element in the `runs` array and adding
    1 to it. Lastly, we push the new run on to the `runs` array and call `createTable()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们刚才写的。注意，`d3.select('svg').on('click', function(){` 在 `svg` 元素上设置了一个点击处理器。传递给
    `.on()` 的第二个参数的匿名函数在用户每次点击 SVG 时都会被调用。一旦进入那个回调函数，我们使用 `d3.event.offsetX` 获取鼠标在
    SVG 内部的 *x* 位置，并使用 `d3.event.offsetY` 获取 *y* 位置。然后我们使用 `xScale.invert()` 和 `yScale.invert()`
    将 *x*/*y* 可视点转换为数据值（日期和距离，分别）。然后我们使用这些数据值创建一个新的运行对象。我们通过获取 `runs` 数组中最后一个元素的 ID
    并加 1 来创建新运行的 ID。最后，我们将新运行推送到 `runs` 数组并调用 `createTable()`。
- en: 'Click on the SVG to create a new run. You might notice that `createTable()`
    just adds on all the run rows again:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 SVG 创建一个新的运行。你可能注意到 `createTable()` 只是再次添加了所有运行行：
- en: '![](img/1d917d16-62ee-4495-a136-63e1fdb85d06.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d917d16-62ee-4495-a136-63e1fdb85d06.png)'
- en: 'Let''s alter the `createTable()` function so that when it runs, it clears out
    any rows previously created and re-renders everything. Add `d3.select(''tbody'').html('''')`
    to the top of the `createTable` function in `app.js`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `createTable()` 函数，使其在运行时清除之前创建的任何行并重新渲染一切。在 `app.js` 中的 `createTable`
    函数顶部添加 `d3.select('tbody').html('')`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now refresh the page and click on the SVG to create a new run. The table should
    then look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新页面并点击 SVG 创建一个新的运行。表格应该看起来像这样：
- en: '![](img/30c58628-df31-4979-a0d5-602398d939a9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30c58628-df31-4979-a0d5-602398d939a9.png)'
- en: 'The only issue now is that circles aren''t being created when you click on
    the SVG. To fix this, let''s wrap the code for creating `<circle>` elements in
    a render function, and call `render()` immediately after it''s defined:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一的问题是当你点击 SVG 时没有创建圆圈。为了解决这个问题，让我们将创建 `<circle>` 元素的代码包裹在一个渲染函数中，并在定义后立即调用
    `render()`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you refresh the browser, you''ll see an error in the console. This is because
    `bottomAxis` and `leftAxis` use `xScale` and `yScale` that are now scoped to exist
    only inside the `render()` function. For future use, let''s move `xScale` and
    `yScale` out of the render function along with the code for creating the domains/ranges:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新浏览器，你会在控制台看到一个错误。这是因为 `bottomAxis` 和 `leftAxis` 使用了现在仅限于 `render()` 函数内部的
    `xScale` 和 `yScale`。为了未来的使用，让我们将 `xScale` 和 `yScale` 以及创建域/范围的代码从渲染函数中移出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now go to the bottom of `app.js` and add a line to call `render()` inside our
    `<svg>` click handler:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到 `app.js` 的底部并添加一行调用 `<svg>` 点击处理器的 `render()`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now when you click the SVG, a circle will appear:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你点击 SVG 时，会出现一个圆圈：
- en: '![](img/54e21521-96d3-40be-901a-4b827b55c686.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54e21521-96d3-40be-901a-4b827b55c686.png)'
- en: Removing data
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'Let''s set up a click handler on all `<circle>` elements so that when the user
    clicks on `<circle>`, D3 will remove that circle and its associated data element
    from the array. Add the following code at the bottom of the `render` function
    declaration we wrote in the last section. We do this so that the click handlers
    are attached *after* the circles are created:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在所有 `<circle>` 元素上设置一个点击处理程序，以便当用户点击 `<circle>` 时，D3 将从数组中删除该圆圈及其相关数据元素。在上一节中我们编写的
    `render` 函数声明底部添加以下代码。我们这样做是为了确保点击处理程序在圆圈创建后附加：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s examine the previous code. The first line selects all `<circle>` elements
    and creates a click handler on each of them. However, `d3.event.stopPropagation();`
    prevents the click from bubbling up the DOM to the SVG. If we don''t add it, the
    click handler on the SVG will fire as well, when we click on a circle. This would
    create an additional run every time we try to remove a run. Next, we call the
    following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查之前的代码。第一行选择所有 `<circle>` 元素并为每个元素创建一个点击处理程序。然而，`d3.event.stopPropagation();`
    阻止点击事件向上冒泡到 SVG。如果我们不添加它，当我们在圆圈上点击时，SVG 上的点击处理程序也会触发。这会在我们尝试删除运行时创建额外的运行。接下来，我们调用以下代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This loops through the `runs` array and filters out any objects that have an
    `id` property that matches the `id` property of `datum` that is associated with
    `<circle>` that was clicked. Notice that the callback function in `.on(''click'',
    function(datum, index){` takes two parameters: `datum`, the run object associated
    with that `<circle>` , and the `index` of the run object in the `runs` array.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这会遍历 `runs` 数组，并过滤掉任何具有与点击的 `<circle>` 关联的 `datum` 的 `id` 属性匹配的 `id` 属性的对象。注意，`.on('click',
    function(datum, index){` 中的回调函数接受两个参数：`datum`，与该 `<circle>` 关联的运行对象，以及 `runs`
    数组中运行对象的 `index`。
- en: Once we've filtered out the correct run object from the `runs` array, we call
    `render()` and `createdTable()` to re-render the graph and the table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从 `runs` 数组中过滤出正确的运行对象，我们就调用 `render()` 和 `createdTable()` 来重新渲染图表和表格。
- en: 'But if we click on the middle circle and examine the **Elements** tab of the
    Developer Tools, we''ll see that the `<circle>` element hasn''t been removed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们点击中间的圆圈并检查开发者工具的 **元素** 选项卡，我们会看到 `<circle>` 元素没有被删除：
- en: '![](img/dcd904e5-f644-4f91-9cd4-c1c64c906205.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcd904e5-f644-4f91-9cd4-c1c64c906205.png)'
- en: Elements tab showing the <circle> element
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 <circle> 元素的元素选项卡
- en: In the previous screenshot, it appears as though there are only two circles,
    but really the middle one has had its `cx` set to 800 and its `cy` set to 0\.
    It's overlapping the other circle in the same position. This is because we've
    removed the second element in the `runs` array. When we re-render the graph, the
    `runs` array only has two objects; the second run object used to be the third
    run object before we removed the middle run. Now that it's the second run object,
    the second `<circle>` is assigned its data. The third circle still has its old
    data assigned to it, so both the second and the third circle have the same data
    and are therefore placed in the same location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，看起来只有两个圆圈，但实际上中间的那个圆圈的 `cx` 被设置为 800，`cy` 被设置为 0。它与相同位置的另一个圆圈重叠。这是因为我们已经从
    `runs` 数组中删除了第二个元素。当我们重新渲染图表时，`runs` 数组中只有两个对象；在删除中间运行之前，第二个运行对象原本是第三个运行对象。现在它是第二个运行对象，第二个
    `<circle>` 被分配了数据。第三个圆圈仍然保留了旧数据，因此第二个和第三个圆圈具有相同的数据，因此它们被放置在相同的位置。
- en: 'Let''s put the circles in `<g>` so that it''s easy to clear out all the circles
    and re-render them when we remove a run. This way we won''t have any extra `<circle>`
    elements lying around when we try to remove them. This approach is similar to
    what we do when re-rendering the table. Adjust your `<svg>` element in `index.html`
    so it looks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把圆圈放入 `<g>` 中，这样当我们删除一个运行时，就可以轻松清除所有圆圈并重新渲染它们。这样，当我们尝试删除它们时，就不会有任何额外的 `<circle>`
    元素散落在周围。这种方法与我们重新渲染表格时所做的类似。调整 `index.html` 中的 `<svg>` 元素，使其看起来如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can clear out the `<circle>` elements each time `render()` is called.
    This is a little crude, but it''ll work for now. Later on, we''ll do things in
    a more elegant fashion. At the top of the `render()` function declaration, add
    `d3.select(''#points'').html('''');` and adjust the next line from `d3.select(''svg'').selectAll(''circle'')`
    to `d3.select(''#points'').selectAll(''circle'')`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以每次调用 `render()` 时清除 `<circle>` 元素。这有点粗糙，但暂时可以工作。稍后，我们将以更优雅的方式处理。在 `render()`
    函数声明顶部添加 `d3.select('#points').html('');` 并将下一行从 `d3.select('svg').selectAll('circle')`
    调整为 `d3.select('#points').selectAll('circle')`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now if we click on the middle circle, the element is removed from the DOM:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您点击中间的圆圈，元素将从 DOM 中移除：
- en: '![](img/796556a5-98ca-42f8-9f2b-627515838e15.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/796556a5-98ca-42f8-9f2b-627515838e15.png)'
- en: Removing the element from the DOM
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DOM 中移除元素
- en: 'If you try to delete all the circles and then add a new one, you''ll get an
    error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试删除所有圆圈并添加一个新的圆圈，您将得到一个错误：
- en: '![](img/c51ac782-30af-4521-9ce7-1294f107a58f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c51ac782-30af-4521-9ce7-1294f107a58f.png)'
- en: Displaying the error you get when deleting all the circles and adding a new
    one
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显示删除所有圆圈并添加一个新圆圈时得到的错误
- en: 'This is because our code for creating `newRun` in the SVG click handler needs
    some work:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在 SVG 点击处理程序中创建 `newRun` 的代码需要一些修改：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is because when there are no run elements in the `runs` array, `runs[runs.length-1]`
    tries to access an element at index `-1` in the array. Inside the `<svg>` click
    handler, let''s put in a little code to handle when the user has deleted all runs
    and tries to add a new one:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当 `runs` 数组中没有运行元素时，`runs[runs.length-1]` 尝试访问数组中索引为 `-1` 的元素。在 `<svg>`
    点击处理程序内部，让我们添加一些代码来处理用户删除所有运行并尝试添加一个新运行的情况：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s what Chrome should look like now if you delete all the runs and then
    try to add a new one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您删除所有运行并尝试添加一个新的运行，Chrome 现在应该看起来是这样的：
- en: '![](img/b34ae165-9619-4176-9531-19be00a7791c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b34ae165-9619-4176-9531-19be00a7791c.png)'
- en: 'Lastly, let''s put in some CSS, so we know we''re clicking on a circle. First,
    add `transition: r 0.5s linear, fill 0.5s linear;` to the CSS code you''ve already
    written for `circle`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，让我们添加一些 CSS，以便我们知道我们在点击圆圈。首先，将 `transition: r 0.5s linear, fill 0.5s linear;`
    添加到您已经为 `circle` 编写的 CSS 代码中：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then add this to the bottom of `app.css`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此代码添加到 `app.css` 的底部：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s what a circle should look like when you hover over it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您悬停在圆圈上时，圆圈应该看起来是这样的：
- en: '![](img/53a034d3-e802-4b52-af58-a4f573e2cd92.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53a034d3-e802-4b52-af58-a4f573e2cd92.png)'
- en: Dragging an element
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动一个元素
- en: 'We want to be able to update the data for a run by dragging the associated
    circle. To do this, we''ll use a behavior, which you can think of as a combination
    of multiple event handlers. For a drag behavior, there are three callbacks:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够通过拖动相关的圆圈来更新一次运行的 数据。为此，我们将使用一个行为，您可以将其视为多个事件处理器的组合。对于拖动行为，有三个回调函数：
- en: When the user starts to drag
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户开始拖动时
- en: Each time the user moves the cursor before releasing the *mouse* button
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次用户在释放鼠标按钮之前移动光标时
- en: When the user releases the *mouse* button
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户释放 *鼠标* 按钮时
- en: 'There are two steps whenever we create a behavior:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个行为时，都有两个步骤：
- en: Create the behavior
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建行为
- en: Attach the behavior to one or more elements
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行为附加到一个或多个元素上
- en: 'Put the following code at the bottom of the `render()` function declaration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放在 `render()` 函数声明底部：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can now drag the circles around, but the data doesn''t update:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以拖动这些圆圈，但数据不会更新：
- en: '![](img/67b77321-bf8a-4288-9d15-d6a4c0b814d2.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67b77321-bf8a-4288-9d15-d6a4c0b814d2.png)'
- en: 'Let''s examine how this code works:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码是如何工作的：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `drag` function will be used as a callback anytime the user moves the cursor
    before releasing the mouse button. It gets the *x* and *y* coordinates of the
    mouse and sets the `cx` and `cy` values of the element being dragged (`d3.select(this)`)
    to those coordinates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `drag` 函数将在用户在释放鼠标按钮之前移动光标时作为回调函数使用。它获取鼠标的 *x* 和 *y* 坐标，并将被拖动元素（`d3.select(this)`）的
    `cx` 和 `cy` 值设置为这些坐标。
- en: 'Next, we generate a drag behavior that will, at the appropriate time, call
    the `drag` function that was just explained:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们生成一个拖动行为，在适当的时候调用刚才解释过的 `drag` 函数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we attach that behavior to all the `<circle>` elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这种行为附加到所有的 `<circle>` 元素上：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Updating data after a drag
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动后更新数据
- en: Now we're going to add functionality so that when the user releases the mouse
    button, the data for the run object associated with the circle being dragged gets
    updated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加功能，以便当用户释放鼠标按钮时，与被拖动的圆圈关联的运行对象的数据将得到更新。
- en: 'First, let''s create the callback function that will get called when the user
    releases the mouse button. Toward the bottom of the `render()` function declaration,
    add the following code just above `var drag = function(datum){`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个当用户释放鼠标按钮时将被调用的回调函数。在`render()`函数声明的底部，在`var drag = function(datum){`之上添加以下代码：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now attach that function to `dragBehavior` so that it is called when the user
    stops dragging a circle. Look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此函数附加到`dragBehavior`，以便在用户停止拖动圆圈时调用。查看以下代码：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change it to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, once you stop dragging a circle around, you should see the data in the
    table change:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你停止拖动圆圈，你应该看到表格中的数据发生变化：
- en: '![](img/fb91edec-c98c-4727-831c-cdbbe73901e7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb91edec-c98c-4727-831c-cdbbe73901e7.png)'
- en: 'Let''s change the color of a circle while it''s being dragged too. Add this
    to the bottom of `app.css`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在拖动圆圈的同时改变圆圈的颜色。将以下内容添加到`app.css`的底部：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you drag a circle, it should turn red.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拖动一个圆圈时，它应该变成红色。
- en: Creating a zoom behavior that scales elements
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个缩放行为以缩放元素
- en: 'Another behavior we can create is the zooming/panning ability. Once this functionality
    is complete, you will be able to zoom in and out on different parts of the graph
    by doing one of the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的另一种行为是缩放/平移能力。一旦这个功能完成，你将能够通过以下操作之一在不同的图形部分进行缩放和平移：
- en: A two-finger drag on a trackpad
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触摸板上进行两指拖动
- en: Rotating your mouse wheel
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动鼠标滚轮
- en: Pinching/spreading on a trackpad
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触摸板上进行捏合/展开操作
- en: You will also be able to pan left, right, up, and down on the graph by clicking
    and dragging on the SVG element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将能够通过在SVG元素上点击和拖动来在图表上左右、上下平移。
- en: 'Put the following code at the bottom of `app.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放在`app.js`的底部：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the callback function that will be called when the user attempts to
    zoom or pan. All it does is take the zoom or pan action and turn it into a `transform`
    attribute that gets applied to the `<g id="points"></g>` element that contains
    the circles. Now add the following code to the bottom of `app.js` to create the
    `zoom` behavior and attach it to the `svg` element:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当用户尝试缩放或平移时将被调用的回调函数。它所做的只是将缩放或平移操作转换为应用于包含圆圈的`<g id="points"></g>`元素的`transform`属性。现在将以下代码添加到`app.js`的底部以创建`zoom`行为并将其附加到`svg`元素：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if we zoom out, the graph should look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们缩放，图表应该看起来像这样：
- en: '![](img/4f8339f3-7079-4c6d-b9ca-34c4dd8cd3ee.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f8339f3-7079-4c6d-b9ca-34c4dd8cd3ee.png)'
- en: Updating axes when zooming and panning
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在缩放和平移时更新坐标轴
- en: 'Now when we zoom, the points move in/out. When we pan, they move vertically/horizontally.
    Unfortunately, the axes don''t update accordingly. Let''s first add IDs to the
    `<g>` elements that contain them. Find the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们缩放时，点移动到内部/外部。当我们平移时，它们垂直/水平移动。不幸的是，坐标轴没有相应更新。让我们首先为包含它们的`<g>`元素添加ID。找到以下代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add `.attr(''id'', ''x-axis'')` after the first `.append(''g'')`, and `.attr(''id'',
    ''y-axis'')` after the second `.append(''g'')`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`.append('g')`之后添加`.attr('id', 'x-axis')`，在第二个`.append('g')`之后添加`.attr('id',
    'y-axis')`：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s use those IDs to adjust the axes when we zoom. Find this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这些ID在缩放时调整坐标轴。找到以下代码：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following to the end of the function declaration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到函数声明的末尾：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now `zoomCallback` should look as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`zoomCallback`应该如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are two things to note about the previous code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码，有两点需要注意：
- en: '`bottomAxis.scale()` tells the axis to redraw itself.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottomAxis.scale()`告诉坐标轴重新绘制自己。'
- en: '`d3.event.transform.rescaleX(xScale)` returns a value indicating how the bottom
    axis should rescale.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.event.transform.rescaleX(xScale)`返回一个值，指示底部坐标轴应该如何缩放。'
- en: 'Now when you zoom out, the axes should redraw themselves:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你缩放时，坐标轴应该重新绘制：
- en: '![](img/417da05e-d963-41e8-8051-efaf8fb4776d.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/417da05e-d963-41e8-8051-efaf8fb4776d.png)'
- en: Updating click points after a transform
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换后更新点击点
- en: Try zooming and panning and then clicking on the SVG to create a new run. You'll
    notice it's in the wrong place. That's because the SVG click handler has no idea
    that a zoom or pan has happened. Currently, if you click on the visual point,
    no matter how much you may have zoomed or panned, the click handler still converts
    it as if you had never zoomed or panned.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试缩放和平移，然后点击SVG创建一个新的运行。你会注意到它位置不正确。这是因为SVG点击处理程序不知道发生了缩放或平移。目前，无论你缩放或平移多少，点击处理程序仍然将其转换为好像你从未缩放或平移过。
- en: 'When we zoom, we need to save the transformation information to a variable
    so that we can use it later to figure out how to properly create circles and runs.
    Find the `zoomCallback` declaration and add `var lastTransform = null` right before
    it. Then add `lastTransform = d3.event.transform;` to the beginning of the function
    declaration. It should look as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们缩放时，我们需要将变换信息保存到变量中，以便我们稍后可以使用它来确定如何正确创建圆圈和运行。找到 `zoomCallback` 声明，并在它之前添加
    `var lastTransform = null`。然后，在函数声明开始处添加 `lastTransform = d3.event.transform;`。它应该看起来如下：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now whenever the user zooms or pans the transformation data that was used to
    shrink or move the SVG and axes is saved in the `lastTransform` variable. Use
    that variable when clicking on the SVG.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当用户缩放或平移时，用于缩小或移动 SVG 和坐标轴的变换数据将保存在 `lastTransform` 变量中。在点击 SVG 时使用该变量。
- en: 'Find these two lines at the beginning of the SVG click handler:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SVG 点击处理器的开头找到这两行：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change them to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们更改为以下内容：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Your click handler should look like this now:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的点击处理器现在应该看起来像这样：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But now click before any zoom is broken, since `lastTransform` will be null:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在在缩放被破坏之前点击，因为 `lastTransform` 将为空：
- en: '![](img/52d68c60-c500-4915-b9be-520ce67590bc.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52d68c60-c500-4915-b9be-520ce67590bc.png)'
- en: 'Find the code that we just wrote for the SVG click handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 找到我们刚刚为 SVG 点击处理器编写的代码：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Adjust it so it looks as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调整它，使其看起来如下：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now initially, `x` and `y` are set to `d3.event.offsetX` and `d3.event.offsetY`,
    respectively. If a zoom or pan occurs, `lastTransform` will not be null, so we
    overwrite `x` and `y` with the transformed values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`x` 和 `y` 分别被设置为 `d3.event.offsetX` 和 `d3.event.offsetY`。如果发生缩放或平移，`lastTransform`
    将不会为空，因此我们将使用变换后的值覆盖 `x` 和 `y`。
- en: 'Add a new run initially:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时添加一个新的运行：
- en: '![](img/f608ba1d-85ba-43c6-9a9e-76b30938368e.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f608ba1d-85ba-43c6-9a9e-76b30938368e.png)'
- en: 'Now pan right and add a new point:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向右平移并添加一个新的点：
- en: '![](img/d3a91e10-aed0-4c4e-b258-2cd9482d7f41.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3a91e10-aed0-4c4e-b258-2cd9482d7f41.png)'
- en: Avoiding redrawing the entire screen during rendering
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在渲染过程中重新绘制整个屏幕
- en: At the moment, every time we call `render()`, we wipe all `<circle>` elements
    from `<svg>`. This is inefficient. Let's just remove the ones we don't want
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每次我们调用 `render()` 时，我们都会从 `<svg>` 中擦除所有 `<circle>` 元素。这是低效的。我们只需移除我们不需要的元素
- en: 'At the top of the `render()` function, assign `d3.select(''#points'').selectAll(''circle'').data(runs)`
    to a variable, so we can use it later. This helps preserve how DOM elements are
    assigned to data elements in the next sections. Find this at the top of the `render()`
    function declaration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render()` 函数的顶部，将 `d3.select('#points').selectAll('circle').data(runs)` 赋值给一个变量，这样我们就可以稍后使用它。这有助于保留在下一节中
    DOM 元素如何分配给数据元素。在 `render()` 函数声明顶部找到它：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Change it to this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, remove the `d3.select(''#points'').html('''');` line. We''ll use `.exit()`
    to find the selection of circles that haven''t been matched with data, and then
    we''ll use `.remove()` to remove those circles. Add the following after the last
    line we just wrote (`circles.enter().append(''circle'');`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，删除 `d3.select(''#points'').html('''');` 这一行。我们将使用 `.exit()` 来找到尚未与数据匹配的圆圈选择，然后我们将使用
    `.remove()` 来移除这些圆圈。在我们刚刚写的最后一行之后添加以下内容 (`circles.enter().append(''circle'');`):'
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reload the page, click on the center (second) circle. You'll notice it looks
    as if the circle disappears, and the circle in the upper-right briefly gains a
    hover state and then shrinks back down. That's not really what's happening.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面，点击中心（第二个）圆圈。你会注意到圆圈似乎消失了，右上角的圆圈短暂地获得悬停状态然后又缩小。这并不是真正发生的事情。
- en: 'If we click on the middle circle (second), it deletes the second run object
    in the `runs` array, and the third run object moves down to replace it in second
    place. We now only have an array of two run objects: the first and what used to
    be the third (but is now the second). When `render()` gets called again, what
    was the middle (second) circle gets assigned to what used to be the third run
    object in the `runs` array (but is now the second). This "run" object used to
    be assigned to the third circle, which was in the upper right. But now, since
    there are only two runs, that third (upper-right) circle gets deleted when we
    call `circles.exit().remove();`. The second circle''s data has changed now, and
    it jumps to the upper–right corner to match that data. It used to have a hover
    state, but all of a sudden it''s moved out from under the cursor, so it shrinks
    back down to normal size and becomes black.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击中间的圆圈（第二个），它将删除 `runs` 数组中的第二个运行对象，第三个运行对象将向下移动以替换它。现在我们只有一个包含两个运行对象的数组：第一个和原本是第三个（但现在变成了第二个）。当再次调用
    `render()` 时，原本的中间（第二个）圆圈被分配给原本是 `runs` 数组中的第三个运行对象（但现在变成了第二个）。这个“运行”对象原本被分配给右上角的第三个圆圈。但现在，由于只有两个运行对象，当我们调用
    `circles.exit().remove();` 时，第三个（右上角）圆圈将被删除。第二个圆圈的数据已经改变，它跳到右上角以匹配该数据。它原本有一个悬停状态，但突然它从光标下移开，因此它缩小回正常大小并变成黑色。
- en: 'To avoid these effects, we need to make sure that each circle stays with the
    data it used to be assigned to when we call `render()`. To do this, we can tell
    D3 to map `<circles>` to datum by ID, rather than index, in the array. At the
    top of the `render()` function, find this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些影响，我们需要确保在调用 `render()` 时，每个圆圈都保持与它最初分配到的数据一致。为此，我们可以告诉 D3 通过 ID 而不是索引将
    `<circles>` 映射到数据项。在 `render()` 函数的顶部，找到以下代码：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change it to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 改为如下所示：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This tells D3 to use the `id` property of each run object when determining which
    `<circle>` element to assign the data object to. It basically assigns that `id`
    property of the run object to the `<circle>` element initially. That way, when
    the second run object is deleted, `circles.exit().remove();` will find the circle
    that had the corresponding ID (the middle circle) and remove it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 D3 在确定将数据对象分配给哪个 `<circle>` 元素时使用每个运行对象的 `id` 属性。它基本上是将运行对象的 `id` 属性最初分配给
    `<circle>` 元素。这样，当第二个运行对象被删除时，`circles.exit().remove();` 将找到具有相应 ID（中间的圆圈）的圆圈并将其删除。
- en: Now clicking on the middle circle should work correctly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击中间的圆圈应该可以正常工作。
- en: Hiding elements beyond an axis
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏超出轴的元素
- en: 'If you pan or zoom extensively, you''ll notice that the circles are visible
    beyond the bounds of the axes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行大量的平移或缩放，你会注意到圆圈在轴的范围之外可见：
- en: '![](img/7e7f4115-4706-447c-81ef-108d3f6384f6.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e7f4115-4706-447c-81ef-108d3f6384f6.png)'
- en: 'To hide elements once they get beyond an axis, we can just add an outer SVG
    with `id="container"` around our current `<svg>` element in `index.html`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏超出轴的元素，我们只需在 `index.html` 中的当前 `<svg>` 元素周围添加一个带有 `id="container"` 的外部 SVG：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now replace all `d3.select(''svg'')` code with `d3.select(''#container'')`.
    You can perform a find-and-replace. There should be five instances to change:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有 `d3.select('svg')` 代码替换为 `d3.select('#container')`。你可以进行查找和替换。应该有五个实例需要更改：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And, lastly, adjust CSS to replace `svg {` with `#container {`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调整 CSS 以将 `svg {` 替换为 `#container {`：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now circles should be hidden once they move beyond the bounds of the inner
    `<svg>` element:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦圆圈移动到内 `<svg>` 元素的范围之外，它们应该被隐藏：
- en: '![](img/dcd8d68a-e9c3-46e7-b424-3112e3fa41cc.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcd8d68a-e9c3-46e7-b424-3112e3fa41cc.png)'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned the basics of D3 and have created a fully interactive
    scatter plot. In the next chapter, we'll learn how to use AJAX to make an asynchronous
    request that will populate a bar graph.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 D3 的基础知识，并创建了一个完全交互式的散点图。在下一章中，我们将学习如何使用 AJAX 发出异步请求以填充条形图。
