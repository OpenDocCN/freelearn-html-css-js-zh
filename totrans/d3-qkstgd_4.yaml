- en: Making a Basic Scatter Plot Interactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we created a static scatter plot. In this chapter, we''ll
    make it interactive so that we can add, update, and delete runs. You''ll learn
    how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a click handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update data after a drag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a zoom behavior that scales elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update axes when zooming/panning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update click points after a transform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid redrawing the entire screen during rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide elements beyond axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)[.](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a click handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we want it so that when the user clicks on the `<svg>` element,
    it creates a new run. Add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine what we just wrote. Note that `d3.select('svg').on('click', function(){`
    sets up a click handler on the `svg` element. The anonymous function that gets
    passed in as the second parameter to `.on()` gets called each time the user clicks
    on the SVG. Once inside that callback function, we use `d3.event.offsetX` to get
    the *x* position of the mouse inside the SVG, and we use `d3.event.offsetY` to
    get the *y* position. We then use `xScale.invert()` and `yScale.invert()` to turn
    the *x*/*y* visual points into data values (date and distance, respectively).
    We then use those data values to create a new run object. We create an ID for
    the new run by getting the ID of the last element in the `runs` array and adding
    1 to it. Lastly, we push the new run on to the `runs` array and call `createTable()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the SVG to create a new run. You might notice that `createTable()`
    just adds on all the run rows again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d917d16-62ee-4495-a136-63e1fdb85d06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s alter the `createTable()` function so that when it runs, it clears out
    any rows previously created and re-renders everything. Add `d3.select(''tbody'').html('''')`
    to the top of the `createTable` function in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now refresh the page and click on the SVG to create a new run. The table should
    then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30c58628-df31-4979-a0d5-602398d939a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only issue now is that circles aren''t being created when you click on
    the SVG. To fix this, let''s wrap the code for creating `<circle>` elements in
    a render function, and call `render()` immediately after it''s defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the browser, you''ll see an error in the console. This is because
    `bottomAxis` and `leftAxis` use `xScale` and `yScale` that are now scoped to exist
    only inside the `render()` function. For future use, let''s move `xScale` and
    `yScale` out of the render function along with the code for creating the domains/ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to the bottom of `app.js` and add a line to call `render()` inside our
    `<svg>` click handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you click the SVG, a circle will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e21521-96d3-40be-901a-4b827b55c686.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up a click handler on all `<circle>` elements so that when the user
    clicks on `<circle>`, D3 will remove that circle and its associated data element
    from the array. Add the following code at the bottom of the `render` function
    declaration we wrote in the last section. We do this so that the click handlers
    are attached *after* the circles are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the previous code. The first line selects all `<circle>` elements
    and creates a click handler on each of them. However, `d3.event.stopPropagation();`
    prevents the click from bubbling up the DOM to the SVG. If we don''t add it, the
    click handler on the SVG will fire as well, when we click on a circle. This would
    create an additional run every time we try to remove a run. Next, we call the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This loops through the `runs` array and filters out any objects that have an
    `id` property that matches the `id` property of `datum` that is associated with
    `<circle>` that was clicked. Notice that the callback function in `.on(''click'',
    function(datum, index){` takes two parameters: `datum`, the run object associated
    with that `<circle>` , and the `index` of the run object in the `runs` array.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we've filtered out the correct run object from the `runs` array, we call
    `render()` and `createdTable()` to re-render the graph and the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we click on the middle circle and examine the **Elements** tab of the
    Developer Tools, we''ll see that the `<circle>` element hasn''t been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd904e5-f644-4f91-9cd4-c1c64c906205.png)'
  prefs: []
  type: TYPE_IMG
- en: Elements tab showing the <circle> element
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, it appears as though there are only two circles,
    but really the middle one has had its `cx` set to 800 and its `cy` set to 0\.
    It's overlapping the other circle in the same position. This is because we've
    removed the second element in the `runs` array. When we re-render the graph, the
    `runs` array only has two objects; the second run object used to be the third
    run object before we removed the middle run. Now that it's the second run object,
    the second `<circle>` is assigned its data. The third circle still has its old
    data assigned to it, so both the second and the third circle have the same data
    and are therefore placed in the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the circles in `<g>` so that it''s easy to clear out all the circles
    and re-render them when we remove a run. This way we won''t have any extra `<circle>`
    elements lying around when we try to remove them. This approach is similar to
    what we do when re-rendering the table. Adjust your `<svg>` element in `index.html`
    so it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can clear out the `<circle>` elements each time `render()` is called.
    This is a little crude, but it''ll work for now. Later on, we''ll do things in
    a more elegant fashion. At the top of the `render()` function declaration, add
    `d3.select(''#points'').html('''');` and adjust the next line from `d3.select(''svg'').selectAll(''circle'')`
    to `d3.select(''#points'').selectAll(''circle'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we click on the middle circle, the element is removed from the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/796556a5-98ca-42f8-9f2b-627515838e15.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the element from the DOM
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to delete all the circles and then add a new one, you''ll get an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c51ac782-30af-4521-9ce7-1294f107a58f.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the error you get when deleting all the circles and adding a new
    one
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because our code for creating `newRun` in the SVG click handler needs
    some work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because when there are no run elements in the `runs` array, `runs[runs.length-1]`
    tries to access an element at index `-1` in the array. Inside the `<svg>` click
    handler, let''s put in a little code to handle when the user has deleted all runs
    and tries to add a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what Chrome should look like now if you delete all the runs and then
    try to add a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b34ae165-9619-4176-9531-19be00a7791c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, let''s put in some CSS, so we know we''re clicking on a circle. First,
    add `transition: r 0.5s linear, fill 0.5s linear;` to the CSS code you''ve already
    written for `circle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add this to the bottom of `app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what a circle should look like when you hover over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53a034d3-e802-4b52-af58-a4f573e2cd92.png)'
  prefs: []
  type: TYPE_IMG
- en: Dragging an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to update the data for a run by dragging the associated
    circle. To do this, we''ll use a behavior, which you can think of as a combination
    of multiple event handlers. For a drag behavior, there are three callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user starts to drag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time the user moves the cursor before releasing the *mouse* button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user releases the *mouse* button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two steps whenever we create a behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the behavior
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the behavior to one or more elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code at the bottom of the `render()` function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now drag the circles around, but the data doesn''t update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67b77321-bf8a-4288-9d15-d6a4c0b814d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine how this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This `drag` function will be used as a callback anytime the user moves the cursor
    before releasing the mouse button. It gets the *x* and *y* coordinates of the
    mouse and sets the `cx` and `cy` values of the element being dragged (`d3.select(this)`)
    to those coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we generate a drag behavior that will, at the appropriate time, call
    the `drag` function that was just explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we attach that behavior to all the `<circle>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Updating data after a drag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're going to add functionality so that when the user releases the mouse
    button, the data for the run object associated with the circle being dragged gets
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the callback function that will get called when the user
    releases the mouse button. Toward the bottom of the `render()` function declaration,
    add the following code just above `var drag = function(datum){`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now attach that function to `dragBehavior` so that it is called when the user
    stops dragging a circle. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once you stop dragging a circle around, you should see the data in the
    table change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb91edec-c98c-4727-831c-cdbbe73901e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the color of a circle while it''s being dragged too. Add this
    to the bottom of `app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you drag a circle, it should turn red.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a zoom behavior that scales elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another behavior we can create is the zooming/panning ability. Once this functionality
    is complete, you will be able to zoom in and out on different parts of the graph
    by doing one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A two-finger drag on a trackpad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating your mouse wheel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinching/spreading on a trackpad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also be able to pan left, right, up, and down on the graph by clicking
    and dragging on the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following code at the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the callback function that will be called when the user attempts to
    zoom or pan. All it does is take the zoom or pan action and turn it into a `transform`
    attribute that gets applied to the `<g id="points"></g>` element that contains
    the circles. Now add the following code to the bottom of `app.js` to create the
    `zoom` behavior and attach it to the `svg` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we zoom out, the graph should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f8339f3-7079-4c6d-b9ca-34c4dd8cd3ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating axes when zooming and panning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now when we zoom, the points move in/out. When we pan, they move vertically/horizontally.
    Unfortunately, the axes don''t update accordingly. Let''s first add IDs to the
    `<g>` elements that contain them. Find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `.attr(''id'', ''x-axis'')` after the first `.append(''g'')`, and `.attr(''id'',
    ''y-axis'')` after the second `.append(''g'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use those IDs to adjust the axes when we zoom. Find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the end of the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `zoomCallback` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to note about the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bottomAxis.scale()` tells the axis to redraw itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.event.transform.rescaleX(xScale)` returns a value indicating how the bottom
    axis should rescale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now when you zoom out, the axes should redraw themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/417da05e-d963-41e8-8051-efaf8fb4776d.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating click points after a transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try zooming and panning and then clicking on the SVG to create a new run. You'll
    notice it's in the wrong place. That's because the SVG click handler has no idea
    that a zoom or pan has happened. Currently, if you click on the visual point,
    no matter how much you may have zoomed or panned, the click handler still converts
    it as if you had never zoomed or panned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we zoom, we need to save the transformation information to a variable
    so that we can use it later to figure out how to properly create circles and runs.
    Find the `zoomCallback` declaration and add `var lastTransform = null` right before
    it. Then add `lastTransform = d3.event.transform;` to the beginning of the function
    declaration. It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the user zooms or pans the transformation data that was used to
    shrink or move the SVG and axes is saved in the `lastTransform` variable. Use
    that variable when clicking on the SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find these two lines at the beginning of the SVG click handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Change them to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Your click handler should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But now click before any zoom is broken, since `lastTransform` will be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52d68c60-c500-4915-b9be-520ce67590bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the code that we just wrote for the SVG click handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust it so it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now initially, `x` and `y` are set to `d3.event.offsetX` and `d3.event.offsetY`,
    respectively. If a zoom or pan occurs, `lastTransform` will not be null, so we
    overwrite `x` and `y` with the transformed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new run initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f608ba1d-85ba-43c6-9a9e-76b30938368e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now pan right and add a new point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3a91e10-aed0-4c4e-b258-2cd9482d7f41.png)'
  prefs: []
  type: TYPE_IMG
- en: Avoiding redrawing the entire screen during rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, every time we call `render()`, we wipe all `<circle>` elements
    from `<svg>`. This is inefficient. Let's just remove the ones we don't want
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `render()` function, assign `d3.select(''#points'').selectAll(''circle'').data(runs)`
    to a variable, so we can use it later. This helps preserve how DOM elements are
    assigned to data elements in the next sections. Find this at the top of the `render()`
    function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the `d3.select(''#points'').html('''');` line. We''ll use `.exit()`
    to find the selection of circles that haven''t been matched with data, and then
    we''ll use `.remove()` to remove those circles. Add the following after the last
    line we just wrote (`circles.enter().append(''circle'');`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reload the page, click on the center (second) circle. You'll notice it looks
    as if the circle disappears, and the circle in the upper-right briefly gains a
    hover state and then shrinks back down. That's not really what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the middle circle (second), it deletes the second run object
    in the `runs` array, and the third run object moves down to replace it in second
    place. We now only have an array of two run objects: the first and what used to
    be the third (but is now the second). When `render()` gets called again, what
    was the middle (second) circle gets assigned to what used to be the third run
    object in the `runs` array (but is now the second). This "run" object used to
    be assigned to the third circle, which was in the upper right. But now, since
    there are only two runs, that third (upper-right) circle gets deleted when we
    call `circles.exit().remove();`. The second circle''s data has changed now, and
    it jumps to the upper–right corner to match that data. It used to have a hover
    state, but all of a sudden it''s moved out from under the cursor, so it shrinks
    back down to normal size and becomes black.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid these effects, we need to make sure that each circle stays with the
    data it used to be assigned to when we call `render()`. To do this, we can tell
    D3 to map `<circles>` to datum by ID, rather than index, in the array. At the
    top of the `render()` function, find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This tells D3 to use the `id` property of each run object when determining which
    `<circle>` element to assign the data object to. It basically assigns that `id`
    property of the run object to the `<circle>` element initially. That way, when
    the second run object is deleted, `circles.exit().remove();` will find the circle
    that had the corresponding ID (the middle circle) and remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Now clicking on the middle circle should work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding elements beyond an axis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you pan or zoom extensively, you''ll notice that the circles are visible
    beyond the bounds of the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e7f4115-4706-447c-81ef-108d3f6384f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To hide elements once they get beyond an axis, we can just add an outer SVG
    with `id="container"` around our current `<svg>` element in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now replace all `d3.select(''svg'')` code with `d3.select(''#container'')`.
    You can perform a find-and-replace. There should be five instances to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And, lastly, adjust CSS to replace `svg {` with `#container {`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now circles should be hidden once they move beyond the bounds of the inner
    `<svg>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd8d68a-e9c3-46e7-b424-3112e3fa41cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned the basics of D3 and have created a fully interactive
    scatter plot. In the next chapter, we'll learn how to use AJAX to make an asynchronous
    request that will populate a bar graph.
  prefs: []
  type: TYPE_NORMAL
