- en: Chapter 6. Combining UI Widgets into the Perfect Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layouts are fundamental to the appearance and usability of your application.
    UI widgets can be combined, and arranged, in any number of different configurations
    to create simple and complex application layouts.
  prefs: []
  type: TYPE_NORMAL
- en: An Ext JS widget requires a layout to manage its sizing and positioning on the
    screen. The framework has a large number of different layouts, which provide simple
    configurations and flexibility to produce applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the most common topics relating to layouts. These are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How components fit together in layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples and explanations of working with the most common layouts, namely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The border layout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fit layout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HBox and VBox layouts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design layouts that are responsive to the user's screen size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts and how they work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ext JS, containers have layouts that manage the sizing and positioning of
    their child components. Traditionally, a developer would apply a combination of
    CSS rules to the elements in the DOM to build the desired screen layout. Ext JS
    takes care of most of this for us, by allowing us to define a layout configuration
    in our container/component and configure the sizing and positioning with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a container is configured with an Auto layout, which makes child
    components flow naturally at full width in much the same way DIVs do in a regular
    HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a list of layouts that are provided by the framework. It is
    possible, and common, to combine a number of layouts together; this is so that
    child containers or components are positioned and sized appropriately. For example,
    a tab panel (card layout) has multiple child containers, of which each may have
    different layouts. Each of these layouts has different configuration options to
    control how your app renders. By default, the Ext JS UI widgets have component
    layouts configured, which you may need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute**: Using *X* and *Y* coordinates, the absolute layout fixes the
    position of the container on screen. Overlapping is possible with this layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accordion**: The accordion layout provides the ability to create an accordion
    stack of panels on screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anchor**: This is a layout that enables anchoring of contained elements relative
    to the container''s dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Border**: The border layout enables you to attach containers to the border
    of a central region giving you a north, south, east, and west region. This layout
    has built-in behavior for collapsing and resizing regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Card**: A card layout provides a stack of containers that can be moved back
    and forth. A card layout is ideal for a wizard-style component or tabbed components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Center**: The contents of a center layout are centered within their container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column**: A column layout is ideal for presenting your interface in multiple
    columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fit**: A very common layout, the fit layout stretches the widget to the size
    and position of the parent container. You can only have one item in a fit layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HBox**: Much like the column layout, this layout presents components horizontally.
    It has some useful configurations to stretch and position child components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VBox**: Much like the HBox layout, this layout presents components vertically,
    one below the other. It has some useful configurations to stretch and position
    child components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table**: While tables are less popular with developers, a table layout can
    still be useful. The content in a table layout will be rendered as an HTML table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the layout system works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, it's the layout that's responsible for the sizing and positioning
    of your container's children. Correctly rendering the screen requires that all
    child components have their sizes and positions calculated so that the DOM can
    be updated. The framework does this with the `updateLayout` method. This method
    recurses fully through all child components and calculates the appropriate positions
    and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those familiar with previous versions of the framework, the `updateLayout`
    method replaced the `doLayout` method in Ext JS 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: The framework automatically takes care of sizing and positioning by calling
    the `updateLayout` method. For example, when the browser window is adjusted or
    resized, or you add or remove components, the framework will do the necessary
    calculations to ensure your components appear correctly on screen.
  prefs: []
  type: TYPE_NORMAL
- en: There are some circumstances when it is beneficial to call the `updateLayout`
    manually. Laying out components can be a resource-intensive task, and if you know
    you are going to make a number of updates to components, then it may be worth
    thinking about batching the layout into one. For instance, adding three components
    one after another would trigger three calls to `updateLayout` (which recurses
    through all child components). By using a `suspendLayout` flag, we can prevent
    our application from updating the DOM until we're ready. When we are ready, it's
    a simple case of switching the `suspendLayout` flag off by setting it to false
    and then manually calling the `updateLayout` method of the container.
  prefs: []
  type: TYPE_NORMAL
- en: The component layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A component also has a layout which defines how it sizes and positions its internal
    child items. Component layouts are configured using the `componentLayout` config
    option.
  prefs: []
  type: TYPE_NORMAL
- en: In most circumstances, you will not require the `componentLayout` configuration,
    unless you plan on writing custom components that have complex layout requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using the border layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are looking to create a desktop style experience with your user interface,
    then the border layout is for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the border layout](img/3717_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The border layout is an application-oriented layout, supporting multiple nested
    panels, the ability to collapse regions by clicking on the regions' header or
    collapse icon, and the resizing of regions by clicking and dragging the splitter
    bar between them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the building blocks of our BizDash application will be a Viewport with
    a border layout. Here, we will learn how to create a simple border layout using
    the maximum number of regions configurable (north, south, east, west, and center).
    The west and east regions will be collapsible, with the east region loading pre-collapsed.
    Resizing will be demonstrated in the south and west regions. These four borders
    will surround the center region, which regardless of your configuration, is required
    for a border layout to work.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the Viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Viewport renders itself to the document's body and automatically consumes
    the viewable area. It represents the entire viewable browser area and automatically
    uses 100 percent of the browser window's width and height (minus address bars,
    developer tools, and so on, of course). Our Viewport will have a border layout
    to manage the size and positioning of its child containers.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we set the `autoCreateViewport` property in `app.js` to
    `BizDash.view.main.Main`. This automatically sets our main view container to a
    Viewport for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the border layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our main view takes the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The border layout, as the name suggests, creates a layout of components that
    border a central component. Therefore, a requirement of the border layout is that
    one item must be specified as the center.
  prefs: []
  type: TYPE_NORMAL
- en: The center region, which you must include for a border layout to work, automatically
    expands to consume the empty space left over from the other regions in your layout.
    It does this by having a pre-defined flex value of `1` for both height and width.
  prefs: []
  type: TYPE_NORMAL
- en: The north and south regions take a height or flex configuration. In our app,
    the north region has a fixed height of 100 px and the south region has a flex
    of 3\. The south and center regions' heights are calculated based on the height
    remaining in the browser window. Here, the height of the south region is just
    under a third of the height of the center. The west and east regions, instead,
    take a width or flex configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add further functionality with `collapsed`, `collapsible`, `split`, and
    `titleCollapse` specified in the desired regions'' configuration. They do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collapsed`: If set to `true`, it means the region will start collapsed (the
    regions need to be `Ext.panel.Panel` to be collapsible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collapsible`: If set to `true`, it allows the user to expand/collapse the
    panel by clicking on the toggle tool that''s added to the header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`titleCollapse`: If set to `true`, it makes the panel collapse no matter where
    the user clicks on the panel''s header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split`: If set to `true`, it makes the region resizable by allowing the users
    to click and drag the dividing bar between regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the fit layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fit layout in Ext JS is ideal if you want a container to expand a component
    to fill its parent. The fit layout is easy to use and requires no configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `main` class has a border layout, but the south region requires a fit layout
    for its child panel.
  prefs: []
  type: TYPE_NORMAL
- en: The fit layout works by defining the `layout` config option as `fit` in the
    parent container. This tells Ext JS that the child item should expand to fill
    the entire space available from its parent.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that the fit layout will only work for the first child item
    of the parent container. If you have multiple items defined, the first will be
    displayed (as it will expand into the remaining space of its parent) and the others
    will not be visible.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HBox layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HBox layout allows you to align components horizontally across a container
    in a manner similar to a column layout. However, it's a bit more advanced, as
    it lets you configure additional properties, such as the height of the columns
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the HBox layout](img/3717_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create an overview widget with three columns to show events, messages,
    and notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining an HBox layout ensures that Ext JS horizontally positions each child
    item giving the appearance of columns in our dashboard application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have configured `stretchmax` on the `align` config option, meaning that
    all child items will automatically be stretched to the height of the tallest child.
    The `align` config option controls how child items are vertically aligned in an
    HBox layout. Valid values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin`: This is the default value. All items in the HBox layout will be vertically
    aligned to the top of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middle`: All items will be vertically aligned to the middle (or center) of
    the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch`: Each item will be vertically stretched to fit the height of the
    container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretchmax`: This vertically stretches all items to the height of the largest
    item, creating a uniform look without having to individually define a height for
    each item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VBox layout has a very similar config to this layout, but the options are
    slightly different, as they are designed to control the horizontal alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'By defining a height of 200 and configuring `align: ''stretchmax''`, all other
    panels will have their height stretched to 200 px.'
  prefs: []
  type: TYPE_NORMAL
- en: Widths in HBox layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HBoxes can have their width defined in two different ways: fixed widths and
    flex widths.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Child containers can have their width fixed by defining a width configuration
    in the object. Containers with a fixed width will retain their width dimensions,
    even when the browser window is resized. Therefore, they are not fluid.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you require your layout to be more responsive to the resizing of
    windows and so on, then it's a `flex` config that's required.
  prefs: []
  type: TYPE_NORMAL
- en: Flex width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flex` config option relatively flexes the child items horizontally in
    their parent containers. For example, take a container with flex: 1 and one with
    flex: 3\. In these cases, 25 percent of the remaining parent space is given to
    the first container and 75 percent of the space is given to the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flex values are calculated in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Packing items together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful config option for the HBox layout is `pack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pack` config option controls how the child items are packed together.
    If the items do not stretch to the full width of the parent container, it''s possible
    to align them to the left, middle, or right using this option. Valid values are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: This is the default value. It aligns all items to the left of the
    parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`: This aligns all items to the middle of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: It aligns all items to the right of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VBox layout contains the same `pack` config, but it is designed to configure
    the packing of child items vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Using the VBox layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VBox layout is very similar to the HBox layout. The only difference is that
    VBox allows you to align components vertically in a container. Just like the HBox
    layout, this layout is configured by setting fixed widths for its children using
    the `width` config, or by calculating the width automatically with the `flex`
    config.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the VBox layout](img/3717_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alignment and packing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The VBox layout has some useful configuration options that are described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'align: String'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `align` config option controls how child items are horizontally aligned
    in a VBox layout. Valid values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin`: This is the default value. All items in the VBox layout are horizontally
    aligned to the left of the container and use their `width` config to define how
    wide they are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middle`: All items are horizontally aligned to the middle (or center) of the
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch`: Each item is horizontally stretched to fit the width of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretchmax`: This horizontally stretches all items to the width of the largest
    item, creating a uniform look without having to individually define a width for
    each item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pack: String'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pack` config option controls how the child items are packed together.
    If the items do not stretch to the full height of the parent container (that is,
    have no flex values), it''s possible to align them to the top, middle, or bottom
    using this option. Valid values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: This is the default value. It aligns all items to the top of the parent
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`: This aligns all items to the middle (or center) of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: This aligns all items to the bottom of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Long gone are the days when web browsers were only found in desktop PCs and
    laptops. Nowadays, they can be found in an ever-increasing range of hardware,
    such as phones, tablets, TVs, and cars, to name a few. Since the release of the
    iPhone in 2007, a new type of web, the mobile web, has grown in popularity, and
    the expectations of users have changed. Users expect to access a web application
    and have fantastic experience, no matter how large or small their screen is.
  prefs: []
  type: TYPE_NORMAL
- en: Until the advent of Ext JS 5, it was difficult to cater to the differing needs
    of users. Ext JS 5 has, however, adopted the popular move towards responsive design,
    giving developers a practical way of adapting the app layout, depending on the
    size and resolution of the screen presenting it.
  prefs: []
  type: TYPE_NORMAL
- en: Ext.mixin.Responsive and Ext.plugin.Responsive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a new responsive mixin and plugin that adds a `responsiveConfig` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our border layout, we want to alter how the regions are presented, based
    on the screen orientation. Adding the `responsiveConfig` with the following *rules*
    to the main view tells the application to add the navigation panel to the north
    or west region based on the orientation of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `responsiveConfig` has two rules defined: one for landscape
    and another for portrait. When the application satisfies the rule, the config
    defined in the object of that rule will be applied to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for example, our screen orientation is landscape, then the framework will
    apply `region: ''west''` to the panel. This is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ResponsiveConfig rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must define rules that contain a condition, or multiple conditions, based
    on which the rules will be applied. These rules can be any valid JavaScript expression,
    but the following values are considered in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '`landscape`: This returns true when the orientation is landscape or on a desktop
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`portrait`: This returns true when the orientation is portrait but is always
    false on desktop devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tall`: This returns true if the height is greater than the width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wide`: This returns true if the width is greater than the height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This defines the width of the Viewport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This defines the height of the Viewport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width and height are particularly useful, as these give us a way to define
    our own values in a way similar to breakpoints in media queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create a rule that will be applied when
    a portrait device is less than 400 pixels wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have explored in detail how to define the layout
    of our components on screen using Ext JS. We have covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How the layout manager works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of layouts available to us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of how to use the border, fit and HBox/VBox layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a responsive layout to cope with different screen sizes and device
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will make use of all of these lessons throughout the rest of the book, as
    our example application comes to life and we start to integrate our widgets into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will demonstrate how to create common UI widgets for
    our sample application. These widgets will make use of some of the layouts we
    have seen in this chapter.
  prefs: []
  type: TYPE_NORMAL
