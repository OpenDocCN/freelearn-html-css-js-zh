- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Form Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I demonstrate the ways that Node.js applications can receive
    form data and explain the differences, including supporting uploading files. This
    chapter also explains how to sanitize form data so that it can be safely included
    in HTML documents, and how to validate data before it is used. *Table 11.1* puts
    this chapter in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.1: Putting HTML forms in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | HTML forms allow users to provide data by entering values
    into form fields. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Forms are the only ways in which data values can be
    collected from users in a structured way. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | HTML documents contain a `form` element that contains
    one or more elements that allow data to be entered, such as an `input` element.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | The data that’s entered into a form
    must be sanitized before inclusion in HTML output and validated before it is used
    by the applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Forms are the only way to efficiently solicit
    data from users. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 11.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Receive data from the user. | Use an HTML form configured to send data to
    the server. | *1-10* |'
  prefs: []
  type: TYPE_TB
- en: '| Receive data used for non-idempotent operations. | Configure the form to
    use HTTP `POST` requests. | *11, 12* |'
  prefs: []
  type: TYPE_TB
- en: '| Receive complex data, including the contents of files. | Use multipart form
    encoding. | *13-16* |'
  prefs: []
  type: TYPE_TB
- en: '| Prevent user data from being interpreted as HTML elements. | Sanitize the
    data received from the user. | *17-21* |'
  prefs: []
  type: TYPE_TB
- en: '| Ensure the application receives useful data. | Validate the data received
    from the user. | *22-27, 30-32* |'
  prefs: []
  type: TYPE_TB
- en: '| Provide immediate validation feedback to the user. | Validate the data in
    the browser before the form is submitted. | *28-29* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `part2app` project from *Chapter 10*. Run the commands
    shown in *Listing 11.1* in the `part2app` folder to remove files that are no longer
    required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.1: Removing files'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, replace the contents of the `client.js` file in the `src/client` folder
    with the contents shown in *Listing 11.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.2: The contents of the client.js file in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a placeholder until later in the chapter when client-side code will
    be needed again. Replace the contents of the `index.html` file in the `static`
    folder with the elements shown in *Listing 11.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.3: The contents of the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The HTML document contains a simple HTML form that asks the user for their name
    and city. To keep the code that handles forms separate from the rest of the application,
    add a file named `forms.ts` to the `src/server` folder with the content shown
    in *Listing 11.4*. You don’t need to keep the forms code separate; I have only
    done so to make the examples easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.4: The contents of the forms.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11.5* updates the server to use the functions defined in *Listing
    11.4*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.5: Configuring the server in the server.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11.6* removes a helper from the layout used by the server-side templates
    and adds a `script` element for the JavaScript bundle created by webpack. Some
    examples in this chapter rely on templates, and removing the helper simplifies
    the template rendering, while adding the `script` element will allow client-side
    code to be used in content generated from templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.6: Changing elements in the main.handlebars file in the templates/server/layouts
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Finally, create a file named `data.json` in the `part2app` folder with the
    content shown in *Listing 11.7*. This file will be used to demonstrate how forms
    can be used to send files to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.7: The contents of the data.json file in the part2app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 11.8* in the `part2app` folder to start the
    development tools and begin listening for HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.8: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser and request `http://localhost:5000`. You will see the form
    elements defined in *Listing 11.3*, whose appearance has been styled using the
    Bootstrap CSS package, as shown in *Figure 11.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Running the example application'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form data can be sent using HTTP `GET` or `POST` requests and the choice of
    method determines how the data contained in the form is presented. *Listing 11.9*
    completes the form to specify the URL to which the form data will be sent and
    adds buttons that submit the form data with different HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.9: Completing the form in the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `action` attribute element on the `form` element tells the browser to send
    the form data to the `/form` URL. The `button` elements are configured with the
    `formmethod` attribute, which specifies which HTTP method the browser should use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: I am using attributes applied to `button` elements so that the same form data
    will be processed in different ways. In later examples, I take a more conventional
    approach and use attributes applied to the `form` element instead.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving form data from GET requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GET` requests are the simplest way to receive form data because the browser
    includes the form field names and values in the URL query string. *Listing 11.10*
    defines a handler for form `GET` requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.10: Handling `GET` requests in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The route uses the `get` method to match `GET` requests sent to the `/form`
    URL. Express decodes URL query strings and presents them through the `Request.query`
    property. In *Listing 11.10*, the query string parameters and values are used
    to generate the response. Use a browser to request `http://localhost:5000`, fill
    out the form using `Alice Smith` as the name and `London` as the city, and click
    the **Submit** (**GET**) button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser will send a `GET` request to the `/form` URL and include the values
    that were entered into the form, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The data will be received by the server, the query string will be parsed, and
    the form data will be used in the response, as shown in *Figure 11.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Handling form data from a `GET` request'
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of `GET` requests is they must be *idempotent*, meaning that
    every request for a given URL should always have the same effect and always return
    the same result. Put another way, form data sent with a `GET` request is effectively
    a request to read data that isn’t expected to change with every request.
  prefs: []
  type: TYPE_NORMAL
- en: This is important because HTTP caches are allowed to store the responses to
    `GET` requests and use them to respond to requests for the same URL, which means
    that some requests may not be received by the backend server. For this reason,
    most form data is sent using `POST` requests, which won’t be cached but which
    can be more complex to process.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving form data from POST requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP `POST` requests include the form data in the request body, which must be
    read and decoded before it can be used. *Listing 11.11* adds a route that handles
    `POST` requests, reads the body, and uses it as the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.11: Adding a handler to the form.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Node.js and Express read the headers from the HTTP request and leave the body
    so that it can be read as a stream. The new route in *Listing 11.11* matches `POST`
    requests sent to `/form` and creates a response containing the request’s `Content-Type`
    header and the request body.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000`, fill out the form with the
    same details as in the previous section, and click the **Submit** (**POST**) button.
    The browser will send a `POST` request to the server with the form data in the
    request body, producing the response shown in *Figure 11.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Handling form data from a POST request'
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser has set the `Content-Type` header to `application/x-www-form-urlencoded`,
    which indicates that the form data values are encoded in the same way as when
    the data is included in the query string, with name-value pairs separated by `=`
    characters and combined with `&` characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can decode the form data yourself, but Express includes middleware that
    detects the `Content-Type` header and decodes the form data into a key/value map.
    *Listing 11.12* enables the middleware and uses the data it produces in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.12: Using Express middleware in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The middleware component is created using the `Express.urlencoded` method and
    the required `extended` configuration option is used to specify whether request
    bodies are processed using the same library that parses query strings or, as here,
    a more sophisticated option that allows more complex data types to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the decoded data, request `http://localhost:5000`, fill in the form,
    and click the **Submit** (**POST**) button. The individual form element names
    and values will be displayed in the response, instead of the URL-encoded string,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Receiving multipart data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `application/x-www-form-urlencoded` format is the default and works well
    for gathering basic data values from a user. For forms where the user submits
    files, the `multipart/form-data` format is used, which is more complex but allows
    for a mix of data types to be sent in the HTTP request body. *Listing 11.13* adds
    an `input` element that allows the user to select a file and a button to the HTML
    form that submits the data using the `multipart/form-data` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.13: Adding elements in the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The new `input` element has a `type` attribute set to `file`, which tells the
    browser that it should present the user with an element to choose a file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11.14* updates the form handler so that `application/x-www-form-urlencoded`
    and `multipart/form-data` requests are handled differently, which is important
    because it affects the way that browsers deal with files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.14: Selecting content type in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000` and fill out the form, choosing
    the `data.json` file created at the start of the chapter for the `File` field.
    The form encoding determines how the browser deals with files. Click **Submit**
    (**POST**) to send the form with a `POST` request in the `application/x-www-form-urlencoded`
    encoding, and the **Submit (POST/MIME)** button to send the form with a `POST`
    request using the `multipart/form-data` encoding. Both outcomes are shown in *Figure
    11.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Sending form data in different encodings'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `application/x-www-form-urlencoded` encoding, the browser includes
    just the name of the file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `multipart/form-data` encoding does include the file contents, but to do
    so, the structure of the request body becomes more complex, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The request body contains multiple parts, each of which is separated by a boundary
    string, which is included in the `Content-Type` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each body part can contain a different type of data and comes complete with
    headers that describe the contents. In the case of the body part for the file,
    the headers provide the name given to the form field, the name of the file that
    has been chosen, and the type of content in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `multipart/form-data` encoding can be decoded manually, but it isn’t a good
    idea because there have been so many non-compliant implementations over the years
    that require special handling or workarounds. Express doesn’t include built-in
    support for processing `multipart/form-data` requests but several JavaScript packages
    can do so. One option is Multer ([https://github.com/expressjs/multer](https://github.com/expressjs/multer)
    which works well with Express. Run the commands shown in *Listing 11.15* to install
    the Multer package and the type definitions that describe the API it provides
    to TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.15: Installing a package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11.16* configures the Multer package and applies it to the form handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.16: Processing multipart requests in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before Multer can be used, it has to be told where it can store the files it
    receives. The package comes with two storage options, which are to write the files
    to a disk folder or to store the file data in memory. As mentioned in *Part 1*,
    care must be taken when writing to the file system and it should be avoided as
    much as possible. If you do need to store data from users, then my advice is to
    use a database, as described in *Chapter 12*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11.16* uses the memory-based storage option to create a middleware
    component that will process `multipart/form-data` requests. Unlike most other
    middleware, the Multer package is applied to specific routes to prevent malicious
    users from uploading files on routes where they are not expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This statement applies the Multer middleware to just one route and looks for
    files in a field named `datafile`, matching the name attribute of the file `input`
    element in the HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: The middleware reads the request body and creates a `file` property through
    which details of the uploaded file can be read, with the most useful properties
    described in *Table 11.3*. Body parts that are not files will be presented through
    the `body` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.3: Useful file description properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns the name of the file on the user’s system. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns the size of the file in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns the MIME type of the file. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns a Buffer that contains the entire file. |'
  prefs: []
  type: TYPE_TB
- en: To see the effect of the middleware, request `http://localhost:5000`, fill out
    the `name` and `city` form fields, select the `data.json` file, and click the
    **Submit** (**POST/MIME**) button. The response includes the values from the body
    and file properties, as shown in *Figure 11.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Uploading files'
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It isn’t just files that you should be cautious about receiving from users:
    any data has the potential to cause problems. The most common problem is a **cross-site
    scripting** (**XSS**) attack where a data value is crafted so that it is interpreted
    by the browser as HTML elements or JavaScript code. In *Chapter 7*, I demonstrated
    how a content security policy can be used to help prevent XSS by telling the browser
    how the application is expected to behave, but another good measure is to sanitize
    data that is received from one user so that it doesn’t contain characters that
    browsers will interpret unexpectedly when it is displayed to another user. To
    prepare, *Listing 11.17* changes the form handler so it returns an HTML response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.17: Returning an HTML response in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The HTML output is simple and unstyled, which you can see by requesting `http://localhost:5000`,
    filling out the form with the same details as for previous examples, and clicking
    the **Submit (POST/MIME)** button, as shown in *Figure 11.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Producing an HTML response'
  prefs: []
  type: TYPE_NORMAL
- en: To see the effect of unsafe content, go back to `http://localhost:5000` and
    fill out the form using the values in *Table 11.4*
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.4: Unsafe content values'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `City` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Submit (POST/MIME)** and the values that were entered into the form
    will be included in the response, which the browser interprets as a `link` element
    for the Bootstrap CSS stylesheet and an anchor element that is styled to look
    like a button, and which will request a URL that is not part of the application,
    as shown in *Figure 11.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The effect of displaying unsafe content'
  prefs: []
  type: TYPE_NORMAL
- en: The sanitization process involves replacing characters that denote HTML content
    with escape sequences that display the same character. *Table 11.5* lists the
    characters that are usually sanitized and the escape sequences that replace them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 11.5: Unsafe characters and escape sequences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unsafe Character | Escape Sequence |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Add a file named `sanitize.ts` to the `src/server` folder with the content shown
    in *Listing 11.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.18: The contents of the sanitize.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `sanitizeValue` function applies a pattern to a string to find dangerous
    characters and replace them with safe escape sequences. Data values are sanitized
    as they are included in an HTML response. This is usually done as part of the
    template process – as I demonstrate shortly – but *Listing 11.19* applies the
    `santizeValue` function to the values included in the HTML response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.19: Sanitizing output values in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, fill out the form with the
    details in *Table 11.5*, and click the **Submit (POST/MIME)** button. The values
    received from the user are sanitized as they are included in the HTML response
    so that the browser can display the strings without interpreting them as valid
    elements, as shown in *Figure 11.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Sanitizing data values'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeatedly Sanitizing data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You must ensure that data is sanitized, but you should only sanitize it once.
    If data is repeatedly sanitized, then the `&` character will be escaped repeatedly.
    If you start with this unsafe string, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'and sanitize it, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The dangerous characters are escaped but the browser will interpret the escape
    sequences so that the string looks like the original but won’t be interpreted
    as an HTML element. If the string is sanitized again, the `&` characters, which
    are already part of escape sequences, will be replaced with `&amp;`, producing
    this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The browser won’t be able to interpret the escape sequences properly and will
    display a mangled string.
  prefs: []
  type: TYPE_NORMAL
- en: Most template packages will automatically sanitize data values when a template
    is rendered, and this includes the Handlebars package added to the project in
    *Chapter 10*. Add a file named `formData.handlebars` to the `templates/server`
    folder with the content shown in *Listing 11.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.20: The contents of the formData.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars automatically sanitizes data values in `{{` and `}}` expressions,
    making it safe to include in HTML responses. *Listing 11.21* updates the form
    request handler to use the new template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.21: Using a template in the forms.ts file in the server/src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The context object passed to the template contains the properties from the `body`
    and `file` objects and a `fileData` property that provides direct access to the
    file data, since Handlebars won’t evaluate code fragments in templates. Request
    `http://localhost:5000`, fill out the form using the details in *Table 11.21*,
    and click the **Submit (POST/MIME)** button and you will see that the template
    contains safe values, as shown in *Figure 11.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars will always sanitize data values in `{{ }}` expressions. If you want
    to include data without sanitization, use the `{{{` and `}}}` character sequences
    instead, as demonstrated in *Chapter 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Using a template to sanitize data values'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: When combined with a content security policy, sanitizing data in HTML templates
    is a good basic defense against XSS attacks. But it isn’t comprehensive and potential
    problems can remain, such as when inserting user data values into JavaScript code
    that will be executed by the browser. A good checklist for avoiding such problems
    can be found at [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: Validating form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sanitizing data can help prevent malicious values from being displayed to users,
    but that doesn’t mean that the data you receive will be useful. Users will enter
    just about anything into a form, sometimes through genuine error, but mostly because
    forms are an unwelcome obstacle between the user and their goal, whatever that
    might be.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the data received from forms must be *validated*, which is
    the process of ensuring that data can be used by the application and telling the
    user when invalid data is received. Form validation is most easily done with a
    template because it makes it easy to give the user feedback when a problem arises.
    To prepare for validation, add a file named `age.handlebars` to the `templates/server`
    folder with the content shown in *Listing 11.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.22: The contents of the age.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This template contains a form that asks the user for their name and age so that
    the server can calculate their age next year. This is a trivially simple application,
    but it contains just enough functionality to require validation. *Listing 11.23*
    updates the routes for the `/form` URL to use the new template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.23: Updating routes in the forms.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `get` route renders the age template with no context data. The `post` route
    renders the template with the form data received in the body and a `nextage` property,
    which is created by parsing the `age` value received from the form into a `Number`
    and adding one. Use a browser to request `http://localhost:5000/form`, enter a
    name and age into the form, and click the **Submit** button. If you repeat the
    process but provide a non-numerical age, the application won’t be able to parse
    the form data and won’t produce a result. Both outcomes are shown in *Figure 11.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: An application that uses form data to produce a result'
  prefs: []
  type: TYPE_NORMAL
- en: The application has expectations for the data that it receives, and validation
    is the process of ensuring those expectations are met.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Validation is a way of making the user fill out the form, but you should take
    a moment to ask whether the form should exist at all. If you want increased user
    satisfaction with your application, then keep forms simple and clear, and ask
    for only the bare minimum needed to get the job done. Be flexible about the formats
    you will accept for complex data values, like credit card numbers or dates, and
    make validation error messages as clear as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation requires a set of tests that can be applied to form data as it is
    received. Add a file named `validation.ts` to the `src/server` folder, with the
    contents shown in *Listing 11.24*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.24: The contents of the validation.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of ways to implement a validation system, but the approach taken
    in *Listing 11.24* is to follow the pattern introduced by other packages used
    in this part of the book and create Express middleware that adds a property to
    the `Request` object. The code isn’t yet complete because it doesn’t apply validation
    checks. But it does allow validation requirements to be defined, and that’s a
    good place to start because the code required to easily perform validation can
    be convoluted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial code defines three validation rules: `required`, `minLength`, and
    `isInteger`. Real validation packages, such as the one I introduce later in this
    chapter, have dozens of different rules, but three is enough to demonstrate how
    form data validation works. The `required` rule ensures the user has supplied
    a value, the `minLength` rule enforces a minimum number of characters, and the
    `isInteger` rule ensures that the value is an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point is to give TypeScript a description of the property that
    will be added to the `Request` object, which is how the validation results will
    be presented to the request handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ValidatedRequest` type has all of the features defined by `Request`, plus
    a property named `validation` that returns an object with `results` and `valid`
    properties. The `valid` property returns a `boolean` value that gives an overall
    indication of the form data validation outcome. The `results` property provides
    detailed information about the form data fields that have been validated. The
    goal is to produce an object that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This object represents validation checks performed on `name` and `age` properties.
    Overall, the form data is invalid, and inspecting the detail, you can see that
    this is because the `name` property has failed its validation checks, specifically
    because the name value hasn’t passed the `minLength` rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate` function returns an Express middleware function that also has
    methods, allowing validation to be defined by chaining together the validation
    rules for a property. The `getValidationResults` reads the `validation` property
    added to the request, making it easy to access the validation data in the request
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Applying validation rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a function that also has methods takes advantage of JavaScript’s flexibility,
    so that validation rules can be specified by calling the `validate` method to
    select a form field and then methods can be called on the result to specify validation
    rules. This isn’t essential, but it does allow validation requirements to be expressed
    concisely, as shown in *Listing 11.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.25: Defining validation rules in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The result of calling a rule method is the handler function that defines it,
    which means that multiple rules can be selected by chaining together method calls.
    *Listing 11.25* applies the `required` and `minLength` rules to the `name` field
    and the `isInteger` rule to the `age` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `getValidationResults` function is called within the handler function to
    get the validation results, which are used to alter the context object used to
    render the view so that the (simple) calculation is only performed when valid
    data has been received from the user.
  prefs: []
  type: TYPE_NORMAL
- en: The validation results are included in the template context object, which allows
    a template helper to inspect the results and control the visibility of validation
    error elements. The elements that display errors to the users will always be present
    in the template, and *Listing 11.25* defines a template helper named `pass` that
    will be used to control visibility.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11.26* updates the template to include the error message elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.26: Adding validation messages in the age.handlebars file in the
    templates/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The new additions ensure that the results are only displayed if the form data
    is valid, and display validation errors when there is a problem. Including the
    error elements in the template will be helpful for client-side validation, which
    is demonstrated later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step is to complete the custom validator by applying the tests to
    a value, as shown in *Listing 11.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.27: Completing the validator in the validation.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: I left this step until the end to make the other parts of the validation system
    easier to understand. Each time one of the validation rule methods is called,
    such as `required`, a new property is added to the object assigned to the constant
    named `tests`. To perform validation, the `tests` properties are enumerated, each
    test is performed, and the outcome is used to build up the validation results.
    If any validation test fails, then the overall validation outcome and the outcome
    for the current field value are set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000` and click the `Submit` button
    without entering values into the form fields. Validation will fail and error messages
    will be displayed to the user, as shown in *Figure 11.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Displaying validation errors'
  prefs: []
  type: TYPE_NORMAL
- en: An error message is displayed for each validation rule that fails, and the backend
    server won’t generate a normal response until validation succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Performing client-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side validation checks form values before the form is submitted, which
    can provide immediate feedback to the user. Client-side validation is used in
    addition to server-side validation, which is still required because users may
    disable the client-side JavaScript code or manually submit form data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Built-in HTML Client validation features**'
  prefs: []
  type: TYPE_NORMAL
- en: HTML supports validation attributes on input elements, along with a JavaScript
    API that allows validation events to be received, both of which are described
    at [https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation).
    These features can be useful, but they are not always implemented consistently
    and provide only basic validation checks. It requires only a little more work
    to create a more comprehensive validation system, which is why they are not used
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The key to client-side development is consistency. This can be achieved by using
    the same package for both client- and server-side validation, which is the approach
    I take in the next section. Otherwise, it is important to ensure that fields are
    validated in the same way and produce the same error messages. Add a file named
    `client_validation.js` to the `src/client` folder with the code shown in *Listing
    11.28*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.28: The contents of the client_validation.js file in the src/client
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript code follows a similar pattern to the TypeScript code used to
    set up chains of validation tests in *Listing 11.24*, albeit without integration
    into Express. *Listing 11.29* updates the client-side code to validate the form
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.29: Validating form data in the client.js file in the src/client
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This code locates the form element in the HTML document and registers a handler
    for the `submit` event, which is emitted when the user clicks the **Submit** button.
    The browser’s `FormData` API is used to obtain the data in the form, which is
    tested using the validation functions defined in *Listing 11.28*. The validation
    results are used to change the visibility of the error message elements in the
    template. If there are any validation errors, the `preventDefault` method is called
    on the submit event, which tells the browser not to send the data to the server.
    *Listing 11.29* preserves the same style for expressing validation requirements,
    which leads to some dense code for processing the results, finding the elements
    that correspond to each test that has been performed, and setting the element
    visibility.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, error message elements are added to a Bootstrap CSS class
    when they are processed by the client-side JavaScript code, just to emphasize
    when an error has been displayed by the client and not the server.
  prefs: []
  type: TYPE_NORMAL
- en: Use a browser to request `http://localhost:5000/form` and click the **Submit**
    button without filling out the form. The error message elements will be displayed,
    but with a solid background color that indicates they were shown by the client-side
    code, as shown in *Figure 11.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Using client-side validation'
  prefs: []
  type: TYPE_NORMAL
- en: Using a package for validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having demonstrated how server-side and client-side form validation works, it
    is time to replace the custom checks with those provided by a well-tested and
    comprehensive validation library.
  prefs: []
  type: TYPE_NORMAL
- en: As with most areas of JavaScript functionality, there are many libraries available,
    and the one I have chosen for this chapter, `validator.js`, is simple and effective
    and can be used for both client- and server-side validation. Run the commands
    shown in *Listing 11.30* in the `part2app` folder to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.30: Installing a validation package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11.31* updates the client-side validation code to use the tests provided
    by the `validator.js` package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.31: Using a validation package in the client_validation.js file
    in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The full set of tests provided by the `validator.js` package can be found at
    [https://github.com/validatorjs/validator.js](https://github.com/validatorjs/validator.js)
    and *Listing 11.31* uses three of these tests to replace the custom logic while
    the rest of the code remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: The same set of changes can be applied to the server, as shown in *Listing 11.32*,
    ensuring consistent validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 11.32: Using a validation package in the validation.ts file in the
    src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Request `http://localhost:5000/form` and submit the form and you will see the
    validation messages shown in *Figure 11.13*. Disable JavaScript in the browser
    and repeat the process, and you will see the same validation messages, but this
    time displayed by the server, also shown in *Figure 11.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: For Google Chrome, you can disable JavaScript in the *F12* developer windows
    by selecting **Run Command** from the menu with three vertical dots and entering
    `java` into the text box. The browser will present the **Disable JavaScript**
    or **Enable JavaScript** commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_11_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Using a validation package'
  prefs: []
  type: TYPE_NORMAL
- en: There is no change in the way validation appears to the user, but the use of
    a validation package increases confidence that validation will be performed accurately
    and provides access to a much wider range of validation tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I described the different ways that applications can receive
    form data, make it safe to handle, and check that it is the data that the application
    requires:'
  prefs: []
  type: TYPE_NORMAL
- en: Form data can be sent using `GET` and `POST` requests, which affects how the
    data is encoded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caution is required when sending data with `GET` requests because the results
    may be cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different encodings are available for forms sent over `POST` requests, including
    an encoding that allows file data to be sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form data should be sanitized before it is included in HTML output or used in
    any operation where the values may be evaluated as trusted content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form data should be validated before it is used to ensure the values sent by
    the user can be safely used by the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation can be done by the server or the client. Client-side validation does
    not replace server-side validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will explain how databases are used in Node.js applications,
    and how data can be included in the HTML content sent to the client.**
  prefs: []
  type: TYPE_NORMAL
