<html><head></head><body>
        

                            
                    <h1 class="header-title">Handling Serverless Notifications</h1>
                
            
            
                
<p>Push notifications are a common use case for modern applications. They are important not just for mobile devices, but also for websites. When you are browsing your Facebook timeline and receive a notification that a friend has commented on one of your photos, this is a push notification. In this chapter, you will learn how to implement this feature in a serverless solution.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Implementing serverless notifications using AWS IoT</li>
<li>Public and private notifications</li>
</ul>
<p>By the end of this chapter, you'll have learned how to handle real-time notifications in a serverless application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AWS IoT</h1>
                
            
            
                
<p>It may sound strange to use the Internet of Things as a service for websites, but AWS IoT is the only service offered by Amazon that supports WebSockets in a serverless model. Without WebSockets, we need to rely on <em>polling</em>. Polling is the process where the client needs to make repeated and frequent requests to the server, checking whether a new message is available, while WebSockets are used to create a link between the client and the server where the server can send the message directly to the client without the need of being constantly requested. WebSockets are used to implement the <em>publish-subscribe</em> pattern, which is more efficient than <em>polling</em>.</p>
<p>Besides AWS IoT, another candidate to implement real-time serverless notifications is Amazon <strong>Simple Queue Service</strong> (<strong>SQS</strong>). You can create a queue of messages that are destined for a single user and wait for this user to request SQS looking for new messages. While polling is necessary for this solution, Amazon offers a feature named <em>long-polling</em>. With this feature, when you request a message to SQS, AWS will hold your request up to 20 seconds, waiting for a new message to arrive. If one arrives while waiting, you will receive the response immediately. If no message appears, after 20 seconds, you will receive an empty response and will need to make a new SQS request. This approach reduces the total number of requests and the costs associated with a frequent polling approach.</p>
<p>One advantage that SQS has over IoT is the guarantee that a message will be read. If you place a message in SQS, it will be removed only when someone receive it, while with IoT, the user must be connected to receive the message.</p>
<p>Another service that is used for notifications is Amazon <strong>Simple Notification Service</strong> (<strong>SNS</strong>). Although the name sounds like an obvious choice for serverless notifications, it does not support WebSockets and you can't hook a browser client to receive notifications on demand. However, for mobile applications, you can use it with push notifications services, such as <strong>Google Cloud Messaging</strong> (<strong>GCM</strong>), for real-time messages without polling.</p>
<p>You may not like the name "IoT", but it is a great service and solves our use case of getting notifications respecting the serverless model. AWS IoT is a simple messaging service. You can have <em>devices</em> subscribed to <em>topics</em> to receive messages that will be published by other devices. In our examples, you will consider a <em>device</em> as a user connected through a web browser that will receive messages from other users or from a Lambda function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Protocols</h1>
                
            
            
                
<p>AWS IoT supports <em>HTTP</em>, <em>MQTT</em>, and <em>MQTT over WebSockets</em> protocols. HTTP uses a RESTful endpoint and <strong>Message Queue Telemetry Transport</strong> (<strong>MQTT</strong>) is a lightweight messaging protocol that was created for small sensors and constrained devices.</p>
<p>You may think that using HTTP would be the easiest option for us who already know how to use RESTful endpoints, but HTTP support is restricted to publishing messages. In a REST architecture, you can't subscribe to messages, since the server can't initiate transmissions. The server is only able to answer requests.</p>
<p>MQTT over WebSockets is an enhancement to the MQTT protocol with the objective of supporting browser-based applications. It supports the <em>subscribe</em> feature, so your user can be hooked waiting for messages instead of being constantly polling for updates every few seconds. Avoiding a polling mechanism is strictly necessary for efficiency and to allow scalability when you want to serve thousands of users simultaneously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding the IoT endpoint</h1>
                
            
            
                
<p>To use the AWS IoT service, you must provide the IoT endpoint of your account from the region that you want to use this service. Let's execute the following steps to find the IoT endpoint:</p>
<ol>
<li>You can find this information using the IoT Management Console, which is available at <a href="https://console.aws.amazon.com/iot">https://console.aws.amazon.com/iot</a>.</li>
<li>In the top-right corner, you can change the service region. Click on Get started to move to the next screen:</li>
</ol>
<div><img class="image-border" src="img/9cab2df0-a742-46ff-b6ef-0df798469484.png"/></div>
<ol start="3">
<li>On the console screen, choose the Settings option located in the bottom-left corner:</li>
</ol>
<div><img class="image-border" src="img/433dac79-1301-4f61-95b3-432516f393d8.png"/></div>
<ol start="4">
<li>Write down your IoT endpoint address to use in your application:</li>
</ol>
<div><img class="image-border" src="img/7acf80d4-3e09-4105-9846-0be0f4bd32dd.png"/></div>
<div><strong>Security observation:</strong> the endpoint address doesn't need to be private. You can hardcode it in your application and distribute it to your clients, since the frontend code needs to know this address to access IoT messages.</div>
<ol start="5">
<li>For our demo application, the frontend code we will have this information in the <kbd>config.js</kbd> file:</li>
</ol>
<pre>
        "iot": {<br/>          "REGION": "us-east-1",<br/>          "ENDPOINT": "abcdef.iot.us-east-1.amazonaws.com"<br/>        }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">AWS IoT SDK</h1>
                
            
            
                
<p>Handling the MQTT protocol and signing each request can be a troublesome task. Fortunately, we don't need to <em>reinvent the wheel</em>. AWS offers an SDK that implements the MQTT protocol for us and offers all the features that we need to use. You can find the source code on GitHub at <a href="https://github.com/aws/aws-iot-device-sdk-js">https://github.com/aws/aws-iot-device-sdk-js</a>.</p>
<p>You can install the module using npm by executing this command:</p>
<pre>
<strong>    npm install aws-iot-device-sdk --save</strong>
</pre>
<p>To use this SDK, we need to pass the following information:</p>
<ul>
<li><strong>Credentials</strong>: The SDK will need to know the AWS access key, AWS secret access key, and session token to be able to sign the requests and get the authorization to access the AWS resources. We are going to use Cognito later to dynamically retrieve temporary credentials.</li>
<li><strong>Region</strong>: The region of the AWS IoT service that we are going to use.</li>
<li><strong>IoT endpoint</strong>: The IoT endpoint that we have just retrieved.</li>
<li><strong>IoT topic</strong>: You don't need to explicitly create an IoT topic beforehand. Just choose a word and use it as a channel to exchange messages. However, your credentials must have authorization to this topic or to <kbd>*</kbd> (all topics).</li>
</ul>
<p>For our example, we are going to create a class in a <kbd>iot.js</kbd> file inside the frontend's <kbd>lib</kbd> folder:</p>
<pre class="mce-root">
    import awsIot from 'aws-iot-device-sdk';<br/>    import config from './config';<br/><br/>    export default class IoT {<br/>    <br/>      constructor(keys, messageCallback) {  <br/>        this.client = null;<br/>        this.accessKey = keys.accessKey;<br/>        this.secretKey = keys.secretKey;<br/>        this.sessionToken = keys.sessionToken;<br/>        this.messageCallback = messageCallback;<br/>      }<br/><br/>      connect() {<br/>        // TODO<br/>      }<br/><br/>      publish(topic, message) {<br/>        // TODO<br/>      }<br/><br/>      subscribe(topic) {<br/>        // TODO<br/>      }<br/>    }
</pre>
<p>This class has a constructor which receives the necessary credentials and a <kbd>messageCallback</kbd> function that will be used as a dependency injection. Whenever we receive a new message, we are going to call this <kbd>messageCallback</kbd> function to execute the desired logic by the one that has created the new object instance of the IoT class.</p>
<p>Let's now see how to implement the <kbd>connect</kbd>, <kbd>publish</kbd>, and <kbd>subscribe</kbd> methods:</p>
<pre class="mce-root">
    connect() {<br/>      this.client = awsIot.device({<br/>        region: config.iot.REGION,<br/>        host: config.iot.ENDPOINT, <br/>        accessKeyId: this.accessKey,<br/>        secretKey: this.secretKey,<br/>        sessionToken: this.sessionToken,<br/>        port: 443,<br/>        protocol: 'wss' // WebSocket with TLS <br/>      });<br/><br/>      this.client.on('connect', this.handleConnect);<br/>      this.client.on('message', this.handleMessage);<br/>      this.client.on('close', this.handleClose);<br/>    }<br/><br/>   publish(topic, message) {<br/>     this.client.publish(topic, message);<br/>   }<br/><br/>   subscribe(topic) {<br/>     this.client.subscribe(topic);<br/>   }
</pre>
<p>In the previous code, the <kbd>connect</kbd> method subscribes the <kbd>client</kbd> object to three events:</p>
<ul>
<li>The <kbd>connect</kbd> event</li>
<li>The <kbd>message</kbd> event</li>
<li>The <kbd>close</kbd> event</li>
</ul>
<p>There are also three more events that you can subscribe to make your application more robust:</p>
<ul>
<li>The <kbd>error</kbd> event</li>
<li>The <kbd>reconnect</kbd> event</li>
<li>The <kbd>offline</kbd> event</li>
</ul>
<p>The last step is to define the methods that will handle these events. They are defined as the following:</p>
<pre class="mce-root">
    handleConnect() {<br/>      console.log('Connected');<br/>    }<br/><br/>    handleMessage(topic, message) {<br/>      this.messageCallback(topic, message);<br/>    }<br/><br/>    handleClose() {<br/>      console.log('Connection closed');<br/>    }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing serverless notifications</h1>
                
            
            
                
<p>In the previous section, you learned about the AWS IoT SDK, we just haven't tested it yet. In this section, we will use it in the following two features of our serverless store:</p>
<ul>
<li>Live comments in a product review page</li>
<li>Notifications after a payment has been accepted</li>
</ul>
<p>The first feature is a type of a <strong>public notification</strong>, as it uses an IoT topic that all users can read. The second one is a <strong>private notification</strong>, so only one person and the Lambda backend are allowed to access the IoT topic to subscribe or publish messages. We will cover both of them to learn how to give proper access for each case.</p>
<p>Those two examples will illustrate how you can work with IoT to serve notifications, but it does not limit what you can do with it. You can think in other use cases. For example, IoT can also be used for serverless multiplayer games. You could build an HTML5 game that could make requests to a Lambda backend to execute some logic (for example, find a room to play) and an IoT topic to exchange messages between players. It may not be well suited to very dynamic games like FPS games, but could be pretty useful and cheap for card games, puzzles, and games where you don't need extremely low and predictable response times.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Public notifications</h1>
                
            
            
                
<p>In <a href="6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml">Chapter 5</a>, <em>Building the Frontend</em>, we defined the product details view and it has a list of all customer reviews. What we are going to implement here is <em>live comments</em>. When a user adds a new review, another user that is browsing the same page will see the message at the same moment that it is posted. It may not seem to be so important for a customer review page, but this is the kind of feature that is extremely important for chat systems, forums, and social networks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a comment box</h1>
                
            
            
                
<p>The following screenshot shows the current state of our product details page:</p>
<div><img class="image-border" src="img/ce575d72-1ff9-4c0d-9078-8f039321efc0.png"/></div>
<p>We are going to modify the React application to add a comment box like this one:</p>
<div><img class="image-border" src="img/123a5d99-f8a7-4528-a481-2d077b26777d.png"/></div>
<p>For this task, we need to create a <kbd>CommentBox</kbd> component that will be rendered as input text and a button:</p>
<pre>
    return (<br/>      &lt;div className="comment-box"&gt;<br/>        &lt;input type="text" <strong>onChange={this.handleChange}</strong> <br/>               value={this.state.input} /&gt;<br/>        &lt;button <strong>onClick={this.handleClick}</strong>&gt;<br/>          &lt;i className="glyphicon glyphicon-share-alt"&gt;<br/>          &lt;/i&gt; Send<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );
</pre>
<p>When defining the elements, we have placed an <kbd>onChange</kbd> event to the input text to save the input value and an <kbd>onClick</kbd> event to send the information to the <kbd>App</kbd> component. They are implemented as the following:</p>
<pre class="mce-root">
    handleChange(e) {<br/>      this.setState({ input: e.target.value });<br/>    }<br/><br/>    handleClick() {<br/>      this.props.onComment(this.state.input, this.props.productId);<br/>      this.setState({ input: '' });<br/>    }
</pre>
<p>This completes the <kbd>CommentBox</kbd> implementation. What we are going to see next is how the <kbd>App</kbd> component will handle these events to update the page and send a message to other users that are on the same page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the list of comments</h1>
                
            
            
                
<p>In the <kbd>App</kbd> component, we need to handle comment creation. In the following code excerpt, we are creating a new comment object and adding it to the beginning of the comment list array:</p>
<pre class="mce-root">
    handleComments(comment, productId) {<br/>      const newComment = {<br/>        id: uuid(),<br/>        username: 'user1337',<br/>        age: 'a few seconds ago',<br/>        text: comment<br/>      };<br/><br/>      const product = this.state<br/>                          .products<br/>                          .find(p =&gt; p.id === productId);<br/><br/>      // add to the comment to the beginning of the array<br/>      product.comments.unshift(newComment);<br/><br/>      this.setState({<br/>        products: this.state.products<br/>      });<br/><br/>      // TODO: send the new comment to IoT<br/>    }
</pre>
<p>To set the ID of the comment, I've used the <kbd>UUID</kbd> module (<kbd>npm install uuid --save</kbd>) to create a random value. Example of an UUID: <kbd>110ec58a-a0f2-4ac4-8393-c866d813b8d1</kbd></p>
<p>What we need to do now is to send the new comment to the IoT service, so it can be shared with other users on the same page and saved in the database. For now, our comment feature should be working and updating the list of customer reviews:</p>
<div><img class="image-border" src="img/83eedf92-55dd-4c77-aecc-cb0d2726c5db.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new instance of the IoT SDK</h1>
                
            
            
                
<p>In this section, we are going to create a new instance of the IoT class that uses the IoT SDK. This class needs AWS access keys to connect with the IoT services. As we are handling public notifications that don't need an authenticated user, we need to create credentials for anonymous users.</p>
<p>Let's create a new instance of the IoT SDK by performing the following steps:</p>
<ol>
<li>We will start adding the AWS SDK to our frontend project using npm:</li>
</ol>
<pre>
<strong>      npm install aws-sdk --save</strong>
</pre>
<ol start="2">
<li>With the AWS SDK, we can request anonymous access to Cognito using the following code:</li>
</ol>
<pre class="mce-root">
        AWS.config.region = config.cognito.REGION;<br/>        AWS.config.credentials = <br/><strong>          new AWS.CognitoIdentityCredentials({<br/></strong><strong>            IdentityPoolId: config.cognito.IDENTITY_POOL_ID</strong><br/><strong>          });</strong><br/><br/><strong>        AWS.config.credentials.get</strong>(() =&gt; {<br/>          const keys = {<br/>            accessKey: <strong>AWS.config.credentials.accessKeyId,</strong><br/>            secretKey: <strong>AWS.config.credentials.secretAccessKey,</strong><br/>            sessionToken: <strong>AWS.config.credentials.sessionToken</strong><br/>          }<br/>        });
</pre>
<ol start="3">
<li>As we configured in the previous chapter, this identity pool gives access to anonymous users to the IoT topic <kbd>serverless-store-comments</kbd>. With those keys in hand, we are ready to create an instance of the IoT class, connect, and subscribe with this topic:</li>
</ol>
<pre>
        const getIotClient = (messageCallback, callback) {    <br/>          retrieveAwsKeys(keys =&gt; {<br/>            const client = new IoT(keys, messageCallback);<br/>            client.connect();<br/>            client.subscribe('serverless-store-comments');<br/>            callback(null, client);<br/>          });<br/>        }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending and receiving new comments</h1>
                
            
            
                
<p>The <kbd>App</kbd> component is our entity responsible for managing the application state. Therefore, it will be responsible for sending and receiving comments. To implement this, we need to make the following three changes:</p>
<ol>
<li>Modify the <kbd>componentDidMount</kbd> to create an instance of the IoT class:</li>
</ol>
<pre>
        componentDidMount() {<br/>          getIotClient(<br/>            this.handleIotMessages, <br/>            (err, client) =&gt; {<br/>              if (err) alert(err);<br/>              else this.setState({iotClient: client})<br/>            });<br/>        }
</pre>
<ol start="2">
<li>Modify the <kbd>handleComments</kbd> function to send new comments using IoT:</li>
</ol>
<pre class="mce-root">
        handleComments(comment, productId) {<br/>          const newComment = {<br/>            id: uuid(),<br/>            username: 'user1337',<br/>            age: 'a few seconds ago',<br/>            text: comment<br/>          };<br/><br/>          const topic = 'serverless-store-comments';<br/>          const message = JSON.stringify({<br/>            comment: newComment,<br/>            productId: productId<br/>          });<br/><br/>          this.state.iotClient.publish(topic, message);<br/>        }
</pre>
<ol start="3">
<li>Create the <kbd>handleIotMessages</kbd> function to receive the messages and update the list of comments:</li>
</ol>
<pre class="mce-root">
        handleIotMessages(topic, message) {<br/>          const msg = JSON.parse(message.toString());<br/><br/>          if (topic === 'serverless-store-comments') {<br/>            const id = msg.productId;<br/>            const product = this.state<br/>                                .products<br/>                                .find(p =&gt; p.id === id);<br/><br/>            product.comments.unshift(msg.comment);<br/>            this.setState({<br/>              products: this.state.products<br/>            });<br/>          }<br/>        }
</pre>
<p>Test the application, running it using two browser tabs. When you add a comment in one tab, the same comment must appear immediately in the other tab.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Triggering a Lambda function with IoT</h1>
                
            
            
                
<p>The IoT service is being used to exchange live messages between connected users. However, the information is not being persisted. What we are going to do here is to trigger a Lambda function when a new message arrives to an IoT topic, so this message can be persisted.</p>
<p>We can trigger a Lambda function by configuring an event in the <kbd>serverless.yml</kbd> file:</p>
<pre>
    functions:<br/>      comments:<br/>        handler: functions/comments.handler<br/>        events:<br/>          - iot:<br/>              sql: "SELECT * FROM 'topic-name'"
</pre>
<p>For our example, replace <kbd>topic-name</kbd> with <kbd>serverless-store-comments</kbd>.</p>
<p>IoT uses an SQL-like syntax to trigger the Lambda function and to select which content will be sent. In the preceding example, we are passing all contents of the message to the Lambda function.</p>
<p>This SQL statement can be very useful for filtering messages to only trigger a Lambda function when necessary. For example, suppose that we send a message with the following JSON object:</p>
<pre>
    {<br/>      "comment": "this is a bad product",<br/>      "rating": 2<br/>    }
</pre>
<p>We could use the SQL statement to trigger another Lambda function, for example <kbd>handle-bad-reviews</kbd>, only when the rating is low:</p>
<pre>
    "SELECT * FROM 'topic-name' WHERE rating &lt; 3"
</pre>
<p>Going back to our serverless store example, we have defined the trigger to the Lambda function. Now we can implement the function to save the data into the database. As using a serverless database was already covered in <a href="cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml">Chapter 7</a>, <em>Managing a Serverless Database</em>, the next example will just log the contents of the <kbd>event</kbd> object for testing purposes:</p>
<pre class="mce-root">
    const utils = require('../lib/utils');<br/><br/>    module.exports.handler = (event, context, callback) =&gt; {<br/>      console.log(event);<br/>      utils.successHandler(event, callback);<br/>    };
</pre>
<p>You can test if it is working using the <kbd>logs</kbd> command of the Serverless Framework:</p>
<pre>
<strong>    serverless logs --function comments</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Private notifications</h1>
                
            
            
                
<p>In <a href="5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml">Chapter 8</a>, <em>Securing the Serverless Application</em>, we defined a policy document for authenticated users to include an authorization to the following IoT topic:</p>
<pre>
<strong>    serverless-store-${cognito-identity.amazonaws.com:sub}</strong>
</pre>
<p>This means that an authenticated user will have access to an exclusive topic, the name of which is defined by its own federated identity. What we are going to implement next is a <em>private notification</em>, where a Lambda function will publish a message to an IoT topic and just one user will be able to receive it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using credentials of an authenticated user</h1>
                
            
            
                
<p>For an unauthenticated user, we saw that we set credentials using the following code:</p>
<pre>
    AWS.config.region = config.cognito.REGION;<br/>    AWS.config.credentials = <br/>      new AWS.CognitoIdentityCredentials({<br/>        IdentityPoolId: config.cognito.IDENTITY_POOL_ID<br/>      });
</pre>
<p>However, for an authenticated user, the <kbd>credentials</kbd> object needs to be set with an extra property: <kbd>Logins</kbd>. The following code shows how this is done:</p>
<pre>
    const region = config.cognito.REGION;<br/>    const pool = config.cognito.USER_POOL_ID;<br/><strong>    const authenticator = </strong><br/><strong>      `cognito-idp.${region}.amazonaws.com/${pool}`;</strong><br/><br/>    AWS.config.credentials = <br/>      new AWS.CognitoIdentityCredentials({<br/>        IdentityPoolId: config.cognito.IDENTITY_POOL_ID,<br/><strong>        Logins: {</strong><br/><strong>          [authenticator]: userToken</strong><br/><strong>        }</strong><br/>      });
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the logout feature</h1>
                
            
            
                
<p>When we use the AWS credentials feature, the AWS SDK saves user data to local storage. To avoid another user logging on the same browser to use the credentials of the previous user, we need to clear that data on logout. This is done by adding the following piece of code to the <kbd>Logout</kbd> handler:</p>
<pre>
    if (AWS.config.credentials) {<br/><strong>      AWS.config.credentials.clearCachedId();</strong><br/>    }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an IoT policy</h1>
                
            
            
                
<p>Using an authenticated user to connect to IoT requires an extra step: we need to attach an IoT security policy. Without this attachment, the IoT service will reject all requests.</p>
<p>Let's see how to create this policy by performing the following steps:</p>
<ol>
<li>Open the IoT Console at <a href="https://console.aws.amazon.com/iot">https://console.aws.amazon.com/iot</a>.</li>
<li>In the left-hand menu, navigate to Security | Policies and then click on Create a policy:</li>
</ol>
<div><img class="image-border" height="459" src="img/9dd7e082-61e2-487f-bfd2-f921f95a4c96.png" width="664"/></div>
<ol start="3">
<li>Choose a policy name, use the Action <kbd>iot:Connect</kbd>, <kbd>iot:Subscribe</kbd>, <kbd>iot:Publish</kbd>, and <kbd>iot:Receive</kbd>, type <kbd>*</kbd> for the Resource, and check Allow for the Effect:</li>
</ol>
<div><img class="image-border" height="478" src="img/49daa357-88ac-44bc-a60e-945d2dd72296.png" width="614"/></div>
<ol start="4">
<li>Click on Create to finish.</li>
</ol>
<div><strong>Security observation:</strong> although we have selected the <kbd>*</kbd> resource, we won't be able to subscribe or publish to all topics because AWS will use the Cognito roles to check permissions and this policy document was set with restricted access.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching an IoT policy and connecting</h1>
                
            
            
                
<p>In the previous chapter, we set the Cognito policy document to allow access to the action <kbd>iot:attachPrincipalPolicy</kbd>. Now we are going to use it. After getting the AWS credentials, we are going to use the <kbd>AWS.Iot</kbd> module and the <kbd>attachPrincipalPolicy</kbd> function to attach the IoT policy that we have just created to the authenticated user. After setting the policy, we are going to connect to IoT and subscribe to the public and private topics:</p>
<pre class="mce-root">
    AWS.config.credentials.get(() =&gt; {<br/>      const keys = {<br/>        accessKey: AWS.config.credentials.accessKeyId,<br/>        secretKey: AWS.config.credentials.secretAccessKey,<br/>        sessionToken: AWS.config.credentials.sessionToken<br/>      }<br/><br/><strong>      const awsIoT = new AWS.Iot();</strong><br/><strong>      const params = {</strong><br/><strong>        policyName: 'iot-policy',</strong><br/><strong>        principal: AWS.config.credentials.identityId</strong><br/><strong>      }</strong><br/><br/><strong>      awsIoT.attachPrincipalPolicy(params, (err, res) =&gt; {</strong><br/>        if (err) alert(err);<br/>        else {<br/>          const client = new IoT(keys, messageCallback);<br/>          client.connect();<br/><br/>          // subscribe to the public topic<br/>          client.subscribe('serverless-store-comments');<br/><br/><strong>          // subscribe to the private topic</strong><br/><strong>          const id = AWS.config.credentials.identityId;</strong><br/><strong>          client.subscribe('serverless-store-' + id);</strong><br/><br/>          callback(null, client);<br/>        }<br/>      });<br/>    });
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Passing the Cognito Identity to the Lambda function</h1>
                
            
            
                
<p>In the previous chapter, when we have defined the restricted access to IoT resources, we have used the <kbd>${cognito-identity.amazonaws.com:sub}</kbd> IAM policy variable to define the IoT topic name. This parameter uses the Cognito Identity, but the backend code doesn't know this value. The Lambda function will retrieve a User ID through the authorizer (<kbd>event.requestContext.authorizer.claims.sub</kbd>), but the Authorizer ID is different from the Cognito Identity.</p>
<p>To pass this value from the frontend code to the backend, AWS recommends we send a signed request using its <strong>Signature Version 4</strong> (<strong>Sigv4</strong>) signing process. Furthermore, instead of setting the Cognito authorizer in the API Gateway, you need to use the <strong>AWS_IAM</strong> authorizer. It's the safest way to pass this information to the backend because this method guarantees that only the real user will be able to send its Cognito ID.</p>
<p>However, we won't cover this topic here. Signing the request with <strong>Sigv4</strong> and using <strong>AWS_IAM</strong> authorizer is much more complicated than using the the Cognito authorizer and our demo application doesn't need this because we use the Authorizer ID to identify a user and not the Cognito ID. Besides, as we have configured the IoT role policy, it's impossible for one user to receive a message created to another user, even if a malicious user knows the other user's Identity. The worst case scenario would be for a malicious user to trigger unwanted messages to other users, which will happen only if the other user credentials were compromised.</p>
<p>So, in our case, we are going to send Cognito ID from the frontend to the backend using the <kbd>AWS.config.credentials.identityId</kbd> parameter in the <kbd>Checkout</kbd> request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending IoT messages with Lambda</h1>
                
            
            
                
<p>We have modified the application to subscribe the authenticated user to a public and a private topic. What we are going to look at now is how to send a message to this private topic using a Lambda function by performing the following steps:</p>
<ol>
<li>The first step is to modify the <kbd>serverless.yml</kbd> file to give explicit permissions to allow access to <kbd>iot:Publish</kbd>:</li>
</ol>
<pre>
        provider:<br/>          name: aws<br/>          runtime: nodejs6.10<br/><strong>          iamRoleStatements:</strong><br/><strong>            - Effect: "Allow"</strong><br/><strong>              Action:</strong><br/><strong>                - "iot:Publish"</strong><br/><strong>              Resource: </strong><br/><strong>                "arn:aws:iot:&lt;region&gt;:&lt;account&gt;:topic/*"</strong>
</pre>
<ol start="2">
<li>For our example, we are going to use the <kbd>processCheckout</kbd> function. The user will click on Checkout and this action will trigger a Lambda function that will publish a message to the user topic. The result will be the notification icon changing color to notify the user that a new message is available:</li>
</ol>
<div><img class="image-border" src="img/2f41c9a6-9107-4819-b8c1-3a9c899e425b.png"/></div>
<ol start="3">
<li>Changing the frontend application is a simple task, so it will be an exercise for the reader. Regarding the backend code, we are going to use the following code for the <kbd>processCheckout</kbd> function:</li>
</ol>
<pre>
        const AWS = require('aws-sdk');<br/>        const utils = require('./utils');<br/><br/>        module.exports.processCheckout = (cognitoId, callback) =&gt; {<br/>          const iotdata = new AWS.IotData({<br/>            endpoint: 'YOUR_IOT_ENDPOINT'<br/>          }); <br/><br/>          const params = {<br/>            topic: 'serverless-store-' + cognitoId,<br/>            payload: 'Your payment was confirmed.'<br/>          };<br/><br/><strong>          iotdata.publish</strong>(params, (err, res) =&gt; {<br/>            if (err) utils.errorHandler(err, callback);<br/>            else utils.successHandler(res, callback);<br/>          });<br/>      };
</pre>
<p>Remember that the <kbd>userId</kbd> variable was retrieved in the previous chapter by analyzing the <kbd>event</kbd> object: <kbd>event.requestContext.authorizer.claims.sub</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how to create serverless notifications using the AWS IoT service. We covered how to implement a live comment system and push notifications for individual users. You already know how to use the AWS IoT Device SDK and how to use the IoT to trigger Lambda functions or to use a Lambda to send messages to an IoT endpoint.</p>
<p>In the next chapter, we will finish the online store, showing how to test our serverless application, followed by the definition of a deployment workflow for development and production environments, and we will finish off by showing what you can (and should) monitor in a serverless solution.</p>


            

            
        
    </body></html>