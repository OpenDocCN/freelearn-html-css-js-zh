<html><head></head><body>
		<div id="_idContainer096">
			<h1 id="_idParaDest-118"><em class="italic"><a id="_idTextAnchor130"/>Chapter 7</em>: Generating Content with Puppeteer</h1>
			<p>When I launched Puppeteer-Sharp (https://github.com/hardkoded/puppeteer-sharp) back in 2019, I was surprised to see that the two main use-case scenarios were content generation and web scraping. </p>
			<p>Things are not too different in the Node.js world. Lots of developers use Puppeteer in Node.js for content generation and web scraping as well.</p>
			<p>If you are a QA analyst, you will learn how to use screenshots to create regression tests. But, please, don't stop there; the other sections will give you a complete picture of everything you can do with Puppeteer on this topic. If you are not much into web development, share this chapter with your development team. No, don't share it – ask them to buy the book. That will be better.</p>
			<p>Web developers will love this chapter. We will see how to use Puppeteer as a content generator tool for your website.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Taking screenshots</li>
				<li>Using screenshots for regression tests</li>
				<li>Generating PDF files</li>
				<li>Creating HTML content</li>
			</ul>
			<p>By the end of this chapter, you will have gotten to a new level. You will have learned how to use Puppeteer as a testing tool and as a content generator.</p>
			<p>Let's get started.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor131"/>Technical requirements</h1>
			<p>You will find all the code of this chapter in the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter7</strong> directory. Remember to run <strong class="source-inline">npm install</strong> on that directory and then go to the <strong class="source-inline">Chapter7/vuejs-firebase-shopping-cart</strong> directory and run <strong class="source-inline">npm install</strong> again.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor132"/>Taking screenshots</h1>
			<p>Taking<a id="_idIndexMarker350"/> screenshots is the first feature I mention when I give talks about Puppeteer or Puppeteer-Sharp. Don't ask me why, maybe because I find it fun to use, or perhaps because it's hard to explain why we would need to take screenshots.</p>
			<p>As a web developer, there are many things you can accomplish using screenshots. The first popular use-case you'll find is to improve your <strong class="bold">Open Graph</strong> information.</p>
			<p>According to <a id="_idIndexMarker351"/>their website (https://ogp.me/), "<em class="italic">The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook."</em></p>
			<p>Open Graph is what <a id="_idIndexMarker352"/>will make social media posts (on Twitter or Facebook) look pretty when people share the URL of your site. We are not going to talk about product positioning on social media in this book. But what you need to know is that if you are working on a public site with users wanting to share your content on social media, someone will ask you to improve the open graph information:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_7.01_B16113.jpg" alt="A post with no Open Graph information&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A post with no Open Graph information</p>
			<p>You don't want your site to look like the preceding screenshot when you share your products on social media. You want your links to be like Amazon, with a nice description and a big image, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_7.02_B16113.jpg" alt="Amazon posts on social media&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Amazon posts on social media</p>
			<p>Adding an <a id="_idIndexMarker353"/>image to your posts is as easy as adding a meta property called <strong class="source-inline">og:image</strong> in the html head of your product page:</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">&lt;title&gt;The Rock (1996)&lt;/title&gt;</p>
			<p class="source-code">&lt;meta property="og:title" content="The Rock" /&gt;</p>
			<p class="source-code">&lt;meta property="og:type" content="video.movie" /&gt;</p>
			<p class="source-code">&lt;meta property="og:url" content="https://www.imdb.com/title/tt0117500/" /&gt;</p>
			<p class="source-code">&lt;meta property="og:image" content="https://ia.media-imdb.com/images/rock.jpg" /&gt;</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p>Those few lines will make your post look prettier on social media. </p>
			<p>What does this have to do with taking screenshots? Well, sometimes getting the image for a post is simple. In a shopping cart, the image would be the product image – a piece of cake. But sometimes, getting the image for a URL is not that easy. Let's take, for instance, this post from the great HolyJS conference:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_7.03_B16113.jpg" alt="HolyJS post&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">HolyJS post</p>
			<p>If you go to that post (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post">https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post</a>), you won't<a id="_idIndexMarker354"/> find the image used in that tweet. You will see Roman's photo, but you won't find the image with the photo, the conference logo, or the talk title. They might have created that image manually. You don't need great Photoshop skills to do that. But if you created hundreds of tweets for all the talks at the HolyJS conference, I bet it would be more productive to code a Puppeteer script in a few minutes.</p>
			<p>We could have an internal page that we would navigate by passing a talk ID. Once loaded, we take a screenshot, and we save that image in some kind of storage.</p>
			<p>But before getting into Puppeteer's code, let me show you a new tool. Do you know that you can take full-page screenshots using Chromium? </p>
			<p>If you open up the Developer Tools in <em class="italic">Chrome</em> and then press <em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">P</em> in macOS or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em>, a <strong class="bold">command menu list</strong> will pop up, just like in VS Code:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_7.04_B16113.jpg" alt="Taking screenshots using Chromium&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Taking screenshots using Chromium</p>
			<p>You will find<a id="_idIndexMarker355"/> tons of commands there. Do you want to have some fun? Open the 3D Viewer. I'll give you 3 minutes.</p>
			<p>OK, back to work. If you type <strong class="source-inline">screenshot</strong> in the <strong class="bold">command menu list</strong>, you will get four options.</p>
			<p>The first option is <strong class="bold">Capture area screenshot</strong>. This option works like the take screenshot area you have in macOS by pressing <em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">4</em> or the <strong class="bold">Rectangular snip</strong> in Windows's snipping tool. When you select that option, the cursor turns into a cross. You select the area you want to take a screenshot of, then you release the mouse and get an image download.</p>
			<p>The second option is <strong class="bold">Capture a full size screenshot</strong>. This feature is so cool that I would put this option in a huge font size, in bold, red, and italics, but I don't think my editor would let me. <strong class="bold">Capture a full size screenshot</strong> will take a screenshot of the entire page, even the parts off the screen. I remember other tools trying to accomplish this by taking several screenshots while scrolling the page, and the results were terrible. To be honest, I have heard of people having issues with this option, but generally speaking, the results are pretty good. You can use this tool for marketing purposes or for reporting bugs so that you can show the entire page.</p>
			<p>The third option is also fantastic. Now I don't know which one is my favorite. <strong class="bold">Capture node screenshot</strong> works with the <strong class="bold">Elements</strong> tab. You go to the <strong class="bold">Elements</strong> tab, select an element by clicking on it, then select the <strong class="bold">Capture node screenshot</strong> option, and you will get a screenshot of that element. This is way better than trying to select a section of the page with the capture area option.</p>
			<p>The last option<a id="_idIndexMarker356"/> is just <strong class="bold">Capture screenshot</strong>. It will capture the visible part of the page. Yes, I know, it sounds boring compared with the others, but it's still useful.</p>
			<p>I don't think I need to tell you the good news because you already know. We can do all these things with Puppeteer using the <strong class="source-inline">screenshot</strong> function.</p>
			<p>Both the <strong class="source-inline">Page</strong> class and the <strong class="source-inline">ElementHandle</strong> class have this function. If you call the <strong class="source-inline">screenshot</strong> function on an <strong class="source-inline">ElementHandle</strong>, you will use the <strong class="bold">Capture node screenshot</strong> option in Chrome.</p>
			<p>The function's signature is quite simple, just <strong class="source-inline">screenshot([options])</strong>, which means that just calling <strong class="source-inline">screenshot()</strong> would be enough. But the <strong class="source-inline">options</strong> object has many interesting properties. Let's take a look at them:</p>
			<ul>
				<li><strong class="source-inline">path</strong> is one of the most common properties you will use. If you pass a path, your screenshot will be saved there. Whether you pass the path or not, the resulting image will be returned by the <strong class="source-inline">screenshot</strong> function.</li>
				<li>With the <strong class="source-inline">type</strong> option, you can determine whether you want a <strong class="bold">jpeg</strong> or a <strong class="bold">png</strong> image. If you don't pass a <strong class="source-inline">type</strong>, Puppeteer will infer the type from the <strong class="source-inline">path</strong>. If you pass neither the <strong class="source-inline">type</strong> nor the <strong class="source-inline">path</strong>, it will default to <strong class="bold">png</strong>.</li>
				<li>If you set the type (whether using the <strong class="source-inline">type</strong> option or the <strong class="source-inline">path</strong> options) to <strong class="bold">jpeg</strong>, you can also pass a <strong class="source-inline">quality</strong> option. It has to be a value from 0 to 100. It will determine the quality of the <strong class="bold">jpeg</strong> image.</li>
				<li>Then we have <strong class="source-inline">fullPage</strong>. This option is a boolean option that will help us perform the <strong class="bold">Capture a full size screenshot</strong> action.</li>
				<li>The <strong class="source-inline">clip</strong> property is an object that will help us perform the <strong class="bold">Capture area screenshot</strong> action. It represents a square, an area, using four properties: <strong class="source-inline">x</strong> for the x-coordinate, <strong class="source-inline">y</strong> for the y-coordinate, and then <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> to determine the area's size.</li>
				<li>With the <strong class="source-inline">omitBackground</strong> property, you will be able to change the page's default (white) background to transparent.<p class="callout-heading">Important Note</p><p class="callout"><strong class="source-inline">omitBackground</strong> changes the default background of the page. If the page has a custom background, even a white background using <strong class="source-inline">background-color: white</strong>, or an image, this option won't work.</p></li>
				<li>The last<a id="_idIndexMarker357"/> property available is <strong class="source-inline">encoding</strong>, which will determine the return type of the <strong class="source-inline">screenshot</strong> function. If you pass <strong class="source-inline">base64</strong>, it will return a base64 string. If you pass <strong class="source-inline">binary</strong> or don't set any value, it will return a Node.js <strong class="source-inline">Buffer</strong> object.</li>
			</ul>
			<p>Time to see some code. Let's create a script and try to replicate the four options that Chrome offers. You will also be able to see this code in the <strong class="source-inline">screenshots.js</strong> file: </p>
			<p class="source-code">const browser = await puppeteer.launch({headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">await page.screenshot({ path: 'normal-only-viewport.png'});</p>
			<p class="source-code">await page.screenshot({ path: 'full-page.png', fullPage: true});</p>
			<p class="source-code">await page.screenshot({ </p>
			<p class="source-code">    path: 'clip.png', </p>
			<p class="source-code">    clip: { </p>
			<p class="source-code">        x: 300, </p>
			<p class="source-code">        y: 150, </p>
			<p class="source-code">        width: 286, </p>
			<p class="source-code">        height: 64</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p class="source-code">const firstBook = await page.$('.tombstone');</p>
			<p class="source-code">await firstBook.screenshot({ path: 'first-book.png'});</p>
			<p>We can see the <a id="_idIndexMarker358"/>four actions expressed in the code. If we pass only the <strong class="source-inline">path</strong>, we <strong class="bold">Capture screenshot</strong>. Then, if we set <strong class="source-inline">fullPage</strong> to true, we will get <strong class="bold">Capture full size screenshot</strong>. If, instead of passing <strong class="source-inline">fullPage</strong>, we pass a <strong class="source-inline">clip</strong>, we'll get <strong class="bold">Capture area screenshot</strong>. Finally, based on the <strong class="source-inline">ElementHandle</strong> we get from <strong class="source-inline">page.$('.tombstone')</strong>, we get <strong class="bold">Capture node screenshot</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Finding the right <strong class="source-inline">clip</strong> will be quite tricky. Pages change their layout based on the window size, which might break the fixed position you are trying to use. I would recommend trying to capture node screenshots instead of using a <strong class="source-inline">clip</strong>. If there is no element you can use, I would try to build the <strong class="source-inline">clip</strong> based on other elements' positions.</p>
			<p>I bet web developers will find more use cases for the screenshot feature. But if you are a QA analyst, we will now learn how to use screenshots to perform UI regression tests.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor133"/>Using screenshots for regression tests</h1>
			<p>We briefly<a id="_idIndexMarker359"/> talked <a id="_idIndexMarker360"/>about UI regression tests in <a href="B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Automated Testing and Test runners</em>. Now it's time to get practical. First, let's recap the concept of <strong class="bold">regression</strong>. Regression is something you hear a lot when you see bug reports. If a user says something like "I found a regression in X feature," they mean that something that was working before in a certain way has now changed. It might be a bug, an error in the app, or an unreported change of behavior.</p>
			<p>We can say that a UI regression is when we detect that a page or component has changed visually. I want to be emphatic again. It might have changed due to a bug or an unreported change of style.</p>
			<p>To prove a regression, you need evidence. Until now, we were testing behavior, and our evidence was the code: "If I input the user, the password, and then I click on the login button, I should get logged in."</p>
			<p>To prove a<a id="_idIndexMarker361"/> UI regression, our <a id="_idIndexMarker362"/>evidence will be <strong class="bold">screenshots</strong>. A UI regression test<a id="_idIndexMarker363"/> would consist of the following steps:</p>
			<ol>
				<li>The first thing we need to do is take a screenshot of the current state.</li>
				<li>The first time we run a test, we have nothing to compare our screenshot to. We have no history, no evidence. We have nothing to test. But now, we have the evidence for the next run.</li>
				<li>If we have evidence, we will compare our current screenshot with the baseline, and we will fail if the images are different.</li>
			</ol>
			<p>That's it. Simple. But what happens when we have a difference? When we get a test fail in end-to-end tests, we would first see if it's an error in our test. If our tests are working as expected, that failure will end up in a bug report.</p>
			<p>But with UI regression tests, that's a little bit different. We would need to evaluate the results to check if we found an error or if <strong class="bold">the baseline has changed</strong>. We get UI changes in pages all the time, so we need to see if they are desired changes or not. If a change was desired, we would need to delete our baseline and create a new baseline image.</p>
			<p>That's our cake. Now, what tools do we need to bake that cake? And also, what are our requirements for those tools? We need four elements:</p>
			<ul>
				<li>A <strong class="bold">test runner</strong>. We already talked about what we need from a test runner, and we saw that Mocha and Jest meet our expectations.</li>
				<li>A <strong class="bold">screenshot taker</strong>. The screenshot taker needs to be stable. By stable, I mean that it needs to return the same screenshot under the same circumstances all the time. It sounds obvious, but UI regression tests are the king of flaky tests. We need a tool that provides the same screenshots consistently. Puppeteer is great for this.</li>
				<li>A <strong class="bold">place to store baselines</strong>. We are not talking about a tool here. But we need files to be organized so that it's easy to find and remove baselines and find the resulting comparisons.</li>
				<li>A <strong class="bold">tool to compare images</strong>. This tool is as important as the screenshot taker. We don't<a id="_idIndexMarker364"/> want false alarms. We don't need a tool that tells <a id="_idIndexMarker365"/>us that everything is wrong just because one pixel is not the exact same white as the baseline. This tool should allow us to pass some kind of threshold to determine how sensitive we want it to be to changes. It should also need to support anti-aliased pixels to reduce the difference in the image rendering. <em class="italic">Pixelmatch</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch">https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch</a>) is <a id="_idIndexMarker366"/>the most popular image comparison package for Node.js.</li>
			</ul>
			<p>As you can see, it shouldn't be that hard implementing that. But many tools on the market solve all that boilerplate for us. Again, it's not about me telling you what's the best tool. You have to look for the right tool for you. I found <a id="_idIndexMarker367"/>that <em class="italic">Project Awesome</em> (<a href="http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing">http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing</a>) has a huge list of regression testing tools. On that site, I<a id="_idIndexMarker368"/> found <em class="italic">differencify</em> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/differencify">https://www.hardkoded.com/ui-testing-with-puppeteer/differencify</a>). I like it because it's simple and covers all the requirements mentioned in the preceding list. I don't like much that it's a layer between Puppeteer and us, but it does the job; I can live with that.</p>
			<p>We can create a test called <strong class="source-inline">"Should visually match"</strong>, and use differencify there. You can find this test in the <strong class="source-inline">homepage.tests.js</strong> file. Let's see how to implement it: </p>
			<p class="source-code">it ('Should visually match', async() =&gt; {</p>
			<p class="source-code">  const target = differencify.init({ </p>
			<p class="source-code">    chain: false, </p>
			<p class="source-code">    testName: 'Home' });</p>
			<p class="source-code">  await target.launch();</p>
			<p class="source-code">  const page = await target.newPage();</p>
			<p class="source-code">  await page.setViewport({ width: 1600, height: 1200 });</p>
			<p class="source-code">  await page.goto(config.baseURL);</p>
			<p class="source-code">  const image = await page.screenshot();</p>
			<p class="source-code">  const result = await target.toMatchSnapshot(image);</p>
			<p class="source-code">  await page.close();</p>
			<p class="source-code">  await target.close();</p>
			<p class="source-code">  expect(result).to.be.true;</p>
			<p class="source-code">});</p>
			<p>It looks pretty <a id="_idIndexMarker369"/>much like a normal Puppeteer test. But there are<a id="_idIndexMarker370"/> some differences. Let's take a look at them:</p>
			<p>It begins by declaring a variable named <strong class="source-inline">target</strong> and assigning to it the result of <strong class="source-inline">differencify.init</strong>. We won't get into the internals of <em class="italic">differencify</em>, because we don't care about the internals. The only thing important in that <strong class="source-inline">init</strong> call is that we are setting the test name there, which, as we will see later, will be used to name the images.</p>
			<p>After that, it looks like pure Puppeteer code, except that we call <strong class="source-inline">target.launch();</strong> instead of <strong class="source-inline">puppeteer.launch();</strong>.</p>
			<p>One important thing we need to do when taking screenshots is setting the <strong class="bold">viewport</strong>. The viewport will determine the size of the screenshot we will use. Even if you take a full-page screenshot, the viewport will determine that image's width.</p>
			<p>Unless you want to check a page's style after specific actions, UI regression tests will just go to a page, wait for the page to be loaded and stable, and take a screenshot. By stable, I mean that you don't want to take a screenshot with half of the resources, for example, images still loading.</p>
			<p>Once the page is loaded, we take a screenshot using <strong class="source-inline">page.screenshot()</strong> and then call <strong class="source-inline">await target.toMatchSnapshot(image)</strong>. This function will be responsible for creating a baseline image if it doesn't exist, and if it exists, make the image comparison. </p>
			<p>When we run the test for the very first time, the test will pass because, again, there is no baseline. One important thing we will notice is that <em class="italic">differencify</em> created the baseline inside a <strong class="source-inline">differencify_reports</strong> directory. You can see the complete directory structure inside the <strong class="source-inline">Chapter7/differencify_reports</strong> directory.</p>
			<p>Now we have our baseline. Hopefully, this test will be green unless something changes on that page. Let's try to break it. We will open the <strong class="source-inline">vuejs-firebase-shopping-cart/src/components/Header.vue</strong> file and change the <strong class="source-inline">color .navbar-btn</strong> elements to blue:</p>
			<p class="source-code">.navbar-btn {</p>
			<p class="source-code">  color: blue;</p>
			<p class="source-code">}</p>
			<p>This is a typical<a id="_idIndexMarker371"/> scenario of a UI regression test. Maybe you wanted to <a id="_idIndexMarker372"/>change the color of a button on the login page, and you didn't realize that the <strong class="source-inline">navbar-btn</strong> class was also being used on the home page.</p>
			<p>If we run the test, we will get the following output, telling us that the test has failed:</p>
			<p class="source-code">  1) Home Page</p>
			<p class="source-code">       Should visually match:</p>
			<p class="source-code">      AssertionError: expected false to be true</p>
			<p class="source-code">      + expected - actual</p>
			<p class="source-code">      -false</p>
			<p class="source-code">      +true</p>
			<p>That doesn't say much. It just simply says that the image is not the same. But if we go to the <strong class="source-inline">differencify_reports</strong> directory, we will see that <em class="italic">differencify</em> created two new files: <strong class="source-inline">Home 1.current.png</strong> under <strong class="source-inline">differencify_reports/__image_snapshots__/__current_output__</strong>, which shows the latest screenshot. The second image is <strong class="source-inline">Home 1.differencified.png</strong> under <strong class="source-inline">differencify_reports/__image_snapshots__/__differencified_output__</strong>. You can see the differencified image inside the directory mentioned above or following the link <a href="https://www.hardkoded.com/ui-testing-with-puppeteer/differencified">https://www.hardkoded.com/ui-testing-with-puppeteer/differencified</a> will show us where the changes were detected. In this case, you will see that it highlighted the word "<strong class="bold">Checkout</strong>". We can now compare the baseline image with the one created in the <strong class="source-inline">__current_output__</strong> directory and evaluate what went wrong.</p>
			<p>To wrap up this section, UI regression tests are not for every project. If you use CSS frameworks like <strong class="bold">bootstrap</strong> or <strong class="bold">tailwindcss</strong> the chances of UI regressions are low. There are also <a id="_idIndexMarker373"/>projects where the page style is not considered a bug. Stakeholders <a id="_idIndexMarker374"/>won't care if a box is a few pixels below.</p>
			<p>I do think it's an excellent tool for frontend developers working on custom CSS. With UI regression tests, a frontend developer can measure the impact of their changes. It's like unit tests for CSS.</p>
			<p>In the next chapter, we are going to talk about device emulation. With device emulation plus UI regression tests, you will be able to check how your site looks on mobile devices.</p>
			<p>Now it's time to learn another way to generate content with Puppeteer. Time to generate PDF files.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor134"/>Generate PDF files</h1>
			<p>We are out of QA land, and <a id="_idIndexMarker375"/>we'll go into the development world again.</p>
			<p>When I talk about PDF generation, I get the same question I mentioned in the screenshot section: "Why would I need to generate PDFs using Puppeteer?"</p>
			<p>The first scenario to mention is using PDFs as an output format for your website. I don't know if you've lived what I lived once. I had to build an e-commerce app. I built the product list, the checkout process, and even the receipt page. Then the requirement came out: "We need to send an email with that receipt as a PDF." That's an estimation breaker. There is no easy way to create PDF files just from scratch.</p>
			<p>Then you find a library that generates PDFs, and you are happy with it. But the stakeholders tell you that it needs to look exactly like the receipt page. Your estimation goes to the trash again. There should be an easy way to generate PDF files.</p>
			<p>Maybe it's not a receipt. Haven't you ever got a request to send a daily report by email as a PDF? You would end up using some huge, complex, and expensive reporting tool, just for that daily email.</p>
			<p>The second scenario is PDF files as a product by themselves. Do you sell documents? Finance reports? You can autogenerate that content using PDF generation tools.</p>
			<p>I bet you already know that<a id="_idIndexMarker376"/> you can save any page as a PDF file using Chrome's print tool:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_7.05_B16113.jpg" alt="Save as PDF in Chrome&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Save as PDF in Chrome</p>
			<p>You can go to any page, hit <em class="italic">Cmd</em> + <em class="italic">P</em> or <em class="italic">Ctrl</em> + <em class="italic">P</em>, and instead of selecting a real printer, you choose <strong class="bold">Save as PDF</strong>. Then you click <strong class="bold">Save</strong>, and you get your PDF.</p>
			<p>I think I don't need to tell you this, but as you might have guessed, Puppeteer uses this same utility to generate PDF files.</p>
			<p>There is something essential you need to know. If you know this, you will be able to answer lots of questions in Stack Overflow. Here goes: <strong class="bold">PDF generation doesn't work as a screenshot but as a print action</strong>.</p>
			<p>It might sound obvious, now<a id="_idIndexMarker377"/> that we've seen that <strong class="bold">Print</strong> dialog. But it's important for you to know that the viewport (the window size) won't determine how the PDF will be generated. The page size will determine that.</p>
			<p>Designers and frontend developers can determine how a page should be printed using the media query print (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries">https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries</a>).</p>
			<p>Let's see how you can change a page style using <strong class="source-inline">@media print</strong>:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">    &lt;head&gt;</p>
			<p class="source-code">        &lt;style&gt;</p>
			<p class="source-code">            body {</p>
			<p class="source-code">                color: blue;</p>
			<p class="source-code">                font-size: 16px;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            @media print {</p>
			<p class="source-code">                body{</p>
			<p class="source-code">                    color: black;</p>
			<p class="source-code">                    font-size: 32px;</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        &lt;/style&gt;</p>
			<p class="source-code">    &lt;/head&gt;</p>
			<p class="source-code">    &lt;body&gt;</p>
			<p class="source-code">        Hello world;</p>
			<p class="source-code">    &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>As we can see, if you browse this HTML content (you will find this code as <strong class="source-inline">mediaprint.html</strong> in the repository), you will find that "<strong class="source-inline">Hello world</strong>" is rendered in blue with a size of 16px. But if you hit <strong class="source-inline">print</strong>, the browser will add all the CSS style from the <strong class="source-inline">@media print</strong> section, changing the font size to 32px and the color to black. In the next section, we will learn how to add print styles if the page has none. For now, what you need to know is that we are printing content.</p>
			<p>If the <strong class="source-inline">@media print</strong> style used in the page doesn't work for you, there is a way to bypass this functionality. You can force the media type <strong class="source-inline">screen</strong> using the following code:</p>
			<p class="source-code">page.emulateMediaType('screen')</p>
			<p>If you call <strong class="source-inline">emulateMediaType</strong> before generating the PDF, <strong class="source-inline">@media print</strong> will be ignored by the browser.</p>
			<p>I don't think I need to<a id="_idIndexMarker378"/> tell you that the function we will use to generate PDF files is called <strong class="source-inline">page.pdf</strong>. Unlike <strong class="source-inline">screenshot</strong>, there is no <strong class="source-inline">elementHandle.pdf</strong> because you can't print just an element.</p>
			<p>The signature is simple, just <strong class="source-inline">page.pdf([options])</strong>, but we have many available options. Let's begin with the options that map the settings you would find in the print dialog.</p>
			<p>The first option you will see in the print dialog after selecting <strong class="bold">Save as PDF</strong>, is the <strong class="bold">Layout</strong>. The option to set the layout is <strong class="source-inline">landscape</strong>. It's a boolean that will tell the browser if you want to generate the PDF with a landscape orientation or not.</p>
			<p>The next option is <strong class="bold">Pages</strong>. In Puppeteer, the property is <strong class="source-inline">pageRanges</strong>. It's a string where you can pass things like <strong class="source-inline">'1-5, 8, 11-13'</strong>. If you don't set this property, it will work as if you had set <strong class="bold">Pages</strong> to <strong class="bold">All</strong> in the print dialog.</p>
			<p>If you click <strong class="bold">More settings</strong> in the print dialog, the next option available will be <strong class="bold">Paper size</strong>. In Puppeteer, it will be <strong class="source-inline">format</strong>, which is a string that accepts the following options:</p>
			<ul>
				<li><strong class="source-inline">Letter</strong>: 8.5 in x 11 in</li>
				<li><strong class="source-inline">Legal</strong>: 8.5 in x 14 in</li>
				<li><strong class="source-inline">Tabloid</strong>: 11 in x 17 in</li>
				<li><strong class="source-inline">Ledger</strong>: 17 in x 11 in</li>
				<li><strong class="source-inline">A0</strong>: 33.1 in x 46.8 in</li>
				<li><strong class="source-inline">A1</strong>: 23.4 in x 33.1 in</li>
				<li><strong class="source-inline">A2</strong>: 16.54 in x 23.4 in</li>
				<li><strong class="source-inline">A3</strong>: 11.7 in x 16.54 in</li>
				<li><strong class="source-inline">A4</strong>: 8.27 in x 11.7 in</li>
				<li><strong class="source-inline">A5</strong>: 5.83 in x 8.27 in</li>
				<li><strong class="source-inline">A6</strong>: 4.13 in x 5.83 in</li>
			</ul>
			<p>Puppeteer also offers two extra options: <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>. If none of those formats suit you, you can set custom dimensions with these two properties. These properties accept a number or a<a id="_idIndexMarker379"/> string. If you use strings, you can pass values in units, such as <strong class="bold">px</strong> for pixels, <strong class="bold">in</strong> for inches, <strong class="bold">cm</strong> for centimeters, or <strong class="bold">mm</strong> for millimeters.</p>
			<p>Next up is <strong class="bold">Scale</strong>. The property is <strong class="source-inline">scale</strong>, and it's the zoom that will be used to print the page. You will see it in the print dialog as a percentage from 10% to 200%. Here, it will be a decimal value from 0.1 to 2.</p>
			<p>After <strong class="bold">Scale</strong>, you will find <strong class="bold">Pages per sheet</strong>. We don't have that setting in Puppeteer.</p>
			<p>The next option in the <strong class="bold">Print</strong> dialog is <strong class="bold">Margins</strong>. The <strong class="bold">Print</strong> dialog offers a few fixed options. In Puppeteer, the <strong class="source-inline">margin</strong> option is an object with four properties:</p>
			<ul>
				<li><strong class="source-inline">top</strong></li>
				<li><strong class="source-inline">right</strong></li>
				<li><strong class="source-inline">bottom</strong></li>
				<li><strong class="source-inline">left</strong></li>
			</ul>
			<p>All these properties accept a number or a string, supporting units as <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> do.</p>
			<p>After the margins, the print dialog offers an extra set of options. The first one is Headers and footers. This is a really fun feature in Puppeteer. Puppeteer not only provides a <strong class="source-inline">displayHeaderFooter</strong> boolean property, but it also provides a <strong class="source-inline">headerTemplate</strong> property and a <strong class="source-inline">footerTemplate</strong> property. That means that you can set what you want the <a id="_idIndexMarker380"/>header and the footer to look like. Puppeteer will even populate elements with the following classes:</p>
			<ul>
				<li><strong class="source-inline">date</strong>: Formatted print date</li>
				<li><strong class="source-inline">title</strong>: Document title</li>
				<li><strong class="source-inline">url</strong>: Document location</li>
				<li><strong class="source-inline">pageNumber</strong>: Current page number</li>
				<li><strong class="source-inline">totalPages</strong>: Total pages in the document</li>
			</ul>
			<p>The next option is <strong class="bold">Background graphics</strong>. You can turn this option on with the <strong class="source-inline">printBackground</strong> property. It will tell the browser that you want to print background graphics. This is <strong class="source-inline">false</strong> by default because this option is intended for printers, and you don't want to waste your toner on a background. But you should consider whether this is something you need to turn on. Let's consider Wikipedia:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_7.06_B16113.jpg" alt="Wikipedia without the background graphics checked&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Wikipedia without the background graphics checked</p>
			<p>As you can see, the Wikipedia title is missing if you don't check the <strong class="bold">Background graphics</strong> checkbox because it's the background image of a <strong class="source-inline">SPAN</strong> element. If you don't know about this flag, you might be scratching your head for several minutes, trying to see what's wrong with your code. Now you know that you have to consider <strong class="source-inline">printBackground</strong>.</p>
			<p>There is one option that<a id="_idIndexMarker381"/> you won't see in the print dialog, and it's <strong class="source-inline">preferCSSPageSize</strong>. This property, whose default is false, will tell the browser to honor the <strong class="source-inline">@page size</strong> declared on the page over <strong class="source-inline">width</strong>/<strong class="source-inline">height</strong> or page <strong class="source-inline">format</strong>. Developers can use <strong class="source-inline">@page size</strong> (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize">https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize</a>) to set the preferred page size when the page is printed.</p>
			<p>The last option is the most important. The function's output works in the same way as in the <strong class="source-inline">screenshot</strong> function. If you set the <strong class="source-inline">path</strong> property, a file will be generated in that path. Either way, the function's return value will be a Buffer (https://nodejs.org/api/buffer.html) with the binary representation of the PDF file.</p>
			<p>Time to take a look at some<a id="_idIndexMarker382"/> code. In the following code, which you can see in the <strong class="source-inline">pdfdemo.js</strong> file, we are going to print www.wikipedia.org using the options we have learned:</p>
			<p class="source-code">const browser = await puppeteer.launch({</p>
			<p class="source-code">    headless: true,</p>
			<p class="source-code">    defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://www.wikipedia.org/');</p>
			<p class="source-code">await page.pdf({</p>
			<p class="source-code">    path: './headers.pdf',</p>
			<p class="source-code">    printBackground : true,</p>
			<p class="source-code">    displayHeaderFooter : true,</p>
			<p class="source-code">    headerTemplate: `</p>
			<p class="source-code">        &lt;span style="font-size: 12px;"&gt;</p>
			<p class="source-code">            This is a custom PDF for </p>
			<p class="source-code">            &lt;span class="title"&gt;&lt;/span&gt; (&lt;span class="url"&gt;&lt;/span&gt;)</p>
			<p class="source-code">        &lt;/span&gt;`,</p>
			<p class="source-code">    footerTemplate: `</p>
			<p class="source-code">        &lt;span style="font-size: 12px;"&gt;</p>
			<p class="source-code">            Generated on: &lt;span class="date"&gt;&lt;/span&gt;&lt;br/&gt;</p>
			<p class="source-code">            Pages &lt;span class="pageNumber"&gt;&lt;/span&gt; of &lt;span class="totalPages"&gt;&lt;/span&gt;</p>
			<p class="source-code">        &lt;/span&gt;`,</p>
			<p class="source-code">    margin:{ </p>
			<p class="source-code">        top:'100px', </p>
			<p class="source-code">        bottom: '100px'</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p class="source-code">await browser.close();</p>
			<p>The first thing to notice in this piece of code is that the <strong class="source-inline">pdf</strong> function only works in headless mode. If you call <strong class="source-inline">pdf</strong> while in headful, you will get an <strong class="bold">Error: Protocol error (Page.printToPDF): PrintToPDF is not implemented</strong>.</p>
			<p>The second thing to <a id="_idIndexMarker383"/>notice is that you need to set up a margin if you want to use footer and header templates. In my personal experience, I wouldn't use very complex templates here. Things can get nasty and hard to debug.</p>
			<p>The last thing to mention in the code is the CSS classes used in the template. As you can see, I'm leaving empty SPANs like <strong class="source-inline">&lt;span class="title"&gt;&lt;/span&gt;</strong> so the browser can replace them with real data.</p>
			<p>This code will generate the following <strong class="source-inline">headers.pdf</strong> file:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_7.07_B16113.jpg" alt="PDF output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">PDF output</p>
			<p>As you can see, we now have a custom header with a title and URL, a custom footer with the date and <a id="_idIndexMarker384"/>the pages, and, as we set <strong class="source-inline">printBackground</strong>, we are getting the Wikipedia logo. </p>
			<p>You might think that's it, but it's not. We have one more way to generate content. We will build our own pages on the fly.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor135"/>Creating HTML content</h1>
			<p>In this section, we will <a id="_idIndexMarker385"/>see a few simple features but pretty useful ones. You will be able to follow the code from this section in the <strong class="source-inline">demohtml.js</strong> file. Most of the time, you navigate pages using the HTTP protocol as we did with Wikipedia. If you open the <strong class="source-inline">mediaprint.html</strong> file, you navigated to that page using the pseudo protocol "file." Although it's not a real protocol, you should know that with Puppeteer, you can also navigate local files using a URL such as file:///some/folder/of/my/computer/mediaprint.html.</p>
			<p>So, if you want to generate a social image, like the HolyJS conference one we saw in the first section, you could create a page on your website, navigate to that page using Puppeteer, take a screenshot, and use that image in your social post.</p>
			<p>You could also have that file stored locally and navigate that file using the <strong class="source-inline">file:// </strong>protocol.</p>
			<p>What I want to show you in this section is that you don't necessarily need to have a file in your file system to generate that social image. You could have the HTML that you need in some external source, for instance, a content database, load that HTML in an empty page, and then take a screenshot.</p>
			<p>We can do that using the <strong class="source-inline">setContent</strong> function. The signature is quite simple: <strong class="source-inline">page.setContent(html[, options])</strong>, where <strong class="source-inline">html</strong> is the HTML to load, and the <strong class="source-inline">options</strong> object, which supports two options you might already know: <strong class="source-inline">timeout</strong> and <strong class="source-inline">waitUntil</strong>. We need a <strong class="source-inline">timeout</strong> and a <strong class="source-inline">waitUntil</strong> property because the HTML we are loading might involve network requests, and we would need to wait for them.</p>
			<p>Let's say we are assigned the task of creating that social media post. The content team tells us that we need to use the content <strong class="source-inline">socialPostTemplate</strong> from the <strong class="source-inline">contentdb</strong> component. We could do something like this:</p>
			<p class="source-code">const puppeteer = require('puppeteer');</p>
			<p class="source-code">const content = require('./contentdb');</p>
			<p class="source-code">(async () =&gt; {</p>
			<p class="source-code">    const browser = await puppeteer.launch({</p>
			<p class="source-code">    headless: true,</p>
			<p class="source-code">    defaultViewport: null});</p>
			<p class="source-code">    const page = await browser.newPage();</p>
			<p class="source-code">    await page.setContent(content.socialPostTemplate);</p>
			<p class="source-code">    await page.screenshot({path:'fromhtml.png'});</p>
			<p class="source-code">    await browser.close();</p>
			<p class="source-code">})();</p>
			<p>We load <strong class="source-inline">contentdb</strong> using<a id="_idIndexMarker386"/> the <strong class="source-inline">require</strong> function. Then we call <strong class="source-inline">newPage</strong>, which will give us an empty canvas, the <strong class="source-inline">about:blank</strong> page. Once we have the empty canvas, we load the HTML using <strong class="source-inline">setContent</strong>, take the screenshot, and close the page.</p>
			<p>Once you call <strong class="source-inline">setContent</strong>, the page will be fully functional. That means that you could even call the <strong class="source-inline">evaluate</strong> function to customize and populate that template's values.</p>
			<p>One thing to consider is that the <strong class="source-inline">setContent</strong> function will override all the page content. You won't be able to append content using <strong class="source-inline">setContent</strong>.</p>
			<p>Two more functions will come in handy while creating new content. The first one is <strong class="source-inline">page.addScriptTag(options)</strong>, which will allow you to inject script tags into any page. These are the options available:</p>
			<ul>
				<li>You can pass <strong class="source-inline">url</strong>, to inject a JavaScript file from a URL.</li>
				<li>You can also use <strong class="source-inline">path</strong> to inject a JavaScript file from a local file.</li>
				<li>If you have the script in a memory variable, you can use <strong class="source-inline">content</strong> and set the entire script there.</li>
				<li>Finally, you can pass <strong class="source-inline">type</strong>, which is the script type you can set to a script element (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement">https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement</a>).</li>
			</ul>
			<p>You can use these two functions when you want to inject new functionality that wouldn't be solved with just an <strong class="source-inline">evaluate</strong> function call.</p>
			<p>We also have <strong class="source-inline">page.addStyleTag(options)</strong>. It's just like <strong class="source-inline">addScriptTag</strong>, but instead of injecting a script, you can inject a CSS file or content. The <strong class="source-inline">addStyleTag</strong> function has the same options as <strong class="source-inline">addScriptTag</strong>, except for the <strong class="source-inline">type</strong> option, which is not a valid option of the link element used to add CSS files. If we go back to PDF generation, you can use the<a id="_idIndexMarker387"/> following code to inject CSS content before generating a PDF file:</p>
			<p class="source-code">await page.addStyleTag({</p>
			<p class="source-code">    content : `</p>
			<p class="source-code">    .search-input {</p>
			<p class="source-code">        display: none !important;</p>
			<p class="source-code">    }`</p>
			<p class="source-code">});</p>
			<p class="source-code">await page.pdf({…});</p>
			<p>With this piece of code, we are hiding the search input before generating the PDF. This is a relatively simple change, but imagine all the things you would be able to set up in real-life scenarios.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we covered many of my favorite features. Creating content is an unexpected use for a browser automation tool.</p>
			<p>We learned how to generate screenshots, use them for UI regression testing, and generate content for our websites. We also learned how to generate PDF files and all the options available. By the end of the chapter, we learned how to generate pages on the fly.</p>
			<p>During this chapter, we also saw many features available in Chrome. I hope you learned some new tricks there.</p>
			<p>In the next chapter, we will take our tests to the next level. We will learn how to test our websites by emulating different mobile devices and network conditions.</p>
		</div>
	</body></html>