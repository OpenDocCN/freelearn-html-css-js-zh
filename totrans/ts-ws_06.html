<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-109">5. <a id="_idTextAnchor125"/>Interfaces and Inheritance</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to interfaces and inheritance. You will learn how to use an interface to shape your classes, objects, and functions. You will also gain an appreciation of how interfaces will help you to write better code. By the end of this chapter, you will be able to write better, more maintainable code with well-structured functions, classes, and objects, and also be able to reuse your existing code efficiently.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor126"/><a id="_idTextAnchor127"/><a id="_idTextAnchor128"/><a id="_idTextAnchor129"/>Introduction</h1>
			<p>The previous chapter discussed classes and objects. You learned that classes define objects and their functionality. Classes are the blueprint followed while constructing these objects. Now, we will go up one level of abstraction. We are now going to construct interfaces. Interfaces are descriptors and allow you to define the structure of your object. Interfaces allow you to define contracts, which are rules that govern how your data is shaped. </p>
			<p>Interfaces are important because they enable your objects to be strongly typed, which gives you the ability to write cleaner code. Defining the shape of your objects may not be much of an issue with smaller applications, but when working with large applications, interfaces will prove their worth as they will make it possible for your application to scale without your code becoming confusing and hard to support. </p>
			<p>Inheritance allows new objects to take the properties of existing objects, enabling you to extend your code functionality without having to redefine common properties. Inheritance will give you a better understanding of how you should structure your code to be more efficient and logical in your approach. This chapter will first address interfaces and equip you with the skills you need to use them and will then progress onto the topic of inheritance.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor130"/>Interfaces</h1>
			<p>Here we have an example of a simple interface that defines the shape of a user object:</p>
			<pre>interface UserInterFace {
    email: string,
    token: string,
    resetPassword: ()=&gt; boolean   
}</pre>
			<p>In the preceding code, we have defined an interface that we can implement on any object that should follow rules defined in our interface. The advantage this gives us over other web languages such as vanilla JavaScript is that all objects that implement this interface have to follow the structure defined by the interface. This means that our objects are now strongly typed and have language support such as syntax highlighting, autocompletion, and the throwing of exceptions when implemented incorrectly. If you are a developer working on a large application, this is very important as you have defined the rules and can now be sure that all the objects that implement <code>UserInterFace</code> will have the same properties as those defined in the interface. </p>
			<p>Here is an example of an object that implements the <code>UserInterface</code> interface:</p>
			<pre>const User: UserInterFace = {
    email: 'home@home.com',
    token: '12345678',
    resetPassword(): boolean{
        return true
    }
}</pre>
			<p>As you can see in the preceding example, we are now able to implement an object that adheres to the guidelines defined in the <code>UserInterFace</code> interface. When working with large teams or on complex web applications, it is important to have transparent, well-understood rules for your code.</p>
			<p>Interfaces allow for the creation of a common point of reference for your objects, a place where rules are defined on how objects should be constructed. In the following section, we will cover in-depth interfaces in TypeScript.</p>
			<p><a id="_idTextAnchor131"/>Interfaces are used when you want to set up rules for how your objects, classes, and functions should be implemented. They are a contract that governs structure but not functionality. Here we have a diagram that shows an interface and its relationship to two classes – <code>User</code> and <code>Admin</code>:</p>
			<div><div><img src="img/B14508_05_01.jpg" alt="Figure 5.1: Relation between interface and classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Relation between interface and classes</p>
			<p>In the diagram, we have a user interface that describes how a class belonging to this interface should be implemented. As you can see, we have a few properties (highlighted code in User Interface) and methods provided in two classes. The interface provides only basic information for the property's name, type, method structures, and return types, if not void. Note that the interface provides no rules related to how the methods work, only how they are structured. The actual functionality of the methods is defined in the class itself. As stated earlier, interfaces in TypeScript give you the rules and you implement them as you see fit. This is evident from the preceding diagram. The <code>AdminUser</code> class has a method not defined in <code>UserInterface</code>; however, this is not an issue because the class is in compliance with all the elements of the interface. There is no rule that says that you cannot add to your class, only that you need to meet the requirements of the interface that your class implements.</p>
			<h2 id="_idParaDest-112">C<a id="_idTextAnchor132"/>ase Study – Writing Your First Interface</h2>
			<p>Imagine you are working with an application development team building an application for warehouse floor workers. You have the task of building the product creation classes and functions. You have developed a plan for your classes based on the functional requirements of your application. You start by creating a product interface called <code>ProductTemplate</code>. <code>ProductTemplate</code> defines the structure of our product object and base requirements. Note that we could also use a type object in the same way, and it may be preferable since this is a simple object, not a class, which could not be represented by a type. However, for the sake of this example and also to enlighten you to the fact that interfaces can also be used as types when defining a simple object, we have constructed the <code>ProductTemplate</code> interface: </p>
			<pre>Example_Interface_1.ts
1 //first interface
2 interface ProductTemplate {
3     height: number
4     width: number
5     color: string
6 }
Link to the preceding example: <a href="https://packt.link/wYJis">https://packt.link/wYJis</a>.</pre>
			<p>When defining an interface, we start with the interface keyword, followed by the name of our interface, <code>ProductTemplate</code>, as shown in the preceding snippet. We have three properties that our product requires – height, width, and color. Now that we have described what our product data should look like, let's use it:</p>
			<pre>7 //make product function
8 const productMaker = (product: ProductTemplate) =&gt; {
9     return product
10 }</pre>
			<p>We have built a function, <code>productMaker</code>, that takes a product object as an argument. To ensure that only objects with the properties required by our <code>productMaker</code> function get passed to the function, we use our <code>ProductTemplate</code> interface, as shown in the preceding snippet. Now, all we need to do is define our product object; we will use our interface there as well:</p>
			<pre>11 // implement interface
12 const myProduct: ProductTemplate = {
13     height: 10,
14     width: 12,
15     color: 'red',
16 }</pre>
			<p>We have declared a product object, <code>myProduct</code>, with our <code>ProductTemplate</code> interface and added the properties required by our interface. Using the interface in this way ensures that we are fully compliant when creating the product object. Now, if we add a property not defined or remove a property that is defined in our <code>ProductTemplate</code> interface, the IDE and or TypeScript compiler will throw a helpful error message. IDE highlighting will depend on your IDE and the level of support for TypeScript. VS Code should highlight the following error messages for the preceding two scenarios.</p>
			<p>The following error message appears when you add a property length that is not defined in the interface:</p>
			<pre>(property) length: number
Type '{ height: number; width: number; color: string; length: number; }' is not assignable to type 'ProductTemplate'.
  Object literal may only specify known properties, and 'length' does not exist in type 'ProductTemplate'.ts(2322)</pre>
			<p>The following error message appears when you don't use the color property, which is defined in the interface:</p>
			<pre>const myProduct: ProductTemplate
Property 'color' is missing in type '{ height: number; width: number; }' but required in type 'ProductTemplate'.ts(2741)
Example_Interface.ts(5, 5): 'color' is declared here.</pre>
			<p>Now that we have our product object, let's pass it to our productMaker function:</p>
			<pre>// call the function using console log to show the output
console.log(productMaker(myProduct));</pre>
			<p>Once you run the file using <code>npx</code> <code>ts-node</code> <code>Example_Interface.ts</code>, you will obtain the following output:</p>
			<pre>{ height: 10, width: 12, color: 'red' }</pre>
			<p>This is the ideal scenario. But what would happen if you pass an object that does not comply with the <code>ProductTemplate</code> interface? Consider the following code representing this scenario:</p>
			<pre>const myBadProduct = {
    height: '20',
    color: 1
}
console.log (productMaker(myBadProduct))</pre>
			<p>You will receive the following error message when you run the file using <code>tsc</code> <code>[filename].ts</code>:</p>
			<pre>error TS2345: Argument of type '{ height: string; color: number; }' is not assignable to parameter of type 'ProductTemplate'.
  Property 'width' is missing in type '{ height: string; color: number; }' but required in type 'ProductTemplate'.</pre>
			<p>VS Code prevents you from making such errors. If you hover over the red-underlined code in the VS Code window, you will see a warning similar to the preceding error message.</p>
			<p>Let's go back to our interface example (<code>Example_Interface.ts</code>). Now, we have an interface for our product. Let's do the same for our <code>productMaker</code> function. We want to make sure that whenever a function takes our product as an argument, it is constructed in the right way. Hence, we construct the following interface – <code>productInterfaceFunction</code>:</p>
			<pre>Example_Interface_2.ts
1 // first interface
2 interface ProductTemplate {
3     height: number
4     width: number
5     color: string
6 }
7 //function interface
8 interface productInterfaceFunction {
9     (product: ProductTemplate): ProductTemplate
10 }
Link to the preceding example: <a href="https://packt.link/Dzogj">https://packt.link/Dzogj</a>.</pre>
			<p>We added the function interface, <code>productInterfaceFunction</code>, just after <code>ProductTemplate</code>. As you can see, the syntax is simple and just defines what arguments the function can take and what it should return. We can now use the function interface in our function declaration, as shown here:</p>
			<pre>//make product function
const productMaker: productInterfaceFunction = (product: ProductTemplate) =&gt; {
    return product }</pre>
			<p>You should again get the same output as before:</p>
			<pre>{ height: 10, width: 12, color: 'red' }</pre>
			<p>We have now used interfaces in two ways: to shape an object and a function. The only issue here is that it's not very efficient to work this way. As good developers, we want to be as efficient as possible and comply with object-oriented standards of coding. To this end, we will now refactor our code to define a class that will encapsulate our product properties and methods:</p>
			<pre>Example_Interface_3.ts
9  //product class interface
10 interface ProductClassInterface {
11    product: ProductTemplate
12    makeProduct(product: ProductTemplate) :ProductTemplate
13 }
Link to the preceding example: <a href="https://packt.link/kF4Ee">https://packt.link/kF4Ee</a>.</pre>
			<p>In the preceding snippet, we have built an interface for our class where we have defined a <code>product</code> property and the makeProduct method.</p>
			<p>We are also making good use of the interfaces we created previously for our product object and <code>makeProduct</code>. Next, we will use the new interface, <code>ProductClassInterface</code>, to instantiate a new class:  </p>
			<pre>16 //class that implements product class interface 
17 class ProductClass implements ProductClassInterface  {
18    product: ProductTemplate
19    constructor(product: ProductTemplate){
20        this.product = product
21    }
22    makeProduct():ProductTemplate {
23        return this.product;
24    }
25 }
26
27 //new product object
28 const product: ProductTemplate = {height:100, width:200, color: 'pink'}</pre>
			<p>In the preceding snippet, we are using the <code>implements</code> keyword to apply the interface rules to our <code>ProductClass</code>. The syntax structure is as follows: <code>class</code> <code>ProductClass</code> followed by the <code>implements</code> keyword, and then the interface you would like to apply to the class: <code>class ProductClass implements ProductClassInterface</code>. As you can see, this code is a bit less verbose and easy to manage. Using an interface to define our product class allows us to be more descriptive as we can not only define our class but the methods and properties associated with it. </p>
			<p>ype aliases can also be used in a similar manner, but types are more of a validator than a descriptor, hence it is recommended to use types more to verify objects returned from a function or arguments received by a function. </p>
			<p>Interfaces and types can be used together, and they should be. However, how they are used, where they are used, and how they are applied in code is down to you, as they are similar in many respects and even more so in recent updates of the TypeScript language. Let's now make a product object and use our class instance, <code>newProduct</code>:</p>
			<pre>27 //new product object
28 const product: ProductTemplate = {height:100, width:200, color: 'pink'}
29 
30 //call make Product function
31 // instantiate product class with new product object 
32 const newProduct = new ProductClass(product)
33 // console our new product instance
34 console.log(newProduct.product)</pre>
			<p>In the preceding snippet, we build a product object and then pass it to our class's <code>makeProduct</code> function. We then console out the results, which is the same as before, except now our functional code is wrapped in a class.</p>
			<p>You will obtain the following output:</p>
			<pre>{ height: 100, width: 200, color: 'pink' }</pre>
			<p>Now that we have a basic understanding of how to implement an interface with TypeScript, let's build a more realistic product creation process in the following exercise.</p>
			<h2 id="_idParaDest-113">E<a id="_idTextAnchor133"/>xercise 5.01: Implementing Interfaces </h2>
			<p>In this exercise, we will implement an interface on an object, function, and class. Some of the code is verbose and you may not implement it this way in a real-world application. However, this exercise will expose you to the different ways in which you can implement interfaces in your code. We will construct a class that manages product objects and use interfaces to enforce rules related to how our class should be implemented. We will also use interfaces to shape our product object and class methods. In a typical web application, this code would probably be part of a product management interface – an inventory management application, for example. Alternativley, it could also be part of the product creation process, where you have a form that takes user data and processes it:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/SR8eg">https://packt.link/SR8eg</a>. For this chapter, in order to run any TypeScript file, you need to go into the file directory and execute <code>npx ts-node filename.ts</code>.</p>
			<ol>
				<li>Create an interface called <code>ProductObjectTemplate</code>:<pre>interface ProductObjectTemplate {
    height: number
    width: number
    color: string
}</pre><p>When creating an interface or a type object for that matter, you should take into consideration what are the common elements your interface or type will need. This could be based on the application requirements or dependent only on the functionality the application is required to have. <code>ProductObjectTemplate</code> is a simple object and, in most cases, should be a type, but in order to show that interfaces can also be used in this way, we have opted to make it an interface. As you can see, we have just defined some basic properties that we may have for a product – <code>height</code>, <code>width</code>, and <code>color</code>.</p></li>
				<li>Using the interface defined in the preceding step, define a function called <code>ProductClass</code>Template:<pre>interface ProductFunctionTemplate {
    (product: ProductObjectTemplate)
}</pre><p>In the preceding step, we used an interface to define a function and, by doing this, we are providing the rules on what arguments your function can take. This will ensure that any implementation of this function will only take <code>ProductObjectTemplate</code> as an argument.</p></li>
				<li>Build an interface for a class called <code>ProductClassTemplate</code>. Reuse <code>ProductFunctionTemplate</code> and <code>ProductObjectTemplate</code> in your new class: <pre>interface ProductClassTemplate {
    makeProduct: ProductFunctionTemplate
    allProducts():ProductObjectTemplate[]
}</pre><p>In the preceding step, we are reusing the function and product interfaces defined in <em class="italic">Steps 1 and 2</em> to build our class interface. We can simplify the code in this step because we are reusing interfaces that we created in the first two steps. <em class="italic">Step 3</em> is a good example of how you can build complexity while also making your code less verbose.  </p></li>
				<li>Create a <code>Product</code> class and implement our class interface:<pre>class Product implements ProductClassTemplate {
    products: ProductObjectTemplate []
    constructor() {
        this.products = []
    }
    makeProduct(product: ProductObjectTemplate) {
        this.products.push(product)
    }
    
    allProducts():ProductObjectTemplate[] {
        return this.products
    }}</pre><p>In this preceding step, we created our class implementing the <code>ProductClassTemplate</code> interface. This will ensure that our class adheres to the rules defined in our interface. We are also reusing the <code>ProductTemplate</code> interface to verify that our class method takes the right arguments and returns the correct data. In the previous steps, we did a bit of prep work setting up interfaces, and now we can reuse them in our code base, making the overall code easier to write, well supported, and understandable.</p></li>
				<li>Instantiate our class as follows:<pre>const productInstance: ProductClassTemplate = new Product()const productInstance: ProductClassTemplate = new Product()
productInstance.makeProduct({})</pre><p>Here again, we are making use of an interface, <code>ProductClassTemplate</code> to ensure the class we implement matches our ruleset. </p><p>If we try to call <code>makeProduct</code> with an empty object, we get a helpful error message we can use to resolve our issue. Feel free to perform a test to make sure that your interfaces are working as they should. Here, we have the correct implementation of our class instance method, <code>makeProduct</code>.</p></li>
				<li>Call the <code>makeProduct</code> method and provide a valid product object as defined in our product interface:<pre>productInstance.makeProduct(
    {
    color: "red", 
    height: 10, 
    width: 14
    }
)</pre></li>
				<li>Call the <code>allProducts</code> method and console out the results: <pre>console.log(productInstance.allProducts())</pre><p>The <code>allProducts</code> method returns an array of products. This would be the equivalent of an API call that returns a list of products to your frontend.</p></li>
				<li>Now, console out the results of the <code>allProducts</code> method:<pre>console.log(productInstance.allProducts())</pre></li>
				<li>Run the file by executing <code>npx</code> <code>ts-node</code> <code>Exercise01.ts</code>.<p>You will obtain the following output:</p><pre> [ { color: 'red', height: 10, width: 14 } ]</pre><p>O<a id="_idTextAnchor134"/>nce you have followed the steps correctly, your output should be an array or product object as shown in the preceding screenshot. Interfaces provide you with the means to define contracts that govern how your code should be implemented, which is the point of a strongly typed language such as TypeScript and its main advantage over JavaScript. By using interfaces as shown in the exercise, we now have code that is less prone to errors and easier to support when working with large applications or on a large team. Interfaces can be invaluable to the development process if they are implemented correctly.</p></li>
			</ol>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor135"/>Exercise 5.02: Implementing Interfaces – Creating a Prototype Blogging Application</h2>
			<p>Imagine that you are a developer working on a social networking site. You are tasked with setting up a blogging system that will allow users to post to the site. The project is intended to scale up globally, so it will be quite large. Hence, your code needs to be well defined with all the necessary contexts. The main theme here is context. You are coding in a manner that will lead to bug-free code that is well supported and understood.</p>
			<p>First, we start with the main object – the blog post. In order to build a blogging system, we need to define what a blog post is. Because this is a simple object, we create a type alias, <code>BlogPost</code>. As mentioned previously, we can use an interface to define this object, but types are more suited to simple, non-complex objects. A type is more of a descriptor of a unit of something, for example, a number or a string, while an interface is more like directions on how to interact with something, not what it is:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/6uFmG">https://packt.link/6uFmG</a>.</p>
			<ol>
				<li value="1">Define a blog type as shown in the following snippet:<pre>type BlogPost = {
    post: string,
    timeStamp: number,
    user: string
}</pre></li>
				<li>Create an interface called <code>AddToPost</code>: <pre>interface AddToPost {
     (post: BlogPost): BlogPost []
}</pre><p>This interface will serve as the main interface for the method we will use to add to our blog list. As we elaborated in the previous exercise, the <code>AddToPost</code> interface defines how we will interact with our main method and also what it will return when called. </p></li>
				<li>Create an interface to define a class, <code>BlogPostClass</code>: <pre>interface IBlogPost {
    allPost: BlogPost [],
    addToPost: AddToPost
}</pre><p>Here, we define our class interface. We know we need a place to hold our blogs, so we define an <code>allPost</code> global object that is of the <code>BlogPost</code> type array. We also define a method, <code>addToPost</code>, that implements the <code>AddPost</code> interface. </p></li>
				<li>Create a class called <code>blogPostClass</code> that implements the <code>blogPostClass</code> interface: <pre>class blogPostClass implements IBlogPost{
    allPost: BlogPost [] = []
    addToPost(post: BlogPost): BlogPost[] {
        this.allPost = [
            ...this.allPost,
            post
        ]
        return this.allPost
    }
}</pre><p>In the preceding class, we reuse our type to enforce and validate. The logic of the <code>addToPost</code> method is up to you, the developer. In this step, the code implements the method once it adheres to the interface by taking an argument of the <code>BlogPost</code> type and returns a <code>BlogPost</code> array.</p></li>
				<li>Create an instance of <code>blogPostClass</code>:<pre>const blog = new blogPostClass();</pre></li>
				<li>Build three objects of the <code>BlogPost</code> type: <pre>let post1: BlogPost = {post: 'Goodbye, 2020', timeStamp: 12345678, user: 'Rayon'}
let post2: BlogPost = {post: 'Welcome, 2021', timeStamp: 12345678, user: 'Mark'}
let post3: BlogPost = {post: 'What happened to 1999?', timeStamp: 12345678, user: 'Will'}</pre><p>This step simulates a user posting to your blog site. In a real-world application, this will be a web form that creates the object when submitted. </p></li>
				<li>Call the <code>addToPost</code> method three times and pass the post objects you created in <em class="italic">Step 6</em>: <pre>blog.addToPost(post1)
blog.addToPost(post2)
blog.addToPost(post3)</pre><p>In an actual web application, the call to <code>addToPost</code> would entail making an API call to send the updated data to the backend of your application, but for the purpose of this exercise, we are just updating an array. If, for example, you are using some kind of state management for your frontend, the preceding code could look very similar to the state management handling the backend updates. </p></li>
				<li>Console out the <code>allPost</code> global from the class instance created in <em class="italic">Step 5</em>:<pre>console.log(blog.allPost)</pre></li>
				<li>Run the file by executing <code>npx ts-node Exercise02.ts</code>.<p>You should see the following output:</p><pre>[
  { post: 'Goodbye, 2020', timeStamp: 12345678, user: 'Rayon' },
  { post: 'Welcome, 2021', timeStamp: 12345678, user: 'Mark' },
  { post: 'What happened to 1999?', timeStamp: 12345678, user: 'Will' }
]</pre></li>
			</ol>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor136"/>Exercise 5.03: Creating Interfaces for a Function for Updating a User Database </h2>
			<p>As part of a web app developer team, you have been tasked with building an interface for a function that will update a user database. In a real-world application, this function might be part of a user registration form that updates a user database via an API call. The requirements are simple: the function should take an argument of the <code>User</code> type, which consists of <code>email</code> and <code>userId</code> properties.</p>
			<p>For the sake of this exercise, assume that you are just working out the logic of the function and that the code is just temporary for testing purposes before you implement it in your working application. As such, we will have an array that will represent the database, which will be preloaded with some user objects:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/XLIz9">https://packt.link/XLIz9</a>.</p>
			<ol>
				<li value="1">Create a user type with <code>email</code> and <code>userId</code> properties, as shown here:<pre>type User = {
    email: string,
    userId: number
}</pre><p>Creating a user type allows you to simplify your function interface. Now, you can reuse your <code>User</code> type when defining your interface in the next step. </p></li>
				<li>Build a function interface called <code>SuperAddMe</code>, as shown here: <pre>interface SuperAddMe {
    (user: User): User[]
};</pre><p>In doing this, we have defined how we will interact with our function. This is a small thing, but now, all functions of this type will have set rules. We will know what it needs and what it will return.</p></li>
				<li>Initialize an array of the <code>User</code> type and populate it with a few users: <pre>let allUsers: User[] = [
    { email: 'home@home.com', userId: 1 },
    { email: 'out@side.com', userId: 2 }
];</pre><p>This array will simulate a database of users that we will add to.</p></li>
				<li>Define a function of the <code>SuperAddMe</code> interface type: <pre>let adduser: SuperAddMe
adduser = function (user: User): User[] {
    return [
        ...allUsers,
        user
    ]
}</pre><p>When implementing a function in this way, you must first declare it as being of the interface type, which in this case is the <code>SuperAddMe</code> interface. Next, use the function variable and assign a function to it that adheres to the specification of our interface. This implementation is very similar to a type assignment, but because of the complexity of the function, an interface is used. Also, note that this code could be simplified by doing the declaration and assignment on one line, but in order to show the process and make it more readable, the assignment is implemented in parts.</p></li>
				<li>Display the results of a call to a new function, <code>adduser</code>, and pass a user object of the <code>User</code> type. Console out the results to show that the code is working:<pre>console.log(
    adduser(
        { email: 'slow@mo', userId: allUsers.length }
    )
)</pre></li>
				<li>Run the code using the <code>npx ts-node</code> command. You should see the following output:<pre>[
  { email: 'home@home.com', userId: 1 },
  { email: 'out@side.com', userId: 2 },
  { email: 'slow@mo', userId: 2 }
]</pre></li>
			</ol>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor137"/>A<a id="_idTextAnchor138"/>ctivity 5.01: Building a User Management Component Using Interfaces</h2>
			<p>Imagine that you are working on a web application and are tasked with building a user management component. You need to build a class to encapsulate the user management aspects of the application and, because you are a good developer, you will be using interfaces to ensure that your code is easy to reuse and support. For this activity, you can assume that your user interface will have at least three properties: email, token, and loginAt. These properties relate to a user's email ID, the web token, and the time on the system when the user logged in. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/xsOhv">https://packt.link/xsOhv</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Create a user object interface with the following properties: <code>email : string</code>, <code>loginAt : number</code>, and <code>token: string</code>. The <code>loginAt</code> and <code>token</code> properties should be optional properties. </li>
				<li>Build a class interface with a global property, <code>user</code>, and use the interface created in the preceding step to apply user object rules. <p>You need to define a <code>getUser</code> method that returns the <code>user</code> object and then use the interface to ensure that the return object is a user object. Finally, define a <code>login</code> method that takes a <code>user</code> object and <code>password(type string)</code> as arguments. Use the <code>user</code> object interface as the <code>user</code> argument type.</p></li>
				<li>Declare a class called <code>UserClass</code> that implements the class interface from the preceding step. Your login method should assign the local function's <code>user</code> argument to the global user property and return the global user. The <code>getUser</code> method should return the global user.</li>
				<li>Create an instance of your class declared in <em class="italic">Step 2</em>.</li>
				<li>Create a <code>user</code> object instance.</li>
				<li>Console out our methods to ensure that they are working as expected.</li>
			</ol>
			<p>The expected output is as follows:</p>
			<pre>{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }
{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor402">this link</a>.</p>
			<p>T<a id="_idTextAnchor139"/><a id="_idTextAnchor140"/><a id="_idTextAnchor141"/>ypeScript was born out of the need to build less confusing, clearly defined code. Interfaces allow you to build out your code in the most structured way possible. Everything has rules and there is no confusion, unlike with vanilla JavaScript.</p>
			<p>To summarize the importance of interfaces, you can say that now you can produce code that is better structured and easier for third parties to use. </p>
			<p>Let's say, for example, that you built a <code>user</code> class as you did in the preceding activity, and now you need to move on to a different part of your project. The interfaces you have built will be a great help to the developer taking over the user section of the application, or maybe some other developer wants to build a user class with a similar structure to your user class. By using the interfaces you have defined, they can build a structure that follows all the rules you have put in place. This is also helpful as regards debugging, as now they know how things are expected to function and can find where the issues are by using the interfaces as a guideline.</p>
			<p>T<a id="_idTextAnchor142"/>he next section of this chapter is dedicated to inheritance in TypeScript.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor143"/>TypeScript Inheritance</h1>
			<p><a id="_idTextAnchor144"/><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/>We will now dive into inheritance, which is one of the core principles of object-oriented programming. It allows us to stay DRY (don't repeat yourself). Inheritance also allows us to be polymorphic, by abstracting functionality. Inheritance gives you the ability to extend your classes from the original class to a child class, which allows you to retain the functionality from the parent or original class and add or override what you don't need. </p>
			<p>Child classes can override methods of their parents and have their own methods and objects. Inheritance only allows you to build on the parent class; how you implement your child class is up to you. However, the rule is that there must be some code you need to reuse from your parent class in your child class or you should create a new class as there would be no need to extend a class you don't plan to use any code from. </p>
			<p>Let's say you have a user class created to manage users in your application. You are working on a web application and, in the planning stages, you come to the realization that you need more than one user type, as different users will have different levels of access and be able to perform different actions depending on their roles. This is the perfect case for the use of inheritance. Any time you have common properties and functionality, you can extend and not duplicate your code. In this case, we have several user types, which all have common properties of a user: email, createDate, lastLogin, and token, for example. </p>
			<p>Because these properties are common to all users, we can put them all into a user class. The user class will serve as the base class that we can extend to our child classes. Your child classes will now have all the common properties without you having to declare them for each child class. As you can see, this is a much more efficient way to do things; it stops code duplication and allows for the consolidation of functionality.</p>
			<p>First, let's go over some ground rules of inheritance in TypeScript:</p>
			<p>TypeScript only supports inheritance in two ways: single-level and multi-level. Thus, in TypeScript, a child can inherit from a parent (single-level inheritance) or a child can inherit from another child (multi-level inheritance). </p>
			<p class="callout-heading">Note</p>
			<p class="callout">They are other types of inheritance, but since Typescript does not support those patterns, this chapter will not address these types here. </p>
			<p>H<a id="_idTextAnchor147"/>ere, we have a diagram of the two types of inheritance that TypeScript supports – single-level and multi-level:</p>
			<div><div><img src="img/B14508_05_02.jpg" alt="Figure 5.2: An example of single- and multi-level inheritance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: An example of single- and multi-level inheritance</p>
			<p>Single-level inheritance occurs when a child class inherits directly from a parent class, as shown in the preceding diagram. The Son child class is derived from the Father parent class and has all its attributes. It can also have its own properties and functions that are unique to the child class. One of the goals of inheritance is to build on top of an existing base, therefore, just creating a duplicate of the class would be pointless. Multi-level inheritance works the same as single-level inheritance, except the child class inherits from another child class and not directly from the parent, as shown in the preceding diagram. In other words, single-level is derived directly from the base class, which has no parents, while a multi-level child class inherits from a derived class. As you can see, the Grandfather class is the base class and therefore has no parents. Father is derived from GrandFather, but Son, in this case, is derived from Father, making this example multi-level. </p>
			<p>Ty<a id="_idTextAnchor148"/>peScript makes use of the private and public keywords to allow you to hide code from a child class that is private and control how your class properties are accessed by a child class with getter and setter methods. You can override any method that is exposed by a parent class in the child that includes the constructor method by using the keyword super, which is a direct link to the parent class. super also allows you to access properties and methods of the parent class even if they are overridden in your child class.</p>
			<p>To see how inheritance works in code, let's go back to our user example that we covered in the introduction to this section. The users of any given application have some common properties, email, createDate, lastLogin, and token, for example. We will use these common elements to build out a base user class:</p>
			<pre>Examples_Inheritance_1.ts
1 class UserOne {
2     email: string = "";
3     createDate: number = 0;
4     lastLogin: number = 0;
5     token: string = ""
6 
7     setToken(token: string): void {
8         // set user token
9        this.token = token;
10     }
11     resetPassword(password: string):string {
12         // return string of new password
13         return password;
14     }
15 }
Link to the preceding example: <a href="https://packt.link/23ts2">https://packt.link/23ts2</a>.</pre>
			<p>Here is some information on the properties used in the base class. This will also help you understand why these properties are present in the base class:</p>
			<ul>
				<li><code>email</code>: This property serves as a unique identifier. </li>
				<li><code>createDate</code>: This property allows you to know when the user was added to the system.</li>
				<li><code>lastLogin</code>: This property lets us know when the user was last active on the system. </li>
				<li><code>token</code>: This property will validate user requests to the application's API. </li>
				<li><code>setToken</code>: This property allows us to set and reset the token property; for example, the user logs out of the application and the token needs to be set to null. </li>
				<li><code>resetPassword</code>: This property allows us to reset the current user's password.</li>
			</ul>
			<p>We are also using the this keyword to access our class-level token in our <code>setToken</code> function. We have also provided a number of default values in our base class, such as setting an empty string for email and zero for <code>createDate</code>. This just makes it easier to create instances of the class as we do not need to provide values every time we initialize a class instance.</p>
			<p>Now, let's move on to inheritance. We will now create a child class, <code>AdminUser</code>:</p>
			<pre>16 class AdminUser extends UserOne {
17     // pages admin has access to
18     adminPages: string [] = ["admin", "settings"];
19 
20     // method that allows the admin to reset other users
21    resetUserPassword(email: string):string {
22         // return default user password
23         return "password123";
24     }
25 }</pre>
			<p>In order for us to create a child class, we must use the extends keyword followed by the parent class, as shown in the preceding snippet. The syntax structure is as follows: class keyword followed by the name of the child class, the extends keyword, and finally, the name of the parent class you would like to extend: class AdminUser extends UserOne.</p>
			<p>Before we move on to some examples, let's list a few things we cannot do with class inheritance in TypeScript: </p>
			<ul>
				<li>You cannot use other types of inheritance other than single- and multi-level.</li>
				<li>If you declare a property or a method private, you cannot access it directly in your derived classes. </li>
				<li>You cannot override the constructor method of your base class unless you call <code>super</code> in your derived class's constructor. </li>
			</ul>
			<p>Now, let's go back to our child class, <code>AdminUser</code>. Note that we have added some properties and methods unique to our child class. Unique to <code>AdminUser</code> are adminPages, which is a list of pages only the admin user has access to, and resetUserPassword, which takes an email address of a user and returns a default password: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also reference directly the properties and methods of your parent class by using the <code>this</code> keyword in the child class, since <code>AdminUser</code> is now a combined class. </p>
			<p>Now, consider the following snippet:</p>
			<pre>26 // create a instance of our child class
27 const adminUser: AdminUser = new AdminUser() 
28
29 // create a string to hold our props
30 let propString = ''
31
32 // loop through your props and appends prop names to propString
33 for(let u in adminUser) {
34     propString += u + ','
35 }</pre>
			<p>In the preceding snippet, we create an instance of our child class, <code>AdminUser</code>. We also declare a string, <code>propString</code>, as an empty string. This string will hold a list of your class properties. Using a <code>for</code> loop, we loop over our class instance and append the properties to <code>propString</code>. </p>
			<p>Now, console out an instance of our child class to verify that we have successfully inherited from our base class:</p>
			<pre>36 // console out the results
37 console.log(propString)</pre>
			<p>You should see the properties and methods of our child and parent classes printed on the console:</p>
			<pre>email,createDate,lastLogin,token,adminPages,constructor,resetUserPassword,setToken,resetPassword,</pre>
			<p>The preceding output is the expected result. You now have a list of the combined properties of <code>UserOne</code> and <code>AdminUser</code>, showing that we have successfully extended our <code>UserOne</code> class to <code>AdminUser</code> or, in other words, we have shown that <code>AdminUser</code> inherits from <code>UserOne</code>. </p>
			<p>Let's now take inheritance up one level by deriving a new class from the <code>AdminUser</code> class. Call the derived class <code>SuperAdmin</code>, because not all admins are created equal:</p>
			<pre>Examples_Inheritance_2.ts
class SuperAdmin extends AdminUser {
    superPages: string[] = ["super", "ultimate"]
    createAdminUser(adminUser: AdminUser ): AdminUser {
        return adminUser
    }
}
Link to the preceding example: <a href="https://packt.link/XcFR6">https://packt.link/XcFR6</a>.</pre>
			<p>As you can see from the preceding snippet, we are now extending the <code>AdminUser</code> class to create a <code>SuperAdmin</code> class. This means that we now have multi-level inheritance as our current class is inheriting from a derived class. We have also added a new property, <code>superPages</code>, and a method, <code>createAdmin</code>.</p>
			<p>Multi-level inheritance is useful for building complexity while still keeping your code easy to manage. </p>
			<p>Next, we are going to overload our <code>resetPassword</code> method in the <code>SuperAdmin</code> child class. </p>
			<p>We want to create a new method for resetting passwords in our <code>SuperAdmin</code> class. We require a method that adds a hash to make the user password more secure as this will be the admin super user's password:</p>
			<pre>26 class SuperAdmin extends AdminUser {
27     superPages: string[] = ["super", "ultimate"]
28     readonly myHash: string
29 
30     constructor() {
31         super()
32         this.myHash = '1234567'
33     }
34 
35     createAdminUser(adminUser: AdminUser ): AdminUser {
36         return adminUser
37     }
38     resetPassword(password: string): string {
39         // add hash to password
40         return password + this.myHash; 
41     }
42 }</pre>
			<p>The preceding code snippet creates a new method, <code>resetPassword</code>, and adds a new <code>myHash</code> property to our <code>SuperAdmin</code> class. We gave our new method the same name, <code>resetPassword</code>, as the <code>resetPassword</code> method in our grandfather class, <code>UserOne</code>. However, this new method returns a password appended with our hash property. </p>
			<p>This is called method overriding because the methods have the same name and signature, meaning they take the same arguments. The method in the grandfather class is overridden and the new method will take precedence with instances of the <code>SuperAdmin</code> class. </p>
			<p>This is useful when you need to add some functionality to a method in a child class but don't want to change the signature, as the new method does something similar but not exactly the same. Consumers of your code will be able to use the same method but get different outcomes based on which derived child class they invoke. </p>
			<p>In the following snippet, we will console out the results of an instance of the <code>SuperAdmin</code> and <code>AdminUser</code> classes and the <code>resetPassword</code> method:</p>
			<pre>43 const superAdmin = new SuperAdmin()
44 const newAdmin = new AdminUser()
45 console.log( superAdmin.resetPassword('iampassword'))
46 console.log( newAdmin.resetPassword('iampassword'))</pre>
			<p>You will obtain the following output:</p>
			<pre>iampassword1234567 
iampassword   </pre>
			<p>As you can see from the output, we are calling the same method and getting a different output. This shows that we were able to successfully override the <code>resetPassword</code> method from our parent class, <code>UserOne</code>.</p>
			<p>You can also add some access modifiers to our classes to show how they will affect our child classes:</p>
			<pre>class UserOne {
    email: string = "";
    createDate: number = 0;
    lastLogin: number = 0;
    private token: string = ""
    setToken(token: string): void {
        // set user token
        this.token = token;
    }
    resetPassword(password: string):string {
        // return string of new password
        return password;
}}</pre>
			<p>In the preceding snippet, we have added the <code>private</code> access modifier to the <code>token</code> property. Now, we can only access the <code>token</code> property through the <code>setToken</code> method, which is public, and all derived classes have access to the <code>setToken</code> method. This is useful in cases where you want to restrict which methods and properties to grant access to in your child classes. This is also useful in cases where you want to abstract functionality, thereby making interfacing with your code easier for consumers. </p>
			<p>We want to make sure that every <code>AdminUser</code> class instance is initialized with an email address. Hence, we decide to add a constructor method to our <code>AdminUser</code> class to create an email address for our admin users whenever an <code>AdminUser</code> class is created. </p>
			<p>However, we cannot just create a constructor as this is a child class, which means we already have a parent class with a constructor method and we cannot override a constructor method without invoking our base class's constructor method. </p>
			<p>To invoke our base class's constructor method, we use <code>super()</code>, which is a direct reference to our base class's constructor method:</p>
			<pre>// adminUserTwo
class AdminUserTwo extends UserOne {
    // pages admin has access to
    constructor(email: string) {
        super()
        this.email = email;
      }
      
      adminPages: string [] = ["admin", "settings"];
  
      resetUserPassword():string {
          // return default user password
          return "password123";
      }</pre>
			<p>As you can see in the preceding snippet, we have a constructor method that takes an email address and sets the global email address. We also call the <code>super</code> method so that we can invoke the constructor method on our parent class. </p>
			<p>Now, you can create an instance of our <code>AdminUserTwo</code> class and pass an email address when the instance is created. This is all transparent to the user of our <code>AdminUser</code> class:</p>
			<pre>const adminUserTwo = new AdminUserTwo('home@home.com');</pre>
			<p>Now that we have covered inheritance, we will put what we have learned to good use in the upcoming exercise.</p>
			<h2 id="_idParaDest-118">Ex<a id="_idTextAnchor149"/>ercise 5.04: Creating a Base Class and Two Extended Child Classes</h2>
			<p>Imagine that you are part of a development team working on a web application for a supermarket chain. You have the task of building a class to represent a user in the application. Because you are a good developer and are aware that you should not try to create one class for all use cases, you will build a base class with common attributes you think all users in your application should have and then extend that as required with child classes: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/hMd62">https://packt.link/hMd62</a>.</p>
			<ol>
				<li value="1">Create a <code>User</code> class, as shown in the following code snippet:<pre>class User {
    private userName: string; 
    private token: string = ''
    readonly timeStamp: number = new Date().getTime()
    constructor(userName: string, token: string) {
        this.userName =  userName
        this.token = token
    }
    logOut():void {
        this.userName = ''
        this.token = ''
    }
    getUser() {
        return {
            userName: this.userName,
            token: this.token,
            createdAt: this.timeStamp
        }
    }
    protected renewToken (newToken: string) {
        this.token = newToken
    }}</pre><p>The application requires all its users to have <code>username</code> and <code>token</code> upon creation of the user object, so we add those properties and they will be initialized in our constructor. </p><p>We also set them to <code>private</code> as we do not want child classes to access our properties directly. We also have a <code>timestamp</code> property that we will use to set a creation date for the user object. This is set to <code>readonly</code> as it is created when the class is instanced and we don't want it to be modified. </p><p>Different parts of your application will also need to access the properties of your user object. Therefore, we have added <code>getUser</code>, a method that returns your user properties. The <code>getUser</code> method will also allow derived or child classes to access private properties in an indirect way. The application allows the user to be logged in for a set period of time, after which the user token is expired. In order for a user to keep working in the application, we will need to renew their token, so we have added the <code>renewToken</code> method to allow for the setting of the user token property without giving direct access to properties.</p></li>
				<li>Create a <code>Cashier</code> class derived from the <code>User</code> class:<pre>class Cashier extends User {
    balance: number = 0
    float: number = 0
    start(balance: number, float: number): void {
        this.balance= balance
        this.float = float
    }
}</pre><p>We now have a new user class, <code>Cashier</code>, derived from <code>User</code>, with some unique traits. A user of the <code>Cashier</code> type would need to function in our application. We do not, however, have access to all the properties of our parent class. You cannot access <code>userName</code> and <code>token</code> directly. You are able to access the <code>renewToken</code> method, but not through an instance of the <code>Cashier</code> class. However, you can call that method while building out the <code>Cashier</code> class as part of your user management for cashiers. </p><p>Why would we want to modify access in the child class as opposed to modifying a parent? This is because of encapsulation and standardization: we want to reduce the complexity of our code when consumed by others. </p><p>For example, you have been working on a library of useful functions. You want your coworkers to be able to use it, but they don't need to know the inner workings of your <code>User</code> class. They just need to be able to access the class using the exposed methods and properties. This allows you to guide the process even if you are not the person extending or implementing the code. A good example would be the <code>Date</code> class in JavaScript. You don't need to know how that works. You can simply instance it and use it as directed.</p></li>
				<li>Create an <code>Inventory</code> class derived from <code>User</code>:<pre>class Inventory extends User {
    products: string [] = []
    // override constructor method, add new prop
    constructor(userName: string, token: string, products: string[]) {
        // call parent constructor method
        super(userName, token)
        // set new prop
        this.products = products
}}</pre><p>Our new user type, <code>Inventory</code>, needs to be able to initialize products upon the declaration of a new inventory user, as this user will be dealing with products directly and should have some products in their user queue when the user logs in to the application. </p><p>In order to make that possible, we have overridden our parent class constructor method in our child class. Our constructor now takes a new argument, <code>products</code>, which is an array of the string type. This means that we have changed the number of arguments our constructor should take based on what we defined in our parent class. Whenever we override our constructor, we need to call <code>super</code>, which is a reference to our parent class. </p><p>As you can see, this allows us to access the parent constructor method, so we can now initialize <code>userName</code> and <code>token</code> and, in doing so, fulfill our child class's parent requirements. The main thing to take away from this is that all our code changes were made in the child class. Your new code for the <code>Inventory</code> class does not affect the other classes derived from <code>User</code>. You have extended and customized your code to deal with unique cases without having to write new code for this user case, saving you time and keeping your code base simple.</p><p>So far, we have derived two classes from our <code>User</code> class, which is single inheritance, as the child classes we created are directly derived from a base class. The next step involves multi-level inheritance.</p></li>
				<li>Create a new derived class, <code>FloorWorker</code>:<pre>class FloorWorker extends Inventory {
    floorStock: string [] = []
    CheckOut(id: number) {
        if(this.products.length &gt;=0) {
            this.floorStock.push(
                this.products[id]
            )
        }
    }
}</pre><p>This is multi-level inheritance. This class takes into account floor workers. These are users that deal with stocking shelves in the store, so they need to access products from the inventory. They also need to have a count of the products they have removed to stock the store shelves. They need to have access to the <code>User</code> class' properties as well as access to the <code>Products</code> array from the <code>Inventory</code> class. </p><p>In the following code snippet, we will instantiate our different user classes and console out the results of the work we have done so far.</p></li>
				<li>Instantiate your basic user and console out the results:<pre>const basicUser = new User('user1', '12345678ttt')
console.log(basicUser) </pre><p>You will obtain the following output:</p><pre>User {
  token: '12345678ttt',
  timeStamp: 1614074754797,
  userName: 'user1'
}</pre></li>
				<li>Instantiate the <code>Cashier</code> class user and console out the results:<pre>const cashUser = new Cashier('user2', '12345678')
console.log(cashUser)
cashUser.start(10, 1.5)
console.log(cashUser)</pre><p>You will obtain the following output:</p><pre>Cashier {
  token: '12345678',
  timeStamp: 1614074754802,
  userName: 'user2',
  balance: 0,
  float: 0
}
Cashier {
  token: '12345678',
  timeStamp: 1614074754802,
  userName: 'user2',
  balance: 10,
  float: 1.5</pre></li>
				<li>Instantiate the <code>Inventory</code> class user and console out the results:<pre>// init inventory
const iUser = new Inventory('user3', '123456789', [
    'orange', 'mango', 'playStation 2'
])
console.log(iUser) </pre><p>You will obtain the following output:</p><pre>Inventory {
  token: '123456789',
  timeStamp: 1614074754819,
  userName: 'user3',
  products: [ 'orange', 'mango', 'playStation 2' ]
}</pre></li>
				<li>Instantiate the <code>FloorWorker</code> class user and console out the results:<pre>// FloorWorker
const fUser = new FloorWorker('user4', '12345678', [
    'orange', 'mango', 'playStation 2'
])
fUser.CheckOut(0)
console.log(fUser.products) 
console.log(fUser.floorStock)</pre><p>You will obtain the following output:</p><pre>[ 'orange', 'mango', 'playStation 2' ]
[ 'orange' ]</pre><p class="callout-heading">Note</p><p class="callout">For <em class="italic">steps 5-8</em>, you can also instantiate and console out all your users belonging to the different classes at once, rather than individually, as shown in the exercise. </p></li>
			</ol>
			<p>In<a id="_idTextAnchor150"/> this exercise, you created a base class, child classes, and worked on multi-level and single-level inheritance. You also made use of <code>super</code> and access modifiers. </p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor151"/>Exercise 5.05: Creating Bases and Extended Classes Using Multi-level Inheritance </h2>
			<p>You are a developer working at a cell phone company and you are given the task of building a cell phone simulation application. The company manufactures two types of phone – a smartphone and a standard phone. The testing department wants to be able to showcase a number of functions of their phones and requires the ability to add more features to both phone types as the real devices are updated. After looking at the requirements, you come to the realization that you need the ability to model two types of phone and you also want to make it easy to update your code without doing a lot of refactoring and breaking other code that your phone models may use. You also know that both phones have a lot in common – they both have the basic functionality of communicating through voice and text data. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/pyqDK">https://packt.link/pyqDK</a>.</p>
			<ol>
				<li value="1">Create a <code>Phone</code> class that will serve as the base class for our child classes, as shown here: <pre>class Phone {
powerButton: boolean;
mic: boolean;
speaker: boolean;
serialNumber: string;
powerOn: boolean = false;
restart: boolean = false;
constructor(
powerButton: boolean,
mic: boolean,
speaker: boolean,
serialNumber: string,
) {
this.powerButton = powerButton
this.mic = mic;
this.speaker = speaker;
this.serialNumber = serialNumber;
}
 
togglePower(): void {
this.powerOn ? this.powerOn = false : this.powerOn = true
}
 
reboot(): void {
this.restart = true
}
}</pre><p>The <code>Phone</code> class is where we will store all the common elements of a phone. This will allow us to simplify our child classes to only deal with the elements unique to them. </p></li>
				<li>Create a <code>Smart</code> class that extends the base or parent class created in <em class="italic">Step 1</em>: <pre>class Smart extends Phone {
touchScreen: boolean = true;
fourG: boolean = true;
constructor(serial: string) {
super(true, true, true, serial)
}
playVideo(fileName: string): boolean {
return true
}
}</pre><p>The <code>Smart</code> child class allows us to isolate all the methods and properties of a <code>Smart</code> <code>Phone</code> class. </p></li>
				<li>Create a <code>Standard</code> class that extends the parent class created in <em class="italic">Step 1</em>, as shown here:<pre>class Dumb extends Phone {
dialPad: boolean = true;
threeG: boolean = true;
constructor(serial: string) {
super(true, true, true, serial)
}
NumberToLetter(number: number): string {
const letter = ['a', 'b', 'c', 'd']
return letter[number]
}
}</pre><p>Steps 2 and 3 deal with the creation of our child class, which allows us to meet our goals of being able to update our code without issues and keep our code clean and well maintained. Because we are planning well at this stage, if we need to add features to our <code>Smart</code> phone, we just need to update one child class. This is also true for the <code>Standard</code> phone class. Also, if we have a method or property that we need in both child classes, we only need to update the <code>Phone</code> parent class. With class inheritance, we work smart, not hard.</p></li>
				<li>Create two instances of our child classes and initialize them:<pre>const smartPhone = new Smart('12345678')
const standardPhone = new Standard('67890')</pre></li>
				<li>Console out and call the unique methods of our class instances to verify that our child classes are working as defined:<pre>console.log(smartPhone.playVideo('videoOne'))
console.log(standardPhone.NumberToLetter(3))</pre><p>You will obtain the following output:</p><pre>true
d</pre><p>if you revisit the respective class definitions of the <code>Smart</code> and <code>Standard</code> classes, you will be able to confirm that the preceding output is indeed evidence of the fact that the classes have worked as expected.</p></li>
				<li>Display the child class instance to show that we have all the properties and methods of our parent class and child classes:<pre>console.log(smartPhone)
console.log(standardPhone)</pre><p>You will obtain the following output:</p><pre>Smart {
  powerOn: false,
  restart: false,
  powerButton: true,
  mic: true,
  speaker: true,
  serialNumber: '12345678',
  touchScreen: true,
  fourG: true
}
Dumb {
  powerOn: false,
  restart: false,
  powerButton: true,
  mic: true,
  speaker: true,
  serialNumber: '67890',
  dialPad: true,
  threeG: true
}</pre><p>For this preceding output, too, revisiting the respective class definitions of the <code>Smart</code> and <code>Dumb</code> classes should be proof enough that inheritance, as applied in this exercise, works correctly.</p></li>
			</ol>
			<p>Now that you have an understanding of how inheritance works in TypeScript, we will test our skills in the form of the following activity.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor152"/>Ac<a id="_idTextAnchor153"/>tivity 5.02: Creating a Prototype Web Application for a Vehicle Showroom Using Inheritance</h2>
			<p>You are tasked with creating a web application for a vehicle showroom. You have decided to use your new skills in inheritance to build out the classes and child classes that will shape the vehicle objects we will require for our complete application. Note that the showroom has several types of vehicles. However, all these types will have some common properties. For example, all vehicles have wheels and a body. You can use this information to build your base class. </p>
			<p>The following steps will help you to complete this activity: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/6Xp8H">https://packt.link/6Xp8H</a>.</p>
			<ol>
				<li value="1">Create a parent class that will hold all common methods and properties for a base vehicle. Define a constructor method that allows you to initialize the base properties of this class and add a method that returns your properties as an object. </li>
				<li>Add an access modifier to properties and class methods you want to control access to if necessary. </li>
				<li>Derive two child classes from your parent class that are types of vehicles, for example, <code>Car</code> and <code>Truck</code>.</li>
				<li>Override your constructor to add some unique properties to your child classes based on the type of vehicle.</li>
				<li>Derive a class from one of the child classes created in <em class="italic">Step 3</em>, for example, <code>Suv</code>, which will have some of the properties a truck might have, so it would be logical to extend <code>Truck</code>.</li>
				<li>Instantiate your child classes and seed them with data.</li>
				<li>Console out our child class instance. </li>
				<li>The expected output is as follows:<pre>Car { name: 'blueBird', wheels: 4, bodyType: 'sedan', rideHeight: 14 }
Truck { name: 'blueBird', wheels: 4, bodyType: 'sedan', offRoad: true }
Suv {
  name: 'xtrail',
  wheels: 4,
  bodyType: 'box',
  offRoad: true,
  roofRack: true,
  thirdRow: true
}</pre><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor405">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-121">Su<a id="_idTextAnchor154"/>mmary</h1>
			<p>In this chapter, we covered interfaces in TypeScript. You learned how interfaces allow you to build contracts around your objects, classes, and methods. You also learned that interfaces are rules that outline how your code is implemented. This chapter covered how using interfaces makes your code easier to understand and is better supported by you and other developers when working in larger teams. </p>
			<p>This chapter also taught you about inheritance, one of the core principles of object-oriented programing. You learned about the types of inheritance TypeScript supports and how you can use inheritance to build complexity in your code without making your code more complex. This chapter elucidated that stacking simple structures to make more complex ones is a good practice as it allows you to reuse code and not reinvent the wheel every time you need to build a class. This also lends itself to better code support as you will write only the code you need and have common parent classes that will remain constant throughout your application, thereby making mistakes and bugs easier to find.</p>
			<p>You now have a good understanding of interfaces and inheritance, two building blocks you will make good use of as you move forward in this book and in web development using TypeScript.</p>
			<p>The concepts you have covered here will make you a better developer overall as now you have the tools to write well-supported, clean, bug-free code.</p>
			<p>In the next chapter, you will cover advanced types and will learn about type aliases, type literals, unions, and intersection types.</p>
		</div>
	</body></html>