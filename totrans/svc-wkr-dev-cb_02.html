<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Working with Resource Files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Resource Files</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Displaying a custom offline page</li><li class="listitem" style="list-style-type: disc">Loading images offline</li><li class="listitem" style="list-style-type: disc">Loading CSS offline</li><li class="listitem" style="list-style-type: disc">Loading fonts offline</li><li class="listitem" style="list-style-type: disc">Implementing multiple fetch handlers</li><li class="listitem" style="list-style-type: disc">Fetching remote resources</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introduction</h1></div></div></div><p>You might have encountered, from time to time, having broken images appear on certain websites. This could be because of a number of reasons: the image might not have existed, it might not have been named properly, or the file path in the code might have been incorrect. Whatever the reason it might be, it could impact your website, and could lead the user to think that your website is broken.</p><p>Images are not the only resources that are essential to your website. <span class="strong"><strong>Cascading style sheets</strong></span> (<span class="strong"><strong>CSS</strong></span>), JavaScript files, and <a id="id66" class="indexterm"/>font files are also necessary to make your website appear functional. In this chapter, we are going to look at how to load these resources offline.</p><p>Before we start working on loading resources offline, let's find out how we can notify the user that the network is unavailable.</p></div></div>
<div class="section" title="Displaying a custom offline page"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Displaying a custom offline page</h1></div></div></div><p>Let's <a id="id67" class="indexterm"/>revisit the scenario from the first chapter where you are on a train, traveling home from work, and you are reading an important news article on the web using your mobile device. At the same moment that you click on a link to view more details, the train suddenly disappears into a tunnel. You've just lost connectivity, and are presented with the <span class="strong"><strong>Unable to connect to the Internet</strong></span> message. Well, you will not doubt be less annoyed if you can still play the dinosaur game by hitting the <a id="id68" class="indexterm"/>spacebar on your desktop/laptop, or by tapping on your phone, but this can be an area where you can significantly enhance a client's user experience by using a service worker. One of the great features of service workers is that they allow you to intercept network requests and decide how you want to respond:</p><div class="mediaobject"><img src="graphics/B05381_02_01.jpg" alt="Displaying a custom offline page"/></div><p>In this recipe, we are going to use a service worker to check whether a user has connectivity, and respond with a really simple offline page if they aren't connected.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we must create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Custom Offline Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
    var scope = {
      scope: './'
    };

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js', scope)
      .then(
        function(serviceWorker) {
        document.getElementById('status').innerHTML = 'successful';
      }).catch(function(error) {
        document.getElementById('status').innerHTML = error;
      });
    } else {
        document.getElementById('status').innerHTML = 'unavailable';
      }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a <a id="id69" class="indexterm"/>JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">'use strict';

var version = 1;
var currentCache = {
  offline: 'offline-cache' + version
};

var offlineUrl = 'offline.html';

self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(currentCache.offline).then(function(cache) {
      return cache.addAll([
        offlineUrl
      ]);
    })
  );
});

self.addEventListener('fetch', function(event) {
  var request = event.request,
    isRequestMethodGET = request.method === 'GET';

  if (request.mode === 'navigate' || isRequestMethodGET) {
    event.respondWith(
      fetch(createRequestWithCacheBusting(request.url)).catch(function(error) {
        console.log('OFFLINE: Returning offline page.', error);
        return caches.match(offlineUrl);
      })
    );
  } else {
    event.respondWith(caches.match(request)
        .then(function (response) {
        return response || fetch(request);
      })
    );
  }
});
function createRequestWithCacheBusting(url) {
  var request,
    cacheBustingUrl;

  request = new Request(url,
    {cache: 'reload'}
  );

  if ('cache' in request) {
    return request;
  }

  cacheBustingUrl = new URL(url, self.location.href);
  cacheBustingUrl.search += (cacheBustingUrl.search ? '&amp;' : '') + 'cachebust=' + Date.now();

  return new Request(cacheBustingUrl);
}</pre></div></li><li class="listitem">Create a second <a id="id70" class="indexterm"/>HTML file called <code class="literal">offline.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Offline&lt;/title&gt;
  &lt;style&gt;
    #container {
      text-align: center;
      margin-top: 40px;
    }
    #container img {
      width: 80px;
      height: 80px;
    }
  &lt;/style&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;div id="container"&gt;
     &lt;svg  width="25" height="25" viewBox="0 0 25 25"&gt;
       &lt;path d="M16 0l-3 9h9l-1.866 2h-14.4L16 0zm2.267 13h-14.4L2 15h9l-3 9 10.267-11z" fill="#04b8b8"/&gt;
     &lt;/svg&gt;
     &lt;p&gt;Whoops, something went wrong...!&lt;/p&gt;
     &lt;p&gt;Your internet connection is not working.&lt;/p&gt;
     &lt;p&gt;Please check your internet connection and try again.&lt;/p&gt;
   &lt;div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Open up a browser and go to <code class="literal">index.html</code>. You will see the <span class="strong"><strong>Registration status: successful</strong></span> message:<div class="mediaobject"><img src="graphics/B05381_02_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open <a id="id71" class="indexterm"/>up DevTools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>), go to the <span class="strong"><strong>Network</strong></span> tab, click on the dropdown displaying <span class="strong"><strong>No throttling</strong></span>, and select <span class="strong"><strong>Offline</strong></span>:<div class="mediaobject"><img src="graphics/B05381_02_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Now refresh your browser, and you will see the offline message and the following image:<div class="mediaobject"><img src="graphics/B05381_02_04.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How it works...</h2></div></div></div><p>When the <a id="id72" class="indexterm"/>registration is successful, we are instructing the service worker to intercept a request and provide resources from the cached content using the fetch event, as illustrated in the following diagram:</p><div class="mediaobject"><img src="graphics/B05381_02_05.jpg" alt="How it works..."/></div><p>Inside the <code class="literal">index.html</code> file, when the registration is successful, we inspect the state of the registration and print it to the browser. Otherwise, we are printing the error message returned by the service worker:</p><div class="informalexample"><pre class="programlisting">navigator.serviceWorker.register(
      'service-worker.js',
      { scope: './' }
   ).then(function(serviceWorker) {
      document.getElementById('status').innerHTML = 
          'successful';
   }).catch(function(error) {
      document.getElementById('status').innerHTML = error;
   });</pre></div><p>The service <a id="id73" class="indexterm"/>worker script file will intercept network requests, check for connectivity, and provide the content to the user.</p><p>We start off by adding our offline page to the cache when we install the service worker. In the first few lines, we are specifying the cache version and the URL for the offline page. If we had different versions of our cache, you would simply update this version number, so a new version of the file will take effect. We call this <span class="strong"><strong>cache busting</strong></span>:</p><div class="informalexample"><pre class="programlisting">var version = 1;
var currentCache = {
  offline: 'offline-cache' + version
};</pre></div><p>We add an event listener to the install event and inside the callback, we make a request for this offline page and its resources; when we have a successful response, it gets added to the cache:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(currentCache.offline)
    .then(function(cache) {
         return cache.addAll([
            offlineUrl
         ]);
    })
  );
});</pre></div><p>Now that the offline page is stored in the cache, we can retrieve it whenever we need to. In the same service worker, we need to add the logic to return the offline page if we have no connectivity:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(event) {
  var request = event.request,
    isRequestMethodGET = request.method === 'GET';

  if (request.mode === 'navigate' || isRequestMethodGET) {
    event.respondWith(
      fetch(createRequestWithCacheBusting(request.url)).catch(function(error) {
        console.log('OFFLINE: Returning offline page.', error);
        return caches.match(offlineUrl);
      })
    );
  } else {
    event.respondWith(caches.match(request)
        .then(function (response) {
        return response || fetch(request);
      })
    );
  }
}); </pre></div><p>In the <a id="id74" class="indexterm"/>preceding listing, we are listening out for the fetch event, and if we detect that the user is trying to navigate to another page, and there is an error while doing so, we simply return the offline page from the cache. And there you go, we have our offline page working.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>There's more...</h2></div></div></div><p>The <code class="literal">waitUntil</code> event extends the lifetime of the install event, until all the caches are populated. In other words, it delays treating the installing worker as installed, until all the resources we specify are cached and the passed promise resolves successfully.</p><p>We saw an HTML and an image file get cached, and then being retrieved when our website is offline. We can cache other resources as well, including CSS and JavaScript files:</p><div class="informalexample"><pre class="programlisting">caches.open(currentCache.offline)
.then(function(cache) {
    return cache.addAll([
        'offline.html',
        '/assets/css/style.css',
        '/assets/js/index.js'
    ]);
  })
);</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Registering a service worker in detail</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating mock responses</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li></ul></div></div></div>
<div class="section" title="Loading images offline"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Loading images offline</h1></div></div></div><p>Images are a <a id="id75" class="indexterm"/>resource that almost all websites in the world today use. Just like your HTML, CSS, and JavaScript, you can cache images to be viewed offline with service workers. In this chapter, we are going to look at how to load images offline, as well as handling responsive images.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we must create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Offline Images&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;main&gt;
    &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;img src="packt-logo.png" alt="logo"&gt;
  &lt;main&gt;
  &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Now we have to create a JavaScript file <code class="literal">service-worker.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">'use strict';

var version = 1;
var cacheName = 'static-' + version;

self.addEventListener('install', installHandler);
self.addEventListener('fetch', fetchHandler);

function installHandler(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
              'index.html',
              'packt-logo.png'
            ]);
        })
    );
}

event.respondWith(
  fetch(event.request).catch(function() {
    return caches.match(event.request);
  })
);</pre></div></li><li class="listitem">Create a<a id="id76" class="indexterm"/> JavaScript file called <code class="literal">index.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">'use strict';

var scope = {
  scope: './'
};

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js', scope
  ).then( function(serviceWorker) {
    printStatus('successful');
  }).catch(function(error) {
    printStatus(error);
  });
} else {
  printStatus('unavailable');
}

function printStatus(status) {
  document.getElementById('status').innerHTML = status;
}</pre></div></li><li class="listitem">Download an image file and save it in the same folder as the <code class="literal">index.html</code> file. In this example, I am calling it <code class="literal">packt-logo.png</code>.</li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_02_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Open <a id="id77" class="indexterm"/>up Chrome Developer Tools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>), select the <span class="strong"><strong>Network</strong></span> tab, and click <span class="strong"><strong>Offline</strong></span>:<div class="mediaobject"><img src="graphics/B05381_02_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Refresh <a id="id78" class="indexterm"/>the page by pressing <span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>R</em></span> or <span class="emphasis"><em>F5</em></span>, and you will see the image looks the same as it did online.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How it works...</h2></div></div></div><p>In the <code class="literal">index.html</code> file, we are linking the image we have downloaded inside an <code class="literal">img</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;img src="packt-logo.png" alt="logo"&gt;
  &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre></div><p>In the service worker script file, we add our offline page to the cache when we install the service worker. In the first few lines, we specify the cache version and the URL for the offline page:</p><div class="informalexample"><pre class="programlisting">var version = 1;
var cacheName = 'static-' + version;</pre></div><p>The event listener for the install event calls the <code class="literal">waitUntil</code> function, where we cache <code class="literal">index.html</code> and the font file, in our case, <code class="literal">webfont-serif.woff</code>. The <code class="literal">cache.addAll</code> function takes <a id="id79" class="indexterm"/>an array of files to be cached:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('install', function(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
                'index.html',
                'packt-logo.png'
            ]);
        })
    );
});</pre></div><p>When we reload the page, after it is set to go offline, the fetch event gets fired, retrieves those two files from the cache, and sends them along with the response:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(event) {
    event.respondWith(caches.match(event.request));
});    </pre></div><p>Now, the page will be displayed as it was online.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>There's more...</h2></div></div></div><p>If we were to develop our website following a mobile-first strategy, having responsive images would greatly benefit it. Let's look at how we can achieve this.</p><div class="section" title="Handling responsive images"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Handling responsive images</h3></div></div></div><p>There <a id="id80" class="indexterm"/>are a number of ways to enable the responsive behavior for images. One of the older methods (not recommended) is by simply <a id="id81" class="indexterm"/>scripting, but this leads to a couple of problems. First, if a script determines which image to download, but the script itself is loaded after the images specified in the HTML have been downloaded, you may potentially end up with two downloaded images. Second, if you don't specify any image in HTML, and want to load only the image defined by the script, you'll end up with no image at all for browsers that have scripting disabled.</p><p>Hence, we need a better way to deal with responsive images. And thankfully, there is one! The recommended way is to use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">srcset</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sizes</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">picture</code></li></ul></div><div class="section" title="The srcset attribute"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>The srcset attribute</h4></div></div></div><p>Before we <a id="id82" class="indexterm"/>explore how <code class="literal">srcset</code> is actually used, let's <a id="id83" class="indexterm"/>understand a few terms.</p><div class="section" title="Device-pixel ratio"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl5sec01"/>Device-pixel ratio</h5></div></div></div><p>The device-pixel ratio <a id="id84" class="indexterm"/>is the number of device pixels per CSS pixel. Two key conditions contribute to the device-pixel ratio:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixel density of the device (number of physical pixels per inch)</strong></span>: A high resolution <a id="id85" class="indexterm"/>device will have a higher pixel density and hence, for the same zoom level, it will have a high device-pixel ratio compared to a lower resolution device. For example: a high-end Lumia 950 phone will have a higher resolution than a budget Lumia 630 phone, and therefore it will have a higher device-pixel ratio for the same zoom level.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Zoom level of the browser</strong></span>: For the <a id="id86" class="indexterm"/>same device, a higher zoom level means a higher number of device pixels per CSS pixel, and hence a higher device-pixel ratio. For example, consider this figure:<div class="mediaobject"><img src="graphics/B05381_02_08.jpg" alt="Device-pixel ratio"/></div></li></ul></div><p>When you zoom in on your browser (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>+</em></span>), the number of CSS pixels for your <code class="literal">div</code> remains the same, but the number of device pixels it occupies increases. So, you have a higher number of device pixels per CSS pixel.</p><p>When you want to display separate images (or usually, a separate asset of the same image) based on the device-pixel ratio, you'd go with a basic <code class="literal">srcset</code> implementation:</p><div class="informalexample"><pre class="programlisting">&lt;img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" /&gt;</pre></div><p>The <code class="literal">x</code> descriptor in the <code class="literal">srcset</code> attribute is used to define the device-pixel ratio:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a device-pixel ratio of 1, the <code class="literal">image-src.png</code> image will be used.</li><li class="listitem" style="list-style-type: disc">For a device-pixel ratio of 2, the <code class="literal">image-2x.png</code> image will be used.</li></ul></div><p>The <code class="literal">src</code> attribute is used as a fallback for browsers that do not yet support <code class="literal">srcset</code> implementation.</p><p>This works <a id="id87" class="indexterm"/>well. Using the <code class="literal">x</code> descriptor, you'll always get the same image on devices with a similar device-pixel ratio—even if this means that you get the same image on a 13.5-inch laptop, and a 5-inch mobile phone, which both have the same device-pixel ratio.</p></div></div><div class="section" title="The sizes attribute"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>The sizes attribute</h4></div></div></div><p>The <a id="id88" class="indexterm"/>actual implementation where you'd want a different-sized image (different height and width) on different screen sizes is accomplished by using the <code class="literal">sizes</code> attribute along with the <code class="literal">w</code> descriptor of the <code class="literal">srcset</code> attribute.</p><p>Say you want the image to be viewed in half of the viewport width. You'll type:</p><div class="informalexample"><pre class="programlisting">&lt;img src="image-src.png" sizes="50vw"
srcset="image-src.png 1x, image-2x.png 2x 400w"&gt;</pre></div></div><div class="section" title="The picture element"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>The picture element</h4></div></div></div><p>As we <a id="id89" class="indexterm"/>saw in the previous section, the <code class="literal">picture</code> element is used when you want to show a different image depending on the rendered size of the image. The <code class="literal">picture</code> element is a container, which contains other elements that control the image to be downloaded:</p><div class="informalexample"><pre class="programlisting">&lt;picture&gt;
  &lt;img src="image-src.png" sizes="50vw"srcset="image-src.png 1x, image-2x.png 2x 400w"&gt;
&lt;/picture&gt;</pre></div><p>At runtime, the <code class="literal">srcset</code> attribute or the <code class="literal">&lt;picture&gt;</code> element selects the most appropriate image asset and performs a network request.</p><p>If you want to cache an image during the install step for the service worker, you have a few options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing a single low-resolution version of the image</li><li class="listitem" style="list-style-type: disc">Installing a single high-resolution version of the image</li></ul></div><p>It is ideal to limit the amount to two or three images in order to preserve memory.</p><p>To improve the load time, you may decide to go for the low resolution version at the time of installation, and you would try to retrieve higher resolution images from the network when the page is<a id="id90" class="indexterm"/> loaded; however, in the case that the high-resolution images fail, you would think you can easily fall back to the low resolution version, but there is one issue.</p><p>Let's assume we have two images:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Display density</p>
</th><th style="text-align: left" valign="bottom">
<p>Width</p>
</th><th style="text-align: left" valign="bottom">
<p>Height</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">1x</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">400</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">400</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">2x</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">800</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">800</code>
</p>
</td></tr></tbody></table></div><p>Here is the markup for an <code class="literal">srcset</code> image:</p><div class="informalexample"><pre class="programlisting">&lt;img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x" /&gt;</pre></div><p>On a screen with a <code class="literal">2x</code> display, the browser could opt to download <code class="literal">image-2x.png</code>, if we are offline, then we could catch this request and return the <code class="literal">image-src.png</code> image instead if the image is cached, the browser may expect an image that considers the extra pixels on a <code class="literal">2x</code> screen, therefore the image will appear as 200 x 200 pixels instead of 400 x 400 pixels. The only fix is to set a fixed width and height on the image:</p><div class="informalexample"><pre class="programlisting">&lt;img src="image-src.png" srcset="image-src.png 1x, image-2x.png 2x"
style="width:400px; height: 400px;" /&gt;</pre></div><p>We can take the same approach to <code class="literal">srcset</code>.</p><p>No width or height set:</p><div class="mediaobject"><img src="graphics/B05381_02_09.jpg" alt="The picture element"/></div><p>Height and <a id="id91" class="indexterm"/>width set:</p><div class="mediaobject"><img src="graphics/B05381_02_10.jpg" alt="The picture element"/></div><p>If you want <a id="id92" class="indexterm"/>to unregister the service worker, you can head to the Developer Toolbar in Chrome, and click the <span class="strong"><strong>Unregister</strong></span> button in the <span class="strong"><strong>Service Workers</strong></span> section, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05381_02_11.jpg" alt="The picture element"/></div><p>If you <a id="id93" class="indexterm"/>want to find out the resources stored in the caches, you can do so by opening Developer Tools and looking at the <span class="strong"><strong>Resources</strong></span> tab:</p><div class="mediaobject"><img src="graphics/B05381_02_12.jpg" alt="The picture element"/></div><p>If you are <a id="id94" class="indexterm"/>using Firefox Nightly, you can view the caches by opening up Developer Tools and looking at the Storage Inspector:</p><div class="mediaobject"><img src="graphics/B05381_02_13.jpg" alt="The picture element"/></div></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Registering a service worker in detail</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating mock responses</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li></ul></div></div></div>
<div class="section" title="Loading CSS offline"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Loading CSS offline</h1></div></div></div><p>CSS is<a id="id95" class="indexterm"/> essential<a id="id96" class="indexterm"/> in structuring your website and making it look functional. Because of this, if your website goes offline and the CSS is not available in the cache, your website will look broken. In order to achieve this, we cache CSS with service workers, and deliver those CSS files as external<a id="id97" class="indexterm"/> resources. In this recipe, we are going to look at how to load CSS offline.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we must create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Offline CSS&lt;/title&gt;
  &lt;link rel="stylesheet" href="style-2.css"&gt;
  &lt;link rel="stylesheet" href="style-1.css"&gt;
&lt;/head&gt; 
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
      var scope = {
      scope: './'
    };

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js', scope)
      .then(
        function(serviceWorker) {
        printStatus('successful');
      }).catch(function(error) {
        printStatus(error);
      });
    } else {
      printStatus('unavailable');
    }

    function printStatus(status) {
      document.getElementById('status').innerHTML = status;
    }  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create <a id="id98" class="indexterm"/>a JavaScript file called <code class="literal">service-worker.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">var version = 1;
var cacheName = 'static-' + version;

self.addEventListener('install', installHandler);
self.addEventListener('fetch', fetchHandler);

function installHandler(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
              'index.html',
              'style-2.css'
            ]);
        })
    );
}

function fetchHandler(event) {
  if (/index/.test(event.request.url) || /style-2/.test(event.request.url)) {
    event.respondWith(caches.match(event.request));
  }
}</pre></div></li><li class="listitem">Create a CSS file called <code class="literal">style-1.css</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">body {
    background-color: lightgreen;
}</pre></div></li><li class="listitem">Create another CSS file called <code class="literal">style-2.css</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">body {
    background-color: red;
}</pre></div></li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file. You will see that the background <a id="id99" class="indexterm"/>color is green:<div class="mediaobject"><img src="graphics/B05381_02_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open up the Developer Tools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>) and change the <span class="strong"><strong>Network</strong></span> tab to <span class="strong"><strong>Offline</strong></span> as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B05381_02_15.jpg" alt="How to do it..."/></div></li><li class="listitem">The <a id="id100" class="indexterm"/>color of the background is now red.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>How it works...</h2></div></div></div><p>In the header section of the <code class="literal">index.html</code> file, we are linking two CSS files:</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Offline CSS&lt;/title&gt;
  &lt;link rel="stylesheet" href="style-2.css"&gt;
  &lt;link rel="stylesheet" href="style-1.css"&gt;
&lt;/head&gt;</pre></div><p>In our styles sheets, we are referencing the same CSS property of body.</p><p>Because of the order we are calling the CSS files, the last selector takes effect on the online page, in our case, this is the <code class="literal">body</code> selector of <code class="literal">style-1.css</code>:</p><div class="informalexample"><pre class="programlisting">body {
    background-color: lightgreen;
}</pre></div><p>In the <code class="literal">service-worker.js</code> file, we add <code class="literal">index.html</code> and the <code class="literal">style-2.css</code> file to the cache when we<a id="id101" class="indexterm"/> install the service worker. In the first few lines, we specify the cache version and the URL for the offline page:</p><div class="informalexample"><pre class="programlisting">var version = 1;
var cacheName = 'static-' + version;</pre></div><p>The event listener for the install event calls the <code class="literal">waitUntil</code> function, where we cache <code class="literal">index.html</code>, and the CSS file. The <code class="literal">cache.addAll</code> function takes an array of files to be cached:</p><div class="informalexample"><pre class="programlisting">function installHandler(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
              'index.html',
              'style-2.css'
            ]);
        })
    );
}</pre></div><p>When we reload the page, after it is set to go offline, the fetch event gets fired, retrieves those two files from the cache, and sends them along with the response:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(event) {
    event.respondWith(caches.match(event.request));
});</pre></div><p>Now, when we refresh the page, the background will change to red, as the CSS file we saved in the cache will be applied to the page this time.</p></div></div>
<div class="section" title="Loading fonts offline"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Loading fonts offline</h1></div></div></div><p>If your <a id="id102" class="indexterm"/>website uses external fonts, such as open source web fonts, you could cache them to be viewed offline with service workers. In this chapter, we are going to look at how to load fonts offline.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How to do it...</h2></div></div></div><p>Follow these<a id="id103" class="indexterm"/> instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we must create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Offline Fonts&lt;/title&gt;
  &lt;style&gt;
    @font-face{
      font-family: 'MyWebFont';
      src: url('webfont-serif.woff') format('woff');
    }
    p { font-family: 'MyWebFont', Arial, sans-serif; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
      var scope = {
      scope: './'
    };

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js', scope)
      .then(
        function(serviceWorker) {
        printStatus('successful');
      }).catch(function(error) {
        printStatus(error);
      });
    } else {
      printStatus('unavailable');
    }

    function printStatus(status) {
      document.getElementById('status').innerHTML = status;
    }  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a<a id="id104" class="indexterm"/> JavaScript file called <code class="literal">service-worker.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">'use strict';

var version = 1;
var cacheName = 'static-' + version;

self.addEventListener('install', installHandler);
self.addEventListener('fetch', fetchHandler);

function installHandler(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
                'index.html',
                'webfont-serif.woff'
            ]);
        })
    );
}

function fetchHandler(event) {
    event.respondWith(caches.match(event.request));
}</pre></div></li><li class="listitem">Download a <a id="id105" class="indexterm"/>web font from <a class="ulink" href="https://www.google.com/fonts">https://www.google.com/fonts</a> and save it in the same folder as the <code class="literal">index.html</code> file. If you are not quite sure how to do this, please look at the following <span class="emphasis"><em>There's more...</em></span> section.</li><li class="listitem">Open up the <a id="id106" class="indexterm"/>browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_02_16.jpg" alt="How to do it..."/></div></li><li class="listitem">Open up Chrome Developer Tools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or Fb12), select the <span class="strong"><strong>Network</strong></span> tab, and click <span class="strong"><strong>Offline</strong></span>:<div class="mediaobject"><img src="graphics/B05381_02_17.jpg" alt="How to do it..."/></div></li><li class="listitem">Refresh <a id="id107" class="indexterm"/>the page by pressing <span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>R</em></span> or <span class="emphasis"><em>F5</em></span>, and you will see the font looks the same as it did online.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How it works...</h2></div></div></div><p>In the header section of the <code class="literal">index.html</code> file, we link the font file we have downloaded inside a <code class="literal">style</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
   @font-face{
     font-family: 'MyWebFont';
     src: url('webfont-serif.woff') format('woff');
   }

   p { font-family: 'MyWebFont', Arial, sans-serif; }
&lt;/style&gt;</pre></div><p>The <code class="literal">@font-face</code> declaration will specify a font named <code class="literal">myWebFont</code> and specify the URL where it can be found. In our case, it is in the same directory as the <code class="literal">index.html</code> file. Then we reference the font inside the paragraph declaration as the <code class="literal">font-family</code> attribute:</p><div class="informalexample"><pre class="programlisting">p { font-family: 'MyWebFont', Arial, sans-serif; }</pre></div><p>In the service<a id="id108" class="indexterm"/> worker script file, we add our offline page to the cache when we install the service worker. In the first few lines, we specify the cache version and the URL for the offline page:</p><div class="informalexample"><pre class="programlisting">var version = 1;
var cacheName = 'static-' + version;</pre></div><p>The event listener for the install event calls the <code class="literal">waitUntil</code> function, where we cache the <code class="literal">index.html</code> file and the font file; in our case <code class="literal">webfont-serif.woff</code>. The <code class="literal">cache.addAll</code> function takes an array of files to be cached:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('install', function(event) {
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.addAll([
                'index.html',
                'webfont-serif.woff'
            ]);
        })
    );
});</pre></div><p>When we reload the page, after it is set to go offline, the fetch event gets fired, retrieves those two files from the cache, and sends them along with the response:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(event) {
    event.respondWith(caches.match(event.request));
});    </pre></div><p>Now, the page will be displayed as it was online.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>There's more...</h2></div></div></div><p>In order to find a free <a id="id109" class="indexterm"/>font family from Google and download it, please perform the following instructions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Please navigate to <a class="ulink" href="https://www.google.com/fonts">https://www.google.com/fonts</a>, and search, or browse, the desired font, then add the one you like to your collection by clicking on the blue <span class="strong"><strong>Add to Collection</strong></span> button on the right side of the font:<div class="mediaobject"><img src="graphics/B05381_02_18.jpg" alt="There's more..."/></div></li><li class="listitem">Your collection will show at the bottom of your screen. Once it has, select the <span class="strong"><strong>Use this style</strong></span> checkbox, towards the top-left side of the screen:<div class="mediaobject"><img src="graphics/B05381_02_19.jpg" alt="There's more..."/></div></li><li class="listitem">Now, when<a id="id110" class="indexterm"/> you click the arrow on the top right-hand side of the page, it will prompt you with a dialog. You can choose the first option, which downloads the file as a ZIP file:<div class="mediaobject"><img src="graphics/B05381_02_20.jpg" alt="There's more..."/></div></li><li class="listitem">Once you unzip the file, you will find the font you need inside the folder. If you want to <a id="id111" class="indexterm"/>unregister a service worker, you can go to <code class="literal">chrome://service-worker-internals</code> and click the <span class="strong"><strong>Unregister</strong></span> button:<div class="mediaobject"><img src="graphics/B05381_02_21.jpg" alt="There's more..."/></div></li><li class="listitem">In Firefox Nightly, you can go to <code class="literal">about:serviceworkers</code> and click on the <span class="strong"><strong>Unregister</strong></span> button:<div class="mediaobject"><img src="graphics/B05381_02_22.jpg" alt="There's more..."/></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Registering a service worker in detail</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating mock responses</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li></ul></div></div></div>
<div class="section" title="Implementing multiple fetch handlers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Implementing multiple fetch handlers</h1></div></div></div><p>Service workers <a id="id112" class="indexterm"/>can handle multiple fetch handlers, each of which intercepts a different type of request. This recipe explains, in detail, how different types of request can be handled by implementing separate fetch handlers.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this <a id="id113" class="indexterm"/>feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Multiple Fetch&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(
        'service-worker.js',
        { scope: './' }
      ).then( function(serviceWorker) {
        document.getElementById('status').innerHTML = 'successful';
      }).catch(function(error) {
        document.getElementById('status').innerHTML = error;
      });
    } else {
      document.getElementById('status').innerHTML = 'unavailable';
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file with the following code:<div class="informalexample"><pre class="programlisting">var cookFetchHandler = function(event) {
  console.log('DEBUG: Inside the /cook handler.');
  if (event.request.url.indexOf('/cook/') &gt; 0) {
    event.respondWith(new Response('Fetch handler for /cook'));
  }
};

var cookBookFetchHandler = function(event) {
  console.log('DEBUG: Inside the /cook/book handler.');
  if (event.request.url.endsWith('/cook/book')) {
    event.respondWith(new Response('Fetch handler for /cook/book'));
  }
};

var fetchHandlers = [cookBookFetchHandler, cookFetchHandler];

fetchHandlers.forEach(function(fetchHandler) {
  self.addEventListener('fetch', fetchHandler);
});</pre></div></li><li class="listitem">Open up a<a id="id114" class="indexterm"/> browser and go to the <code class="literal">index.html</code> file. You will see the <span class="strong"><strong>Registration status: successful</strong></span> message:<div class="mediaobject"><img src="graphics/B05381_02_23.jpg" alt="How to do it..."/></div></li><li class="listitem">Change the URL by adding <code class="literal">/cook/</code> in front as follows:<div class="mediaobject"><img src="graphics/B05381_02_24.jpg" alt="How to do it..."/></div></li><li class="listitem">Change<a id="id115" class="indexterm"/> the URL again by adding <code class="literal">/book</code> in front as follows:<div class="mediaobject"><img src="graphics/B05381_02_25.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How it works...</h2></div></div></div><p>When the registration is successful, we inspect the state of the registration, and print it to the browser. Now it's time to trigger the responses by the service worker. In the <code class="literal">service-worker.js</code> file, there are two registered fetch handlers, <code class="literal">cookFetchHandler</code> and <code class="literal">cookBookFetchHandler</code>:</p><div class="informalexample"><pre class="programlisting">var cookFetchHandler = function(event) {
  console.log('DEBUG: Inside the /cook handler.');
  if (event.request.url.indexOf('/cook/') &gt; 0) {
    event.respondWith(new Response('Fetch handler for /cook'));
  }
};

var cookBookFetchHandler = function(event) {
  console.log('DEBUG: Inside the /cook/book handler.');
  if (event.request.url.endsWith('/cook/book')) {
    event.respondWith(new Response('Fetch handler for /cook/book'));
  }
};</pre></div><p>The first handler, <code class="literal">cookFetchHandler</code>, intercepts requests ending with <code class="literal">/cook</code> anywhere in the URL, and returns a new response with the wording, <code class="literal">Fetch handler for /cook</code>.</p><p>The second handler, <code class="literal">cookBookFetchHandler</code>, intercepts requests ending with <code class="literal">/cook/book</code> anywhere in the URL, and returns a new response with the wording, <code class="literal">Fetch handler for /cook/book</code>.</p><p>Since <code class="literal">cookBookFetchHandler</code> is registered first, when it intercepts <code class="literal">/cook/book</code> requests, it will always first have the chance to return a response via <code class="literal">event.respondWith()</code>.The second handler gets its chance to handle <code class="literal">event.respondWith()</code> only if the first handler does not call it.</p><p>When the fetch event occurs, they are invoked one at a time, in the order they are registered. Any time a handler calls <code class="literal">event.respondWith()</code>, none of the other registered handlers will be run:</p><div class="informalexample"><pre class="programlisting">var fetchHandlers = [cookBookFetchHandler, cookFetchHandler];

fetchHandlers.forEach(function(fetchHandler) {
  self.addEventListener('fetch', fetchHandler);
});</pre></div><p>If none of the registered fetch handlers call <code class="literal">event.respondWith()</code>, the browser takes control and makes a normal HTTP request. This is the normal procedure, when no service workers are involved.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>There's more...</h2></div></div></div><p>Within each fetch handler, we have to make sure that the logic that determines whether or not<a id="id116" class="indexterm"/> to call <code class="literal">event.respondWith()</code>, is executed synchronously. Simple <code class="literal">if()</code> statements that check <code class="literal">event.request.url</code> are fine. Anything asynchronous, such as performing <code class="literal">caches.match()</code> and then deciding whether or not to call <code class="literal">event.respondWith()</code> based on the response, will trigger a race condition, and you're likely to see an <code class="literal">event already responded to</code> error in the console.</p><p>If you want to unregister the service worker, you can head to the Developer Toolbar in Chrome and click the <span class="strong"><strong>Unregister</strong></span> button in the <span class="strong"><strong>Service Workers</strong></span> section, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05381_02_26.jpg" alt="There's more..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Registering a service worker in detail</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating mock responses</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li></ul></div></div></div>
<div class="section" title="Fetching remote resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Fetching remote resources</h1></div></div></div><p>Fetching remote resources <a id="id117" class="indexterm"/>can be done in a few different ways. In this recipe, we are going to look at two standard ways of fetching remote resources, as well as finding out how to use a service worker to act like a proxy middleware.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the <span class="emphasis"><em>Setting up service workers</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>. Service workers only run <a id="id118" class="indexterm"/>across HTTPS. To find out how to set up a development environment to support this feature, refer to the <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to create an <code class="literal">index.html</code> file as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Fetching Offline Resources&lt;/title&gt;
  &lt;style&gt;
      .error {
        color: #FF0000;
      }
      .success {
        color: #00FF00;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;section&gt;
      &lt;h1&gt;Images&lt;/h1&gt;
      &lt;div id="https-acao-image"&gt;&lt;/div&gt;
      &lt;div id="https-image"&gt;&lt;/div&gt;
      &lt;div id="http-image"&gt;&lt;/div&gt;
    &lt;/section&gt;

    &lt;section&gt;
      &lt;h1&gt;HTTPS Fetch&lt;/h1&gt;
      &lt;div id="https-cors"&gt;
        &lt;strong&gt;https-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="https-no-cors"&gt;
        &lt;strong&gt;https-no-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="https-acao-cors"&gt;
        &lt;strong&gt;https-acao-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="https-acao-no-cors"&gt;
        &lt;strong&gt;https-acao-no-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="service-https-cors"&gt;
        &lt;strong&gt;service-https-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="service-http-cors"&gt;
        &lt;strong&gt;service-http-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="service-http-no-cors"&gt;
        &lt;strong&gt;service-http-no-cors&lt;/strong&gt;
      &lt;/div&gt;
    &lt;/section&gt;

    &lt;section&gt;
      &lt;h1&gt;HTTP Fetch&lt;/h1&gt;
      &lt;div id="http-cors"&gt;
        &lt;strong&gt;http-cors&lt;/strong&gt;
      &lt;/div&gt;
      &lt;div id="http-no-cors"&gt;
        &lt;strong&gt;http-no-cors&lt;/strong&gt;
      &lt;/div&gt;
    &lt;/section&gt;

    &lt;script src="index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a JavaScript <a id="id119" class="indexterm"/>file called <code class="literal">index.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">'use strict';

var protocols = {
'https': 
'https://dz13w8afd47il.cloudfront.net/sites/all/themes/packt_v4/images/packtlib-logo-dark.png',

  'https-acao': 
'https://i942.photobucket.com/albums/ad261/szaranger/Packt/packt-logo.png',
  
  'http': 
'http://seanamarasinghe.com/wp-content/uploads/2015/06/icon-128x128.jpg'
};

navigator.serviceWorker.getRegistration()
.then(function(registration) {
  var fetchModes = ['cors', 'no-cors'];

  if (!registration || !navigator.serviceWorker.controller) {
    navigator.serviceWorker.register(
    './service-worker.js').then(function() {
        console.log('Service worker registered, 
        reloading the page');
        window.location.reload();
    });
  } else {
    console.log('Client is under service worker\s control');

    for (var protocol in protocols) {
      if (protocols.hasOwnProperty(protocol)) {
        buildImage(protocol, protocols[protocol]);

        for (var index = 0; index &lt; fetchModes.length; index++) {
          var fetchMode = fetchModes[index],
            init = { method: 'GET',
                     mode: fetchMode,
                     cache: 'default' };

          fireRequest(fetchMode, protocol, init)();
        }
      }
    }
  }
});

function buildImage(protocol, url) {
  var element = protocol + '-image',
    image = document.createElement('img');

  image.src = url;
  document.getElementById(element).appendChild(image);
}

function fireRequest(fetchMode, protocol, init) {
  return function() {
    var section = protocol + '-' + fetchMode,
      url = protocols[protocol];

    fetch(url, init).then(function(response) {
      printSuccess(response, url, section);
    }).catch(function(error) {
      printError(error, url, section);
    });
    
    fetch('./proxy/' + url, init).then(function(response) {
      url = './proxy/' + url;
      printSuccess(response, url, section);
    }).catch(function(error) {
      section = 'service-' + section;

      console.log(section, 'ERROR: ', url, error);
      log(section, 'ERROR: ' + error, 'error');
    });
  };
}

function printSuccess(response, url, section) {
  if (response.ok) {
    console.log(section, 'SUCCESS: ', url, response);
    log(section, 'SUCCESS');
  } else {
    console.log(section, 'FAIL:', url, response);
    log(section, 'FAIL: response type: ' + response.type +
                 ', response status: ' + 
                 response.status, 'error');
  }
}

function printError(error, url, section) {
  console.log(section, 'ERROR: ', url, error);
  log(section, 'ERROR: ' + error, 'error');
}

function log(id, message, type) {
  var sectionElement = document.getElementById(id),
    logElement = document.createElement('p');

  if (type) {
    logElement.classList.add(type);
  }
  logElement.textContent = message;
  sectionElement.appendChild(logElement);
}</pre></div></li><li class="listitem">Create a <a id="id120" class="indexterm"/>JavaScript file called <code class="literal">service-worker.js</code>, in the same folder as the <code class="literal">index.html</code> file, with the following code:<div class="informalexample"><pre class="programlisting">self.onfetch = function(event) {
  if (event.request.url.indexOf('proxy') &gt; -1) {
    var init = { method: 'GET',
                 mode: event.request.mode,
                 cache: 'default' };
    var url = event.request.url.split('proxy/')[1];
    console.log('DEBUG: proxying', url);
    event.respondWith(fetch(url, init));
  } else {
    event.respondWith(fetch(event.request));
  }
};</pre></div></li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_02_27.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How it works...</h2></div></div></div><p>At the <a id="id121" class="indexterm"/>beginning of the <code class="literal">index.js</code> file, we are testing three different protocols for loading resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">https</code>: HTTP with <span class="strong"><strong>Secure Socket Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>) protocol</li><li class="listitem" style="list-style-type: disc"><code class="literal">https-acao</code>: SSL protocol with the <span class="strong"><strong>Access-Control-Origin=*</strong></span> header</li><li class="listitem" style="list-style-type: disc"><code class="literal">http</code>: HTTP without SSL</li></ul></div><p>We will use three different URLs, which will be loaded multiple times:</p><div class="informalexample"><pre class="programlisting">var protocols = {
  'https-acao':  
    'https://i942.photobucket.com/albums/ad261/szaranger/Packt/packt-logo.png',
  'https': 
    'https://dz13w8afd47il.cloudfront.net/sites/all/themes/packt_v4/images/packtlib-logo-dark.png',
  'http': 
    'http://seanamarasinghe.com/wp-content/uploads/2015/06/icon-128x128.jpg'
};</pre></div><p>We also use two different methods for fetching resources, with or without <code class="literal">cors</code>:</p><div class="informalexample"><pre class="programlisting">var fetchModes = ['cors', 'no-cors'];</pre></div><p>Next, we check to see whether the service worker is registered:</p><div class="informalexample"><pre class="programlisting">  navigator.serviceWorker.register(
'./service-worker.js').then(function() {
      console.log('Service worker registered, reloading the page');
      window.location.reload();
    });</pre></div><p>If that is not the case, then we register it and reload the page to make sure the client is under the service worker's control:</p><div class="informalexample"><pre class="programlisting">for (var protocol in protocols) {
      if (protocols.hasOwnProperty(protocol)) {
        buildImage(protocol, protocols[protocol]);

        for (var i = 0; i &lt; fetchModes.length; i++) {
          var fetchMode = fetchModes[i],
            init = { 
                 method: 'GET',
                 mode: fetchMode,
                 cache: 'default' 
            };

          fireRequest(fetchMode, protocol, init)();
        }
      }
}</pre></div><p>The <code class="literal">for</code> loops go<a id="id122" class="indexterm"/> through the provided <code class="literal">protocols</code> array, make requests for each protocol, build a DOM image element with each URL, and go through each mode of the <code class="literal">fetchModes</code> array.</p><p>The <code class="literal">init</code> object contains any custom settings that you want to apply to the request:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: The<a id="id123" class="indexterm"/> request method, for example, <code class="literal">GET</code> and <code class="literal">POST</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mode</code>: The <a id="id124" class="indexterm"/>mode you want to use for the request, for example, <code class="literal">cors</code>, <code class="literal">no-cors</code>, or <code class="literal">same-origin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cache</code>: The <a id="id125" class="indexterm"/>cache mode you want to use for the request: <code class="literal">default</code>, <code class="literal">no-store</code>, <code class="literal">reload</code>, <code class="literal">no-cache</code>, <code class="literal">force-cache</code>, or <code class="literal">only-if-cached</code></li></ul></div><p>The <code class="literal">buildImage</code> function takes two arguments: <code class="literal">protocol</code> and <code class="literal">url</code>. It creates an image element on the fly and attaches the URL as the source of that image. Then it goes on to add that image to the DOM tree, where the ID is one of <code class="literal">https-acao-image</code>, <code class="literal">https-image</code>, or <code class="literal">http–image</code>. JavaScript has no control over the URL handling at this point; the browser handles the URLs:</p><div class="informalexample"><pre class="programlisting">function buildImage(protocol, url) {
  var element = protocol + '-image',
    image = document.createElement('img');

  image.src = url;
  document.getElementById(element).appendChild(image);
}</pre></div><p>Images will be rendered for HTTPS requests only, as service workers only support connections over SSL:</p><div class="mediaobject"><img src="graphics/B05381_02_28.jpg" alt="How it works..."/></div><p>The broken <a id="id126" class="indexterm"/>image is the one requested over standard HTTP, which fails to respond with the requested image.</p><p>Other requests over HTTP also fail to deliver, resulting in errors:</p><div class="mediaobject"><img src="graphics/B05381_02_29.jpg" alt="How it works..."/></div><p>The requests over SSL, with the <span class="strong"><strong>Access-Control-Origin=*</strong></span> header (<span class="strong"><strong>Access Control Allow Origin</strong></span>), will return results successfully:</p><div class="mediaobject"><img src="graphics/B05381_02_30.jpg" alt="How it works..."/></div><p>By default, <a id="id127" class="indexterm"/>fetching a resource from a third-party URL will fail if it doesn't support CORS. You can add a non-CORS option to the request to overcome this, although this will cause an <span class="emphasis"><em>opaque</em></span> response, which means you won't be able to tell whether the response was successful or not:</p><div class="mediaobject"><img src="graphics/B05381_02_31.jpg" alt="How it works..."/></div><p>The <code class="literal">fireRequest</code> function takes three arguments, <code class="literal">fetchMode</code>, <code class="literal">protocol</code>, and <code class="literal">init</code>. This function, in turn returns another function, which we can call a composition. We start with fetching the given resource directly from the remote resource:</p><div class="informalexample"><pre class="programlisting"> fetch(url, init).then(function(response) {
    printSuccess(response, url, section);
 }).catch(function(error) {
    printError(error, url, section);
 });</pre></div><p>If the fetch was successful, we print it to the console, as well as log it on the webpage. We do the same if the request fails, only we print <code class="literal">error</code>.</p><p>We also attempt to fetch the resource with the service worker's proxy, which the client recognizes as a local resource:</p><div class="informalexample"><pre class="programlisting">fetch('./proxy/' + url, init).then(function(response) {
    url = './proxy/' + url;
    printSuccess(response, url, section);
  }).catch(function(error) {
    section = 'service-' + section;

     console.log(section, 'ERROR: ', url, error);
    log(section, 'ERROR: ' + error, 'error');
   });</pre></div><p>The <code class="literal">printSuccess</code> and <code class="literal">printError</code> functions log responses to the console, as well as the DOM of the web page:</p><div class="informalexample"><pre class="programlisting">function printSuccess(response, url, section) {
  if (response.ok) {
    console.log(section, 'SUCCESS: ', url, response);
    log(section, 'SUCCESS');
  } else {
    console.log(section, 'FAIL:', url, response);
    log(section, 'FAIL: response type: ' + response.type +
                 ', response status: ' + response.status, 'error');
  }
}

function printError(error, url, section) {
  console.log(section, 'ERROR: ', url, error);
  log(section, 'ERROR: ' + error, 'error');
}</pre></div><p>The helper <a id="id128" class="indexterm"/>function log finds the DOM element by the ID, and adds a paragraph element, as well as a class attribute, to depict the type of the message:</p><div class="informalexample"><pre class="programlisting">function log(id, message, type) {
  var type = type || 'success',
    sectionElement = document.getElementById(id),
    logElement = document.createElement('p');

  if (type) {
    logElement.classList.add(type);
  }
  logElement.textContent = message;
  sectionElement.appendChild(logElement);
}</pre></div><p>In the <code class="literal">index.html</code> file, we have style declarations in the <code class="literal">head</code> section:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
.error {
     color: #FF0000;
   }
   .success {
     color: #00FF00;
   }
&lt;/style&gt;</pre></div><p>In our <code class="literal">log()</code> function, we set the undefined type to success, so that it will display the color green when we add it to <code class="literal">classList</code>. The error type will display red as declared in the previous styles.</p><p>Let's move <a id="id129" class="indexterm"/>over to our <code class="literal">service-worker.js</code> file. There we have the <code class="literal">onfetch</code> event handler, which gets fired whenever a fetch event occurs. Here, we check to see whether the request has a <code class="literal">proxy/</code> parameter in it. If it does, then it responds with the remaining part of the URL:</p><div class="informalexample"><pre class="programlisting">var url = event.request.url.split('proxy/')[1];
console.log('DEBUG: proxying', url);
event.respondWith(fetch(url, init));</pre></div><p>Otherwise, the response will perform the request with the full URL:</p><div class="informalexample"><pre class="programlisting">} else {
    event.respondWith(fetch(event.request));
}</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>There's more...</h2></div></div></div><p>Let's examine the defaults of the <code class="literal">fetch()</code> function in more detail.</p><div class="section" title="No credentials by default"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>No credentials by default</h3></div></div></div><p>When you<a id="id130" class="indexterm"/> use fetch, by default, requests won't contain credentials such as cookies. If you want credentials, you can call this instead:</p><div class="informalexample"><pre class="programlisting">fetch(url, {
  credentials: 'include'
});</pre></div><p>This behavior is intentional, and is arguably better than XHR's more complex default behavior of sending credentials if the URL has the same origin, but omitting them otherwise.</p><p>Fetch's behavior is more like other CORS requests, such as <code class="literal">&lt;img crossorigin&gt;</code>, which never sends cookies unless you opt in with <code class="literal">&lt;img crossorigin="use-credentials"&gt;</code>.</p></div><div class="section" title="Non-CORS fail by default"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Non-CORS fail by default</h3></div></div></div><p>By default, fetching <a id="id131" class="indexterm"/>a resource from a third-party URL will fail if it doesn't support CORS. You can add a non-CORS option to the <span class="strong"><strong>Request</strong></span> function to overcome this, although this will cause an <span class="emphasis"><em>opaque</em></span> response, which means you won't be able to tell whether the response was successful or not:</p><div class="informalexample"><pre class="programlisting">cache.addAll(urlsToPrefetch.map(function(urlToPrefetch) {
  return new Request(urlToPrefetch, { mode: 'no-cors' });
})).then(function() {
  console.log('All resources have been fetched and cached.');
});</pre></div><p>If you want <a id="id132" class="indexterm"/>to unregister the service worker, you can head over to the <code class="literal">chrome://service-worker-internals</code> page in Chrome and click the <span class="strong"><strong>Unregister</strong></span> button of the relevant service worker, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05381_02_32.jpg" alt="Non-CORS fail by default"/></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Registering a service worker in detail</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating mock responses</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span></li></ul></div></div></div></body></html>