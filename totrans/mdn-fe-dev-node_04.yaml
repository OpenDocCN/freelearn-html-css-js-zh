- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using Different Flavors of JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同版本的 JavaScript
- en: With the previous chapter, you’ve completed the essentials for doing projects
    in Node.js. Looking at real projects out there, you’ll find quickly that people
    use Node.js with all kinds of flavors of JavaScript. A **flavor** of JavaScript
    is a new language that can be seen as a variation of the official JavaScript language
    standard. Mostly, these flavors look very much like the JavaScript you are used
    to but differ in key parts. Sometimes, they add new language constructs to simplify
    certain tasks; sometimes, they bring improvements for reliability before releasing
    any code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经完成了在 Node.js 中进行项目的基本要素。看看现实中的项目，您会很快发现人们使用各种版本的 JavaScript 与 Node.js
    一起使用。JavaScript 的一个 **版本** 可以看作是官方 JavaScript 语言标准的变体。大多数情况下，这些版本看起来非常像您所习惯的 JavaScript，但在关键部分有所不同。有时，它们添加新的语言结构以简化某些任务；有时，在发布任何代码之前，它们会带来改进以确保可靠性。
- en: In this chapter, we’ll learn how different flavors of JavaScript can be used
    with Node.js. We will introduce the most important tools and flavors. As far as
    the tooling part is concerned, we’ll introduce the popular open source package,
    **Babel**. This tool can be quite helpful to teach Node.js how to use a flavor
    of JavaScript. These flavors include interesting additions to the language such
    as **Flow** or **TypeScript**. Both introduce type systems, but the latter also
    adds new constructs to the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Node.js 与不同的 JavaScript 版本。我们将介绍最重要的工具和版本。就工具部分而言，我们将介绍流行的开源包
    **Babel**。这个工具可以帮助 Node.js 学习如何使用一个 JavaScript 版本。这些版本包括对语言的一些有趣补充，如 **Flow**
    或 **TypeScript**。两者都引入了类型系统，但后者还向语言添加了新的结构。
- en: This chapter will help you to use languages that can be converted to JavaScript
    with Node.js. Ultimately, this is key – not only to be able to run JavaScript
    files independent of their syntax with any version of Node.js but also to introduce
    additional safety and convenience in larger projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您使用可以用 Node.js 转换为 JavaScript 的语言。最终，这是关键——不仅能够独立于语法在任何版本的 Node.js 上运行
    JavaScript 文件，而且还能在大型项目中引入额外的安全性和便利性。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Integrating Babel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Babel
- en: Using Flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flow
- en: Using TypeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04)
    找到。
- en: The CiA videos for this chapter can be accessed at [http://bit.ly/3UeL4Ot](http://bit.ly/3UeL4Ot).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在 [http://bit.ly/3UeL4Ot](http://bit.ly/3UeL4Ot) 访问。
- en: Integrating Babel
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Babel
- en: In the last decade, JavaScript ascended from a simple scripting language to
    the most used programming language in the whole world. With the increased popularity,
    the language has also gotten a lot of interesting features. Unfortunately, it
    always takes a while until the latest features are made available in all implementations.
    The problem gets worse if we want to use the latest language features in old implementations
    anyway.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，JavaScript 从一种简单的脚本语言上升为全球使用最广泛的编程语言。随着流行度的增加，该语言也获得了许多有趣的功能。不幸的是，最新的功能通常需要一段时间才能在所有实现中可用。如果我们想在旧实现中使用最新的语言功能，这个问题会变得更糟。
- en: This is a problem that has been known by frontend developers for years – after
    all, the version and variety of the browser used cannot be predetermined by the
    developer. Only the user makes this decision – and an older browser may not understand
    some of the modern features that the developer wants to use. In Node.js, we don’t
    have exactly the same problem – as we can theoretically decide the version of
    Node.js – but it can be a similar issue if Node.js does not have the latest language
    features or if we create tools that are supposed to run on other people’s machines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个前端开发者多年来都知道的问题——毕竟，浏览器版本和种类不能由开发者预先确定。只有用户才能做出这个决定——而且一个较旧的浏览器可能无法理解开发者想要使用的某些现代特性。在
    Node.js 中，我们并没有遇到完全相同的问题——因为我们理论上可以决定 Node.js 的版本——但如果 Node.js 没有最新的语言特性，或者如果我们创建了应该在他人机器上运行的工具，那么这可能会成为一个类似的问题。
- en: A nice way out of the language feature lockdown (that is, the restriction to
    only use the feature set supported by the engine) is to use a tool that understands
    the latest language specification and is capable of properly translating it into
    an older language specification. The process of such a programming language translation
    is called **transpilation**. The tool is called a **transpiler**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种摆脱语言特性锁定（即，仅使用由引擎支持的特性集的限制）的好方法是使用一个理解最新语言规范并能将其正确翻译成旧语言规范的工具。这种编程语言翻译的过程称为**转译**。这个工具被称为**转译器**。
- en: One of the most known transpilers for JavaScript is Babel. Its power lies in
    a rich plugin ecosystem. Actually, it is so easy to extend the JavaScript language
    with constructs using Babel, that many features were first introduced in Babel
    before they either became part of the official standard or a de facto standard.
    An example of the former is `async`/`await`, which is a fairly complex feature.
    An example of the latter is **JSX**, that is, the extension of JavaScript with
    **XML**-like constructs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的JavaScript转译器之一是Babel。它的力量在于丰富的插件生态系统。实际上，使用Babel扩展JavaScript语言的结构非常容易，以至于许多功能最初都是在Babel中引入的，然后才成为官方标准或事实标准。前者是一个例子是`async`/`await`，这是一个相当复杂的功能。后者的例子是**JSX**，即JavaScript的**XML**-样结构的扩展。
- en: 'The following code is using `async`/`await` and would be incompatible with
    Node.js before version *7.6.0*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用了`async`/`await`，并且与版本*7.6.0*之前的Node.js不兼容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we want to make this compatible with older versions (or, in general, JavaScript
    engines that cannot handle the modern `async`/`await` syntax), then we can use
    Babel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使其与旧版本（或更一般地说，无法处理现代`async`/`await`语法的JavaScript引擎）兼容，那么我们可以使用Babel。
- en: 'There are three ways of transpiling the code with Babel:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babel转译代码有三种方式：
- en: We can use the `@babel/node` package, which is a thin wrapper around Node.js.
    Essentially, it will transpile the modules during execution – that is, when they
    are needed.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`@babel/node`包，它是对Node.js的一个薄包装。本质上，它将在执行期间转译模块——也就是说，当它们被需要时。
- en: The `@babel/cli` package can be used to transpile the modules beforehand and
    run Node.js on the transpiled modules.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@babel/cli`包可以用来预先转译模块并在转译后的模块上运行Node.js。'
- en: Alternatively, the `@babel/core` package can be used to programmatically control
    the transpilation process – that is, which modules are being transpiled and what
    is done with the results.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，可以使用`@babel/core`包来编程控制转译过程——也就是说，哪些模块正在被转译以及如何处理结果。
- en: Each way has its own advantages and disadvantages. For instance, choosing `@babel/node`
    might be the easiest to get running, but will actually give us a small performance
    hit and some uncertainty. If some lesser-used module has a syntax problem, then
    we would only find out later when the module is used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其自身的优缺点。例如，选择`@babel/node`可能最容易启动，但实际上会给我们带来轻微的性能损失和一些不确定性。如果某些较少使用的模块存在语法问题，那么我们只能在模块使用时才发现。
- en: Likewise, `@babel/cli` certainly hits the sweet spot between convenience and
    power. Yes, it only works with files, but that is what we want in almost all cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`@babel/cli`在便利性和功能之间找到了一个完美的平衡点。是的，它只与文件一起工作，但在几乎所有情况下这正是我们想要的。
- en: 'One way to see very conveniently how Babel handles things is to use the interactive
    website located at [https://babeljs.io/repl](https://babeljs.io/repl). For our
    previous code example, which is using an `async` function with `await`, we get
    a view as shown in *Figure 4**.1*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常方便地查看Babel如何处理事情的方法是使用位于[https://babeljs.io/repl](https://babeljs.io/repl)的交互式网站。对于我们的上一个代码示例，它使用了一个带有`await`的`async`函数，我们得到如图*4.1*所示的视图：
- en: '![Figure 4.1 – Transpiling some JavaScript via Babel online ](img/Figure_4.01_B18989.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 通过Babel在线转译一些JavaScript](img/Figure_4.01_B18989.jpg)'
- en: Figure 4.1 – Transpiling some JavaScript via Babel online
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 通过Babel在线转译一些JavaScript
- en: 'For the screenshot shown in *Figure 4**.1*, we specified the version of Node.js
    to be *7.6*. Once we change that to something lower, for example, *7.5*, we get
    a different output. It all starts with some generated code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*图4.1*中显示的截图，我们指定了Node.js的版本为*7.6*。一旦我们将它改为更低的版本，例如，*7.5*，我们就会得到不同的输出。这一切都始于一些生成的代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the generated code, our own code is spat out. The crucial difference
    is that our code now uses the helpers from the preceding generated code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的代码之后，我们的代码被输出。关键的区别在于，我们的代码现在使用了前面生成的代码中的辅助工具：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the code was modified with the generated functions. In our case,
    those functions have been used to replace the standard `async`/`await` mechanism
    with a generator function using `yield`. But even that could be changed further
    when transpiling for Node.js before version *6.0*, which introduced support for
    generator functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码已被生成的函数修改。在我们的例子中，这些函数已被用来用`yield`替换标准的`async`/`await`机制，使用生成器函数。但在为版本*6.0*之前的Node.js进行转换时，这还可以进一步改变，因为*6.0*引入了对生成器函数的支持。
- en: In any case, Babel is actually doing the hard work of figuring out which constructs
    are used in our code, and which constructs need to be replaced depending on the
    target version of Node.js. It also knows the proper replacements and can generate
    some boilerplate code to support the language constructs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，Babel实际上正在做艰苦的工作，确定我们代码中使用了哪些构造，以及根据Node.js的目标版本需要替换哪些构造。它还知道适当的替换，并可以生成一些模板代码来支持语言构造。
- en: For Babel to do all this work, it needs to understand the JavaScript language.
    This is done by **parsing** the source code. Parsing is a process that involves
    going over all characters, grouping them into so-called tokens (such as identifiers,
    numbers, etc.), and then putting these tokens in a tree-like structure known as
    an **abstract syntax tree** (**AST**). One tool to explore the AST as seen by
    Babel can be found at [https://astexplorer.net/](https://astexplorer.net/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Babel完成所有这些工作，它需要理解JavaScript语言。这是通过**解析**源代码来实现的。解析是一个涉及遍历所有字符、将它们分组为所谓的标记（如标识符、数字等），然后将这些标记放入一个称为**抽象语法树**（**AST**）的树状结构中的过程。一个可以探索Babel看到的AST的工具可以在[https://astexplorer.net/](https://astexplorer.net/)找到。
- en: Understanding ASTs
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解ASTs
- en: Much like processing HTML results in a tree of different nodes, any programming
    language actually resolves to a tree of expressions and statements. While statements
    such as a `for` loop form a closed block of instructions, expressions such as
    an addition will always return a value. The AST puts all of those in relation
    and integrates all provided information for the respective node types. For instance,
    an addition expression consists of two expressions that should be added together.
    Those could be any expression, for example, a simple literal expression such as
    a number token.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理HTML会产生一个不同节点的树一样，任何编程语言实际上都会解析为一个表达式和语句的树。虽然`for`循环等语句形成一个封闭的指令块，但加法等表达式总是会返回一个值。AST将这些全部联系起来，并为相应的节点类型整合所有提供的信息。例如，加法表达式由两个应该相加的表达式组成。这些可以是任何表达式，例如，一个简单的字面量表达式，如数字标记。
- en: 'A snippet of the AST of the preceding example can be seen in *Figure 4**.2*.
    Each node in the AST has an associated type (such as `AwaitExpression`) and a
    position in the source document:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的AST片段可以在*图4.2*中看到。AST中的每个节点都有一个关联的类型（如`AwaitExpression`）和源文档中的位置：
- en: '![Figure 4.2 – The AST Explorer shows the information as parsed by Babel ](img/Figure_4.02_B18989.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – AST Explorer显示了Babel解析的信息](img/Figure_4.02_B18989.jpg)'
- en: Figure 4.2 – The AST Explorer shows the information as parsed by Babel
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – AST Explorer显示了Babel解析的信息
- en: 'Equipped with this knowledge, we can now try to do something locally using
    `@babel/node`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们现在可以尝试使用`@babel/node`在本地做一些事情：
- en: 'We start by creating a new Node.js project. In a new directory, run the following:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的Node.js项目。在一个新目录中，运行以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will create a `package.json` and include some basic information. Afterwards,
    you can install the `@babel/node` and `@babel/core` packages as a development
    dependency:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个`package.json`文件并包含一些基本信息。之后，你可以将`@babel/node`和`@babel/core`包作为开发依赖项安装：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Feel free to use another package manager for this. Once the installation has
    finished, we should add the script. Create a new `index.js` file with the following
    content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用其他包管理器进行此操作。一旦安装完成，我们应该添加脚本。创建一个名为`index.js`的新文件，内容如下：
- en: index.js
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code uses an `ES2021` feature called conditional assignments. Only if `y`
    is truthy will the assignment be done. In this case, we expect `x` to be `2` after
    the conditional assignment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了一个名为条件赋值的`ES2021`特性。只有当`y`为真值时，才会执行赋值。在这种情况下，我们期望条件赋值后`x`的值为`2`。
- en: 'To run the code, we need to modify `package.json`. In the `scripts` section,
    we add a `start` field. Now, the `scripts` section should look like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行代码，我们需要修改`package.json`。在`scripts`部分，我们添加一个`start`字段。现在，`scripts`部分应该看起来像这样：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, we can conveniently run the script using `npm start`. For recent
    Node.js versions (*15* or later), the output should be as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以方便地使用 `npm start` 运行脚本。对于最近的 Node.js 版本（*15* 或更高版本），输出应该是这样的：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, if we try to run the code with Node.js *14*, we’ll get an error:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用 Node.js *14* 运行代码，我们会得到一个错误：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if you want this to run, you can switch the `start` script of `package.json`
    to use `babel-node` instead of the standard `node`. Trying this, however, will
    not work. The reason is that, by default, Babel does not understand the current
    environment and, therefore, cannot apply the transformations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想让它运行，你可以将 `package.json` 的 `start` 脚本切换为使用 `babel-node` 而不是标准的 `node`。然而，尝试这样做是不会工作的。原因是，默认情况下，Babel
    不理解当前环境，因此无法应用转换。
- en: 'For Babel to actually understand it, we need to use the `@babel/preset-env`
    package. This is a preset that represents a collection of plugins. In this case,
    the `env` preset is a special one that intelligently looks for the right plugins
    depending on the current environment. Let’s first install it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 Babel 真正理解它，我们需要使用 `@babel/preset-env` 包。这是一个代表插件集合的预设。在这种情况下，`env` 预设是一个特殊的预设，它根据当前环境智能地查找正确的插件。让我们首先安装它：
- en: '[PRE22]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Afterward, we can integrate it by creating a new file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以通过创建一个新文件来集成它：
- en: .babelrc
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: .babelrc
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The file has to be placed next to `package.json`. Once there, Babel will automatically
    load the file and take its content as configuration input. Now the output matches
    our expectations:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件必须放置在 `package.json` 旁边。一旦放置在那里，Babel 将自动加载该文件并将其内容作为配置输入。现在输出符合我们的预期：
- en: '[PRE24]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With these instructions, you are now able to run modern code, even on older
    versions of Node.js. The preceding example did finally run in Node.js *14* – even
    though this version does not support the `&&=` new assignment operator.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些说明，你现在可以运行现代代码，即使在较旧的 Node.js 版本上。前面的例子最终在 Node.js *14* 上运行了——即使这个版本不支持新的赋值运算符
    `&&=`。
- en: There are many different packages that work together with Babel. Full languages
    or language extensions have been written for Babel. One of those extensions is
    Flow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的包与 Babel 一起工作。为 Babel 编写了完整的语言或语言扩展。其中之一是 Flow。
- en: Using Flow
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flow
- en: Flow is mainly a **static type checker** for JavaScript code. The purpose of
    a static type checker is to ensure at build time that everything works together
    as it should. As a result, we should see a lot fewer errors at runtime. In fact,
    proper usage of a static type checker will essentially eliminate all simple bugs
    and let us focus on solving the algorithmic and behavioral issues that would arise
    anyway.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 主要是一个 JavaScript 代码的 **静态类型检查器**。静态类型检查器的目的是确保在构建时一切都能按预期工作。因此，我们应该在运行时看到更少的错误。实际上，正确使用静态类型检查器将基本上消除所有简单的错误，并让我们专注于解决那些无论如何都会出现的算法和行为问题。
- en: 'In Flow, every JavaScript file can be changed to a Flow file. All that needs
    to be done is to introduce the `@flow` comment. A simple example is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flow 中，每个 JavaScript 文件都可以转换为 Flow 文件。需要做的只是引入 `@flow` 注释。一个简单的例子如下：
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though the code would work pretty well in standard JavaScript, Flow will
    help us by raising an error in the last line. The `square` function has been annotated
    using types for the `n` input argument and the return value. The colon notation
    separates the identifier or function head from the specified type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码在标准 JavaScript 中运行得相当好，Flow 也会通过在最后一行引发错误来帮助我们。`square` 函数使用了类型注解来指定 `n`
    输入参数和返回值。冒号表示法将标识符或函数头与指定的类型分开。
- en: Since the colon notation is not part of the JavaScript standard, we cannot just
    run the preceding code. Instead, we can use Babel together with the `@babel/preset-flow`
    package to strip away the Flow type annotations – keeping only the JavaScript
    that Node.js can understand.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '由于冒号表示法不是 JavaScript 标准的一部分，我们无法直接运行前面的代码。相反，我们可以使用 Babel 与 `@babel/preset-flow`
    包一起使用，以去除 Flow 类型注释——只保留 Node.js 可以理解的 JavaScript。 '
- en: 'Let’s test this with a new project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个新项目来测试一下：
- en: 'We start in a new directory by initializing an `npm` project and installing
    the necessary development dependencies:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过初始化一个 `npm` 项目并安装必要的开发依赖来在新的目录中开始：
- en: '[PRE31]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we configure Babel and change the `package.json` file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们配置 Babel 并更改 `package.json` 文件：
- en: .babelrc
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: .babelrc
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `package.json`, we need to add a `start` field to the `scripts` section:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中，我们需要在 `scripts` 部分添加一个 `start` 字段：
- en: package.json
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, running `npm start` should work without any error message. However, if
    we run `node index.js`, then we’ll actually face an error. Still, shouldn’t we
    also face an error in this case?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`npm start`应该不会出现任何错误信息。然而，如果我们运行`node index.js`，那么我们实际上会面对一个错误。尽管如此，我们不应该在这种情况下也遇到错误吗？
- en: 'Well, as mentioned, the Babel part is only for running. The installed preset
    only understands and removes the type annotations. It does not do the actual type
    checking. For this, we need to install another package called `flow-bin`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，正如提到的，Babel部分只是为了运行。安装的预设只理解并移除类型注解。它并不进行实际的类型检查。为此，我们需要安装另一个名为`flow-bin`的包：
- en: '[PRE36]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can run `flow` with the `npx` runner that comes already with `npm`. First,
    we initialize the project:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`npm`中自带`npx`运行器来运行`flow`。首先，我们初始化项目：
- en: '[PRE37]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we can type-check our solution:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以对我们的解决方案进行类型检查：
- en: '[PRE38]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As expected, the call does not satisfy the type checks. This is great for our
    own code, but it is even better for using third-party libraries. With type checking,
    we can be sure that we use the provided APIs correctly. Not only now but also
    in the future when we install an update for third-party libraries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，调用不满足类型检查。这对我们自己的代码来说是个好消息，但对于使用第三方库来说更是如此。有了类型检查，我们可以确信我们正确地使用了提供的API。不仅现在如此，而且在我们为第三方库安装更新时也是如此。
- en: Unfortunately, not every package comes with `flow`-type annotations. However,
    the situation looks a bit more promising for a quite similar tool called TypeScript.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，并不是每个包都包含 `flow`-类型的注解。然而，对于一个非常类似的工具TypeScript来说，情况看起来要乐观一些。
- en: Using TypeScript
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript
- en: TypeScript is a full programming language that was designed as a superset of
    JavaScript. The basic idea was to start with JavaScript, enhance it with missing
    parts such as types, classes, or enums, and choose JavaScript as a transpilation
    target for the language. Over the years, many of the features that were first
    introduced in the TypeScript language also made it to the JavaScript language.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是一种完整的编程语言，它被设计为JavaScript的超集。基本想法是从JavaScript开始，通过添加类型、类或枚举等缺失的部分来增强它，并将JavaScript作为语言的转译目标。多年来，TypeScript语言中首次引入的许多功能也进入了JavaScript语言。
- en: Today, TypeScript is the most popular way to write large-scale JavaScript projects.
    Nearly every package on the official `npm` registry comes with TypeScript-compatible
    type annotations – either within the package or in a dedicated package. As an
    example, the type annotations for the `react` package can be found in the `@``types/react`
    package.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，TypeScript是编写大型JavaScript项目的最流行方式。在官方`npm`注册表中，几乎每个包都提供了与TypeScript兼容的类型注解——要么在包内部，要么在专门的包中。例如，`react`包的类型注解可以在`@types/react`包中找到。
- en: To use TypeScript, we need to install the `typescript` package. This contains
    the `tsc` script, which gives us the ability to check types and transpile TypeScript
    files written using the `.ts` or `.``tsx` extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用TypeScript，我们需要安装`typescript`包。这个包包含了`tsc`脚本，它赋予我们检查类型和将使用`.ts`或`.tsx`扩展名编写的TypeScript文件进行转译的能力。
- en: 'Let’s go ahead and create a new project, install `typescript`, and add a source
    file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的项目，安装`typescript`，并添加一个源文件：
- en: 'We start with the project creation. In a new directory, run the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从项目创建开始。在一个新目录中，运行以下命令：
- en: '[PRE56]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s add an `index.ts` file with content similar to the example for Flow:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个与Flow示例内容相似的`index.ts`文件：
- en: index.ts
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: index.ts
- en: '[PRE58]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The content of the file is pretty much the same as beforehand, however, the
    `@flow` comment is missing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容与之前几乎相同，然而，缺少了`@flow`注释。
- en: 'We can now run this directly via the `tsc` command, which has been installed
    together with the `typescript` package:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以直接通过安装的`typescript`包中的`tsc`命令来运行它：
- en: '[PRE59]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In comparison to the `flow` tool, `tsc` does a bit more. It does not only do
    the type checking but it will also produce output files. What it does not do is
    run the code. The immediate evaluation functionality of `@babel/node` can be found
    in the `ts-node` package, which works quite similarly to its Babel counterpart.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与`flow`工具相比，`tsc`做得多一些。它不仅进行类型检查，还会生成输出文件。它不做的就是运行代码。`@babel/node`的即时评估功能可以在`ts-node`包中找到，它的工作方式与Babel类似。
- en: 'By default, `tsc` tries to convert a `.ts` or `.tsx` input file to some new
    files: a `.js` and `.d.ts` file. Even in the case of failed type checks, these
    files might be produced. The `.js` file will be written by default, that is, with
    every use of `tsc`, unless we tell TypeScript to not emit the output. The `.d.ts`
    file will only be written if we also enable the creation of declarations. Looking
    at the directory after we’ve run the previous example will reveal two new files:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`tsc` 尝试将 `.ts` 或 `.tsx` 输入文件转换为一些新文件：一个 `.js` 文件和一个 `.d.ts` 文件。即使在类型检查失败的情况下，这些文件也可能被生成。`.js`
    文件将默认写入，也就是说，每次使用 `tsc` 时都会写入，除非我们告诉 TypeScript 不要输出。`.d.ts` 文件只有在我们也启用了声明创建时才会写入。在运行了之前的示例之后查看目录将揭示两个新文件：
- en: '[PRE65]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Having the additional JavaScript is needed to actually run the code. This also
    applies to TypeScript being written for the browser. Since no browser understands
    TypeScript code, we need to transpile it to JavaScript beforehand. Like Babel,
    we can actually transpile for different versions of the JavaScript standard.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际运行代码需要额外的 JavaScript。这同样适用于为浏览器编写的 TypeScript。由于没有浏览器能理解 TypeScript 代码，我们需要在之前将其转换为
    JavaScript。就像 Babel 一样，我们可以为不同的 JavaScript 标准版本进行转换。
- en: 'In order to keep your code repository clean, you should not use TypeScript
    as shown earlier. Instead, a much better way is to introduce a `tsconfig.json`
    file, which you should place adjacent to the `package.json`. This way, you can
    not only properly define the target JavaScript version but also a destination
    directory where the transpilation output should be placed. The destination directory
    can then be ignored in your version control system:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持你的代码库整洁，你不应该像之前展示的那样使用 TypeScript。相反，一个更好的方法是引入一个 `tsconfig.json` 文件，你应该将其放置在
    `package.json` 旁边。这样，你不仅可以正确地定义目标 JavaScript 版本，还可以指定转换输出应该放置的目标目录。然后，你可以在这个目标目录中忽略版本控制系统：
- en: tsconfig.json
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: tsconfig.json
- en: '[PRE71]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the configuration, we indicated an `src` directory as the root for the transpilation.
    Every `.ts` and `.tsx` file inside will be transpiled. The output will be available
    in the `dist` directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，我们指定了一个 `src` 目录作为转换的根目录。内部所有的 `.ts` 和 `.tsx` 文件都将被转换。输出将可在 `dist` 目录中找到。
- en: 'Now, you can just move `index.ts` inside a new `src` subfolder and try running
    `tsc` again. The same error pops up, but instead of creating the `index.js` adjacent
    to the `index.ts` file, the output would appear in the `dist` folder:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你只需将 `index.ts` 移动到一个新的 `src` 子文件夹中，然后再次运行 `tsc`。同样的错误会再次出现，但与在 `index.ts`
    文件旁边创建 `index.js` 不同，输出将出现在 `dist` 文件夹中：
- en: '[PRE72]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Today, most libraries that are published on the public `npm` registry will be
    created using TypeScript. This not only prevents some unnecessary bugs but also
    makes the experience for consumers of the library much better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数发布在公共 `npm` 注册库上的库都将使用 TypeScript 创建。这不仅防止了一些不必要的错误，而且也使库的消费者体验变得更好。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use different flavors of JavaScript with
    Node.js. You have seen how Babel can be installed, configured, and used to transpile
    your code to the JavaScript standard supported by the target version of Node.js.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Node.js 的不同 JavaScript 风格。你看到了如何安装、配置 Babel，以及如何使用它将你的代码转换为 Node.js
    目标版本支持的 JavaScript 标准。
- en: 'Right now, you should also know the basics of the most important JavaScript
    flavors: Flow and TypeScript. We discussed how they can be installed and configured.
    Of course, to practically use these flavors, you’ll need additional material to
    learn their syntax and master the concepts behind these languages. A good book
    to learn TypeScript is *Mastering TypeScript* by *Nathan Rozentals*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你也应该了解最重要的 JavaScript 风格的基础：Flow 和 TypeScript。我们讨论了它们的安装和配置方法。当然，为了实际使用这些风格，你需要额外的材料来学习它们的语法并掌握这些语言背后的概念。学习
    TypeScript 的好书是 *Mastering TypeScript*，作者为 *Nathan Rozentals*。
- en: In the next chapter, we will discuss a quite important area of tooling – applications
    that can give our code improved consistency and validation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个非常重要的工具领域——能够为我们代码提供改进的一致性和验证的应用程序。
