<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Security</h1></div></div></div><p>In this chapter we will authenticate users using a GitHub account and <a id="id139" class="indexterm"/>
<span class="strong"><strong>OAuth 2.0</strong></span> tokens. This will allow us to secure the site and support multiple users; currently we have a single hardcoded token and user. We will also add HTTPS to our site and explore some other modules that we can use to secure other common security vulnerabilities.</p><div class="section" title="Setting up Passport"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Setting up Passport</h1></div></div></div><p>Passport <a id="id140" class="indexterm"/>is an authentication middleware for node that supports; via plugin; multiple authentication strategies, including Basic Auth, OAuth, and OAuth 2. Passport works by defining a route middleware to be used to authenticate the request.</p><p>Let's install<a id="id141" class="indexterm"/> Passport:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install passport --save</strong></span>
</pre></div><p>Passport does not include a GitHub strategy; for this we need to install <code class="literal">passport-github</code>; a strategy for authenticating with GitHub using the OAuth 2.0 API:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install passport-github --save</strong></span>
</pre></div></div></div>
<div class="section" title="Acceptance testing with Cucumber and Zombie.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Acceptance testing with Cucumber and Zombie.js</h1></div></div></div><p>OAuth authentication uses a <a id="id142" class="indexterm"/>callback mechanism; this is messy to test with an integration-testing <a id="id143" class="indexterm"/>tool such as <a id="id144" class="indexterm"/>SuperTest; we<a id="id145" class="indexterm"/> require something a little more <a id="id146" class="indexterm"/>end-to-end.</p><p>Cucumber<a id="id147" class="indexterm"/> allows teams to describe software behavior in a simple plain text language called <span class="strong"><strong>Gherkin</strong></span>
<a id="id148" class="indexterm"/>. The process of describing this behavior aids development; the output serves as documentation that can be automated to run as a set of tests. Let's install cucumber:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g cucumber</strong></span>
</pre></div><p>Zombie.js<a id="id149" class="indexterm"/> is simple,<a id="id150" class="indexterm"/> lightweight framework for doing headless full-stack testing. Let's install <code class="literal">Zombie.js</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install zombie --save-dev</strong></span>
</pre></div><p>Let's automate <a id="id151" class="indexterm"/>running<a id="id152" class="indexterm"/> Cucumber with a grunt task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-cucumber --save-dev</strong></span>
</pre></div><p>Add the following to our gruntfile <code class="literal">./gruntfile.js</code>. The section <code class="literal">files</code> defines the location of our feature files, and <code class="literal">options:steps</code> defines the location of our step definitions:</p><div class="informalexample"><pre class="programlisting">    cucumberjs: {
      files: 'features',
      options: {
        steps: "features/step_definitions",format: "pretty"
      }
    },</pre></div></div>
<div class="section" title="Feature: Authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Feature: Authentication</h1></div></div></div><div class="informalexample"><pre class="programlisting">As a vision user
I want to be able to authenticate via Github
So that I can view project activity</pre></div><p>Let's create our first feature file <code class="literal">./features/authentication.feature</code>. The following feature file contains a <code class="literal">Feature</code> section, which for the agile among you will know that it defines the story and its value to the business, and a list of scenarios. Our acceptance criteria; written in the Gherkin language.</p><p>The following <code class="literal">Authenticate</code> feature<a id="id153" class="indexterm"/> contains two scenarios, including one to log in, titled <code class="literal">User logs in successfully</code>, and one to log out, titled <code class="literal">User logs out successfully</code>:</p><div class="informalexample"><pre class="programlisting">Feature: Authentication
As a vision user
I want to be able to authenticate via Github
So that I can view project activity 

  Scenario: User logs in successfully
    Given I have a GitHub Account
    When I click the GitHub authentication button
    Then I should be logged in
    And I should see my name and a logout link

  Scenario: User logs out successfully
    Given I am logged in to Vision
    When I click the logout button
    Then I should see the GitHub login button</pre></div><p>Let's run<a id="id154" class="indexterm"/> Cucumber using our grunt task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt cucumberjs</strong></span>
</pre></div><p>This will generate the following output:</p><div class="informalexample"><pre class="programlisting">2 scenarios (2 undefined)
7 steps (7 undefined)
You can implement step definitions for undefined steps with these snippets:
this.Given(/^I have a GitHub Account$/, function(callback) {
  callback.pending();
});

this.When(/^I click the GitHub authentication button$/, function(callback) {
  callback.pending();
});

this.Then(/^I should be logged in$/, function(callback) {
  callback.pending();
});

this.Then(/^I should see my name and a logout link$/, function(callback) {
  callback.pending();
});

this.Given(/^I am logged in to Vision$/, function(callback) {
  callback.pending();
});

this.When(/^I click the logout button$/, function(callback) {
  callback.pending();
});

this.Then(/^I should see the GitHub login button$/, function(callback) {
  callback.pending();
});</pre></div><p>From the preceding output, you can see that Cucumber has generated a series of stubbed steps that are set to <code class="literal">pending</code>. These steps represent the <code class="literal">Given</code>, <code class="literal">When</code>, and <code class="literal">Then</code> scenarios we defined in our feature file <code class="literal">./features/authentication/authentication.feature</code>.</p><p>We can use these steps to implement our Cucumber tests. Let's create a step definition file <code class="literal">./features/step_definitions/authentication/authenticate.js</code>:</p><div class="informalexample"><pre class="programlisting">var steps = function() {
  var Given = When = Then = this.defineStep;
  <span class="strong"><strong>..add generated steps here</strong></span>
};

module.exports = steps;</pre></div><p>Let's run <a id="id155" class="indexterm"/>Cucumber using our grunt task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt cucumberjs</strong></span>
</pre></div><p>We get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2 scenarios (2 pending)</strong></span>
<span class="strong"><strong>7 steps (2 pending, 5 skipped)</strong></span>
</pre></div><p>We are now ready to begin implementing our first scenario.</p><div class="section" title="Scenario: User logs in successfully"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Scenario: User logs in successfully</h2></div></div></div><p>Let's begin implementing <a id="id156" class="indexterm"/>this scenario. First, we need a GitHub <code class="literal">clientId</code> <a id="id157" class="indexterm"/>and <code class="literal">clientSecret</code>. Visit your GitHub account, click on <span class="strong"><strong>Settings</strong></span> and then <span class="strong"><strong>Applications</strong></span> and again on <span class="strong"><strong>Register New Application.</strong></span> Complete the form by adding the <code class="literal">homepage</code> URL and the <code class="literal">callback</code> URL (same as our homepage), and a <code class="literal">clientId</code> and a <code class="literal">clientSecret</code> will be generated.</p><p>Let's add these details to our config files <code class="literal">./config/*.json</code>:</p><div class="informalexample"><pre class="programlisting">"auth": {
    "homepage": "http://127.0.0.1:3000"
  , "callback": "http://127.0.0.1:3000/auth/github/callback"
  , "clientId": "5bb691b4ebb5417f4ab9"
  , "clientSecret": "15310740929666983d52808dda32417d733791d0"
}</pre></div><p>Let's remove the temporary login we set up in <a class="link" href="ch02.html" title="Chapter 2. Building a Web API">Chapter 2</a>, <span class="emphasis"><em>Building a Web API</em></span>, and remove the following line and all code related to it <code class="literal">./lib/routes/project.js</code>:</p><div class="informalexample"><pre class="programlisting">, login = require('../../test/login');</pre></div><p>We are now ready to implement our GitHub strategy <code class="literal">./lib/github/authentication.js</code>. We start by defining a function, <code class="literal">GitHubAuth</code>; we import the <code class="literal">passport</code> and <code class="literal">passport-github</code> modules. We instantiate a <code class="literal">GitHubStrategy</code>, add it<a id="id158" class="indexterm"/> to <code class="literal">passport</code>, and pass a <code class="literal">clientID</code>, <code class="literal">clientSecret</code>, a <code class="literal">callbackUrl</code>, and a <code class="literal">verify</code> function (all passport strategies require a verify function), that is called when GitHub authenticates passing back an <code class="literal">accessToken</code>, <code class="literal">refreshToken</code>, and a <code class="literal">profile</code>.</p><p>Inside this verify function, we have the option of rejecting the user by passing a false out of the <code class="literal">callback</code> function. We will accept anyone with a GitHub access token; so simply pass back a user profile; which we create using the profile GitHub passed to us. Within the verify function, we instantiate a <code class="literal">GitHubRepo</code> and call <code class="literal">updateTokens</code>, which updates their access tokens for use by our Redis cache population.</p><p>Our application will support user sessions, <a id="id159" class="indexterm"/>so we add two functions to the <code class="literal">passport</code> module, that include <code class="literal">serializeUser</code> and <code class="literal">deserializeUser</code>, which serialize and deserializes the GitHub user profile <a id="id160" class="indexterm"/>into and out of a user session:</p><div class="informalexample"><pre class="programlisting">var async = require('async')
, GitHubRepo = require('../github')
, config = require('../configuration');

function GitHubAuth() {
  this.passport = require('passport')
  var GitHubStrategy = require('passport-github').Strategy;

  this.passport.use(new GitHubStrategy({
      clientID     : config.get('auth:clientId'),
      clientSecret : config.get('auth:clientSecret'),
      callbackURL  : config.get('auth:callback')
  },
  function(accessToken, refreshToken, profile, done) {

    var user = {
      id : profile.username,
      displayName : profile.displayName,
      token : accessToken
    };

    var git = new GitHubRepo(user.token, user.id);

    git.updateTokens(function(){
      process.nextTick(function () {
        return done(null, user);
      });
    });
  };
  ));

  this.passport.serializeUser(function(user, done) {
    done(null, user);
  });

  this.passport.deserializeUser(function(user, done) {
    done(null, user);
  });
};

module.exports = new GitHubAuth();</pre></div><p>Let's add an <code class="literal">updateTokens</code> <a id="id161" class="indexterm"/>function to <code class="literal">GitHubRepo</code>, which gets all of a<a id="id162" class="indexterm"/> users' projects and <code class="literal">async.each</code> through <code class="literal">each</code> one updating its token:</p><div class="informalexample"><pre class="programlisting">GitHubRepo.prototype.updateTokens = function(done) {
  var query = { "user" :  this.user };

  Project.find(query, function(error, projects) {
    if (error) return done();
    if (projects == null) done();

    async.each(projects, function(project, callback) {
      project.token = this.token;

      project.save(function(error, p) {
        callback();
      });
    }
    , function(error) {
      done();
    });
  });
};</pre></div><p>Let's add configuration to our config files <code class="literal">./config/*.json</code>, in order to support Express sessions:</p><div class="informalexample"><pre class="programlisting">  "session": {
    "secret": "th1$1$a$ecret"
    , "maxAge": null
    , "secure": true
    , "httpOnly": true
  }</pre></div><p>Let's wire up our GitHub strategy to our Express server: <code class="literal">./lib/express/index.js</code>. The first change we make it to include our new GitHub <code class="literal">authentication</code> strategy:</p><div class="informalexample"><pre class="programlisting">var gitHubAuth = require('../github/authentication')</pre></div><p>We create a <code class="literal">cookieParser</code> middleware and include it just before the <code class="literal">bodyParser</code> middleware, which will parse the cookie header field and populate <code class="literal">req.cookies</code>. We pass a <code class="literal">secret</code>; which is a string used to create a signed cookie enabling the detection of a modified cookie:</p><div class="informalexample"><pre class="programlisting">
  var cookieParser = express.
    cookieParser(config.get('session:secret'));
  app.use(cookieParser);</pre></div><p>The <a id="id163" class="indexterm"/>application will require persistent login sessions, so we will include <a id="id164" class="indexterm"/>the connect <code class="literal">session</code> middleware in our Express server in order to provide session support. We will use the <code class="literal">sessionStore</code>, which is an in-memory session store. We pass in a <code class="literal">secret</code> and a value for a cookie <code class="literal">maxAge</code> (a null value will expire the session on closing the browser), <code class="literal">httpOnly</code> (disallow client-side JavaScript access to cookies; XSS attacks), and <code class="literal">secure</code> (send cookies over HTTPS only):</p><div class="informalexample"><pre class="programlisting">app.use(express.bodyParser());
var sessionStore = new express.session.MemoryStore();
app.use(express.session({ store: sessionStore,
  secret: config.get('session:secret'),
  cookie: { secure: config.get('session:secure'),
  httpOnly: config.get('session:httpOnly'),
  maxAge: config.get('session:maxAge') }}));</pre></div><p>The Passport module requires we call <code class="literal">passport.initialize()</code> in order to initialize <code class="literal">passport</code>, and in order to provide session support, we must also call the <code class="literal">passport.session()</code> middleware; we add both to our Express server:</p><div class="informalexample"><pre class="programlisting">app.use(gitHubAuth.passport.initialize());
app.use(gitHubAuth.passport.session());</pre></div><p>We now define the first of two routes on our Express server; both use the passport strategy for GitHub. The first route is a login route <code class="literal">/auth/github</code>; hitting this route will redirect you to GitHub and try to authenticate. If you are not logged in to GitHub, you will be asked to log in. If you are doing this for the first time, you will be prompted. You will be asked if you would like to grant Vision access. The second route; is the route GitHub will callback when authentication is complete:</p><div class="informalexample"><pre class="programlisting">app.get('/auth/github',gitHubAuth.passport.authenticate('github'),routes.auth.login);

app.get('/auth/github/callback',gitHubAuth.passport.authenticate('github',{ failureRedirect: '/' }), routes.auth.callback);</pre></div><p>We have configured our Express server with a GitHub passport strategy. Let's add the two missing routes to our routes, <code class="literal">./lib/routes/auth.js</code>; one for login and one for the callback as described previously:</p><div class="informalexample"><pre class="programlisting">exports.callback = function(req, res) {
  logger.info('Request.' + req.url);
  res.redirect('/');
};

exports.login = function(req, res){
  logger.info('Request.' + req.url);
};</pre></div><p>In order to <a id="id165" class="indexterm"/>simulate the body of our project form containing a <code class="literal">user</code> <a id="id166" class="indexterm"/>and <code class="literal">token</code>, we will add a middleware that simply adds this data to the form for an authenticated user. We can add the <code class="literal">projectForm.addToken</code> middleware to all of our routes easily by using <code class="literal">app.all</code>, which will apply this middleware to all routes that follow it.</p><p>Let's make a further change to our Express server: <code class="literal">./lib/express/index.js</code>, and clean up our middleware by removing all require statements involving it and using <code class="literal">require-directory</code> with an <code class="literal">./lib/middleware/index.js</code> file, as we did with our routes. We can now add this <code class="literal">projectForm</code> above all the routes that require authentication:</p><div class="informalexample"><pre class="programlisting">   , middleware = require('../middleware')

app.all('*', middleware.projectForm.addToken);
.. all routes below</pre></div><p>Let's create the <code class="literal">projectForm.addToken</code> middleware in <code class="literal">./lib/middleware/projectForm.js</code>. The <code class="literal">AddToken</code> middleware checks if the request is authenticated via <code class="literal">req.isAuthenticated</code>; we add <code class="literal">user</code> and <code class="literal">token</code> to the request:</p><div class="informalexample"><pre class="programlisting">exports.addToken = function(req, res, next){
  if (req.isAuthenticated()) {
    req.body.user = req.session.passport.user.id;
    req.body.token = req.session.passport.user.token;
    req.user = req.session.passport.user;
  };

  next();
}</pre></div><p>Now that we have authentication in place, let's remove the hardcoded user in <code class="literal">./lib/routes/home.js</code>:</p><div class="informalexample"><pre class="programlisting">exports.index = function(req, res){
  var model = {
    title: 'vision.',
    description: 'a project based dashboard for github',
    author: 'airasoul',
<span class="strong"><strong>    user: req.isAuthenticated() ? req.user.displayName : ''</strong></span>
  };

  res.render('index', model);
};</pre></div><p>Now when we click on the GitHub logo in our header, we are redirected to GitHub which will ask you to log in. Once you have logged in to GitHub, you must grant access to our Vision application; however, future attempts to log in will not require you to grant access to Vision.</p><p>Let's complete<a id="id167" class="indexterm"/> our Cucumber steps for login using Zombie.js. <code class="literal">./features/step_definitions/authentication/authenticate.js</code>. First, we include zombie and and define <a id="id168" class="indexterm"/>a <code class="literal">steps</code> function. Then, we set <code class="literal">silent</code> and <code class="literal">debug</code> to enable Zombie.js debugging output. We define <code class="literal">Given = When = Then</code> as Cucumber steps and add a <code class="literal">Before</code> step, which runs before each test. From here we instantiate a zombie<code class="literal"> Browser</code>:</p><div class="informalexample"><pre class="programlisting">var Browser = require('zombie')
, assert = require('assert')
S = require('string')
config = require('../../../lib/configuration');

var steps = function() {
  var silent = false;
  var debug = false;
  var Given = When = Then = this.defineStep;
  var browser = null;
  var me = this;

   this.Before(function(callback) {
     browser = new Browser();
     browser.setMaxListeners(20);
     setTimeout(callback(), 5000);
   });
};

module.exports = steps;</pre></div><p>The step <code class="literal">I have a GitHub Account</code> uses the zombie browser to visit the GitHub login page, and waits for the page to<a id="id169" class="indexterm"/> load and fill in the login details; we then click on the sign in button:</p><div class="informalexample"><pre class="programlisting">this.Given(/^I have a GitHub Account$/, function(callback) {browser.visit('https://github.com/login',{silent: silent, debug: debug});
    
    browser.wait(function(){
      browser
        .fill('login', '#LOGIN#')
        .fill('password', '#PASSWORD#')
        .pressButton('Sign in', function() {
          callback();
    });
  });
});</pre></div><p>The step <code class="literal">I click the GitHub authentication button</code> uses the zombie browser to visit the <a id="id170" class="indexterm"/>GitHub login page and waits for the page to load and fill in the login details; we then click on the sign in button:</p><div class="informalexample"><pre class="programlisting">this.When(/^I click the GitHub authentication button$/, function(callback) {
    browser.visit(config.get('auth:homepage'),
    {silent: silent, debug: debug});
    
    browser.wait(function(){
      browser
        .clickLink('#login', function() {
          callback();
        });
      });
});</pre></div><p>The step <code class="literal">I should be logged in</code> uses the zombie browser to visit the GitHub login page and waits for the page to load and fill in the login details; we then click on the sign in button:</p><div class="informalexample"><pre class="programlisting">this.Then(/^I should be logged in$/, function(callback) {
  assert.ok(browser.success);
  callback();
});</pre></div><p>The step <code class="literal">I should see my name and a logout link</code> uses the zombie browser to visit the GitHub login page and waits for the page to load and fill in the login details; we then click on the sign in button:</p><div class="informalexample"><pre class="programlisting">this.Then(/^I should see my name and a logout link$/, function(callback) {
  assert.equal(browser.text('#welcome'),'welcome Andrew Keig, click here to sign out');
      callback();
});</pre></div></div><div class="section" title="Scenario: User logs out successfully"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>Scenario: User logs out successfully</h2></div></div></div><div class="informalexample"><pre class="programlisting">  Given I am logged in to Vision
  When I click the logout button
  Then I should see the GitHub login button</pre></div><p>Let's add a<a id="id171" class="indexterm"/> logout route<a id="id172" class="indexterm"/> to our Express server: <code class="literal">./lib/express/index.js</code>:</p><div class="informalexample"><pre class="programlisting">app.get('/logout', routes.auth.logout);</pre></div><p>Now add the route to our routes: <code class="literal">./lib/routes/auth.js</code>:</p><div class="informalexample"><pre class="programlisting">exports.logout = function(req, res){
  logger.info('Request.' + req.url);
  req.logout();
  res.redirect('/');
};</pre></div><p>Let's complete our Cucumber steps for logout using Zombie.js in <code class="literal">./features/step_definitions/authentication/authenticate.js</code>
</p><p>The step <code class="literal">I am logged in to Vision</code> uses the zombie browser to visit the Vision home page, waits for the page to load, and clicks on the login link:</p><div class="informalexample"><pre class="programlisting">this.Given(/^I am logged in to Vision$/, function(callback) {
  browser.visit(config.get('auth:homepage'),{silent: silent, debug: debug});
  
  browser.wait(function(){
    browser
    .clickLink('#login', function() {
      callback();
    });
  });
});</pre></div><p>The step <code class="literal">I click the logout button</code> uses the zombie browser to visit the Vision home page, waits for the page to load, and clicks on the logout link:</p><div class="informalexample"><pre class="programlisting">this.When(/^I click the logout button$/, function(callback) {
  browser.visit(config.get('auth:homepage'),{silent: silent, debug: debug});
  
  browser.wait(function(){
    browser
    .clickLink('#logout', function(err) {
      callback();
    });
  });
});</pre></div><p>The <a id="id173" class="indexterm"/>step <code class="literal">I should see the GitHub login button</code> checks to see if the browser response returns<a id="id174" class="indexterm"/> a <code class="literal">success</code>, and then checks to see if the GitHub login link is accessible:</p><div class="informalexample"><pre class="programlisting">this.Then(/^I should see the GitHub login button$/, function(callback) {
  assert.ok(browser.success);
  var containsLogin = S(browser.html('#login')).contains('vision/github.png')
    assert.equal(true, containsLogin);
    callback();
  });</pre></div></div></div>
<div class="section" title="Securing our site with HTTPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Securing our site with HTTPS</h1></div></div></div><p>In order to make our site <a id="id175" class="indexterm"/>secure, we will run the entire application under HTTPS. We <a id="id176" class="indexterm"/>will need two files: a PEM encoded SSL certificate <code class="literal">./lib/secure/cert.pem</code>, and a private key <code class="literal">./lib/secure/key.pem</code>. In order to create an SSL certificate, we first need to generate a private key and a certificate signing request (CSR). For development purposes, we will create a self-signed certificate. Run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd ../vision/lib/secure</strong></span>
<span class="strong"><strong>openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</strong></span>
</pre></div><p>Upon running the second command, you will enter an interactive prompt to generate a 2048-bit RSA private key and a certificate signing request (CSR). You will need to enter various pieces of information including address details, common name or domain name, company details, and an email address.</p><p>Let's add a module, <code class="literal">./lib/express/server.js</code>, that will create a HTTP server based on the <code class="literal">key</code>/<code class="literal">cert</code> we have just created. We import the <code class="literal">https</code> module, read the <code class="literal">key</code> and <code class="literal">cert</code> files from disk, and add them to a options object. Then using the <code class="literal">https</code> module, we create a server passing in these options:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs')
, https = require('https');

function Server(app){
  var httpsOptions = {
    key: fs.readFileSync('./lib/secure/key.pem'),cert: fs.readFileSync('./lib/secure/cert.pem')
  };

  return https.createServer(httpsOptions,app).listen(app.get('port'));
}

module.exports = Server;</pre></div><p>Let's use the <a id="id177" class="indexterm"/>
<code class="literal">server</code>
<a id="id178" class="indexterm"/> from within our Express server <code class="literal">./lib/express/index.js</code>; remove the line that creates our HTTP server:</p><div class="informalexample"><pre class="programlisting">var httpServer = http.createServer(app).listen(app.get('port'));</pre></div><p>Replace it with a call to our new HTTPS server:</p><div class="informalexample"><pre class="programlisting">var server = require('./server')(app);</pre></div><p>Now we need to replace all references to <code class="literal">http://127.0.0.1:3000</code>; port 3000 with <code class="literal">https://127.0.0.1:8443</code>; port 8443. Our config file contains two references:</p><div class="informalexample"><pre class="programlisting">"auth": {
    "homepage": "https://127.0.0.1:8443"
  , "callback": "https://127.0.0.1:8443/auth/github/callback"
  , "clientId": "5bb691b4ebb5417f4ab9"
  , "clientSecret": "15310740929666983d52808dda32417d733791d0"
  },</pre></div><p>We have a further reference in our <code class="literal">backbone.js</code> script <code class="literal">./public/components/vision.js</code>. When connecting to our Socket.IO server, we pass a URL <code class="literal">127.0.0.1:3000</code>. We make another important change here; we pass an options object when connecting to Socket.IO with the setting <code class="literal">secure: true, port: '8443'</code>:</p><div class="informalexample"><pre class="programlisting">Vision.Application = function(){        
  this.start = function(){
<span class="strong"><strong>    var socketio = io.connect('/', {secure: true, port: '8443'});</strong></span>
    var router = new Vision.Router(socketio);
    Backbone.history.start();
    router.navigate('index', true);
  }
};</pre></div></div>
<div class="section" title="Sharing Express sessions with Socket.IO"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Sharing Express sessions with Socket.IO</h1></div></div></div><p>Now that we have <a id="id179" class="indexterm"/>session support in place, we can share<a id="id180" class="indexterm"/> the session with Socket.IO allowing us to accept or reject the connection based on this session data. Express and Socket.IO do this using a handshake mechanism. When a client connects to the server, the handshake is initiated, which consists of executing an authorization function on Socket.IO. Here, the cookie associated with the handshake request is examined and rejected if invalid. Let's install <code class="literal">session.socket.io</code>; a module that has wrapped up this process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install session.socket.io --save</strong></span>
</pre></div><p>First off, let's change our Express server, <code class="literal">./lib/express/index.js</code>, and pass to our <code class="literal">SocketHandler</code> module the <code class="literal">sessionStore</code> and the <code class="literal">cookieParser</code>:</p><div class="informalexample"><pre class="programlisting">var socketHandler = new SocketHandler(httpServer, sessionStore, cookieParser);</pre></div><p>The <code class="literal">SocketHandler</code> module now accepts the parameters <code class="literal">httpServer</code>, <code class="literal">sessionStore</code>, and <code class="literal">cookieParser</code>. The <code class="literal">SocketHandler</code> will now instantiate a <code class="literal">SessionSockets</code> module passing <code class="literal">socketIo</code>, the <code class="literal">sessionStore</code> module, and the <code class="literal">cookieParser</code>. We change the <code class="literal">connection</code> event to listen on the <code class="literal">SessionSockets</code> module instead of the <code class="literal">socket.Io</code> module so that we can access the <code class="literal">session</code>. Now from within the <code class="literal">subscribe</code> event, we can check to ensure the <code class="literal">session.passport.user</code> is valid. We call <code class="literal">session.touch</code> which updates the <code class="literal">maxAge</code> and <code class="literal">lastAccess</code> properties of a session:</p><div class="informalexample"><pre class="programlisting">function SocketHandler(httpServer, sessionStore, cookieParser) {
  var socketIo = new Socket(httpServer)
  var sessionSockets = new SessionSockets(socketIo, sessionStore, cookieParser);

  sessionSockets.on('connection', function(err, socket, session) {
    subscriber.subscribe("issues");
    subscriber.subscribe("commits");

    subscriber.client.on("message", function (channel, message) {
      socket.broadcast.to(message.projectId)
      .emit(channel, JSON.parse(message));
    });

    socket.on('subscribe', function (data) {
      var user = session ? session.passport.user : null;
      if (!user) return;
      socket.join(data.channel);
      session.touch();
    });
  });

  sessionSockets.on('error', function() {
    logger.error(arguments);
  });
};

module.exports = SocketHandler;</pre></div></div>
<div class="section" title="Cross-site request forgery"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Cross-site request forgery</h1></div></div></div><p>
<span class="strong"><strong>Cross-site request forgery</strong></span> (<span class="strong"><strong>CRSF</strong></span>)<a id="id181" class="indexterm"/> is an attack that tricks the victim  into executing malicious actions on a web application in which they are authenticated. Connect/Express comes packaged with a Cross-site request forgery protection middleware. This middleware allows us to ensure that a request to a mutate state is from a valid source. The CRSF middleware creates a token that is stored in the requests session as <code class="literal">_csrf</code>. A request to our Express server will then need to pass the token in the header field <code class="literal">X-CSRF-Token</code>.</p><p>Let's create a security <code class="literal">./lib/security/index.js</code> module that adds the <code class="literal">csrf</code> middleware to our application. We define a function, <code class="literal">Security</code>, that takes an Express <code class="literal">app</code> as an argument and removes the middleware when in <code class="literal">TEST</code> or <code class="literal">COVERAGE</code> mode.</p><div class="informalexample"><pre class="programlisting">var express = require('express');

function Security(app) {
  if (process.env['NODE_ENV'] === "TEST"  ||process.env['NODE_ENV'] === "COVERAGE") return;

  app.use(express.csrf());
};

module.exports = Security;</pre></div><p>Let's make a change to our Express server <code class="literal">./lib/express/index.js</code>. The <code class="literal">crsf</code> middleware requires session support, so we add the following line below the <code class="literal">session</code> and <code class="literal">passport</code> middleware:</p><div class="informalexample"><pre class="programlisting">require('../security')(app);</pre></div><p>As we are using <code class="literal">backbone.js</code> that uses jQuery under the hood to make AJAX requests, we will need to make a change to our backbone code <code class="literal">./public/components/vision/vision.js</code>. We will now override the <code class="literal">Backbone.sync</code> function, so that all requests through it pass the <code class="literal">X-CSRF-Token</code> in the header. The <code class="literal">X-CSRF-Token</code> is pulled from a <code class="literal">meta</code> tag in the master page:</p><div class="informalexample"><pre class="programlisting">Backbone.sync = (function(original) {
  return function(method, model, options) {
    options.beforeSend = function(xhr) {
      var token = $("meta[name='csrf-token']").attr('content');
      xhr.setRequestHeader('X-CSRF-Token', token);
    };
    original(method, model, options);
  };
})(Backbone.sync);</pre></div><p>We now need to<a id="id182" class="indexterm"/> pass the <code class="literal">X-CSRF-Token</code> to our master page via the master page route. The token is stored in the requests session as <code class="literal">_csrf</code>, in the following code we add the token to <code class="literal">csrftoken</code> in our view object:</p><div class="informalexample"><pre class="programlisting">exports.index = function(req, res){
  var model = {
    title: 'vision.',
    description: 'a project based dashboard for github',
    author: 'airasoul',
    user: req.isAuthenticated() ? req.user.displayName : '',
<span class="strong"><strong>    csrftoken: req.session._csrf</strong></span>
  };

  res.render('index', model);
};</pre></div><p>The <code class="literal">csrftoken</code> is rendered in our master page in a <code class="literal">meta</code> tag called <code class="literal">csrf-token</code>; the backbone sync method will put it from this meta tag:</p><div class="informalexample"><pre class="programlisting">&lt;meta name="csrf-token" content="{{csrftoken}}"&gt;</pre></div></div>
<div class="section" title="Improving security with HTTP headers and helmet"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Improving security with HTTP headers and helmet</h1></div></div></div><p>Helmet<a id="id183" class="indexterm"/> is a collection of middleware that implements various security headers for Express; for more information on helmet visit <a class="ulink" href="https://npmjs.org/package/helmet">https://npmjs.org/package/helmet</a>.</p><p>Helmet supports the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">csp (Content Security Policy)</li><li class="listitem" style="list-style-type: disc">HSTS (HTTP Strict Transport Security)</li><li class="listitem" style="list-style-type: disc">xframe (X-FRAME-OPTIONS)</li><li class="listitem" style="list-style-type: disc">iexss (X-XSS-PROTECTION for IE8+)</li><li class="listitem" style="list-style-type: disc">contentTypeOptions (X-Content-Type-Options nosniff)</li><li class="listitem" style="list-style-type: disc">cacheControl (Cache-Control no-store, no-cache)</li></ul></div><p>Let's extend <a id="id184" class="indexterm"/>our <a id="id185" class="indexterm"/>security <code class="literal">./lib/security/index.js</code> module, and<a id="id186" class="indexterm"/> add <a id="id187" class="indexterm"/>helmet security for the previous issues:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
<span class="strong"><strong>, helmet = require('helmet');</strong></span>

function Security(app) {
  if (process.env['NODE_ENV'] === "TEST"  ||
    process.env['NODE_ENV'] === "COVERAGE") return;

<span class="strong"><strong>  app.use(helmet.xframe());</strong></span>
<span class="strong"><strong>  app.use(helmet.hsts());</strong></span>
<span class="strong"><strong>  app.use(helmet.iexss());</strong></span>
<span class="strong"><strong>  app.use(helmet.contentTypeOptions());</strong></span>
<span class="strong"><strong>  app.use(helmet.cacheControl());</strong></span>
  app.use(express.csrf());
};

module.exports = Security;</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Summary</h1></div></div></div><p>By default, Express uses in-memory sessions. In the next chapter we will move our sessions to Redis. We will also configure Socket.IO to use Redis and explore some other interesting ways of scaling Express.</p></div></body></html>