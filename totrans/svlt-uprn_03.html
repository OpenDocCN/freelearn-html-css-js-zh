<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Compatibility with Existing Standards</h1>
<p>Some frameworks attempt to simplify your work as a developer by providing you with tools and functionality to wrap around common tasks, such as making network requests or managing data submitted by forms. While the intentions are noble, this strategy can have unintended consequences. For instance, when learning a new framework, developers have to master all of its intricacies to be effective. Reading about <em class="italic">yet another way to make network requests</em> can slow developers down, as time spent reading documentation is time spent <em class="italic">not building</em>. It can also prevent code portability. When the code written for application <em class="italic">A</em> is specific to framework <em class="italic">X</em>, then the code will need to be modified before being reused in application <em class="italic">B</em>, which was built with framework <em class="italic">Y</em>.</p>
<p>SvelteKit has a solution to this, and that solution is to do nothing. Well, not <em class="italic">nothing</em>, but rather than providing you with wrappers and functions that will require you to look up the documentation each time you go to use one, SvelteKit encourages the use of existing Web <strong class="bold">Application Programming Interfaces</strong> (<strong class="bold">APIs</strong>) and standards. By not reinventing the wheel, more developers can get started with SvelteKit quickly, since they won’t have to learn abstractions for standards that they’re already familiar with. Not only does it keep time spent reading documentation to a minimum, but it also requires less code to power a framework.</p>
<p>This chapter will cover some basic use cases of <strong class="bold">Web APIs</strong> and how they interact with SvelteKit. Specifically, we’ll look at these examples of current web standards:</p>
<ul>
<li>Fetch</li>
<li>FormData</li>
<li>URL</li>
</ul>
<p>An in-depth dive into each of these standards is beyond the scope of this chapter, but if you’re looking for more information about them, resources will be provided at the end. After these examples, you should feel comfortable using your existing knowledge of various web standards with SvelteKit.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03</a>.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Fetch</h1>
<p>To begin, let’s <a id="_idIndexMarker043"/>take a look at one of the most commonly used Web APIs, <code>fetch</code>. Assuming <a id="_idIndexMarker044"/>your development environment is on the latest LTS version of Node.js (v18+), you’ll have access to <code>fetch</code> on the server without having to install an extra package such as <code>node-fetch</code>. That package was the most widely used package to deliver functionality, allowing developers to make network requests before <code>fetch</code> was incorporated into Node.js's core features. Since <code>fetch</code> is now also supported in every major browser, we can safely use it in both client- and server-side environments to make external and internal requests. Because SvelteKit can run in both a browser and server environment, it is safe to say that we have, in fact, “made fetch happen.”</p>
<p>To illustrate how fetch can work in both the browser and server, let’s take a look at an example. We’ll create a new route by adding the <code>src/routes/fetch/+page.svelte</code> file to serve as our demo page. We’ll also create <code>src/routes/fetch/+page.js</code> to get data from an actual <code>fetch</code> request. In this example, we’ll utilize NASA’s free <em class="italic">Astronomy Picture of the Day</em> API found at <a href="https://api.nasa.gov/">https://api.nasa.gov/</a>. It’s recommended to obtain an API key for regular use; however, the demonstration API key provided in the following examples will suffice for our purposes. This example makes a network request to the NASA API and shows the data received on our page.</p>
<p>Please note that the styles are by no means required and are only provided to make our example more digestible when viewed in the browser. We could add lots of styles and make this look fantastic, but that would take up more of our limited space on these pages. Plus, you’re here to learn about SvelteKit, not CSS:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/fetch/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;h1&gt;Astronomy Picture of the Day&lt;/h1&gt;
&lt;h2&gt;{data.pic.title}&lt;/h2&gt;
&lt;div class='wrap'&gt;
  &lt;a href={data.pic.hdurl}&gt;&lt;img src={data.pic.url}&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;{data.pic.explanation}&lt;/p&gt;
&lt;style&gt;
  h1, h2 {
    text-align: center;
  }
  .wrap {
    max-width: 75%;
    margin: 0 auto;
    text-align: center;
  }
  img {
    max-width: 100%;
  }
&lt;/style&gt;</pre>
<p>In this file, we’re <a id="_idIndexMarker045"/>simply setting up the markup for our data to populate. To get access<a id="_idIndexMarker046"/> to the data provided by the sibling <code>+page.js</code> file, we <em class="italic">must</em> include <code>export let data;</code>. If you're familiar with React or Vue, think of this as SvelteKit's method for passing props between components. If you're familiar with React of Vue, think of this as SvelteKit's method for passing props between components. After doing that, we can use the data provided in the object to populate the image title, a link to the high-resolution file, a link to the externally hosted image, and show an image description. And, of course, we’ve added some minimal styles. The real magic, and our <code>fetch</code> request, happens in the next snippet for <code>+page.js</code>, where we make the call to the external API:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/fetch/+page.js</p>
<pre class="source-code">
const key = 'DEMO_KEY'; // your API key here
export function load() {
  const pic = fetch(`https://api.nasa.gov/planetary/apod?api_key=${key}`)
  .then(response =&gt; {
    console.log('got response');
    return response.json();
  });
  return {pic};
}</pre>
<p>In <code>+page.js</code>, we’ve <a id="_idIndexMarker047"/>created <a id="_idIndexMarker048"/>a constant where you can place your own API key. Then, we exported the <code>load</code> function, which is necessary to tell SvelteKit to run before rendering the sibling <code>+page.svelte</code> file. It can be <code>async</code> or not; SvelteKit doesn’t care and will handle each case accordingly. We then create the constant <code>pic</code>, to which we can assign the promise returned from the <code>fetch</code> call. In the <code>fetch</code> call, we provided the URL with an API key appended to it, as the first and only argument. If your API needed to have options specified in the header, a method set, or perhaps an authentication cookie, you could do so by providing that as an object in the second argument. Remember that SvelteKit aims to be compatible with the existing web standards, so the implementations will have at least the standardized functionality. See the resources at the end of this chapter for more information on how to utilize <code>fetch</code> in these ways.</p>
<p>Continuing with the promise received by the <code>fetch</code> call, we run <code>console.log()</code> to demonstrate that code is being run in both the browser and server environments. If your development environment isn’t yet running, you can start it with the <code>npm run dev</code> command. Remember that it will then be available in your browser at the provided URL. You can confirm this by checking your browser console output in your developer tools, as well as the output from your Vite development server in your terminal. In both cases, you should see the “<em class="italic">got response</em>” output displayed. Because our request didn’t require any authentication, it was safe for us to run on the client side.</p>
<p>Finally, we<a id="_idIndexMarker049"/> convert the <code>load</code> functions, they run on both the server and browser. In the case of universal load functions, they <em class="italic">must</em> return an object.</p>
<p class="callout-heading">Loading Data</p>
<p class="callout">We’ve established that code run from <code>+page.js</code> is actually run in both the browser and server. If we wanted the code to only be run on the client, we would place that in <code>+page.svelte</code>. Similarly, if we wanted this code to be run only on the server, then we could change the filename to <code>+page.server.js</code>. This second use case would be more suitable for making an authenticated database call or accessing environment variables, such as API keys (as we did in this previous example). SvelteKit will recognize that this file is intended to run only in the server environment and will take the appropriate steps to separate that logic. Server <code>load</code> functions also work slightly differently from universal <code>load</code> functions, but we’ll go into that in more depth in a later chapter.</p>
<p>After doing all of this, we can now navigate to <code>/fetch</code> in our browser and see the image, its title, and a description, and even click on the image to view the full high-resolution file. It’s very helpful to make calls to various internal or external APIs, but our application will likely need to receive data from users at some point. In the next section, we’ll cover how we can access and manipulate <code>FormData</code> objects provided in <code>Requests</code>.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>FormData</h1>
<p>When<a id="_idIndexMarker051"/> building web applications, it’s common to accept data from users through the use of forms. Accessing this data can be done via the <code>+page.svelte</code> and <code>+page.server.js</code>, under the new <em class="italic">comment</em> route. As before, the <code>+page.svelte</code> file contains HTML to scaffold our form and minimal styles. In order to get access to the data sent from our server, we must include the line reading <code>export let form;</code> in our client-side <code>&lt;script&gt;</code> code. This lets us view the status of the object returned from <code>+page.server.js</code> and report the status back to the user by using<a id="_idIndexMarker053"/> the templating <a id="_idIndexMarker054"/>system provided by Svelte:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/comment/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let form;
&lt;/script&gt;
&lt;div class='wrap'&gt;
  {#if form &amp;&amp; form.status === true}
    &lt;p&gt;{form.msg}&lt;/p&gt;
  {/if}
  &lt;form method='POST'&gt;
    &lt;label&gt;
      Comment
      &lt;input name="comment" type="text"&gt;
    &lt;/label&gt;
    &lt;button&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;style&gt;
  .wrap {
    width: 50%;
    margin: 0 auto;
    text-align: center;
  }
  p {
    color: green;
  }
  label {
    display: block;
    margin: 1rem;
  }
&lt;/style&gt;</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"> src/routes/comment/+page.server.js</p>
<pre class="source-code">
export const actions = {
  default: async (event) =&gt; {
    const form = await event.request.formData();
    const comment = form.get('comment');
    if(comment) {
      // save comment to database
      return {
        status: true,
        msg: `Your comment has been received!`
      }
    }
  }
}</pre>
<p>As<a id="_idIndexMarker055"/> noted <a id="_idIndexMarker056"/>earlier, <code>+page.server.js</code> works in the same way as a <code>+page.js</code> file, except that it will only run on the server. Just as we can export <code>load()</code>, like in our <code>fetch</code> example, server-side files can also export <code>actions</code>. These exported <code>actions</code> can only be accessed via <code>POST</code> requests. We’ll look at how we can further utilize <code>actions</code> in a later chapter, but for now, note that we’re creating a single action, <code>default</code>. This means that when a form is submitted, the <code>POST</code> request is handled by the <code>/</code><code>comment</code> endpoint.</p>
<p>From the <code>default</code> action, this <a id="_idIndexMarker057"/>example accesses the <code>Request</code> object located in <code>event</code>, and then accesses <code>FormData</code> within that <code>Request</code>. Once the <code>FormData</code> object has been assigned to the <code>form</code> variable, we use <code>get()</code> to retrieve<a id="_idIndexMarker058"/> the value from the form input by its name. Normally, we would then move on to something akin to a database call that would save the comment alongside a unique user identifier. For the sake of brevity, we will just return an object with the <code>status</code> and <code>msg</code> properties.</p>
<p>When the page reloads, those properties are then checked by the Svelte template syntax and show the user a message that their comment has been successfully submitted. Even though this example only accessed <code>FormData</code> with <code>get()</code>, all methods documented in official standards are also available to us. If we wanted to cycle through all values and keys submitted, we could do so using a <code>for...of</code> loop and access the values via <code>form.values()</code> and <code>form.keys()</code>.</p>
<p>Now that we know how to obtain data from submitted forms, we should also look at another way of receiving data from users that may be overlooked – the URL.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>URL</h1>
<p>The <code>event</code> object, just as the <code>request</code> object was. Let’s continue with our previous example using comments. If we wanted to build a commenting service for use across a network of other websites, we may want to report to a user which site they just commented on. Let’s expand on that previous example and do just that. We don’t need to make any changes to <code>src/routes/comment/+page.svelte</code>. Instead, we’ll adjust our server action accordingly.</p>
<p>This example is identical to the last except for a couple of changes. The URL API is accessed via <code>event.url</code> and assigned to the <code>url</code> constant. It is then output to the server with <code>console.log(url)</code> to show you the various read-only properties that you can access. For this demonstration, we get the hostname via <code>url.hostname</code> and use it in a<a id="_idIndexMarker061"/> template literal, which is assigned to the <code>msg</code> property of the returned object:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/comment/+page.server.js</p>
<pre class="source-code">
export const actions = {
  default: async (event) =&gt; {
    const form = await event.request.formData();
    const url = event.url;
    console.log(url);
    const comment = form.get('comment');
    if(comment) {
      // save comment to DB here
      return {
        status: true,
        msg: `Your comment at ${url.hostname} has been 
          received!`
      }
    }
  }
}</pre>
<p>If you switch to your <a id="_idIndexMarker062"/>browser window and post a comment, you’ll now see that it reports the <code>hostname</code> property. In a production environment, this would ideally be your domain name, but in our development environment, we see the message <code>http://localhost</code>, you’ll see <code>URL</code> object:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Sample event.url object</p>
<pre class="source-code">
URL {
  href: 'http://127.0.0.1:5173/comment',
  origin: 'http://127.0.0.1:5173',
  protocol: 'http:',
  username: '',
  password: '',
  host: '127.0.0.1:5173',
  hostname: '127.0.0.1',
  port: '5173',
  pathname: '/comment',
  search: '',
  searchParams: URLSearchParams {},\
  hash: ''
}</pre>
<p>This <code>URL</code> object <a id="_idIndexMarker064"/>showcases how simple it is to grab information about it. All of the read-only properties shown are easily accessed using dot notation. Gone are the days of parsing an entire <code>URL</code> with regex in an attempt to extract the portion needed. Now, if you wanted to get the values set in query strings, you could easily iterate over <code>event.url.searchParams</code> with a <code>for...of</code> loop. Go ahead and add some options to the URL in your browser. An example might look like <code>http://127.0.0.1:5173/comment?id=5&amp;name=YOUR_NAME_HERE</code>. Now, the <code>console.log(url)</code> function call will output the names and values set after the first <code>?</code> and each subsequent <code>&amp;</code>.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/>Summary</h1>
<p>In this chapter, we covered an example use case of <code>fetch</code> and a two-part demonstration showing how <code>URL</code> and <code>FormData</code> can be used. While the examples presented here do not represent the full scope of the various Web APIs that you’ll have access to, they should illustrate how simple it is to use them with SvelteKit. If you’re hoping to build applications with SvelteKit, it’s important you become familiar with these modern Web APIs, as they’re used extensively throughout development with SvelteKit. SvelteKit encourages you to lean on that existing knowledge. By doing so, SvelteKit can ship less code to you so that you can ship less code to your users.</p>
<p>In the next chapter, we’ll move away from the background information that is necessary for using SvelteKit and start building something that resembles an application. We’ll cover various routing techniques and how you can build out a consistent user interface across the application.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Resources</h1>
<ul>
<li>MDN Web Docs – For references to <code>fetch()</code>, <code>formData()</code>, <code>URL</code>, and more, visit <a href="https://developer.mozilla.org">https://developer.mozilla.org</a>.</li>
</ul>
</div>


<div><h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Part 2 – Core Concepts</h1>
<p>Navigation on the web is such a quintessential experience that the developers of SvelteKit have made routing central to the framework. In this part, we’ll examine previously introduced routing techniques in more detail. After that, we’ll see how SvelteKit moves data to components and accepts data from them through HTML form elements. Finally, we’ll see some more advanced routing techniques that promise to cover even the most obscure edge cases encountered in routing.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Effective Routing Techniques</em></li>
<li><a href="B19024_05_Final_AM.xhtml#_idTextAnchor072"><em class="italic">Chapter 5</em></a>, <em class="italic">Deep Dive into Data Loading</em></li>
<li><a href="B19024_06_Final_AM.xhtml#_idTextAnchor080"><em class="italic">Chapter 6</em></a>, <em class="italic">Forms and Data Submission</em></li>
<li><a href="B19024_07_Final_AM.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Routing Techniques</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>