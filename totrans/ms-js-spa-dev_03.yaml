- en: Chapter 3. SPA Essentials – Creating the Ideal Application Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now be fairly comfortable working within the Node.js ecosystem of
    modules, tasks, and package management. In this chapter, we will dive a bit deeper
    into the intricacies of a JavaScript SPA and its dependencies. We will explore
    various data formats and database types, SPA encapsulation architectural patterns,
    and more through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON and other data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between SQL and NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use SQL versus NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods of presenting a single page application container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving and managing layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON data format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is something that most JavaScript
    developers today are quite familiar with. Despite its name, JSON is a language-independent
    standard that is really just a text document, and it must first be parsed by JavaScript,
    or any language interpreter, before it can be used as data representing objects
    with name-value pairs, or as simple sequences of values.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason the JSON acronym includes the word *JavaScript* is because its formatting
    is based on the structure of JavaScript objects and arrays. This is why working
    with JSON data and JavaScript is so straightforward, and why it makes a lot of
    sense to consume JSON data from within JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `user.json` file we created in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever")*
    , *Model-View-Whatever* is an example of the JSON data interchange format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON follows the format of standard JavaScript objects, but must also adhere
    to a few important rules to be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: Property names must be formatted as strings in double quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value can be a string in double quotes, a number, `true` or `false`, an object,
    or an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects and arrays can be nested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double quotes contained within a string must be escaped using backslashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules allow the JSON format to be parsed directly to native JavaScript
    while still being strict enough to make it an easily interchangeable format across
    languages. Although native JavaScript object notation does not enforce the use
    of double quotes around property names, it is required for JSON in order to prevent
    JavaScript reserved word exceptions from occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reserved words in JavaScript are not allowed to be used as variable or function
    names because they represent some current or potential future construct of the
    language. For example, the reserved word `class` is often misused by inexperienced
    developers as a variable name for holding a CSS class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This example would throw an exception because `class` is a reserved word. Additionally,
    using it as a straight property name in a JavaScript object would throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An experienced JavaScript developer would know not to use this word as a property
    name due to it being a reserved word, but if your application is consuming JSON
    data from an external source, you have no control over the property names that
    may be pulled in with an object. For example, you may retrieve data from an application
    running on another server that is not JavaScript and has no awareness of the reserved
    word restrictions of any other application that may consume it. If this application
    wants to convey CSS class information, it is likely that it may use the word `"class"`
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the property name is valid because it is in double quotes and
    thereby parsed as a string instead of as a reserved word. For this reason, the
    rule requiring double quotes around property names is strictly enforced, and no
    JSON parser will allow property names without them.
  prefs: []
  type: TYPE_NORMAL
- en: Other data formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON was first conceived of in 2001 by Douglas Crockford. Before then, data
    interchange had long been a practice using established formats that were already
    integrated with many programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Long before JSON was commonly known, **Extensible Markup Language** (**XML**)
    was one of the most widely used web application data interchange formats. XML
    was first introduced in 1996 and would become an international standard. It is
    a form of **Standard Generalized Markup Language** (**SGML**) and was created
    by the **World Wide Web Consortium** (**W3C**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example of a XML document. If you haven't worked with XML before,
    you most likely have at least heard of it. XML was a precursor to many other data
    formats, including SOAP, RSS, Atom, and XHTML. XHTML is also well known to many
    web developers, and it was the recommended standard for serving web pages before
    the HTML5 specification was introduced. Notice that the formatting of the preceding
    example is similar to HTML.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'YAML is a recursive acronym, meaning it refers to itself, for *YAML Ain''t
    Markup Language*. What makes YAML interesting, aside from its silly name, is that
    its syntax for hierarchy requires the use of lines and indentation as delimiters,
    rather than structured enclosures such as curly braces and brackets, which are
    used in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for YAML was designed to make the hierarchy structure of data more
    easily human-readable by requiring the lines and spaces for explicit delineation
    of its structure. In contrast, other data formats that use characters such as
    brackets for defining structure can find it difficult to convey hierarchy to the
    human eye, especially when in compressed format.
  prefs: []
  type: TYPE_NORMAL
- en: YAML was first created around the same time as JSON, but it has not received
    nearly the amount of notoriety that JSON has in the web development community.
    YAML is arguably more flexible than JSON in that it allows for more features,
    such as comments and relational anchors, but it is likely the simplicity of JSON
    that makes it a more popular data format for consumption within web applications
    and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: BSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Binary JSON** (**BSON**) is a binary form of JSON that is used primarily
    as the data storage format for the MongoDB document-oriented database system.
    BSON is just like JSON, with the main difference being that BSON supports more
    complex data types such as Date, Timestamp, and `ObjectId`. An `ObjectId` in BSON
    and MongoDB is a 12-byte unique identifier for a stored object. MongoDB requires
    that every object has a unique identifier field named `_id` and an `ObjectId`
    is the default mechanism for assigning this field a value. This concept is much
    like a *primary key* in a relational database system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A BSON document that uses the `ObjectId` and `Timestamp` data types might look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we discuss MongoDB and document-oriented databases in this text, the term
    JSON may be used interchangeably for BSON with the implication that this distinction
    is understood. You can learn more about the BSON specification at bsonspec.org.
  prefs: []
  type: TYPE_NORMAL
- en: Why does JSON reign supreme?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is simple, easy to read, and structured in a way that is easily understood
    by just about any programming language in existence. Lists (or arrays) and name-value
    pairs (or associative arrays) are a fundamental concept and common implementation
    in computer languages. The simpler a format is, the easier it is to parse, and
    thus more platforms will develop a way to inherently consume that data format.
    Such has been the case with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the JSON specification was only changed a few times after it was
    first developed. Its creator, Douglas Crockford, intentionally gave no version
    number to the specification so that it would be set in stone and could not change
    over time. This may likely be the biggest factor in JSON's dominance over other
    data formats. Since it does not change over time, the parsers built to consume
    it across myriad programming languages and platforms don't have to change either.
    This has created an ecosystem in which JSON exists with only one version in every
    place, making it entirely predictable, widely understandable, and virtually unbreakable.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between SQL and NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*,
    we briefly discussed document-oriented databases, otherwise known as NoSQL databases.
    This concept is imperative to the MEAN stack, as the *M* in the MEAN acronym stands
    for MongoDB, a widely used NoSQL database implementation. NoSQL databases are
    conceptually divergent from traditional relational, or SQL, databases.
  prefs: []
  type: TYPE_NORMAL
- en: Non-relational databases have existed for decades, but they did not achieve
    any widespread use until more recently. This rise in popularity led to the term
    *NoSQL* first being applied to these types of databases. The reason for the increase
    in the use of NoSQL databases has primarily been to solve the problem of handling
    *Big Data*, or massive and complex datasets, and *scaling* that data horizontally
    in modern web applications.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL data typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term NoSQL means *non-SQL* which implies that it is a non-relational database
    type. NoSQL databases that are document-oriented, like MongoDB, store their data
    in documents represented by structured JSON objects. The data *types* in a NoSQL
    database like this are defined by the data itself, as is the case with standard
    JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you have a field in a NoSQL database with the key `id` and
    the value is `1`, a number, you could easily change the value to `myID`, a string,
    without needing to change any other reference to that data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the data *type* for that value is entirely dependent upon what
    it is defined as. In a relational database, making this change would not be so
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Relational data typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to document-oriented databases, traditional SQL databases use tables
    to structure their data. Each table column is set to a specific data type and
    the data stored under that column must adhere to the defined type. If you have
    a large SQL database and wish to change the type for a particular column, it can
    be potentially problematic and could require the change to be executed on thousands
    of rows of data. Changing a data type in a JSON document is relatively easy compared
    to this, as it only involves changing the data itself, and there is no concept
    of a table column defining the data type across multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: The term *relational* in regard to relational databases refers to the tabular
    relation of the data stored. Each table of data is considered a relation because
    the different data stored within it is related to one another in some manner defined
    by the applications and programs that will be consuming it. A table in a SQL database
    can be compared to a JSON object in a NoSQL database. The biggest difference between
    the two, however, is that a table is composed of rows and columns, and the data
    is further related by column types and rows containing records of related data.
    In a NoSQL database, there is no concept of rows and columns, and data can be
    nested with unlimited scope.
  prefs: []
  type: TYPE_NORMAL
- en: In order to retrieve *nested* data within a SQL database, relations must also
    be identified between tables. Since data cannot actually be nested, references
    from one or more tables to one or more other tables must be used to create related
    sets of data for use in application Models and Views. SQL is a programming language
    used to manage and extract the data from relational database tables and format
    it in such a way that is required for an application.
  prefs: []
  type: TYPE_NORMAL
- en: ACID transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of NoSQL database systems do not support *transactions* which conform
    to the properties of **ACID**, which stands for **Atomicity**, **Consistency**,
    **Isolation,** and **Durability**. This set of properties is required for a database
    to handle transactions in a reliable fashion. A transaction is any change made
    to a database. That change can be to a single value for a field in one table,
    or it can be a change that spans multiple tables and affects multiple rows within
    those tables. Most widely used relational databases support the ACID properties
    for transactions, no matter the complexity of the operation that is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Atomicity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Atomicity property of ACID refers to atomic operations within a database,
    meaning that the changes required for a transaction must all be ensured to occur,
    otherwise none will occur. This property provides a guarantee that partial changes
    are not made, which could lead to corrupt data sets. If an atomic transaction
    fails at any point within a database, the changes made up to that point are rolled
    back to their previous state.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Consistency property of ACID is the requirement that a transaction only
    causes *valid* data changes as defined by that database system. This includes
    ensuring that data is not corrupt, that rollbacks are enforced when necessary,
    and that all the necessary database triggers related to a transaction are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Isolation property of ACID requires that a simultaneously executed transaction,
    or concurrency, does not result in database errors in related data. This can involve
    different levels of strictness, dependent upon the database system being used.
    The primary goal of Isolation is that the end result of a set of concurrent transactions
    is the same as if you were to go back and replay them one after another. Isolation
    is closely tied to Consistency, and it should always ensure that Consistency is
    maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Durability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Durability property of ACID requires that a transaction is not *lost* while
    being executed. You can imagine any number of things going wrong with a computer
    that could occur during the execution of a transaction, such as a power outage.
    When something like this occurs, Durability provides that the database system
    *remembers* the transaction that was in the middle of execution by recording it
    to disk and ensuring that it isn't lost, even after a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB and ACID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is true that many NoSQL database systems do not conform to the ACID properties;
    however, MongoDB does to a certain degree. As mentioned, MongoDB is a document-oriented
    database system, which is a more terse subset of NoSQL databases. In this fashion,
    MongoDB has the ability to support ACID transactions at the single-document level.
    It cannot support multi-document transactions, so in this way it falls short of
    most relational databases, which can support ACID transactions across multiple
    tables, but MongoDB still stands out among document-oriented databases at the
    document level.
  prefs: []
  type: TYPE_NORMAL
- en: Write-ahead logging with MongoDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another feature that MongoDB touts above others is **Write-Ahead Logging** (**WAL**).
    This is a set of features allowing a database system to conform to the Atomicity
    and Durability properties of ACID. To do this, MongoDB writes a record of all
    operations and their results to an internal log before actually executing the
    operations. This is a simple and effective way to ensure the Durability of document-level
    transactions because with all operations logged ahead of execution, evidence of
    what occurred is not lost in the event of a sudden interruption to an operation.
    Similarly, this feature ensures Atomicity because it gives MongoDB the ability
    to *undo* and *redo* these operations upon reboot after determining what changes
    were made and comparing them to the state of the database before the interrupted
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: When to use SQL versus NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are clearly major differences between SQL and NoSQL databases, not only
    in how they are structured, but in how developers and applications interact with
    them. These differences can have serious implications for the development of an
    application from both an architectural and a functional perspective. This is why
    choosing your database type is no small matter and should always be thoroughly
    evaluated before moving forward with the development of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It was mentioned earlier that the needs of modern web applications have led
    to the rise in popularity of NoSQL databases. *Scalability*, or the ability to
    continuously handle growing amounts of data and operations on that data, is one
    of these needs. You can imagine this being the scenario for a social media company
    such as Facebook or Twitter, and any other social applications that may interact
    with social data received from resources like this. In the following, scalability
    is a feature you may need to take under consideration when deciding on the type
    of database you want to use for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In particular, *horizontal scaling* is a necessity for a growing number of modern-day
    web applications. This refers to the need for distributed servers and databases
    geographically with a growing user base. Effective horizontal scaling allows users
    of an application to receive data from a server that is closest to them, rather
    than a single server or set of servers that may be in a data warehouse halfway
    around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling is certainly not impossible with a relational database, but
    it is difficult, and it requires the use of a sophisticated **Database Management
    System** (**DBMS**). NoSQL databases, on the other hand, are simpler in design,
    and this makes data replication across clusters of machines and networks much
    simpler as well.
  prefs: []
  type: TYPE_NORMAL
- en: Big Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another need for modern web applications is **Big Data**, which can mean exactly
    what its name implies: a massive amount of data. More often than not, however,
    Big Data refers to a high degree of complexity among data sets such that it can
    be difficult to analyze and extract value from them without the aid of sophisticated
    techniques for doing so.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases lend themselves perfectly to handling Big Data due to their
    support for *dynamic schema design*, which simply means that you do not have to
    define a specific schema for a data set before you store it, as is required by
    traditional relational databases. This goes back to the flexibility of data typing
    in NoSQL, which doesn't require that the type for a field be governed by a rule,
    as it is for a column in a tabular data schema. Additionally, the schema for a
    relational database table cannot be changed without affecting all of the data
    for that table. In contrast, the schema of a particular data set in a JSON document,
    for instance, can change at any time without affecting previously stored data
    sets in that same document.
  prefs: []
  type: TYPE_NORMAL
- en: If Big Data is a foreseeable need for your web application, then the *type*
    of Big Data is a further consideration you should make before choosing a database
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Operational Big Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Operational Big Data** refers to data that is consumed and managed in real
    time to support the operation of currently running processes in distributed applications.
    Document-oriented databases such as MongoDB are built with operational Big Data
    support in mind and focus on *speed* of concurrent read and write operations to
    provide for this.'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB, and other NoSQL systems designed to work with operational Big Data,
    do so by taking advantage of modern distributed network computing power to increase
    the efficiency of operations. Traditional relational databases were not built
    with this ability in mind because computer systems were more isolated when they
    were developed.
  prefs: []
  type: TYPE_NORMAL
- en: Analytical Big Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Analytical Big Data** contrasts greatly with operational Big Data in that
    its focus is on **Massively Parallel Processing** (**MPP**). This means that massive
    amounts of data are consumed and later analyzed for any number of requirements
    that give value to the application using it. In contrast to operational Big Data,
    database systems designed for analytical Big Data focus on massive *throughput*
    and retrospective processing of that data, rather than speed of concurrent, unrelated
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The need to handle analytical Big Data is not always apparent at the outset
    when developing an application. Anticipation of this requirement is often difficult
    because when you start out with a small data set, you may not know what massive
    amounts of data you might want to analyze as your database matures over time.
    Fortunately, this problem can be handled by the implementation of a solution subsequent
    to identifying its need. MPP databases are built for this specific purpose, in
    addition to *MapReduce*, which is an alternative implementation to handle MPP
    across distributed computers in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Overall considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When deciding whether to use a SQL or NoSQL database for your application, you
    should consider the needs of your application both at the initial release and
    what you foresee further down the line. If you expect a large user base and the
    potential for viral growth, then you will want to consider a NoSQL database built
    for handling operational Big Data and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing an application that you anticipate having a smaller user
    base, or perhaps no users other than administrators of the data, then a relational
    SQL database may be more appropriate. Additionally, if your application may have
    many users, but has no need for horizontal scalability, a SQL database is likely
    suitable as well.
  prefs: []
  type: TYPE_NORMAL
- en: Also consider that many modern, distributed web applications started out using
    only relational databases, and they later implemented NoSQL solutions in congruence
    with the existing databases to handle growing needs. This is also a use case that
    can be planned for and adapted to as needed during the life cycle of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of presenting an SPA container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Single Page Application, the *container* is the object in which the application
    is initially loaded and displayed to the user. This concept is different from
    that of a *software container*, which is an isolated environment that an application
    lives in, much like a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a single page web application, the container could be the `<body>` element,
    or any element within the `<body>` element. For instance, you may have some static
    welcome text initially loaded on the page in a `<p>` element, and the SPA will
    then load dynamically below that element in a `<div>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a scenario like this, you will always have some fixed content on the page
    that doesn''t need to change based on the user''s interaction with the application.
    This is just a simple example, but the same could be done for a common `<header>`,
    `<footer>`, and `<nav>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to define your SPA container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no *right* way to define your SPA container; it really just depends
    on the type of application you are building and what your preference is. It can
    also depend on the server-side limitations of the system you are using to serve
    your *layout* - the HTML page used to house your app.
  prefs: []
  type: TYPE_NORMAL
- en: Partial page container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As shown in previous sections, you may want to show some static content in your
    SPA layout before the application loads. This is useful when you anticipate a
    long initial load time for an app, or if you require some user interaction to
    trigger the loading of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Full page container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your application can be completely controlled through API endpoints accessed
    by **XMLHttpRequest**, commonly known as **Asynchronous JavaScript and XML** (**AJAX**),
    then there is no need to load any static content in your SPA layout unless you
    want to. One reason you may load static content in your layout is to have something
    for the user to view or read while they are waiting for the application to load.
    This can be particularly useful when you anticipate long initial load times for
    your app and you want to help deter a user from leaving before the application's
    initial *state* is ready.
  prefs: []
  type: TYPE_NORMAL
- en: A *state* in a SPA refers to a particular version of the **Document Object Model**
    (**DOM**), at any point in time. A *loading state* is one you might show within
    your container element while waiting for it to load the next requested state.
    A loading indicator of some sort is often enough to let the user know that something
    is happening and the application will load soon, but when you have any excessive
    latency in your app, a user may think something has gone wrong and leave the app
    layout page before the process completes.
  prefs: []
  type: TYPE_NORMAL
- en: How to load your SPA container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way you initially load your SPA is highly dependent upon the nature of your
    application. There could be any number of requirements that must be fulfilled
    before your app can be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Loading on user interaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many web applications require some type of user interaction before the full
    SPA is loaded. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: User authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User acceptance of an agreement to enter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interstitial content that must be shown and either engaged or dismissed by the
    user, such as an advertisement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios like these are quite common in web applications, and they can often
    be challenging to solve in a fluid manner.
  prefs: []
  type: TYPE_NORMAL
- en: Login page transition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many web applications, the login screen is loaded on a secure page and submitted
    using HTTP POST to another secure page to authenticate the user and load the actual
    SPA. This pattern is generally used due to limitations in the server-side framework
    that is being used to handle authentication.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about a financial application for accessing your bank account that
    you log in to on your phone, you will likely not see much more than a login screen
    until you have authenticated with your username and password. This will typically
    bring you to a second page that loads the full single page application with your
    sensitive banking information that you would not otherwise want available to someone
    else who picks up your phone.
  prefs: []
  type: TYPE_NORMAL
- en: A login screen is arguably the most common use case requiring user interaction
    to load an application, and it is one that is often handled with little elegance.
    The most fluid way to handle this use case, if your REST framework allows for
    it, is to load a login screen as part of your SPA and request authentication via
    a REST endpoint from your login form. When you receive a properly authenticated
    response from your API request, you can then load the data you need into the existing
    SPA container and replace the login state with a new *logged in* state.
  prefs: []
  type: TYPE_NORMAL
- en: Loading based on the DOMContentLoaded event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your SPA does not require user authentication or any other interaction for
    initial loading, or if you detect a user that is already authenticated at the
    time the page is loaded and you can skip that step, then you will want a way to
    automatically load your SPA upon initial page load, and as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best time to load a single page application is generally as soon as the
    DOM is completely loaded and can be parsed by the browser. Modern browsers fire
    an event on the `document` object when this happens, called `DOMContentLoaded`,
    and that can be used for this purpose. To do this, you would simply add an `EventListener`
    on the `document` to detect when the event is fired, and then call a function
    to load your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are using jQuery, you can call the handy jQuery `.ready()`
    method to listen for the `DOMContentLoaded` event and trigger your custom application
    code within an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Loading based on the document readystatechange event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modern browsers also provide an event that is fired on the `document` object
    when you first load a page called `readystatechange`. This event can be used to
    determine three states of the DOM, which are returned as the following via the
    `document.readyState` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading` - This is when the document is still loading and has not been entirely
    parsed by the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interactive` - This is when all DOM elements have finished loading and can
    be accessed, but certain external resources may have not fully loaded, such as
    images and stylesheets. This state change also indicates that the `DOMContentLoaded`
    event has been fired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete` - This is when all DOM elements and external resources have fully
    loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the `readystatechange` event to load your application at the same time
    as the `DOMContentLoaded` event, you would assign a function to be called on the
    `readystatechange` event and then check whether the `document.readyState` property
    is set to `interactive`. If it is, then you can call your application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using this method to detect the state of the document provides more flexibility
    in the event that you want to call custom application code for any of the three
    document states, and not just on the `DOMContentLoaded` event, or `interactive`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Loading directly from the document.body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The more traditional way of loading `<script>` tags is by placing them within
    the document `<head>` element. Adding the `<script>` tags to the `<head>` is fine
    for loading an SPA if you are using the document `DOMContentLoaded` or `readystatechange`
    events within your external JavaScript to initialize your application code at
    the appropriate time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want to avoid using these custom DOM events and trigger your application
    code precisely when you need it, however, a different and more direct approach
    can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common technique for loading JavaScript into a web page today is by placing
    the `<script>` tag, which loads your external JavaScript file, directly within
    the `<body>` element of the page. The ability to do this lies in the way the DOM
    is parsed by a browser: from the top to the bottom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Loading the external JavaScript `app.js` file from within the `document.body`
    and just above the closing `</body>` tag will ensure that all DOM elements above
    the `<script>` tag are parsed before it is loaded, and the `app.js` file is loaded
    precisely after the `<div class="container">` element. If that element is where
    you will load your SPA, then this technique ensures that your application code
    within `app.js` will be executed immediately following the `container` element
    being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to loading your `<script>` tags near the bottom of the DOM
    and below the elements that are required for loading your application is that
    the loading of those `<script>` tags will not block the loading of any content
    above them, due to the browser's top-down parsing of the DOM. Once the `<script>`
    tag is reached, there may be some blocking preventing the browser from being usable
    while it is being loaded, but the user will at least see everything on the page
    that has been loaded up until that point.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, loading a `<script>` tag within the `<body>` and near the bottom
    of the DOM is preferable to loading it with the traditional `<head>` tag insertion
    so that no blocking occurs before anything is visible on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Using the script tag async attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One method for preventing a `<script>` tag from blocking the browser usability
    while it is loaded is the `async` attribute. This attribute can be added to ensure
    that your `app.js` file is loaded asynchronously once parsed, and so that the
    rest of the DOM continues to be parsed and loaded, regardless of when the loading
    of that script completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The advantage to this is, again, there is no blocking. The disadvantage to it,
    however, is that when you are loading multiple scripts asynchronously, there is
    no guarantee in what order they will finish loading and eventually execute. This
    is why it also a good practice to load only a single, compressed JavaScript file
    for your application as much as possible. The fewer `<script>` tags there are,
    the fewer external resources have to be parsed and downloaded, and in the case
    of using the `async` attribute, using only one `<script>` tag means waiting for
    only one asynchronous resource to load and not having to worry about the unpredictable
    sequence of loading multiples files, which could potentially break your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the script tag defer attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another method for loading a `<script>` tag directly from the body and not causing
    the document parser to be blocked is the `defer` attribute. Unlike `async`, this
    attribute ensures that the `<script>` tag will not be loaded until the document
    parsing is complete, or upon the `DOMContentLoaded` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `defer` attribute, your `<script>` tag can be placed anywhere within
    the `<body>` and always be guaranteed to load after the `DOMContentLoaded` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Managing layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever")* ,
    *Model-View-Whatever*, a *layout* in relation to an SPA is the server-side HTML
    page that is used to house, initialize, and display your app. The layout will
    contain similar HTML markup to the examples in the previous section regarding
    how to load your SPA container.
  prefs: []
  type: TYPE_NORMAL
- en: The layout is generally the only native server-side component necessary to create
    an SPA, the other components being the native frontend code and the external API
    for providing endpoints for data consumption and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Static layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A layout can be something as simple as a static HTML page that is loaded onto
    a web server and calls the resources necessary for loading your app within a defined
    container element on that page. Ideally, once that initial HTML page is loaded,
    no other server-side HTML pages need to be accessed to run your app, hence the
    term *Single Page Application*.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not require any server-side framework interaction for setting up environment
    variables, testing login state, and so on, then a static HTML page is the quickest
    and easiest way to launch your SPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'A static HTML layout page could be something as simple as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A drawback to using a static HTML file simply being served on a web server is
    that you have to go directly to that file in order to load your app. If your app
    is reached at `myapp.com`, for instance, and your static HTML layout page is named
    `index.html`, most web servers will route the *root* server request to this page
    automatically, so a user would not need to navigate directly to `myapp.com/index.html`
    in order to reach it, but just to `myapp.com`.
  prefs: []
  type: TYPE_NORMAL
- en: If a user were to go to `myapp.com/profile`, however, where they might find
    their user profile information, the app layout would not be loaded and the server
    would generate a **HTTP 404**, or **Not Found**, response. In order to provide
    for this use case and allow custom URLs for your app, a *dynamic layout* is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have control over the server-side framework for your single page application,
    as would be the case when using the MEAN stack, then you may want to develop a
    more dynamic server layout page that can load variables and some minimal logic
    from the server side when your app initially loads.
  prefs: []
  type: TYPE_NORMAL
- en: Express is a server-side web framework for Node.js, and it is the *E* in the
    MEAN stack acronym. When you are developing with the MEAN stack, you will be using
    Express to define and handle all of your REST API endpoints, but you will also
    want to handle your main application entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to our Node.js environment we have been using to work with NPM,
    Bower, and Grunt, and install Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using the `--save` parameter to save Express to our main
    NPM dependencies, since it is not just being used for development.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic server with Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have Express installed, create a file called `server.js` in the root
    directory of your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this file, add the following code to include the Express module and
    initialize your application object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `app` object within your `server.js` file will allow you to call methods
    on it for defining routes. In the case of our SPA example, we only need to define
    one route for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: Basic routing with Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Routing in Express refers to defining URL paths which are used to respond to
    server requests. Express can define routes for any type of HTTP request, including
    `GET`, `POST`, `PUT`, and `DELETE` requests, which are necessary for creating
    a REST API. At this point, however, we simply want to define a route for loading
    a HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a route for your main application entry point would be a GET request,
    and this is quite simple to do with Express. In the `server.js` file you just
    created, add the following code below the `app` object definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command adds a route that will serve the `index.html` file you created
    earlier as the root response for the app. The second parameter, which defines
    a `root` property as `__dirname`, simply sets the root server path for the app
    to the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to use Express to serve our app instead of the simple `http-server`
    module from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Running a server with Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have your `server.js` file set up with a basic route to the root
    of your application, all that is left is to set up a HTTP port to listen on and
    to load the app. In your `server.js` file, add the following code to your route
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the server to listen on HTTP `port 8080` for serving the app layout.
    Now all you have to do is run the server from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will run the server and display the console message `App now listening
    on port 8080` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Now go to `localhost:8080` in your browser and you should see the simple SPA
    page we created in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), Model-View-Whatever*.
    You will notice some errors in your browser console, however, because the local
    JavaScript files which are linked to in `index.html` are not found. This is occurring
    because you have not defined a route for loading static asset files.
  prefs: []
  type: TYPE_NORMAL
- en: Loading static assets with Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, stop the app by pressing *Ctrl* + *C* from the command line. Now edit
    `server.js` again and add the following code *above* the SPA layout page route
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command will set the app to load static assets from the root directory.
    Now if you run `nodeserver.js` again from the command line and reload the page
    in your browser, the SPA should load all assets and work just as it did before
    with `http-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routing with Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier, our app should allow a user to go to something like `myapp.com/profile`,
    or in our case `localhost:8080/profile`, to load a dynamic request that will trigger
    a different view than the main root view for the app. If you go to `localhost:8080/profile`
    in your app now, you will get the following response in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, stop your local server again, edit the `server.js` file and make
    the following change to the app layout route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply changed the path parameter in the `GET` route definition from
    `'/'` to `'*'`. Express allows for regular expression syntax within route definitions,
    so what this does is tell the server to route all dynamic path requests to the
    `index.html` page, instead of just the root `'/'` path.
  prefs: []
  type: TYPE_NORMAL
- en: Save this change, and now if you run `node server.js` again on the command line
    and go to `localhost:8080/profile` in your browser, you will see the SPA displayed
    again just as it did from the root path, and all static asset files should be
    loaded as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting up this basic Node.js Express server, your final `server.js`
    file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our simple SPA has now become a bit more sophisticated, with the ability to
    serve a dynamic layout file, and to use dynamic routes for loading the layout
    via custom URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a better understanding of various data interchange formats
    such as JSON, BSON, XML, and YAML, and how they are used in web applications.
    You should understand the differences between SQL and NoSQL databases and what
    the advantages are of using one or the other depending on the needs of your application,
    and you have also learned about MongoDB and its use of BSON as a binary form of
    JSON. Additionally, you have learned about using web SPA container elements, and
    various methods of initializing and loading your app into that container.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are fundamental to understanding SPA development in general,
    and to understanding the inner workings of the MEAN stack and how it differs from
    other application development architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have gotten a glimpse into the server side of a Node.js application
    and built a basic server with Express, let's go deeper into working with Express
    and learn about creating REST API requests for consumption within an SPA.
  prefs: []
  type: TYPE_NORMAL
