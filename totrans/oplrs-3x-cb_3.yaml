- en: Chapter 3. Working with Vector Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a GML layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding KML layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating features programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and creating features from a WKT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding markers to the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using point features as markers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with popups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding features from a WFS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the cluster strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering features in WFS requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading features directly using Protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter talks about vector layers. In addition to raster, vector information
    is the other important type of information we can work with in a GIS system.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter tries to summarize the most common and important recipes you may
    need to work with in OpenLayers.
  prefs: []
  type: TYPE_NORMAL
- en: In GIS, a real-world phenomenon is represented by the concept of a feature.
    It can be a place—like a city or a village—it can be a road or a railway, it can
    be a region, a lake, the border of a country, or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every feature has a set of attributes: population, length, and so on. It is
    represented visually by a geometrical symbol: point, line, polygon, and so on,
    using some visual style: color, radius, width, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many concepts to take into account when working with
    vector information. Fortunately, OpenLayers provides us classes to work with them.
    We will learn more about these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The base class for vector layers is `OpenLayers.Layer.Vector` class, which defines
    the common properties and behavior for all the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenLayers.Layer.Vector` class contains a set of features. These features
    are instances of the `OpenLayers.Feature.Vector` subclasses (which, in fact, are
    inherited from a more generic `OpenLayers.Feature` class).
  prefs: []
  type: TYPE_NORMAL
- en: Each feature has an `attributes` property and an `OpenLayers.Geometry` class
    instance associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: The vector layer itself or each feature can have a visual style associated with
    it, which will be used to render the feature on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the representation on the screen, we need to take into account
    the data source. OpenLayers offers classes to read/write features from/to many
    sources, or protocols, and using different formats: GML, KML, GeoJSON, GeoRSS,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector layer has optionally associated an instance of the `OpenLayers.Protocol`
    class and a list of instances of the `OpenLayers.Strategy` class. The first is
    responsible to read/write data using some protocol, such as HTTP or WFS, while
    the second (the strategy) is responsible to control tasks such as when to load
    or refresh the data in the layer: only once, every time the layer is moved, every
    few seconds, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and see these classes in action.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a GML layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Geography Markup Language (GML)** is an XML grammar used to express geographic
    features. It is an OGC standard and is very well accepted by the GIS community.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a GML layer](img/7843_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we will show you how to create a vector layer from a GML file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the necessary files in the GML format attached to the source code
    of this book on the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file with the required OpenLayers dependencies and insert the
    following code. First add the `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the JavaScript code to initialize the map, add a base layer, and
    a layer switcher control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a vector layer with the GML data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before using the `OpenLayers.Layer.Vector` class, we need to take some aspects
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to load data from some source then we need to set a protocol and
    a strategy. In this case, we have used a fixed strategy, through the `OpenLayers.Strategy.Fixed`
    class instance, which means the data content is loaded only once. It is never
    refreshed or loaded again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The data to be loaded is accessible via the HTTP protocol and a URL to the file.
    The protocol, as an instance of the `OpenLayers.Protocol.HTTP` class, is responsible
    to read the data from the specified resource and requires a URL and a format to
    know how to read the data.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers offers many format classes to read/write data, but in this recipe
    we have made use of an `OpenLayer.Format.GML` instance because our data source
    is a GML file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding a KML layer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a KML layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The arrival of Google Maps leads to an explosion in the world of GIS and web
    mapping. Google introduced not only an API but also some file formats.
  prefs: []
  type: TYPE_NORMAL
- en: The **Keyhole Markup Language (KML)** had become one of the most extensively
    used formats, and finally it became an OGC standard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a KML layer](img/7843_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This recipe will show you how easy it is to add features from a KML file. You
    can find the necessary files in the KML format attached to the source code of
    this book available on the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file including the OpenLayers library and insert the following
    code in it. First, add the `DOM` element that will hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, initialize a map instance, add a base layer, add a layer switcher control,
    and center the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a vector layer that will load data from a KML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After initializing the map, we centered the view and added some controls. Then
    we added a vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: Because we want to load data from a KML file, that is accessible via HTTP protocol,
    we have set an `OpenLayers.Protocol.HTTP` instance as the protocol of the vector
    layer. It uses the URL of the file and uses an `OpenLayers.Format.KML` instance
    as the `format` property.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have set an `OpenLayers.Strategy.Fixed` instance as the strategy
    of the vector layer, which makes the file load only once.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have used a couple of `OpenLayers.Format.KML` classes, `extractStyles`
    and `extractAttributes`, to maintain the color styles and attributes specified
    in the source KML file. Otherwise, OpenLayers will apply a default style.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The KML format, like GML, offers tons of options and possibilities at the cost
    of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the KML format, placemarks can have a description attached to them and, if
    you load a KML file in Google Maps, the placemark's description is shown as a
    balloon (or popup) when you click on them.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenLayers, this approach differs a bit. As we will see in the *Working with
    popups* recipe, the process to load the KML data and the behavior to show them
    are completely different. So don't expect the vector layer that loads the data
    to also attach the required code to control the click event, show the popup, and
    so on. That is our work.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding a GML layer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with popups* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating features programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading data from an external source is not the only way to work with vector
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a web mapping application where the user can create new features on
    the fly: cities, rivers, areas of interest, and so on, and add them to a vector
    layer with some style. This scenario requires the ability to create and add the
    features programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will see some ways to create and manage features programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a new HTML file with the required OpenLayers dependencies.
    Add the `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, initialize the map instance and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create three vector layers to put three different types of features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the function that will create the point, line, and polygon features and
    add them to each of the previous layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As described in the chapter's introduction, a vector layer contains a set of
    features. Each feature represents some phenomenon of the real world and has a
    geometry and a style associated with it, which will determine the visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start looking at the code responsible for creating random points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each feature is represented by a point geometry, because we first
    need to create an `OpenLayers.Geometry.Point` instance with the coordinates of
    the point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to express the coordinates in the appropriate projection, the one used
    by the map, or set the right projection in the vector layer so that OpenLayers
    can translate the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the geometry instance, we can create a new `OpenLayers.Feature.Vector`
    instance by passing the desired geometry instance to be used by the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we will cover working with feature styles in another chapter. It will
    be rendered with a default OpenLayers style.
  prefs: []
  type: TYPE_NORMAL
- en: All the features are stored in an array and passed at once to the vector layer
    using the `addFeatures()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Next in the difficulty order is the creation of lines, named in the geometry
    objects terminology as LineStrings. When you want to represent a feature as a
    LineString you need to use an instance of the geometry class `OpenLayers.Geometry.LineString`.
    As we can see in the following block of code, the line string constructor needs
    an array of the `OpenLayers.Geometry.Point` instance that conforms the set of
    points for the lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OGC's Simple Feature Access specification ([http://www.opengeospatial.org/standards/sfa](http://www.opengeospatial.org/standards/sfa))
    contains an in-depth description of the standard. It also contains an UML class
    diagram where you can see all the geometry classes and hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we found the code that creates some polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Polygons are great geometries to represent states or countries. We can think
    of polygons as a simple set of lines where the start and end point is the same,
    a so called *LineRing*, and filled with some color. But be aware, polygons can
    be very complex structures that complicate the way we must express them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think of a region with a hole in it. In this case we have two line
    rings to describe the external and internal perimeters. We must also specify which
    part must be colored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we create an `OpenLayers.Geometry.LineRing` instance by passing an array
    of `OpenLayers.Geometry.Point` with the set of points that conforms the line ring.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have one or more line rings, we can create a new instance of the `OpenLayers.Geometry.Polygon`
    class, which will be used to render our new vector layer feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding marker to the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading and creating features from WKT* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with popups* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and creating features from a WKT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenLayers comes with a great set of format classes, which are used to read/write
    from/to different file data formats. GeoJSON, GML, or GPX are some of the many
    formats we can find.
  prefs: []
  type: TYPE_NORMAL
- en: If you have read the *Adding a GML layer* recipe in this chapter, you will know
    that a vector class can read the features stored in a file, specify the format
    of the data source, and place the contained features in the map.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe wants to show us exactly that. We will see the magic step responsible
    to read data from a file using a format class, and transform it to the corresponding
    feature ready to be placed in the layer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity, we will only see how to read features from the WKT text. You
    can learn more about WKT (Well-Known Text) format from [http://en.wikipedia.org/wiki/Well-known_text](http://en.wikipedia.org/wiki/Well-known_text).
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the previous screenshot, we are going to create a map on the
    left side, and on the right we will place a couple of text area components to
    add and get features in the WKT format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading and creating features from a WKT](img/7843_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new HTML file with OpenLayers dependencies. Then, add the following
    HTML code for the map, text area, and buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, we are using Dojo toolkit framework ([http://dojotoolkit.org](http://dojotoolkit.org))
    to improve our components, so some elements will have attributes like `dojoType="dijit.form.Button"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will initialize the map component and place a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go on to create a vector layer to hold the features we will read from
    the WKT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a couple of functions to handle the button events. The first function
    is responsible to clean the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second function reads the data from the WKT string and places the features
    on the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the format classes are inherited from the `OpenLayers.Format` base class,
    which defines the basic behavior of the format classes, that is, have a `read`
    and a `write` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `read()` method is supposed to read data in some format (a JSON string,
    a WKT string, and so on) and return an array of features as instances of the `OpenLayers.Feature.Vector`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` method, on the other hand, receives an array of features and returns
    a string that represents the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the format subclass, the `read` and `write` methods can accept
    additional parameters. Always be careful and read the API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the features from a WKT string, we only need to instantiate the desired
    format class and call its `read` method by passing a valid string as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the current features of the vector layer and convert them to a
    WKT representation by passing them to the `write` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding a GML layer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading features directly using Protocols* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding markers to the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Markers are widely used in web mapping applications. They allow us to quickly
    identify points of interest (POI) by showing an icon at the desired place.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to add markers to our maps by using the `OpenLayers.Marker`
    and `OpenLayers.Layer.Markers` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding markers to the map](img/7843_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating an HTML page with dependencies on the OpenLayers library.
    Add the `div` element that will hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a new kind of layer, `OpenLayers.Layer.Markers`, specially designed
    to contain the `OpenLayers.Marker` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create markers at random places by using a random icon from an
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The class `OpenLayers.Layer.Markers` is a direct subclass of the `OpenLayers.Layer`
    base class, and is specially designed to contain markers.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a marker is represented by instances of the class `OpenLayers.
    Layer.Markers`. Every marker has an associated point, expressed with an instance
    of the `OpenLayers.LonLat` class, and an icon using an instance of `OpenLayers.Icon`.
  prefs: []
  type: TYPE_NORMAL
- en: An icon requires a *URL* of the image to be loaded, a *size* expressed as an
    instance of `OpenLayers.Size`, and an *offset* expressed as an instance of `OpenLayers.Pixel`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, for each marker we have registered two listeners, one to know when
    the mouse is over and one to know when it leaves the marker. In this way, we can
    modify the size and opacity of the marker to highlight when the mouse has selected
    or deselected it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the handler functions, we have made use of the methods `inflate()`,
    to change the size of the icon augmenting its proportions, and `setOpacity()`,
    to change the icon opacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For beginners in JavaScript, remember the object that calls the anonymous function
    that handles the marker event is the marker itself. Because the `this` keyword
    is referencing the marker with which we can call the `inflate()` or `setOpacity()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of markers through the `OpenLayers.Marker` and `OpenLayers.Layer.Markers`
    classes is not the only way we can show POIs in our maps.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the *Using point features as markers* recipe, we can also
    use features to show POIs as an alternative that can be improved by the use of
    strategies, formats, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, OpenLayers offers some classes, such as `OpenLayers.Layer.GeoRSS`
    or `OpenLayers.Layer.Text`, that create markers automatically from the GeoRSS
    and CSV files respectively. They are relatively simple and are implemented for
    a specific usage and, most probably, you will soon need more flexibility than
    offered by those classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Using point features as markers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading features directly using Protocol* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using point features as markers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying markers is not only limited to using the `OpenLayers.Marker` and
    `OpenLayers.Layer.Markers` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A marker can be understood as a point of interest (POI) where we place an icon
    to identify it and has some information associated with it: a monument, a parking
    area, a bridge, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use these features with a point geometry
    type associated to create markers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using point features as markers](img/7843_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created the right HTML file with OpenLayers dependencies, add
    a `div` element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start initializing the map instance and add a base layer and control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a vector layer that will contain a set of random markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create some random points. To improve the performance we add all the points
    to an array and then to the vector layer all at once with the `addFeatures` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, attach two event listeners to the vector layer for the `featureselected`
    and `featureunselected` events. The listener will be responsible for changing
    the feature style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to attach a `SelectFeature` control to the map, and reference
    the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea is simple, add point features to the layer and listen for their selection
    event to change the style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a different way than working with the `OpenLayers.Marker` instances, we
    need to attach listeners to the vector layer and not to the feature itself, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the listener function, we can access the selected feature or the vector
    layer it belongs to with the `event` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Styling Features"), *Styling Features*,
    we will learn more about styling features and improving its look using images,
    in a similar way to the `OpenLayers.Marker` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the feature style is changed, we can call `drawFeature()` on the vector
    layer to refresh the feature on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To allow the vector layer to trigger events, we need to attach a `SelectFeature`
    control to the map, reference the vector layer, and activate it. Without it the
    listeners will never be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding markers to the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with popups* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the cluster strategy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with popups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common charecteristic of web mapping applications is the ability to show information
    related to the features the map contains. By feature we mean any real phenomenon
    or aspect we can visually represent with points, lines, polygons, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Of course we can select a feature, retrieve its associated information and show
    it anywhere in our application layout, but the most common way to show it is by
    using popups.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with popups](img/7843_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file with OpenLayers dependencies. Then add the `div` element
    to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the JavaScript section, initialize the map and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a vector layer and add some features to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add some random features to the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to change the previous URL to the right address of your custom server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the code responsible to manage the feature selection to show the
    popup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we did, after creating the vector layer, was the creation of
    some random point features.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are computing random latitude and longitude values in decimal degrees
    ("EPSG:4326" projection), we need to translate it to the projection used by the
    map. In this case, because `OpenStreetMap` is the base layer, it applies an`"EPSG:900913"`
    projection as the map's projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are creating features with a custom style. The constructor of the `OpenLayers.Feature.Vector`
    class accepts three parameters: a *geometry* parameter, which is mandatory, and
    two optional parameters, the feature *attributes* and the feature *style*.'
  prefs: []
  type: TYPE_NORMAL
- en: Our features have no special attributes so we have passed a `null` value but,
    on the other hand, we have used a custom style to show an icon image instead of
    a simple point to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the features we want, it is time to show a popup with some nice
    description when a feature is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we have used the `SelectFeature` control. Given a layer, this
    control allows the user to select features. We can customize the behavior of the
    control with the `options` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe we have used the following three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hover:` It indicates that the features must be selected or unselected without
    the need of clicking on it, and by simply moving the mouse over the button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSelect:` This function is executed when a feature is selected. It receives
    the selected feature as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onUnselect:` This function is executed when a feature is unselected. It receives
    the unselected feature as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's take a look at how to create the popups.
  prefs: []
  type: TYPE_NORMAL
- en: The important point to be noted here is that popups are added to the map. They
    are not added to a feature and nor to a layer. So to show or hide a popup, we
    simply need to add or remove it from the map with the methods `addPopup()` or
    `removePopup()`.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers offers some classes to be used as popups, but all of them are inherited
    from the base class `OpenLayers.Popup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have chosen the `OpenLayers.Popup.FramedCloud` subclass, which is a visually
    decent styled popup. The constructor requires the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id:` A string that identifies the popup among all the popups that can exist,
    which are attached to the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lonlat:` The location where the popup must appear'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentSize:` The dimensions of the popup, as an instance of the `OpenLayers.Size`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentHTML:` The HTML string to be put as content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor:` An object where the popup will be anchored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeBox:` Boolean indicating if the close buttons must be shown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeBoxCallback:` A function that will be executed when the user clicks on
    the close button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all these parameters, our code to create a `FramedCloud` popup looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, we add it to the map, which makes it visible automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also stored a reference of the popup within the feature. In this way,
    we can easily find a reference to the popup in the function that is executed when
    the feature is unselected and remove it from the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a note, the map's `addPopup()` method has a second and optional parameter
    `exclusive`, which if set, automatically removes all existing popups in the map
    when a new one is added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding markers to the map* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using point features as markers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding features from a WFS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Web Feature Service (WFS)** is an OGC standard, which provides independent
    platform calls to request geographical features to a server. In practice, it means
    a client makes a HTTP request to a server that implements the WFS standard and
    gets a set of features in the GML (Geographic Markup Language, [http://en.wikipedia.org/wiki/Geography_Markup_Language)](http://en.wikipedia.org/wiki/Geography_Markup_Language))
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A nice introduction to WFS can be found in the tutorial about WFS available
    at [https://www.e-education.psu.edu/geog585/book/export/html/1724](http://https://www.e-education.psu.edu/geog585/book/export/html/1724).
    If you want to learn more about this, there is a complete specification on the
    OGC site [http://www.opengeospatial.org/standards/wfs](http://www.opengeospatial.org/standards/wfs).
  prefs: []
  type: TYPE_NORMAL
- en: From the OpenLayers point of view, the WFS is nothing more than another data
    source we can read to fill a vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, there is an important point to take into account. Most of
    the requests made by OpenLayers when data is loaded, say GML, KML, or GeoRSS files,
    are made asynchronously through the helper class `OpenLayers.Request`.
  prefs: []
  type: TYPE_NORMAL
- en: Any JavaScript call is limited by the security model imposed by the browser,
    which avoids cross domain requests. This means you can only make requests to the
    same server that the web page originally came from.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to avoid this fact, but a simple one is the use of
    a proxy on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read a clearer explanation at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.yahoo.com/javascript/howto-proxy.html](http://developer.yahoo.com/javascript/howto-proxy.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a proxy is simple, instead of making a request directly to a cross
    domain we make a request to a script on the same domain, which is responsible
    for making the cross domain request and returning the results.
  prefs: []
  type: TYPE_NORMAL
- en: A script, say PHP, Python, or Java servlet, is not limited by the cross domain
    requests. It is only security imposed by the browser in the JavaScript calls.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers offers a proxy implementation as a Python script that we can use
    in our application. It can be found in the `examples/proxy.cgi` file in the source
    code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: It is not the only possibility. For this recipe we will be using a PHP proxy
    file (see the `utils/proxy.php` file in the book's source code) from the `MapBuilder`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a HTML file, set the OpenLayers dependencies, and add a `div` element
    to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `OpenLayers.ProxyHost` variable to our proxy URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the map and add a base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a vector layer that uses the WFS protocol to access the data
    source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first important step is to set the `OpenLayers.ProxyHost` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Most of the JavaScript requests in OpenLayers are made through the helper class
    `OpenLayers.Request`, which checks if the previous variable is set. If so, all
    requests are made using the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the main action in this recipe is the creation of a vector layer
    filling its data from a WFS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only thing to do is set the protocol to be used by the layer.
    In this case, we use an instance of the `OpenLayers.Protocol.WFS` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WFS protocol constructor has many parameters but the most important ones
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url:` The URL to the WFS server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`featureType:` The feature to be queried'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`featureNS:` The namespace of the feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other important options and, more or less, the commonly used ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`geometryName:` Specifies the name of the attribute that stores the feature''s
    geometry information. By default it is `the_geom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`srsName:` The spatial reference system used in the requests. By default it
    is`"EPSG:4326".`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the vector layer uses an `OpenLayers.Strategy.BBOX` strategy, which
    is responsible to refresh the content of the layer every time the map's viewport
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many times the map server that supports WMS and WFS protocols, can serve the
    same information both in raster and vector formats.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a set of regions stored in PostgreSQL/PostGIS and a map server, such
    as GeoServer, with a layer of countries configured to be served both as raster
    images via WMS requests, or as vector GML format using WFS requests.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, if we have previously created an `OpenLayers.Layer.WMS` layer,
    there is an easy way to create a new WFS protocol instance with the static method
    `OpenLayers.Protocol.WFS.fromWMSLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a WMS layer and some options, the method initializes an `OpenLayers.Protocol.WFS`
    instance, supposing the WFS `url, srsName`, and other properties are the same
    as in the WMS instance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Filtering features in WFS requests* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with popups* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using point features as markers* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading features directly using Protocols* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the cluster strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the chapter's introduction, the behavior of vector layers
    is determined by the strategies we attach to them.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where we want to show all the museums in every city around
    the world. What will happen when the user navigates within the map and sets a
    zoom level to see the whole world? We simply see a cloud of points, all at the
    same place.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to cluster the features on each zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the cluster strategy](img/7843_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This recipe shows how easy it is to use the cluster strategy on a vector layer,
    which is responsible for clustering the features to avoid a situation similar
    to the one we just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and insert the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see the vector layer is using two strategies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A vector layer can have more than one strategy associated with it. In this
    recipe we have added the `OpenLayers.Strategy.Fixed` strategy, which loads the
    layer content only once, and the `OpenLayers.Strategy.Cluster` strategy, which
    automatically clusters the features to avoid an ugly cloud of features caused
    by overlapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Every time we change the zoom level, the cluster strategy computes the distance
    among all features and adds all the features that conform to some parameters of
    the same cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main parameters we can use to control the behavior of the cluster strategy
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distance:` The distance in pixels between features to be considered that they
    are in the same cluster. By default it is set to 20 pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threshold:` If the number of features in a cluster is less than the threshold,
    then they will be added directly to the layer instead of the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenLayers has a set of basic but very common strategies that we can combine
    in vector layers:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Box* strategy, to request features every time the map's viewport changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Refresh* strategy, to update the layer features periodically after some
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Filter* strategy to limit the features the layer must request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We encourage those more advanced JavaScript readers, to take a close look at
    the OpenLayers source code and learn more about how strategies work.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Creating features programmatically* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding features from a WFS server* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering features in WFS requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key concept when working against a WFS server is the concept of filters.
  prefs: []
  type: TYPE_NORMAL
- en: Among many other specifications, the OGC has defined a standard that defines
    the notation to be used for filtering, the *Filter Encoding Specification*.
  prefs: []
  type: TYPE_NORMAL
- en: Filters are similar to the `WHERE` clause in SQL and allow us to select features
    that meet some conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the Filter Encoding Specification on the OGC website available
    at [http://www.opengeospatial.org/standards/filter](http://www.opengeospatial.org/standards/filter).
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in [Chapter 7](ch07.html "Chapter 7. Styling Features"), *Styling
    Features*, filters are not only used to query features but are also used to define
    rules to style them.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenLayers offers a set of classes suited to work with the filters the specification
    defines: property filters `(PropertyIsEqualTo, PropertyIsLessThan`, and so on),
    logical filters, and spatial filters `(Intersects, Within`, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering features in WFS requests](img/7843_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This recipe shows a basic usage of the filter classes to restrict the features
    queried on a WFS server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to query a remote WFS server, so we will require a proxy script
    that was configured in our own server to make the real WFS request.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Adding features from a WFS server* recipe in this chapter for more
    information about proxy scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first step in the JavaScript code is to set the proxy script required to
    solve the cross domain request policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set OSM as the base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To center the map''s viewport in a concrete location we need to transform the
    desired location from latitude/longitude to the projection used by the base layer,
    that is, the projection used by the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a vector layer, which requests some states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main part of this recipe is the code involved in the instantiation of the
    vector layer. The constructor receives two parameters, the name and an options
    object. Within the options object we have set three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the protocol, strategies, and filter used in the layer.
    We are querying a WFS server, so we need to use an `OpenLayers.Protocol.WFS` instance
    to talk to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the same way as WMS, the WFS server has the `GetCapabilities` action, which
    allows the client to know the capabilities it provides: kind of features, available
    operations, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the response obtained from the server used in the recipe: [http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities](http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a strategy, we want the layer to refresh the features every time the map''s
    viewport is modified, so `OpenLayers.Strategy.BBOX` is the right instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a `filter` property, which performs all the magic in this
    recipe. We have tried to use a more or less complete filter, which includes one
    logical filter, one comparison filter, and one spatial filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the kind of filter, they can have different properties with different
    values allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Our filter queries for all states in the WFS server, on the specified layer,
    that are within the bounding box defined by `[-120, 10,-90,50]` and have a `MALE`
    population greater than `700,000`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OpenLayers.Protocol` class has a `defaultFilter` property, which allows
    us to set a default filter for the requests.
  prefs: []
  type: TYPE_NORMAL
- en: The filters specified in the vector layer, will be the logical AND operator,
    which is merged before making the request.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding features from a WFS server* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading features directly using Potocols* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading features directly using Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenLayers allows us to read data from different origins and sources. As we
    have described in the chapter''s introduction, OpenLayers offers the helper classes:
    protocols and formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols are designed to simplify the task of retrieving data from different
    origins: via HTTP, from an WFS server, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, formats simplifies the task of reading from (or writing to)
    a given data format. It is very common to load data from different origins and
    know how to work directly with protocols that can incredibly simplify this task.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading features directly using Protocols](img/7843_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As an example, this recipe shows how we can add features from different data
    sources in the same vector layer, by working directly with the protocol instances.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an HTML file and add the OpenLayers dependencies. Then create a `DOM`
    element to hold the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, initialize the map, add some base layer, and center the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two protocols pointing to the desired remote files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the callback function to be executed when the protocol instances
    load data from remote files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this recipe is to show how we can work directly with a protocol
    and load content from different data sources on the same vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this we have created an empty vector layer, without specifying the
    protocol and strategy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have created an `OpenLayers.Protocol.HTTP` instance that reads
    a remote `GeoJSON` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note how we can specify a callback function that will be called once the file
    is loaded and read it using the desired format. The function receives one parameter
    of type `OpenLayers.Protocol.Response`, which among others, contains a `features`
    array property with the set of features read from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the protocol start the reading process we simply need to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's take a look at the callback function. This function is called
    when both the protocols finish reading the data. We have implemented it to transform
    the features to the right projection and add to the vector layer only those of
    type `OpenLayers.Geometry.Point:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this is another way to filter the content we put in a vector
    layer, but take into account that the filtering is made on the client side and
    not on the server side. That means the entire data is transferred from the server
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We would like to mention that in this recipe we do not set the `OpenLayers.ProxyHost`
    variable. This is because the files we are requesting via AJAX are in the same
    domain the HTML file is loaded from.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Adding a GML layer* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding features from a WFS server* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Filtering features in WFS requests* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
