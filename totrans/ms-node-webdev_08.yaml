- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I describe the features that Node.js provides for testing and
    debugging JavaScript code. I begin by demonstrating the Node.js integrated test
    runner, which makes it easy to define and execute unit tests. I continue by demonstrating
    the Node.js debugger, which is integrated into the JavaScript runtime but used
    through external tools. *Table 8.1* puts testing and debugging in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.1: Putting testing and debugging in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What is it? | Unit testing is the process of defining and running tests that
    check the behavior of code. Debugging is the process of inspecting the state of
    the application as it is executed to determine the cause of unexpected or undesirable
    behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| Why is it useful? | Testing and debugging help identify problems in code
    before applications are deployed to real users. |'
  prefs: []
  type: TYPE_TB
- en: '| How is it used? | Unit tests are written in JavaScript code and executed
    using the integrated Node.js test runner. The Node.js runtime includes support
    for debugging, which is used through external tools, including popular code editors.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Differing views on how code should
    be tested often cause tension in development teams. Effort that could be spent
    completing the project is too often spent arguing about testing. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Testing and debugging are both optional activities.
    Both can help produce code with fewer defects, but neither is compulsory. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 8.2* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.2: Chapter Summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Create a unit test | Create a file with the `test.js` suffix and use the
    `test` function defined in the `node:test` module. | *3* |'
  prefs: []
  type: TYPE_TB
- en: '| Run unit tests | Use the `--test` argument to start Node.js in test mode.
    Use the `--watch` argument to run tests automatically when a change is detected.
    | *4-8* |'
  prefs: []
  type: TYPE_TB
- en: '| Create mocks | Use the `fn`, `method`, `getter`, or `setter` methods. | *9-10*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Understand how mocks are used | Use the spy features added to mocks. | *11*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Check the outcome of a test | Use the assertion functions in the `assert`
    module. | *12* |'
  prefs: []
  type: TYPE_TB
- en: '| Test asynchronous code | Create asynchronous mocks that produce test data.
    | *13-16* |'
  prefs: []
  type: TYPE_TB
- en: '| Testing different outcomes | Use subtests. | *17* |'
  prefs: []
  type: TYPE_TB
- en: '| Trigger the debugger | Use the `debugger` keyword or set breakpoints in the
    code editor. | *18-20* |'
  prefs: []
  type: TYPE_TB
- en: '| Debug an application | Use the features provided by popular code editors
    or browsers. | *21-22* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I continue to use the `webapp` project from *Chapter 7*. No
    changes are required to prepare for this chapter. Open a command prompt, navigate
    to the `webapp` folder, and run the command shown in *Listing 8.1* to start the
    build tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.1: Starting the build tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser, request `http://localhost:5000`, enter a message into the
    text field, and click the **Send Message** button. The client-side JavaScript
    code will send the contents of the `input` element to the backend server, which
    will pipe it back to the browser in the response, as shown in *Figure 8.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Running the example application'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing Node.js applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has a built-in test runner, which is a convenient way to define and
    run unit tests. As much as I recommend TypeScript for development, unit tests
    are best written in pure JavaScript. Unit testing requires extensive use of fake
    objects – known as *mocks* – to isolate the code being tested from the rest of
    the application, and the process of creating mocks – known as *mocking* – relies
    on creating objects that have just enough functionality to run a test, which can
    upset the TypeScript compiler. To prepare for pure JavaScript unit tests, *Listing
    8.2* changes the configuration for the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deciding Whether to Unit Test**'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to easily perform unit testing is one of the benefits of using Node.js,
    but it isn’t for everyone, and I have no intention of pretending otherwise. I
    like unit testing, and I use it in my projects, but not all of them, and not as
    consistently as you might expect. I tend to focus on writing unit tests for features
    and functions that I know will be hard to write and likely will be the source
    of bugs in deployment. In these situations, unit testing helps structure my thoughts
    about how to best implement what I need. I find that just thinking about what
    I need to test helps produce ideas about potential problems, and that’s before
    I start dealing with actual bugs and defects.
  prefs: []
  type: TYPE_NORMAL
- en: That said, unit testing is a tool and not a religion, and only you know how
    much testing you require. If you don’t find unit testing useful or you have a
    different methodology that suits you better, then don’t feel you need to unit
    test just because it is fashionable. (However, if you don’t have a better methodology
    and you are not testing at all, then you are probably letting users find your
    bugs, which is rarely ideal. You don’t have to unit test, but you really should
    consider doing some testing of some kind.)
  prefs: []
  type: TYPE_NORMAL
- en: If you have not encountered unit testing before, then I encourage you to give
    it a try to see how it works. If you are not a fan of unit testing, then you can
    skip this section and move on to the *Debugging JavaScript code* section, where
    I demonstrate how to use the Node.js debugging features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.2: Adding properties in the tsconfig.Json file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The new configuration properties tell the TypeScript compiler to process JavaScript
    as well as TypeScript files and specify that all of the source code files are
    in the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with testing, add a file named `readHandler.test.js` to the `src`
    folder with the contents shown in *Listing 8.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.3: The contents of the readHandler.test.js file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The testing functionality is provided in the `node:test` module, and the most
    important function is `test`, which is used to define a unit test. The `test`
    function accepts a name for the test and a function, which is executed to perform
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be executed from the command line. Open a new command prompt and run
    the command shown in *Listing 8.4* in the `webapp` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.4: Running unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `--test` argument executes the Node.js test runner. Test files are discovered
    automatically, either because the filename contains `test` or because files are
    in a folder named `test`. I followed the common convention of defining the tests
    for a module in a file that shares the module’s name but with the`.test.js` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript compiler will process the JavaScript file in the `src` folder
    and generate a file in the `dist` folder that contains the test code. The test
    runner will produce the following output, which may include additional characters,
    such as checkmarks, depending on your platform and command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The test doesn’t do anything yet, but the output shows the test runner has found
    the file and executed the function it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The test runner can also be run in watch mode, where it will run tests automatically
    when there is a file change. *Listing 8.5* adds a new command to the `scripts`
    section of the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Test Package**'
  prefs: []
  type: TYPE_NORMAL
- en: I have used the built-in Node.js test runner in this chapter because it is simple
    to use and does everything that most projects require. But there are good open-source
    test packages available; the most popular is Jest ([https://jestjs.io](https://jestjs.io)).
    A testing package can be useful if you have specialized testing needs or want
    to use the same package for testing the client- and server-side JavaScript code
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.5: Adding a command in the package.json file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `--watch` argument puts the test runner into watch mode. Run the command
    shown in *Listing 8.6* in the `webapp` folder to start the command defined in
    *Listing 8.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.6: Running the Test Runner in Watch Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The test runner will start, discover the test file in the `dist` file, and
    run the test it contains, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8.7* changes the name given to the test to confirm the test watch
    mode is working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.7: Changing the name in the readHandler.test.js file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main build process will detect the change to the JavaScript file in the
    `src` folder and create a corresponding file in the `dist` folder. The Node.js
    test runner will detect the change to the pure JavaScript file and execute its
    contents, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Node.js test runner considers tests to have passed if they complete without
    throwing an exception, which is why the test passes, even though it doesn’t do
    anything. *Listing 8.8* modifies the sample test so that it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.8: Creating a failing test in the readHandler.test.js file in the
    src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test runner executes the test, the exception is thrown and the failure
    is displayed in the console output, along with some details about the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Writing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common approach to writing unit tests is to follow the **arrange/act/assert**
    (**A/A/A**) pattern, which breaks unit tests into three parts. *Arrange* refers
    to setting up the conditions for the test, *act* refers to performing the test,
    and *assert* refers to verifying that the result was the one that was expected.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging a test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For web applications, the arrange section of a unit test usually means simulating
    an HTTP request and response to be able to test a request handler. As a reminder,
    here is the `readHandler` from the example project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler does two things: sets a cookie and invokes the `Request.pipe`
    method so that the body of the response is read from the body of the request.
    To test this functionality, the unit test needs a mock `Request` that has a `pipe`
    method and a `Response` that has a `cookie` method. The unit test doesn’t need
    to recreate the real functionality of the `pipe` and `cookie` methods because
    these are outside the scope of the code being tested. *Listing 8.9* uses the features
    provided by Node.js to create mock objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.9: Creating mock HTTP objects in the readHandler.test.ts file in
    the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A good mock object contains just enough functionality to run the test but also
    has to support inspecting the outcome. When the Node.js test runner invokes the
    test function, it provides a `TestContext` object, whose `mock` property returns
    a `MockTracker` object that can be used to create mocks, and whose most useful
    methods are described in *Table 8.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.3: Useful MockTracker Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| This method creates a mock function. The optional arguments are the original
    implementation of the function and a new implementation. If the arguments are
    omitted, a `no-op` function is returned. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| This method creates a mock method. The arguments are an object and the method
    name to mock. The optional argument is a replacement implementation of the method.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Similar to `method` but creates a getter. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Similar to `method` but creates a setter. |'
  prefs: []
  type: TYPE_TB
- en: The methods described in *Table 8.3* are used to create functions or methods
    that keep track of how they are used, which is useful in the assert part of the
    test, described in the *Asserting test results* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `method`, `getter`, and `setter` methods can create wrappers around existing
    functionality, as demonstrated in the *Testing asynchronous code* section. It
    is difficult to wrap the HTTP request and response methods and properties because
    of the way they are created and their dependency on so much of the Node.js API.
    Instead, the `fn` method can be used to create a function that tracks how it is
    used and provides a simple building block to create the features needed to test
    the handler. JavaScript functions can accept any number of arguments, which is
    how the function returned from the `fn` method can be used anywhere. This is one
    of the reasons why writing tests in TypeScript can be so difficult and why pure
    JavaScript should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For unit tests on HTTP handlers, performing the test is often the simplest part
    of the process, because it involves invoking the handler function with the mock
    HTTP request and response objects, as shown in *Listing 8.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.10: Performing the test in the readHandler.test.js file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Asserting test results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The methods in *Table 8.3* produce results that have a `mock` property that
    can be used to learn how a function or method was used when the test was performed.
    The `mock` property returns a `MockFunctionContext` object, whose most useful
    features are described in *Table 8.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.4: Useful MockFunctionContext Features'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This method returns the number of times the function or method has been called.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| This method returns an array of objects, where each element describes one
    call. |'
  prefs: []
  type: TYPE_TB
- en: The result from the `calls` property described in *Table 8.4* contains objects
    with the properties described in *Table 8.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.5: Useful Properties Used to Describe a Method or Function Call'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns an array of arguments that were passed to the function
    or method. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns the result produced by the function or method. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns an object if the function throws an error and `undefined`
    if it does not. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| This property returns an `Error` object that can be used to determine where
    an error was thrown. |'
  prefs: []
  type: TYPE_TB
- en: The mocked functions and methods act as spies that report on how they were used
    during the test, allowing the result to be easily inspected and assessed, as shown
    in *Listing 8.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.11: Assessing rest results in the readHandler.test.js file in the
    src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The new statements use the `mock` properties to confirm that the `pipe` and
    `cookie` methods have been called once and have received the correct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The assessment of test results can be simplified by using *assertions*, which
    are methods that perform comparisons and throw exceptions more concisely. Node.js
    provides assertions in the `assert` module and the most useful methods are described
    in *Table 8.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8.6: Useful Assertions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| This method throws an error if `val` isn’t truthy (as described in *Chapter
    2*). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| This method throws an error if `v1` doesn’t equal `v2`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| This method throws an error if `v1` equals `v2`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| This method performs a deep comparison of `v1` and `v2` and throws an error
    if they do not match. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| This method performs a deep comparison of `v1` and `v2` and throws an error
    if they match. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| This method throws an error if `str` isn’t matched by the specified regular
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| This method throws an error if `str` is matched by the specified regular
    expression. |'
  prefs: []
  type: TYPE_TB
- en: '*Listing 8.12* revises the unit test to use the assertions to check the results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.12: Using assertions in the readHandler.test.js file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `equal` method is used to make a series of comparisons and will throw an
    error that will cause the test to fail if the values do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js test runner has support for testing asynchronous code. For promise-based
    code, the test fails if the promise is rejected. To prepare, *Listing 8.13* changes
    the handler so that it performs an asynchronous file read and sends the file contents
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.13: Performing an asynchronous operation in the readHander.ts File
    in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Ignore the output from the test runner for the moment and check the handler
    works by using a browser to request [http://localhost:5000](http://localhost:5000)
    and clicking the **Send Message** button. The response will contain the JSON data
    read from the `data.json` file, as shown in *Figure 8.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Testing the revised handler'
  prefs: []
  type: TYPE_NORMAL
- en: To write the unit test, a different approach to mocking is required, as shown
    in *Listing 8.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.14: Testing an asynchronous handler in the readHandler.test.js file
    in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The key to this test is being able to mock the `readFile` function in the `fs`
    module, which is done by this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is difficult to explain because the name and the result use the same word:
    the method named `method` mocks a method on an object. In this case, the object
    is the entire `fs` module, which was imported like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The top-level functions defined by the module are presented as methods on an
    object named `fs`, which allows them to be mocked using `method`. In this case,
    the `readFile` function has been replaced with a mock implementation that invokes
    the callback function with test data, making it possible to perform the test without
    having to read from the file system. The other mocks in this example are created
    with the `fn` method and correspond to the `Response` methods that are called
    by the handler being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing code that uses promises is done in much the same way, except the mock
    resolves the promise with test data. *Listing 8.15* updates the handler to use
    the promise-based version of the `readFile` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.15: Using promises in the readHandler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8.16* updates the unit test so that the mock resolves a promise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.16: Testing a promise in the readHandler.test.js file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The mock is an asynchronous function that produces the test data when it resolves.
    The rest of the unit test is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subtests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test in *Listing 8.16* doesn’t test how the handler responds when there
    is a problem reading the data from the file. A little more work is required, as
    shown in *Listing 8.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.17: Testing multiple outcomes in the readHandler.test.js file in
    the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TestContext` class defines a `test` method that can be used to create
    subtests. Subtests receive their own context object that can be used to create
    mocks specific to that subtest and *Listing 8.17* uses this feature to create
    tests that use different implementations for the mock `readFile` function. Save
    the changes and the output from the test runner will reflect the addition of the
    subtests, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the subtests are asynchronous and require the `await` keyword. If
    you don’t wait for subtests, then the top-level test will be completed early,
    and the test runner will report an error.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging javascript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is the process of confirming code behaves as it should; debugging
    is the process of figuring out why it doesn’t. Before starting, use *Ctrl + C*
    to stop the build process and the unit-testing process. Once the processes have
    stopped, run the command shown in *Listing 8.18* to start the webpack development
    server on its own. The debugger will be applied to the backend server, which will
    be started on its own, but relies on webpack to handle requests for client-side
    content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.18: Starting the webpack development server'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to configure the TypeScript compiler so that it generates source
    maps, as shown in *Listing 8.19*, which lets the debugger correlate the pure JavaScript
    being executed by Node.js with the TypeScript code written by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.19: Enabling source maps in the tsconfig.json file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When you save the file, the compiler will start generating files with the `map`
    file extension in the `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code editors that have good TypeScript support, such as Visual Studio Code,
    allow breakpoints to be added to code files. My experience with this feature has
    been mixed, and I have found them unreliable, which is why I rely on the less
    elegant but more predictable `debugger` JavaScript keyword.
  prefs: []
  type: TYPE_NORMAL
- en: When a JavaScript application is executed through a debugger, execution halts
    when the `debugger` keyword is encountered, and control is passed to the developer.
    *Listing 8.20* adds the `debugger` keyword to the `readHandler.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.20: Adding the debugger keyword in the readHandler.ts file in the
    src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There will be no change in the output when the code is executed because Node.js
    ignores the `debugger` keyword by default.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio Code for debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most good code editors have some degree of support for debugging TypeScript
    and JavaScript code. In this section, I will show you how to perform debugging
    with Visual Studio Code to give you an idea of the process. There may be different
    steps required if you use another editor, but the basic approach is likely to
    be similar.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the configuration for debugging, select **Add Configuration** from
    the **Run** menu and select **Node.js** from the list of environments when prompted,
    as shown in *Figure 8.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Selecting the debugging environment'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code will create a `.vscode` folder and a file called `launch.json`,
    which is used to configure the debugger. Change the value of the `program` property
    so that the debugger executes the JavaScript code in the `dist` folder, as shown
    in *Listing 8.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.21: Configuring the debugger in the launch.json file in the .vscode
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Save the changes to the `launch.json` file and select **Start Debugging** from
    the **Run** menu. Visual Studio Code will start Node.js and execution will continue
    as normal until the `debugger` keyword is reached. Use a browser to request `http://localhost:5000`
    and click the **Send Message** button. The request will be passed to the handler
    for processing, and when the `debugger` keyword is reached, execution will be
    halted and control will be transferred to the debugging popup, as shown in *Figure
    8.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Debugging with Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: The state of the application is displayed in the sidebar, showing the variables
    that are set at the point that execution was halted. Standard debugging features
    are available, including setting watches, stepping into and over statements, and
    resuming execution. The **Debug Console** window allows JavaScript statements
    to be executed in the context of the application so that entering a variable name
    and pressing *Return*, for example, will return the value assigned to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the remote Node.js debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t want to use the code editor for debugging, then Google Chrome provides
    good integrated debugging for Node.js, using the same features that are used to
    debug client-side code. Stop the Visual Studio Code debugger from the previous
    section and run the command shown in *Listing 8.22* in the `webapp` folder to
    start Node.js in debugging mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 8.22: Starting Node.js in debugging mode'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When Node.js starts, it will produce messages like these, which include details
    of the URL on which it is ready to accept debugging requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using Google Chrome, request `chrome://inspect` and click on the **Open Dedicated
    DevTools for Node** option and the debugging window will open, as shown in *Figure
    8.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All of the browsers that use the Chromium engine support this feature, including
    Brave, Opera, and Edge. Use the name of the browser for the URL that opens the
    Node.js tools, such as `brave://inspect` for the Brave browser. This doesn’t work
    for Firefox, which has its own browser engine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Using the chrome node.Js debugging features'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new browser window, request `http://localhost:5000`, and click **Send
    Message**. As the request is being processed, Node.js reaches the `debugger` keyword.
    Execution is halted and control is passed to the Chrome developer tools, as shown
    in *Figure 8.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The Chrome developer tools debugging Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I described the Node.js features for unit testing and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js includes a built-in test runner, with support for executing tests and
    creating mock functions and methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests for web applications focus on request handling and require mocks
    of HTTP requests and responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party packages, such as Jest, can be used for projects that require the
    same test tools for client- and server-side JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js includes support for debugging, which can be performed with many code
    editors or with one of the Chromium-based browsers, such as Google Chrome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next part of this book, I demonstrate how Node.js can be used to create
    the features required for web applications, such as generating dynamic content
    and authenticating users.
  prefs: []
  type: TYPE_NORMAL
