- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Unit Testing and Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和调试
- en: In this chapter, I describe the features that Node.js provides for testing and
    debugging JavaScript code. I begin by demonstrating the Node.js integrated test
    runner, which makes it easy to define and execute unit tests. I continue by demonstrating
    the Node.js debugger, which is integrated into the JavaScript runtime but used
    through external tools. *Table 8.1* puts testing and debugging in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了Node.js提供的用于测试和调试JavaScript代码的功能。我首先演示了Node.js集成测试运行器，它使得定义和执行单元测试变得容易。然后，我演示了Node.js调试器，它集成在JavaScript运行时中，但通过外部工具使用。*表8.1*
    将测试和调试置于上下文中。
- en: 'Table 8.1: Putting testing and debugging in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：将测试和调试置于上下文中
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What is it? | Unit testing is the process of defining and running tests that
    check the behavior of code. Debugging is the process of inspecting the state of
    the application as it is executed to determine the cause of unexpected or undesirable
    behavior. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它是什么？ | 单元测试是定义和运行测试以检查代码行为的过程。调试是检查应用程序执行状态的过程，以确定意外或不希望的行为的原因。 |'
- en: '| Why is it useful? | Testing and debugging help identify problems in code
    before applications are deployed to real users. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它有用？ | 测试和调试有助于在应用程序部署给真实用户之前识别代码中的问题。 |'
- en: '| How is it used? | Unit tests are written in JavaScript code and executed
    using the integrated Node.js test runner. The Node.js runtime includes support
    for debugging, which is used through external tools, including popular code editors.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用？ | 单元测试是用JavaScript代码编写的，并使用集成的Node.js测试运行器执行。Node.js运行时包括对调试的支持，这通过外部工具使用，包括流行的代码编辑器。
    |'
- en: '| Are there any pitfalls or limitations? | Differing views on how code should
    be tested often cause tension in development teams. Effort that could be spent
    completing the project is too often spent arguing about testing. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 对代码应该如何测试的不同观点往往会导致开发团队中的紧张关系。本可以用来完成项目的努力，往往被花费在争论测试上。 |'
- en: '| Are there any alternatives? | Testing and debugging are both optional activities.
    Both can help produce code with fewer defects, but neither is compulsory. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 测试和调试都是可选活动。两者都可以帮助产生缺陷更少的代码，但都不是强制性的。 |'
- en: '*Table 8.2* summarizes the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表8.2* 总结了本章内容。'
- en: 'Table 8.2: Chapter Summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2：本章总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Create a unit test | Create a file with the `test.js` suffix and use the
    `test` function defined in the `node:test` module. | *3* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 创建单元测试 | 创建一个以`test.js`后缀的文件，并使用`node:test`模块中定义的`test`函数。 | *3* |'
- en: '| Run unit tests | Use the `--test` argument to start Node.js in test mode.
    Use the `--watch` argument to run tests automatically when a change is detected.
    | *4-8* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 运行单元测试 | 使用`--test`参数以测试模式启动Node.js。使用`--watch`参数在检测到更改时自动运行测试。 | *4-8* |'
- en: '| Create mocks | Use the `fn`, `method`, `getter`, or `setter` methods. | *9-10*
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 创建模拟 | 使用`fn`、`method`、`getter`或`setter`方法。 | *9-10* |'
- en: '| Understand how mocks are used | Use the spy features added to mocks. | *11*
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 理解模拟的使用 | 使用添加到模拟中的间谍功能。 | *11* |'
- en: '| Check the outcome of a test | Use the assertion functions in the `assert`
    module. | *12* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 检查测试结果 | 使用`assert`模块中的断言函数。 | *12* |'
- en: '| Test asynchronous code | Create asynchronous mocks that produce test data.
    | *13-16* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 测试异步代码 | 创建产生测试数据的异步模拟。 | *13-16* |'
- en: '| Testing different outcomes | Use subtests. | *17* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 测试不同的结果 | 使用子测试。 | *17* |'
- en: '| Trigger the debugger | Use the `debugger` keyword or set breakpoints in the
    code editor. | *18-20* |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 触发调试器 | 使用`debugger`关键字或在代码编辑器中设置断点。 | *18-20* |'
- en: '| Debug an application | Use the features provided by popular code editors
    or browsers. | *21-22* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 调试应用程序 | 使用流行的代码编辑器或浏览器提供的功能。 | *21-22* |'
- en: Preparing for this chapter
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: In this chapter, I continue to use the `webapp` project from *Chapter 7*. No
    changes are required to prepare for this chapter. Open a command prompt, navigate
    to the `webapp` folder, and run the command shown in *Listing 8.1* to start the
    build tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我继续使用*第7章*中的`webapp`项目。为准备本章不需要进行任何更改。打开命令提示符，导航到`webapp`文件夹，并运行*列表8.1*中显示的命令以启动构建工具。
- en: 'Listing 8.1: Starting the build tools'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1：启动构建工具
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open a web browser, request `http://localhost:5000`, enter a message into the
    text field, and click the **Send Message** button. The client-side JavaScript
    code will send the contents of the `input` element to the backend server, which
    will pipe it back to the browser in the response, as shown in *Figure 8.1*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器，请求`http://localhost:5000`，在文本框中输入一条消息，然后点击**发送消息**按钮。客户端JavaScript代码会将`input`元素的
    内容发送到后端服务器，服务器会将它作为响应管道回浏览器，如图*图8.1*所示。
- en: '**Tip**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)下载本章的示例项目——以及本书中所有其他章节的示例项目。有关运行示例时遇到问题的帮助，请参阅*第1章*。
- en: '![](img/B21959_08_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_08_01.png)'
- en: 'Figure 8.1: Running the example application'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：运行示例应用程序
- en: Unit testing Node.js applications
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Node.js应用程序
- en: Node.js has a built-in test runner, which is a convenient way to define and
    run unit tests. As much as I recommend TypeScript for development, unit tests
    are best written in pure JavaScript. Unit testing requires extensive use of fake
    objects – known as *mocks* – to isolate the code being tested from the rest of
    the application, and the process of creating mocks – known as *mocking* – relies
    on creating objects that have just enough functionality to run a test, which can
    upset the TypeScript compiler. To prepare for pure JavaScript unit tests, *Listing
    8.2* changes the configuration for the TypeScript compiler.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个内置的测试运行器，这是一种方便的方式来定义和运行单元测试。尽管我推荐TypeScript进行开发，但单元测试最好用纯JavaScript编写。单元测试需要广泛使用假对象——称为*模拟*——来隔离正在测试的代码与应用程序的其他部分，创建模拟的过程——称为*模拟化*——依赖于创建仅具有足够功能来运行测试的对象，这可能会影响TypeScript编译器。为了准备纯JavaScript单元测试，*列表8.2*更改了TypeScript编译器的配置。
- en: '**Deciding Whether to Unit Test**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**决定是否进行单元测试**'
- en: Being able to easily perform unit testing is one of the benefits of using Node.js,
    but it isn’t for everyone, and I have no intention of pretending otherwise. I
    like unit testing, and I use it in my projects, but not all of them, and not as
    consistently as you might expect. I tend to focus on writing unit tests for features
    and functions that I know will be hard to write and likely will be the source
    of bugs in deployment. In these situations, unit testing helps structure my thoughts
    about how to best implement what I need. I find that just thinking about what
    I need to test helps produce ideas about potential problems, and that’s before
    I start dealing with actual bugs and defects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地进行单元测试是使用Node.js的一个好处，但这并不是每个人都需要的，我也没有假装不是这样。我喜欢单元测试，并在我的项目中使用它，但并不是所有的项目，而且并不像你期望的那样一致。我倾向于专注于编写那些我知道将很难编写并且很可能是部署中错误来源的功能和函数的单元测试。在这些情况下，单元测试帮助我组织关于如何最好实现我所需要的想法。我发现，仅仅思考我需要测试的内容就能产生关于潜在问题的想法，这在我开始处理实际的错误和缺陷之前就已经发生了。
- en: That said, unit testing is a tool and not a religion, and only you know how
    much testing you require. If you don’t find unit testing useful or you have a
    different methodology that suits you better, then don’t feel you need to unit
    test just because it is fashionable. (However, if you don’t have a better methodology
    and you are not testing at all, then you are probably letting users find your
    bugs, which is rarely ideal. You don’t have to unit test, but you really should
    consider doing some testing of some kind.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，单元测试是一个工具，而不是一种信仰，只有你自己才知道你需要多少测试。如果你觉得单元测试没有用，或者你有更适合你的不同方法，那么请不要因为它是时尚的而觉得你需要进行单元测试。（然而，如果你没有更好的方法，而且你根本不做测试，那么你很可能是让用户发现你的错误，这很少是理想的。你不必进行单元测试，但你确实应该考虑进行某种形式的测试。）
- en: If you have not encountered unit testing before, then I encourage you to give
    it a try to see how it works. If you are not a fan of unit testing, then you can
    skip this section and move on to the *Debugging JavaScript code* section, where
    I demonstrate how to use the Node.js debugging features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有遇到过单元测试，那么我鼓励您尝试一下，看看它是如何工作的。如果您不是单元测试的粉丝，那么您可以跳过这一部分，转到*调试JavaScript代码*部分，在那里我将演示如何使用Node.js的调试功能。
- en: 'Listing 8.2: Adding properties in the tsconfig.Json file in the webapp folder'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2：在webapp文件夹中的tsconfig.Json文件中添加属性
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The new configuration properties tell the TypeScript compiler to process JavaScript
    as well as TypeScript files and specify that all of the source code files are
    in the `src` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新的配置属性告诉 TypeScript 编译器处理 JavaScript 以及 TypeScript 文件，并指定所有源代码文件都在 `src` 文件夹中。
- en: To get started with testing, add a file named `readHandler.test.js` to the `src`
    folder with the contents shown in *Listing 8.3*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试，请将名为 `readHandler.test.js` 的文件添加到 `src` 文件夹中，其内容如 *清单 8.3* 所示。
- en: 'Listing 8.3: The contents of the readHandler.test.js file in the src folder'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.3*：`src` 文件夹中 readHandler.test.js 文件的 内容'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The testing functionality is provided in the `node:test` module, and the most
    important function is `test`, which is used to define a unit test. The `test`
    function accepts a name for the test and a function, which is executed to perform
    the test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测试功能由 `node:test` 模块提供，其中最重要的函数是 `test`，用于定义单元测试。`test` 函数接受测试的名称和一个函数，该函数执行测试。
- en: Tests can be executed from the command line. Open a new command prompt and run
    the command shown in *Listing 8.4* in the `webapp` folder.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以从命令行执行。打开一个新的命令提示符，并在 `webapp` 文件夹中运行 *清单 8.4* 中显示的命令。
- en: 'Listing 8.4: Running unit tests'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.4*：运行单元测试'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `--test` argument executes the Node.js test runner. Test files are discovered
    automatically, either because the filename contains `test` or because files are
    in a folder named `test`. I followed the common convention of defining the tests
    for a module in a file that shares the module’s name but with the`.test.js` suffix.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`--test` 参数执行 Node.js 测试运行器。测试文件会自动发现，要么因为文件名包含 `test`，要么因为文件位于名为 `test` 的文件夹中。我遵循了在具有
    `.test.js` 后缀的与模块同名的文件中定义模块测试的通用约定。'
- en: 'The TypeScript compiler will process the JavaScript file in the `src` folder
    and generate a file in the `dist` folder that contains the test code. The test
    runner will produce the following output, which may include additional characters,
    such as checkmarks, depending on your platform and command line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器将处理 `src` 文件夹中的 JavaScript 文件，并在 `dist` 文件夹中生成包含测试代码的文件。测试运行器将生成以下输出，这可能会根据您的平台和命令行包括额外的字符，例如勾选标记：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test doesn’t do anything yet, but the output shows the test runner has found
    the file and executed the function it contains.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目前还没有做任何事情，但输出显示测试运行器已找到文件并执行了其中包含的函数。
- en: The test runner can also be run in watch mode, where it will run tests automatically
    when there is a file change. *Listing 8.5* adds a new command to the `scripts`
    section of the `package.json` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器也可以在监视模式下运行，当文件发生变化时，它会自动运行测试。*清单 8.5* 向 `package.json` 文件的 `scripts` 部分添加了一个新命令。
- en: '**Using a Test Package**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用测试包**'
- en: I have used the built-in Node.js test runner in this chapter because it is simple
    to use and does everything that most projects require. But there are good open-source
    test packages available; the most popular is Jest ([https://jestjs.io](https://jestjs.io)).
    A testing package can be useful if you have specialized testing needs or want
    to use the same package for testing the client- and server-side JavaScript code
    in your projects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中使用了内置的 Node.js 测试运行器，因为它易于使用，并且可以满足大多数项目的需求。但还有许多优秀的开源测试包可用；最受欢迎的是 Jest
    ([https://jestjs.io](https://jestjs.io))。如果您有特殊的测试需求或希望为项目中的客户端和服务器端 JavaScript
    代码使用相同的测试包，测试包可能很有用。
- en: 'Listing 8.5: Adding a command in the package.json file in the webapp folder'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.5*：在 `webapp` 文件夹中的 package.json 文件中添加命令'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `--watch` argument puts the test runner into watch mode. Run the command
    shown in *Listing 8.6* in the `webapp` folder to start the command defined in
    *Listing 8.5*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`--watch` 参数将测试运行器置于监视模式。在 `webapp` 文件夹中运行 *清单 8.6* 中显示的命令以启动 *清单 8.5* 中定义的命令。'
- en: 'Listing 8.6: Running the Test Runner in Watch Mode'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.6*：在监视模式下运行测试运行器'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The test runner will start, discover the test file in the `dist` file, and
    run the test it contains, producing the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器将启动，在 `dist` 文件夹中找到测试文件，并运行其中包含的测试，生成以下输出：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8.7* changes the name given to the test to confirm the test watch
    mode is working.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.7* 将测试的名称更改，以确认测试监视模式正在工作。'
- en: 'Listing 8.7: Changing the name in the readHandler.test.js file in the src folder'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8.7*：在 `src` 文件夹中的 readHandler.test.js 文件中更改名称'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main build process will detect the change to the JavaScript file in the
    `src` folder and create a corresponding file in the `dist` folder. The Node.js
    test runner will detect the change to the pure JavaScript file and execute its
    contents, producing the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构建过程将检测`src`文件夹中JavaScript文件的变化，并在`dist`文件夹中创建相应的文件。Node.js测试运行器将检测纯JavaScript文件的变化，并执行其内容，产生以下输出：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Node.js test runner considers tests to have passed if they complete without
    throwing an exception, which is why the test passes, even though it doesn’t do
    anything. *Listing 8.8* modifies the sample test so that it fails.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js测试运行器认为，如果测试完成而没有抛出异常，则测试通过，这就是为什么即使它没有做任何事情，测试也会通过。"列表8.8"修改了示例测试，使其失败。
- en: 'Listing 8.8: Creating a failing test in the readHandler.test.js file in the
    src folder'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8：在src文件夹中的readHandler.test.js文件中创建失败的测试
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the test runner executes the test, the exception is thrown and the failure
    is displayed in the console output, along with some details about the exception:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行器执行测试时，会抛出异常，并在控制台输出中显示失败，以及有关异常的一些详细信息：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Writing unit tests
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: A common approach to writing unit tests is to follow the **arrange/act/assert**
    (**A/A/A**) pattern, which breaks unit tests into three parts. *Arrange* refers
    to setting up the conditions for the test, *act* refers to performing the test,
    and *assert* refers to verifying that the result was the one that was expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试的常见方法是从**arrange/act/assert**（**A/A/A**）模式开始，将单元测试分为三个部分。"Arrange"指的是为测试设置条件，"act"指的是执行测试，"assert"指的是验证结果是否符合预期。
- en: Arranging a test
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安排测试
- en: 'For web applications, the arrange section of a unit test usually means simulating
    an HTTP request and response to be able to test a request handler. As a reminder,
    here is the `readHandler` from the example project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，单元测试的安排部分通常意味着模拟HTTP请求和响应，以便能够测试请求处理器。作为提醒，以下是示例项目中的`readHandler`：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This handler does two things: sets a cookie and invokes the `Request.pipe`
    method so that the body of the response is read from the body of the request.
    To test this functionality, the unit test needs a mock `Request` that has a `pipe`
    method and a `Response` that has a `cookie` method. The unit test doesn’t need
    to recreate the real functionality of the `pipe` and `cookie` methods because
    these are outside the scope of the code being tested. *Listing 8.9* uses the features
    provided by Node.js to create mock objects.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序执行两项操作：设置cookie并调用`Request.pipe`方法，以便从请求体中读取响应体。为了测试此功能，单元测试需要一个具有`pipe`方法和一个具有`cookie`方法的模拟`Request`和一个`Response`。单元测试不需要重新创建`pipe`和`cookie`方法的实际功能，因为这些功能超出了正在测试的代码的作用域。"列表8.9"使用Node.js提供的功能创建模拟对象。
- en: 'Listing 8.9: Creating mock HTTP objects in the readHandler.test.ts file in
    the src folder'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9：在src文件夹中的readHandler.test.ts文件中创建模拟HTTP对象
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A good mock object contains just enough functionality to run the test but also
    has to support inspecting the outcome. When the Node.js test runner invokes the
    test function, it provides a `TestContext` object, whose `mock` property returns
    a `MockTracker` object that can be used to create mocks, and whose most useful
    methods are described in *Table 8.3*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模拟对象应包含足够的功能来运行测试，同时还需要支持检查结果。当Node.js测试运行器调用测试函数时，它提供了一个`TestContext`对象，其`mock`属性返回一个`MockTracker`对象，可以用来创建模拟，其最有用的方法在"表8.3"中描述。
- en: 'Table 8.3: Useful MockTracker Methods'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.3：有用的MockTracker方法
- en: '| Name | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| This method creates a mock function. The optional arguments are the original
    implementation of the function and a new implementation. If the arguments are
    omitted, a `no-op` function is returned. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 此方法创建一个模拟函数。可选参数是函数的原始实现和新实现。如果省略参数，则返回一个`no-op`函数。 |'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| This method creates a mock method. The arguments are an object and the method
    name to mock. The optional argument is a replacement implementation of the method.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 此方法创建一个模拟方法。参数是一个对象和要模拟的方法名称。可选参数是方法的替换实现。 |'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| Similar to `method` but creates a getter. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 与`method`类似，但创建一个getter。 |'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Similar to `method` but creates a setter. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 与`method`类似，但创建一个setter。 |'
- en: The methods described in *Table 8.3* are used to create functions or methods
    that keep track of how they are used, which is useful in the assert part of the
    test, described in the *Asserting test results* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*表8.3* 中描述的方法用于创建跟踪其使用情况的函数或方法，这在测试的断言部分很有用，如*断言测试结果*部分所述。'
- en: The `method`, `getter`, and `setter` methods can create wrappers around existing
    functionality, as demonstrated in the *Testing asynchronous code* section. It
    is difficult to wrap the HTTP request and response methods and properties because
    of the way they are created and their dependency on so much of the Node.js API.
    Instead, the `fn` method can be used to create a function that tracks how it is
    used and provides a simple building block to create the features needed to test
    the handler. JavaScript functions can accept any number of arguments, which is
    how the function returned from the `fn` method can be used anywhere. This is one
    of the reasons why writing tests in TypeScript can be so difficult and why pure
    JavaScript should be used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`method`、`getter`和`setter`方法可以围绕现有功能创建包装器，如*测试异步代码*部分所示。由于它们创建的方式以及它们对Node.js
    API的依赖性，很难包装HTTP请求和响应方法和属性。相反，可以使用`fn`方法创建一个跟踪其使用情况并提供创建测试所需功能的简单构建块的功能。JavaScript函数可以接受任意数量的参数，这就是为什么从`fn`方法返回的函数可以在任何地方使用的原因。这也是为什么在TypeScript中编写测试可能如此困难，以及为什么应该使用纯JavaScript的原因。'
- en: Performing a test
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行测试
- en: For unit tests on HTTP handlers, performing the test is often the simplest part
    of the process, because it involves invoking the handler function with the mock
    HTTP request and response objects, as shown in *Listing 8.10*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP处理器的单元测试，执行测试通常是过程中最简单的部分，因为它涉及使用模拟的HTTP请求和响应对象调用处理器函数，如*列表8.10*所示。
- en: 'Listing 8.10: Performing the test in the readHandler.test.js file in the src
    folder'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10：在src文件夹中的readHandler.test.js文件中执行测试
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Asserting test results
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言测试结果
- en: The methods in *Table 8.3* produce results that have a `mock` property that
    can be used to learn how a function or method was used when the test was performed.
    The `mock` property returns a `MockFunctionContext` object, whose most useful
    features are described in *Table 8.4*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*表8.3* 中的方法产生具有`mock`属性的结果，该属性可用于了解在执行测试时函数或方法是如何被使用的。`mock`属性返回一个`MockFunctionContext`对象，其中最有用的功能在*表8.4*中描述。'
- en: 'Table 8.4: Useful MockFunctionContext Features'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.4：有用的MockFunctionContext功能
- en: '| Name | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This method returns the number of times the function or method has been called.
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 此方法返回函数或方法被调用的次数。 |'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| This method returns an array of objects, where each element describes one
    call. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 此方法返回一个对象数组，其中每个元素描述一次调用。 |'
- en: The result from the `calls` property described in *Table 8.4* contains objects
    with the properties described in *Table 8.5*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*表8.4* 中描述的`calls`属性的输出包含具有*表8.5*中描述的属性的对象。'
- en: 'Table 8.5: Useful Properties Used to Describe a Method or Function Call'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.5：用于描述方法或函数调用的有用属性
- en: '| Name | Description |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| This property returns an array of arguments that were passed to the function
    or method. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 该属性返回传递给函数或方法的参数数组。 |'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| This property returns the result produced by the function or method. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 该属性返回函数或方法产生的结果。 |'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| This property returns an object if the function throws an error and `undefined`
    if it does not. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 此属性返回一个对象，如果函数抛出错误，则返回`undefined`。 |'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| This property returns an `Error` object that can be used to determine where
    an error was thrown. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 此属性返回一个`Error`对象，可用于确定错误抛出的位置。 |'
- en: The mocked functions and methods act as spies that report on how they were used
    during the test, allowing the result to be easily inspected and assessed, as shown
    in *Listing 8.11*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 被模拟的函数和方法充当间谍，报告它们在测试期间的使用情况，使得结果可以轻松检查和评估，如*列表8.11*所示。
- en: 'Listing 8.11: Assessing rest results in the readHandler.test.js file in the
    src folder'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11：在src文件夹中的readHandler.test.js文件中评估rest结果
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new statements use the `mock` properties to confirm that the `pipe` and
    `cookie` methods have been called once and have received the correct arguments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语句使用`mock`属性来确认`pipe`和`cookie`方法已被调用一次，并且接收到了正确的参数。
- en: The assessment of test results can be simplified by using *assertions*, which
    are methods that perform comparisons and throw exceptions more concisely. Node.js
    provides assertions in the `assert` module and the most useful methods are described
    in *Table 8.6*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*断言*可以简化测试结果的评估，这些断言是执行比较并抛出异常的更简洁的方法。Node.js在`assert`模块中提供了断言，其中最有用的方法在*表8.6*中描述。
- en: 'Table 8.6: Useful Assertions'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.6：有用的断言
- en: '| Name | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| This method throws an error if `val` isn’t truthy (as described in *Chapter
    2*). |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 此方法如果`val`不是真值（如*第2章*所述），则会抛出错误。 |'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| This method throws an error if `v1` doesn’t equal `v2`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 此方法如果`v1`不等于`v2`，则会抛出错误。 |'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| This method throws an error if `v1` equals `v2`. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 此方法如果`v1`等于`v2`，则会抛出错误。 |'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| This method performs a deep comparison of `v1` and `v2` and throws an error
    if they do not match. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 此方法对`v1`和`v2`进行深度比较，如果它们不匹配，则会抛出错误。 |'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| This method performs a deep comparison of `v1` and `v2` and throws an error
    if they match. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 此方法对`v1`和`v2`进行深度比较，如果它们匹配，则会抛出错误。 |'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| This method throws an error if `str` isn’t matched by the specified regular
    expression. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 此方法如果`str`不匹配指定的正则表达式，则会抛出错误。 |'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This method throws an error if `str` is matched by the specified regular
    expression. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 此方法如果`str`匹配指定的正则表达式，则会抛出错误。 |'
- en: '*Listing 8.12* revises the unit test to use the assertions to check the results.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表8.12*修改了单元测试，使用断言来检查结果。'
- en: 'Listing 8.12: Using assertions in the readHandler.test.js file in the src folder'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12：在src文件夹中的readHandler.test.js文件中使用断言
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `equal` method is used to make a series of comparisons and will throw an
    error that will cause the test to fail if the values do not match.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal`方法用于进行一系列比较，如果值不匹配，则会抛出错误，导致测试失败。'
- en: Testing asynchronous code
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: The Node.js test runner has support for testing asynchronous code. For promise-based
    code, the test fails if the promise is rejected. To prepare, *Listing 8.13* changes
    the handler so that it performs an asynchronous file read and sends the file contents
    to the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js测试运行器支持测试异步代码。对于基于promise的代码，如果promise被拒绝，则测试失败。为了准备，*列表8.13*更改了处理器，使其执行异步文件读取并将文件内容发送到客户端。
- en: 'Listing 8.13: Performing an asynchronous operation in the readHander.ts File
    in the src folder'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13：在src文件夹中的readHander.ts文件中执行异步操作
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Ignore the output from the test runner for the moment and check the handler
    works by using a browser to request [http://localhost:5000](http://localhost:5000)
    and clicking the **Send Message** button. The response will contain the JSON data
    read from the `data.json` file, as shown in *Figure 8.2*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前忽略测试运行器的输出，并使用浏览器请求[http://localhost:5000](http://localhost:5000)并点击**发送消息**按钮来检查处理器的功能。响应将包含从`data.json`文件中读取的JSON数据，如图*图8.2*所示。
- en: '![](img/B21959_08_02.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_08_02.png)'
- en: 'Figure 8.2: Testing the revised handler'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：测试修改后的处理器
- en: To write the unit test, a different approach to mocking is required, as shown
    in *Listing 8.14*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试时，需要采用不同的模拟方法，如*列表8.14*所示。
- en: 'Listing 8.14: Testing an asynchronous handler in the readHandler.test.js file
    in the src folder'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14：在src文件夹中的readHandler.test.js文件中测试异步处理器
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The key to this test is being able to mock the `readFile` function in the `fs`
    module, which is done by this statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试的关键是能够模拟`fs`模块中的`readFile`函数，这是通过以下语句完成的：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is difficult to explain because the name and the result use the same word:
    the method named `method` mocks a method on an object. In this case, the object
    is the entire `fs` module, which was imported like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这很难解释，因为名称和结果使用了相同的单词：名为`method`的方法模拟了一个对象上的方法。在这种情况下，对象是整个`fs`模块，它被导入如下：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The top-level functions defined by the module are presented as methods on an
    object named `fs`, which allows them to be mocked using `method`. In this case,
    the `readFile` function has been replaced with a mock implementation that invokes
    the callback function with test data, making it possible to perform the test without
    having to read from the file system. The other mocks in this example are created
    with the `fn` method and correspond to the `Response` methods that are called
    by the handler being tested.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义的顶层函数作为名为 `fs` 的对象上的方法呈现，这使得它们可以通过 `method` 来模拟。在这种情况下，`readFile` 函数已被替换为一个模拟实现，该实现使用测试数据调用回调函数，使得可以在不读取文件系统的情况下执行测试。本例中的其他模拟是通过
    `fn` 方法创建的，对应于被测试的处理程序调用的 `Response` 方法。
- en: Testing promises
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试承诺
- en: Testing code that uses promises is done in much the same way, except the mock
    resolves the promise with test data. *Listing 8.15* updates the handler to use
    the promise-based version of the `readFile` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用承诺的代码的方式几乎相同，只是模拟使用测试数据解决承诺。*列表 8.15* 更新了处理程序，以使用基于承诺的 `readFile` 函数版本。
- en: 'Listing 8.15: Using promises in the readHandler.ts file in the src folder'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15：在 src 文件夹中的 readHandler.ts 文件中使用承诺
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 8.16* updates the unit test so that the mock resolves a promise.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8.16* 更新了单元测试，以便模拟解决承诺。'
- en: 'Listing 8.16: Testing a promise in the readHandler.test.js file in the src
    folder'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16：在 src 文件夹中的 readHandler.test.js 文件中测试承诺
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The mock is an asynchronous function that produces the test data when it resolves.
    The rest of the unit test is unchanged.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一个异步函数，在解决时产生测试数据。单元测试的其余部分保持不变。
- en: Creating subtests
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子测试
- en: The test in *Listing 8.16* doesn’t test how the handler responds when there
    is a problem reading the data from the file. A little more work is required, as
    shown in *Listing 8.17*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8.16* 中的测试没有测试处理程序在读取文件数据时出现问题时如何响应。需要做更多的工作，如 *列表 8.17* 所示。'
- en: 'Listing 8.17: Testing multiple outcomes in the readHandler.test.js file in
    the src folder'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17：在 src 文件夹中的 readHandler.test.js 文件中测试多个结果
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `TestContext` class defines a `test` method that can be used to create
    subtests. Subtests receive their own context object that can be used to create
    mocks specific to that subtest and *Listing 8.17* uses this feature to create
    tests that use different implementations for the mock `readFile` function. Save
    the changes and the output from the test runner will reflect the addition of the
    subtests, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestContext` 类定义了一个 `test` 方法，可以用来创建子测试。子测试会接收到自己的上下文对象，可以用来为该子测试创建特定的模拟，*列表
    8.17* 就使用了这个特性来创建使用不同实现的模拟 `readFile` 函数的测试。保存更改后，测试运行器的输出将反映子测试的添加，如下所示：'
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that the subtests are asynchronous and require the `await` keyword. If
    you don’t wait for subtests, then the top-level test will be completed early,
    and the test runner will report an error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到子测试是异步的，需要 `await` 关键字。如果您不等待子测试，则顶层测试将提前完成，测试运行器将报告错误。
- en: Debugging javascript code
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 JavaScript 代码
- en: Unit testing is the process of confirming code behaves as it should; debugging
    is the process of figuring out why it doesn’t. Before starting, use *Ctrl + C*
    to stop the build process and the unit-testing process. Once the processes have
    stopped, run the command shown in *Listing 8.18* to start the webpack development
    server on its own. The debugger will be applied to the backend server, which will
    be started on its own, but relies on webpack to handle requests for client-side
    content.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是确认代码按预期行为的过程；调试是找出为什么它不按预期工作的过程。在开始之前，使用 *Ctrl + C* 停止构建过程和单元测试过程。一旦进程停止，运行
    *列表 8.18* 中显示的命令以单独启动 webpack 开发服务器。调试器将应用于后端服务器，该服务器将自行启动，但依赖于 webpack 来处理客户端内容的请求。
- en: 'Listing 8.18: Starting the webpack development server'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18：启动 webpack 开发服务器
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next step is to configure the TypeScript compiler so that it generates source
    maps, as shown in *Listing 8.19*, which lets the debugger correlate the pure JavaScript
    being executed by Node.js with the TypeScript code written by the developer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置 TypeScript 编译器，使其生成源映射，如 *列表 8.19* 所示，这允许调试器将 Node.js 执行的纯 JavaScript
    与开发者编写的 TypeScript 代码关联起来。
- en: 'Listing 8.19: Enabling source maps in the tsconfig.json file in the src folder'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19：在 src 文件夹中的 tsconfig.json 文件中启用源映射
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When you save the file, the compiler will start generating files with the `map`
    file extension in the `dist` folder.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件时，编译器将在 `dist` 文件夹中开始生成具有 `map` 文件扩展名的文件。
- en: Adding code breakpoints
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加代码断点
- en: Code editors that have good TypeScript support, such as Visual Studio Code,
    allow breakpoints to be added to code files. My experience with this feature has
    been mixed, and I have found them unreliable, which is why I rely on the less
    elegant but more predictable `debugger` JavaScript keyword.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 具有良好 TypeScript 支持的代码编辑器，如 Visual Studio Code，允许向代码文件添加断点。我对该功能的体验好坏参半，并且我发现它们不可靠，这就是为什么我依赖于不那么优雅但更可预测的
    `debugger` JavaScript 关键字。
- en: When a JavaScript application is executed through a debugger, execution halts
    when the `debugger` keyword is encountered, and control is passed to the developer.
    *Listing 8.20* adds the `debugger` keyword to the `readHandler.ts` file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 应用程序通过调试器执行时，遇到 `debugger` 关键字时执行将停止，控制权传递给开发者。*清单 8.20* 将 `debugger`
    关键字添加到 `readHandler.ts` 文件中。
- en: 'Listing 8.20: Adding the debugger keyword in the readHandler.ts file in the
    src folder'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8.20：在 src 文件夹中的 readHandler.ts 文件中添加调试器关键字
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There will be no change in the output when the code is executed because Node.js
    ignores the `debugger` keyword by default.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码时输出不会发生变化，因为 Node.js 默认忽略 `debugger` 关键字。
- en: Using Visual Studio Code for debugging
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 进行调试
- en: Most good code editors have some degree of support for debugging TypeScript
    and JavaScript code. In this section, I will show you how to perform debugging
    with Visual Studio Code to give you an idea of the process. There may be different
    steps required if you use another editor, but the basic approach is likely to
    be similar.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优秀的代码编辑器都具有一定的 TypeScript 和 JavaScript 代码调试支持。在本节中，我将向您展示如何使用 Visual Studio
    Code 进行调试，以便您了解整个过程。如果您使用其他编辑器，可能需要不同的步骤，但基本方法可能相似。
- en: To set up the configuration for debugging, select **Add Configuration** from
    the **Run** menu and select **Node.js** from the list of environments when prompted,
    as shown in *Figure 8.3*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置调试配置，从 **运行** 菜单中选择 **添加配置**，并在提示时从环境列表中选择 **Node.js**，如 *图 8.3* 所示。
- en: '![](img/B21959_08_03.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_08_03.png)'
- en: 'Figure 8.3: Selecting the debugging environment'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：选择调试环境
- en: Visual Studio Code will create a `.vscode` folder and a file called `launch.json`,
    which is used to configure the debugger. Change the value of the `program` property
    so that the debugger executes the JavaScript code in the `dist` folder, as shown
    in *Listing 8.21*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 将创建一个 `.vscode` 文件夹和一个名为 `launch.json` 的文件，该文件用于配置调试器。更改
    `program` 属性的值，以便调试器在 `dist` 文件夹中执行 JavaScript 代码，如 *清单 8.21* 所示。
- en: 'Listing 8.21: Configuring the debugger in the launch.json file in the .vscode
    folder'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8.21：在 .vscode 文件夹中的 launch.json 文件中配置调试器
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Save the changes to the `launch.json` file and select **Start Debugging** from
    the **Run** menu. Visual Studio Code will start Node.js and execution will continue
    as normal until the `debugger` keyword is reached. Use a browser to request `http://localhost:5000`
    and click the **Send Message** button. The request will be passed to the handler
    for processing, and when the `debugger` keyword is reached, execution will be
    halted and control will be transferred to the debugging popup, as shown in *Figure
    8.4*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 保存对 `launch.json` 文件的更改，并从 **运行** 菜单中选择 **开始调试**。Visual Studio Code 将启动 Node.js，执行将继续正常进行，直到遇到
    `debugger` 关键字。使用浏览器请求 `http://localhost:5000` 并点击 **发送消息** 按钮。请求将被传递到处理器进行处理，当遇到
    `debugger` 关键字时，执行将停止，控制权将转移到调试弹出窗口，如 *图 8.4* 所示。
- en: '![](img/B21959_08_04.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_08_04.png)'
- en: 'Figure 8.4: Debugging with Visual Studio Code'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：使用 Visual Studio Code 进行调试
- en: The state of the application is displayed in the sidebar, showing the variables
    that are set at the point that execution was halted. Standard debugging features
    are available, including setting watches, stepping into and over statements, and
    resuming execution. The **Debug Console** window allows JavaScript statements
    to be executed in the context of the application so that entering a variable name
    and pressing *Return*, for example, will return the value assigned to that variable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的状态显示在侧边栏中，显示在执行停止点设置的变量。提供了标准调试功能，包括设置监视、单步执行和跳过语句以及恢复执行。**调试控制台**窗口允许在应用程序的上下文中执行
    JavaScript 语句，例如，输入一个变量名并按 *Enter* 键，将返回该变量的值。
- en: Using the remote Node.js debugger
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用远程 Node.js 调试器
- en: If you don’t want to use the code editor for debugging, then Google Chrome provides
    good integrated debugging for Node.js, using the same features that are used to
    debug client-side code. Stop the Visual Studio Code debugger from the previous
    section and run the command shown in *Listing 8.22* in the `webapp` folder to
    start Node.js in debugging mode.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用代码编辑器进行调试，那么 Google Chrome 为 Node.js 提供了良好的集成调试功能，使用与调试客户端代码相同的特性。停止上一节中的
    Visual Studio Code 调试器，然后在 `webapp` 文件夹中运行 *清单 8.22* 中显示的命令以启动 Node.js 的调试模式。
- en: 'Listing 8.22: Starting Node.js in debugging mode'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.22：以调试模式启动 Node.js
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When Node.js starts, it will produce messages like these, which include details
    of the URL on which it is ready to accept debugging requests:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 启动时，它将产生类似这些的消息，其中包含它准备接受调试请求的 URL 详细信息：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using Google Chrome, request `chrome://inspect` and click on the **Open Dedicated
    DevTools for Node** option and the debugging window will open, as shown in *Figure
    8.5*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google Chrome，请求 `chrome://inspect` 并点击 **打开 Node 的专用开发者工具** 选项，调试窗口将打开，如图
    *图 8.5* 所示。
- en: '**Note**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All of the browsers that use the Chromium engine support this feature, including
    Brave, Opera, and Edge. Use the name of the browser for the URL that opens the
    Node.js tools, such as `brave://inspect` for the Brave browser. This doesn’t work
    for Firefox, which has its own browser engine.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有使用 Chromium 引擎的浏览器都支持此功能，包括 Brave、Opera 和 Edge。使用浏览器名称作为打开 Node.js 工具的 URL，例如
    Brave 浏览器的 `brave://inspect`。这对于拥有自己浏览器引擎的 Firefox 不适用。
- en: '![](img/B21959_08_05.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_08_05.png)'
- en: 'Figure 8.5: Using the chrome node.Js debugging features'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：使用 Chrome 的 Node.js 调试功能
- en: Open a new browser window, request `http://localhost:5000`, and click **Send
    Message**. As the request is being processed, Node.js reaches the `debugger` keyword.
    Execution is halted and control is passed to the Chrome developer tools, as shown
    in *Figure 8.6*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器窗口，请求 `http://localhost:5000`，并点击 **发送消息**。当请求正在处理时，Node.js 达到 `debugger`
    关键字。执行停止，控制权传递给 Chrome 开发者工具，如图 *图 8.6* 所示。
- en: '![](img/B21959_08_06.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_08_06.png)'
- en: 'Figure 8.6: The Chrome developer tools debugging Node.js'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：Chrome 开发者工具调试 Node.js
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I described the Node.js features for unit testing and debugging.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 Node.js 的单元测试和调试功能。
- en: Node.js includes a built-in test runner, with support for executing tests and
    creating mock functions and methods.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 包含一个内置的测试运行器，支持执行测试和创建模拟函数和方法。
- en: Unit tests for web applications focus on request handling and require mocks
    of HTTP requests and responses.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 应用程序的单元测试主要关注请求处理，需要模拟 HTTP 请求和响应。
- en: Third-party packages, such as Jest, can be used for projects that require the
    same test tools for client- and server-side JavaScript code.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于需要客户端和服务器端 JavaScript 代码相同测试工具的项目，可以使用第三方包，如 Jest。
- en: Node.js includes support for debugging, which can be performed with many code
    editors or with one of the Chromium-based browsers, such as Google Chrome.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 包含调试支持，可以使用许多代码编辑器或基于 Chromium 的浏览器（如 Google Chrome）进行调试。
- en: In the next part of this book, I demonstrate how Node.js can be used to create
    the features required for web applications, such as generating dynamic content
    and authenticating users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我将演示如何使用 Node.js 创建 Web 应用程序所需的功能，例如生成动态内容和验证用户。
