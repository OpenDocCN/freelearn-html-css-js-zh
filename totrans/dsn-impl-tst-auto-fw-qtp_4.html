<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Understanding and Creating Frameworks</h1></div></div></div><p>This chapter provides a detailed approach and guidance for creating a framework for test automation.</p><p>Creating frameworks in<a id="id246" class="indexterm"/> QTP requires knowledge of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">VBScript basics, control structures, loops, and built-in functions</li><li class="listitem" style="list-style-type: disc">Basic concepts and approaches for designing various frameworks</li><li class="listitem" style="list-style-type: disc">Programming constructs that help to create the utilities for the framework</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Programming with VBScript</h1></div></div></div><p>Knowledge <a id="id247" class="indexterm"/>of Visual Basic script is essential to create frameworks. The knowledge of creating simple statements, controls structure, loops, and built-in functions in VBScript allows us to enhance the test scripts and make them more robust; it also allows us to interact with external resources. This section describes the VBScript features that are useful throughout the designing of the frameworks.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Using VBScript</h2></div></div></div><p>QTP uses VBScript as a scripting language. VBScript allows scripts to deal with resources that are<a id="id248" class="indexterm"/> not a part of the QTP itself, for example, filesystem and external data sources (Excel, databases, and so on). VBScript allows us to define the function procedures; it provides a lot of built-in functions that help to create the reusable functions. VBScript supports the regular expression that assists in verification and validation. Since it's a lightweight language, the framework designer is benefited.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>VBScript datatypes</h2></div></div></div><p>Variant is the only datatype in VBScript. A variant can contain different kinds of information <a id="id249" class="indexterm"/>depending on its declaration and use. It can contain numeric, constant, date, string, and Boolean values.</p><p>The following is a list of the subtypes of a variant:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Subtype</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Range</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Empty</code>
<a id="id250" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Variant is uninitialized</p>
</td><td style="text-align: left" valign="top">
<p> 0 for the numeric variables</p>
<p>"" or Zero-length for the string variables</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Null</code>
<a id="id251" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Variant initially contains no valid data</p>
</td><td style="text-align: left" valign="top">
<p>Does not contain data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Boolean</code>
<a id="id252" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>True or False</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Byte</code>
<a id="id253" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Small integer</p>
</td><td style="text-align: left" valign="top">
<p>0-255</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Integer</code>
<a id="id254" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Integer</p>
</td><td style="text-align: left" valign="top">
<p>From -32,768 to 32,767</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Currency</code>
<a id="id255" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Currency</p>
</td><td style="text-align: left" valign="top">
<p>From -922,337,203,685,477.5808 to 922,337,203,685,477.5807</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Long</code>
<a id="id256" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Long integer</p>
</td><td style="text-align: left" valign="top">
<p>From -2,147,483,648 to 2,147,483,647</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Single</code>
<a id="id257" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Single-precision floating-point number</p>
</td><td style="text-align: left" valign="top">
<p>From -3.402823E38 to -1.401298E-45 for negative values, and from 1.401298E-45 to 3.402823E38 for positive values</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Double</code>
<a id="id258" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Double-precision floating-point number</p>
</td><td style="text-align: left" valign="top">
<p>1.79769313486232E308 to 4.94065645841247E-324 for negative values, and 4.94065645841247E-324 to 1.79769313486232E308 for positive values</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Date (Time)</code>
<a id="id259" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>A number that represents a date</p>
</td><td style="text-align: left" valign="top">
<p>Dates from January 1, 100 to December 31, 9999</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">String</code>
<a id="id260" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Represents the characters</p>
</td><td style="text-align: left" valign="top">
<p>Contains characters of variable length string, approximately 2 billion in length</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Object</code>
<a id="id261" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Contains an object</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Error </code>
<a id="id262" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Contains an Error object</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Operators in VBScript</h2></div></div></div><p>Operators are <a id="id263" class="indexterm"/>useful in creating the expressions; these expressions are created by arithmetic, comparison, and<a id="id264" class="indexterm"/> logical operators. In VBScript, we can divide operators into four major categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mathematical</li><li class="listitem" style="list-style-type: disc">Comparison</li><li class="listitem" style="list-style-type: disc">Concatenation</li><li class="listitem" style="list-style-type: disc">Logical</li></ul></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mathematical</p>
</th><th style="text-align: left" valign="bottom">
<p>Symbol</p>
</th><th style="text-align: left" valign="bottom">
<p>Comparison</p>
</th><th style="text-align: left" valign="bottom">
<p>Symbol</p>
</th><th style="text-align: left" valign="bottom">
<p>Logical</p>
</th><th style="text-align: left" valign="bottom">
<p>Symbol</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Exponential<a id="id265" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">^</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Equality<a id="id266" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">=</code>
</p>
</td><td style="text-align: left" valign="top">
<a id="id267" class="indexterm"/>
<p>Logical negation</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Not</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Urinary negation</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">-</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Inequality</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logical conjunction</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">And</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Multiplication</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">*</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Less than</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logical disjunction</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">OR</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Division</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Greater than</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logical exclusion</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">XOR</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Integer division</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">\</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Less than equal to</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;=</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logical equivalence</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">EQV</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Modulus </p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MOD</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Greater than equal to</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&gt;=</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logical implication</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">IMP</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Addition</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">+</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Object equivalence**</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Is</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Subtraction</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">- </code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Concatenation<a id="id268" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&amp;</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Integer division divides two numbers and returns an integer result, for example, 5/2 will result in 2 not 2.5.</p><p>The modulus or remainder operator divides operand 1 by operand 2 (rounding the floating-point number to an integer) and returns a remainder, for example, 5 MOD 2 will result in 1.</p><p>Object equivalence compares two object reference variables. If object1 and object2 both refer to the same object, the result is <code class="literal">True</code>; if they don't, the result is <code class="literal">False</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec30"/>Adding examples of expressions</h3></div></div></div><p>An expression is a <a id="id269" class="indexterm"/>combination of explicit values, constants, variables, operators, and functions that are interpreted according to particular rules of precedence and association for a particular programming/scripting language.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Control structures and loops</h2></div></div></div><p>A control structure, <a id="id270" class="indexterm"/>conditionally, executes a group of statements, depending on the value of an expression. There are four constructs that control the flow of the execution, which are shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>If (condition)</p>
<p>      statement1</p>
<p>End If</p>
</td><td style="text-align: left" valign="top">
<p>If condition Then statements [Else else statements ]</p>
<p>End If</p>
</td><td style="text-align: left" valign="top">
<p>If condition Then</p>
<p>   [statements]</p>
<p>[ElseIf condition Then</p>
<p>   [elseif statements]]</p>
<p>[Else</p>
<p>   [else statements]]</p>
<p>End If</p>
</td><td style="text-align: left" valign="top">
<p>Select Case expression</p>
<p>   [Case expression list</p>
<p>      [statements]]</p>
<p>   [Case Else</p>
<p>      [else statements]]</p>
<p>End Select</p>
</td></tr></tbody></table></div><p>An example of the <code class="literal">If</code> and <code class="literal">else </code>control statement is given as follows:</p><div><pre class="programlisting">If True Then
Reporter.ReportEvent micPass,"Name of the step", "Details..."
Else
Reporter.ReportEvent micFail, "Name of the step", "Details..."
End If
If elseif … and end if
color ="b"

If color ="r" Then
    msgbox "red"
  elseif  color ="g" then
  msgbox "green"
  elseif color="b" then
  msgbox "blue"
  else
  msgbox "invalid color..."
End If</pre></div><p>The following is an example of the <code class="literal">Select</code> case:</p><div><pre class="programlisting">Dim Color, bgcolor
   Select Case Color
      Case "red"     bgColor = "red"
      Case "green"   bgColor = "green"
      Case "blue"    bgColor = "blue"
      Case Else      MsgBox "pick another color"
   End select
   Msgbox "You have Selected the "&amp; bgcolor</pre></div><p>Running the <a id="id271" class="indexterm"/>preceding lines of code executes a series of statements as long as the given condition is <code class="literal">True</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Using loops</h2></div></div></div><p>A loop executes <a id="id272" class="indexterm"/>a sequence <a id="id273" class="indexterm"/>of statements that are specified once but may be carried out several times in succession. VBScript allows four looping constructs as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>While … Wend</p>
</th><th style="text-align: left" valign="bottom">
<p>Do… Loop</p>
</th><th style="text-align: left" valign="bottom">
<p>For… Next</p>
</th><th style="text-align: left" valign="bottom">
<p>For each… Next</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>While<a id="id274" class="indexterm"/> condition</p>
<p>  [statements]</p>
<p>Wend</p>
</td><td style="text-align: left" valign="top">
<p>Do [{While | Until} condition]</p>
<p>  [statements]</p>
<p>  [Exit Do]</p>
<p>  [statements]</p>
<p>Loop<a id="id275" class="indexterm"/>
</p>
<p>Do</p>
<p>  [statements]</p>
<p>  [Exit Do]</p>
<p>  [statements]</p>
<p>Loop [{While | Until} condition]</p>
</td><td style="text-align: left" valign="top">
<p>For<a id="id276" class="indexterm"/> counter = start To end [Step step]</p>
<p>    [statements]</p>
<p>    [Exit For]</p>
<p>    [statements]</p>
<p>Next</p>
</td><td style="text-align: left" valign="top">
<p>For each <a id="id277" class="indexterm"/>element in collection</p>
<p>   [statements]</p>
<p>   [Exit For]</p>
<p>   [statements]</p>
<p>Next [element]</p>
</td></tr></tbody></table></div><p>The following is an example of the usage of <code class="literal">While … Wend</code>:</p><div><pre class="programlisting">'Print 10 random numbers
counter = 0 'Initialize the counter
While counter &lt; 10
  print Cint( rnd() * 100 )
  counter = counter + 1 'Increment the counter
Wend</pre></div><p>One of the drawbacks of the <code class="literal">While…Wend</code> loop is that it does not have the <code class="literal">exit</code> statement to terminate from the loop but other looping constructs allow us to exit from the loop.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec31"/>The Do Loop</h3></div></div></div><p>The <code class="literal">Do...Loop</code> runs<a id="id278" class="indexterm"/> statements for an indefinite number<a id="id279" class="indexterm"/> of times. The statements are repeated either while a condition is true or <a id="id280" class="indexterm"/>until it becomes true.</p><p>The following is an example of the usage of <code class="literal">Do Loops</code>:</p><div><pre class="programlisting">'Execute the loop until the response until CANCEL button is clicked
Usages 1
Do Until DefResp = vbNo
   MyNum = Int (6 * Rnd + 1)  
 'Generate a random number between 1 and 6.
   DefResp = MsgBox (MyNum &amp; "Do you want another number?", vbYesNo)
'The msgbox displays generated random number and OK and Cancel button
Loop
Usages 2
Do while not DefResp = vbNo
   MyNum = Int (6 * Rnd + 1)  
   DefResp = MsgBox (MyNum &amp; "Do you want another number?", vbYesNo)
Loop
Usages 3
Do 
   MyNum = Int (6 * Rnd + 1)  
   DefResp = MsgBox (MyNum &amp; "Do you want another number?", vbYesNo)
Loop until DefResp = vbNo</pre></div><p>There are two variants of <code class="literal">Do Loop</code>; we can use the <code class="literal">while</code> or <code class="literal">until</code> conditions with <code class="literal">Do</code> or <code class="literal">Loop</code>. When <a id="id281" class="indexterm"/> we use the <code class="literal">while</code> or <code class="literal">until</code> condition with <code class="literal">Do</code>, the execution starts with validating the condition first and then enters into the  loop; refer to example 1. In the latter case, example 3, the first loop is executed once and the condition is checked later.</p><p>The <code class="literal">For Next</code> loop iterates statements over a predefined number of times. Refer to the following code.</p><p>The <a id="id282" class="indexterm"/>
<code class="literal">ToProperties</code> method returns a collection of the properties of the test object.</p><div><pre class="programlisting">set Pcoll = 
Dialog("DialogLogin").WinEdit("EditAgentName:").GetTOProperties()

For i = 0 to coll.count() – 1  
'Count method return the numbers of properties
  -print "Item is  " &amp; Pcoll.item(i)
Next</pre></div><p>The result of the preceding set of code is as follows:</p><div><pre class="programlisting">Item is Edit
Item is Agent Name:
Refer the above results and compare the properties of the object  are same in the following image.</pre></div><p>Refer to the following <a id="id283" class="indexterm"/>screenshot:</p><div><img src="img/1027EN_04_01.jpg" alt="The Do Loop"/></div><p>The <code class="literal">For each … Next</code> loop<a id="id284" class="indexterm"/> iterates statements for each element in an array or collection.</p><p>
<code class="literal">Dim dicObj</code> creates<a id="id285" class="indexterm"/>  a dictionary variable, which is shown as follows:</p><div><pre class="programlisting">Set city = CreateObject("Scripting.Dictionary") 'Creates Dictionary Object
'Dictionary stores data key, item (key – value) pairs.
'Add keys and items.
dicObj.Add "a", "Atlanta"
dicObj.Add "b", "Paris"
dicObj.Add "c", "New Delhi"
'Keys is a method that returns an array or collection containing all existing keys in a Dictionary object.
For each keyitem in d.Keys
   print keyitem
Next</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Introducing frameworks</h1></div></div></div><p>A framework is defined as a broad overview, guideline, or skeleton of the interlinked components, which supports a particular approach to a specific objective, and serves as a guide that can be <a id="id286" class="indexterm"/>enhanced as required by adding or deleting components. A framework is a working or conceptual model that supports or provides guidelines for creating or expanding the test scripts to achieve the test automation, ensuring lower maintenance and easy expandability.</p><p>A test automation framework<a id="id287" class="indexterm"/> is a layered structure and provides the mechanism to interrelate and interact with each other to achieve the common goals. Frameworks also include actual programs and interfaces or offer utility tools for using the frameworks. A framework facilitates a standard way for modifying, adding, and deleting the scripts and functions. It's a comprehensive structure that provides scalability and reliability with less efforts.</p><p>Automation goals<a id="id288" class="indexterm"/> can be achieved by selecting the right framework that is suitable for test automation. The cost of test automation includes both development and maintenance efforts. Selecting the suitable framework and techniques helps in maintaining the lower cost and high impact solution.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>The automation framework and types of framework</h2></div></div></div><p>In general, various structures and techniques are used to design the framework. Broadly based on these techniques and structures, we can classify the framework as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Linear</strong>: In this the<a id="id289" class="indexterm"/> script is created in a linear fashion, usually generated<a id="id290" class="indexterm"/> by recording and replaying without or with only slight modification.</li><li class="listitem" style="list-style-type: disc"><strong>Data-driven</strong>: Parameterizes<a id="id291" class="indexterm"/> the test and fetches data<a id="id292" class="indexterm"/> from a persistent data source. The data source could be internal or external to the test.</li><li class="listitem" style="list-style-type: disc"><strong>Modular</strong>: A modular<a id="id293" class="indexterm"/> framework is designed to achieve modularity at test as well as script levels. The modular framework can be<a id="id294" class="indexterm"/> of the following combinations:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test script modular framework</li><li class="listitem" style="list-style-type: disc">Test library modular framework</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Keyword-driven</strong>: Keyword-driven <a id="id295" class="indexterm"/>framework is designed<a id="id296" class="indexterm"/> for reducing the maintenance cost by separating test cases from their execution.</li><li class="listitem" style="list-style-type: disc"><strong>Hybrid</strong>: In this,<a id="id297" class="indexterm"/> two <a id="id298" class="indexterm"/>or more of the previous patterns are used.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Record and replay</h2></div></div></div><p>Recording<a id="id299" class="indexterm"/> is the process of capturing an object and its properties, creating the test objects, and storing them in the Object Repository with hierarchy. Assign a logical name to the test object and create the scripts by capturing the operation performed on the GUI.</p><div><img src="img/1027EN_04_02.jpg" alt="Record and replay"/></div><p>The preceding screenshot shows the AUT, recorded script, and OR. The AUT contains the test objects. OR stores the test objects in an hierarchy and with their identification properties:</p><p>The recorded scripts take us through the following three test steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the <strong>Login</strong> dialog.</li><li class="listitem">Enter <code class="literal">ashish</code> in the Agent Name textbox.</li><li class="listitem">Enter the password.</li></ol></div><p>A test step contains test objects with hierarchy, operation, and data value (if applicable) for the test object. While recording the user action on AUT, OR creation and scripts generation almost happen simultaneously. This approach is also called the <strong>QTP linear framework</strong> approach. In the linear framework approach, scripts are recorded in a step-by-step fashion without focusing on reusability. Consider an example where you have a test case to log in to an application, search for some data and then log out. In the linear framework, the code would look like something shown in the following example:</p><p>Steps for creating the<a id="id300" class="indexterm"/> QTP linear framework:</p><div><ol class="orderedlist arabic"><li class="listitem">Enter <a id="id301" class="indexterm"/>username.</li><li class="listitem">Enter password.</li><li class="listitem">Click on the <strong>OK</strong> button.</li><li class="listitem">Enter the <strong>Flight</strong> date.</li><li class="listitem">Select <strong>Fly From</strong> (source).</li><li class="listitem">Select <strong>Fly To</strong> (destination).</li><li class="listitem">Click on the <strong>FLIGHT</strong> button.</li><li class="listitem">Click on the <strong>OK</strong> button.</li><li class="listitem">Enter the name.</li><li class="listitem">Click on<a id="id302" class="indexterm"/> the <strong>Insert Order</strong> button.</li><li class="listitem">Close<a id="id303" class="indexterm"/> the <strong>Flight Reservation</strong> window.</li></ol></div><div><pre class="programlisting">'Login 
Dialog("DialogLogin").Activate
Dialog("DialogLogin").WinEdit("EditAgentName:").Set "ashish"    'Enter the agent name
Dialog("DialogLogin").WinEdit("EditPassword:").SetSecure "51e6911da82a99155f73b209eaeac51a66ef0883" ' Enter password
'Create Order
Window("WinFlight").Activate
Window("WinFlight").ActiveX("MaskEdBox").Type "111114"             'Enter Flight Date 
Window("WinFlight").WinComboBox("FlyFrom").Select "London"  ' Select Source 
Window("WinFlight").WinComboBox("Fly To:").Select "Frankfurt"     'Select destination
Window("WinFlight").WinButton("btnFLIGHT").Click                                        'Click on flight button
Window("WinFlight").Dialog("FlightTable").WinButton("btnOK").Click 'Click on the OK button
Window("WinFlight").WinEdit("EditName:").Set "Mr. James Anderson" 'Enter the passenger name
Window("WinFlight").WinButton("btnInsertOrder").Click'Click on the Insert Order button
Window("WinFlight").Activate
Window("WinFlight").Close'Click on the close button</pre></div><p>This is the simplest way to create scripts and use and implement them if the AUT is small, but do not expect frequent changes in AUT. The normal record and playback falls under this framework.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Advantages and disadvantages of linear a framework</h2></div></div></div><p>The advantages of<a id="id304" class="indexterm"/> linear framework are stated as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No expertize or experience of programming or designing is required. Basic knowledge of QTP is required for creating scripts.</li><li class="listitem" style="list-style-type: disc">Automatic test object creation and storage in the Object Repository.</li><li class="listitem" style="list-style-type: disc">This is the fastest way to create test automation scripts.</li><li class="listitem" style="list-style-type: disc">This is the simplest framework, and it is easy to understand.</li><li class="listitem" style="list-style-type: disc">Helps to learn<a id="id305" class="indexterm"/> the objects and create the scripts manually.</li><li class="listitem" style="list-style-type: disc">Can add checkpoints easily.</li></ul></div><p>The disadvantages <a id="id306" class="indexterm"/>of linear framework are stated as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does not allow reusability since scripts are created in a linear fashion and do not have functions.</li><li class="listitem" style="list-style-type: disc">Data is bound with the scripts; hence, the test is noniterative, and this approach is inefficient for executing the test for multiple sets of data. Change the data manually for each run or create multiple copies of scripts; unfortunately, both of these techniques are inefficient.</li><li class="listitem" style="list-style-type: disc">The maintenance cost is very high, and it is tedious, and error-prone since it is required to make changes in all the affected areas.</li><li class="listitem" style="list-style-type: disc">Need to add comments on our own.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Introduction to the data-driven framework</h1></div></div></div><p>A data-driven framework is the collection of test scripts that run with related multiple datasets. This framework <a id="id307" class="indexterm"/>provides reusable scripts for different sets of data and it improves the test coverage. Input and result (test criteria) data values can be stored in one or more central data sources or databases; the actual format and organization can be implementation specific.</p><p>To understand the data-driven framework implementation we should know three terms:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Variable</strong></li><li class="listitem" style="list-style-type: disc"><strong>Parameter</strong></li><li class="listitem" style="list-style-type: disc"><strong>Iteration</strong></li></ul></div><p>A variable <a id="id308" class="indexterm"/>is a storage location and an associated<a id="id309" class="indexterm"/> with an identifier, which contains some known or unknown quantity or information, a value.</p><p>A parameter<a id="id310" class="indexterm"/> is a variable that is provided as an input to the scripts. Parameterization in QTP can be achieved by the <code class="literal">datatable</code> object. The <code class="literal">datatable</code> object represents the QuickTest design-time data table and its associated sheets and parameters. The <code class="literal">datatable</code> object has various methods and properties to access data from the runtime data table object.</p><p>Iteration is a <a id="id311" class="indexterm"/>process where a parameterized script <a id="id312" class="indexterm"/>executes the test for a predefined number of times from a data source.</p><p>There are four major steps in creating a data-driven framework:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a<a id="id313" class="indexterm"/> script.</li><li class="listitem">Define the parameters that hold data.</li><li class="listitem">Add code to get data from the data source and assign a value.</li><li class="listitem">Modify the settings or add code to execute the test for all the rows or subset of rows.</li></ol></div><p>There are two major ways<a id="id314" class="indexterm"/> to access data in QTP:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using <code class="literal">datatable</code> object</li><li class="listitem" style="list-style-type: disc">Using external data source</li></ul></div><p>Creating data-driven scripts using<a id="id315" class="indexterm"/> the <code class="literal">datatable</code> object:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the script by recording or manually.</li><li class="listitem">Define parameters in an external Excel sheet as shown in the following screenshot. Make sure that the first row contains the parameter name. Enter data in the subsequent rows as shown in the following screenshot:<div><img src="img/1027EN_04_03.jpg" alt="Introduction to the data-driven framework"/></div></li></ol></div><p>To fetch the data <a id="id316" class="indexterm"/>from the external excel sheet, use the <a id="id317" class="indexterm"/>
<code class="literal">import</code> method of <code class="literal">datatable</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Define parameters using the <code class="literal">datatable</code> object</li><li class="listitem">To add the data, rename the column name by double-clicking on the column name. Rename the column and add data to the subsequent rows as shown in the following screenshot:<div><img src="img/1027EN_04_04.jpg" alt="Introduction to the data-driven framework"/></div></li><li class="listitem">Use the data-driver tool or <code class="literal">datatable</code> object parameterization. Add the test data to <code class="literal">datatable</code>, add the column name to the header, and double-click on <strong>Add</strong> or change the column name to parameter in the data table.</li><li class="listitem">Make the<a id="id318" class="indexterm"/> test scripts iterative.</li></ol></div><p>There are two ways to make scripts iterative. First, under <strong>Test Settings</strong> select <strong>Run one iteration only</strong>, <strong>Run on all rows</strong>, and then <strong>Run from row</strong> <code class="literal">n</code> <strong>to row</strong> <code class="literal">m</code>:</p><div><img src="img/1027EN_04_05.jpg" alt="Introduction to the data-driven framework"/></div><p>Second, you can also programmatically create the scripts for running the test script:</p><div><pre class="programlisting">'Set the current row to retrieve the value from datatable
datatable.SetCurrentRow startnum
For i =startnum to endnum 'run the script from row (n) to row (m)
.
.
.
'Move to next row of datatable
datatable.SetNextRow
Next</pre></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>To run for one iteration, <code class="literal">startnum</code> and <code class="literal">endnum</code> should be 1, <code class="literal">startnum=endnum=1</code>
</p><p>To run test for all rows, <code class="literal">startnum = 1</code> and <code class="literal">endnum = datatable. datatable.GetRowCount</code>.</p></div></div><p>Let's club all the concepts <a id="id319" class="indexterm"/>together to parameterize the test. Creating the test data in <code class="literal">datatable</code>. <code class="literal">datatable</code> takes two arguments: parameter name and sheet type. <code class="literal">datatable</code> has two types of sheets: local sheet (local to action) and global sheet. To access the data from the global sheet, use <code class="literal">dtGlobalSheet</code>, and to access the data from the local sheet, use <code class="literal">dtLocalSheet</code>. Refer to the following example:</p><div><pre class="programlisting">Systemutil.Run PathToFlightApp
Dialog("DialogLogin").Activate
Dialog("DialogLogin").WinEdit("EditAgentName:").Set DataTable("Agent",dtGlobalSheet)
Dialog("DialogLogin").WinEdit("EditPassword:").SetSecure DataTable("Password",dtGlobalSheet)
Dialog("DialogLogin").WinButton("btnOK").Click
Window("WinFlight").ActiveX("MaskEdBox").Type DataTable("FlightDate",dtGlobalSheet)
Window("WinFlight").WinComboBox("FlyFrom").Select DataTable("FlyFrom",dtGlobalSheet)
Window("WinFlight").WinComboBox("Fly To:").Select DataTable("Flyto",dtGlobalSheet)
Window("WinFlight").WinButton("btnFLIGHT").Click
Window("WinFlight").Dialog("FlightTable").WinButton("btnOK").Click
Window("WinFlight").WinEdit("EditName:").Set DataTable("Name", dtGlobalSheet)
Window("WinFlight").WinButton("btnInsertOrder").Click
Window("WinFlight").WinButton("btnButton").Click
Window("WinFlight").Close</pre></div><p>The following code shows how to import and iterate the test using <code class="literal">datatable</code>:</p><div><pre class="programlisting">datatable.Import "c:\FlightData.xls"
' Import the excel to the datatable.
rc = datatable.GetRowCount
'get the row count
For i = 1 to rc
systemutil.Run PathToFlightApp
Dialog("DialogLogin").Activate
Dialog("DialogLogin").WinEdit("EditAgentName:").Set datatable.Value("Agent")
'Value is DataTable default property. Retrieves or sets the value of the cell in the specified parameter and the current row of the run-time Data Table.
'To find the value use DataTable.Value(ParameterID [, SheetID]) .SheetID Optional. Identifies the sheet to be returned. The SheetID can be the sheet name, index or dtLocalSheet, or dtGlobalSheet.
Dialog("DialogLogin").WinEdit("EditPassword:").SetSecure datatable.Value("Password")
Dialog("DialogLogin").WinButton("btnOK").Click
Window("WinFlight").ActiveX("MaskEdBox").Type datatable.Value("FlightDate")
Window("WinFlight").WinComboBox("FlyFrom").Select datatable.Value("FlyFrom")
Window("WinFlight").WinComboBox("Fly To:").Select datatable.Value("Flyto")
Window("WinFlight").WinButton("btnFLIGHT").Click
Window("WinFlight").Dialog("FlightTable").WinButton("btnOK").Click
Window("WinFlight").WinEdit("EditName:").Set datatable.Value("Name")
Window("WinFlight").WinButton("btnInsertOrder").Click
Window("WinFlight").WinButton("btnButton").Click
Window("WinFlight").Close
datatable.SetNextRow
Next</pre></div><p>Using the Excel application with VBScript:</p><div><pre class="programlisting">Set excelfile = createobject("excel.application") 
 
'Create the excel first before executing script. 
'Ensure that excel file is in Closed state.
 
excelfile.Workbooks.Open "D:\parameter.xls"
set sheet = excelfile.ActiveWorkbook.Worksheets("Sheet1")
 'Get the max row occupied in the excel file 
Row = sheet.UsedRange.Rows.Count 
 
'Read the data from the excel file
For i= 2 to Row
 
Username=sheet.cells(i,1).value
Password=sheet.cells(i,2).value
wait 1
 Next

'Close the Workbook
excelfile.ActiveWorkbook.Close
 
'Close Excel
excelfile.Application.Quit
 
'Release the objects
Set sheet =nothing
Set excelfile = nothing</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>The FileSystemObject object model</h2></div></div></div><p>VBScript <a id="id320" class="indexterm"/>allows you to process drives, folders, and files using the <code class="literal">FileSystemObject</code> (FSO) object model, which is <a id="id321" class="indexterm"/>explained in the following section that describes how you can use <code class="literal">FileSystemObject</code> to manipulate files.</p><p>There are two ways for file manipulation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and appending files, removing data from the files, and reading from the files</li><li class="listitem" style="list-style-type: disc">Copying, moving, and deleting files</li></ul></div><p>The following are<a id="id322" class="indexterm"/> the steps for reading and writing data from text files:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a text file.</li><li class="listitem">Write data to it.</li><li class="listitem">Close it.</li><li class="listitem">Open the text file again.</li><li class="listitem">Read the file.</li><li class="listitem">Close it.</li></ol></div><p>The following is an example<a id="id323" class="indexterm"/> of reading and writing to the text file:</p><div><pre class="programlisting">Dim filefso, file1, readfile, s
   Const ForReading = 1
'create the object of a File system Object
   Set filefso = CreateObject("Scripting.FileSystemObject")
   Set file1 = filefso.CreateTextFile("c:\logfile.txt", True)
   'Write a line.
      fi1e1.WriteLine "Testing FSO"
   file1.WriteBlankLines(2)
   file1.Close
   'Read contents of the text file.
   'Reading file 
   Set readfile = filefso.OpenTextFile("c:\logfile.txt", ForReading)
   's = readfile.ReadLine
 'iterate the file until end of the file
Do While readfile.AtEndOfStream &lt;&gt; True
      retstring = readfile.ReadLine
   Loop
      ts.Close</pre></div><p>An example of using a text file for data-driven testing is given as follows:</p><div><pre class="programlisting">Dim fso, f1, textfile, s
   Const ForReading = 1

Set textfile = fso.OpenTextFile("c:\logfile.txt", ForReading)
   's = textfile.ReadLine
 'iterate the file until end of the file
Do While textfile.AtEndOfStream &lt;&gt; True
      retstring = textfile.ReadLine
Dialog("DialogLogin").Activate
Dialog("DialogLogin").WinEdit("EditAgentName:").Set datatable.Value("Agent")
'Value is DataTable default property. Retrieves or sets the value of the cell in the specified parameter and the current row of the run-time Data Table.
'To find the value use DataTable.Value(ParameterID [, SheetID]) .SheetID Optional. Identifies the sheet to be returned. The SheetID can be the sheet name, index or dtLocalSheet, or dtGlobalSheet.
Dialog("DialogLogin").WinEdit("EditPassword:").SetSecure datatable.Value("Password")
Dialog("DialogLogin").WinButton("btnOK").Click
Window("WinFlight").ActiveX("MaskEdBox").Type datatable.Value("FlightDate")
Window("WinFlight").WinComboBox("FlyFrom").Select datatable.Value("FlyFrom")
Window("WinFlight").WinComboBox("FlyTo:").Select datatable.Value("Flyto")
Window("WinFlight").WinButton("btnFLIGHT").Click
Window("WinFlight").Dialog("FlightTable").WinButton("btnOK").Click
Window("WinFlight").WinEdit("EditName:").Set datatable.Value("Name")
Window("WinFlight").WinButton("btnInsertOrder").Click
Window("WinFlight").WinButton("btnButton").Click
Window("WinFlight").Close

   Loop
      textfile.Close</pre></div><p>The methods<a id="id324" class="indexterm"/> used for performing<a id="id325" class="indexterm"/> the read and write operation on the test files are listed as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Write</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Write to an opened text file</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">WriteLine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Write to an open text file and add a newline character to it</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">WriteBlankLines</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Write blank line(s) to an opened text file</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Read</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Read characters from the text file, which are specified as an argument</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ReadLine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Read the entire line, excluding the newline character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ReadAll</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Read the entire data from a text file</p>
</td></tr></tbody></table></div><p>The following example demonstrates the file manipulation operations:</p><div><pre class="programlisting">Dim filefso, txtfile1, txtfile2, txtfifle3
   Set filefso = CreateObject("Scripting.FileSystemObject")
   Set txtfile1 = filefso.CreateTextFile("d:\tmp\testfile.txt", True)
   'Write a line.
   txtfile1.Write ("Writing a text")
   'Close the file to writing.
   txtfile1.Close
   'Moving the file to d:\tmp 
   'Get a handle of the file in root of d:\.
   Set txtfile2 = filefso.GetFile("d:\tmp\testfile.txt")
   'Moving the file to tmp directory.
   txtfile2.Move ("d:\tmp\testfile.txt")
   
   'Copying the file to temp.
   txtfile2.Copy ("d:\temp\testfile.txt")
     
   Set txtfifle2 = filefso.GetFile("d:\tmp\testfile.txt")
   Set txtfifle3 = filefso.GetFile("d:\temp\testfile.txt")
   'Deleting the files
   txtfifle2.Delete
   txtfifle3.Delete</pre></div><p>The following is an example of using the ADODB to get data from the database:</p><div><pre class="programlisting">Set Conn = CreateObject("ADODB.Connection") 

'Set the Connection String.
Conn.ConnectionString = 
"DSN=QT_Flight32;DBQ=C:\Program Files\Mercury Interactive\QuickTest Professional\samples\flight\app\flight32.mdb;Driver=C:\WINDOWS\system32\odbcjt32.dll;DriverId=281;FIL=MS Access;MaxBufferSize=2048;PageTimeout=5;"
'ADODB.Connection
'RecordSet
Conn.Open("DSN=QT_Flight32") 
Set rcRecordSet= Conn.Execute("SELECT order_number from Orders order by order_number desc")
rcRecordSet.MoveFirst
var_order_num = rcRecordSet.fields("Order_Number")
rcRecordSet.close

Conn.close
set rcRecordSet = nothing
set Conn = nothing</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Introduction to the modular framework</h1></div></div></div><p>Modularity allows decomposing the components and/or functionality and recombines them. This approach<a id="id326" class="indexterm"/> is a design technique that emphasizes on separating the functionality of an AUT into independent, interconnected modules such that each module contains everything necessary to execute only one aspect of the desired functionality.</p><p>Achieving the modularity requires modularity at two different layers; one layer is test and the other layer is script. To create a modular framework, we need to decompose the test layer into manageable pieces based on their objectives. For example, common test libraries are separate from function libraries. At test level, we decompose the key libraries and resources into a structure to achieve the automation goals using appropriate design.</p><p>There are four distinct parts of the modular framework:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Script-level modularity</li><li class="listitem" style="list-style-type: disc">Test-level modularity</li><li class="listitem" style="list-style-type: disc">Resource structure</li><li class="listitem" style="list-style-type: disc">Framework design</li></ul></div><p>Let's take the example of the Flight application; the entire functionality can be divided into small independent functions as shown in the following figure. This requires to achieve <a id="id327" class="indexterm"/>script-level modularity as shown in the following figure:</p><div><img src="img/1027EN_04_06.jpg" alt="Introduction to the modular framework"/></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>We can omit a few functions as part of the automation that are least used and do not contribute towards ROI, such as graph, edit, and help in the Flight application.</p></div></div><p>Apart from decomposing the entire functionality into small, independent functions, we need to ensure that other components should also be decomposed. After decomposing, the entire test <a id="id328" class="indexterm"/>component look likes the following figure:</p><div><img src="img/1027EN_04_07.jpg" alt="Introduction to the modular framework"/></div><p>The preceding list contains the most frequently used components, but implementation of the framework may<a id="id329" class="indexterm"/> require having a few more or less components based on the automation goals and requirements. Following is the description of these components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Function library</strong>: This is<a id="id330" class="indexterm"/> a collection of scripts that perform a particular task. Usually one task that allows to perform on the set of statements on AUT.</li><li class="listitem" style="list-style-type: disc"><strong>Test data</strong>: This is stored in <a id="id331" class="indexterm"/><code class="literal">datatable</code>, or an external data source provides the input for the tests.</li><li class="listitem" style="list-style-type: disc"><strong>Log files</strong>: They capture<a id="id332" class="indexterm"/> the log message that is used to see the outcome of the test scripts.</li><li class="listitem" style="list-style-type: disc"><strong>Master scripts</strong>: These<a id="id333" class="indexterm"/> drive the flow of the test and allow coordination with the other components to ensure that the test runs successfully.</li><li class="listitem" style="list-style-type: disc"><strong>Error handlers</strong>: These<a id="id334" class="indexterm"/> allow to exit the test gracefully when an error occurs, and reveal information about the error.</li><li class="listitem" style="list-style-type: disc"><strong>OR</strong>: This is a part of the test <a id="id335" class="indexterm"/>that contains the test object; usually the OR is a shared OR.</li><li class="listitem" style="list-style-type: disc"><strong>Environment</strong>: This is<a id="id336" class="indexterm"/> a component used to provide test-level environment variables or values that allow configuration of the tests that have to be run on various environments.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Structure</h2></div></div></div><p>After the test is decomposed, resources are required to be arranged in a structured way, which means there is a centralized repository for these resources. Managing the test requires the folder<a id="id337" class="indexterm"/> structure or test management tool (for example, Quality Center) to store the test resources. We need to ensure that the test component stays as<a id="id338" class="indexterm"/> defined by the guidelines and structure. Structure allows organizing the resources for achieving portability and consistency. The framework's folder structure is as shown in the following screenshot. The structure may vary from project to project but it's important for achieving consistency.</p><div><img src="img/1027EN_04_08.jpg" alt="Structure"/></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec32"/>Advantages</h3></div></div></div><p>Structure has the following advantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Facilitates specialization</strong>: Structure<a id="id339" class="indexterm"/> designs the components to perform the specific tasks and provide abstraction from complexity.</li><li class="listitem" style="list-style-type: disc"><strong>Control over resources</strong>: Resource<a id="id340" class="indexterm"/> structure simplifies control over resources because they are at centralized locations<a id="id341" class="indexterm"/> and governed by policies for accessing, creating, and updating the resources.</li><li class="listitem" style="list-style-type: disc"><strong>Easier communication</strong>: Resource structures clearly state the flow of information in a controlled<a id="id342" class="indexterm"/> way among team members. The modifications are done at a centralized location and utilized by all the other team members.</li><li class="listitem" style="list-style-type: disc"><strong>Better performance</strong>: Each<a id="id343" class="indexterm"/> component is specialized to perform its task and is tested thoroughly to improve the performance and reliability of the test.<div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Always use the relative path; do not hardcode the resource location in scripts.</p></div></div></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Design</h2></div></div></div><p>Design is the most<a id="id344" class="indexterm"/> important aspect of frameworks. The design of<a id="id345" class="indexterm"/> a framework is driven by its key automation goals. The following is a comprehensive but not complete list of goals, where a few more goals can be added if required:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Maintainability</strong>: It allows decomposing of resources and scripts; this make it easier to maintain and <a id="id346" class="indexterm"/>debug, and to fix the issues faster and reliably.</li><li class="listitem" style="list-style-type: disc"><strong>Readability</strong>: It is a<a id="id347" class="indexterm"/> well-designed and smaller function that improves the readability of the script and makes it easy to understand as well as enhances it.<div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Comments and script/function headers are important to improve the readability and understandability.</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Extensibility</strong>: When small functions are created and resources are structured, extending the existing<a id="id348" class="indexterm"/> functionality becomes easy. This allows us to add and enhance functionality, debug, and test with ease faster.</li><li class="listitem" style="list-style-type: disc"><strong>Reusability</strong>: Functions<a id="id349" class="indexterm"/> that allow reusability to function make the framework robust and reliable.<div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Before we start designing the framework, we should think of functions that can be used across scripts in the test to increase the reusability. Test these common functions thoroughly, and make sure that they  have the necessary error handling capabilities.</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Concise scripts</strong>: Make<a id="id350" class="indexterm"/> sure that scripts are short and do a single task at a time; these scripts should be a part of the appropriate libraries or modules. Ensure that the scripts are tightly cohesive and loosely coupled.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec33"/>High cohesion and coupling</h3></div></div></div><p>Coupling refers to<a id="id351" class="indexterm"/> that part of the code which can be reused and can be separated from the code but is part of it directly. Whereas cohesion is a measure of how closely related are all the responsibilities, data, and methods of a class/code to each other.</p><p>In particular, I would like to achieve a minimum of three specific things with the design and architecture of a framework:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keep things that have to change together in the code, as close together as possible.</li><li class="listitem" style="list-style-type: disc">Allow unrelated things in the code to change independently (also known as orthogonality).<p>Orthogonality is a concept that allows combining the small components to get effective results. This eases the read/write programs. A more orthogonal design allows for fewer exceptions, symmetry, and consistency.</p></li><li class="listitem" style="list-style-type: disc">Minimize duplication in the code.</li></ul></div><p>The goals behind achieving loose<a id="id352" class="indexterm"/> coupling between modules are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make the code easier to read</li><li class="listitem" style="list-style-type: disc">Make our codes easier to consume by other developers by hiding the complexity</li><li class="listitem" style="list-style-type: disc">Isolate <a id="id353" class="indexterm"/>potential changes to a small area of code</li><li class="listitem" style="list-style-type: disc">Reuse code in completely new contexts</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>Decreasing coupling and increasing cohesion</h3></div></div></div><p>We generally consider high cohesion to be a good thing for designing framework libraries like a key design considerations, but why?<a id="id354" class="indexterm"/>
</p><p>Look at the following code. <a id="id355" class="indexterm"/>We need a connection string to connect to the database, and the connection string and database manipulation code is tightly coupled. Alright, what is the issue here? Now if we want to change the DSN, we need to change the code for each DSN:</p><div><pre class="programlisting">Set Conn = CreateObject("ADODB.Connection") 
Conn.Open("DSN=QT_Flight32") 
Set rcRecordSet= Conn.Execute("SELECT order_number from Orders order by order_number desc")
rcRecordSet.MoveFirst
var_order_num = rcRecordSet.fields("Order_Number")
rcRecordSet.close

Conn.close
set rcRecordSet = nothing
set Conn = nothing</pre></div><p>Let's rewrite this code to make it less coupled and highly cohesive. I have divided the code into two parts. The first part is a function that returns the DSN, and the second part uses that DSN and manipulates the database. Now if the user wants to access another database, the DSN will be different and the user just needs to change the parameter. The previous code is coupled and the following code is cohesive:</p><div><pre class="programlisting">Function getDSN(database)
If database = "access"
 DSN ="DSN=QT_Flight32"
ELSEIF
…
End Function

Set Conn = CreateObject("ADODB.Connection") 
Conn.Open(getDSN("access") )
Set rcRecordSet= Conn.Execute("SELECT order_number from Orders order by order_number desc")
rcRecordSet.MoveFirst
var_order_num = rcRecordSet.fields("Order_Number")
rcRecordSet.close
Conn.close
set rcRecordSet = nothing
set Conn = nothing</pre></div><p>There is one more design consideration in the context of the QTP, that is, whether we should use actions or functions.</p><p>From my personal experience, we should use functions. Actions have many advantages and should be<a id="id356" class="indexterm"/> preferred in implementing any framework. Functions allow us to achieve the goals without functional decomposition. To create the framework, the generic library is required; for<a id="id357" class="indexterm"/> example, Logger, Error handler, and configuration utilities are required to achieve the following:</p><p>The usability can be enhanced by dividing the entire flow into small manageable pieces using actions or functions.</p><p>Key steps for designing the modular framework are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Analyze the application</li><li class="listitem" style="list-style-type: disc">Create the design</li><li class="listitem" style="list-style-type: disc">Create Automation Test Repository</li><li class="listitem" style="list-style-type: disc">Create the test-level components</li><li class="listitem" style="list-style-type: disc">Create the script-level functions</li><li class="listitem" style="list-style-type: disc">Integrate</li><li class="listitem" style="list-style-type: disc">Test It</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>Analyzing the application</h3></div></div></div><p>Analyzing the <a id="id358" class="indexterm"/>application defines the automation goals into the defined functions and operations of the intended application. The key considerations for the analysis are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What are the key functionalities of the application and how are they related to each other?</li><li class="listitem" style="list-style-type: disc">What are key flows?</li><li class="listitem" style="list-style-type: disc">Which is the least used functionality? Will it contribute to ROI?</li><li class="listitem" style="list-style-type: disc">What are the goals that we want to achieve through automation?</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Creating a design</h3></div></div></div><p>Creating a design describes the desired features and operations in detail, including layouts, modules, rules, verification, and interaction among modules along with the process diagrams,<a id="id359" class="indexterm"/> pseudo code, and other documentation.</p><p>The key to achieving modularity is by decomposing the functionality and recombining the modules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Decomposition</strong>: The interaction of the user with the application is broken down into libraries, <a id="id360" class="indexterm"/>such as Functional library (login, createorder, and so on), Common library, OR, Test data, and environment.</li><li class="listitem" style="list-style-type: disc"><strong>Recombination</strong>: The basic elements of interaction are recombined to follow a formal test plan <a id="id361" class="indexterm"/>using several levels of aggregation. The steps are aggregated to make sequences of the basic steps, and the sequences of basic steps are combined to make a scenario. The scenarios are aggregated to make a test suite.</li></ul></div><p>After decomposition and recombination, the overall modular framework design will look like the following diagram:</p><div><img src="img/1027EN_04_09.jpg" alt="Creating a design"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>Setting up an environment</h3></div></div></div><p>Perform the following steps to set up<a id="id362" class="indexterm"/> the test environment:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the structure, which is the same as creating the infrastructure for the test.</li><li class="listitem">Create resources, including installation.</li><li class="listitem">Create the folder structures or resources in the Test Management tool.</li><li class="listitem">Ensure version control (good practice).</li><li class="listitem">Create the configuration file.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>Creating Object Repository</h3></div></div></div><p>Create the OR by<a id="id363" class="indexterm"/> adding objects (Add objects to local repository or record the test step that automatically creates the test objects).</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>Creating test-level components</h3></div></div></div><p>Perform the following steps<a id="id364" class="indexterm"/> to create test-level components:</p><div><ol class="orderedlist arabic"><li class="listitem">Prepare the test data.</li><li class="listitem">Create common functions/libraries.</li><li class="listitem">Create a functional library.</li><li class="listitem">Create test flows.</li><li class="listitem">Add common components by loading the libraries.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Creating script-level functions</h3></div></div></div><p>Perform the following<a id="id365" class="indexterm"/> steps to create script-level components:</p><div><ol class="orderedlist arabic"><li class="listitem">Create steps manually.</li><li class="listitem">Add the required programming logic.</li><li class="listitem">Call the common functions (verification points).</li><li class="listitem">Call the <code class="literal">err</code> handlers.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Integrating design elements</h3></div></div></div><p>Bring all the pieces together into a testing environment, and ensure that the test automation is working end-to-end.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Test the framework design</h3></div></div></div><p>Finally, we can <a id="id366" class="indexterm"/>perform the test to checks for errors, bugs, and interoperability.</p><p>Report the bugs, fix them, and retest.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Advantages of modular frameworks</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional decomposition allows us to divide and conquer the complexities</li><li class="listitem" style="list-style-type: disc">Modularity<a id="id367" class="indexterm"/> eases designing, implementing, and debugging of the frameworks</li><li class="listitem" style="list-style-type: disc">Provides standard interfaces for communicating with each other and allows the plugging in and removal of the new modules</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Challenges for modular frameworks</h2></div></div></div><p>The key challenges<a id="id368" class="indexterm"/> for creating modular frameworks<a id="id369" class="indexterm"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Require more technical know-how and effort to create generic modules</li><li class="listitem" style="list-style-type: disc">For very specific modules, the cost of making interfaces is high</li><li class="listitem" style="list-style-type: disc">For assemblers (integrators), it can be difficult to assess the quality and interaction of different modules</li><li class="listitem" style="list-style-type: disc">It can be difficult to assemble (integrate) the modules</li><li class="listitem" style="list-style-type: disc">The design creativity of a module designer can be limited because he needs to conform to the interface</li><li class="listitem" style="list-style-type: disc">Less variation in products because of overuse of the same modules</li><li class="listitem" style="list-style-type: disc">Total system performance may be suboptimal</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>The keyword-driven framework</h1></div></div></div><p>
<strong>Keyword-driven</strong> testing<a id="id370" class="indexterm"/> is also called table-driven testing or action-based testing. It is a software testing methodology.</p><p>Keyword-driven testing uses a spreadsheet to specify test cases in a specific format, usually in a table format. The functions are designed for each keyword. This keyword is stored in the column on a row of the table. For example, in the keyword-driven approach, each action has its corresponding function stored in the functional library. Driver scripts drive the entire flow, fetch the action, and call the corresponding function.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>The keyword-driven testing approach</h2></div></div></div><p>The keyword-driven approach is when the interaction of a user with an application is abstracted in the form of actions, and data is maintained in the external source.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Decomposition</h3></div></div></div><p>The interaction of the<a id="id371" class="indexterm"/> user with the application is broken down to the basic elements (login, select flight …). In the keyword-driven approach, a keyword represents the business scenario that performs many actions on AUT or small actions repeatedly. The basic elements of interaction are referred to as steps.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Recombination</h3></div></div></div><p>The basic elements of interaction are recombined to follow a formal test plan using several levels of aggregation. <a id="id372" class="indexterm"/>The steps are aggregated to make sequence(s) of the basic steps, and sequences of the basic steps are combined to make sequence groups.</p><p>Refer to the following<a id="id373" class="indexterm"/> screenshot that shows mapping of the actions from its library function using driver script. The interaction of a user with an application is abstracted in the form of actions and data maintained in the external source.</p><p>Separate the test cases from the scripts. The test cases are kept out of the scripts. These are fetched by the driver script and the <code class="literal">keyword</code> function is called as shown in the following screenshot:</p><div><img src="img/1027EN_04_10.jpg" alt="Recombination"/></div><p>Once the keyword is found, the corresponding keyword library function is called as shown in the following screenshot:</p><div><img src="img/1027EN_04_11.jpg" alt="Recombination"/></div><p>Development of the <a id="id374" class="indexterm"/>keyword-driven framework requires achieving the modularity first; apart from that, we need the keyword function library, test cases, and driver script. The keyword-driven framework is a modular framework plus test cases stored in an external source and driver scripts with a specific functional library, also called the keyword library.</p><p>Function decomposition is an important activity for designing the keyword-driven framework, and the decomposition guide to identify the keywords. Keywords are the reusable functions that perform one of the key action(s) on AUT, do a specific task, and complete it on their own terms. Another important aspect of the keyword-driven framework is test cases are separated from the test scripts.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>The keyword-driven or test-plan driven method</h3></div></div></div><p>This approach leverages the advantages of functional decomposition and separates the execution from the scripts. <a id="id375" class="indexterm"/>The test cases are defined in the spreadsheet containing the keywords. Each keyword has its corresponding function library that performs the action on the AUT.</p><p>In this method, the entire process is keyword driven, including the functionality. The keywords control the processing.</p><p>
<strong>Keyword-driven testing</strong> (<strong>KDT</strong>) was created to simplify the creation of automated test cases and make them<a id="id376" class="indexterm"/> as much as manual test cases. KDT creates QTP-automated test scripts <code class="literal">On the Fly</code> based on information entered into a spreadsheet.</p><p>Test case representation will be in rows and columns. In the test scenario spreadsheet, each test case will perform an action.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>In automated testing, the lowest level of granularity is the test case step. The step level is where each action or verification occurs.</p></div></div><p>As per KDT, we need to prepare data spreadsheets for each locale because the functionality may differ based upon the different locales. Some locales have a specific coverage for commercial groups, individual businesses, and so on. It is difficult to handle these in the test script. Test suite is prepared to specify which locale/locales need to be executed, and the script is made generic. The script is driven based on the Excel sheet, which will take Excel data from the locale and generate the <code class="literal">On the Fly </code>script.</p><p>Key steps for<a id="id377" class="indexterm"/> designing the keyword-driven framework:</p><div><ol class="orderedlist arabic"><li class="listitem">Analyze the application.</li><li class="listitem">Create the design.</li><li class="listitem">Create the Automation Test Repository.</li><li class="listitem">Create the test-level components.</li><li class="listitem">Create the scripts-level functions.</li><li class="listitem">Integrate.</li><li class="listitem">Test it.</li></ol></div><p>We have already seen the key steps in creating the modular framework. The approach remains the same for the keyword-driven framework as well.</p><p>Let's find out about the automation repository in the keyword-driven approach. Overall, it contains data related to documents, test suite, and created test cases and libraries.</p><p>Test cases are also referred to as test scenarios or test groups, which contain the spreadsheet that specifies the test steps for execution.</p><p>Common libraries contain the QTP library files and (<code class="literal">.vbs</code>, <code class="literal">.qfl</code>) files that control the entire KDT control flow, for example, driver scripts and library files (<code class="literal">.qfl</code>, <code class="literal">.vbs</code>). Common libraries<a id="id378" class="indexterm"/> can be viewed as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Utility functions</li><li class="listitem" style="list-style-type: disc">Navigation functions</li><li class="listitem" style="list-style-type: disc">Support functions</li></ul></div><p>
<strong>Environment libraries</strong> <a id="id379" class="indexterm"/>contain <code class="literal">.xml</code> and <code class="literal">.qfl</code> files that are used to set the environment.</p><p>
<strong>Error libraries</strong> contain <a id="id380" class="indexterm"/>files that are used to catch the errors during execution and perform the<a id="id381" class="indexterm"/> necessary actions (<code class="literal">.qfl</code> or <code class="literal">.vbs</code> file).</p><p>
<strong>Framework documents</strong> contain all the data that is created for the framework, for example, enhancements to the initial framework or help files created for the framework.</p><p>
<strong>Object Repository</strong>
<a id="id382" class="indexterm"/> contains the <code class="literal">.tsr</code> object files created using QTP.</p><p>The following<a id="id383" class="indexterm"/> diagram shows how various layers and components work together to achieve the overall design:</p><div><img src="img/1027EN_04_12.jpg" alt="The keyword-driven or test-plan driven method"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Generic flow in keyword-driven approach</h3></div></div></div><p>The key steps and their sequence of execution in the keyword-driven approach are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Fetch the keyword as mentioned in the spreadsheet<a id="id384" class="indexterm"/>.</li><li class="listitem">Build a list of the parameters from the step that follows.</li><li class="listitem">Call the utility functions; the utility scripts will do the following:<div><ol class="orderedlist arabic"><li class="listitem">Call utility scripts with the input parameter-list received from the utility script.</li><li class="listitem">Call the driver script to perform specific tasks (for example, log in, select flight, and so on), calling user-defined functions if required.</li><li class="listitem">Report any errors to a test report for the test case.</li><li class="listitem">Exception handler scripts.</li><li class="listitem">Return to the driver script.</li></ol></div></li><li class="listitem">Repeat the steps from 1 to 3.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Advantages of the keyword-driven approach</h2></div></div></div><p>The key advantages <a id="id385" class="indexterm"/>offered by the keyword-driven approach are as explained in the following sections.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Cost effectiveness</h3></div></div></div><p>The keyword-driven automation framework reduces cost and time of the test design, automation, and <a id="id386" class="indexterm"/>execution. Keywords are highly reusable functions that represent the business scenarios or actions performed on the GUI. Each of these well-designed and tested functions provide good return on investment over a period of time.</p><p>Separating test cases allows executing test cases without modifying the scripts. When the flow of the application changes, just change the test cases and not the scripts.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Reusability</h3></div></div></div><p>Keywords, utilities,<a id="id387" class="indexterm"/> and functions are built to achieve reusability. The entire framework is divided into layers that are integrated with each other.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Ease of maintenance</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The keyword-driven approach provides abstraction from the complexities and technical challenges; it is easy to maintain</li><li class="listitem" style="list-style-type: disc">The robustness<a id="id388" class="indexterm"/> of the keyword-driven framework allows adapting the changes in GUI and test flows</li><li class="listitem" style="list-style-type: disc">Allows focusing on the development of test cases without or with minimal changes to the scripts, functions, and utilities</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>Ease of execution</h3></div></div></div><p>The keyword-driven <a id="id389" class="indexterm"/>approach allows executing and creating automated test cases for non-technical testers, business analysts, and SMEs (Subject Matter Expert) to write automated tests.</p><p>Test cases are separated from the scripts, and it is easy to prepare the test cases using the used keywords without knowledge of how they have been implemented.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Key challenges</h2></div></div></div><p>Knowledge of<a id="id390" class="indexterm"/> designing is required.</p><p>New team <a id="id391" class="indexterm"/>members have to put in efforts to understand the framework and its design. Good documentation and knowledge sharing is required to overcome this issue.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>The hybrid framework</h1></div></div></div><p>The<strong> hybrid framework</strong> allows combining the two frameworks to leverage their strengths and remove their <a id="id392" class="indexterm"/>weaknesses. Most frameworks, which are developed, fall into this category that uses the function decomposition like modular frameworks and the data-driven approach.</p><p>Key steps in<a id="id393" class="indexterm"/> designing the hybrid framework are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Creating the folder structure.</li><li class="listitem">Creating and storing automation resources.</li><li class="listitem">Organizing and managing resources.</li><li class="listitem">Integrating the frameworks.</li><li class="listitem">Dry run.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Advantages of the hybrid framework</h2></div></div></div><p>Hybrid framework allows<a id="id394" class="indexterm"/> leverages, and pulls the strengths of the other frameworks and eliminates their shortcomings, which suits the automation. Practically, most of the test automation solutions fall in this category.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Key challenges</h2></div></div></div><p>Though<a id="id395" class="indexterm"/> it mitigates<a id="id396" class="indexterm"/> the weaknesses of the other approaches, it loses its generosity and is very specific to the test automation solution AUT, which reduces the reusability of its components across the multiple AUTs.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Business Process Testing</h1></div></div></div><p>
<strong>Business Process Testing</strong> (<strong>BPT</strong>) approach allows dividing the business processes into smaller reusable components that can used many times in the same or different test scripts; for example, the business process of buying a <a id="id397" class="indexterm"/>product is split into components such as log in, select product, add to cart, place order, and log out, which can be re-used in the same business process or different processes. The key advantage is it facilitates SMEs, Bas, and automation engineers to work and collaborate effectively. Some people call it a framework, but this is an approach rather than a framework. BPT is similar to the modular approach of creating test automation solutions using QTP and Quality Center.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Application-independent framework</h1></div></div></div><p>The<a id="id398" class="indexterm"/> application-independent framework is a specific keyword-driven testing or table-driven testing. It identifies the keywords that are independent of the AUT, which can perform specific actions on the components of the AUT directly. The key difference between the keyword-driven framework and application-independent keyword-driven framework lies in the library. In the application-independent keyword-driven framework, the functional library is more generic or works directly on the generic components for AUT. The following is the data table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Window</p>
</th><th style="text-align: left" valign="bottom">
<p>WinObject</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th><th style="text-align: left" valign="bottom">
<p>Arguments</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Calculator</p>
</td><td style="text-align: left" valign="top">
<p>button</p>
</td><td style="text-align: left" valign="top">
<p>Click</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Calculator</p>
</td><td style="text-align: left" valign="top">
<p>button</p>
</td><td style="text-align: left" valign="top">
<p>Click</p>
</td><td style="text-align: left" valign="top">
<p>+</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Calculator</p>
</td><td style="text-align: left" valign="top">
<p>button</p>
</td><td style="text-align: left" valign="top">
<p>Click</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Calculator</p>
</td><td style="text-align: left" valign="top">
<p>button</p>
</td><td style="text-align: left" valign="top">
<p>Click</p>
</td><td style="text-align: left" valign="top">
<p>=</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Calculator</p>
</td><td style="text-align: left" valign="top">
<p>Text</p>
</td><td style="text-align: left" valign="top">
<p>VerResult</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr></tbody></table></div><p>The functionality of the AUT is specified in the data table. The preceding table allows calculating<a id="id399" class="indexterm"/> some operations on the calculator window, which is 1 + 3 = and verify the result. The instructions are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the button (<strong>1</strong>) in the calculator window.</li><li class="listitem">Click on the button (<strong>+</strong>) in the calculator window.</li><li class="listitem">Click on the button (<strong>3</strong>) in the calculator window.</li><li class="listitem">Click on the button (<strong>=</strong>) in the calculator window.</li><li class="listitem">Verify the result from text in the calculator.</li></ol></div><p>The action column lists the actions done with the mouse, keyboard, or specific functions. The data table should be mapped to generate the test step; for example, mouse click on the button, and the button is identified by the argument (<code class="literal">1</code>). The control name is given in the <code class="literal">WinObject</code> column, and the <code class="literal">Window</code> column contains the name of the application.</p><p>In QTP, the Object Repository stores the test objects and provides the logical name |to it. We can use this logical name as a parameter to create the script; for example, we can store the object hierarchy in Excel with data. That is, utilizing the code to create the application-independent frameworks. The following diagram is an example of how we can achieve the application-independent implementation using excel and convert it into scripts. All the objects' names are provided in the column; in runtime, it fetches the object information and creates the scripts as shown in the following diagram:</p><div><img src="img/1027EN_04_13.jpg" alt="Application-independent framework"/></div><p>In the preceding diagram, we can observe that the script creates the objects at runtime rather than the hardcoded scripts. This gives the application independence from the other applications.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Advantages of the application-independent framework</h2></div></div></div><p>Application-independent<a id="id400" class="indexterm"/> keyword-driven framework inherits all the advantages of the keyword-driven framework, apart from the one that allows us to work on different applications without much changes.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Key challenges of the application-independent framework</h2></div></div></div><p>Creating the<a id="id401" class="indexterm"/> application-independent framework requires more expertise to deal with the complexities in creating generic libraries.</p><p>The <a id="id402" class="indexterm"/>application-independent keyword-driven approach is usually designed for specific technologies and not for multiple technologies.</p><p>The most basic framework that is provided by QTP is the replay mechanism and easy steps to create the test steps. These steps are put into reusable functions and become the functional library in the modular and keyword-driven frameworks. Parameterizing the step and allowing it to iterate becomes the data-driven approach. Refer to the following diagram that shows the steps we performed in developing the one framework that became the base for developing the next one, for example, record and replay become the base for data-driven frameworks. One framework becomes the base or partial base to the next framework. Refer to<a id="id403" class="indexterm"/> the following diagram demonstrating how they are related:</p><div><img src="img/1027EN_04_14.jpg" alt="Key challenges of the application-independent framework"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>This chapter describes the various concepts and approaches to build a framework and its components, and a structure that allows us to keep the resources uniformly accessible. This helps to achieve the automation goals and lower the maintenance cost of the test automation suite.</p><p>In the next chapter, we are going to discuss various ways to debug scripts, custom logging deployment, and maintaining the framework.</p></div></body></html>