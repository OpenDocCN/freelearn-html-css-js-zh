<html><head></head><body>
		<div><h1 id="_idParaDest-22"><em class="italic"><a id="_idTextAnchor027"/>Chapter 2:</em> Exploring TestCafe Under the Hood</h1>
			<p>The main goal of this chapter is to learn how TestCafe works under the hood and how it can be used in <strong class="bold">test automation</strong> to cover different features of websites and portals. We will get acquainted with the architecture of TestCafe, its API, and custom client-side code.</p>
			<p>These topics will give us the ability to understand what main methods and functions of TestCafe are available out of the box and how to invoke them.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor028"/>Scouting the TestCafe architecture.</li>
				<li>Learning about the TestCafe API.</li>
				<li>Executing custom client-side code.</li>
			</ul>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor029"/>Scouting the TestCafe architecture</h1>
			<p>From the beginning of time, end-to-end web testing frameworks <a id="_idIndexMarker045"/>have depended on external drivers to emulate user actions in real browsers. This approach, however, has a number of downsides: </p>
			<ul>
				<li><strong class="bold">Third-party dependencies and a limited number of supported browsers</strong>: You had to download, install, configure, and update additional drivers or libraries for each test environment (and sometimes even for each test run). In addition to that, you could only use the browsers supported by each driver.</li>
				<li><strong class="bold">Lack of flexibility</strong>: Old tools were unable to operate on the tested page directly. As long as the test code does not interfere with the app code, operating on the tested page directly enables the tool to execute many additional scenarios and workarounds. For example, this way it can add and remove styles or change the visibility of any elements on the tested page.</li>
				<li><strong class="bold">Code duplication</strong>: Legacy testing frameworks ran with the same browser instance during the entire test run, maintaining the tested web application state from test to test (and keeping the same values in cookies and storage). As a consequence, end-to-end tests had a huge amount of duplicated code for clearing the <a id="_idIndexMarker046"/>web application state between tests to avoid interference.</li>
			</ul>
			<p>However, TestCafe has a fix for each of these problems.</p>
			<p>The core idea behind the architecture of TestCafe is that users should not need any external drivers to run end-to-end browser tests. Instead, all the test scripts that emulate user actions can be executed from the page itself. This enables a true cross-platform and cross-browser approach as tests will be able to run on any device with a modern browser!</p>
			<p>After each test finishes its execution, TestCafe purges the browser state: it deletes cookies, clears <code>localStorage</code> and <code>sessionStorage</code>, and reloads the page. If you launch several tests in parallel, TestCafe executes each test run in an independent server-side context to prevent server-side collisions.</p>
			<p>TestCafe execution can be split into two parts:</p>
			<ul>
				<li>Server-side (in the Node.js process).</li>
				<li>Client-side (in the browser).</li>
			</ul>
			<p>Let's take a look at each of these parts.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>The server side</h2>
			<p>Test code is <a id="_idIndexMarker047"/>performed in the Node.js environment on the <strong class="bold">server side</strong>. This enables TestCafe to use advantages of standalone server-side code, including the possibility of launching tested web application servers before tests and enhanced control over the testing environment and test execution.</p>
			<p>Executing test code in Node.js provides a lot of advantages:</p>
			<ul>
				<li>Database preparation and the launching of the application can be done from within the tests.</li>
				<li>Tests have access to the server's filesystem, so you can read data or create files needed for testing.</li>
				<li>Tests can use all recent <a id="_idIndexMarker048"/>syntax features of Node.js. In addition to that, you can include and utilize any Node.js third-party packages.</li>
				<li>Improved stability and speed of execution due to test logic separation from automation scripts.</li>
			</ul>
			<p>Since Node.js code executes on the server, it doesn't have direct access to the <strong class="bold">Document Object Model (DOM)</strong> of the <a id="_idIndexMarker049"/>page or browser API, but this is handled by custom client-side functions that have access to the DOM and are executed in the browser context.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor031"/>The client side</h2>
			<p>TestCafe automation scripts<a id="_idIndexMarker050"/> are designed to imitate user actions on any tested page. Their main goal is to enable you to write high-level cross-browser tests, so element-focusing, triggering events, and processing attributes are performed in the same way as a real human would in a browser.</p>
			<p>Scripts that emulate user activity (TestCafe internal scripts) run on the <strong class="bold">client side</strong> on the tested page in the browser. This enables TestCafe to utilize the advantages of browser scripts, including built-in smart waits, mobile testing, and user roles. For client-side code to work in the browser, TestCafe proxies the tested page on the server and injects the scripts into its code. This approach is also known as a reverse proxy. When you run TestCafe tests, the browser address bar shows a URL that is prefixed with some digits – this is because TestCafe uses its own <a id="_idIndexMarker051"/>open source URL-rewriting proxy (<a href="https://github.com/DevExpress/testcafe-hammerhead">https://github.com/DevExpress/testcafe-hammerhead</a>) and proxies the tested pages.</p>
			<p>When you run tests with TestCafe, a reverse proxy is automatically launched locally on your computer. It injects automation scripts into the tested page, so neither the page code nor the resources it communicates with can tell that the page has been modified. In other words, when TestCafe proxies the tested page, it adds automation scripts and rewrites all the URLs on the tested page to point to the proxy:</p>
			<div><div><img src="img/Figure_2.1_B16280.jpg" alt="Figure 2.1 – TestCafe reverse proxies between the user's browser and the web server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – TestCafe reverse proxies between the user's browse<a id="_idTextAnchor032"/>r and the web server</p>
			<p>When the browser refers to<a id="_idIndexMarker052"/> these new, rewritten URLs, the original resources are also proxied and enhanced in the same way. TestCafe also mocks the browser API to separate automation scripts from the rest of the page code. The proxying mechanism is absolutely safe – it guarantees that the page appears to be hosted at the original URL, even to the test code.</p>
			<p>In this section, we reviewed how TestCafe operates from the server and client sides. We also learned about the main advantages of this architecture, including the possibility to prelaunch applications before tests, extend control over testing environments, proxying and injecting scripts, which enables smart waiting, mobile testing, and user roles, which we will discuss a bit later.</p>
			<p>TestCafe supports JavaScript – the most<a id="_idIndexMarker053"/> popular programming language for web development – which allows most users to use their existing coding skills and minimizes the learning curve for newcomers. In addition to that, its clear API makes tests easy to create, read, and maintain. So, let's see what methods TestCafe has to offer.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor033"/>Learning about the TestCafe API</h1>
			<p>Since the server-side code runs in <a id="_idIndexMarker054"/>Node.js, tests should be written in JavaScript (TypeScript and CoffeeScript are also supported, but eventually, everything should be transpiled into JavaScript).</p>
			<p>TestCafe utilizes a minimalistic API that provides less than a few dozen methods, which are then transformed into user actions on the page. As our tests will be using the TestCafe API methods to interact with the pages, let's review the main interaction groups supported in TestCafe:</p>
			<ul>
				<li>Elements selection<a id="_idTextAnchor034"/>.</li>
				<li>Actions.</li>
				<li>Assertions.</li>
				<li>User roles.</li>
			</ul>
			<p>Let's discover each of these interactions in more detail.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor035"/>Elements selection</h2>
			<p>TestCafe utilizes<a id="_idIndexMarker055"/> an advanced mechanism with built-in waiting to locate target elements for an action or assertion. To perform an action (such as click, hover, type, and so on) or to make an assertion, you should first identify the target page element. This is as easy as specifying a standard CSS selector. For more complex situations, you can chain methods (such as, for example, getting an element by class name, then getting its second child, and then finally, getting its third sibling). Selector strings should be passed inside chainable <code>Selector</code> constructors to create a selector.</p>
			<p>For example, you can click on a button with the <code>button-test</code> class, as follows:</p>
			<pre>const { Selector } = require('testcafe');const buttonTest = Selector('.button-test');</pre>
			<p>For more complex situations, you can traverse the DOM tree by chaining selectors:</p>
			<pre>const { Selector } = require('testcafe');const linkTest = Selector('#block-test')    .child('a')    .withAttribute('href', 'https://test-site.com/main.html')    .withText('Second link');</pre>
			<p>What this chain of <a id="_idIndexMarker056"/>selectors does is the following:</p>
			<ol>
				<li>Selects an element with the <code>block-test</code> id.</li>
				<li>Selects its child elements.</li>
				<li>Filters them by the <code>a</code> tag.</li>
				<li>Selects elements with the <code>href</code> attribute that includes <code>https://test-site.com/main.html</code>.</li>
				<li>Selects elements that include the <code>Second link</code> text.<p class="callout-heading">Note</p><p class="callout">If a selector matches several elements, the subsequent methods return results for all the elements that were matched.</p></li>
			</ol>
			<p>TestCafe provides a number of methods that search for elements relative to the selected element (keep in mind that all of these methods should be prepended with <code>Selector(cssSelector)</code>). Most of these methods accept <code>index</code> as an argument, which should be a zero-based number (0 will be the closest relative element in the set). If the number is negative, the index is counted from the end of the matched set. Here are the methods:</p>
			<ul>
				<li><code>.find(cssSelector)</code>: Finds the descendant nodes of all the nodes in the matched set and uses a CSS selector to filter them (the CSS selector should be a string) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/find.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/find.html</a>).</li>
				<li><code>.parent(index)</code>: Finds the parents of all the nodes in the matched set (the first element in the set is the closest parent) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/parent.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/parent.html</a>).</li>
				<li><code>.child(index)</code>: Finds the<a id="_idIndexMarker057"/> child elements of all nodes in the matched set (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/child.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/child.html</a>).</li>
				<li><code>.sibling(index)</code>: Finds the <a id="_idIndexMarker058"/>sibling elements of all the nodes in the matched set (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/sibling.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/sibling.html</a>).</li>
				<li><code>.nextSibling(index)</code>: Finds the succeeding sibling elements of all the nodes in the matched set (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/nextsibling.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/nextsibling.html</a>).</li>
				<li><code>.prevSibling(index)</code>: Finds the preceding sibling elements of all nodes in the matched set and filters them by index (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/prevsibling.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/prevsibling.html</a>).</li>
			</ul>
			<p>Now, let's look at the methods that filter elements from the selector. The same as before, all of these methods should be prepended with <code>Selector(cssSelector)</code>. Here are the methods:</p>
			<ul>
				<li><code>.nth(index)</code>: Selects an element with the specified index in the matched set. Here, the <code>index</code> argument should be a zero-based number (0 will be the closest relative element in the set). If it is negative, the index is counted from the end of the matched set (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/nth.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/nth.html</a>).</li>
				<li><code>.withText(text)</code>: Selects elements that contain the specified text. Here, <code>text</code> is the element's text content (the <code>text</code> argument is a case-sensitive string) or a <strong class="bold">regular expression</strong> (<strong class="bold">RegExp</strong>) that should match the element's text (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withtext.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withtext.html</a>).</li>
				<li><code>.withExactText(text)</code>: Selects<a id="_idIndexMarker059"/> elements whose text content strictly matches the specified text. Here, <code>text</code> is the element's text content (the <code>text</code> argument is a case-sensitive string) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withexacttext.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withexacttext.html</a>).</li>
				<li><code>.withAttribute(attrName[, attrValue])</code>: Selects elements that contain the <a id="_idIndexMarker060"/>specified attribute. Here, <code>attrName</code> can be a case-sensitive string or a <code>RegExp</code>, and optionally, <code>attrValue</code> can also be a case-sensitive string or a <code>RegExp</code> (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withattribute.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/withattribute.html</a>).</li>
				<li><code>.filterVisible()</code>: Selects elements that do not have the <code>display: none;</code> or <code>visibility: hidden;</code> CSS properties and have non-zero widths and heights (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filtervisible.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filtervisible.html</a>).</li>
				<li><code>.filterHidden()</code>: Selects elements that have the <code>display: none;</code> or <code>visibility: hidden;</code> CSS properties, or zero widths or heights (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filterhidden.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filterhidden.html</a>).</li>
				<li><code>.filter(cssSelector)</code>: Selects elements that match the CSS selector (the CSS selector should be a string used to filter child elements). Also, instead of the <code>cssSelector</code> argument, you could provide <code>filterFn</code> (a function predicate used to filter the elements) and, optionally, <code>dependencies</code> (an object with functions, variables, or objects passed to the <code>filterFn</code> function) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filter.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/filter.html</a>).</li>
			</ul>
			<p>When a selector is executed, TestCafe will be<a id="_idIndexMarker061"/> waiting for the target node to appear on the page until the selector timeout expires. You can specify the timeout (in milliseconds) in the following cases:</p>
			<ul>
				<li><code>selectorTimeout</code> config option in the <code>.testcaferc.json</code> configuration file (<a href="https://devexpress.github.io/testcafe/documentation/reference/configuration-file.html">https://devexpress.github.io/testcafe/documentation/reference/configuration-file.html</a>).</li>
				<li><code>--selector-timeout</code> command-line option (<a href="https://devexpress.github.io/testcafe/documentation/reference/command-line-interface.html#--selector-timeout-ms">https://devexpress.github.io/testcafe/documentation/reference/command-line-interface.html#--selector-timeout-ms</a><a href="https://devexpress.github.io/testcafe/documentation/reference/command-line-interface.html#--selector-timeout-ms)"/>.</li>
				<li><code>Selector</code> (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/constructor.html#optionstimeout">https://devexpress.github.io/testcafe/documentation/reference/test-api/selector/constructor.html#optionstimeout</a>) to set the timeout for any particular element.</li>
			</ul>
			<p>During the timeout, the selector is rerun until it returns a DOM element or the timeout is surpassed. If TestCafe can't find the corresponding node in the DOM, the test is marked as failed.</p>
			<p>Actions</p>
			<p>The TestCafe API <a id="_idIndexMarker063"/>provides a set of action methods to interact with the page (such as click, type, select text, hover, and so on). You can call them one after another in a chained fashion. All of these methods should be prepended with <code>t</code> as they are the methods of the test controller object (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/</a>). Also, <code>selector</code> can be a string, selector, DOM node, function, or Promise; and optionally, you can use <code>options</code>, which is an object with a set of options containing supplementary parameters for the action (unless otherwise specified). Here are all the main <a id="_idIndexMarker064"/>action methods:</p>
			<ul>
				<li><code>.click(selector[, options])</code>: Clicks on an element on a page  (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/click.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/click.html</a>).</li>
				<li><code>.doubleClick(selector[, options])</code>: Double-clicks on an element on a page (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/doubleclick.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/doubleclick.html</a>).</li>
				<li><code>.rightClick(selector[, options])</code>: Right-clicks on an element on a page (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/rightclick.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/rightclick.html</a>).</li>
				<li><code>.pressKey(keys[, options])</code>: Presses the specified keyboard keys. Here, <code>keys</code> is a <a id="_idIndexMarker065"/>sequence of keys and key combinations to be pressed (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/presskey.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/presskey.html</a>).</li>
				<li><code>.navigateTo(url)</code>: Navigates to the specified URL. Here, <code>url</code> is a string with the URL to navigate to (which can be absolute or relative to the current page) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/navigateto.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/navigateto.html</a>).</li>
				<li><code>.typeText(selector, text[, options])</code>: Types the specified text into an input element. Here, <code>text</code> is a string of the text to be typed into the specified web page element (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/typetext.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/typetext.html</a>).</li>
				<li><code>.selectText(selector[, startPos][, endPos][, options])</code>: Selects text in input elements of various types. Here, <code>startPos</code> is the number (zero-based integer, 0 by default) of the start position of the selection. Optionally, <code>endPos</code> is the number (zero-based integer; by default, it is equal to the length of the visible text content) of the end position of the selection (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/selecttext.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/selecttext.html</a>).</li>
				<li><code>.hover(selector[, options])</code>: Hovers the mouse pointer over a web page element (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/hover.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/hover.html</a>).</li>
				<li><code>.drag(selector, dragOffsetX, dragOffsetY[, options])</code>: Drags an<a id="_idIndexMarker066"/> element to a specified offset. Here, <code>dragOffsetX</code> is the number of pixels for the <em class="italic">X</em> offset (horizontal) of the drop coordinates from the original position of the <a id="_idIndexMarker067"/>mouse pointer, and <code>dragOffsetY</code> is the number of pixels for the <em class="italic">Y</em> offset (vertical) of the drop coordinates from the original position of the mouse pointer (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/drag.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/drag.html</a>).</li>
				<li><code>.dragToElement(selector, destinationSelector[, options])</code>: Drags an element onto another web page element. Here, <code>destinationSelector</code> should identify the web page element that will be the drop location (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/dragtoelement.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/dragtoelement.html</a>).</li>
				<li><code>.setFilesToUpload(selector, filePath)</code>: Adds file paths to the specified file upload input. Here, <code>filePath</code> is a string or an array with the path to the uploaded file (or several paths, in the case of an array). Relative paths are resolved against the folder with the test file (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/setfilestoupload.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/setfilestoupload.html</a>).</li>
				<li><code>.clearUpload(selector)</code>: Deletes all the file paths from the specified file upload input (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/clearupload.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/clearupload.html</a>).</li>
				<li><code>.takeScreenshot([options])</code>: Takes a screenshot of the entire page. The optional <code>options</code> object can include the following properties: the <code>path</code> string with the screenshot file's relative path and name or a <code>fullPage</code> boolean (false by default) that <a id="_idIndexMarker068"/>specifies if the full page should be captured, including content that is not visible due to overflow (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/takescreenshot.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/takescreenshot.html</a>).</li>
				<li><code>.takeElementScreenshot(selector[, path][, options])</code>: Takes a <a id="_idIndexMarker069"/>screenshot of the specified web page element. Here, <code>path</code> (an optional argument) is a string with the screenshot file's relative path and name (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/takeelementscreenshot.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/takeelementscreenshot.html</a>).</li>
				<li><code>.switchToIframe(selector)</code>: Switches the browsing context of the test to the specified <code>&lt;iframe&gt;</code> (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/switchtoiframe.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/switchtoiframe.html</a>).</li>
				<li><code>.switchToMainWindow()</code>: Switches the browsing context of the test from an <code>&lt;iframe&gt;</code> back to the main window (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/switchtomainwindow.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/switchtomainwindow.html</a>).</li>
				<li><code>.setNativeDialogHandler(fn(type, text, url)[, options])</code>: Specifies a handler function to deal with native dialogs triggered during the test run. Here, <code>fn(type, text, url)</code> can be a function or a client function that will be invoked whenever a native dialog is triggered (<code>null</code> to delete the native dialog handler). The handler function can utilize three arguments: <code>type</code>, which is a string with the type of the native dialog (<code>confirm</code>, <code>alert</code>, <code>prompt</code>, or <code>beforeunload</code>); <code>text</code>, which is a string with the dialog message text; and <code>url</code>, which is a string with the URL of the page that triggered the dialog (used to check whether the dialog was called from the main window or an <code>&lt;iframe&gt;</code>) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/setnativedialoghandler.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/setnativedialoghandler.html</a>).</li>
				<li><code>.getNativeDialogHistory()</code>: Provides <a id="_idIndexMarker070"/>a history of the native dialogs that were triggered (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/getnativedialoghistory.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/getnativedialoghistory.html</a>).</li>
				<li><code>.resizeWindow(width, height)</code>: Resizes a window to fit the provided width and height, where <code>width</code> is the value of the new width (in pixels) and <code>height</code> is <a id="_idIndexMarker071"/>the value of the new height (in pixels) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/resizewindow.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/resizewindow.html</a>).</li>
				<li><code>.resizeWindowToFitDevice(deviceName[, options])</code>: Resizes the window to fit the screen of the specified mobile device, where <code>deviceName</code> is a string with the device name (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/resizewindowtofitdevice.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/resizewindowtofitdevice.html</a>).</li>
				<li><code>.maximizeWindow()</code>: Maximizes the browser window (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/maximizewindow.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/maximizewindow.html</a>).</li>
				<li><code>.wait(timeout)</code>: Pauses a test execution for a specified period of time. Here, <code>timeout</code> is the length of the pause duration (in milliseconds) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/wait.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/wait.html</a>).</li>
			</ul>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/>Assertions</h2>
			<p>TestCafe allows you to <a id="_idIndexMarker072"/>verify elements, page properties, and parameters (equals, contains, greater, match, and so on). To write assertions, use the test controller's <code>t.expect</code> method, followed by an assertion method that accepts an expected value and optional arguments; <code>message</code> is the assertion message string that shows up in the report if the test fails and <code>options</code> is an object with a set of options containing supplementary parameters for the assertion. Here are all the assertion methods available in TestCafe out of the box:</p>
			<ul>
				<li><code>.expect(actual).eql(expected[, message][, options])</code>: Verifies that the <code>actual</code> value is<a id="_idIndexMarker073"/> equal to the <code>expected</code> value. Here, <code>actual</code> is any type of comparison value and <code>expected</code> is any type of expected value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/eql.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/eql.html</a>).</li>
				<li><code>.expect(actual).notEql(expected[, message][, options])</code>: Verifies that the <code>actual</code> value does not equal the <code>expected</code> value. Here, <code>actual</code> is any type of<a id="_idIndexMarker074"/> comparison value and <code>expected</code> is any type of value that is expected not to be equal to <code>actual</code> (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/noteql.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/noteql.html</a>).</li>
				<li><code>.expect(actual).ok([message][, options])</code>: Verifies that the <code>actual</code> value is <code>true</code>. Here, <code>actual</code> is any type of value tested in the assertion (the assertion will pass if the actual value is <code>true</code>) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/ok.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/ok.html</a>).</li>
				<li><code>.expect(actual).notOk([message][, options])</code>: Verifies that the <code>actual</code> value is <code>false</code>. Here, <code>actual</code> is any type of value tested in the assertion (the assertion will pass if the actual value is <code>false</code>) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notok.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notok.html</a>).</li>
				<li><code>.expect(actual).contains(expected[, message][, options])</code>: Verifies that the <code>actual</code> value contains the <code>expected</code> value. Here, <code>actual</code> is any type of comparison value and <code>expected</code> is any type of expected value (the assertion will pass if the actual value contains the expected value) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/contains.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/contains.html</a>).</li>
				<li><code>.expect(actual).notContains(expected[, message][, options])</code>: Verifies that the <code>actual</code> value contains the <code>expected</code> value. Here, <code>actual</code> is any type of comparison value, and <code>expected</code> is any type of expected value (the assertion will pass if the actual value does not contain the expected value) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notcontains.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notcontains.html</a>).</li>
				<li><code>.expect(actual).typeOf(typeName[, message][, options])</code>: Asserts that the <code>actual</code> value type is <code>typeName</code>. Here, <code>actual</code> is any type of comparison value and <code>typeName</code> is <a id="_idIndexMarker075"/>a string of the expected type of an actual value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/typeof.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/typeof.html</a>).</li>
				<li><code>.expect(actual).notTypeOf(typeName[, message][, options])</code>: Asserts <a id="_idIndexMarker076"/>that the <code>actual</code> value type is not <code>typeName</code>. Here, <code>actual</code> is any type of comparison value and <code>typeName</code> is a string of the type of the actual value tha<a id="_idTextAnchor037"/>t causes an assertion to fail (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/nottypeof.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/nottypeof.html</a>).</li>
				<li><code>.expect(actual).gt(expected[, message][, options])</code>: Verifies that the <code>actual</code> value is greater than the <code>expected</code> value. Here, <code>actual</code> is the number tested in the assertion (the assertion will pass if the actual value is greater than the expected value) and <code>expected</code> is any type of expected value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/gt.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/gt.html</a>).</li>
				<li><code>.expect(actual).gte(expected[, message][, options])</code>: Verifies that the <code>actual</code> value is greater than or equal to the <code>expected</code> value. Here, <code>actual</code> is a number tested in the assertion (the assertion will pass if the actual value is greater than or equal to the expected value), and <code>expected</code> is any type of expected value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/gte.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/gte.html</a>).</li>
				<li><code>.expect(actual).lt(expected[, message][, options])</code>: Verifies that the <code>actual</code> value is less than the <code>expected</code> value. Here, <code>actual</code> is the number tested<a id="_idIndexMarker077"/> in the assertion (the assertion will pass if the actual value is less than the expected value) and <code>expected</code> is any type of expected value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/lt.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/lt.html</a>).</li>
				<li><code>.expect(actual).lte(expected[, message][, options])</code>: Verifies that the <code>actual</code> value is less than or equal to the <code>expected</code> value. Here, <code>actual</code> is the<a id="_idIndexMarker078"/> number tested in the assertion (the assertion will pass if the actual value is less than or equal to the expected value) and <code>expected</code> is any type of expected value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/lte.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/lte.html</a>).</li>
				<li><code>.expect(actual).within(start, finish[, message][, options])</code>: Verifies that the <code>actual</code> value is within a specified range from start to finish (bounds are inclusive). Here, <code>actual</code> is a number, <code>start</code> is the number for the lower range (inclusive), and <code>finish</code> is the number for the upper range (inclusive) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/within.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/within.html</a>).</li>
				<li><code>.expect(actual).notWithin(start, finish[, message][, options])</code>: Verifies that the <code>actual</code> value is not within the specified range from start to finish (bounds are inclusive). Here, <code>actual</code> is a number, <code>start</code> is the number for the lower range (inclusive), and <code>finish</code> is the number for the upper range (inclusive) (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notwithin.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notwithin.html</a>).</li>
				<li><code>.expect(actual).match(re[, message][, options])</code>: Verifies that the <code>actual</code> value matches the <code>re</code> regular expression. Here, <code>actual</code> is any type of comparison value <a id="_idIndexMarker079"/>and <code>re</code> is a regular expression that is expected to match the actual value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/match.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/match.html</a>).</li>
				<li><code>.expect(actual).notMatch(re[, message][, options])</code>: Verifies that the <code>actual</code> value does not match the <code>re</code> regular expression. Here, <code>actual</code> is any <a id="_idIndexMarker080"/>type of comparison value and <code>re</code> is a regular expression that is expected not to match the actual value (<a href="https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notmatch.html">https://devexpress.github.io/testcafe/documentation/reference/test-api/testcontroller/expect/notmatch.html</a>).</li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor038"/>User roles</h2>
			<p>TestCafe has a built-in user role<a id="_idIndexMarker081"/> mechanism that emulates user actions for logging in to a website. It also saves the logged-in state of each user in a separate role that can be reused later on in any part of your tests to switch between user accounts. This approach gives access to some unique features:</p>
			<ul>
				<li>Login actions are not duplicated upon switching to a previously used role during the same session. So, for example, if you activate a role in the <code>beforeEach</code> hook, the login actions will run only once before the first test. All further tests will just reuse the existing authentication data.</li>
				<li>When you switch roles, the browser automatically navigates back to the page where the switch happened, so there is no need to additionally open any URLs for a new role (this behavior can be disabled if required).</li>
				<li>If during a test you log in to several websites, authentication data from cookies and browser storage is saved in the active role. When switching back to this role in the same test, you will be logged in to all the websites automatically.</li>
				<li>An anonymous built-in role that logs you out of all accounts.</li>
			</ul>
			<p>Let's have a look at a practical example of creating and using roles.</p>
			<p>To create and initialize a<a id="_idIndexMarker082"/> role, we will need to use a <code>Role</code> constructor. Then, the login page URL and actions needed to log in should be passed to <code>Role</code>. This is shown in the following code block:</p>
			<pre>const { Role, Selector } = require('testcafe');const regularUser = <strong class="bold">Role</strong>('https://test-site.com/login', async (t) =&gt; {    await t.typeText('.login', 'TestUser')        .typeText('.passwor<a id="_idTextAnchor039"/>d', 'testuserpass')        .click('#log-in');});const admin = Role('https://test-site.com/login', async (t) =&gt; {    await t.typeText('.login', 'TestAdmin')        .typeText('.password', 'testadminpass')        .click('#log-in');});const linkLoggedInUser = Selector('.link-logged-in-user');const linkLoggedInAdmin = Selector('.link-logged-in-admin');fixture('My first test Fixture').page('https://test-site.com');test('Test login with three users', async (t) =&gt; {    await t.useRole(regularUser)        .expect(linkLoggedInUser.exists).ok()        .useRole(admin)        .expect(linkLoggedInUser.exists).notOk()        .expect(linkLoggedInAdmin.exists).ok()        .useRole(Role.anonymous())        .expect(linkLoggedInUser.exists).notOk()        .expect(linkLoggedInAdmin.exists).notOk();});</pre>
			<p>After you create all the required <a id="_idIndexMarker083"/>roles, you can switch between them anytime; roles are shared across tests and fixtures. Roles can even be created in a separate file and then used in any test fixture that references (requires or imports) this file.</p>
			<p>To sum up, in this section, we reviewed the TestCafe API and the main methods that it provides. We also learned how to select elements, conduct assertions, and utilize user roles to switch between different accounts. Now, let's take a look at how custom client-side code can be executed in TestCafe to give us even more control over the browser.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor040"/>Executing custom client-side code</h1>
			<p>With TestCafe, you <a id="_idIndexMarker084"/>can create client functions that can run on the client side (in the browser) and return any serializable value. For example, you can obtain the URL of the current page, set cookies, or even manipulate any elements on the page.</p>
			<p>In some complex scenarios, TestCafe helps you write code to be executed on the tested page. Here are several examples of tasks that can be done with custom client-side code:</p>
			<ul>
				<li>Get elements from the web page for further actions. TestCafe allows you to create selectors based on client-side code that returns DOM nodes. You can write this code in the server-side test and TestCafe will run these functions in the browser when it needs to locate an element:<pre>const { Selector } = require('testcafe');const testElement = Selector(() =&gt; {    return document.querySelector('.test-class-name');});await t.click(testElement);</pre></li>
				<li>Obtain data from a client function that returns any serializable object from the client side (including any objects that can be converted to JSON). Unlike selectors, test code can access the object this client function returns. Usually, the data obtained from client functions is used to assert different page parameters. Here is an example of getting and verifying a page URL:<pre>const { ClientFunction } = require('testcafe');const getPageUrl = ClientFunction(() =&gt; {    return window.location.href;});await t.expect(getPageUrl).eql('https://test-site.com');</pre></li>
				<li>Inject custom code into the tested page. Injected scripts can then be used to add helper functions <a id="_idIndexMarker085"/>or to mock browser API:<pre>fixture('My second test Fixture')    .page('https://test-site.com')    .clientScripts(        'assets/jquery-latest.js',        'scripts/location-mock.js'    );</pre><p class="callout-heading">Note</p><p class="callout">It is recommended that you avoid changing the DOM with custom client-side code. A rule of thumb is to use client-side code only to explore the page, find and return information to the server.</p></li>
			</ul>
			<p>You can find more examples of client-side scripts and injections<a id="_idIndexMarker086"/> at the following links: </p>
			<ul>
				<li><a href="https://devexpress.github.io/testcafe/documentation/guides/basic-guides/obtain-client-side-info.html">https://devexpress.github.io/testcafe/documentation/guides/basic-guides/obtain-client-side-info.html</a>.</li>
				<li><a href="https://devexpress.github.io/testcafe/documentation/guides/advanced-guides/inject-client-scripts.html">https://devexpress.github.io/testcafe/documentation/guides/advanced-guides/inject-client-scripts.html</a>.</li>
			</ul>
			<p>As we just discovered, TestCafe client functions are quite useful for different browser manipulations and getting additional data to verify in our tests.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor041"/>Summary</h1>
			<p>In this chapter, we learned how TestCafe work<a id="_idTextAnchor042"/>s under the hood. We got acquainted with the architecture of TestCafe, saw how it performs on client and server sides, and learned about the strategies for selecting elements, actions, assertions, roles, and custom client-side code.</p>
			<p>All of this will be used in the upcoming chapters to write our own suite of end-to-end tests. In addition to that, you can always use this chapter as a reference to search for any particular method or assertion and see how it's called and what it does.</p>
			<p>Now, let's move on from the main methods and functions of TestCafe to more practical aspects, such as setting up the testing environment for our future automated tests.</p>
		</div>
	</body></html>