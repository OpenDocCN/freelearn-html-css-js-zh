- en: Writing End-to-End Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml),
    *Setting Up Development Tools*, we successfully bootstrapped our project. In this
    chapter, we'll begin the development of our user directory API, which simply consists
    of **Create, Read, Update, and Delete** (**CRUD**) endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The Importance
    of Good Code*, we discussed the importance of testing and briefly outlined the
    principles and high-level processes of **Test-Driven Development** (**TDD**).
    But theory and practice are two very different things. In this chapter, we will
    put the TDD approach into practice by first writing **End-to-End** (**E2E**) tests,
    and then using them to drive the development of our API. Specifically, we will
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about different types of test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice implementing a TDD workflow, specifically following the **Red-Green-Refactor**
    cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write E2E tests with **Cucumber** and **Gherkin**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding different types of test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s learn about the different types of tests and how they all fit
    into our project''s workflow. The first thing to note is that some tests are more
    technically-focused, while others are more business-focused; some tests are only
    concerned with a very small part of the whole system, while others test the system
    as a whole. Here''s a brief overview of the most common types of tests you''ll
    encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These test the smallest testable parts of an application, called **units**.
    For example, if we have a function called `createUser`, we can write a unit test
    that tests that the function always returns a promise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With unit tests, we are only concerned with the function of the unit, *independent
    of external dependencies*. If the unit has external dependencies, such as a database,
    we must substitute the real database client with a fake one. This fake client
    must be able to mimic the behavior of the database adequately so that, from the
    perspective of the unit under test, the fake behaves in the same way as the authentic
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will talk more about fakes later, but the important takeaway is that unit
    tests test a small and specific component of the whole code base, using minimal
    (or no) dependencies, and without calling other parts of the application (that
    is, there are no **side-effects**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Integration tests:** These test whether different units can work together
    as a single, larger ensemble. To continue our example, the `createUser` function
    may rely on the `Auth` module to check whether the client has permission to create
    the user. We can create a test case where `createUser` is called with an unauthenticated
    client, and assert that the function throws an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests test the integration between two or more units and ensure
    they are compatible. In our example, if the `Auth` module changes the data structure
    of its response payload, and we forget to update our `createUser` method to consume
    this new data structure, the integration test should fail, alerting us to fix
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**E2E/functional tests**: These test the flow of an application from start
    to finish, acting as if we are the end consumers. In our example, we''d attempt
    to create a new user by actually sending a `POST` request to the `/users` endpoint,
    because that''s how our end users would actually interact with our API. After
    the call, we''d check the database to ensure that a user document is indeed created
    and conforms to the expected data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface** (**UI**) **tests**: For applications that include a frontend
    component, UI tests are automated tests that mimic the behavior of real users
    interacting with the UI, such as scrolling and clicking. You may use generic browser
    automation tools such as **Selenium** ([https://www.seleniumhq.org/](https://www.seleniumhq.org/)),
    or framework-specific tools such as **Enzyme** ([airbnb.io/enzyme/](http://airbnb.io/enzyme/),
    used for React applications).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual tests**: These are tests that cannot be automated. Manual tests should
    be kept to a minimum as they are not deterministic and there''s a high cost to
    running them. Apart from catching bugs, manual tests can also unearth scenarios
    that are unintuitive and/or bad for **user experience** (**UX**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance tests**: These differ from the other tests that have already been
    outlined because they are more focused on business needs. They are a list of business
    requirements (as opposed to functional requirements), laid out by the business
    stakeholders, that the platform must fulfill. For example, one such requirement
    might read "95% of all visitors must be able to load the page within 3 seconds".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a purely technical requirement, but it drives the technical decisions
    that are to be made. For example, the development team may now be required to
    install analytics libraries to collect data on the load times of the site for
    all visitors, and to prioritize optimizing the site over developing new features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Parts of the acceptance tests may be written in a **Behavior-Driven Development**
    (**BDD**) format, which focuses on the steps that an actual user may take when
    interacting with the platform. One such requirement may read "Given a user has
    successfully authenticated and he is on a product page, when he clicks the Add
    to Cart button, then that product should be added to the cart". Then, when this
    requirement is verified, either through automated and/or manual testing, it would
    pass the acceptance test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Think of acceptance tests as a final stage of the development process, when
    the business stakeholder accepts the work as complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Structuring our test suite with the testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is the most **granular** form of testing, as it addresses the lowest
    possible level of detail of your project. Unit tests give you confidence in a
    very small part of your application, but are also the quickest to run, as they
    do not depend on other modules, databases, filesystems, or the network.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you can set up your unit tests to run every time a change is made
    to your code; this will provide timely feedback as you develop.
  prefs: []
  type: TYPE_NORMAL
- en: Granularity decreases as you move to integration tests and E2E tests. These
    tests give you confidence in a larger part of your project, but are also slower
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we design our test suite, we should find a balance between writing
    unit, integration, and E2E tests. In [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml),
    *The Importance of Good Code*, we briefly mentioned the concept of the **Testing
    Pyramid**; let's apply it here and make sure that our test suite contains a lot
    of unit tests, fewer integration tests, and the fewest E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a new feature, write your E2E tests first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common misinterpretation of TDD and the Testing Pyramid is that unit tests
    are more important than E2E tests, and that you should start writing unit tests
    *first*. This is wrong. TDD only requires you to write tests first, but does not
    specify the type of test you must use. The Testing Pyramid simply encourages you
    balance your test suite to have more granular tests; it does not specify the importance
    or order for which you test.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when implementing a new feature, E2E tests are the most important tests,
    and should be the first test you write when composing your test suite. E2E tests
    mimic how your end users would interact with the project, and are often tied to
    the business requirements. If your E2E tests pass, it means the feature you are
    developing is working.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it's often impractical to write your unit tests first. A unit tests
    concerns itself with implementation details, but there are many ways to implement
    a set of features and our first solutions are often substandard. It is likely
    to undergo many iterations of changes before it becomes stable. Since unit tests
    are coupled to the implementation they are testing, when the implementation changes,
    the unit tests would be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when implementing new features, E2E tests should be written first;
    unit and integration tests should be written only after the implementation has
    settled.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, E2E tests and unit tests are not mutually exclusive. For example, if
    you are writing a library that exports as single utility function, then your E2E
    tests *are* your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: This is because your end users would interact with your unit directly, making
    E2E and unit tests one and the same. Therefore, always keep your target audience
    in mind, and think about how they'll interact with your project. Use the appropriate
    type of tests to define contracts/interfaces with the end consumers, and use these
    test to drive your development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are developing new features, this chapter will focus on E2E tests.
    Unit and integration tests will be covered in the next chapter, *TDD Part II:
    Unit/Integration Tests*; and UI testing with Selenium will be covered in [Chapter
    15](76ad50ef-1134-4672-88e1-c2700f63268f.xhtml), *E2E Testing with React*. Manual
    tests are not programmable and thus earn only a brief mention at the end of this
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Following a TDD workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's examine a typical TDD workflow, and see how the different types
    of tests fit into it.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering business requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TDD workflow starts with the product manager gathering **business requirements**
    from the business stakeholders, and then liaising with the technical team to refine
    these requirements, taking into account feasibility, costs, and time constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of the requirements should be small. If the application is large,
    the product manager should prioritize the requirements by importance and urgency,
    and group them into phases. The first phase should contain the highest priority
    requirements, which would be implemented first.
  prefs: []
  type: TYPE_NORMAL
- en: These requirements should be well-defined and unambiguous, so that there's no room
    for (mis)interpretation. This means they should quantified as much as possible.
    For example, instead of "the app must load quickly", it should say "the app must
    load within 1 second on an iPhone 5S".
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the requirement-gathering stage should be a joint-process involving
    many teams. Developers, designers, product managers, and business owners all provide
    different expertise and points of view. By allowing everyone to give feedback
    on the scope, timeline, and overall business strategy, it could help the team
    set realistic expectations and avoid common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Formalizing requirements through documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once everyone has agreed on the requirements for the current phase, it is extremely
    important that they are formally documented. When everyone involved understands
    the requirements, it''s very tempting to not write them down; after all, it''s
    a boring chore that no one wants to do. One may even argue that it slows down
    development unnecessarily. However, we must fight against that temptation and
    be disciplined because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**People have bad memories**: I once read a tongue-in-cheek comment from an
    online discussion that said "Good programmers have good minutiae memory. Great
    programmers have good gestalt memory. Legendary programmers have no memory at
    all." Don''t rely on your memory—write down the requirements!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It prevents misinterpretation.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A formalized requirement provides a** **S****ingle Source of Truth** (**SSoT**):
    In development, change is often the only constant. It is inevitable that requirements
    will change. 99% of the problems with requirement changes lies in not communicating
    that change with everyone, resulting in different team members having different,
    possibly conflicting, snapshots of the requirements. By having a single document
    that acts as an SSoT, we can ensure everyone has access to the latest, *and the
    same*, information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A formalized requirement can be improved**: If there are areas of ambiguity,
    the language of the requirement can be revised to be more explicit. If someone
    forgot an important point, they can add it as an addendum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, having a set of formal requirements is only helpful if it is kept up
    to date. It is very important that a single person is put in sole charge of maintaining
    the requirements document. Otherwise, everyone may assume someone else will update
    it, but then no one does. Out-of-date requirements may be worse than no requirements
    at all, if the old version conflicts with the most up-to-date version.
  prefs: []
  type: TYPE_NORMAL
- en: However, this does not mean the person in charge has to be the one to actually
    update the document itself; he/she may appoint someone more suitable to do the
    task. But the point is that, ultimately, it is his/her responsibility to make
    sure the requirements are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Refining requirements into specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements outline the high-level goals that the business wants the application
    to achieve, but it does not have sufficient details for developers to start implementation
    straight away. Requirements are imprecise and do not translate well into code,
    which is very explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, developers need to understand the overall business goal, and the current
    sets of requirements, and produces a more detailed set of **technical specifications**. A
    specification should contain sufficient technical details needed by developers
    to begin implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the overall goal of the project is to "Create a web application
    that allows users to log in and update their profiles."; and the first requirement
    may be to "create an API server with an endpoint to create new users". You should
    now think about how to structure the application. For example, you may split the
    application into the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: To allow users to register and log in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profile**: To allow users to edit their own profile and view the profile
    of others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database(s)**: To store user data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API server**: The interface between our internal services and external consumers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the structure of the application on the back of your mind, we can now move
    on to writing the specification. As we've already mentioned in [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The
    Importance of Good Code*, the best specifications are tests, so let's write some
    tests!
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests as specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tests are the best form of specification because:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be run, which means you can programmatically verify your implementation
    against your specification. If the tests pass, your implementation conforms to
    the specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are an integral part of the code (that is, **S****pecification-as-Code**
    (**SaC**)). There is less chance that your specification becomes outdated, because
    if it does, the test would fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we can write our technical specifications as E2E tests, which then
    drives the TDD development process.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that it's very hard for a single developer to be able to conjure up
    an exhaustive list of scenarios and edge cases to test for; we are bound to miss
    some. That's why it is important that the tests and code are inspected by multiple
    people. This may involve writing the test descriptions as a pair or mob, putting
    in place a code review workflow involving developers both within and outside the
    project. Doing so maximizes the value of the tests and ensures that they cover
    the most relevant edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as the first E2E test for our selected feature has been written, the
    TDD process can begin. We should now run the test, see it fail, implement the
    feature so it passes the test, and then refactor. Unit and integration tests should
    be written, where appropriate, to increase confidence in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for every test case until the current set of features has
    been fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Writing manual tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are developing our feature, the product manager should also be defining
    manual tests. Manual tests are required because not all requirements can be automated,
    and some may require real user data (for example, usability testing). For example,
    part of the acceptance criteria may be that "95% of users are able to find the
    settings page within 5 seconds". In these scenarios, manual testing is required.
  prefs: []
  type: TYPE_NORMAL
- en: Although we cannot automate this process, we can formalize it in a structured
    way. Instead of writing down the requirements in a text document, we can use **test
    case management tools**, such as TestLink ([testlink.org](http://testlink.org/)),
    as well as proprietary alternatives, such as TestRail ([gurock.com/testrail/](http://www.gurock.com/testrail/)),
    qTest ([qasymphony.com/software-testing-tools/qtest-manager/](https://www.qasymphony.com/software-testing-tools/qtest-manager/)),
    Helix TCM ([perforce.com/products/helix-test-case-management](https://www.perforce.com/products/helix-test-case-management)),
    Hiptest ([hiptest.net](https://hiptest.net/)), PractiTest ([practitest.com](https://www.practitest.com/)),
    and many more. These test case management systems help you define, run, and record
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Each test should contain a set of clear, unambiguous steps to follow. A group
    of testers, who, ideally, have no prior knowledge of the platform, would then
    be given the instructions, the expected results, and be asked whether the results obtained match
    the expected ones.
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, you may simply ask manual testers to poke around the application, or
    explore the API themselves, without being given any steps to follow. This is called **exploratory
    testing** and may be grouped under manual testing. The purpose of exploratory
    testing is to identify edge cases that were missed, identify unintuitive outcomes,
    or find bugs that may otherwise break the system.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inevitably, all applications, no matter how well tested, will have bugs and
    areas of improvement. An essential part of any workflow is to allow users to report
    bugs, raise issues, and ask questions. As an extension to this, we also need a
    system to triage these issues, prioritizing them based on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Impact**: How many users are impacted? How important are these users?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease**: How easy is it to fix?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Urgency**: How time-sensitive is this issue?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be done through platforms such as GitHub's issue trackers, Atlassian's
    JIRA, or similar software.
  prefs: []
  type: TYPE_NORMAL
- en: When a bug is reported, it should be reproduced and confirmed. Once confirmed,
    test cases that cover that scenario should be written to prevent regression in
    the future. For example, if the bug is that the `age` field is returned as a float,
    a test case should be written to test that the `age` field is always a positive
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the workflow, let's put it into practice!
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by selecting a small portion of our application and defining its requirements.
    We picked the Create User feature because many other features depend on it. Specifically,
    the feature requires us to create an API endpoint, `/users`, that accepts `POST`
    requests, and stores the JSON payload of the request (representing the user) into
    a database. In addition, the following constraints should be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: The user payload must include the email address and password fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user payload may optionally provide a profile object; otherwise, an empty
    profile will be created for them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our requirements, let's write our specification as E2E tests,
    using a tool called *Cucumber*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up E2E tests with Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber is an automated test runner that executes tests written in a **Domain-Specific
    Language** (**DSL**) called *Gherkin*. Gherkin allows you to write tests in plain
    language, usually in a behavior-driven way, which can be read and understood by
    anyone, even if they are not technically-minded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many Cucumber implementations for different languages and platforms,
    such as Ruby, Java, Python, C++, PHP, Groovy, Lua, Clojure, .NET and, of course,
    JavaScript. The JavaScript implementation is available as an npm package, so let''s
    add it to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to write the specification for our first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Features, scenarios, and steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Cucumber, you''d first separate your platform into multiple **features**;
    then, within each feature, you''d define **scenarios** to test for. For us, we
    can take the "Create user" requirement as one feature, and start breaking it down
    into scenarios, starting with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the client sends a `POST` request to `/users` with an empty payload, our
    API should respond with a `400 Bad Request` HTTP status code and a JSON object
    payload containing an appropriate error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client sends a `POST` request to `/users` with a payload that is not
    JSON, our API should respond with a `415 Unsupported Media Type` HTTP status code
    and a JSON response payload containing an appropriate error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client sends a `POST` request to `/users` with a malformed JSON payload,
    our API should respond with a `400 Bad Request` HTTP status code and a JSON response
    payload containing an appropriate error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will define more scenarios later, but let's focus on these three to get us
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Each feature should be defined, using the Gherkin language, within its own `.feature` file.
    So, let's create one now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's translate the scenarios for our Create User feature into Gherkin.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Gherkin, every non-empty line starts with a Gherkin **keyword** (although
    there are several common exceptions). We will go over the relevant keywords in
    more detail when we use them, but here''s a brief overview of each keyword and
    its uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Feature`: Specifies the name and description of the feature. A feature is
    just a way to group related scenarios together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scenario`: Specifies the name and description of the scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Given`, `When`, `Then`, `And`, `But`: Each scenario is made up of one or more
    **steps**, each corresponding to a JavaScript function that is to be executed
    by Cucumber. If, after executing all the steps, no errors were thrown, then the
    test is deemed to have passed. The five step keywords are equivalent; you should
    use the one that makes your test most readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Background`: Allows you to set up a common environment to execute all your
    scenarios. This saves you from defining duplicate set-up steps for all scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scenario Outline`: Allows you to define a template for multiple scenarios
    that differ only in certain values. This prevents specifying many scenarios/steps
    that are very similar to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Examples`: When using scenario outline, the `Examples` keyword allows you
    to specify values to plug into the scenario outline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"""`: Allows you to use **doc strings** to specify multiline strings as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: Allows you to specify more complex data tables as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@`: Allows you to group related scenarios together using **tags**. After tagging
    scenarios, you can instruct Cucumber to execute only those with a certain tag,
    or, conversely, exclude tests with certain tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#`: Allows you to specify comments, which will not be executed by Cucumber.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Visual Studio Code (VSCode), we recommend that you install
    the *Cucumber (Gherkin) Full Support* VSCode Extension ([github.com/alexkrechik/VSCucumberAutoComplete](https://github.com/alexkrechik/VSCucumberAutoComplete)),
    which provides syntax highlighting and snippet support.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying our feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s start defining our feature by adding a name and description to `spec/cucumber/features/users/create/main.feature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Writing our first scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll write our first scenario and steps. As a reminder, the scenario
    is "If the client sends a `POST` request to `/users` with an empty payload, our
    API should respond with a `400 Bad Request` HTTP status code, and a JSON object
    payload containing an appropriate error message".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have broken the scenario down into modular units called **steps** and prefixed
    them with the Gherkin keywords. Here, we've used the keywords `When`, `Then`, and `And`,
    although we could have used any of the five keywords; we chose these because it
    makes the specification more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, you can group steps into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Used to set up the environment in preparation for an action to be
    executed. Usually, you''d use the `Given` keyword to define setup steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action**: Used to execute an action, which is usually the event we are testing
    for. You''d typically use the `When` keyword to define action steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: Used to assert whether the actual outcome of the action is
    the same as the expected outcome. Usually, you''d use the `Then` keyword to define
    assertion steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, you can use the `And` and `But` keywords to chain multiple steps
    together and make the specification more readable. But, remember that all step
    keywords are functionally equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out our step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of Gherkin, we now have our specification written in plain English.
    Next, let's try to use Cucumber to run our specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Cucumber will look for a directory called `features` in the project''s
    root directory and run the `.feature` files it finds inside. Since we have placed
    our `main.feature` file inside the `spec/cucumber/features` directory, we should
    pass this path to Cucumber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The test result informs us that our tests are undefined. This is because Cucumber
    is not clever enough to parse the plain text specification and figure out how
    to run these tests. We must link these steps to actual JavaScript code, which,
    in the context of Cucumber, are called **step definitions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `steps` next to the `features` directory; here''s
    where we''ll define all our step definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining steps inside their own directory helps us to mentally dissociate steps
    from being tied to any particular feature, and keep steps as modular as possible.
    Create an `index.js` file within the `steps` directory and add the following placeholder
    step definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have the ESLint extension installed on your editor, you may see ESLint
    complain about arrow functions and function names. Normally, these would be valid
    problems, but this is not the case in our test files. Therefore, we should override
    the default configuration and turn these rules off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `spec/` directory, create a new `.eslintrc.json` file, and paste
    in the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will turn off the `func-names` and `prefer-arrow-callback` rules for all
    files inside the `spec/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Each step definition consists of the step keyword method (`When`/`Then` and
    so on), which takes in two parameters. The first one is the **pattern**, which
    is a string that is used to match the text in the feature specification with the
    step definition. The second parameter is the **code function**, which is a function
    that is run for that step.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, when Cucumber gets to the `When the client creates a POST request
    to /users` step in our scenario, it will try to run the function associated with
    the `When('the client creates a POST request to /users')` step definition, because
    the pattern matches the step description.
  prefs: []
  type: TYPE_NORMAL
- en: Running our scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we implement the logic behind each step definition, let's make sure our
    setup is working. By default, Cucumber will look for step definitions inside a
    root-level `features/` directory; since we placed our definitions in a different
    directory, we must use the `--require` flag to tell Cucumber where to find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `npx cucumber-js spec/cucumber/features --require spec/cucumber/steps` to
    trigger the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns with a `SyntaxError: Unexpected token import` error. This is because
    we are not using Babel to transpile the code before running it, and so the `import` ES6
    keyword is not supported. This is where the `@babel/register` package is useful:
    it allows us to instruct Cucumber to use Babel as the compiler to process our
    step definitions before running them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install the `@babel/register` package as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run `cucumber-js` again with the `--require-module` flag and it
    should be **able to find and run our step definitions:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, Cucumber would first execute all the step definition functions
    (`When` and `Then`), register the code function, and associate it with the corresponding
    pattern. Then, it will parse and run the feature files, attempting to match the
    string with step definitions that it has registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the test result reads `pending` because we have not implemented the code
    function for each step definition, which we will do in the next section. But before
    that, let''s first formalize our E2E test command into an npm script, to save
    us all that typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have set up the infrastructure for running E2E tests, it''d be a perfect
    time to commit our code. First, let''s create the `dev` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check out the new feature branch, `create-user/main`, and commit our
    changes to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Implementing step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our API server, we would need to run the server itself and send HTTP
    requests to it. There are many ways to send requests in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `request` method provided by Node's native `http` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the new Fetch Web API syntax: `fetch` is an improvement on the traditional `XMLHttpRequest`
    used to make **AJAX** (**Asynchronous JavaScript And XML**) requests from the
    client. We can use polyfills, such as `isomorphic-fetch` ([https://www.npmjs.com/package/isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)),
    which will allow us to use the same syntax on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a library, such as `request` ([https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)), `superagent` ([npmjs.com/package/superagent](https://www.npmjs.com/package/superagent)), `axios` ([npmjs.com/package/axios](https://www.npmjs.com/package/axios)),
    and many more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the native `http` module allows us to be as expressive as possible because
    it works at the lowest-level API layer; however, this also means the code is likely
    to be verbose. Using the Fetch API might provide a simpler syntax, but it will
    still have a lot of boilerplate code. For example, when we receive a response,
    we must explicitly tell our code how we want to parse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our use cases, using a library is probably the most appropriate. Libraries
    are more opinionated but they also save you from writing the same lines repeatedly;
    for example, response payloads are parsed automatically in most libraries. Of
    all the available libraries, I''ve found that `superagent` is the most suitable
    for our tests because it allows you to compose a request by chaining multiple
    steps together. To demonstrate, the following is the example given in `superagent`''s `README.md`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to initiate a request object at the beginning, and each step
    in our scenario can simply modify that object to collectively compose the final
    request that we send to our test API server. Without further ado, let''s install
    `superagent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Calling our endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first call to our server, we have broken it down into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`When the client creates a POST request to /users`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`And attaches a generic empty payload`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`And sends the request`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first step, we will create a new request object and save it as a file-scoped
    variable, making it available to be accessed by subsequent steps. In the second,
    we will attach an empty payload to the request; however, this is already the default
    behavior of `superagent`, so we can simply `return` from the function without
    doing anything. In the third step, we will send the request and save the response
    in another variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now update the start of your `spec/cucumber/steps/index.js` file
    to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our third step definition involves sending a request to the server and waiting
    for a response; this is an asynchronous operation. To ensure the next step won't
    run before this asynchronous operation is complete, we can pass a `callback` function
    into the code function as its last parameter. Cucumber will wait for the `callback`
    function to be called before moving on to the next step. Here, we are executing
    the `callback` only after the result has been returned and we have saved it to
    the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we run our E2E tests again, the first three steps should pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Asserting results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s move on to our next step definition, which is an assertion step.
    In there, we should assert that the response from our server should have a `400`
    HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with our API server running in the background, run our E2E tests again.
    You should see the result of the second step changing from `pending` to `failed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It fails because our API is currently always returning the `Hello World` string with
    the HTTP status code of `200`, regardless of what the request is. But this is
    nothing to be concerned about! Writing a failing test is the first step of the
    TDD workflow; now, we just need to write the minimum amount to code to make the
    test pass.
  prefs: []
  type: TYPE_NORMAL
- en: To make our fourth step pass, we must check the method and path of the `req`
    object in the `requestHandler` function, and if it matches `POST` and `/users`,
    respectively, we will send back a `400` response.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we know the structure of the `req` object? We can use `console.log` to
    print it onto the console, but the structure of objects such as `req` and `res` are
    complex and the output is going to be hard to read. Instead, we should use a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Using a debugger for Node.js debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **debugger** is a tool that allows us to pause the execution of the code at
    certain **breakpoints** and examine any variables that are accessible within that
    scope at the time. For us, we want to pause the execution inside our server's `requestHandler` method
    to enable us to examine the `req` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chrome DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All modern browsers have a debugger built into them. Firefox has Firebug and
    Chrome has Chrome DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/472b461f-84d2-47e8-9586-bfe4b2a0c3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: The debugger in Chrome is available under the Sources tab of Chrome DevTools.
    We've set a breakpoint on line 3 and our script has paused there. While it is
    paused, we can access variables within the scope, which include local and global
    scope, as well as scope available due to closures. It also lists out all our breakpoints
    so we can activate/deactivate them easily.
  prefs: []
  type: TYPE_NORMAL
- en: To use Chrome DevTools for Node.js debugging, simply pass in the `--inspect` flag
    when you run `node`, then navigate to `chrome://inspect/#devices` in Chrome, and
    click on the Open dedicated DevTools for Node link, which will open the debugger
    in a new window.
  prefs: []
  type: TYPE_NORMAL
- en: Using ndb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On July 22, 2018, Google released **ndb** ([https://github.com/GoogleChromeLabs/ndb](https://github.com/GoogleChromeLabs/ndb)),
    an "improved" debugger that is based on Chrome DevTools, and uses **Puppeteer** ([github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer))
    to interact with **Chromium** over the **DevTools Protocol**. It requires at least
    Node.js v8.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try it out by installing it locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you may also have to install the `windows-build-tools` package
    in order to compile native dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can run the `ndb` binary with `npx`, and a new window will pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1480d634-dec7-4990-86a7-2783e9c88abc.png)'
  prefs: []
  type: TYPE_IMG
- en: ndb comes with its own integrated terminal, which will hook onto any node processes
    that you run from it.
  prefs: []
  type: TYPE_NORMAL
- en: While using Chrome DevTools and/or ndb provides several unique benefits, such
    as the availability of the Console, Memory, and Profile tabs, I'd still recommend
    using the debugger that comes with your IDE or code editor, simply because there's
    less context switching that comes with switching between different tools.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using Visual Studio Code as a code editor for JavaScript projects,
    and thus we will use the VSCode editor to illustrate our workflow; you are, however,
    free to use the IDE or editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Visual Studio Code debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up `src/index.js` on VSCode. If you hover your mouse to the left of the
    line numbers, you'll see some small, dimmed, red circles appear; you can click
    on the circle to insert a breakpoint on that line. This means whenever the script
    is executing and reaches that line, it will pause there. This allows us to examine
    the variables available within scope at that point. Go ahead and set the breakpoint
    at line 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use the `debugger` statement, which has exactly the same effect
    as setting a breakpoint. The only difference is that the `debugger` statement
    would now be part of the code, which is usually not what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''ve set the breakpoint, go to the Debugger tab in your editor. Click
    the Start Debugging button (usually this looks like the "Play" button: ►); this
    will execute the current file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc4f4b1e-7457-423f-b222-1200442e21ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The debugger throws an error because it doesn''t recognize the ES6 modules'' `import`
    syntax. This is because we are running the debugger on the source file directly,
    instead of the compiled file produced by Babel. To instruct VSCode to process
    modules, we can do one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `@babel/node` package and instruct VSCode to execute our file using
    `babel-node`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruct VSCode to add the `--experimental-modules` flag when running Node.
    This has been supported since Node v8.5.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do either of these, we need to add configurations to the VSCode debugger.
    Configurations in VSCode are defined as JSON objects inside a `launch.json` file.
    To edit the `launch.json` file, click the cogwheel button (![](img/f64144d2-6235-4f3c-a734-7c1a938ab8c3.png))
    near the top. Then, paste in the following JSON object, which will provide us
    with both configurations mentioned before, as well as an option to run the program
    as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, also remember to install the `@babel/node` package as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Retaining line numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use `babel-node` with the VSCode debugger, we also need to enable the `retainLines`
    option in Babel, which retains the line numbers between the source code and the
    built files. If we don't do this, VSCode's debugger would set the breakpoints
    at the incorrect lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we only want to retain lines when debugging our code; when we are
    building our application, we want it to be formatted sensibly. To do this, we
    can update our `.babelrc` to apply the `retainLines` option only when the `BABEL_ENV`
    environment variable is set to `"debug"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open up the `launch.json` file again and add the following to the Babel
    Node configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Examining the req object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, stop your API server (if you''re running it), go back to `src/index.js`,
    open up the Debug panel, select one of the two configurations we just defined,
    and click the Start Debugging button (►). This time, you should see it succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7091a724-8d80-4836-8cec-adfb401137c6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do not see the configuration in the dropdown, try closing and restarting
    Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: In a new tab, navigate to `localhost:8080`. This time, you won't see our `Hello,
    World!` text; this is because our server hasn't provided a response yet! Instead,
    it has paused at the breakpoint we set.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left-hand side, we can see a tab called VARIABLES, and here we can see
    all the local, closure, and global variables available at our breakpoint. When
    we expand the `req` variable, we''ll find the `method` and `url` properties, which
    are exactly what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb54222b-1e55-4329-9bb8-dd69941134eb.png)'
  prefs: []
  type: TYPE_IMG
- en: I'd encourage you to spend a few minutes exploring the structure of the `req` and `res` objects.
  prefs: []
  type: TYPE_NORMAL
- en: We've added several VSCode debugger configurations and should commit these changes
    to our Git repository. The VSCode configurations are, however, not part of our
    Create User feature, and should be committed directly to the `dev` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Making work-in-progress (WIP) commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, we have already made some changes related to our Create User feature,
    and we can't check out the `dev` branch unless we `git commit` or `git stash`
    these changes. Ideally, we should commit the entire Create User feature together;
    it is not clean to have **work-in-progress** (**WIP**) **commits** in our Git
    history tree.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this dilemma, we can use `git stash`, but it can be quite confusing
    and you risk losing your work. Instead, we are going to commit the WIP changes
    now and amend the commit later with the full implementation. We can do this because
    we are working on our local feature branch, not one of the permanent `dev` or
    `master` branches. This means that as long we do not push our changes onto the
    remote repository, no one else will know about the WIP commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git commit` our WIP changes related to our Create User feature on the `create-user/main`
    branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git checkout` the `dev` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@babel/node` package once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git commit` the VSCode debugger configuration changes onto the `dev` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git checkout` the `create-user/main` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git rebase` the `create-user/main` branch onto the `dev` branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to work on the feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `git add` and `git commit --amend` to commit our implementation code in
    the existing commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `yarn install` to make sure all the packages are linked, especially those
    that are present in the `create-user/main` branch but not the `dev` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following that workflow, we should execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Asserting the correct response status code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to use the debugger to examine the structure of complex
    objects, we are ready to implement the logic to check for the status of the response.
    To make our second test pass, we must send back a response with a `400` HTTP status
    code. With TDD, we should write the minimum amount of code that is required to
    make the test pass. Once the test passes, we can then spend some time refactoring
    the code to make it more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward piece of logic to make the test pass is to simply
    check that the `req` object''s `method` and `url` match exactly with `''POST''`
    and `''/users''`, and return with a `400` HTTP status code specifically for this
    scenario. If they do not match, send back the `Hello World!` response as before.
    After making the change, the `requestHandler` function should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart our API server and run the E2E tests; the first four steps should
    now pass.
  prefs: []
  type: TYPE_NORMAL
- en: You ain't gonna need it (YAGNI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the previous logic will indiscriminately return a `400` response,
    even if the payload is not empty. This is fine because the TDD process encourages
    you to write the minimum amount of code possible to make the tests pass, and so
    far we have only written a test for the empty payload scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind this is to ensure you are not falling into the trap of
    coding something that you don't need. This principle has been summarized in the
    phrase *"You ain't gonna need it,"* or **YAGNI**, which is a principle that originated
    from **extreme programming** (**XP**). The original states that you should "always
    implement things when you actually need them, never when you just foresee that
    you need them". You may have also heard the phrase *"do the simplest thing that
    could possibly work"* (**DTSTTCPW**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Being disciplined and sticking to this principle yields several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It ensures you follow TDD**: The tests are written before the code is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It saves you time**: If we preempt a feature and implement it before it is
    needed, it may turn out that the feature was not needed after all, or the feature
    has changed from what you had in mind when you implemented it, or other parts
    of the code have changed and you''d need to revise your original implementation.
    In any case, you would have spent time on something that is not useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even when you "know" for sure, make it a habit to follow the YAGNI principle.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the correct response payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next test requires that the payload is a JSON object. Since our server
    is replying with a JSON object, the `Content-Type` header should also reflect
    this. Therefore, in our step definition, we should check for both of these criteria.
    In the `spec/cucumber/steps/index.js`, update the step definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, restart our API server and we run the tests again; we should get a failing
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Red. Green. Refactor. Now we have a failing test (red), the next step is to
    make it pass (green). To do this, we must set the `Content-Type` header to `application/json`
    and provide a JSON object in the payload. Change our `requestHandler` function
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests again, and the first five tests should have passed.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the correct response payload content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, on to our last test. We need our error object payload to contain a `message`
    property that reads `"Payload should not be empty"`. So first, let''s implement
    our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the tests again and they should fail. Then, to make it pass, we need
    to pass a different object into the `res.end` method. Your `if` block should now
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our E2E tests again, they all pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember that the TDD process can be summed up with the phrase "Red. Green.
    Refactor". Here, we''ve written failing tests (red) and we''ve written some code
    to make them pass (green); therefore, the next step is to refactor, which, as
    a reminder, means restructuring and improving the quality of our implementation
    without changing its external behavior. This can mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing duplicated code (keeping things DRY)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our code more modular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing cyclomatic complexity, probably by breaking larger functions into smaller
    ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring should be done for our entire code base, which includes both the
    test code and our application code. Here, however, our application code is already
    quite neat and there are no obvious areas we can improve on at this time. Therefore,
    we can focus on improving our test code.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating contexts for each scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, we are storing the `request`, `result`, `error`, and `payload` variables
    at the top level of the file's scope.
  prefs: []
  type: TYPE_NORMAL
- en: But step definitions can be mixed and matched in different scenarios. For example,
    in another scenario where we are updating a specific user, we may want to test
    that the API returns with the correct status code when given a malformed request.
    Here, we can reuse the same step definition, `"our API should respond with a 400
    HTTP status code"`, but this time, the `error` variable may not be set if the
    previous steps were defined in a different file.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using file-scoped variables, we can instead pass a context object
    into each step and use it to keep track of the results. This context object would
    be maintained throughout the entire scenario and be available in every step. In
    the vocabulary of Cucumber, an isolated context for each scenario is called a **world**.
    The context object is exposed inside each step as the `this` object.
  prefs: []
  type: TYPE_NORMAL
- en: '*Within* the step definition''s code function, make sure you''re using arrow
    functions, which automatically bind `this`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can assign the response (regardless of it being a success or
    an error) to the more generically-named `this.response` and do the same for all
    other top-level file-scoped variables. After these changes, we should end up with
    the following `spec/cucumber/steps/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we refactor, we must be careful not to change the behavior of the existing
    code. Therefore, run our tests again to make sure they are still passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Making failure more informative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, if one of the assertions fails, we''re throwing a generic `Error`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test actually fails, the error message is not helpful because it doesn''t
    tell us what the actual result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can improve this by throwing an instance of `AssertionError` instead of just
    an instance of `Error`. `AssertionError` is a class provided by Node.js that allows
    you to specify the expected and actual outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, first import it from the `assert` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change our step definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when there''s an error, the error output is much more informative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can go one better and use the `equal` method from the `assert` module
    directly. Now, our step definition is much more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`assert.equal` will automatically throw an `AssertionError` if the parameters
    passed into it are not equal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now do the same for the step definition that checks for the response''s message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Removing hardcoded values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are only running these tests locally for now, we can simply hardcode
    the host name of our local API server, which we've set to `http://localhost:8080/`.
    However, it's never ideal to hardcode values into our code, as when we want to
    run these same tests on a different server, we'd have to edit the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can make use of environment variables, which we can set in an `.env` file at
    the project root directory and load it when we run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `.env` file and add in the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to load the environment variable into our code. We can use the `dotenv-cli` package
    ([https://www.npmjs.com/package/dotenv-cli](https://www.npmjs.com/package/dotenv-cli))
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `dotenv-cli` package, you simply place `dotenv` in front of the
    command you want to run, and it will load the variables from the `.env` file and
    then run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s change our `serve` and `test:e2e` npm scripts to use the `dotenv-cli` package.
    Note that we are using a double dash (`--`) to pass the flags into `cucumber-js`
    after `dotenv` has finished loading the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our code, remove the hardcoded hostname and replace it with the environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we should run the tests to ensure they pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the point of using environment variables is that different environments
    would have different settings; therefore, we shouldn''t track the `.env` file
    in Git. However, we do want to keep a record of what environment variables are
    supported, and so we should copy our `.env` file into a new `.env.example` file
    and add that into our Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now implemented a new feature that is functional for a single scenario;
    this is a good time to commit our code to the Git repository. Remember that we
    had previously made a WIP commit. So now, instead of running `git commit`, we
    should add an `--amend` flag, which will overwrite and replace our previous commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Validating data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have completed our first scenario, so let''s move on to our second and third
    scenarios. As a reminder, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the client sends a `POST` request to `/users` with a payload that is not
    JSON, our API should respond with a `415 Unsupported Media Type` HTTP status code
    and a JSON object payload containing an appropriate error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client sends a `POST` request to `/users` with a malformed JSON payload,
    our API should respond with a `400 Bad Request` HTTP status code and a JSON response
    payload containing an appropriate error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by adding the following scenario definition to the `spec/cucumber/features/users/create/main.feature`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first, third, and fifth steps are exactly the same as the ones
    in the previous scenario; therefore, Cucumber can re-use the step definition that
    we have already defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of the steps, however, we need to implement their corresponding
    step definitions. But since they are similar to the ones we''ve just defined,
    we can copy and paste them and make some small adjustments. Copy the following
    step definitions into `spec/cucumber/steps/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our tests again, the first three steps of the `Payload using
    Unsupported Media Type` scenario should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth step fails because, in our code, we are not specifically handling
    cases where the payload is a non-JSON or malformed object. Therefore, we must
    add some additional logic to check the `Content-Type` header and the actual contents
    of the request payload, which is much more involved than indiscriminately returning
    a `400` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For `POST` and `PUT` requests, the body payload can be quite large. So, instead
    of receiving the entire payload in one large chunk, it's better to consume it
    as a stream of smaller units. The request object, `req`, that is passed into the
    `requestHandler` function implements the `ReadableStream` interface. To extract
    the request body of `POST` and `PUT` requests, we must listen for the `data` and
    `end` events emitted from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new piece of data is received by our server, the `data` event will
    be emitted. The parameter passed into the event listener for the `data` event
    is a type of `Buffer`, which is simply a small chunk of raw data. In our case,
    the `data` parameter represents a small chunk of our JSON request payload.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the stream has finished, the `end` event is emitted. It is here that
    we check whether the payload is empty, and if it is, we return a `400` error as
    we did before. But if it is not empty, we then check the `Content-Type` header
    to see if it is `application/json`; if not, we return a `415` error. Lastly, to
    check whether the JSON is well formed, we concatenate the buffer array to restore
    our original payload. Then, we try to parse the payload with `JSON.parse`. If
    the payload is able to be parsed, we don't do anything; if it is not, it means
    the payload is not valid JSON and we should return a `400` error, as specified
    in our step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we had to wrap the `JSON.parse()` call in a `try`/`catch` block because
    it''ll throw an error if the payload is not a JSON-serializable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the tests again; all tests should now pass, with one exception: somehow,
    the step `And contains a message property which says ''The "Content-Type" header
    must always be "application/json"''` is said to be undefined. But if we check
    our step definitions, we can certainly see it *is* defined. So what''s happening?'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the forward slash character (`/`) has a special meaning in Gherkin.
    It specifies **alternative text**, which allows you to match *either* of the strings
    adjacent to the slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the step definition pattern `the client sends a GET/POST request`
    would match both of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `the client sends a GET request` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`the client sends a POST request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no way to escape the alternative text character. Instead,
    we must employ regular expressions to match this step definition pattern to its
    steps. This is as simple as replacing the containing single quotes with `/^` and
    `$/,` and escaping the forward slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all our tests should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For consistency's sake, replace all other string patterns with regular expressions;
    run the tests again to ensure they're still passing.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Red. Green. Refactor. We again find ourselves at the "green" phase; therefore,
    the next step is to refactor. We are going to start with our test code first.
  prefs: []
  type: TYPE_NORMAL
- en: Using scenario outlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our second scenario, we have three steps that are very similar to the steps
    defined for our first scenario. So far, we have simply been copying and pasting
    those step definitions and making small changes to them. Repetition or duplication
    is never good when it comes to code; so instead, we can define a *scenario outline*,
    which acts as a template scenario with placeholder variables that we can plug
    in. For example, we can combine these two scenarios into a scenario outline as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: First, we changed the keyword from `Scenario` to `Scenario Outline` and added
    placeholders (enclosed in `<>`). Then, we use the `Examples` keyword to supply
    these placeholders with actual values in the form of a **datatable**, which is
    simply columns of values separated by the pipe character (`|`). Now, our Cucumber
    specification is a lot less repetitive!
  prefs: []
  type: TYPE_NORMAL
- en: After each refactoring step, we should take care to ensure that we didn't break
    anything. So run our tests again and check they still pass.
  prefs: []
  type: TYPE_NORMAL
- en: Combining duplicate step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar vein, we can introduce **parameters** into our step definitions
    to help us avoid duplicated code. With string patterns, parameters can be specified
    using curly braces (`{}`), inside of which the type of the variable is indicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `Then our API should respond with a <statusCode> HTTP status
    code` step definition can be redefined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've replaced the hardcoded `400` HTTP status code with a placeholder,
    `{int}`, which indicates that the pattern should match an integer. Then, we are
    passing the value of the placeholder into the code function as `statusCode`, which
    is then used to perform the checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same with regular expression patterns. Instead of curly braces,
    we can define parameters by adding capturing groups to the RegEx. For instance,
    the same step definition would look like this using a regular expression pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your `spec/cucumber/steps/index.js` file to add groups to the regular
    expression patterns, and use those captured parameters in your step definition
    function. The end result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our tests have been refactored, we can now turn our focus to refactoring
    our application code. The great thing about having existing E2E tests is that
    if, during the refactoring, we break something, the tests will fail and we'd be
    able to fix them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did before, let''s list out all the issues with our current code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not very readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to work with quite low-level constructs, such as streams and buffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have not taken into consideration performance and security implications.
    For example, we are not handling situations where the payload is extremely large
    (or even infinite). This is a dangerous situation to avoid if we want to ensure
    high-availability of our service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the last issue, we can add an additional `if` block inside the `req.on(''data'')`
    block to check whether the payload is getting too large; if it is, we can return
    a `413 Payload Too Large` error. In the following example, we are using a limit
    of `1e6`, which is one million, or `1,000,000`, bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: However, this makes the code even harder to understand. At the moment, there's
    not too much functionality behind our API, yet our code is already quite long
    and complex; imagine how much more obscure it will get when we have to implement
    the logic to parse URL paths, query parameters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you may expect, these problems have already been solved and optimized by
    frameworks. So, let's take a look at some libraries we can use and then pick the
    one that best fits our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a minimum, we want a basic router; at most, we want a web framework. In
    this section, we will focus on four of the most popular frameworks: **Express**, **Koa**, **Hapi**, and **Restify**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Website** | **First** **released** | **GitHub** **stars** |
    **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Express | [expressjs.com](http://expressjs.com) | Jan, 3 2010 | 39,957 |
    "Fast, unopinionated, minimalist web framework for Node".Express is a thin routing
    layer above Node''s native `http` module, with support for templating and **middleware**
    (functions that preprocess the request object before it is passed to the handler).Express
    has been around the longest and is the most popular framework for Node.js. We
    will use Express as the benchmark from which comparisons with other libraries
    will be made. |'
  prefs: []
  type: TYPE_TB
- en: '| Koa | [koajs.com](http://koajs.com/) | Nov, 8 2013 | 22,847 | Created by TJ
    Holowaychuk, the same developer behind Express. It is similar to Express but uses
    async functions instead of callbacks. |'
  prefs: []
  type: TYPE_TB
- en: '| Hapi | [hapijs.com](https://hapijs.com/) | Aug, 21 2012 | 9,913 | While Express
    is minimalistic, Hapi ships with many built-in features, such as input validation,
    caching, and authentication; all you have to do is specify your settings in the
    configuration object for that route.Like middleware for Express, Hapi has a request
    life cycle and extension points where you can process the request or response
    objects.Hapi also supports a plugin system that allows you to split your app into
    modular parts. |'
  prefs: []
  type: TYPE_TB
- en: '| Restify | [restify.com](http://restify.com/) | May, 6 2011 | 8,582 | REST
    framework for providing microservices APIs. It is essentially Express but without
    the templating parts. It supports **DTrace**, which allows you to find out the
    amount of resources (for example, memory, CPU time, filesystem I/O, and bandwidth)
    used by a process. |'
  prefs: []
  type: TYPE_TB
- en: For basic features such as routing, all of these frameworks are more than capable.
    They differ only in their philosophy and community support.
  prefs: []
  type: TYPE_NORMAL
- en: Express is, without a doubt, the most popular and has the most community support,
    but it requires a lot of configuration and extra middleware just to get it out
    of the box. On the other hand, Hapi's configuration-centric philosophy is very
    interesting, because it means we don't have to change our code or update 10 different
    middleware, even when the feature code is changed and optimized. It's configuration-as-code,
    which is a nice philosophy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we develop our frontend application with React, we may later decide
    to use more advanced features, such as **Server-Side Rendering** (**SSR**). For
    these, we need to ensure that the tools and integrations we employ are widely
    used, so that if we run into any trouble, there'll be a large group of developers
    out there who have faced and resolved those issues. Otherwise, we may waste a
    long time looking at that source code to figure out a simple problem.
  prefs: []
  type: TYPE_NORMAL
- en: So although Hapi might technically be a better choice in theory, we will use
    Express because it is more popular and has a lot more community support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since migration to Express is an involved process, I''d recommend you to commit
    your code before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Migrating our API to Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to install Express: directly in the code itself or through
    the `express-generator` application generator tool. The `express-generator` tool
    installs the `express` CLI, which we can use to generate an application skeleton
    from. However, we won''t be using that because it''s mainly meant for client-facing
    applications, while we are just trying to build a server-side API at the moment. Instead,
    we''ll add the `express` package directly into our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the package into our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up your `src/index.js` file, and replace our `import` of the `http`
    module with the `express` package. Also replace the current `http.createServer` and
    `server.listen` calls with `express` and `app.listen`. What was previously this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Would now be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To help us know when the server has successfully initialized, we should add
    a callback function to `app.listen`, which will log a message onto the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We needed to disable ESLint for our `console.log` line because Airbnb's style
    guide enforces the `no-console` rule. `// eslint-disable-next-line` is a special
    type of comment recognized by ESLint, and will cause it to disable the specified
    rules for the next line. There is also the `// eslint-disable-line` comment if
    you want to disable the same line as the comment.
  prefs: []
  type: TYPE_NORMAL
- en: (Re)defining routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's migrate our `requestHandler` function to Express. With Express,
    instead of defining a single request handler for all our routes, we can define
    request handlers for each route using the format `app.METHOD('path', callback)`,
    where `METHOD` is the HTTP method of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, replace our previous `requestHandler` function with an `app.post`
    call. This is our old implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is our new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `req` and `res` objects passed by Express are identical to the ones passed
    by Node''s `http` module; this is why we can reuse the same logic as before. Run
    the tests again and they should still all pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code using Express is much clearer than our original example; here, each
    route is defined in its own block. Furthermore, if a request comes in for an unspecified
    route, then a `404: Not Found` response is automatically given. These small conveniences
    highlight one of the benefits of using a framework rather than programming your
    own implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, instead of using `res.writeHead`, we can use `res.status` and
    `res.set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, instead of using `res.end` with `JSON.stringify`, we can use the
    new `res.json` method provided by Express.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Using body-parser middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's just the start of our Express journey. The power of Express is in its
    abundance of middleware, which are functions that every request passes through.
    These middleware functions can opt to modify the request object before it arrives
    at the handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, instead of working with streams and buffers to obtain our payload
    data, we can make use of a very popular middleware package, `body-parser`. `body-parser` provides
    the ability to parse request bodies into JavaScript objects, which can then be
    consumed by our handlers. It does this in an efficient and optimized way, and
    also provides safeguards to ensure the payload is not too large. So, let''s install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following lines to the top of `src/index.js` to instruct our
    application server to use the `body-parser` package to parse any request that
    has a JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `bodyParser.json` method returns with a middleware.  Here, we are using
    the `app.use()` method to instruct our instance of the Express server to use the
    middleware generated by the `bodyParser.json` method. The middleware will parse
    the payload and assign it to the `body` property of the `req` object. We no longer
    need to work with streams and buffers; we can simply get the payload from `req.body`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `app.post(''/users'')` call, remove any code that works with buffers
    and streams, and replace the `payloadData` variable with `req.body`. Lastly, replace
    the condition `req.body.length === 0` inside our first if block with `req.headers[''content-length'']
    === ''0''`. Our handler should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Run E2E test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But if we run our E2E tests now, the scenario that sends a malformed JSON would
    fail. This is because of how the `body-parser` middleware works. The `bodyParser.json()`
    middleware will attempt to parse the payload of all requests that has their `Content-Type` header
    set to `application/json`. However, if the payload itself is not a valid JSON
    object, the middleware will throw an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we need to catch this error in order to provide the correct response.
    Error handling can also be done through middleware, but they must be defined *at
    the end*, after other middleware. In the error handler middleware, we need to
    check whether the error thrown is caused by a malformed JSON payload, and if it
    is, send the `'Payload should be in JSON format'` response we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try your hands on implementing this error handler middleware; when you finish,
    compare your `src/index.js` file with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our E2E tests, they should all be passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now successfully migrated our API to Express, and thus completed our
    (long) refactoring step. Let''s commit our hard work into the Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Moving common logic into middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can improve our code further. If you examine our Create User
    endpoint handler, you may notice that its logic could be applied to all requests.
    For example, if a request comes in carrying a payload, we expect the value of
    its `Content-Type` header to include the string `application/json`, *regardless
    of which endpoint it is hitting*. Therefore, we should pull that piece of logic
    out into middleware functions to maximize reusability. Specifically, these middleware
    should perform the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: If a request uses the method `POST`, `PUT` or `PATCH`, it must carry a non-empty
    payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a request contains a non-empty payload, it should have its `Content-Type` header
    set. If it doesn't, respond with the `400 Bad Request` status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a request has set its `Content-Type` header, it must contain the string `application/json`.
    If it doesn't, respond with the `415 Unsupported Media Type` status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s translate these criteria into Cucumber/Gherkin specifications. Since
    these are generic requirements, we should create a new file at `spec/cucumber/features/main.feature` and
    define our scenarios there. Have a go at it yourself; once you''re done, compare
    it with the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our tests, the step `But without a "Content-Type" header set` shows
    up as undefined; so let''s implement it. It is as simple as running the `unset` method
    on a superagent''s `request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests and see that all steps are now defined but some are failing.
    Red. Green. Refactor. We''re at the red stage, so let''s modify our application
    code so that it''ll pass (green). Again, have a go at it yourself, and compare
    it with our solution here once you''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to run our tests again to make sure we didn''t break existing
    functionality. On this occasion, they should all be passing. Therefore, the only
    thing left to do is to commit this refactoring into our Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Validating our payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been writing tests that ensure our request is valid and well-formed;
    in other words, making sure they are *syntactically *correct. Next, we are going
    to shift our focus to writing test cases that look at the payload object itself,
    ensuring that the payload has the correct structure and that it is *semantically*
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for required fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our requirements, we specified that in order to create a user account, the
    client must provide at least the `email` and `password` fields. So, let's write
    a test for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `spec/cucumber/features/users/create/main.feature` file, add the following
    scenario outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the second step, `And attaches a Create User payload which is missing
    the <missingFields> field`, every other step has already been implemented. The
    missing step should attach a dummy user payload, but then remove the specified
    property. Try implementing the logic of this step definition yourself, and compare
    it with the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the step definition, we first extract the variables and convert the `missingFields`
    string into an array. We then loop through this array and delete each property
    from the payload object. Lastly, we feed this incomplete payload into the request
    as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test now, it will fail. This is because we have not implemented
    the validation logic inside our Create User handler. Once again, have a go at
    implementing it, and check back here for our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all our tests will pass again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to commit these changes into Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Checking property type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we must ensure that both our `email` and `password` fields are of type
    string and that the email address is formatted correctly. Have a go at defining
    a new scenario outline for this, and compare it to the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, run the tests and confirm that one of the steps is undefined. Then,
    try to implement the step definition yourself, and check back with the following
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, it fails because we have not implemented our application
    to handle that scenario. So, let''s do that now by adding this `if` block to the
    end of the request handler for `POST /users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the tests to see them pass, and commit our changes to Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Checking the payload property's format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, the email address field may be present and have the correct data type,
    but it may still not be a valid email. So, the final check is to ensure the email
    is a valid email address. You should get the drill by now: define a new feature
    inside `spec/cucumber/features/users/create/main.feature`, and check back here
    for the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are excluding emails that are technically valid email addresses
    (such as `a@1.2.3.4`), but for our API, we want to accept only the more "generic"
    email addresses (such as `jane@gmail.com`).
  prefs: []
  type: TYPE_NORMAL
- en: We are checking multiple examples here to give us confidence that our endpoint *really* won't
    accept an invalid email. In theory, the more examples we define, the better, because
    it gives us more confidence in our feature. However, E2E tests take a (relatively)
    long time to run; therefore, we must find a balance between confidence and speed.
    Here, we have specified three sufficiently diverse examples, which should cover
    most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define the step definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests and see them fail. Then, implement the following application
    code to make them pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests again, make sure they all pass, and then commit your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring our step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Red. Green. Refactor. Now that all tests pass, it's a good time to refactor
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Our application code, although slightly repetitive, is easy to follow and read;
    therefore, we don't need to refactor it for now. There are, however, some improvements
    we can make to our test code. For example, we are hardcoding the Create User payload
    into our tests; it'll be better if we abstract that into a function that generates
    the payload when called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new `spec/cucumber/steps/utils.js` file to house our
    utility/support code. Add the following into the `utils.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Import it and use it in our test code. For example, the `When(/^attaches an?
    (.+) payload where the ([a-zA-Z0-9, ]+) fields? (?:is|are) exactly (.+)$/)` step
    definition would become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Do this for all other step definitions that use an endpoint-specific payload.
    After this, run the tests again and make sure they all still pass (because refactoring
    shouldn''t modify the functionality), and then commit the changes to Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Testing the success scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered almost all of the edge cases. Now, we must implement the happy
    path scenario, where our endpoint is called as intended, and where we are actually
    creating the user and storing it in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s carry on with the same process and start by defining a scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'All steps are defined except the second, fifth, and last step. The second step
    can be implemented by using our `getValidPayload` method to get a valid payload,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The fifth step is a variation of the `Then(''the payload of the response should
    be a JSON object'')` step definition we have already defined, and therefore we
    can simply modify it to make it more generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: For the last step, however, we actually need a database to write to. But we
    have already achieved a lot in this chapter. So let's review what we have done
    up to this point, and set up a database in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we coerced you into following TDD principles when developing
    your application. We used Cucumber and Gherkin to write our end-to-end test, and
    used that to drive the implementation of our first endpoint. As part of our refactoring
    efforts, we've also migrated our API to use the Express framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have the TDD process drilled into your brain: Red.
    Green. Refactor. Begin by writing out test scenarios, implementing any undefined
    steps, then run the tests and see them fail, and finally, implementing the application
    code to make them pass. Once the tests have passed, refactor where appropriate. Rinse
    and repeat.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that TDD is not required to have self-testing code.
    You can, without following TDD, still write tests after to verify behavior and
    catch bugs. The emphasis of TDD is that it translates the design of your system
    into a set of concrete requirements, and uses these requirements to *drive* your
    development. Testing is a forethought, not an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement the last remaining step of our E2E tests,
    setting up Elasticsearch and using it to persist our user data.
  prefs: []
  type: TYPE_NORMAL
