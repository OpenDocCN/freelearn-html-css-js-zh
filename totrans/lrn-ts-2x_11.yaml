- en: Frontend Development with React and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we learned how to implement web services with Node.js.
    In this chapter, we are going to learn how to implement a **single-page application**
    (**SPA**) that consumes the web services that we created in the preceding chapter.
    The web services might change slightly in this chapter, but the changes should
    be small enough not to require us to cover them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The companion source code includes an updated version of the backend application
    that we implemented in the preceding chapter. The new upgraded version contains
    new controllers and web services that allow us to manage a catalog of movies and
    actors, as opposed to just movies.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to consume a web service from a React
    application and how we can use React components to display the data fetched from
    the backend in a web user interface. We are also going to learn how to implement
    client-side routing powered by the `react-router` and how to implement smart components
    powered by MobX.
  prefs: []
  type: TYPE_NORMAL
- en: Working with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a library that allows us to implement web user interfaces. In this
    chapter, we are going to create a small frontend application using React and MobX.
    A frontend web application is quite different from a Node.js backend web application.
    It is true that both the web browser and Node.js can understand JavaScript natively,
    but the environments are quite different. For example, in the Node.js environment,
    we can access system resources like the filesystem, and we can use CommonJS modules
    natively. On the other hand, in a web browser, we cannot access resources like
    the filesystem and CommonJS modules are not supported natively. Also, the performance
    of a frontend web application is extremely influenced by its loading times. This
    means that in a frontend web application we must pay special attention to the
    number of HTTP requests and the size of the contents being loaded through the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of native support for modules and the need for size optimization explains
    the need for a module bundler when we are working on a frontend web application.
    Throughout this book, we have been using Webpack as our module bundler, and we
    will do the same once more in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the following Webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used some plugins to compile the SCSS files into one unique CSS file
    and to copy the HTML files into the build output directory (the `public` directory).
    If the build is successful, we should end up with three files under the `public`
    directory: `index.html`, `bundle.js`, and `main.css`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: About the sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same application included in the companion source code is a very small
    web application that allows us to manage a database or movies and actors. The
    application is going to be divided into two main units: pages and components.
    In this section, we are going to learn about each of the pages and components
    used in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *home* page allows us to access the Movies and Actors pages. The Home page
    uses the Layout, Header, Container, Row, Column, Card, Card image, and Link components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7ec162f-f13d-4e34-a0d1-b4524fa7b885.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Movies page allows us to see a list of existing movies in the database
    as well as to add and delete movies and uses the Layout, Header, Container, Row,
    Column, Modal, Button, Text field, and List Group components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ff8eed-3f34-490b-be0e-279760ee54da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows what the page looks like when the Movie Editor
    is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84f7483-e0c8-46ae-9a65-d1cfcb267940.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows what the page looks like when we try to Delete
    a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35404f8c-3ea5-45d9-8134-b918d8c4d422.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Actors page allows us to see a list of existing actors in the database
    as well as to add and delete actors and uses the Layout, Header, Container, Row,
    Column, Modal, Button, Text field, and List Group components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02e4a8f4-946b-4412-a90d-dd9242fec21f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating or deleting an actor is almost identical to creating or deleting a
    movie. The following screenshot shows what the page looks like when the Actor
    Editor is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/133ad93b-a82e-42f5-9692-7436c83ee531.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshots, multiple pages can consume the
    same React components. The level of reusability of a component is one of the main
    strengths of React as a library for the development of user interfaces. React
    allows us to develop reusable *units of work* known as components that can later
    be reused across multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample application included in the companion source code implements both
    a backend and a frontend web application and uses the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to implement a very basic compilation pipeline using the
    following npm scripts commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding command using the following `npm` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To run the application, we must first run the build command, which will build
    our frontend application and transform it into bundled JavaScript and CSS files
    located under the directory named `public`. We can then run the application using
    the `npm run start` command. The Node.js server will then start listening to our
    API calls. The Node.js will also serve the files under the `public` directory
    as we will see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Serving a React application with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to try to avoid introducing changes to our existing
    Node.js backend. Some changes have been introduced to the web services declared
    by the controllers. We will not spend any time going through those changes in
    this chapter because they are trivial.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are going to focus on some changes in the Express.js configuration
    required to serve the JavaScript and CSS files under the public directory. If
    we want our Express.js application to serve the static files of our frontend application,
    we are going to need to configure what is known as the **static middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet contains the entire source code of the application''s
    entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new Express.js application. The key point
    to focus on here is the invocation to the `setConfig` method. We have configured
    the Express.js static middleware to serve all the files located under the `public`
    directory when the default path (`"/"`) is invoked. This means that if we run
    the application using `npm start` and we access `http://127.0.0.1:3000/`, the
    `index.html` file located under the `public` directory will be served. The `index.html`
    file will then request the JavaScript and CSS files; these files are also located
    under the `public` directory and can be accessed using `http://127.0.0.1:3000/main.css`
    and `http://127.0.0.1:3000/bundle.js` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we have also configured our application to use the body-parser
    middleware. This is required to be able to parse JSON data contained in the body
    of an HTTP request. Please refer to [Chapter 10](18001bfb-4043-425e-bf6d-7f5625dff5f5.xhtml),
    *Node.js Development with TypeScript*, if you need additional help with Node.js
    and Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Working with react-dom and JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how we can use Webpack to build our frontend application and
    how we can use Express.js to serve its static files, we can focus on the code
    of the React application. We are going to start by examining the entry point of
    our frontend application. The application's entry point is located at `/web/frontend/index.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have used the file extension .tsx instead of the .ts extension.
    This is the case because we are going to use a template system known as JSX. TypeScript
    supports JSX natively, but it requires us to use the .tsx file extension and to
    configure the JSX settings in our `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The JSX setting determines if the JSX code should be compiled into JavaScript
    by TypeScript or by an external tool. In this case, we are working to set the
    JSX setting to `react`, which means that the JSX code will be compiled into JavaScript
    by TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: The application's entry point uses the `react-dom` module to render the application's
    root component. At this point, we don't know what a React component is yet. However,
    we don't need to go into detail just yet. All we need to understand here is that
    the `Layout` variable is a React component and that it is rendered into an HTML
    element using the `render` method from the `react-dom` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `querySelector` to find an existing DOM element in our `index.html`
    file and then we use the `render` function to render the output of the `Layout`
    component into the selected DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the render function is a JSX element. As you can see,
    the JSX syntax is very similar to the HTML syntax, however it has some differences
    that we will explore throughout the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that the preceding file is also importing some files
    required by the entire frontend application. For example, the file imports the
    `bootstrap.css` and the `reflect-metadata` modules. The first file contains the
    CSS required by the React components in this application, and the `reflect-metadata`
    module declares a polyfill required to implement dependency injection in some
    of our components.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the react-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we learned how to use the `render` method from the
    `react-dom` module to render the `Layout` component. In this section, we are going
    to take a closer look at the `Layout` component.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the code snippet below, the `Layout` component is a function
    that returns a series of nested JSX elements; some of these JSX elements are other
    React components (such as `BrowserRouter`, `Header`, and `Switch` components).
    This is the first time that we have seen the actual implementation of a React
    component. In this case, a React component is a function that returns some JSX.
    However, it is important to mention that this is not always the case as a component
    can also be a class.
  prefs: []
  type: TYPE_NORMAL
- en: React is a component-based frontend development framework. This means that in
    React, everything is a component. Our application is a component, the pages within
    the application are components, and the elements in each of the pages are components.
  prefs: []
  type: TYPE_NORMAL
- en: The `Layout` component is the application's root component. The `Layout` component
    is always rendered on screen. However, the pages within the application are conditionally
    rendered as a child of the `Layout` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Layout` component uses the `react-router` module to implement routing
    in our React application. The `react-router` module includes the following React
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BrowserRouter` module is used to provide other components with access to
    some browser APIs required to implement client-side navigation (such as the History
    API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Switch` component allows us to define the routes available in our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Route` component allows us to define a route in our application. The `Route`
    component takes a `path` and a `component` as properties. When the browser URL
    matches one of the routes, the respective component is rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Link` component is not used by the `Layout` component directly. However,
    it is the component used to declare a link to one of the existing routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet showcases how the `Layout` component declares three
    different routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already mentioned, the `Link` component is not used by the `Layout`
    component, but it can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we have already mentioned, the JSX syntax is almost identical to the HTML
    syntax. However, some attributes are not available or are named differently (for
    example, `className`). Another significant difference is that we must use a special
    syntax (`{}`) to bind the value of a variable to one of the properties of a component.
  prefs: []
  type: TYPE_NORMAL
- en: Working with React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take a close look at some of the components
    used by the application included in the companion source code. We will use multiple
    components to demonstrate multiple concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Components as classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code snippet declares three components named `Container`, `Row`,
    and `Column`. These components extend the `Component` class, which is imported
    from the `React` module. There are a few methods that we can implement in a class
    that extends the `Component` class, but at a bare minimum, we must implement the
    `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Container`, `Row`, and `Column` components are used to control the layout
    of a page. These components use the CSS classes from the Bootstrap (a library
    that allow us to style our application with ease) grid system. In Bootstrap, the
    layout has a maximum of 12 columns, and a different size can be declared for a
    given screen size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Properties and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see in the preceding code snippet, the `Component` class is a generic
    class with two optional generic types: `Component<TProps, TState>`. These two
    generic types allow us to specify the type of the properties and state used in
    a React component.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Container` and the `Row` components don't have any properties
    or state. However, the `Column` component defines the type of its properties because
    we need some additional data to be provided by its consumers. For example, when
    we declare the `Column` component, we don't know if the consumers will set its
    size to 1 or 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties are passed to a component via its constructor by the consumers of
    the component. For example, the following code snippet demonstrates how we can
    pass the property `width` to the `Column` component. The code snippet also demonstrates
    how we can pass other properties to the `Card` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A component can also have an internal state. The main difference between properties
    and states is that properties are immutable. In other words, the value of the
    properties of a component cannot change (be mutated) after the component instantiation.
    On the other hand, the state of a component mutates through the `setState` function.
    For example, the following code snippet declares a component that uses both properties
    and states. The component displays a basic numeric counter that increments when
    the users click on a button. The component properties are used to set the initial
    state of the component (the value of the counter). The state is then mutated by
    the `setState` function when the users click on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding component can be consumed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The state of a component can only be changed by the component itself. In general,
    properties are preferred over internal states because it can lead to maintainability
    issues in very large projects. This is mainly because when we use an internal
    state, it is slightly more complicated to keep track of state mutations and the current
    state. We are going to learn more about this topic later in this chapter in the
    *Smart components and dumb components* section.
  prefs: []
  type: TYPE_NORMAL
- en: Functional stateless components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **functional stateless component** (**FSC**) is a component that doesn''t
    use an internal state, and it is a simple function, as opposed to a class that
    extends the `Component` class. For example, the `Header` component is an FSC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: React component life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a component extends the `Component` class, it is possible to implement
    some component life cycle hooks. The companion source code includes a component
    named `MoviePage` that declares a component life cycle hook named `componentWillMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'React allows us to declare multiple component life cycle hooks. Covering all
    the available React component life cycle hooks is out of the scope of this book.
    However, it is important to understand that the events are organized into three
    main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The mounting phase takes place before the component is rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The updating phase included the rendering and the moment immediately before
    and after the component has been rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unmounting phase takes place when the component is about to stop being rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram showcases the order in which the main events are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80051090-0f69-4212-a831-c2ec76fd1cd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Please refer to the official React documentation at [https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)
    to learn more about the component life cycle events.
  prefs: []
  type: TYPE_NORMAL
- en: Smart components and dumb components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a real-world React application, we will have many stateless React components,
    but somewhere in our tree of components, a component must be responsible for the
    management of the application state. This means that we can group them into two
    main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dumb components** are also known as presentational components because their
    only responsibility is to present something to the DOM. Dumb components may be
    functional stateless components or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart components** are also known as container components because they are
    the ones that keep track of states and care about how the app works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation between smart and dumb components can be achieved in many ways,
    and it is sometimes coupled to some implementation details. The most simplistic
    way to achieve this is to have a smart component that uses an internal state and
    the `setState` function and some dumb components that take their parent's internal
    state as their properties. However, it is also very common to use external state
    container libraries (such as Redux or MobX) to implement smart components.
  prefs: []
  type: TYPE_NORMAL
- en: The application included in the companion source code declares a lot of dumb
    components (under the `components` directory) and some smart components (under
    the `pages` directory). The smart components are the ones responsible for the
    management of the application state. However, instead of using the `setState`
    function we are using MobX and some design patterns to ensure that our application
    can scale in a predictable and maintainable way.
  prefs: []
  type: TYPE_NORMAL
- en: Working with MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX is a library that helps us to manage and mutate the state in a React application.
    In this section, we are going to understand the MobX architecture. We will also
    learn how to install and configure it, what its main components are, and its APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the MobX architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MobX architecture introduces an entity known as the `Store`. A `Store`
    is an object that contains some state and provides access to some actions that
    allow us to mutate its internal state:'
  prefs: []
  type: TYPE_NORMAL
- en: The state is observable; this means that when its value changes, an event is
    emitted and other parts of the application can subscribe to state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actions allow us to mutate the current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with actions and observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn to use observables and actions. The
    following code snippet declares a `Store` named `ActorStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `ActorStore` is a class that is decorated with the `@provide` decorators.
    This decorator is used to allow us to inject the `Store` into other elements in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we will learn more about the `@provide` decorator later in
    this chapter in the *Dependency injection in MobX* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Store` class also declares some properties that are decorated with the
    `@observable` decorator. This decorator allows other elements in our application
    to subscribe to the changes in the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the properties of the `Store`, we are going to declare its
    actions. As you can see in the following code snippet, an action is a method decorated
    with the `@action` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@action` decorator can be used to decorate methods that perform state
    mutations like the preceding methods, but we are not limited to only this kind
    of operation. The following methods perform state mutations, but they also send
    some HTTP requests to the server using the Fetch API. There is an action to fetch
    all actors from the actors REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an action to create a new actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an action to delete an actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `runInAction` function to wrap the state mutations. Using the `runInAction`
    function is required because we previously configured MobX to enforce that state
    mutations must only take place in actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our `Store` is ready to be injected into one of our React smart
    components using the `@lazyInject` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we will learn more about the `@lazyInject` decorator later
    in this chapter in the *Dependency injection in MobX* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a smart component named `MoviePages`. In
    our React application, the pages are smart components and the components are simply
    dumb components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This smart component is implemented using a class that extends the `Component`
    class and is decorated with the `@observer` decorator. The `@observer` decorator
    binds the React component to the state changes in the `Store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MovieStore` is injected into the `Component` after an instance of it has
    been created by React. We can ignore the details about this for now because it
    will be explained in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use then the `componentWillMount` event hook to trigger the initial data-fetching
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render the page. The `render` method accesses some of the properties
    (`@observables`) of the `Store`. Because our component is an observer (`@observer`),
    if an action (`@action`) is triggered, our component will be re-rendered. The
    component renders a list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also renders a modal window that allows us to create a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This component also renders a modal window that allows us to confirm that we
    wish to delete a movie from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection in MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we decorated the `ActorStore` class with the `@provide`
    decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator is an alternative to the InversifyJS biding syntax and is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@provide` decorator is not required but it is more convenient than the
    binding API. The `@provide` decorator can be created using the `inversify-binding-decorators`
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that the examples use the version 3.2.0 of the `inversify-binding-decorators`
    module and the upcoming version (4.0.0) will introduce some breaking changes.
    You can refer to the documentation at [https://github.com/inversify/inversify-binding-decorators](https://github.com/inversify/inversify-binding-decorators)
    to learn more about the new API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@provider` decorator declares a binding automatically for us when it is
    executed, and decorators are executed when a class is declared. This means that
    we need to import the files that use the `@provider` decorator at least once in
    our application to trigger the class declaration, or no bindings will be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the bindings, the `Store` is injected into a React component.
    However, we cannot use the `@injectable` and `@inject` annotations as we did in
    some of the preceding chapters because React components are instantiated by React.
    This means that our IoC container will not be able to create instances of our
    React components and will therefore not be able to perform any constructor injection.
    We can overcome this limitation by using the `@lazyInject` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@lazyInject` decorator injects a dependency immediately before it is used
    instead of injecting it when an instance of its dependent is created. The `@lazyInject`
    decorator can be created using the `inversify-inject-decorators` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more about dependency injection and InversifyJS.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection in MobX is useful because we can inject a different
    store with hardcoded results during the execution of the unit tests. This allows
    us to test the components in complete isolation.
  prefs: []
  type: TYPE_NORMAL
- en: MobX alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using MobX to manage the state of our application and the required
    state mutations (actions). MobX is a great library and it has great support for
    TypeScript. However, it is not the only option.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best features of React is that we have the freedom to select many
    different state management tools and architectures. Freedom of choice can lead
    to confusion and is a problem for junior engineers because they don't have the
    experience required to judge if a library is better than another. On the other
    hand, freedom can lead to more innovation and better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular alternatives to MobX are Redux and Flux. You can learn
    more about Redux at [https://redux.js.org](https://redux.js.org). Please refer
    to [https://facebook.github.io/flux](https://facebook.github.io/flux/) to learn
    more about Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install the React development tools extensions for Google Chrome to help
    us to debug our frontend React applications. The extension can be downloaded at
    [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a Google Chrome extension available that can help us to debug
    a MobX application. We can download the extension at the official installation
    page: [https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod](https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools allow us to see components being rendered, their properties and
    state, and the MobX actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56b27ebe-b622-425a-bbe7-97205090ef17.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the basic principles of component-based web
    development and how to use React. We have also learned about concepts like stateless
    functional components and dumb components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to implement the same application one more
    time. However, we will use Angular instead of React and MobX as our application
    development framework. We will try to implement a copy of the application as close
    as possible to enable us to compare both frameworks.
  prefs: []
  type: TYPE_NORMAL
