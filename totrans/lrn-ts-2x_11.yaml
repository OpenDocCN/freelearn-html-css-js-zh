- en: Frontend Development with React and TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React和TypeScript进行前端开发
- en: In the preceding chapter, we learned how to implement web services with Node.js.
    In this chapter, we are going to learn how to implement a **single-page application**
    (**SPA**) that consumes the web services that we created in the preceding chapter.
    The web services might change slightly in this chapter, but the changes should
    be small enough not to require us to cover them in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Node.js实现Web服务。在本章中，我们将学习如何实现一个**单页应用程序**（SPA），该应用程序消费我们在上一章中创建的Web服务。Web服务在本章中可能会有所变化，但这些变化应该足够小，不需要在本章中详细说明。
- en: The companion source code includes an updated version of the backend application
    that we implemented in the preceding chapter. The new upgraded version contains
    new controllers and web services that allow us to manage a catalog of movies and
    actors, as opposed to just movies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的源代码包括我们在上一章中实现的后端应用程序的更新版本。新的升级版本包含新的控制器和Web服务，使我们能够管理电影和演员的目录，而不仅仅是电影。
- en: In this chapter, we are going to learn how to consume a web service from a React
    application and how we can use React components to display the data fetched from
    the backend in a web user interface. We are also going to learn how to implement
    client-side routing powered by the `react-router` and how to implement smart components
    powered by MobX.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从React应用程序中消费Web服务，以及我们如何使用React组件在Web用户界面中显示从后端获取的数据。我们还将学习如何使用`react-router`实现客户端路由，以及如何使用MobX实现智能组件。
- en: Working with React
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与React一起工作
- en: React is a library that allows us to implement web user interfaces. In this
    chapter, we are going to create a small frontend application using React and MobX.
    A frontend web application is quite different from a Node.js backend web application.
    It is true that both the web browser and Node.js can understand JavaScript natively,
    but the environments are quite different. For example, in the Node.js environment,
    we can access system resources like the filesystem, and we can use CommonJS modules
    natively. On the other hand, in a web browser, we cannot access resources like
    the filesystem and CommonJS modules are not supported natively. Also, the performance
    of a frontend web application is extremely influenced by its loading times. This
    means that in a frontend web application we must pay special attention to the
    number of HTTP requests and the size of the contents being loaded through the
    network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个允许我们实现Web用户界面的库。在本章中，我们将使用React和MobX创建一个小型前端应用程序。前端Web应用程序与Node.js后端Web应用程序有很大不同。确实，Web浏览器和Node.js都可以原生理解JavaScript，但环境却大不相同。例如，在Node.js环境中，我们可以访问系统资源，如文件系统，并且可以原生使用CommonJS模块。另一方面，在Web浏览器中，我们无法访问像文件系统这样的资源，并且CommonJS模块不支持原生。此外，前端Web应用程序的性能极其受其加载时间的影响。这意味着在Web前端应用程序中，我们必须特别注意HTTP请求的数量和通过网络加载的内容的大小。
- en: The lack of native support for modules and the need for size optimization explains
    the need for a module bundler when we are working on a frontend web application.
    Throughout this book, we have been using Webpack as our module bundler, and we
    will do the same once more in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前端Web应用程序上工作时，由于原生模块支持不足和需要大小优化，因此需要一个模块打包器。在整个本书中，我们一直在使用Webpack作为我们的模块打包器，在本章中我们也将再次这样做。
- en: 'We are going to use the following Webpack configuration:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Webpack配置：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have used some plugins to compile the SCSS files into one unique CSS file
    and to copy the HTML files into the build output directory (the `public` directory).
    If the build is successful, we should end up with three files under the `public`
    directory: `index.html`, `bundle.js`, and `main.css`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些插件将SCSS文件编译成一个唯一的CSS文件，并将HTML文件复制到构建输出目录（`public`目录）。如果构建成功，我们应该在`public`目录下得到三个文件：`index.html`、`bundle.js`和`main.css`。
- en: Please refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn more about Webpack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化你的开发工作流程*，以了解更多关于Webpack的信息。
- en: About the sample application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于示例应用程序
- en: 'The same application included in the companion source code is a very small
    web application that allows us to manage a database or movies and actors. The
    application is going to be divided into two main units: pages and components.
    In this section, we are going to learn about each of the pages and components
    used in the application.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码中包含的相同应用程序是一个非常小的 Web 应用程序，允许我们管理电影和演员的数据库。应用程序将被分为两个主要单元：页面和组件。在本节中，我们将了解应用程序中使用的每个页面和组件。
- en: 'The *home* page allows us to access the Movies and Actors pages. The Home page
    uses the Layout, Header, Container, Row, Column, Card, Card image, and Link components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*主页* 允许我们访问 Movies 和 Actors 页面。主页使用 Layout、Header、Container、Row、Column、Card、Card
    image 和 Link 组件：'
- en: '![](img/c7ec162f-f13d-4e34-a0d1-b4524fa7b885.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c7ec162f-f13d-4e34-a0d1-b4524fa7b885.png)'
- en: 'The Movies page allows us to see a list of existing movies in the database
    as well as to add and delete movies and uses the Layout, Header, Container, Row,
    Column, Modal, Button, Text field, and List Group components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Movies 页面允许我们查看数据库中现有的电影列表，以及添加和删除电影，并使用 Layout、Header、Container、Row、Column、Modal、Button、Text
    field 和 List Group 组件：
- en: '![](img/e3ff8eed-3f34-490b-be0e-279760ee54da.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e3ff8eed-3f34-490b-be0e-279760ee54da.png)'
- en: 'The following screenshot shows what the page looks like when the Movie Editor
    is active:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当 Movie 编辑器处于活动状态时的页面外观：
- en: '![](img/f84f7483-e0c8-46ae-9a65-d1cfcb267940.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f84f7483-e0c8-46ae-9a65-d1cfcb267940.png)'
- en: 'The following screenshot shows what the page looks like when we try to Delete
    a movie:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当我们尝试删除一部电影时的页面外观：
- en: '![](img/35404f8c-3ea5-45d9-8134-b918d8c4d422.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/35404f8c-3ea5-45d9-8134-b918d8c4d422.png)'
- en: 'The Actors page allows us to see a list of existing actors in the database
    as well as to add and delete actors and uses the Layout, Header, Container, Row,
    Column, Modal, Button, Text field, and List Group components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Actors 页面允许我们查看数据库中现有的演员列表，以及添加和删除演员，并使用 Layout、Header、Container、Row、Column、Modal、Button、Text
    field 和 List Group 组件：
- en: '![](img/02e4a8f4-946b-4412-a90d-dd9242fec21f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/02e4a8f4-946b-4412-a90d-dd9242fec21f.png)'
- en: 'Creating or deleting an actor is almost identical to creating or deleting a
    movie. The following screenshot shows what the page looks like when the Actor
    Editor is active:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或删除一个演员几乎与创建或删除一部电影相同。以下截图显示了当 Actor 编辑器处于活动状态时的页面外观：
- en: '![](img/133ad93b-a82e-42f5-9692-7436c83ee531.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/133ad93b-a82e-42f5-9692-7436c83ee531.png)'
- en: As you can see in the preceding screenshots, multiple pages can consume the
    same React components. The level of reusability of a component is one of the main
    strengths of React as a library for the development of user interfaces. React
    allows us to develop reusable *units of work* known as components that can later
    be reused across multiple applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，多个页面可以消耗相同的 React 组件。组件的可复用性是 React 作为用户界面开发库的主要优势之一。React 允许我们开发可复用的
    *工作单元*，称为组件，这些组件可以在多个应用程序中重复使用。
- en: 'The sample application included in the companion source code implements both
    a backend and a frontend web application and uses the following dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码中包含的示例应用程序实现了一个后端和前端 Web 应用程序，并使用了以下依赖项：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are also going to implement a very basic compilation pipeline using the
    following npm scripts commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下 npm 脚本命令实现一个非常基本的编译管道：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the preceding command using the following `npm` commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `npm` 命令使用前面的命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To run the application, we must first run the build command, which will build
    our frontend application and transform it into bundled JavaScript and CSS files
    located under the directory named `public`. We can then run the application using
    the `npm run start` command. The Node.js server will then start listening to our
    API calls. The Node.js will also serve the files under the `public` directory
    as we will see in the following section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，我们首先必须运行构建命令，这将构建我们的前端应用程序并将其转换为位于名为 `public` 的目录下的捆绑 JavaScript 和 CSS
    文件。然后，我们可以使用 `npm run start` 命令运行应用程序。Node.js 服务器将开始监听我们的 API 调用。Node.js 还将提供
    `public` 目录下的文件，正如我们将在下一节中看到的那样。
- en: Serving a React application with Node.js
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 提供React应用程序
- en: In this chapter, we are going to try to avoid introducing changes to our existing
    Node.js backend. Some changes have been introduced to the web services declared
    by the controllers. We will not spend any time going through those changes in
    this chapter because they are trivial.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尽量避免对现有的Node.js后端进行修改。控制器声明的一些网络服务已经引入了变化。我们不会在本章中花费时间详细说明这些变化，因为它们是微不足道的。
- en: However, we are going to focus on some changes in the Express.js configuration
    required to serve the JavaScript and CSS files under the public directory. If
    we want our Express.js application to serve the static files of our frontend application,
    we are going to need to configure what is known as the **static middleware**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将关注在Express.js配置中的一些变化，这些变化是必要的，以便在public目录下提供JavaScript和CSS文件。如果我们想让我们的Express.js应用程序提供前端应用程序的静态文件，我们需要配置所谓的**静态中间件**。
- en: 'The following code snippet contains the entire source code of the application''s
    entry point:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段包含了应用程序入口点的全部源代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet creates a new Express.js application. The key point
    to focus on here is the invocation to the `setConfig` method. We have configured
    the Express.js static middleware to serve all the files located under the `public`
    directory when the default path (`"/"`) is invoked. This means that if we run
    the application using `npm start` and we access `http://127.0.0.1:3000/`, the
    `index.html` file located under the `public` directory will be served. The `index.html`
    file will then request the JavaScript and CSS files; these files are also located
    under the `public` directory and can be accessed using `http://127.0.0.1:3000/main.css`
    and `http://127.0.0.1:3000/bundle.js` respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个新的Express.js应用程序。这里的关键点是关注对`setConfig`方法的调用。我们已经配置了Express.js静态中间件，以便在调用默认路径（`"/"`）时提供位于`public`目录下的所有文件。这意味着如果我们使用`npm
    start`运行应用程序，并访问`http://127.0.0.1:3000/`，则位于`public`目录下的`index.html`文件将被提供。然后，`index.html`文件将请求JavaScript和CSS文件；这些文件也位于`public`目录下，可以通过`http://127.0.0.1:3000/main.css`和`http://127.0.0.1:3000/bundle.js`分别访问。
- en: Please note that we have also configured our application to use the body-parser
    middleware. This is required to be able to parse JSON data contained in the body
    of an HTTP request. Please refer to [Chapter 10](18001bfb-4043-425e-bf6d-7f5625dff5f5.xhtml),
    *Node.js Development with TypeScript*, if you need additional help with Node.js
    and Express.js.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还配置了应用程序使用body-parser中间件。这是为了能够解析HTTP请求体中包含的JSON数据。如果您需要关于Node.js和Express.js的额外帮助，请参阅[第10章](18001bfb-4043-425e-bf6d-7f5625dff5f5.xhtml)，*使用TypeScript进行Node.js开发*。
- en: Working with react-dom and JSX
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与react-dom和JSX一起工作
- en: Now that we know how we can use Webpack to build our frontend application and
    how we can use Express.js to serve its static files, we can focus on the code
    of the React application. We are going to start by examining the entry point of
    our frontend application. The application's entry point is located at `/web/frontend/index.tsx`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用Webpack构建我们的前端应用程序，以及如何使用Express.js提供其静态文件，我们可以专注于React应用程序的代码。我们将从检查前端应用程序的入口点开始。应用程序的入口点位于`/web/frontend/index.tsx`。
- en: 'As you can see, we have used the file extension .tsx instead of the .ts extension.
    This is the case because we are going to use a template system known as JSX. TypeScript
    supports JSX natively, but it requires us to use the .tsx file extension and to
    configure the JSX settings in our `tsconfig.json` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了.tsx文件扩展名而不是.ts扩展名。这是因为我们将使用一个名为JSX的模板系统。TypeScript原生支持JSX，但它要求我们使用.tsx文件扩展名，并在我们的`tsconfig.json`文件中配置JSX设置：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The JSX setting determines if the JSX code should be compiled into JavaScript
    by TypeScript or by an external tool. In this case, we are working to set the
    JSX setting to `react`, which means that the JSX code will be compiled into JavaScript
    by TypeScript.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSX设置决定了TypeScript是否应该将JSX代码编译成JavaScript，或者由外部工具编译。在这种情况下，我们正在努力将JSX设置设置为`react`，这意味着JSX代码将由TypeScript编译成JavaScript。
- en: The application's entry point uses the `react-dom` module to render the application's
    root component. At this point, we don't know what a React component is yet. However,
    we don't need to go into detail just yet. All we need to understand here is that
    the `Layout` variable is a React component and that it is rendered into an HTML
    element using the `render` method from the `react-dom` library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点使用 `react-dom` 模块来渲染应用程序的根组件。在此阶段，我们还不了解 React 组件是什么。然而，我们目前不需要深入了解。我们只需要理解的是，`Layout`
    变量是一个 React 组件，并且它使用 `react-dom` 库的 `render` 方法渲染到一个 HTML 元素中。
- en: 'We use the `querySelector` to find an existing DOM element in our `index.html`
    file and then we use the `render` function to render the output of the `Layout`
    component into the selected DOM element:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `querySelector` 在 `index.html` 文件中查找现有的 DOM 元素，然后使用 `render` 函数将 `Layout`
    组件的输出渲染到选定的 DOM 元素中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first argument of the render function is a JSX element. As you can see,
    the JSX syntax is very similar to the HTML syntax, however it has some differences
    that we will explore throughout the rest of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数的第一个参数是一个 JSX 元素。正如你所见，JSX 语法与 HTML 语法非常相似，然而它有一些我们在本章余下的部分将探讨的不同之处。'
- en: It is also worth mentioning that the preceding file is also importing some files
    required by the entire frontend application. For example, the file imports the
    `bootstrap.css` and the `reflect-metadata` modules. The first file contains the
    CSS required by the React components in this application, and the `reflect-metadata`
    module declares a polyfill required to implement dependency injection in some
    of our components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，前面的文件也导入了整个前端应用程序所需的某些文件。例如，该文件导入了 `bootstrap.css` 和 `reflect-metadata`
    模块。第一个文件包含应用程序中 React 组件所需的 CSS，而 `reflect-metadata` 模块声明了实现某些组件中依赖注入所需的 polyfill。
- en: Working with the react-router
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 react-router
- en: In the preceding section, we learned how to use the `render` method from the
    `react-dom` module to render the `Layout` component. In this section, we are going
    to take a closer look at the `Layout` component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用来自 `react-dom` 模块的 `render` 方法来渲染 `Layout` 组件。在本节中，我们将更深入地研究
    `Layout` 组件。
- en: As we can see in the code snippet below, the `Layout` component is a function
    that returns a series of nested JSX elements; some of these JSX elements are other
    React components (such as `BrowserRouter`, `Header`, and `Switch` components).
    This is the first time that we have seen the actual implementation of a React
    component. In this case, a React component is a function that returns some JSX.
    However, it is important to mention that this is not always the case as a component
    can also be a class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码片段所示，`Layout` 组件是一个返回一系列嵌套 JSX 元素的函数；其中一些 JSX 元素是其他 React 组件（例如 `BrowserRouter`、`Header`
    和 `Switch` 组件）。这是我们第一次看到 React 组件的实际实现。在这种情况下，一个 React 组件是一个返回一些 JSX 的函数。然而，重要的是要提到这并不总是如此，因为组件也可以是一个类。
- en: React is a component-based frontend development framework. This means that in
    React, everything is a component. Our application is a component, the pages within
    the application are components, and the elements in each of the pages are components.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个基于组件的前端开发框架。这意味着在 React 中，一切都是组件。我们的应用程序是一个组件，应用程序内的页面是组件，每个页面中的元素也是组件。
- en: The `Layout` component is the application's root component. The `Layout` component
    is always rendered on screen. However, the pages within the application are conditionally
    rendered as a child of the `Layout` component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout` 组件是应用程序的根组件。`Layout` 组件始终在屏幕上渲染。然而，应用程序内的页面作为 `Layout` 组件的子组件有条件地渲染。'
- en: 'The `Layout` component uses the `react-router` module to implement routing
    in our React application. The `react-router` module includes the following React
    components:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout` 组件使用 `react-router` 模块在我们的 React 应用程序中实现路由。`react-router` 模块包括以下 React
    组件：'
- en: The `BrowserRouter` module is used to provide other components with access to
    some browser APIs required to implement client-side navigation (such as the History
    API).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BrowserRouter` 模块用于为其他组件提供访问实现客户端导航所需的某些浏览器 API（例如 History API）的权限。'
- en: The `Switch` component allows us to define the routes available in our application.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch` 组件允许我们定义应用程序中可用的路由。'
- en: The `Route` component allows us to define a route in our application. The `Route`
    component takes a `path` and a `component` as properties. When the browser URL
    matches one of the routes, the respective component is rendered.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Route` 组件允许我们在应用程序中定义路由。`Route` 组件接受 `path` 和 `component` 作为属性。当浏览器 URL 与其中一个路由匹配时，相应的组件将被渲染。'
- en: The `Link` component is not used by the `Layout` component directly. However,
    it is the component used to declare a link to one of the existing routes.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Link` 组件不是由 `Layout` 组件直接使用的。然而，它是用来声明指向现有路由之一的链接的组件。'
- en: 'The following code snippet showcases how the `Layout` component declares three
    different routes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `Layout` 组件如何声明三个不同的路由：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we have already mentioned, the `Link` component is not used by the `Layout`
    component, but it can be used as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，`Link` 组件不是由 `Layout` 组件使用的，但它可以如下使用：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we have already mentioned, the JSX syntax is almost identical to the HTML
    syntax. However, some attributes are not available or are named differently (for
    example, `className`). Another significant difference is that we must use a special
    syntax (`{}`) to bind the value of a variable to one of the properties of a component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，JSX 语法几乎与 HTML 语法相同。但是，一些属性不可用或名称不同（例如，`className`）。另一个显著的区别是我们必须使用特殊语法（`{}`）将变量的值绑定到组件的一个属性上。
- en: Working with React components
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 React 组件一起工作
- en: In this section, we are going to take a close look at some of the components
    used by the application included in the companion source code. We will use multiple
    components to demonstrate multiple concepts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仔细研究一些在配套源代码中包含的应用程序使用的组件。我们将使用多个组件来展示多个概念。
- en: Components as classes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件作为类
- en: The following code snippet declares three components named `Container`, `Row`,
    and `Column`. These components extend the `Component` class, which is imported
    from the `React` module. There are a few methods that we can implement in a class
    that extends the `Component` class, but at a bare minimum, we must implement the
    `render` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了三个名为 `Container`、`Row` 和 `Column` 的组件。这些组件扩展了从 `React` 模块导入的 `Component`
    类。在扩展 `Component` 类的类中，我们可以实现一些方法，但至少必须实现 `render` 方法。
- en: 'The `Container`, `Row`, and `Column` components are used to control the layout
    of a page. These components use the CSS classes from the Bootstrap (a library
    that allow us to style our application with ease) grid system. In Bootstrap, the
    layout has a maximum of 12 columns, and a different size can be declared for a
    given screen size:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container`、`Row` 和 `Column` 组件用于控制页面的布局。这些组件使用来自 Bootstrap（一个允许我们轻松为应用程序添加样式的库）的
    CSS 类网格系统。在 Bootstrap 中，布局最多有 12 列，可以为特定屏幕尺寸声明不同的尺寸：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Properties and state
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和状态
- en: 'As we can see in the preceding code snippet, the `Component` class is a generic
    class with two optional generic types: `Component<TProps, TState>`. These two
    generic types allow us to specify the type of the properties and state used in
    a React component.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`Component` 类是一个泛型类，具有两个可选的泛型类型：`Component<TProps, TState>`。这两个泛型类型允许我们指定在
    React 组件中使用的属性和状态类型。
- en: As you can see, the `Container` and the `Row` components don't have any properties
    or state. However, the `Column` component defines the type of its properties because
    we need some additional data to be provided by its consumers. For example, when
    we declare the `Column` component, we don't know if the consumers will set its
    size to 1 or 12.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Container` 和 `Row` 组件没有任何属性或状态。然而，`Column` 组件定义了其属性的类型，因为我们需要消费者提供一些额外的数据。例如，当我们声明
    `Column` 组件时，我们不知道消费者是否会将其大小设置为 1 或 12。
- en: 'Properties are passed to a component via its constructor by the consumers of
    the component. For example, the following code snippet demonstrates how we can
    pass the property `width` to the `Column` component. The code snippet also demonstrates
    how we can pass other properties to the `Card` component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通过组件的构造函数由组件的消费者传递。例如，以下代码片段演示了我们可以如何将属性 `width` 传递给 `Column` 组件。代码片段还演示了如何将其他属性传递给
    `Card` 组件：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A component can also have an internal state. The main difference between properties
    and states is that properties are immutable. In other words, the value of the
    properties of a component cannot change (be mutated) after the component instantiation.
    On the other hand, the state of a component mutates through the `setState` function.
    For example, the following code snippet declares a component that uses both properties
    and states. The component displays a basic numeric counter that increments when
    the users click on a button. The component properties are used to set the initial
    state of the component (the value of the counter). The state is then mutated by
    the `setState` function when the users click on the button:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 组件也可以有内部状态。属性和状态之间的主要区别是属性是不可变的。换句话说，组件属性的值在组件实例化后不能改变（被变异）。另一方面，组件的状态通过`setState`函数进行变异。例如，以下代码片段声明了一个使用属性和状态的组件。该组件显示了一个基本的数字计数器，当用户点击按钮时计数器会增加。组件属性用于设置组件的初始状态（计数器的值）。然后，当用户点击按钮时，通过`setState`函数对状态进行变异：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding component can be consumed as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个组件可以按以下方式使用：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The state of a component can only be changed by the component itself. In general,
    properties are preferred over internal states because it can lead to maintainability
    issues in very large projects. This is mainly because when we use an internal
    state, it is slightly more complicated to keep track of state mutations and the current
    state. We are going to learn more about this topic later in this chapter in the
    *Smart components and dumb components* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的状态只能由组件本身更改。一般来说，属性比内部状态更受欢迎，因为它可能导致在非常大的项目中出现可维护性问题。这主要是因为当我们使用内部状态时，跟踪状态变更和当前状态稍微复杂一些。我们将在本章的*智能组件和傻瓜组件*部分中更详细地了解这个话题。
- en: Functional stateless components
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性无状态组件
- en: 'A **functional stateless component** (**FSC**) is a component that doesn''t
    use an internal state, and it is a simple function, as opposed to a class that
    extends the `Component` class. For example, the `Header` component is an FSC:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**功能性无状态组件**（**FSC**）是一个不使用内部状态的组件，它是一个简单的函数，与扩展`Component`类的类相对。例如，`Header`组件就是一个FSC：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: React component life cycle
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件生命周期
- en: 'When a component extends the `Component` class, it is possible to implement
    some component life cycle hooks. The companion source code includes a component
    named `MoviePage` that declares a component life cycle hook named `componentWillMount`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件扩展`Component`类时，可以实现一些组件生命周期钩子。配套源代码中包含一个名为`MoviePage`的组件，它声明了一个名为`componentWillMount`的组件生命周期钩子：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'React allows us to declare multiple component life cycle hooks. Covering all
    the available React component life cycle hooks is out of the scope of this book.
    However, it is important to understand that the events are organized into three
    main phases:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: React允许我们声明多个组件生命周期钩子。涵盖所有可用的React组件生命周期钩子超出了本书的范围。然而，了解事件被组织成三个主要阶段是很重要的：
- en: The mounting phase takes place before the component is rendered
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装阶段发生在组件渲染之前
- en: The updating phase included the rendering and the moment immediately before
    and after the component has been rendered
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新阶段包括渲染以及组件渲染前后的瞬间
- en: The unmounting phase takes place when the component is about to stop being rendered
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载阶段发生在组件即将停止渲染时
- en: 'The following diagram showcases the order in which the main events are executed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了主事件执行的顺序：
- en: '![](img/80051090-0f69-4212-a831-c2ec76fd1cd3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80051090-0f69-4212-a831-c2ec76fd1cd3.png)'
- en: Please refer to the official React documentation at [https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)
    to learn more about the component life cycle events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)的官方React文档，了解更多关于组件生命周期事件的信息。
- en: Smart components and dumb components
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能组件和傻瓜组件
- en: 'In a real-world React application, we will have many stateless React components,
    but somewhere in our tree of components, a component must be responsible for the
    management of the application state. This means that we can group them into two
    main categories:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的React应用程序中，我们将有许多无状态React组件，但在我们组件树中的某个地方，必须有一个组件负责管理应用程序的状态。这意味着我们可以将它们分为两大类：
- en: '**Dumb components** are also known as presentational components because their
    only responsibility is to present something to the DOM. Dumb components may be
    functional stateless components or not.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态组件**也被称为展示组件，因为它们的唯一责任是将某些内容呈现到 DOM 中。无状态组件可能是函数式无状态组件，也可能不是。'
- en: '**Smart components** are also known as container components because they are
    the ones that keep track of states and care about how the app works.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能组件**也被称为容器组件，因为它们是跟踪状态并关注应用程序如何工作的组件。'
- en: The separation between smart and dumb components can be achieved in many ways,
    and it is sometimes coupled to some implementation details. The most simplistic
    way to achieve this is to have a smart component that uses an internal state and
    the `setState` function and some dumb components that take their parent's internal
    state as their properties. However, it is also very common to use external state
    container libraries (such as Redux or MobX) to implement smart components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 智能组件和无状态组件之间的分离可以通过多种方式实现，有时它与某些实现细节相关联。最简单的方法是拥有一个使用内部状态和 `setState` 函数的智能组件，以及一些将父组件的内部状态作为其属性的无状态组件。然而，使用外部状态容器库（如
    Redux 或 MobX）来实现智能组件也非常常见。
- en: The application included in the companion source code declares a lot of dumb
    components (under the `components` directory) and some smart components (under
    the `pages` directory). The smart components are the ones responsible for the
    management of the application state. However, instead of using the `setState`
    function we are using MobX and some design patterns to ensure that our application
    can scale in a predictable and maintainable way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码中的应用程序包含许多无状态组件（位于 `components` 目录下）和一些智能组件（位于 `pages` 目录下）。智能组件是负责管理应用程序状态的组件。然而，我们不是使用
    `setState` 函数，而是使用 MobX 和一些设计模式来确保我们的应用程序可以以可预测和可维护的方式扩展。
- en: Working with MobX
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MobX
- en: MobX is a library that helps us to manage and mutate the state in a React application.
    In this section, we are going to understand the MobX architecture. We will also
    learn how to install and configure it, what its main components are, and its APIs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MobX 是一个库，帮助我们管理并修改 React 应用程序中的状态。在本节中，我们将了解 MobX 架构。我们还将学习如何安装和配置它，了解其主要组件以及其
    API。
- en: Understanding the MobX architecture
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 MobX 架构
- en: 'The MobX architecture introduces an entity known as the `Store`. A `Store`
    is an object that contains some state and provides access to some actions that
    allow us to mutate its internal state:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MobX 架构引入了一个名为 `Store` 的实体。`Store` 是一个包含一些状态并提供访问一些动作的对象，这些动作允许我们修改其内部状态：
- en: The state is observable; this means that when its value changes, an event is
    emitted and other parts of the application can subscribe to state changes
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是可观察的；这意味着当其值发生变化时，会发出一个事件，并且应用程序的其他部分可以订阅状态变化
- en: The actions allow us to mutate the current state
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作允许我们修改当前状态
- en: Working with actions and observables
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作和可观察对象
- en: 'In this section, we are going to learn to use observables and actions. The
    following code snippet declares a `Store` named `ActorStore`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用可观察对象和动作。以下代码片段声明了一个名为 `ActorStore` 的 `Store`：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ActorStore` is a class that is decorated with the `@provide` decorators.
    This decorator is used to allow us to inject the `Store` into other elements in
    the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorStore` 是一个被 `@provide` 装饰器装饰的类。这个装饰器用于允许我们将 `Store` 注入到应用程序的其他元素中。'
- en: Please note that we will learn more about the `@provide` decorator later in
    this chapter in the *Dependency injection in MobX* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本章的 *MobX 中的依赖注入* 部分后面学习更多关于 `@provide` 装饰器的知识。
- en: 'The `Store` class also declares some properties that are decorated with the
    `@observable` decorator. This decorator allows other elements in our application
    to subscribe to the changes in the properties:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Store` 类还声明了一些被 `@observable` 装饰器装饰的属性。这个装饰器允许我们的应用程序中的其他元素订阅属性的变化：'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After declaring the properties of the `Store`, we are going to declare its
    actions. As you can see in the following code snippet, an action is a method decorated
    with the `@action` decorator:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 `Store` 的属性之后，我们将声明其动作。正如您在以下代码片段中可以看到的，动作是一个被 `@action` 装饰器装饰的方法：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `@action` decorator can be used to decorate methods that perform state
    mutations like the preceding methods, but we are not limited to only this kind
    of operation. The following methods perform state mutations, but they also send
    some HTTP requests to the server using the Fetch API. There is an action to fetch
    all actors from the actors REST API:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`@action`装饰器可以用来装饰执行状态变更的方法，如前面的方法，但我们不仅限于这种操作。以下方法执行状态变更，同时也使用Fetch API向服务器发送一些HTTP请求。有一个动作是从演员REST
    API获取所有演员：'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is also an action to create a new actor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个动作可以创建新的演员：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is also an action to delete an actor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个动作可以删除演员：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We use the `runInAction` function to wrap the state mutations. Using the `runInAction`
    function is required because we previously configured MobX to enforce that state
    mutations must only take place in actions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`runInAction`函数来包装状态变更。使用`runInAction`函数是必需的，因为我们之前配置了MobX，强制要求状态变更只能在动作中发生：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, our `Store` is ready to be injected into one of our React smart
    components using the `@lazyInject` decorator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`Store`已经准备好使用`@lazyInject`装饰器注入到我们的React智能组件中。
- en: Please note that we will learn more about the `@lazyInject` decorator later
    in this chapter in the *Dependency injection in MobX* section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本章的*依赖注入在MobX*部分中学习更多关于`@lazyInject`装饰器的知识。
- en: 'The following code snippet declares a smart component named `MoviePages`. In
    our React application, the pages are smart components and the components are simply
    dumb components:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为`MoviePages`的智能组件。在我们的React应用程序中，页面是智能组件，而组件本身是简单的哑组件：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This smart component is implemented using a class that extends the `Component`
    class and is decorated with the `@observer` decorator. The `@observer` decorator
    binds the React component to the state changes in the `Store`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能组件是通过一个扩展`Component`类并带有`@observer`装饰器的类实现的。`@observer`装饰器将React组件绑定到`Store`中的状态变更：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `MovieStore` is injected into the `Component` after an instance of it has
    been created by React. We can ignore the details about this for now because it
    will be explained in the following section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在React创建`Component`实例之后，将`MovieStore`注入到该组件中。现在我们可以忽略这方面的细节，因为将在下一节中解释：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use then the `componentWillMount` event hook to trigger the initial data-fetching
    action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`componentWillMount`事件钩子来触发初始数据获取操作：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we render the page. The `render` method accesses some of the properties
    (`@observables`) of the `Store`. Because our component is an observer (`@observer`),
    if an action (`@action`) is triggered, our component will be re-rendered. The
    component renders a list of movies:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们渲染页面。`render`方法访问`Store`的一些属性（`@observables`）。由于我们的组件是观察者（`@observer`），如果触发了一个动作（`@action`），我们的组件将被重新渲染。该组件渲染电影列表：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This component also renders a modal window that allows us to create a movie:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还渲染一个模态窗口，允许我们创建电影：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This component also renders a modal window that allows us to confirm that we
    wish to delete a movie from the database:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件还渲染一个模态窗口，允许我们确认是否要从数据库中删除电影：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Dependency injection in MobX
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX中的依赖注入
- en: 'In the preceding section, we decorated the `ActorStore` class with the `@provide`
    decorators:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用`@provide`装饰器对`ActorStore`类进行了装饰：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This decorator is an alternative to the InversifyJS biding syntax and is equivalent
    to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器是InversifyJS绑定语法的替代方案，等同于以下内容：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `@provide` decorator is not required but it is more convenient than the
    binding API. The `@provide` decorator can be created using the `inversify-binding-decorators`
    module as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`@provide`装饰器不是必需的，但比绑定API更方便。可以使用`inversify-binding-decorators`模块创建`@provide`装饰器，如下所示：'
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the examples use the version 3.2.0 of the `inversify-binding-decorators`
    module and the upcoming version (4.0.0) will introduce some breaking changes.
    You can refer to the documentation at [https://github.com/inversify/inversify-binding-decorators](https://github.com/inversify/inversify-binding-decorators)
    to learn more about the new API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，示例使用了`inversify-binding-decorators`模块的3.2.0版本，即将推出的4.0.0版本将引入一些破坏性更改。您可以参考[https://github.com/inversify/inversify-binding-decorators](https://github.com/inversify/inversify-binding-decorators)上的文档来了解有关新API的更多信息。
- en: 'The `@provider` decorator declares a binding automatically for us when it is
    executed, and decorators are executed when a class is declared. This means that
    we need to import the files that use the `@provider` decorator at least once in
    our application to trigger the class declaration, or no bindings will be declared:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`@provider` 装饰器在执行时会自动为我们声明绑定，而装饰器在类声明时会被执行。这意味着我们需要在我们的应用程序中至少导入一次使用 `@provider`
    装饰器的文件来触发类声明，否则将不会声明任何绑定：'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After declaring the bindings, the `Store` is injected into a React component.
    However, we cannot use the `@injectable` and `@inject` annotations as we did in
    some of the preceding chapters because React components are instantiated by React.
    This means that our IoC container will not be able to create instances of our
    React components and will therefore not be able to perform any constructor injection.
    We can overcome this limitation by using the `@lazyInject` decorator:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明绑定之后，`Store` 被注入到 React 组件中。然而，我们不能像在前几章中做的那样使用 `@injectable` 和 `@inject`
    注解，因为 React 组件是由 React 实例化的。这意味着我们的 IoC 容器将无法创建我们的 React 组件实例，因此无法执行任何构造函数注入。我们可以通过使用
    `@lazyInject` 装饰器来克服这种限制：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `@lazyInject` decorator injects a dependency immediately before it is used
    instead of injecting it when an instance of its dependent is created. The `@lazyInject`
    decorator can be created using the `inversify-inject-decorators` module as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`@lazyInject` 装饰器在依赖项被使用之前立即注入它，而不是在其依赖项的实例创建时注入。可以使用 `inversify-inject-decorators`
    模块创建 `@lazyInject` 装饰器，如下所示：'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, to learn more about dependency injection and InversifyJS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [第 5 章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，以了解更多关于依赖注入和
    InversifyJS 的信息。
- en: Using dependency injection in MobX is useful because we can inject a different
    store with hardcoded results during the execution of the unit tests. This allows
    us to test the components in complete isolation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MobX 中使用依赖注入是有用的，因为我们可以注入一个具有硬编码结果的不同的存储库来执行单元测试。这允许我们在完全隔离的情况下测试组件。
- en: MobX alternatives
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MobX 替代方案
- en: We have been using MobX to manage the state of our application and the required
    state mutations (actions). MobX is a great library and it has great support for
    TypeScript. However, it is not the only option.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用 MobX 来管理我们应用程序的状态和所需的状态变更（动作）。MobX 是一个优秀的库，并且它对 TypeScript 有很好的支持。然而，它并不是唯一的选择。
- en: One of the best features of React is that we have the freedom to select many
    different state management tools and architectures. Freedom of choice can lead
    to confusion and is a problem for junior engineers because they don't have the
    experience required to judge if a library is better than another. On the other
    hand, freedom can lead to more innovation and better solutions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: React 最好的特性之一是我们有选择许多不同状态管理工具和架构的自由。选择自由可能会导致困惑，并且是初级工程师的问题，因为他们没有足够的经验来判断一个库是否比另一个库更好。另一方面，自由可以导致更多的创新和更好的解决方案。
- en: The two most popular alternatives to MobX are Redux and Flux. You can learn
    more about Redux at [https://redux.js.org](https://redux.js.org). Please refer
    to [https://facebook.github.io/flux](https://facebook.github.io/flux/) to learn
    more about Flux.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MobX 的两个最受欢迎的替代方案是 Redux 和 Flux。您可以在 [https://redux.js.org](https://redux.js.org)
    上了解更多关于 Redux 的信息。请参考 [https://facebook.github.io/flux](https://facebook.github.io/flux/)
    了解更多关于 Flux 的信息。
- en: Development tools
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: We can install the React development tools extensions for Google Chrome to help
    us to debug our frontend React applications. The extension can be downloaded at
    [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 Google Chrome 安装 React 开发者工具扩展来帮助我们调试我们的前端 React 应用程序。该扩展可以从 [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
    下载。
- en: 'There is also a Google Chrome extension available that can help us to debug
    a MobX application. We can download the extension at the official installation
    page: [https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod](https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个可用的 Google Chrome 扩展程序可以帮助我们调试 MobX 应用程序。我们可以在官方安装页面下载此扩展程序：[https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod](https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod).
- en: 'These tools allow us to see components being rendered, their properties and
    state, and the MobX actions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具允许我们查看正在渲染的组件、它们的属性和状态，以及 MobX 动作：
- en: '![](img/56b27ebe-b622-425a-bbe7-97205090ef17.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56b27ebe-b622-425a-bbe7-97205090ef17.png)'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the basic principles of component-based web
    development and how to use React. We have also learned about concepts like stateless
    functional components and dumb components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了基于组件的 Web 开发的基本原则以及如何使用 React。我们还了解了诸如无状态函数组件和哑组件等概念。
- en: In the next chapter, we are going to implement the same application one more
    time. However, we will use Angular instead of React and MobX as our application
    development framework. We will try to implement a copy of the application as close
    as possible to enable us to compare both frameworks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将再次实现相同的应用程序。然而，我们将使用 Angular 而不是 React，并将 MobX 作为我们的应用程序开发框架。我们将尝试实现尽可能接近的应用程序副本，以便我们能够比较这两个框架。
