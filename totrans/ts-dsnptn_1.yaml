- en: Chapter 3. Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns in object-oriented programming are design patterns
    that are to be applied during the instantiation of objects. In this chapter, we'll
    be talking about patterns in this category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider we are building a rocket, which has payload and one or more stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In old-fashioned JavaScript, there are two major approaches to building such
    a rocket:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor with `new` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first approach, things could be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the second approach, it could be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From a certain angle, they are doing pretty much the same thing, but semantically
    they differ a lot. The constructor approach suggests a strong association between
    the building process and the final product. The factory function, on the other
    hand, implies an interface of its product and claims the ability to build such
    a product.
  prefs: []
  type: TYPE_NORMAL
- en: However, neither of the preceding implementations provides the flexibility to
    modularly assemble rockets based on specific needs; this is what creational design
    patterns are about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following creational patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Factory method**: By using abstract methods of a factory instead of the constructor
    to build instances, this allows subclasses to change what''s built by implementing
    or overriding these methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract factory**: Defining the interface of compatible factories and their
    *products*. Thus by changing the factory passed, we can change the family of built
    products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder**: Defining the *steps* of building complex objects, and changing
    what''s built either by changing the sequence of steps, or using a different builder
    implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: Creating objects by cloning parameterized prototypes. Thus by
    replacing these prototypes, we may build different products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: Ensuring only one instance (under a certain scope) will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting to see that even though the factory function approach to creating
    objects in JavaScript looks primitive, it does have parts in common with some
    patterns we are going to talk about (although applied to different scopes).
  prefs: []
  type: TYPE_NORMAL
- en: Factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under some scenarios, a class cannot predict exactly what objects it will create,
    or its subclasses may want to create more specified versions of these objects.
    Then, the Factory Method Pattern can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture shows the possible structure of the Factory Method Pattern
    applied to creating rockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory method](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A **factory method** is a method of a factory that builds objects. Take building
    rockets as an example; a factory method could be a method that builds either the
    entire rocket or a single component. One factory method might rely on other factory
    methods to build its target object. For example, if we have a `createRocket` method
    under the `Rocket` class, it would probably call factory methods like `createStages`
    and `createPayload` to get the necessary components.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method Pattern provides some flexibility upon reasonable complexity.
    It allows extendable usage by implementing (or overriding) specific factory methods.
    Taking `createStages` method, for example, we can create a one-stage rocket or
    a two-stage rocket by providing different `createStages` method that return one
    or two stages respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of a typical Factory Method Pattern implementation include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product: `Rocket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define an abstract class or an interface of a rocket that will be created as
    the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concrete product: `FreightRocket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a specific rocket product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creator: `RocketFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the optionally abstract factory class that creates products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concrete creator: `FreightRocketFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement or overrides specific factory methods to build products on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Factory Method Pattern decouples `Rocket` from the constructor implementation
    and makes it possible for subclasses of a factory to change what's built accordingly.
    A concrete creator still cares about what exactly its components are and how they
    are built. But the implementation or overriding usually focuses more on each component,
    rather than the entire product.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin with building a simple one-stage rocket that carries a 0-weight
    payload as the default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with creating components. We will simply return a payload with 0 weight
    for the factory method `createPayload` and one single stage with one single engine
    for the factory method `createStages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After implementing methods to create the components of a rocket, we are going
    to put them together with the factory method `buildRocket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the blueprint of a simple rocket factory, yet with certain extensibilities.
    To build a rocket (that does nothing so far), we just need to instantiate this
    very factory and call its `buildRocket` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to build two-stage freight rockets that send satellites into
    orbit. Thus, there are some differences compared to the basic factory implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a different payload, satellites, instead of a 0-weight placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we now have two stages, probably with different specifications. The
    first stage is going to have four engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While the second stage has only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have what this new freight rocket would look like in mind, let''s extend
    the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we are using the *type alias* of a *tuple* to represent the stages sequence
    of a freight rocket, namely the first and second stages. To find out more about
    type aliases, please refer to [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we added the `id` property to `Satellite`, we might need a counter for each
    instance of the factory, and then create every satellite with a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on and implement the `createStages` method that builds first and
    second stage of the rocket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Comparing to the original implementation, you may have noticed that we've automatically
    decoupled specific stage building processes from assembling them into constructors
    of different stages. It is also possible to apply another creational pattern for
    the initiation of every stage if it helps.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding implementation, the factory method `buildRocket` handles the
    outline of the building steps. We were lucky to have the freight rocket in the
    same structure as the very first rocket we had defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that won''t always happen. If we want to change the class of products (`Rocket`),
    we''ll have to override the entire `buildRocket` with everything else but the
    class name. This looks frustrating but it can be solved, again, by decoupling
    the creation of a rocket instance from the building process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus we can change the rocket class by overriding the `createRocket` method.
    However, the return type of the `buildRocket` of a subclass (for example, `FreightRocketFactory`)
    is still `Rocket` instead of something like `FreightRocket`. But as the object
    created is actually an instance of `FreightRocket`, it is valid to cast the type
    by type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The trade-off is a little type safety, but that can be eliminated using generics.
    Unfortunately, in TypeScript what you get from a generic type argument is just
    a type without an actual value. This means that we may need another level of abstraction
    or other patterns that can use the help of type inference to make sure of everything.
  prefs: []
  type: TYPE_NORMAL
- en: The former option would lead us to the Abstract Factory Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type safety could be one reason to consider when choosing a pattern but usually,
    it will not be decisive. Please note we are not trying to switch a pattern for
    this single reason, but just exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Abstract Factory Pattern usually defines the interfaces of a collection
    of factory methods, without specifying concrete products. This allows an entire
    factory to be replaceable, in order to produce different products following the
    same production outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract Factory](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of the products (components) are omitted from the diagram, but
    do notice that these products belong to two parallel families: `ExperimentalRocket`
    and `FreightRocket`.'
  prefs: []
  type: TYPE_NORMAL
- en: Different from the Factory Method Pattern, the Abstract Factory Pattern extracts
    another part called **client** that take cares of shaping the outline of the building
    process. This makes the factory part focused more on producing each component.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of a typical Abstract Factory Pattern implementation include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract factory**: `RocketFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the *industrial standards* of a factory which provide interfaces for
    manufacturing components or complex products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concrete factory**: `ExperimentalRocketFactory`, `FreightRocketFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the interfaces defined by the abstract factory and builds concrete
    products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract products**: `Rocket`, `Payload`, `Stage[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the interfaces of the products the factories are going to build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concrete products**: `ExperimentalRocket`/`FreightRocket`, `ExperimentalPayload`/`Satellite`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presents actual products that are manufactured by a concrete factory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranges the production process across factories (only if these factories conform
    to *industrial standards*).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract Factory Pattern makes the abstraction on top of different concrete
    factories. At the scope of a single factory or a single branch of factories, it
    just works like the Factory Method Pattern. However, the highlight of this pattern
    is to make a whole family of products interchangeable. A good example could be
    components of themes for a UI implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Abstract Factory Pattern, it is the client interacting with a concrete
    factory for building integral products. However, the concrete class of products
    is decoupled from the client during design time, while the client cares only about
    what a factory and its products look like instead of what exactly they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by simplifying related classes to interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course the abstract factory itself is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The building steps are abstracted from the factory and put into the client,
    but we still need to implement it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the same issue we previously had when we implemented the Factory
    Method Pattern. As different concrete factories build different rockets, the class
    of the product changes. However, now we have generics to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a `RocketFactory`  interface with a generic type parameter that
    describes a concrete rocket class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And second, update the `buildRocket` method of the client to support generic
    factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, with the help of the type system, we will have rocket type inferred based
    on the type of a concrete factory, starting with `ExperimentalRocket` and `ExperimentalRocketFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `buildRocket` method of a client with an instance of `ExperimentalRocketFactory`,
    the return type will automatically be `ExperimentalRocket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can complete the implementation of the `ExperimentalRocketFactory` object,
    we need to define concrete classes for the products of the family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trivial initializations of payload and stage are omitted for more compact content.
    The same kinds of omission may be applied if they are not necessary for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we may define the factory methods of this concrete factory class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to another concrete factory that builds a freight rocket and
    products of its family, starting with the rocket components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue with the rocket itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the structures or classes of the freight rocket family defined, we are
    ready to implement its factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we once again have two families of rockets and their factories, and we
    can use the same client to build different rockets by passing different factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Abstract Factory Pattern makes it easy and smooth to change the entire family
    of products. This is the direct benefit brought by the factory level abstraction.
    As a consequence, it also brings other benefits, as well as some disadvantages
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, it provides better compatibility within the products in a specific
    family. As the products built by a single factory are usually meant to work together,
    we can assume that they tend to cooperate more easily.
  prefs: []
  type: TYPE_NORMAL
- en: But on the other hand, it relies on a common outline of the building process,
    although for a well-abstracted building process, this won't always be an issue.
    We can also parameterize factory methods on both concrete factories and the client
    to make the process more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, an abstract factory does not have to be a pure interface or an abstract
    class with no methods implemented. An implementation in practice should be decided
    based on detailed context.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Abstract Factory Pattern and Factory Method Pattern have abstractions
    of different levels, what they encapsulate are similar. For building a product
    with multiple components, the factories split the products into components to
    gain flexibility. However, a fixed family of products and their internal components
    may not always satisfy the requirements, and thus we may consider the Builder
    Pattern as another option.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Factory Patterns expose the internal components (such as the payload and
    stages of a rocket), the Builder Pattern encapsulates them by exposing only the
    building steps and provides the final products directly. At the same time, the
    Builder Pattern also encapsulates the internal structures of a product. This makes
    it possible for a more flexible abstraction and implementation of building complex
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Builder Pattern also introduces a new role called **director**, as shown
    in the following diagram. It is quite like the client in the Abstract Factory
    Pattern, although it cares only about build steps or pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Builder](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the only constraint from `RocketBuilder` that applies to a product of its
    subclass is the overall shape of a `Rocket`. This might not bring a lot of benefits
    with the `Rocket` interface we previously defined, which exposes some details
    of the rocket that the clients (by clients I mean those who want to send their
    satellites or other kinds of payload to space) may not care about that much. For
    these clients, what they want to know might just be which orbit the rocket is
    capable of sending their payloads to, rather than how many and what stages this
    rocket has.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of a typical Builder Pattern implementation include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Builder**: `RocketBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of a builder that builds products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concrete builder**: `FalconBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements methods that build parts of the products, and keeps track of the
    current building state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Director**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the steps and collaborates with builders to build products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Final product**: `Falcon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product built by a builder.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Builder Pattern has a similar scope to the Abstract Factory Pattern, which
    extracts abstraction from a complete collection of operations that will finally
    initiate the products. Compared to the Abstract Factory Pattern, a builder in
    the Builder Pattern focuses more on the building steps and the association between
    those steps, while the Abstract Factory Pattern puts that part into the clients
    and makes its factory focus on producing components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As now we are assuming that stages are not the concern of the clients who want
    to buy rockets to carry their payloads, we can remove the `stages` property from
    the general `Rocket` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a rocket family called sounding rocket that sends probes to near space.
    And this means we don''t even need to have the concept of stages. `SoundingRocket`
    is going to have only one `engine` property other than `payload` (which will be
    a `Probe`), and the only engine will be a `SolidRocketEngine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But still we need rockets to send satellites, which usually use `LiquidRocketEngine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And we might want to have the corresponding  `LiquidRocketStage` abstract class
    that handles refuelling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update  `FreightRocketFirstStage` and `FreightRocketSecondStage`
    as subclasses of `LiquidRocketStage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FreightRocket` will remain the same as it was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, there is the builder. This time, we are going to use an abstract
    class that has the builder partially implemented, with generics applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's actually no abstract method in this abstract class. One of the reasons
    is that specific steps might be optional to certain builders. By implementing
    no-op methods, the subclasses can just leave the steps they don't care about empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `Director` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be cautious, without explicitly providing a building context, the builder instance
    relies on the building pipelines being queued (either synchronously or asynchronously).
    One way to avoid risk (especially with asynchronous operations) is to initialize
    a builder instance every time you prepare a rocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to implement concrete builders, starting with `SoundingRocketBuilder`,
    which builds a `SoundingRocket` with only one `SolidRocketEngine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several notable things in this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `addStages` method relies on the previously added payload to add an engine
    with the correct thrust specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `refuel` method is not overridden (so it remains no-op) because a solid
    rocket engine does not need to be refueled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve sensed a little about the context provided by a builder, and it could
    have a significant influence on the result. For example, let''s take a look at
    `FreightRocketBuilder`. It could be similar to `SoundingRocket` if we don''t take
    the `addStages` and `refuel` methods into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume that a payload that weighs less than `1000` takes only one stage to
    send into space, while payloads weighing more take two or more stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to refueling, we can even decide how much to refuel based on
    the weight of the payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can prepare different rockets ready to launch, with different builders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the Builder Pattern takes greater control of the product structures and how
    the building steps influence each other, it provides the maximum flexibility by
    subclassing the builder itself, without changing the director (which plays a similar
    role to a client in the Abstract Factory Pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As JavaScript is a prototype-based programming language, you might be using
    prototype related patterns all the time without knowing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve talked about an example in the Abstract Factory Pattern, and part of
    the code is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes we may need to add a subclass just for changing the class name while
    performing the same `new` operation. Instances of a single class usually share
    the same methods and properties, so we can `clone` one existing instance for new
    instances to be created. That is the concept of a prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in JavaScript, with the prototype concept built-in, `new Constructor()`
    does basically what a `clone` method would do. So actually a constructor can play
    the role of a concrete factory in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With this privilege, we can parameterize product or component classes as part
    of other patterns and make creation even more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is something that could easily be ignored when talking about the Prototype
    Pattern in JavaScript: cloning with the state. With the `class` syntax sugar introduced
    in ES6, which hides the prototype modifications, we may occasionally forget that
    we can actually modify prototypes directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `derived` object will keep the `state` of the `base` object. This could
    be useful when you want to create copies of a specific instance, but keep in mind
    that properties in a prototype of these copies are not the *own properties* of
    these cloned objects.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are scenarios in which only one instance of the specific class should
    ever exist, and that leads to Singleton Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Basic implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest singleton in JavaScript is an object literal; it provides a quick
    and cheap way to create a unique object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But sometimes we might want private variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we want to take the advantage of an anonymous constructor function or class
    expression in ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `private` modifier only has an effect at compile time, and
    simply disappears after being compiled to JavaScript (although of course its accessibility
    will be kept in `.d.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to have the requirements for creating new instances
    of "singletons" sometimes. Thus a normal class will still be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another benefit brought by this approach is lazy initialization: the object
    only gets initialized when it gets accessed the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional singletons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we might want to get "singletons" based on certain conditions. For
    example, every country usually has only one capital city, thus a capital city
    could be treated as a singleton under the scope of the specific country.
  prefs: []
  type: TYPE_NORMAL
- en: The condition could also be the result of context rather than explicit arguments.
    Assuming we have a class `Environment` and its derived classes, `WindowsEnvironment`
    and `UnixEnvironment`, we would like to access the correct environment singleton
    across platforms by using `Environment.default` and apparently, a selection could
    be made by the `default` getter.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex scenarios, we might want a registration-based implementation
    to make it extendable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've talked about several important creational design patterns
    including the Factory Method, Abstract Factory, Builder, Prototype, and Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the Factory Method Pattern, which provides flexibility with limited
    complexity, we also explored the Abstract Factory Pattern, the Builder Pattern
    and the Prototype Pattern, which share similar levels of abstraction but focus
    on different aspects. These patterns have more flexibility than the Factory Method
    Pattern, but are more complex at the same time. With the knowledge of the idea
    behind each of the patterns, we should be able to choose and apply a pattern accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: While comparing the differences, we also found many things in common between
    different creational patterns. These patterns are unlikely to be isolated from
    others and some of them can even collaborate with or complete each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to discuss structural patterns that help
    to form large objects with complex structures.
  prefs: []
  type: TYPE_NORMAL
