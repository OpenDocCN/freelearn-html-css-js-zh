- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Test-Driving Service Workers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动服务工作者
- en: This chapter looks at **service workers**, which are bits of code that are installed
    on the browser and are invoked before any HTTP operation. That makes them useful
    for a certain set of features, such as enabling offline access to your app. The
    service worker implemented in this chapter provides exactly that feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了**服务工作者**，这些代码片段被安装在浏览器上，并在任何 HTTP 操作之前被调用。这使得它们对于一组特定的功能非常有用，例如启用对您的应用程序的离线访问。本章实现的服务工作者正好提供了这个功能。
- en: It’s almost always a good idea to use off-the-shelf service workers rather than
    rolling your own. But it’s instructive to see how you might test your own service
    workers, hence the inclusion in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用现成的服务工作者而不是自己编写是一个好主意。但是，了解如何测试自己的服务工作者是有教育意义的，因此本书中包含了这部分内容。
- en: The term **testability** is used to describe how straightforward it is to write
    tests for your application code. The way we structure our components and modules
    has a big impact on their testability. Service workers are a great example of
    taking something that, at first glance, is a highly complex thing to test and
    restructuring its implementation so that the tests become almost trivial.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**可测试性**用来描述编写应用程序代码测试的简单程度。我们构建组件和模块的方式对它们的可测试性有很大影响。服务工作者是这样一个很好的例子，即一开始看起来非常复杂难以测试的东西，通过重构其实现，使得测试变得几乎微不足道。
- en: 'This chapter covers the following key topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下关键主题：
- en: Adding a Playwright test for offline access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于离线访问的 Playwright 测试
- en: Implementing the service worker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务工作者
- en: By the end of the chapter, you’ll have learned how to test-drive service workers,
    plus you’ll have learned a new technique for making your application code more
    testable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何测试驱动服务工作者，并且你还将学会一种使你的应用程序代码更容易测试的新技术。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址是 [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter16/Complete)。
- en: Adding a Playwright test for offline access
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于离线访问的 Playwright 测试
- en: 'Service workers tend to have a specific intent. In our case, the service worker
    enables the application to be used offline: loading the application causes it
    to be cached. If the network is no longer accessible, the next page load will
    be served from this cache, courtesy of the service worker.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者通常具有特定的意图。在我们的例子中，服务工作者使应用程序能够离线使用：加载应用程序会导致它被缓存。如果网络不再可访问，下一次页面加载将从这个缓存中提供，这是服务工作者提供的。
- en: Therefore, the Playwright test needs to test the application’s behavior when
    there’s no network connection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Playwright 测试需要测试在没有网络连接时应用程序的行为。
- en: 'At the time of writing, Playwright’s support for service worker events is experimental,
    so it needs to be enabled using the `PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS`
    flag in your `package.json` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，Playwright 对服务工作者事件的支撑是实验性的，因此需要通过在 `package.json` 文件中使用 `PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS`
    标志来启用：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once that’s done, we’re ready to write our tests. We need two helper functions.
    The first, `waitForServiceWorkerActivation`, can be invoked by any Playwright
    test to ensure that subsequent commands don’t run until the service worker is
    actively caching new requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们就准备好编写测试了。我们需要两个辅助函数。第一个，`waitForServiceWorkerActivation`，可以被任何 Playwright
    测试调用，以确保后续命令在服务工作者正在积极缓存新请求之前不会运行。
- en: 'This code can be found in `tests/offline.test.js`. I’ve parked it right next
    to the single test that uses it: there’s not much point in moving it to another
    file because I don’t expect to reuse this function anywhere else in the test suite:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在 `tests/offline.test.js` 中找到。我把它放在了使用它的单个测试旁边：没有必要将其移动到另一个文件，因为我不会在测试套件的其他地方重用这个函数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need a `disableNetwork` function that will cause any network request
    to return a network error:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个 `disableNetwork` 函数，它将导致任何网络请求返回网络错误：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we’re ready to write the test:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就可以编写测试了：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Without the service worker, this test will fail because the second `page.goto`
    call will error. In the next section, we’ll see how this service worker can be
    implemented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有服务工作者，这个测试将会失败，因为第二个 `page.goto` 调用将会出错。在下一节中，我们将看到如何实现这个服务工作者。
- en: Implementing the service worker
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务工作者
- en: Service workers have an odd interface. For one thing, they need to rely on a
    variable named `self` that is provided by the browser context. Then they need
    to attach listeners to certain events, and they need to use the `event.waitUntil`
    function to ensure that the browser waits for its operations to finish before
    assuming the worker is ready.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者有一个奇怪的用户界面。一方面，它们需要依赖于浏览器上下文提供的名为`self`的变量。然后它们需要将监听器附加到某些事件上，并且它们需要使用`event.waitUntil`函数来确保浏览器在假设工作者准备好之前等待其操作完成。
- en: It turns out that it’s quite difficult to set up a value for `self` together
    with fake events within your Vitest tests. Not impossible, but difficult and laborious.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在Vitest测试中设置`self`的值以及伪造事件相当困难。并非不可能，但困难且费时。
- en: 'Given this complexity, the trick to implementing a testable service worker
    is to move most of the functionality into another module: each event becomes a
    simple function call, and we can test that function call rather than the event.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种复杂性，实现可测试的服务工作者的技巧是将大部分功能移入另一个模块：每个事件都变成一个简单的函数调用，我们可以测试这个函数调用而不是事件。
- en: Then, we leave the service worker module untested. We still have the Playwright
    test giving us coverage, and this code isn’t likely to change once it’s complete,
    so it’s no big deal that this particular file is without unit tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们不对服务工作者模块进行测试。我们仍然有Playwright测试为我们提供覆盖率，并且一旦完成，这段代码不太可能发生变化，所以这个特定文件没有单元测试并不是什么大问题。
- en: 'This example, shown in the following code block, is stored in the `src/service-worker.js`
    file. It pushes almost all the functionality into the `addFilesToCache`, `deleteOldCaches`,
    and `fetchWithCacheOnError` functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例，如下代码块所示，存储在`src/service-worker.js`文件中。它几乎将所有功能推入`addFilesToCache`、`deleteOldCaches`和`fetchWithCacheOnError`函数中：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s take a look at the implementation of the three functions located in the
    `src/lib/service-worker.js` file. Each of these functions makes use of the Cache
    API, which we’ll test by setting up spies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于`src/lib/service-worker.js`文件中的三个函数的实现。这些函数都使用了Cache API，我们将通过设置间谍来测试它。
- en: 'Here’s `addFilesToCache`, which simply opens the relevant cache and inserts
    all the given assets:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`addFilesToCache`，它只是简单地打开相关的缓存并插入所有给定的资产：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To begin testing that, first we need to define a default value for `caches`.
    In the sample repository, the following code lives in the test suite in `src/lib/service-worker.test.js`,
    but you could also place it in a Vitest setup file, which would make better sense
    if you had more than one test suite using the Cache API:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试这一点，首先我们需要为`caches`定义一个默认值。在示例仓库中，以下代码位于`src/lib/service-worker.test.js`测试套件中，但您也可以将其放置在Vitest设置文件中，如果您有多个测试套件使用Cache
    API，这会更有意义：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let’s start off with a `describe` block for the `addFilesToCache` function.
    All it takes is a call to `vi.spyOn` together with a hand-rolled cache object.
    Both the `caches` spy and the `cache` stub implement just enough for the purposes
    of testing the `addFilesToCache` function, nothing more, nothing less:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从`addFilesToCache`函数的`describe`块开始。它只需要调用`vi.spyOn`以及一个手工制作的缓存对象。`caches`间谍和`cache`存根仅实现了测试`addFilesToCache`函数所需的功能，不多也不少：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then the tests themselves are straightforward:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试本身很简单：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, here’s the definition of `deleteOldCaches`, which is a bit more complex:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`deleteOldCaches`的定义，它稍微复杂一些：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It turns out that our spy setup for this is much simpler:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们为这个设置的反间谍活动非常简单：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, the tests themselves are fairly straightforward. Notice how each of the
    tests is self-contained, with their own stub values for the `cache.keys` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试本身相当简单。注意每个测试都是自包含的，它们为`cache.keys`函数有自己的存根值：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we come to the `fetchWithCacheOnError` function, the most complex
    of the three. This involves the Cache API and the Fetch API, so our tests will
    need to deal with the `request` and `response` objects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到`fetchWithCacheOnError`函数，这是三个中最复杂的。这涉及到Cache API和Fetch API，因此我们的测试将需要处理`request`和`response`对象：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s take a look at the test setup. In addition to the `caches.open` spy and
    the `cache` stub; there’s also a `successResponse` object and a `request` object.
    These have dummy values: calling `successResponse.clone()` doesn’t give you back
    a response, and `request` isn’t a real request object. They’re just strings. But
    that’s all we need for the tests:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看测试设置。除了`caches.open`间谍和`cache`存根；还有一个`successResponse`对象和一个`request`对象。这些有虚拟值：调用`successResponse.clone()`不会返回一个响应，而`request`不是一个真正的请求对象。它们只是字符串。但这就是我们测试所需要的：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let’s look at the four happy path tests. These tests assume a working network
    connection and a valid HTTP response with a `200` status code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看四个快乐的路径测试。这些测试假设有一个正常工作的网络连接和一个有效的HTTP响应，状态码为`200`：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we have a test for an HTTP status code of anything other than `200`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对除了`200`以外的HTTP状态码进行了测试：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have a nested context for the network error. Note the use of `mockRejectedValue`
    instead of `mockResolvedValue`, which will throw an exception and cause the `catch`
    block to be executed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个嵌套的网络错误上下文。注意使用`mockRejectedValue`而不是`mockResolvedValue`，这将抛出异常并导致`catch`块执行：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And that’s it: we have a fully-tested service worker using a combination of
    Playwright and Vitest tests.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们使用Playwright和Vitest测试的组合，实现了一个完全经过测试的服务工作者。
- en: Summary
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've finished the book by looking at how even a complex browser feature, such
    as service workers, can be fully covered by tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过观察即使是像服务工作者这样的复杂浏览器功能也可以被测试覆盖完全，完成了这本书的编写。
- en: You’ve seen how Playwright tests should always test the benefit provided by
    the implementation – in this case, checking that the page is available offline
    – rather than testing an implementation detail, such as whether the service worker
    is is available or not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了Playwright测试应该如何始终测试实现带来的好处——在这个例子中，检查页面是否可以离线访问——而不是测试实现细节，比如服务工作者是否可用。
- en: You’ve also seen how the Vitest tests can avoid checking the awkward service
    worker interface by pushing the majority of the implementation into plain JavaScript
    functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了Vitest测试如何通过将大部分实现推入纯JavaScript函数来避免检查尴尬的服务工作者接口。
- en: And with that, our tour of test-driven Svelte comes to an end. It’s now over
    to you to put what you’ve learned into practice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们对测试驱动Svelte的探索告一段落。现在轮到你了，将你所学的应用到实践中。
- en: As this book has shown, there are many avenues that your testing practice can
    follow. I encourage you to experiment and find what works for you. Seek out the
    practices that make your life easier and allow you to build higher-quality software
    at a steady rate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这本书所展示的，你的测试实践有很多途径可以遵循。我鼓励你进行实验，找到适合你的方法。寻找那些使你的生活更轻松并允许你以稳定的速度构建更高品质软件的实践。
- en: Thank you for choosing to spend your time with this book. If you have any feedback,
    good or bad, I’d love to hear it. You can contact me via the book’s GitHub repository
    or via my website at [www.danielirvine.com](http://www.danielirvine.com).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你选择花时间阅读这本书。如果你有任何反馈，无论是好是坏，我都非常乐意听到。你可以通过书的GitHub仓库或通过我的网站[www.danielirvine.com](http://www.danielirvine.com)联系我。
