["```js\nclass StackCalculator {\n  constructor () {\n    this.stack = []\n  }\n  putValue (value) {\n    this.stack.push(value)\n  }\n  getValue () {\n    return this.stack.pop()\n  }\n  peekValue () {\n    return this.stack[this.stack.length - 1]\n  }\n  clear () {\n    this.stack = []\n  }\n  divide () {\n    const divisor = this.getValue()\n    const dividend = this.getValue()\n    const result = dividend / divisor\n    this.putValue(result)\n    return result\n  }\n  multiply () {\n    const multiplicand = this.getValue()\n    const multiplier = this.getValue()\n    const result = multiplier * multiplicand\n    this.putValue(result)\n    return result\n  }\n} \n```", "```js\nconst calculator = new StackCalculator()\ncalculator.putValue(3)\ncalculator.putValue(2)\nconsole.log(calculator.multiply()) // 3*2 = 6\ncalculator.putValue(2)\nconsole.log(calculator.multiply()) // 6*2 = 12 \n```", "```js\nclass SafeCalculator {\n  constructor (calculator) {\n    this.calculator = calculator\n  }\n  // proxied method\n  divide () {\n    // additional validation logic\n    const divisor = this.calculator.peekValue()\n    if (divisor === 0) {\n      throw Error('Division by 0')\n    }\n    // if valid delegates to the subject\n    return this.calculator.divide()\n  }\n  // delegated methods\n  putValue (value) {\n    return this.calculator.putValue(value)\n  }\n  getValue () {\n    return this.calculator.getValue()\n  }\n  peekValue () {\n    return this.calculator.peekValue()\n  }\n  clear () {\n    return this.calculator.clear()\n  }\n  multiply () {\n    return this.calculator.multiply()\n  }\n}\nconst calculator = new StackCalculator()\nconst safeCalculator = new SafeCalculator(calculator)\ncalculator.putValue(3)\ncalculator.putValue(2)\nconsole.log(calculator.multiply())     // 3*2 = 6\nsafeCalculator.putValue(2)\nconsole.log(safeCalculator.multiply()) // 6*2 = 12\ncalculator.putValue(0)\nconsole.log(calculator.divide())       // 12/0 = Infinity\nsafeCalculator.clear()\nsafeCalculator.putValue(4)\nsafeCalculator.putValue(0)\nconsole.log(safeCalculator.divide())   // 4/0 -> Error \n```", "```js\nfunction createSafeCalculator (calculator) {\n  return {\n    // proxied method\n    divide () {\n      // additional validation logic\n      const divisor = calculator.peekValue()\n      if (divisor === 0) {\n        throw Error('Division by 0')\n      }\n      // if valid delegates to the subject\n      return calculator.divide()\n    },\n    // delegated methods\n    putValue (value) {\n      return calculator.putValue(value)\n    },\n    getValue () {\n      return calculator.getValue()\n    },\n    peekValue () {\n      return calculator.peekValue()\n    },\n    clear () {\n      return calculator.clear()\n    },\n    multiply () {\n      return calculator.multiply()\n    }\n  }\n}\nconst calculator = new StackCalculator()\nconst safeCalculator = createSafeCalculator(calculator)\n   // ... \n```", "```js\nfunction patchToSafeCalculator (calculator) {\n  const divideOrig = calculator.divide\n  calculator.divide = () => {\n    // additional validation logic\n    const divisor = calculator.peekValue()\n    if (divisor === 0) {\n      throw Error('Division by 0')\n    }\n    // if valid delegates to the subject\n    return divideOrig.apply(calculator)\n  }\n  return calculator\n}\nconst calculator = new StackCalculator()\nconst safeCalculator = patchToSafeCalculator(calculator)\n// ... \n```", "```js\nconst proxy = new Proxy(target, handler) \n```", "```js\nconst safeCalculatorHandler = {\n  get: (target, property) => {\n    if (property === 'divide') {\n      // proxied method\n      return function () {\n        // additional validation logic\n        const divisor = target.peekValue()\n        if (divisor === 0) {\n          throw Error('Division by 0')\n        }\n        // if valid delegates to the subject\n        return target.divide()\n      }\n    }\n    // delegated methods and properties\n    return target[property]\n  }\n}\nconst calculator = new StackCalculator()\nconst safeCalculator = new Proxy(\n  calculator,\n  safeCalculatorHandler\n)\n// ... \n```", "```js\nconst evenNumbers = new Proxy([], {\n  get: (target, index) => index * 2,\n  has: (target, number) => number % 2 === 0\n})\nconsole.log(2 in evenNumbers) // true\nconsole.log(5 in evenNumbers) // false\nconsole.log(evenNumbers[7])   // 14 \n```", "```js\nProxy object, it is not implementing the Proxy pattern. This example allows us to see that, even though the Proxy object is commonly used to implement the Proxy pattern (hence the name), it can also be used to implement other patterns and use cases. As an example, we will see later in this chapter how to use the Proxy objectâ€”to implement the Decorator pattern.\n```", "```js\nexport function createLoggingWritable (writable) {\n  return new Proxy(writable, {                             // (1)\n    get (target, propKey, receiver) {                      // (2)\n      if (propKey === 'write') {                           // (3)\n        return function (...args) {                        // (4)\n          const [chunk] = args\n          console.log('Writing', chunk)\n          return writable.write(...args)\n        }\n      }\n      return target[propKey]                               // (5)\n    }\n  })\n} \n```", "```js\nimport { createWriteStream } from 'fs'\nimport { createLoggingWritable } from './logging-writable.js'\nconst writable = createWriteStream('test.txt')\nconst writableProxy = createLoggingWritable(writable)\nwritableProxy.write('First chunk')\nwritableProxy.write('Second chunk')\nwritable.write('This is not logged')\nwritableProxy.end() \n```", "```js\nexport function createObservable (target, observer) {\n  const observable = new Proxy(target, {\n    set (obj, prop, value) {\n      if (value !== obj[prop]) {\n        const prev = obj[prop]\n        obj[prop] = value\n        observer({ prop, prev, curr: value })\n      }\n      return true\n    }\n  })\n  return observable\n} \n```", "```js\nimport { createObservable } from './create-observable.js'\nfunction calculateTotal (invoice) {                          // (1)\n  return invoice.subtotal -\n    invoice.discount +\n    invoice.tax\n}\nconst invoice = {\n  subtotal: 100,\n  discount: 10,\n  tax: 20\n}\nlet total = calculateTotal(invoice)\nconsole.log(`Starting total: ${total}`)\nconst obsInvoice = createObservable(                         // (2)\n  invoice,\n  ({ prop, prev, curr }) => {\n    total = calculateTotal(invoice)\n    console.log(`TOTAL: ${total} (${prop} changed: ${prev} -> ${curr})`)\n  }\n)\n                                                             // (3)\nobsInvoice.subtotal = 200 // TOTAL: 210\nobsInvoice.discount = 20  // TOTAL: 200\nobsInvoice.discount = 20  // no change: doesn't notify\nobsInvoice.tax = 30       // TOTAL: 210\nconsole.log(`Final total: ${total}`) \n```", "```js\nStarting total: 110\nTOTAL: 210 (subtotal changed: 100 -> 200)\nTOTAL: 200 (discount changed: 10 -> 20)\nTOTAL: 210 (tax changed: 20 -> 30)\nFinal total: 210 \n```", "```js\nclass EnhancedCalculator {\n  constructor (calculator) {\n    this.calculator = calculator\n  }\n  // new method\n  add () {\n    const addend2 = this.getValue()\n    const addend1 = this.getValue()\n    const result = addend1 + addend2\n    this.putValue(result)\n    return result\n  }\n  // modified method\n  divide () {\n    // additional validation logic\n    const divisor = this.calculator.peekValue()\n    if (divisor === 0) {\n      throw Error('Division by 0')\n    }\n    // if valid delegates to the subject\n    return this.calculator.divide()\n  }\n  // delegated methods\n  putValue (value) {\n    return this.calculator.putValue(value)\n  }\n  getValue () {\n    return this.calculator.getValue()\n  }\n  peekValue () {\n    return this.calculator.peekValue()\n  }\n  clear () {\n    return this.calculator.clear()\n  }\n  multiply () {\n    return this.calculator.multiply()\n  }\n}\nconst calculator = new StackCalculator()\nconst enhancedCalculator = new EnhancedCalculator(calculator)\nenhancedCalculator.putValue(4)\nenhancedCalculator.putValue(3)\nconsole.log(enhancedCalculator.add())      // 4+3 = 7\nenhancedCalculator.putValue(2)\nconsole.log(enhancedCalculator.multiply()) // 7*2 = 14 \n```", "```js\nfunction patchCalculator (calculator) {\n  // new method\n  calculator.add = function () {\n    const addend2 = calculator.getValue()\n    const addend1 = calculator.getValue()\n    const result = addend1 + addend2\n    calculator.putValue(result)\n    return result\n  }\n  // modified method\n  const divideOrig = calculator.divide\n  calculator.divide = () => {\n    // additional validation logic\n    const divisor = calculator.peekValue()\n    if (divisor === 0) {\n      throw Error('Division by 0')\n    }\n    // if valid delegates to the subject\n    return divideOrig.apply(calculator)\n  }\n  return calculator\n}\nconst calculator = new StackCalculator()\nconst enhancedCalculator = patchCalculator(calculator)\n// ... \n```", "```js\nconst enhancedCalculatorHandler = {\n  get (target, property) {\n    if (property === 'add') {\n      // new method\n      return function add () {\n        const addend2 = target.getValue()\n        const addend1 = target.getValue()\n        const result = addend1 + addend2\n        target.putValue(result)\n        return result\n      }\n    } else if (property === 'divide') {\n      // modified method\n      return function () {\n        // additional validation logic\n        const divisor = target.peekValue()\n        if (divisor === 0) {\n          throw Error('Division by 0')\n        }\n        // if valid delegates to the subject\n        return target.divide()\n      }\n    }\n    // delegated methods and properties\n    return target[property]\n  }\n}\nconst calculator = new StackCalculator()\nconst enhancedCalculator = new Proxy(\n  calculator,\n  enhancedCalculatorHandler\n)\n// ... \n```", "```js\nexport function levelSubscribe (db) {\n  db.subscribe = (pattern, listener) => {                // (1)\n    db.on('put', (key, val) => {                         // (2)\n      const match = Object.keys(pattern).every(\n        k => (pattern[k] === val[k])                     // (3)\n      )\n      if (match) {\n        listener(key, val)                               // (4)\n      }\n    })\n  }\n  return db\n} \n```", "```js\nimport { dirname, join } from 'path'\nimport { fileURLToPath } from 'url'\nimport level from 'level'\nimport { levelSubscribe } from './level-subscribe.js'\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst dbPath = join(__dirname, 'db')\nconst db = level(dbPath, { valueEncoding: 'json' })      // (1)\nlevelSubscribe(db)                                       // (2)\ndb.subscribe(                                            // (3)\n  { doctype: 'tweet', language: 'en' },\n  (k, val) => console.log(val)\n)\ndb.put('1', {                                            // (4)\n  doctype: 'tweet',\n  text: 'Hi',\n  language: 'en'\n})\ndb.put('2', {\n  doctype: 'company',\n  name: 'ACME Co.'\n}) \n```", "```js\nimport { resolve } from 'path'\nexport function createFSAdapter (db) {\n  return ({\n    readFile (filename, options, callback) {\n      // ...\n    },\n    writeFile (filename, contents, options, callback) {\n      // ...\n    }\n  })\n} \n```", "```js\n readFile (filename, options, callback) {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      } else if (typeof options === 'string') {\n        options = { encoding: options }\n      }\n      db.get(resolve(filename), {                           // (1)\n        valueEncoding: options.encoding\n      },\n      (err, value) => {\n        if (err) {\n          if (err.type === 'NotFoundError') {               // (2)\n            err = new Error(`ENOENT, open \"${filename}\"`)\n            err.code = 'ENOENT'\n            err.errno = 34\n            err.path = filename\n          }\n          return callback && callback(err)\n        }\n        callback && callback(null, value)                   // (3)\n      })\n    } \n```", "```js\n writeFile (filename, contents, options, callback) {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      } else if (typeof options === 'string') {\n        options = { encoding: options }\n      }\n      db.put(resolve(filename), contents, {\n        valueEncoding: options.encoding\n      }, callback)\n    } \n```", "```js\nimport fs from 'fs'\nfs.writeFile('file.txt', 'Hello!', () => {\n  fs.readFile('file.txt', { encoding: 'utf8' }, (err, res) => {\n    if (err) {\n      return console.error(err)\n    }\n    console.log(res)\n  })\n})\n// try to read a missing file\nfs.readFile('missing.txt', { encoding: 'utf8' }, (err, res) => {\n  console.error(err)\n}) \n```", "```js\nError: ENOENT, open \"missing.txt\"\nHello! \n```", "```js\nimport { dirname, join } from 'path'\nimport { fileURLToPath } from 'url'\nimport level from 'level'\nimport { createFSAdapter } from './fs-adapter.js'\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst db = level(join(__dirname, 'db'), {\n  valueEncoding: 'binary'\n})\nconst fs = createFSAdapter(db)\n// ... \n```"]