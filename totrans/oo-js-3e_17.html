<html><head></head><body><div class="appendix" title="Appendix&#xA0;D.&#xA0;Regular Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="appD"/>Appendix D. Regular Expressions</h1></div></div></div><p>When you use regular expressions (discussed in <a class="link" href="ch04.html" title="Chapter 4. Objects">Chapter 4</a>, <span class="emphasis"><em>Objects</em></span>), you can match literal strings, for example:</p><pre class="programlisting">    &gt; "some text".match(/me/); &#13;
    ["me"] &#13;
</pre><p>However, the true power of regular expressions comes from matching patterns, not literal strings. The following table describes the different syntax you can use in your patterns, and provides some examples of their use:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
<p>
<span class="strong"><strong>Pattern</strong></span>
</p>
</th><th>
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</th></tr></thead><tbody><tr><td>
<p>
<code class="literal">[abc]</code>
</p>
</td><td>
<p>Matches a class of characters:
</p><pre class="programlisting">    &gt; "some text".match(/[otx]/g);   &#13;
    ["o", "t", "x",   "t"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">[a-z]</code>
</p>
</td><td>
<p>A class of characters defined as a range. For example, [a-d] is the same as [abcd], [a-z] matches all lowercase characters, [a-zA-Z0-9_] matches all characters, numbers, and the underscore character:
</p><pre class="programlisting">    &gt; "Some Text".match(/[a-z]/g);   &#13;
    ["o", "m", "e",   "e", "x", "t"]   &#13;
    &gt; "Some Text".match(/[a-zA-Z]/g);   &#13;
    ["S", "o", "m",   "e", "T", "e", "x", "t"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">[^abc]</code>
</p>
</td><td>
<p>Matches everything that is not matched by the class of characters:
</p><pre class="programlisting">    &gt; "Some Text".match(/[^a-z]/g);   &#13;
    ["S", " ", "T"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">a|b</code>
</p>
</td><td>
<p>Matches a or b. The pipe character means OR, and it can be used more than once:
</p><pre class="programlisting">    &gt; "Some Text".match(/t|T/g);&#13;
    ["T", "t"]&#13;
    &gt; "Some Text".match(/t|T|Some/g);&#13;
    ["Some", "T",   "t"]&#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">a(?=b)</code>
</p>
</td><td>
<p>Matches a only if followed by b:
</p><pre class="programlisting">    &gt; "Some Text".match(/Some(?=Tex)/g);   &#13;
    null   &#13;
    &gt; "Some Text".match(/Some(?=Tex)/g);   &#13;
    ["Some"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">a(?!b)</code>
</p>
</td><td>
<p>Matches a only when not followed by b:
</p><pre class="programlisting">    &gt; "Some Text".match(/Some(?!Tex)/g);   &#13;
    null   &#13;
    &gt; "Some Text".match(/Some(?!Tex)/g);   &#13;
    ["Some"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\</code>
</p>
</td><td>
<p>Escape character used to help you match the special characters used in patterns as literals:
</p><pre class="programlisting">    &gt; "R2-D2".match(/[2-3]/g);   &#13;
    ["2", "2"]   &#13;
    &gt; "R2-D2".match(/[2\-3]/g);   &#13;
    ["2", "-", "2"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
</p><p>
<code class="literal">\n</code>
</p><p>
</p><p>
<code class="literal">\r</code>
</p><p>
</p><p>
<code class="literal">\f</code>
</p><p>
</p><p>
<code class="literal">\t</code>
</p><p>
</p><p>
<code class="literal">\v</code>
</p><p>
</p>
</td><td>
<p>
</p><p>New line</p><p>
</p><p>Carriage return</p><p>
</p><p>Form feed</p><p>
</p><p>Tab</p><p>
</p><p>Vertical tab</p><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\s</code>
</p>
</td><td>
<p>White space, or any of the previous five escape sequences:
</p><pre class="programlisting">    &gt; "R2\n D2".match(/\s/g);   &#13;
    ["\n", " "]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\S</code>
</p>
</td><td>
<p>Opposite of the above; matches everything but white space. Same as [^\s]:
</p><pre class="programlisting">    &gt; "R2\n D2".match(/\S/g);   &#13;
    ["R", "2", "D",   "2"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\w</code>
</p>
</td><td>
<p>Any letter, number, or underscore. Same as [A-Za-z0-9_]:
</p><pre class="programlisting">    &gt; "S0m3 text!".match(/\w/g);   &#13;
    ["S", "0", "m",   "3", "t", "e", "x", "t"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\W</code>
</p>
</td><td>
<p>Opposite of <code class="literal">\w</code>:
</p><pre class="programlisting">    &gt; "S0m3 text!".match(/\W/g);   &#13;
    [" ", "!"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\d</code>
</p>
</td><td>
<p>Matches a number, same as [0-9]:
</p><pre class="programlisting">    &gt; "R2-D2 and C-3PO".match(/\d/g);   &#13;
    ["2", "2", "3"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\D</code>
</p>
</td><td>
<p>Opposite of <code class="literal">\d</code>; matches non-numbers, same as [^0-9] or [^\d]:
</p><pre class="programlisting">    &gt; "R2-D2 and C-3PO".match(/\D/g);   &#13;
    ["R", "-", "D",   " ", "a", "n", "d",&#13;
      " ", "C",   "-", "P", "O"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\b</code>
</p>
</td><td>
<p>
</p><p>Matches a word boundary such as space or punctuation.</p><p>
</p><p>Matching R or D followed by 2:</p><p>
</p><pre class="programlisting">    &gt; "R2D2 and C-3PO".match(/[RD]2/g);   &#13;
    ["R2", "D2"]   &#13;
</pre><p>
</p><p>Same as above but only at the end of a word:</p><p>
</p><pre class="programlisting">    &gt; "R2D2 and C-3PO".match(/[RD]2\b/g);   &#13;
    ["D2"]   &#13;
</pre><p>
</p><p>Same pattern but the input has a dash, which is also an end of a word:</p><p>
</p><pre class="programlisting">    &gt; "R2-D2 and C-3PO".match(/[RD]2\b/g);   &#13;
    ["R2", "D2"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\B</code>
</p>
</td><td>
<p>The opposite of <code class="literal">\b</code>:
</p><pre class="programlisting">    &gt; "R2-D2 and C-3PO".match(/[RD]2\B/g);   &#13;
    null   &#13;
    &gt; "R2D2 and C-3PO".match(/[RD]2\B/g);   &#13;
    ["R2"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">[\b]</code>
</p>
</td><td>
<p>Matches the backspace character.</p>
</td></tr><tr><td>
<p>
<code class="literal">\0</code>
</p>
</td><td>
<p>The null character.</p>
</td></tr><tr><td>
<p>
<code class="literal">\u0000</code>
</p>
</td><td>
<p>Matches a Unicode character, represented by a four-digit hexadecimal number:
</p><pre class="programlisting">    &gt; "стоян".match(/\u0441\u0442\u043E/);   &#13;
    ["сто"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">\x00</code>
</p>
</td><td>
<p>Matches a character code represented by a two-digit hexadecimal number:
</p><pre class="programlisting">    &gt; "\x64";   &#13;
     "d"   &#13;
    &gt; "dude".match(/\x64/g);   &#13;
    ["d", "d"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">^</code>
</p>
</td><td>
<p>The beginning of the string to be matched. If you set the <code class="literal">m</code> modifier (multi-line), it matches the beginning of each line:
</p><pre class="programlisting">   &gt; "regular\nregular\nexpression".match(/r/g);   &#13;
    ["r", "r", "r",   "r", "r"]   &#13;
    &gt; "regular\nregular\nexpression".match(/^r/g);   &#13;
    ["r"]   &#13;
   &gt; "regular\nregular\nexpression".match(/^r/mg);   &#13;
    ["r", "r"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">$</code>
</p>
</td><td>
<p>Matches the end of the input or, when using the multiline modifier, the end of each line:
</p><pre class="programlisting">    &gt; "regular\nregular\nexpression".match(/r$/g);   &#13;
    null   &#13;
    &gt; "regular\nregular\nexpression".match(/r$/mg);   &#13;
    ["r", "r"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">.</code>
</p>
</td><td>
<p>Matches any single character except for the new line and the line feed:
</p><pre class="programlisting">    &gt; "regular".match(/r./g);   &#13;
    ["re"]   &#13;
    &gt; "regular".match(/r.../g);   &#13;
    ["regu"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">*</code>
</p>
</td><td>
<p>Matches the preceding pattern if it occurs zero or more times. For example, <code class="literal">/.*/</code> will match anything including nothing (an empty input):
</p><pre class="programlisting">    &gt; "".match(/.*/);   &#13;
    [""]   &#13;
    &gt; "anything".match(/.*/);   &#13;
    ["anything"]   &#13;
    &gt; "anything".match(/n.*h/);   &#13;
    ["nyth"]   &#13;
</pre><p>
</p><p>Keep in mind that the pattern is "greedy", meaning it will match as much as possible:</p><p>
</p><pre class="programlisting">    &gt; "anything within".match(/n.*h/g);   &#13;
    ["nything with"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">?</code>
</p>
</td><td>
<p>Matches the preceding pattern if it occurs zero or one times:
</p><pre class="programlisting">    &gt; "anything".match(/ny?/g);   &#13;
    ["ny", "n"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">+</code>
</p>
</td><td>
<p>Matches the preceding pattern if it occurs at least once (or more times):
</p><pre class="programlisting">    &gt; "anything".match(/ny+/g);   &#13;
    ["ny"]   &#13;
    &gt; "R2-D2 and C-3PO".match(/[a-z]/gi);   &#13;
    ["R", "D", "a",   "n", "d", "C", "P", "O"]   &#13;
    &gt; "R2-D2 and C-3PO".match(/[a-z]+/gi);   &#13;
    ["R", "D", "and",   "C", "PO"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">{n}</code>
</p>
</td><td>
<p>Matches the preceding pattern if it occurs exactly n times:
</p><pre class="programlisting">    &gt; "regular expression".match(/s/g);   &#13;
    ["s", "s"]   &#13;
    &gt; "regular expression".match(/s{2}/g);   &#13;
    ["ss"]   &#13;
    &gt; "regular expression".match(/\b\w{3}/g);   &#13;
    ["reg", "exp"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">{min,max}</code>
</p>
</td><td>
<p>
</p><p>Matches the preceding pattern if it occurs between min and max number of times. You can omit max, which will mean no maximum, but only a minimum. You cannot omit min.</p><p>
</p><p>An example where the input is "doodle" with the "o" repeated 10 times:</p><p>
</p><pre class="programlisting">    &gt; "doooooooooodle".match(/o/g);   &#13;
    ["o", "o", "o",   "o", "o", &#13;
    "o", "o", "o", "o",   "o"]   &#13;
    &gt; "doooooooooodle".match(/o/g).length;   &#13;
    10   &#13;
    &gt; "doooooooooodle".match(/o{2}/g);   &#13;
    ["oo", "oo", "oo",   "oo", "oo"]   &#13;
    &gt; "doooooooooodle".match(/o{2,}/g);   &#13;
    ["oooooooooo"]   &#13;
    &gt; "doooooooooodle".match(/o{2,6}/g);   &#13;
    ["oooooo", "oooo"]   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">(pattern)</code>
</p>
</td><td>
<p>
</p><p>When the pattern is in parentheses, it is remembered so that it can be used for replacements. These are also known as capturing patterns.</p><p>
</p><p>The captured matches are available as $1, $2,... $9</p><p>
</p><p>Matching all "r" occurrences and repeating them:</p><p>
</p><pre class="programlisting">    &gt; "regular expression".replace(/(r)/g, '$1$1');   &#13;
    "rregularr exprression"   &#13;
</pre><p>
</p><p>Matching "re" and turning it to "er":</p><p>
</p><pre class="programlisting">    &gt; "regular expression".replace(/(r)(e)/g, '$2$1');   &#13;
    "ergular experssion"   &#13;
</pre><p>
</p>
</td></tr><tr><td>
<p>
<code class="literal">(?:pattern)</code>
</p>
</td><td>
<p>
</p><p>Non-capturing pattern, not remembered and not available in $1, $2...</p><p>
</p><p>Here's an example of how "re" is matched, but the "r" is not remembered and the second pattern becomes $1:</p><p>
</p><pre class="programlisting">   &gt; "regular expression".replace(/(?:r)(e)/g, '$1$1');   &#13;
   "eegular expeession"   &#13;
</pre><p>
</p>
</td></tr></tbody></table></div><p>Make sure you pay attention when a special character can have two meanings, as is the case with <code class="literal">^</code>, <code class="literal">?</code>, and <code class="literal">\b</code>.</p></div></body></html>