- en: '*Chapter 8*: Environments emulation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I had the good luck of using the internet before it became popular. I was a
    teenager when *Windows 95 Plus* was launched to the market. Most people might
    remember *Windows 95 Plus* because it came with some cool themes and even the
    *Space Cadet Pinball* game. But this version of Windows brought a new software
    application whose name is still around these days, with haters and lovers. *Windows
    95 Plus* came with *Internet Explorer 1.0 (IE 1.0)*.
  prefs: []
  type: TYPE_NORMAL
- en: My first internet connection was a free phone number that a local newspaper
    shared with its readers. I was able to convince my dad to get me a modem. The
    speed was 36.6 kbps. Today my speed test goes to 150 Mbps download and 30 Mbps
    upload, over 4,000 times faster than the speed I got as a teen.
  prefs: []
  type: TYPE_NORMAL
- en: I don't remember very well the specs of my computer. But I do remember using
    a 15'' 800x600 monitor, and then upgrading to a 17'' 1,024x768\. LED? No way!
    What's that? There were some bulky, eye-burning CRT monitors.
  prefs: []
  type: TYPE_NORMAL
- en: SEO? Google? Nobody knew those words back then. I remember that my favorite
    search engine was *AltaVista*.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I telling you all this? Because back then, the internet experience was
    consistent. It was slow, very slow, ugly, very ugly, and limited, very limited.
    But it was the same for everybody. If you were a developer back then, you knew
    that you had to develop a website for IE 1.0 to be displayed on an 800x600 screen
    and that your page would take over a minute to download. But you wouldn't have
    thought about all that. You would be happy creating your page with *Microsoft
    FrontPage*, pushing that to some server, and letting the world know about your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: But now things are different. The ecosystem is more diverse than ever, and we
    need to be prepared to test all the different scenarios that we could come across.
    At the end of the day, it is our job to honor all our customers and try to understand
    their environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the browser's market share
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating network conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other emulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to get into your users' shoes and
    emulate how they experience your sites.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter8` directory. Remember to run `npm install` on that directory,
    and then go to the `Chapter8/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the browser's market share
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into all the emulation features Puppeteer provides, I would like
    to discuss how the browser's market share looks these days. I believe that will
    give you a clear picture of the importance of testing and emulating different
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The browser's popularity over the years
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have lived through lots of changes over the past 25 years. Browsers have
    been dramatically adopted and discarded. Let''s take a look at this table made
    by Nick Routley in his post *Internet Browser Market Share (1996â€“2019)* ([https://www.visualcapitalist.com/internet-browser-market-share/](https://www.visualcapitalist.com/internet-browser-market-share/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_8.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although I used *Netscape Navigator*, I wasn't there at its peak back in 1995\.
    But I remember the days when the only browser that mattered was *Internet Explorer*.
  prefs: []
  type: TYPE_NORMAL
- en: The community was living through browser fatigue back in 2008, when *Google
    Chrome* was launched, causing a massive number of users to move to *Google Chrome*
    and *Firefox*, which had a peak in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t play the video on Nick''s post, don''t miss that. I took a screenshot
    from the moment that the video gets to 2013 Q1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Market share in 2013'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Market share in 2013
  prefs: []
  type: TYPE_NORMAL
- en: That was a challenging year for developers. You had four different browser engines
    behaving differently, processing CSS styles differently, having different JavaScript
    features. It was a mess. But I think that was a healthy web, with no clear market
    owner.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers' popularity in 2020
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to *StatCounter* ([https://gs.statcounter.com/](https://gs.statcounter.com/)),
    the picture is very different these days:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browser market share in December 2020 according to StatCounter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Browser market share in December 2020 according to StatCounter
  prefs: []
  type: TYPE_NORMAL
- en: Many people call *Google Chrome* the **new** Internet Explorer. The Chrome predominance
    gets even more important when you consider that *Edge* and *Opera* use the Chromium
    engine. When a browser gets to these levels of market share, it is good for developers,
    but it's not good for the web.
  prefs: []
  type: TYPE_NORMAL
- en: What if we take a look at operative systems?
  prefs: []
  type: TYPE_NORMAL
- en: Operative Systems market share
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operative systems play an essential part in how browsers work. They are responsible
    for providing the fonts and interacting with the hardware, among other things.
    Most browsers are cross-platform, but although they try to give the same experience
    across operative systems, they don''t always work in the same way. That''s why
    it''s so important to know how the operative system market share looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operative system market share in December 2020 according to StatCounter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.03_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Operative system market share in December 2020 according to StatCounter
  prefs: []
  type: TYPE_NORMAL
- en: I honestly found this surprising. Almost 55% of internet consumption is on mobile,
    and over 39% is on Android. These values should make us re-think how we develop
    and test our sites.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we can take a look at is screen resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Screen resolution distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Screen resolution is another important piece when we try to understand the
    whole web ecosystem. In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*, we talked about how developers can change a page
    layout based on the screen resolution. Let''s see how the screen resolution is
    distributed according to **StatCounter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen resolution market share in December 2020 according to StatCounter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Screen resolution market share in December 2020 according to StatCounter
  prefs: []
  type: TYPE_NORMAL
- en: The distribution of screen resolutions is crazy. There is not only a wide variety
    of resolutions, but we also have "**Other**" with 41%. We are far from that 800x600
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: The message I want to leave you with is that the internet ecosystem is more
    diverse than ever. The world where everything was just IE, 800x600, over a dial-up
    connection is long gone. Although there is one predominant browser, we have many
    possible scenarios, mobile devices, and screen resolutions, and we haven't talked
    about network speeds. We have Wi-Fi, 4G, 3G, or GPRS.
  prefs: []
  type: TYPE_NORMAL
- en: We sometimes make the error of thinking that all users have a crazy-fast internet
    and 27'' 4K displays, and we are unable to understand why they feel frustrated
    with our site.
  prefs: []
  type: TYPE_NORMAL
- en: Do you know your users? Do you know whether they use your site on the street
    on their phones? Do you want your site to be used worldwide? Do you know that
    there are countries where they write right to left or where they don't have 4G
    coverage?
  prefs: []
  type: TYPE_NORMAL
- en: It's time to get into mobile users' shoes. Let's see how we can emulate mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating mobile devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first type of emulation I want to cover is mobile emulation. In this section,
    we will cover the three elements that Puppeteer can emulate: The viewport, the
    touchscreen, and the user agent. We have to keep in mind that it is a browser
    trying to **emulate** a mobile device. Puppeteer and Chromium won''t be able to
    emulate any hardware limitations or any other specific features that certain mobile
    phones offer. There is no real device behind the curtains; it''s just a browser
    trying to show you how a website would look on that device''s screen.'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, **55% of the internet traffic comes from mobile devices**.
    Most of the diversity we saw in the previous section is in the mobile world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the browser distribution in the mobile world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browser market share in mobile devices according to StatCounter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Browser market share in mobile devices according to StatCounter
  prefs: []
  type: TYPE_NORMAL
- en: The mobile market is mostly divided between *Chrome* and *Safari*. One thing
    you should know is that in *iOS*, the only available browser engine is *WebKit*/*Safari*.
    You have browsers such as *Chrome*, *Edge*, or *Firefox* available in *iOS*, but
    they cannot ship their own browser engine. They have to use *WebKit*. The only
    thing they can provide are features over that engine. The main feature you will
    see in those browsers is the synchronization between the desktop and the mobile
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at screen resolutions on mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.06_B16113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen resolutions on mobile devices according to StatCounter
  prefs: []
  type: TYPE_NORMAL
- en: You need 10 screen resolutions to reach 50% of the market share, compared with
    only three resolutions on desktop, 1,920x1,080, 1,366x768, and 1,536x864\. The
    screen resolutions in the mobile world are highly diverse. Another thing that
    should call your attention in that chart is the resolutions that are pretty low.
    Who buys a phone with a 360x640 resolution? No one. We will find out in the next
    section who those 360x480 users really are.
  prefs: []
  type: TYPE_NORMAL
- en: So, it's time to talk about the elements that Puppeteer considers to emulate
    a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: The Viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've talked a lot about the viewport in this book. It's time to give a clear
    definition of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to explain the viewport by explaining what it''s not. The viewport is
    not the screen resolution. It''s not the size of the browser''s window. And lastly,
    it''s not the size of the page. The viewport is the rectangular portion of the
    screen the browser uses to render a page. From the user''s point of view, the
    viewport is the part of the page you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The viewport'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.07_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The viewport
  prefs: []
  type: TYPE_NORMAL
- en: I love the preceding visualization, not because I made it, but because it clearly
    shows the difference between the viewport and the screen size. The page can be
    huge. It can be way longer than what you can see. Even more, if you are a social
    media user, you would also know that pages can have an "infinite" height because
    sites such as *Facebook* and *Twitter* load new content when you are close to
    reaching the end of the page. Although it's not as common, a page could also be
    wider than the viewport. There was a wave of horizontal-scrolling pages when *Windows
    8* was launched. The Microsoft *Azure* portal still shows its content using a
    horizontal layout.
  prefs: []
  type: TYPE_NORMAL
- en: The second element to take into consideration when you try to emulate a device
    screen is the pixel ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel ratio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if I told you that the Samsung Galaxy S20, with a screen resolution of
    1,440x3,200, has a viewport of 360x800?
  prefs: []
  type: TYPE_NORMAL
- en: 'No, that''s not a typo, nor an error. That''s the browser''s viewport on that
    beautiful mobile phone. How''s that possible? Let''s see how a web page would
    be displayed on a Samsung S20 without a pixel ratio set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Galaxy S20 without a pixel ratio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.08_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Galaxy S20 without a pixel ratio
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine if the browser honored the real resolution of the screen. That would
    be impossible to read, so you need to scale the resolution. You need to tell the
    browser to use a ratio to zoom the page and make it more usable. In the case of
    the Samsung Galaxy S20, the pixel ratio is 4, taking the viewport to 360x800,
    which is simple math (1,440/4) x (3,200/4). If we navigate the page using a pixel
    ratio of 4, we will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Galaxy S20 with the right pixel ratio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.09_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Galaxy S20 with the right pixel ratio
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an S20 with a huge resolution, but pages are rendered in a way that
    we can read them.
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering how I've been emulating different devices, it's tool time!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the developer tools (I hope that by now I don''t have to tell you
    how to do that), you will find that there is a button called **Toggle device emulation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Toggle device emulation option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Toggle device emulation option
  prefs: []
  type: TYPE_NORMAL
- en: If you click on that button, you will activate the device emulation mode. From
    there, you will be able to pick any device to emulate, or create new ones. You
    will also be able to change the zoom. Notice that this zoom won't affect the viewport;
    it's just to zoom the emulator. Finally, you will have the option to emulate different
    network speeds. We will talk about that in the *Emulating network conditions*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The next element that Puppeteer takes into consideration is the touchscreen.
  prefs: []
  type: TYPE_NORMAL
- en: The touchscreen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the device has a touchscreen, the browser will give developers an extra
    set of tools, **touch events** ([https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents](https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents)).
    Single taps will be processed as click events. But the browser offers the chance
    of processing multi-touch interactions. Let''s see how Chromium shows the touchscreen
    emulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Touch emulation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Touch emulation
  prefs: []
  type: TYPE_NORMAL
- en: If you use the device emulation, you will see that Chromium will emulate taps
    with a black circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes us to the last thing that Puppeteer uses to emulate devices: the
    user agent.'
  prefs: []
  type: TYPE_NORMAL
- en: The user agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user agent is one of those terrible decisions made on the web that are hard
    to eradicate. The user agent is a string (text) sent to the server on every request
    that identifies the browser/application, the operative system, the vendor, and
    its version.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to MDN ([https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent)),
    the format should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open DevTools in Chrome and type `navigator.userAgent`, you will get
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only clear thing here is that I'm on a Mac, using an Intel processor, and
    the operating system version is `11_0_1`. It's also true that I'm on `Chrome/87.0.4280.88`.
    The rest are patches after patches, so the user doesn't get a "Your browser is
    not compatible" message. So, if the server checks for Mozilla, the user agent
    will match, but it's not Mozilla. Could you tell me what *KHTML, like Gecko* is?
    As you can see, the user agent system is broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many developers would use the user agent to determine which device is on the
    other side. Let''s take, for instance, the user agent on an iPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If a developer wants to check whether the user is on an iPad, they can check
    whether the user agent contains the word **iPad**. But what if they want to check
    whether the user is using Safari? If they look for the word **Safari**, it will
    work on iPad, but, if you look at Chrome's user agent, it also has the word Safari,
    so we would think that Chromium is Safari. User agents are a mess.
  prefs: []
  type: TYPE_NORMAL
- en: If Puppeteer wants to emulate devices correctly, it needs to change the User-Agent
    in two places. First, it needs to change the User-Agent request header ([https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent))
    sent to the server. And second, as developers can also access the User-Agent from
    their JavaScript code using the `navigator.userAgent` property, the browser needs
    to change the value of that property as well. With these changes, both the server
    and the client will get a User-Agent that a real device would send.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to see how we apply all this in our Puppeteer code.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating mobile devices with Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You toggle the emulation mode by calling `page.emulate(options)`. I honestly
    think that the name `options` is wrong there. Compared with the other options
    we have seen in this book, this `options` argument is mandatory. The object will
    contain all the required data Puppeteer needs to emulate a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`viewport` is the first property, and it includes the definition of the viewport
    and a little bit more:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) `width`, representing the viewport width.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) `height`, representing the viewport height.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) `deviceScaleFactor`, which is the pixel ratio we talked about before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) `isMobile` is a Boolean property that will make the browser consider the
    meta viewport tag. You can read more about this on the MDN site ([https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag](https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e) `hasTouch` is a Boolean that will enable touch support.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f) `isLandscape` is a Boolean that will emulate a device in landscape mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `userAgent` property will allow us to change the user agent on the request
    header and JavaScript, as we saw in the previous section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have some good news and some bad news for you. Good news first. The `puppeteer`
    class has a property called `devices`. It''s a dictionary containing over 70 devices.
    We could do something like this in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the good news. The bad news is that you have to go to the source code
    for you to know the available list of devices: [https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors](https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors).
    That''s not ideal. The other option would be grabbing any Puppeteer code you have
    and printing the keys of the `devices` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you do that, you will get all the devices included in Puppeteer. The other
    bad news is that the list of devices is not as up to date as you might expect.
    But I think it makes sense. First, because we get new devices every month, and
    keeping that list updated would be a tough job. And second, the website you want
    to automate shouldn't need to be tested on every single device. I think you should
    be able to have good test coverage using the provided devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you do need to test a specific device, you could browse the spec on the web
    and manually pass a device setting. *yesviz.com* (https://yesviz.com/devices.php)
    has a nice list of devices' viewports. You can find a list of user agents at *DeviceAtlas*
    (https://deviceatlas.com/blog/list-of-user-agent-strings).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to emulate an iPhone 12 device, which is not on the devices list,
    we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book, I wasn't able to find the user agent sent
    by an iPhone 12, so I'm using the one from the iPhone XR. But if you are using
    this as a test tool, it would be a matter of asking your development team which
    values they are checking so you can then test the different user agents used by
    the team.
  prefs: []
  type: TYPE_NORMAL
- en: That takes us on to the next questions. How do we apply all these new concepts?
    How should we test mobile emulation?
  prefs: []
  type: TYPE_NORMAL
- en: Testing mobile UX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you need to check for **behavior changes**. Good developers make a great
    effort to give the best experience based on the device they infer you are using.
    Let''s see how the [www.packtpub.com](http://www.packtpub.com) website looks on
    mobile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The packtpub site on an iPhone X'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The packtpub site on an iPhone X
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the experience changes completely. The top menu is changed to
    a hamburger menu, and now you need to click on the magnifying glass to search
    for a book.
  prefs: []
  type: TYPE_NORMAL
- en: If you care about UI regressions, you will need to identify the different **layout
    changes**. Grids could become lists, and sections might be removed entirely to
    simplify the UI, fit the content on the screen, and make the user experience much
    nicer.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, "OK, but how do I test all that? Which devices should
    I test, all of them?". In order to know which devices to test, we need to know
    a little bit about **breakpoints**. No, not debugging breakings, **media query
    breakpoints**. Media query breakpoints are points that a developer can use to
    apply a different set of CSS styles based on the viewport width or height.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember how when we talked about generating PDF files, we mentioned
    that developers could use `@media print` to determine the style used to print
    a page? Well, `@media print` is not the only option we have there. We can also
    do stuff such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is taken from the *w3schools* site ([https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints](https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints)).
    We can see that developers can set specific styles depending on the width of the
    viewport. Functionally speaking, these days, we talk about five types of device
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile phones in portrait (up to 600 px)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablets in portrait (up to 900 px)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tablets in landscape (up to 1,200 px)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktops (up to 1,800 px)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big desktops (bigger than 1,800 px)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These numbers are relative, and you should team up with the development team
    and see which breakpoints they are using, and you should try to test edge scenarios
    using those breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'So maybe once you have met with the development team, you find that, based
    on the breakpoints they use, you should test the following devices:'
  prefs: []
  type: TYPE_NORMAL
- en: iPhone 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad Landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A desktop with a viewport of 1,280x1,080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could improve our UI regression tests and test those devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, I grabbed the same code from the previous chapter, but I wrapped it in
    a `for` loop that will iterate through the four devices we picked. We will assume
    that an empty string will be the default. If we get a device in the loop, we call
    the `emulate` function. If not, we set the **viewport** we had before.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if you want to emulate user taps, you can replace calls to the `click`
    function with a call to the `tap` function. The `tap` function works just like
    the `click` function, but instead of using mouse emulation, it will use touchscreen
    emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have UI regression tests for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Device emulation is not only for UI testing. Web developers can benefit from
    this feature to check how a page looks on different devices. In the same way that
    we coded this test, you can create a small script that can loop through many devices,
    navigate a page, and take screenshots. Then you can check whether something is
    broken or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test a page''s behavior on mobile devices, it won''t be much
    different from the different Puppeteer tests we''ve been writing. You could create
    a new test file for mobile and add your tests there. You could create a `homepage.iPhone.tests.js`,
    and do something like this in the `beforeEach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only thing new there is the call to the `emulate` function. From there,
    it is up to you to evaluate which tests you want to write for iPhone and which
    tests you don't. For instance, you might want to test layout changes, but tests
    such as prices or stock checks should be the same no matter the device.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to emulate different viewports, user agents,
    and touch devices. But there is more. Let's move on to bandwidth emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating network conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Networking is a challenging topic in computer science. If you tell a network
    engineer that Chromium emulates a 4G network, they will ask you to show them how
    it can emulate radio tower and weather conditions. Chromium does not pretend to
    emulate a network but a network condition. Chromium limits the scope to three
    variables that affect web development: Download speed, Upload speed, and Latency.
    That''s it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Emulating network conditions is something that you can now do on Chromium.
    You can open the developer tools and go to the **Network** tab, and you will find
    a drop-down list called throttling with the **Online** option selected by default,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Emulating network conditions on Chromium'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Emulating network conditions on Chromium
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on that drop-down list, you will find three other options: **Fast
    3G**, **Slow 3G**, and **Offline**. Another cool feature is that you will be able
    to add custom profiles. There you will be asked about three variables we mentioned
    before, download, upload, and latency, and additionally, to provide a name so
    you can identify your new profile.'
  prefs: []
  type: TYPE_NORMAL
- en: Emulating different network conditions is not something you want to add to every
    UI test. We want our tests to be as fast as possible. But it's a great tool to
    perform tests on demand. For instance, say one user of your e-commerce site reports
    that they're unable to finish the checkout process when they're using 4G. The
    company doesn't want to leave mobile users out, so they improve the site to work
    better on 4G. Now we have to write a test to ensure that the page will work on
    4G.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can emulate different network conditions by calling `page.networkConditions(networkConditions)`,
    where `networkConditions` is an object with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`download`: Download speed (bytes/sec). -1 disables download throttling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upload`: Upload speed (bytes/sec). -1 disables upload throttling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latency`: Minimum latency from the request sent to response headers received
    (ms).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `puppeteer` object has a property called `networkConditions` that provides
    two network settings: `''Slow 3G''` and `''Fast 3G''`. This is how you can use
    them according to the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But we are not limited to the two options Puppeteer provides. We can create
    our own settings, or find examples on GitHub. For instance, The *porchmark* project
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark))
    has a great list. The project is under the MIT license so we can use it freely.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some values we can get from that project, and then use them in our
    own code to emulate different network conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more in that repository. You can see the full list here: [https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets).
    If you want to incorporate that file, you will need to rename the `downloadThroughput`
    property to `download` and `uploadThroughput` to `upload`, and remove the `offline`
    property. You will also find the `networkPresets.js` file in the project of this
    chapter with all the replacements already made.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could test our login on a "Good 3G" network with all this information. We
    can go to our `login.tests.js` file and add this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same test as `emulateNetworkConditions` function. If we don''t
    want to use a `NetworkPresets` file, we could hardcode our network condition.
    Let''s see how we can call `page.emulateNetworkConditions` using our own settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The end result will be the same. You can also have a fixed preset and add it
    to our existing `config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We already covered a lot of ground in this chapter. In this section, we learned
    how to emulate different network conditions. We also learned how to execute methods
    from the DevTools protocol that are not exposed in the Puppeteer API. Now it's
    time to learn about localization.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I love this topic. Maybe because English is not my mother tongue, so I have
    seen and felt the pain when a site fails to honor other cultures.
  prefs: []
  type: TYPE_NORMAL
- en: There are many debates about what localization is, what internationalization
    is, and the difference between them. While I bet there will be debate over whether
    I should treat both as a whole or not, we will treat both as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about localization, we''re saying that a website should honor
    its audience:'
  prefs: []
  type: TYPE_NORMAL
- en: It should honor their language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should honor their culture, such as how they read numbers, sort information,
    and read the content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should honor their beliefs. For example, Green/Good Red/Bad might not apply
    in every culture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization is a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, every site on the web should consider localization. But localization
    can be quite a costly feature to implement. There is a high chance that your company
    is not Google or Amazon and you cannot afford to localize your site for every
    culture, so you need to know your audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking: "I''m just a QA analyst. Should I care about that?".
    Let me tell you this: You should be the number-one person in the company defending
    and honoring your customers'' culture.'
  prefs: []
  type: TYPE_NORMAL
- en: Let me share a few real-life examples of having a clear scope of your audience.
  prefs: []
  type: TYPE_NORMAL
- en: I have found many times that buying local train tickets in Europe can be hard.
    They are only in the local language, or the English version of the site is extremely
    poor. The scope is evident. This site is for local people. If you are a tourist,
    go to *Rail Europe*.
  prefs: []
  type: TYPE_NORMAL
- en: One colleague from the United States wanted to buy a flight ticket on a Chilean
    website. He went to that site and found a flight at $186.992\. He thought the
    flight price was 186 dollars and 992 cents. In fact, it was one hundred and eighty-six
    thousand, nine hundred and ninety-two Chilean pesos. The site didn't consider
    the way that my friend reads numbers. He wasn't part of the site's audience.
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, if you go to [www.google.com](http://www.google.com), you
    will always get the site in your preferred language. The world is their audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I go to [www.kayak.com](http://www.kayak.com), I will get prices in my local
    currency, because I''m part of their audience. This is the full list of countries
    you will find on Kayak''s website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kayak''s audience'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Kayak's audience
  prefs: []
  type: TYPE_NORMAL
- en: This might look like just a list of countries in Kayak. But that's, in fact,
    the definition of their audience.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know your site's audience, ask for it, and defend it in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into the code, there is one more thing you need to know regarding
    localization. There is no one way to implement it, and Puppeteer won't cover every
    scenario. But, let's take a look at the things we will be able to do with Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating geolocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Puppeteer, we will be able to change the geolocation used by pages using
    the Geolocation API ([https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization](https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization)).
    I chose those words carefully. You won't be able to emulate geolocation completely.
    Most sites use IP-based geolocation. That means that when a site gets a request
    from your device, it will grab the IP, and it will infer your country based on
    an IP-to-country table they have on their server. In other words, you won't be
    able to change the country on *Netflix.com*.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we emulate? You will be able to emulate client-side geolocation,
    such as [maps.google.com](http://maps.google.com) or even the [google.com](http://google.com)
    search itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to make Google tell us where to eat, but in Paris. We can
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this code. You can find this script in the `wheretoeat.js`
    file. We already know what `puppeteer.launch` and `browser.newPage` do. The third
    line has something new: `browser.defaultBrowserContext`. OK, that''s new for us,
    but that''s not a big deal. It will give us the context of the new page we got
    in the previous line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line does have something interesting: `context.overridePermissions`.
    This function allows us to bypass many permission checks that Chromium performs.
    If you open Google for the first time and you search for "where to eat," you will
    get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Geolocation permission request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation permission request
  prefs: []
  type: TYPE_NORMAL
- en: 'That window is not something you can click on with Puppeteer. As we can''t
    click on that, Puppeteer provides `context.overridePermissions` to tell the browser
    which permissions we want to grant automatically. The signature is quite simple:
    `browserContext.overridePermissions(origin, permissions)`, where `origin` is the
    page (the URL) we want to grant permission, and `permissions` is an array of strings
    accepting one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: geolocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: midi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: midi-sysex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: microphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: background-sync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ambient-light-sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: magnetometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: accessibility-events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clipboard-read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clipboard-write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: payment-handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to remember all these values; just come to this list when you
    get a permission request, and you need to know which value to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line is a fun one: `await page.setGeolocation({latitude: 48.8578349,
    longitude: 2.3249841})`. This function is also fairly straightforward. It only
    expects an object with three properties: `latitude`, which is a number between
    -90 and 90; `longitude`, which is a number between -180 and 180; and `accuracy`.'
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know the coordinates of a place, you can go to Google Maps ([https://www.google.com/maps](https://www.google.com/maps))
    and search for a place. The resulting URL will give you the coordinates. For instance,
    if you search for Paris, the URL should be https://www.google.com/maps/search/Paris/@48.8590448,2.3257917,14.49z;
    `48.8590448` will be the latitude, and `2.3257917` the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the geolocation, we can navigate to Google, type **where to eat**,
    and the result will be where to eat in Paris:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Where to eat in Paris'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Where to eat in Paris
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer allows us to emulate not only a location but also a time zone. Let's
    see how we can travel around the globe with Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating time zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding a use case for time zone emulation is not easy, but there are a few.
    You can emulate time zones to test an application in some specific time zone,
    even if you are not there. This will be helpful when we talk about scraping in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One check that can be interesting is testing that your application saves data
    correctly, no matter the time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to emulate time zones is pretty straightforward: `page.emulateTimezone(timezoneId)`,
    where `timezoneId` is an ICU''s time zone. Chromium also has a list of ICU time
    zones in its source code. You can find it using the following link: [https://www.hardkoded.com/ui-testing-with-puppeteer/metazones](https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test this feature, you can try changing your time zone and going
    to a site that shows your current date. You can follow this script in the `timezones.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There we set the time zone to "Europe/London," and go to [https://www.unixtimestamp.com/](https://www.unixtimestamp.com/),
    which shows dates and times in different formats. Not a fancy feature, but it
    might be useful someday.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we want to cover on this localization topic is language.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delivering the website in the user's language is the first thing developers
    cover when implementing localization. But there's one problem in our ecosystem.
    Let's cover the four common ways developers implement localization.
  prefs: []
  type: TYPE_NORMAL
- en: You will see sites that will show you the content **based on your IP**. If it
    detects your IP is from Spain, it'll show you content in Spanish. If it detects
    you're in France, it'll show you the site in French. What if you live in a country
    with five official languages? It just picks one. As we mentioned when we talked
    about geolocation, we won't be able to emulate IP-based language change.
  prefs: []
  type: TYPE_NORMAL
- en: Developers could also deliver **domain-based** solutions. If you go to [www.amazon.es](http://www.amazon.es),
    you will see the content in Spanish. If you go to [www.amazon.fr](http://www.amazon.fr),
    you will see content in French. This will be easy to test. You just need to create
    a language domain map and use it in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Third, developers might offer a **preference-based** solution. If you go to
    [www.amazon.com](http://www.amazon.com), you'll get the content in English, but
    it will show you a drop-down list somewhere to change your language. This one
    will also be easy to test. You could have one user per language in your test database,
    and then use them to test the website in different languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option I will cover here, although maybe there are more, is the one
    I believe is the proper way of inferring the user language: by reading the **Accept-Language
    header** value. According to MDN (https://www.hardkoded.com/ui-testing-with-puppeteer/Accept-Language),
    "*the Accept-Language request HTTP header advertises which languages the client
    is able to understand, and which locale variant is preferred. (By languages, we
    mean natural languages, such as English, and not programming languages.) Using
    content negotiation, the server then selects one of the proposals, uses it and
    informs the client of its choice with the Content-Language response header*."'
  prefs: []
  type: TYPE_NORMAL
- en: The browser tells the server which languages you prefer. When you navigate to
    a page, and on every subsequent request after that, the browser adds the **Accept-Language**
    header so that the server can act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install a Browser, it will have a default list of languages, based
    on the download option you chose or the language of your Operative System. But
    you can then go to the preferences page and change that list of languages. If
    you go to your browser''s preferences, you should be able to find a **Languages**
    section. You should be able to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.17_B16113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Language settings in Microsoft Edge
  prefs: []
  type: TYPE_NORMAL
- en: 'There, I have three languages: English (United States), English, and Spanish.
    All those three are set in the Accept-Language header. Sadly for us, according
    to Paul Reinheimer (https://twitter.com/preinheimer), only 7.2% of the top 10,000
    sites supported Accept-Language in 2017 (https://wonderproxy.com/blog/accept-language/).
    That means that despite having the tools to infer the language based on the user''s
    preference, most sites won''t use it. I hope that changes over time. How can we
    test languages using the Accept-Language header? It''s not that hard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a way you can get Google's website in French. We will talk more about
    `page.setExtraHTTPHeaders` in the next chapter. But what you need to know is that
    you will be able to change the Accept-Language header the server gets.
  prefs: []
  type: TYPE_NORMAL
- en: I think we have now seen the most relevant emulation features that Puppeteer
    offers. But I don't want you to miss anything. Let me briefly show you a few more
    emulation tools.
  prefs: []
  type: TYPE_NORMAL
- en: Other emulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up this chapter, I want to share three extra emulation functions with
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is related to **accessibility**. Localization and accessibility
    are two human topics. They talk about integration, about not leaving anyone out,
    not even from the web. I believe that your website could leave certain cultures
    out (read these words in context, please). You could say, "I don''t plan to sell
    my products to this country, so I don''t need to translate my site to X." As we
    said, localization could be expensive. But we do have to design sites to be inclusive.
    I think that in the same way we enforce shopping malls to have ramps for wheelchairs,
    we should enforce websites to be accessible. I could write lots of pages about
    this, but that''s not the purpose of this book. But I encourage you to read about
    inclusive design on Microsoft''s site: [https://www.microsoft.com/design/inclusive/](https://www.microsoft.com/design/inclusive/).
    I will leave you with this quote from that site:'
  prefs: []
  type: TYPE_NORMAL
- en: Exclusion happens when we solve problems using our own biases.
  prefs: []
  type: TYPE_NORMAL
- en: I'm taking the time to write these paragraphs in a UI testing book because I
    believe that Quality Assurance is the last line of defense for defending and including
    all users of the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppeteer won''t cover every accessibility check you should do, but it will
    help you emulate different vision deficiencies. You can call the `page.emulateVisionDeficiency(type)`
    function to emulate the following vision deficiencies: **achromatopsia** (total
    color blindness), **deuteranopia** (green color blindness), **protanopia** (red
    color blindness), **tritanopia** (blue-yellow color blindness), and **blurredVision**,
    to check blurred vision. Let''s see how we can use this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this check, you will get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packtpub under blurred vision emulation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Packtpub under blurred vision emulation
  prefs: []
  type: TYPE_NORMAL
- en: You could write checks such as this and share them in a dashboard, so both the
    design and the development team can see how accessible the site is for people
    with visual impairments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next emulation I want to share with you is about emulating media features.
    The function is `page.emulateMediaFeatures(features)`. It accepts an array of
    **name/value** features you want to change. These are the two features that Puppeteer
    supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prefers-colors-scheme`, which will help you toggle between `dark` and `light`
    mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefers-reduced-motion`, which will reduce CSS animations with the `reduce`
    option or `no-preference`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This might not have been a popular feature a few years ago. But now, many sites
    are jumping onto the dark mode hype. This is how you can test dark mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can simply navigate to a page and emulate `prefers-color-scheme`
    with the value `dark`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last emulation I want to share in this chapter is media type emulation.
    We talked about media types when we talked about PDF generation. We have two media
    types: **screen** and **print**. This is an excellent feature if you need to test
    how a page would be printed. You could use it to test the receipt page, which
    might be printed by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is `page.emulateMediaType(type)`, and the type is a string that
    can be `screen` or `print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we go to the Puppeteer repo and check how it would look if we were about
    to print the page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was another chapter full of content. I hope you enjoyed it as much as I
    enjoyed writing it.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by talking about the internet ecosystem. We talked about
    how the world is moving toward mobile experiences. This is an excellent time to
    reach out to the person in charge of analytics in your company and see whether
    the charts we saw in this chapter represent your website's users.
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved on to mobile emulation. There, we learn about the viewport, the
    pixel ratio, a fundamental concept in mobile resolution, touchscreen emulation,
    and the user agent.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to emulate different network conditions. We will see in
    [*Chapter 10*](B16113_10_Final_SK_ePub.xhtml#_idTextAnchor167), *Evaluating and
    Improving the Performance of a Website*, how critical speed is in the mobile experience.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we covered localization emulation. We learned how
    to emulate geolocation, time zones, and languages.
  prefs: []
  type: TYPE_NORMAL
- en: I didn't want to leave any emulation out of this chapter. That's why we also
    learned about other available emulations. We covered accessibility, dark mode,
    and media type emulation. Testing dark mode will become more important with all
    the dark mode hype we live in these days.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about Scraping. We will demystify the concept of scraping
    and learn some new techniques so that you can use Puppeteer not only for testing
    but also for other fun stuff.
  prefs: []
  type: TYPE_NORMAL
