- en: Introducing Aurelia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Aurelia
- en: If you were born in the 80s or 90s, without doubt, you were a witness to the
    internet evolution. The first web pages were composed only of black text in a
    white screen; everything they wrote was in pure HTML format, and really, really
    static. After some years, the first CSS was adding some color to the web, and,
    after some unsuccessful  attempts, JavaScript did appear.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您出生于80年代或90年代，毫无疑问，您是互联网演变的见证者。最初的网页仅由白色屏幕上的黑色文本组成；他们所写的一切都是纯HTML格式，实际上是非常静态的。几年后，第一个CSS为网络添加了一些颜色，经过一些不成功的尝试后，JavaScript终于出现了。
- en: From its first appearance, JavaScript has improved over the years and adapted
    to build the next generation of web pages. Many companies such as Microsoft were
    involved in the evolution of this language, adding features and increasing its
    popularity. This new scripting language allowed the developers to improve the
    customer experience and application performance and, in a short time, there began
    to appear the first JavaScript frameworks that made JavaScript the new rock star
    of web development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从其首次出现以来，JavaScript 在这些年里不断改进并适应构建下一代网页。许多公司，如 Microsoft，参与了这种语言的演变，增加了功能并提高了其知名度。这种新的脚本语言允许开发者提高客户体验和应用性能，在短时间内，开始出现第一个
    JavaScript 框架，使 JavaScript 成为网络开发的新的摇滚明星。
- en: All this sounds great, but, was it always as awesome as the strong language
    we have today? Uhmm, no it was not. The first JavaScript version was created by
    *Brendan Eich* in 1995 for the *Netscape Navigator*, named in those times as *Mocha*,
    then *LiveScript*, and finally, JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来都很棒，但是，它是否一直像我们今天拥有的强类型语言那样出色？嗯，不是的。第一个 JavaScript 版本是由 *Brendan Eich*
    在 1995 年为 *Netscape Navigator* 创建的，当时命名为 *Mocha*，然后是 *LiveScript*，最终命名为 JavaScript。
- en: Let's explore more about the features of this powerful language and how it becomes
    one of the most used for application development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这种强大语言的特性以及它是如何成为最常用于应用开发的语言的。
- en: 'In this chapter, we will walk through the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: JavaScript fundamentals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 基础
- en: The ECMAScript standard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 标准
- en: Setting up our environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: The Aurelia framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 框架
- en: The Aurelia command line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 命令行
- en: Overview of the example app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例应用的概述
- en: JavaScript fundamentals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 基础
- en: JavaScript is a programming language used to add custom behavior to your web
    page by executing code in your web browser side (commonly named client side).
    So, this allows us to create rich dynamic projects such as games, execute custom
    code in response to events when the user presses some button, apply dynamic effects
    to our web page elements, form data validation, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种编程语言，用于通过在您的网页浏览器端（通常称为客户端）执行代码来为您的网页添加自定义行为。因此，这使我们能够创建丰富的动态项目，例如游戏，当用户按下某些按钮时执行自定义代码，对我们的网页元素应用动态效果，表单数据验证等等。
- en: JavaScript as a single language is very flexible, and there is a big community
    of developers writing and unlocking additional functionality, big companies working
    on new libraries and of course, we as empowered developers ready to get all these
    features and make the web awesome.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单一语言的 JavaScript 非常灵活，有一个庞大的开发者社区在编写和解锁额外的功能，大公司正在开发新的库，当然，我们作为有能力的开发者准备获取所有这些功能，使网络变得精彩。
- en: 'There are a few basic characteristics of JavaScript:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有几个基本特征：
- en: Dynamic typing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型
- en: Object oriented
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象
- en: Functional
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式
- en: Prototyped
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型化
- en: Event handling
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Dynamic typing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态类型
- en: In most of the scripting languages, the type is associated with the value, not
    with the variable itself. What it means? JavaScript and other languages such as
    Python, called **weakly typed**, does not need to specify which kind of data we
    will use to store in the variable. JavaScript has many ways to ensure the correct
    type of an object, including *duck typing*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数脚本语言中，类型与值相关联，而不是与变量本身相关联。这意味着什么？JavaScript 和其他如 Python 等称为 **弱类型** 的语言不需要指定我们将使用哪种数据类型存储在变量中。JavaScript
    有许多方法来确保对象的正确类型，包括 *鸭子类型*。
- en: Why duck?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是鸭子？
- en: Well, James Whitcomb did a humorous inference explaining the deductive thinking
    about it—"If it looks like a duck, swims like a duck, and quacks like a duck,
    then it probably is a duck"
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，James Whitcomb 对其进行了幽默的推断，解释了关于它的演绎思维——“如果它看起来像鸭子，游泳像鸭子，叫声像鸭子，那么它可能就是一只鸭子”
- en: 'Let’s look at an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the defined variables accept any data type, because data
    types will be evaluated at runtime, so, for example, the `age` variable in line
    `1` will be an integer, will become a string in line `2` and, finally, Boolean.
    Sounds tricky? Don't worry, think of the variable as an empty vial without a label.
    You can put anything you want, cookies, milk, or salt. What you will store in
    the vial? Depending of your needs, if you want to make a breakfast, milk should
    be the better option. The only thing you must keep in mind, is remember what is
    containing this vial! We would hate to confuse salt with sweet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，定义的变量接受任何数据类型，因为数据类型将在运行时评估，所以，例如，第 `1` 行的 `age` 变量将是一个整数，在第 `2` 行将变成字符串，最后是布尔值。听起来很复杂吗？别担心，把变量想象成一个没有标签的空瓶子。你可以放任何你想要的东西，饼干、牛奶或盐。你会在瓶子里放什么？根据你的需求，如果你想做早餐，牛奶可能是更好的选择。唯一你必须记住的是，记住这个瓶子里装的是什么！我们不愿意把盐和甜味混淆。
- en: 'If we need to ensure that the value belongs to some specific type, we can use
    the `typeof` operator to retrieve the data type of a given variable. Let''s have
    a look at them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要确保值属于某些特定类型，我们可以使用 `typeof` 操作符来检索给定变量的数据类型。让我们看看它们：
- en: '`typeof "Diego"`: This will return `string`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typeof "Diego"`：这将返回 `string`'
- en: '`typeof false`: This will return `boolean`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typeof false`：这将返回 `boolean`'
- en: '`typeof "Diego" == boolean`: This will return `false`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typeof "Diego" == boolean`：这将返回 `false`'
- en: The `typeof` operator is very useful, but keep in mind it only gives primary
    types (`number`, `string`, `boolean` or `object`). Different from other similar
    operators such `instanceof` of Java, `typeof` won't return the object type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 操作符非常有用，但请记住，它只给出基本类型（`number`、`string`、`boolean` 或 `object`）。与 Java
    中的类似操作符 `instanceof` 不同，`typeof` 不会返回对象类型。'
- en: Object oriented
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象
- en: JavaScript objects are based on associative arrays, improved with the prototyping
    inclusion. The properties and values can be changed at runtime. Another common
    way to create objects is using the **JavaScript Object Notation** (**JSON**) or
    using functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象基于关联数组，通过包含原型进行了改进。属性和值可以在运行时更改。创建对象的另一种常见方式是使用 **JavaScript 对象表示法**（**JSON**）或使用函数。
- en: 'Let''s see how an object created by JavaScript code looks, and its JSON representation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看由 JavaScript 代码创建的对象的外观及其 JSON 表示形式：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functional
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式
- en: 'A function is an object inside itself. They have properties, methods, and can
    include inner functions. It''s a way to encapsulate a functionality you want to
    reuse in more than one place in your application; you just need to write the function
    name instead of all the code inside that, just like the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个包含自身的对象。它们有属性、方法，并且可以包含内部函数。这是一种在应用程序的多个地方重用功能的方法；你只需要写函数名，而不是所有代码，就像以下示例：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Prototyped
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型化
- en: 'JavaScript uses prototypes instead of classes for inheritance. It is possible
    to emulate all OOP characteristics using just prototypes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用原型而不是类来实现继承。仅使用原型就可以模拟所有面向对象（OOP）的特性：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That being said, what is exactly a prototype? Different from objects, one prototype
    does not have a closed structure. In objects, we define standard properties and
    we just have these properties for work, since JavaScript is not completely an
    object-oriented language, we have the advantage to add, remove, or change properties
    and values of our prototypes depending on our needs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，原型究竟是什么？与对象不同，一个原型没有封闭的结构。在对象中，我们定义标准属性，我们只是有这些属性来工作，因为 JavaScript 并非完全是一种面向对象的语言，我们有添加、删除或根据需要更改原型属性和值的优势。
- en: We can modify prototype attributes at runtime. Note that even if you can modify
    any prototype, you should only modify yours. If you modify standard prototypes
    (for example, the  array prototype) you will encounter very weird bugs in your
    application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在运行时修改原型属性。请注意，即使你可以修改任何原型，你也应该只修改自己的。如果你修改标准原型（例如，数组原型），你将在应用程序中遇到非常奇怪的错误。
- en: Events handling
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: 'Events allow you to add the real interaction on your web page. JavaScript allows
    you to attach event handlers on your HTML pages and execute custom code when they
    are triggered. For example, the given code will display an alert when the user
    clicks on your web page body:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 事件允许你在网页上添加真正的交互。JavaScript 允许你在 HTML 页面上附加事件处理器，并在它们被触发时执行自定义代码。例如，给定的代码将在用户点击网页主体时显示一个警告：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ECMAScript standard
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 标准
- en: In the beginning, some companies such as Microsoft were trying to develop their
    own JavaScript implementation, in this case, JScript for Internet Explorer 3.0,
    in the year  1996\. To define a standard, Netscape delivered JavaScript to the
    **European Computer Manufacturers Association** (**ECMA**), a standards organization
    for information and communication systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，一些公司，如 Microsoft，试图开发他们自己的 JavaScript 实现，在这种情况下，1996 年为 Internet Explorer
    3.0 开发的 JScript。为了定义一个标准，Netscape 将 JavaScript 提交给**欧洲计算机制造商协会**（**ECMA**），这是一个信息和通信系统的标准化组织。
- en: The first edition of ECMA-262 was adopted by the ECMA General Assembly in June
    1997\. Several editions of the language standard have been published since then.
    The name *ECMAScript* was a compromise between the organizations involved in standardizing
    the language, especially Netscape and Microsoft, whose disputes dominated the
    early standards sessions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA-262 的第一版于 1997 年 6 月由 ECMA 全体会议采纳。自那时起，该语言标准的多个版本已经发布。*ECMAScript* 这个名字是参与语言标准化工作的组织之间的一种折衷，特别是
    Netscape 和 Microsoft，他们的争议主导了早期的标准会议。
- en: So, after all these standardization processes and paperwork, what are we using?
    ECMAScript, JScript, ActionScript, or JavaScript? Are they the same? Well, basically
    no. After the standardization, ECMAScript was defined as the main language, and
    JavaScript, JScript, and ActionScript are dialects of this language, of course,
    JavaScript being the most known and used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，经过所有这些标准化过程和文件工作，我们到底在用什么呢？ECMAScript、JScript、ActionScript 还是 JavaScript？它们是相同的吗？基本上不是。标准化后，ECMAScript
    被定义为主要的语言，而 JavaScript、JScript 和 ActionScript 是这种语言的方言，当然，JavaScript 是最知名和最常用的。
- en: 'The ECMAScript Version 5 is supported by most browsers nowadays, released in
    2011\. Some of the features managed for this version are as listed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数浏览器都支持 ECMAScript 版本 5，该版本于 2011 年发布。为这个版本管理的特性如下所示：
- en: Support for new Array methods
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数组方法支持
- en: Support for manage dates
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期管理支持
- en: Support for JSON
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 支持
- en: At this point, we’ve seen pure ES5 syntax, very verbose, sometimes highly coupled
    with other functionality, and if we are planning to develop a big application,
    it can become difficult to maintain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了纯 ES5 语法，非常冗长，有时与其他功能高度耦合，如果我们计划开发大型应用程序，它可能变得难以维护。
- en: Thank God we won’t have to deal with this syntax anymore. The **ECMAScript 6**
    (**ES6**) version came with a lot of changes that simplify the development and
    understanding of our code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 谢天谢地，我们再也不必处理这种语法了。**ECMAScript 6**（**ES6**）版本带来了许多简化代码开发和理解的改变。
- en: ES 6
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES 6
- en: This version arrives with significant changes in the language syntax. Let's
    review the new features and compare with the ES5 syntax.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本带来了语言语法的重大变化。让我们回顾一下新特性，并与 ES5 语法进行比较。
- en: 'In ES5, to make a near representation of an object in JavaScript, we commonly
    type something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，为了在 JavaScript 中创建一个近似的对象表示，我们通常输入如下内容：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we want to improve our code, maybe we can do some refactoring, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要改进我们的代码，也许我们可以进行一些重构，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s how **Object-Oriented Programming** (**OOP**) is done on JavaScript
    these days, but for programmers with previous experience on Java or PHP, that
    syntax result is a little difficult to understand, because they are not dealing
    with real objects, they are dealing directly with the prototypes. ES6 introduces
    a new syntax to declare objects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是现在在 JavaScript 上如何进行**面向对象编程**（**OOP**），但对于有 Java 或 PHP 等先前经验的程序员来说，这种语法结果可能有点难以理解，因为他们不是处理真实对象，而是直接处理原型。ES6
    引入了一种新的语法来声明对象：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, now, the syntax is more readable and understandable, and we
    can extend from another class, just like other languages, such as Java:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在的语法更加易读易懂，我们可以从另一个类扩展，就像其他语言，例如 Java：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, of course, we can use encapsulation principles to manipulate our object
    properties. Similar to Java, we can define mutator methods to get the property
    value or set some value to a property:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用封装原则来操作我们的对象属性。类似于 Java，我们可以定义修改器方法来获取属性值或将某些值设置到属性中：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having these kind of methods does not avoid the fact that you can still be
    using the JavaScript native syntax to change the values or add properties at runtime.
    You will still be able to do the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有这些方法，但这并不能避免你仍然可以使用 JavaScript 的原生语法在运行时更改值或添加属性的事实。你仍然能够执行以下操作：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like other languages, ES6 allows static methods using the static modifier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他语言一样，ES6 允许使用静态修饰符使用静态方法：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Do you note something? In the last example, we used `let` instead of `var`
    to declare a variable. ES6 has two new ways of defining a variable: `let` is the
    direct replacement of `var`, and `const` will be used if we are declaring a constant.
    Can we still use `var` instead of the new ES6 declaration syntax? Yes, but let''s
    imagine that you are an experienced developer and have two trainees under your
    supervision. In your code, you can define something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到什么了吗？在最后一个例子中，我们使用了`let`而不是`var`来声明一个变量。ES6有两种新的变量定义方式：`let`是`var`的直接替代，而`const`将用于声明常量。我们是否还可以使用`var`而不是新的ES6声明语法？是的，但让我们想象一下，你是一位经验丰富的开发者，并且有两位实习生在你的监督下。在你的代码中，你可以定义如下内容：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, of course, we do not want this value changed, for any reason. As this
    is still a `var`, any trainee developer is able to change the value, directly
    or indirectly (from a method call, assignation error, bad comparison syntax, and
    so on), so we are exposed to get errors on our application. To prevent these kind
    of scenarios, `const` would be a more accurate modifier for this variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也不希望这个值因任何原因而改变。由于这仍然是一个`var`，任何初级开发者都可以直接或间接地（通过方法调用、赋值错误、错误的比较语法等）更改该值，因此我们可能会在我们的应用中遇到错误。为了防止这类情况，`const`将是一个更准确的变量修饰符。
- en: Does ES6 only improve syntax for objects' declaration? No. At this moment, we
    only focused on our class definition syntax, because it will be the core of all
    applications, just like OOP. Now, we will check other improvements that we are
    pretty sure you will find very useful in your day-to-day work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ES6仅仅改进了对象的声明语法吗？不。此刻，我们只关注我们的类定义语法，因为它将是所有应用的核心，就像面向对象编程一样。现在，我们将检查其他改进，我们非常确信你会在日常工作中发现这些改进非常有用。
- en: 'A very important note: You must know that different to other code languages,
    in Javascript you can define `const MY_ARRAY = []` and you will still being able
    to do `MY_ARRAY.push(3)`. The `const` prefix will only avoid the overwriting,
    so you cannot do `MY_ARRAY = [1,2]`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的注意事项：你必须知道，与其他代码语言不同，在JavaScript中，你可以定义`const MY_ARRAY = []`，并且你仍然能够执行`MY_ARRAY.push(3)`。`const`前缀只会避免覆盖，所以你不能做`MY_ARRAY
    = [1,2]`
- en: Arrow functions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'You need to iterate over the elements of an array; normally, you would write
    something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要遍历数组的元素；通常，你会写如下内容：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the arrow functions, you can refactor your code and write something as
    follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，你可以重构你的代码，并编写如下内容：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The arrow (`=>`) operator defines a function in one line, making our code readable
    and ordered. First, you need to declare the inputs; the arrow will send these
    params to the function body defined by the operator:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头（`=>`）操作符在一行中定义一个函数，使我们的代码更易读和有序。首先，你需要声明输入；箭头会将这些参数发送到由操作符定义的函数体：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: String interpolation
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'Do you remember those times when you needed to concatenate a string using the
    `+` operator? It won’t be necessary anymore. For example, the following code concatenates
    `string1` and `string2` using the `+` operator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得那些需要使用`+`操作符连接字符串的时候吗？这不再必要了。例如，以下代码使用`+`操作符连接`string1`和`string2`：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s look at how interpolation helps us write simpler code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看插值如何帮助我们编写更简单的代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Destructuring
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构赋值
- en: 'We have a new way to assign values to objects and arrays. Let’s look at some
    examples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种新的方法来为对象和数组赋值。让我们看看一些例子：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Setting up our environment
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: At this point, we are ready to start writing our first functions and methods
    in JavaScript language. We know how to deal with the new ES6 syntax and how we
    can use all these new features to improve our application. Let's set up our environment
    and install Node.js.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好开始用JavaScript语言编写我们的第一个函数和方法。我们知道如何处理新的ES6语法，以及我们如何使用所有这些新特性来改进我们的应用。让我们设置我们的环境并安装Node.js。
- en: Installing Node.js
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: The first thing you need to do to start using NPM is download Node.js. Node
    is an asynchronous event-driven JavaScript runtime. It is not a new language or
    a new syntax; it's just the platform where you can write JavaScript code outside
    the browser and Node.js will use the power of Google's V8 JavaScript Engine to
    execute it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用NPM，你需要先下载Node.js。Node是一个异步事件驱动的JavaScript运行时环境。它不是一种新的语言或新的语法；它只是你可以在其中编写JavaScript代码的平台，而Node.js将使用谷歌的V8
    JavaScript引擎来执行它。
- en: If you're using OS X or Windows, the best way to install Node.js is to use one
    of the installers from the Node.js download page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 OS X 或 Windows，最佳安装 Node.js 的方式是使用 Node.js 下载页面上的安装程序之一。
- en: If you're using Linux, you can use your package manager or check the download
    page to see whether there's a more recent version that works with your system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Linux，你可以使用你的包管理器或查看下载页面，以查看是否有与你的系统兼容的更新版本。
- en: 'To check whether you have a previous version installed, run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你是否安装了之前的版本，请运行以下命令：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Node Package Manager
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node 包管理器
- en: 'The **Node Package Manager** (**NPM**) is a complete tool created to help developers
    share, maintain, and reuse JavaScript code bundled in packages with other developers
    to reuse it on their own applications. NPM is made up of three distinct components:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 包管理器**（**NPM**）是一个完整的工具，旨在帮助开发者共享、维护和重用打包在包中的 JavaScript 代码，以便其他开发者可以在自己的应用程序中重用。NPM
    由三个不同的组件组成：'
- en: The NPM website
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM 网站
- en: The NPM registry
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM 仓库
- en: The NPM command-line tool
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM 命令行工具
- en: NPM website
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM 网站
- en: 'This website serves as the primary tool for users to discover packages; you’ll
    find something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站作为用户发现包的主要工具；你会找到类似以下的内容：
- en: '![](img/8b39f41c-df77-4799-964a-a5a60aa36fc9.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b39f41c-df77-4799-964a-a5a60aa36fc9.png)'
- en: This page describes all the features of the package you want to download, a
    brief documentation about it, the GitHub URL, and instructions to import them
    into your project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面描述了你想要下载的包的所有功能，关于它的简要文档，GitHub 网址以及将其导入项目的说明。
- en: NPM Registry
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM 仓库
- en: It is a large database of information about each package. The official public
    NPM registry is at [https://registry.npmjs.org/](https://registry.npmjs.org/).
    It is powered by a CouchDB database, of which there is a public mirror at [https://skimdb.npmjs.com/registry](https://skimdb.npmjs.com/registry).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它是关于每个包的信息的大型数据库。官方公共 NPM 仓库位于 [https://registry.npmjs.org/](https://registry.npmjs.org/)。它由
    CouchDB 数据库提供支持，其中有一个公共镜像位于 [https://skimdb.npmjs.com/registry](https://skimdb.npmjs.com/registry)。
- en: NPM CLI
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM CLI
- en: A command-line tool for interacting with the registry and allowing the developers
    to publish or download packages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于与仓库交互的命令行工具，允许开发者发布或下载包。
- en: Once you have the code downloaded on your machine, NPM will make it very easy
    to check whether there is an update available and download those changes when
    they’re made. More than two bits of reusable code is called a package. That’s
    just a directory with one or more files in it, along with a file called `package.json`,
    which contains all the metadata about that package.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将代码下载到你的机器上，NPM 将使检查是否有更新可用以及下载这些更改变得非常容易。超过两个可重用的代码块被称为包。那只是一个包含一个或多个文件的目录，以及一个名为
    `package.json` 的文件，其中包含有关该包的所有元数据。
- en: Common NPM operations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 NPM 操作
- en: Like all the command-line tools, it is important to understand the options provided
    by NPM. The NPM CLI is a powerful tool that will help us in the development cycle
    of our project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有命令行工具一样，了解 NPM 提供的选项非常重要。NPM CLI 是一个强大的工具，将帮助我们完成项目的开发周期。
- en: Updating NPM
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 NPM
- en: 'The first step is complete! We have the Node runtime on our machine ready to
    execute our `.js` files, so the last thing we need to start working on is the
    NPM. Node comes with NPM installed by default, but NPM gets updated more frequently
    than Node, so we can check the updation of our NPM CLI by executing the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步已经完成！我们已经在我们的机器上安装了 Node 运行时，可以执行我们的 `.js` 文件，所以我们需要开始工作的最后一件事就是 NPM。Node
    默认安装了 NPM，但 NPM 的更新频率比 Node 更高，因此我们可以通过执行以下命令来检查我们的 NPM CLI 的更新情况：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Installing NPM packages
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 NPM 包
- en: 'NPM is installed and configured; now it''s time to start working. There are
    two ways to install NPM packages. Our choice will depend on how we want to use
    the package. The options are as listed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 已安装和配置；现在是时候开始工作了。有两种方式可以安装 NPM 包。我们的选择将取决于我们如何使用该包。选项如下：
- en: '**Globally:** Install the given package globally as part of our command-line
    tools'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局安装：**将给定的包作为我们的命令行工具的一部分全局安装'
- en: '**Locally:** Install the given package to be available only in our application
    context'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地安装：**将给定的包安装到我们的应用程序上下文中，使其仅在我们自己的应用程序中使用'
- en: 'With this in mind, type the following command to install a new package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，输入以下命令来安装一个新的包：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This instruction will create a folder called `node_modules`, where we will
    download all the packages we need. We can ensure that we have the package downloaded,
    entering the folder and checking the existence of a folder with a name similar
    to our package name. Run the following command to list all the packages installed
    in your project:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将创建一个名为 `node_modules` 的文件夹，我们将在此文件夹中下载所有需要的包。我们可以确保已下载包，进入文件夹并检查是否存在一个与我们的包名相似的文件夹。运行以下命令以列出项目中安装的所有包：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Versions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本
- en: 'If no package version is specified, we will get the latest. To install a specific
    version, we need to add the following to the `install` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定包版本，我们将获取最新版本。要安装特定版本，我们需要在 `install` 命令中添加以下内容：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The package.json file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.json 文件
- en: We know how to download a package and how to import it into our project. However,
    we will commonly need more than one package, with some specific versions. Should
    we memorize them to download manually each time we set up the project? No, now
    is the moment to create a `package.json` file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何下载一个包并将其导入到我们的项目中。然而，我们通常需要不止一个包，并且需要特定的版本。我们是否需要记住它们以便每次设置项目时都手动下载？不，现在是创建
    `package.json` 文件的时候了。
- en: 'This file is not only to map our dependencies; it must contain all the metadata
    about our project, and it serves as a quick documentation for which packages your
    project depends on. As minimal, the `package.json` should contain the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件不仅用于映射我们的依赖项；它必须包含我们项目的所有元数据，并作为快速文档，说明项目依赖于哪些包。至少，`package.json` 应包含以下内容：
- en: '**Name**: Project name, all lowercase with no blank spaces (you can use underscores
    if needed)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：项目名称，全部小写，没有空格（如果需要，可以使用下划线）'
- en: '**Version**: In the form of x.x.x'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：以 x.x.x 的形式'
- en: 'We can create this file manually, but NPM allows us to create it automatically
    by executing the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动创建此文件，但 NPM 允许我们通过执行以下命令自动创建：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command will prompt you with a bunch of questions that will be
    present in your `package.json` file. If you don''t want to accept the defaults
    without being prompted any question, run the same command, adding a `--yes` flag
    at the end:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将提示您一系列问题，这些问题将出现在您的 `package.json` 文件中。如果您不想在未提示任何问题的情况下接受默认值，请运行相同的命令，并在末尾添加一个
    `--yes` 标志：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, you will get a `package.json` file, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将得到一个如下的 `package.json` 文件：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dependencies and devDependencies
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项和 devDependencies
- en: You have all your dependencies installed now. You start working and during the
    development process, you may need some other dependencies to improve your code.
    You just need to run the NPM CLI to get the new dependency, but this will not
    be present in your `package.json` file! It can be very dangerous, because if you
    don't have the list of libraries or dependencies you need for your project, when
    you want to run it in a different machine, your code will fail, because the dependency
    is not installed in that machine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已安装了所有依赖项。您开始工作，在开发过程中，您可能需要其他依赖项来改进您的代码。您只需运行 NPM CLI 来获取新的依赖项，但这不会出现在您的
    `package.json` 文件中！这可能会非常危险，因为如果您没有项目所需的库或依赖项的列表，当您想在不同的机器上运行它时，您的代码将失败，因为依赖项未安装在该机器上。
- en: 'We can ensure that the new package name will be added to our dependencies''
    list, adding the `–-save` or `–-save-dev` flag. The first will add the package
    name to the dependencies'' section of the `package.json` file. This means that
    the dependency is mandatory for the application itself and should be installed
    before running or deploying the application. On the other hand, we have the devDependencies'' part,
    where there will be only the dependencies used for our development process:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加 `–-save` 或 `–-save-dev` 标志来确保新包名将被添加到我们的依赖项列表中。第一个将包名添加到 `package.json`
    文件的依赖项部分。这意味着依赖项是应用程序本身的强制性依赖项，应在运行或部署应用程序之前安装。另一方面，我们有 devDependencies 部分，其中将只包含用于我们开发过程的依赖项：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we are ready to start developing JavaScript applications. In the next section,
    you will make use of NPM to install the Aurelia command-line tool required to
    create new Aurelia projects, but let's continue exploring the Aurelia framework.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始开发 JavaScript 应用程序了。在下一节中，您将使用 NPM 安装创建新 Aurelia 项目所需的 Aurelia 命令行工具，但让我们继续探索
    Aurelia 框架。
- en: The Aurelia framework
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia 框架
- en: Before we start working with Aurelia and learning this amazing framework, it
    is important to have it clear why you should choose Aurelia over other popular
    frameworks. For that reason, let's explore in detail what a JavaScript framework
    is and the key differentiator present in Aurelia.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Aurelia 并学习这个令人惊叹的框架之前，了解为什么你应该选择 Aurelia 而不是其他流行的框架是很重要的。为此，让我们详细探讨一下什么是
    JavaScript 框架以及 Aurelia 中存在的关键区别性因素。
- en: What is a JavaScript framework?
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 JavaScript 框架？
- en: In the last section, we were reviewing all concerns about JavaScript and how
    we can organize our packages using NPM and Yarn. Now, it's time to review some
    tools that will improve our development experience; it's time to talk about frameworks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们回顾了所有关于 JavaScript 的疑虑以及我们如何使用 NPM 和 Yarn 来组织我们的包。现在，是时候回顾一些将提高我们的开发体验的工具了；是时候讨论框架了。
- en: A framework can be described as a group of tools and methodologies organized
    to solve common problems in the project development. Those solutions are generic;
    each one was tested in different environments and allows you to reuse that functionality
    to save time and cost.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可以被描述为一组工具和方法，这些工具和方法被组织起来以解决项目开发中的常见问题。这些解决方案是通用的；每个解决方案都在不同的环境中进行了测试，并允许你重用这些功能以节省时间和成本。
- en: 'So, based on the previous explanation, we can define a JavaScript framework
    as a collection of components and libraries (in most cases, interdependent) to
    fill the needs of the application in browser clients. What are these needs? Let''s
    check some of the most generic ones:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据前面的解释，我们可以将 JavaScript 框架定义为一组组件和库（在大多数情况下，相互依赖）的集合，以满足浏览器客户端应用程序的需求。这些需求是什么？让我们检查一些最通用的需求：
- en: Routing
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Data sending features and retrieval (XMLHttpRequest)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据发送功能和检索（XMLHttpRequest）
- en: Correct DOM management
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确管理 DOM
- en: Managing and organizing your code in separated functionality
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分离的功能中管理和组织你的代码
- en: Defining standard data flows for the application
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序的标准数据流
- en: Defining lifecycle for some functionality
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义某些功能的生命周期
- en: Why use a JavaScript framework?
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 JavaScript 框架？
- en: 'In general, a JavaScript framework will help us do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JavaScript 框架将帮助我们完成以下工作：
- en: Organizing your code
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织你的代码
- en: Structuring it in a maintainable and ordered way
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可维护和有序的方式构建结构
- en: Making separation of concerns
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现关注点的分离
- en: Implementing tested solutions to the most common problems
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现针对最常见问题的测试解决方案
- en: Working on a base structure that any developer can follow
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何开发者都可以遵循的基础结构上工作
- en: More specifically, a JavaScript framework is particularly helpful for applications
    where much of the business logic will take place on the client side—routing, templating,
    first-pass model validation, table building and pagination—pretty much whatever
    you might have used the server for in the past, but now without the latency and
    overhead that additional HTTP calls would have incurred.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，JavaScript 框架特别有助于那些大部分业务逻辑将在客户端执行的应用程序——路由、模板化、首次模型验证、表格构建和分页——几乎是你过去可能用于服务器的任何东西，但现在没有额外的
    HTTP 调用所造成的延迟和开销。
- en: JavaScript framework comparison
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 框架比较
- en: One problem always has more than just one solution, and JavaScript developers
    know that. Before 2010, developers had very limited options to implement their
    functionality in their day-to-day work. The most popular option in these times
    was jQuery, used a lot nowadays too. Although jQuery was not a bad choice, but
    it has a great weakness. For example, if your project growth and your business
    code become more complex, jQuery will be really difficult to maintain, your concerns
    will be mixed, and you will be involved in one of the most common anti-patron—**Spaghetti
    code**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题通常有不止一个解决方案，JavaScript 开发者都知道这一点。在 2010 年之前，开发者们在日常工作中实现功能的选择非常有限。在那个时代最受欢迎的选项是
    jQuery，现在仍然被广泛使用。虽然 jQuery 并不是一个坏的选择，但它有一个很大的弱点。例如，如果你的项目增长和你的业务代码变得更加复杂，jQuery
    将会非常难以维护，你的关注点将会混合，你可能会陷入最常见的反模式之一——**意大利面条式代码**。
- en: In 2010, Google released one of the most popular JavaScript frameworks—Angular.
    Different from jQuery, Angular comes with a complete set of tools and a new way
    to organize the JavaScript code, introducing new concepts such as modules, components,
    routes, and templates. After Angular, many JavaScript frameworks were appearing;
    some of them became very popular for the company sponsoring them, such as Facebook
    with React.js, others gained fame by the adoption of the community, such as Meteor
    and Vue, and others are really new in the neighborhood.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，谷歌发布了一个最受欢迎的JavaScript框架——Angular。与jQuery不同，Angular提供了一套完整的工具和一种新的组织JavaScript代码的方式，引入了模块、组件、路由和模板等新概念。在Angular之后，出现了许多JavaScript框架；其中一些因为赞助公司的支持而变得非常流行，例如Facebook的React.js，一些因为社区的采用而获得了名声，例如Meteor和Vue，还有一些在邻里中真正崭新。
- en: As innovation is the essence of technology, one of the main engineers of Angular
    2 project developed a new awesome framework called Aurelia, which, in just three
    years in the market, is becoming the new rock star in the neighborhood.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创新的本质，Angular 2项目的其中一位主要工程师开发了一个名为Aurelia的新颖框架，该框架在市场上仅仅三年时间，就已经成为了邻里的新摇滚明星。
- en: Why Aurelia?
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Aurelia？
- en: Over the last years in our current day-to-day work, we were getting involved
    with a vast variety of JavaScript frameworks; the most popular was always Angular,
    but we learned that popularity is not synonymous with quality. For understanding
    purposes, we will check some of the most used frameworks nowadays and then make
    a little comparison with our battle horse, Aurelia.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前日常工作的过去几年里，我们参与了各种各样的JavaScript框架；最受欢迎的始终是Angular，但我们了解到流行并不等同于质量。为了理解的目的，我们将检查现在最常用的几个框架，然后与我们的战斗马Aurelia进行一些比较。
- en: Angular
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular
- en: The component-based framework uses Typescript as the main (and unique) JavaScript
    platform. Angular is a complete superset of libraries designed for all purposes
    of **Single Page Applications** (**SPA**), very useful for developing applications
    from scratch. You can link your templates and your `Typescript` code so you `HTML`
    is updated with values from your code and ready to react on user actions . You
    need to learn three basic concepts about this framework—directives, modules, and
    components. Each one involves another, and you need to register each component
    with one Module to make it available. JavaScript also has its own module system
    for managing collections of JavaScript objects. It's completely different and
    unrelated to Angular's module system. Angular has its own implementation to define
    service classes, routes, double data binding, HTTP requests, and so on, making
    this framework very heavyweight.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该基于组件的框架使用TypeScript作为主要（且唯一）的JavaScript平台。Angular是一个为所有**单页应用（SPA**）目的设计的库的完整超集，非常适合从头开始开发应用程序。你可以链接你的模板和你的`TypeScript`代码，这样你的`HTML`就会根据代码中的值更新，并准备好对用户操作做出反应。你需要了解这个框架的三个基本概念——指令、模块和组件。每个概念都涉及另一个，你需要将每个组件注册到一个模块中，使其可用。JavaScript也有自己的模块系统来管理JavaScript对象的集合。它与Angular的模块系统完全不同且无关。Angular有自己定义服务类、路由、双向数据绑定、HTTP请求等的实现，这使得这个框架非常重量级。
- en: Technical information
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术信息
- en: '**Size**: 698 Kb'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：698 Kb'
- en: '**Standard compliance**: ES 2016 (TypeScript)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准兼容性**：ES 2016（TypeScript）'
- en: '**Non-compliant**: NG2 Markup and Dart'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不兼容**：NG2标记和Dart'
- en: '**Interoperability**: Average'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：平均'
- en: Dependency injection
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'The dependency injection framework requires more configuration. In contrast
    to Aurelia, Angular requires you to specify the HTML `selector` and `template`,
    increasing the file complexity. Aurelia will detect the template based on a name
    strategy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入框架需要更多的配置。与Aurelia相比，Angular要求你指定HTML `选择器`和`模板`，增加了文件复杂性。Aurelia将根据名称策略检测模板：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Component encapsulation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件封装
- en: 'Angular components need more explicit configuration and some (in some cases
    confusing) characters in the template. You can put the template in a separate
    file, or for simpler components, you can include the template inline:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件需要更明确的配置，并且在模板中有些（在某些情况下令人困惑）字符。你可以将模板放在单独的文件中，或者对于更简单的组件，你可以将模板内联包含：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: React.js
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React.js
- en: Different from Angular, React.js is a library that can be integrated with any
    JavaScript project. It is used for handling the view layer for the web applications
    and build reusable UI components. React is component based too, but it mixes the
    HTML code inside the JavaScript files, in JSX format. JSX is a React syntax very
    similar to XML format since you can manage your view layer and add some behavior
    defining some attributes as the state or properties of your component. Sounds
    a little confusing? Yes, you will need to learn how JSX works and read about some
    of the new concepts about the tool.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular不同，React.js是一个可以与任何JavaScript项目集成的库。它用于处理Web应用的视图层并构建可重用的UI组件。React也是基于组件的，但它将HTML代码混合在JavaScript文件中，以JSX格式。JSX是一种与XML格式非常相似的React语法，因为你可以管理你的视图层并添加一些行为，通过定义一些属性作为组件的状态或属性。听起来有点复杂？是的，你需要学习JSX是如何工作的，并阅读一些关于这个工具的新概念。
- en: React.js has a great feature—server-side rendering. What does that mean? Common
    JavaScript frameworks let the render work to the client side, so the browser needs
    to interpret your JavaScript files and transform it to plain HTML files. It can
    take time depending on how much data will be displayed on the page. With React.js,
    you can configure your server to have all those pages processed in the server
    side, so the browser just needs to call the correct HTML file and of course, the
    loading time will be less.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: React.js有一个很棒的功能——服务器端渲染。这意味着什么？常见的JavaScript框架让渲染工作在客户端进行，所以浏览器需要解释你的JavaScript文件并将其转换为纯HTML文件。这取决于页面上将显示多少数据，可能需要一些时间。使用React.js，你可以配置你的服务器在服务器端处理所有这些页面，所以浏览器只需要调用正确的HTML文件，当然，加载时间会更短。
- en: Similar to Angular, React.js offers you a complete set of libraries to implement
    dynamic routing, data binding, HTTP requests, and other React implementations
    libraries such as Inferno.js, with a rendering algorithm more powerful and optimized.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular类似，React.js为你提供了一套完整的库来实现动态路由、数据绑定、HTTP请求以及其他React实现库，如Inferno.js，具有更强大和优化的渲染算法。
- en: One very important note! Aurelia now has its own server side rendering plugin.
    You can find more info there: [https://aurelia.io/docs/ssr/introduction/](https://aurelia.io/docs/ssr/introduction/)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的注意事项！Aurelia现在有一个自己的服务器端渲染插件。你可以在那里找到更多信息：[https://aurelia.io/docs/ssr/introduction/](https://aurelia.io/docs/ssr/introduction/)
- en: Technical information
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术信息
- en: '**Size**: 156 KB or 167 KB with plugins'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：156 KB 或带插件167 KB'
- en: '**Standard compliance**: ES 2015'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准合规性**：ES 2015'
- en: '**Non-compliant**: JSX'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不合规**：JSX'
- en: '**Interoperability**: High friction'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：高摩擦'
- en: Dependency injection
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: There is no such dependency injection concept in React.js.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: React.js中没有这样的依赖注入概念。
- en: Component encapsulation
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件封装
- en: 'A component is *one* JS class. Do you want to include another component in
    your component? Just import it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件就是一个JS类。你想要在你的组件中包含另一个组件吗？只需导入它：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Aurelia
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia
- en: Aurelia is a new JavaScript framework created by one of the team members of
    Angular 2 project. Different from Angular, Aurelia is composed of a collection
    of libraries that work together using well-defined interfaces so that it’s completely
    modular. This means that a web application only needs to include the dependencies
    that it needs, not the complete bundle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia是由Angular 2项目团队成员之一创建的新JavaScript框架。与Angular不同，Aurelia由一组库组成，这些库通过定义良好的接口协同工作，使其完全模块化。这意味着一个Web应用只需要包含它需要的依赖项，而不是完整的包。
- en: Aurelia's APIs are carefully designed to be consumed naturally by both today's
    and tomorrow's most useful web programming languages. Aurelia supports ES5, ES2015,
    ES2016, and Typescript, which are very helpful and give you high flexibility.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia的API被精心设计，以便自然地被今天和明天最有用的Web编程语言所消费。Aurelia支持ES5、ES2015、ES2016和TypeScript，这些都非常有用，并为你提供了高度的灵活性。
- en: Furthermore, writing web applications using ES6 is not a new thing. In fact,
    there are many solutions out there that can allow you to write Angular apps using
    ES6 (you need to configure it manually and it's not included in the default Angular
    configuration).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用ES6编写Web应用并不是什么新鲜事。实际上，有许多解决方案可以让你使用ES6编写Angular应用（你需要手动配置它，并且它不包括在默认的Angular配置中）。
- en: You don't need to worry about special framework concepts or syntax; Aurelia
    is a *convention over configuration* framework, encouraging you to use good practices
    when developing applications, and it allows the developers to focus only on business
    code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需担心特殊的框架概念或语法；Aurelia 是一个*约定优于配置*的框架，鼓励你在开发应用程序时使用良好的实践，并且它允许开发者只关注业务代码。
- en: Technical information
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术信息
- en: '**Size**: 252 kb minimum, 302 kb with standard plugin'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：最小 252 kb，带标准插件为 302 kb'
- en: '**Standard compliance**: HTML, ES 2016, Web Components (including the Shadow
    DOM)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准兼容性**：HTML、ES 2016、Web Components（包括 Shadow DOM）'
- en: '**Interoperability**: Very interoperable'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：非常互操作'
- en: Dependency injection
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'All you need is the `@autoinject` annotation. The JS/HTML mapping is performed
    automatically by the framework:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需的一切就是 `@autoinject` 注解。JS/HTML 映射将由框架自动执行：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For `Typescript` users, the annotation names are very similar. Use `@autoinject`
    instead of `@inject` and don''t forget to specify the visibility and type of object
    in the constructor : `constructor(private ticket : Ticket)`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `Typescript` 用户，注解名称非常相似。使用 `@autoinject` 而不是 `@inject`，并且不要忘记在构造函数中指定对象的可见性和类型：`constructor(private
    ticket : Ticket)`'
- en: Component encapsulation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件封装
- en: 'Component encapsulation uses a separate template file that looks more or less
    like every other web templating language you''ve ever used. By convention, if
    your component class is in `hello.ts`, then its template is in `hello.html` and
    your component will be `<hello/>`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 组件封装使用一个看起来或多或少像你曾经使用过的任何其他 Web 模板语言的单独模板文件。按照惯例，如果你的组件类在 `hello.ts` 中，那么它的模板就在
    `hello.html` 中，你的组件将是 `<hello/>`：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each JavaScript framework has its own way of working, and we can explore more
    features about each one, but Aurelia has something special—you don't need to go
    far away from learning how the framework works, and in extreme cases, in their
    own way/syntax for developing. With Aurelia, you will feel like writing plain
    JavaScript and HTML code, highly maintainable, scalable, and focusing only on
    your business purposes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 JavaScript 框架都有其自己的工作方式，我们可以探索每个框架的更多功能，但 Aurelia 有其独特之处——你无需远离学习框架的工作方式，在极端情况下，以它们自己的方式/语法进行开发。使用
    Aurelia，你将感觉像是在编写纯 JavaScript 和 HTML 代码，高度可维护、可扩展，并且只关注你的业务目标。
- en: Now it's time to start working with Aurelia. So, let's explore the Aurelia command
    line to start our trip. Keep reading!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始使用 Aurelia 了。所以，让我们探索 Aurelia 命令行，开始我们的旅程。继续阅读！
- en: Aurelia command-line tool
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia 命令行工具
- en: There are many ways to create an Aurelia project. For this book, we will use
    the official Aurelia command-line tool, which is supported by the Aurelia team.
    Although there are other options to configure your Aurelia application, such as
    Webpack and JSPM, we consider that the CLI is powerful and will help us save valuable
    time configuring our application skeleton and build tools.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Aurelia 项目有许多方法。对于本书，我们将使用官方的 Aurelia 命令行工具，它由 Aurelia 团队支持。尽管有其他选项可以配置你的
    Aurelia 应用程序，例如 Webpack 和 JSPM，但我们认为 CLI 功能强大，将帮助我们节省宝贵的配置应用程序骨架和构建工具的时间。
- en: In this section, we will explore in detail the CLI capabilities, and you will
    convince yourself that this is the best option for our adventure. After this section,
    you will be a master in using the Aurelia CLI.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细探讨 CLI 的功能，并且你会自己信服这确实是我们的冒险的最佳选择。在本节之后，你将成为使用 Aurelia CLI 的专家。
- en: Installation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing the CLI is not a big deal if you have installed Node.js in the previous
    section. We just need to open your favorite Terminal and execute the following
    command, and if you are using a Unix-based operating system, remember to add `sudo`
    before the command if you have permission issues:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在上一节中已经安装了 Node.js，那么安装 CLI 并不是什么大问题。我们只需要打开你最喜欢的终端，并执行以下命令；如果你使用的是基于 Unix
    的操作系统，记得如果你有权限问题，在命令前添加 `sudo`：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding command will install the Aurelia CLI as a global executable command-line
    tool. This allows us to use the CLI with the `au` command as any other command
    of our operative system Terminal, for example, the `dir` command.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将安装 Aurelia CLI 作为全局的可执行命令行工具。这允许我们使用 `au` 命令，就像使用操作系统的终端中的任何其他命令一样，例如
    `dir` 命令。
- en: 'After the installation is complete, execute the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，执行以下命令：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should return the following output that displays the CLI help. As you
    can see, this command has two main options:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下输出，显示 CLI 帮助。正如你所见，这个命令有两个主要选项：
- en: '![](img/d0a072b5-e86d-4b18-9703-b838a3f376bc.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0a072b5-e86d-4b18-9703-b838a3f376bc.png)'
- en: Now that we are sure that it is working as we expected, let's learn how to get
    the most out of it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信它按预期工作，让我们学习如何充分利用它。
- en: Creating a new application
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新应用程序
- en: This is one of the most important options. As its name says, it will create
    a new Aurelia application with a well-defined application folder structure and
    all the initial configuration files in just three steps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的选项之一。正如其名称所示，它将通过三个步骤创建一个具有良好定义的应用程序文件夹结构和所有初始配置文件的新 Aurelia 应用程序。
- en: 'Execute the following command and replace `my-app` with your application''s
    name:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令，并将 `my-app` 替换为你的应用程序名称：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When the Aurelia CLI wizard is running, we will select the following options
    to create our application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Aurelia CLI 向导运行时，我们将选择以下选项来创建我们的应用程序：
- en: Select `1` for ECMAScript next generation language
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `1` 以选择 ECMAScript 新一代语言
- en: Select `1` to create the project
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `1` 以创建项目
- en: Select `1` to install the dependencies
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `1` 以安装依赖项
- en: 'Once you answer the last question, the CLI will install all the dependencies
    and once everything is complete, you will see the following output in your Terminal
    window:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你回答了最后一个问题，CLI 将会安装所有依赖，一旦一切完成，你将在你的终端窗口看到以下输出：
- en: '![](img/5622f4ca-8706-40b8-a6f9-7469d9317136.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5622f4ca-8706-40b8-a6f9-7469d9317136.png)'
- en: Running our Application
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: Next, we will look into the run option. This option allows us to run our application,
    and it provides us with an option to create a productive development environment
    by specifying the `--watch` option, which configures a watcher to detect changes
    in our source code and update our browser automatically. This cool feature is
    known as browser-sync or auto-refresh.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看运行选项。此选项允许我们运行应用程序，并提供一个选项，通过指定 `--watch` 选项来创建一个生产性开发环境，该选项配置了一个监视器来检测源代码中的更改并自动更新浏览器。这个酷炫的功能被称为浏览器同步或自动刷新。
- en: 'The `run` command also allows us to specify the environment where we want to
    execute our application; these are the default environments: `dev`, `stage`, and
    `prod`. By default, the CLI will run our application using the `dev` environment.
    Use the `--env` flag to change it.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 命令还允许我们指定我们想要执行应用程序的环境；这些是默认环境：`dev`、`stage` 和 `prod`。默认情况下，CLI 将使用 `dev`
    环境运行我们的应用程序。使用 `--env` 标志来更改它。'
- en: What means exactly each environment? Well, in software development, commonly
    when you are writing your application you test your code on you local development
    environment (`dev`). Once you think its complete, you send it to a Quality Assurance
    area to test your application, this tests won't be performed on your machine so
    you need to export your application and deploy it on another server, it will be
    called the `test` environment. Finally, once the QA people gives his approval,
    you code will be deployed in the real world environment (`prod`). Of course, this
    is a very basic scope, you will find many more environments in other companies
    such UAT (User Acceptance Test).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境究竟意味着什么？在软件开发中，通常当你编写应用程序时，你会在本地开发环境中测试你的代码（`dev`）。一旦你认为它已经完成，你将其发送到质量保证区域进行测试，这些测试不会在你的机器上执行，因此你需要导出你的应用程序并将其部署到另一台服务器上，这将被称为
    `test` 环境。最后，一旦 QA 人员批准，你的代码将部署到真实世界的环境（`prod`）。当然，这是一个非常基本的范围，你将在其他公司找到更多环境，如
    UAT（用户验收测试）。
- en: 'For example, let''s get into our application (`cd` command) and execute the
    following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们进入我们的应用程序（使用 `cd` 命令）并执行以下命令：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the output that has two URLs where we can see our application
    up and running:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在两个 URL 中可以看到我们的应用程序正在运行并运行的输出：
- en: '![](img/19dc38ec-7abb-4250-98fe-2c8273cbb356.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19dc38ec-7abb-4250-98fe-2c8273cbb356.png)'
- en: 'Open the `http://localhost:9000` URL in your favorite web browser, and you
    should see the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在你喜欢的网络浏览器中打开 `http://localhost:9000` URL，你应该会看到以下内容：
- en: '![](img/c558fe0a-93b8-43b0-b679-082b8b5c2c1a.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c558fe0a-93b8-43b0-b679-082b8b5c2c1a.png)'
- en: Pay attention to the last two lines in the console. Those tell you in which
    port is running your application, it could be different depending on your operating
    system and which port you have available.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意控制台中的最后两行。这些行告诉你应用程序正在哪个端口上运行，这可能会根据你的操作系统和可用的端口而有所不同。
- en: Now, let's test how auto-refresh works, remember that this feature is enabled
    by adding the `--watch` option in the `au run` command.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下自动刷新功能，记住这个功能是通过在 `au run` 命令中添加 `--watch` 选项来启用的。
- en: 'Open the `app.js` file located in the `src` folder and change the `''Hello
    World!''` string to `''Hola Mundo!''`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`src`文件夹中的`app.js`文件，将`'Hello World!'`字符串更改为`'Hola Mundo!'`：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save it and go back to your browser; the CLI will detect the change you made
    in the `app.js` file and will refresh your browser automatically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 保存它并回到您的浏览器；CLI将检测您在`app.js`文件中做出的更改，并将自动刷新您的浏览器。
- en: To be more productive, you can use two displays—the first with your application
    running in the browser and the second with your source code editor.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，您可以使用两个显示器——一个用于在浏览器中运行应用程序，另一个用于源代码编辑器。
- en: Testing our application
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的应用程序
- en: Of course, testing is an important skill all developers need to have. We have
    a complete chapter to talk about testing and discuss TDD, unit testing, and end-to-end
    testing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试是所有开发者都需要掌握的重要技能。我们有一个完整的章节来讨论测试，并讨论TDD、单元测试和端到端测试。
- en: The test command comes with the `--watch` and the `--env` flags. Use the watch
    option to tell the CLI to detect changes in the `test` folder and execute the
    tests again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命令带有`--watch`和`--env`标志。使用watch选项告诉CLI检测`test`文件夹中的更改并再次执行测试。
- en: In order to run tests, the CLI uses Karma, which is a test runner technology
    that is configured to use Jasmine testing framework to write all our testing files
    that should be saved into the `test` folder.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行测试，CLI使用Karma，这是一个配置为使用Jasmine测试框架来编写所有应该保存在`test`文件夹中的测试文件的测试运行器技术。
- en: 'For example, the preceding command will run the `app.sec.js` file located in
    the `test/unit` folder:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的命令将运行位于`test/unit`文件夹中的`app.sec.js`文件：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the output that has executed one test successfully:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个测试成功执行后的输出结果：
- en: '![](img/023c5016-8482-44b2-ab42-2b7a2ed9d94b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/023c5016-8482-44b2-ab42-2b7a2ed9d94b.png)'
- en: Building our application
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的应用程序
- en: Now is the time to deploy our application, but before we do this, we need to
    compress and minify our Aurelia code. Aurelia CLI provides us with the build option
    to generate these ready-to-deploy files that contain all our application code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是部署我们的应用程序的时候了，但在我们这样做之前，我们需要压缩和精简我们的Aurelia代码。Aurelia CLI为我们提供了构建选项，以生成包含所有应用程序代码的、准备就绪的部署文件。
- en: 'As you might want to build your application for different environments (`dev`,
    `stage`, or `prod`), this build option comes along with the `--env` flag. For
    example, execute the following command in your project:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可能想要为不同的环境（`dev`、`stage`或`prod`）构建应用程序，这个构建选项还带有`--env`标志。例如，在您的项目中执行以下命令：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is a sample output of `my-app` project:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`my-app`项目的示例输出：
- en: '![](img/b4eb79cc-8b18-485e-8b7e-0b59b4b3a63d.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4eb79cc-8b18-485e-8b7e-0b59b4b3a63d.png)'
- en: 'As the output shows, there are two main files generated: `app-bundle.js`, which
    contains our application logic and `vendor-bundle.js`, which contains third-party
    dependencies. These two files are generated into the `scripts` folder in our root
    application folder.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，生成了两个主要文件：`app-bundle.js`，其中包含我们的应用程序逻辑，以及`vendor-bundle.js`，其中包含第三方依赖项。这两个文件被生成到我们的根应用程序文件夹中的`scripts`文件夹。
- en: 'If you want to run your application and check whether everything is okay with
    the bundles you recently created, let''s install the `http-server` module using
    `npm`. Run the following command in your Terminal:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想运行您的应用程序并检查您最近创建的打包文件是否一切正常，让我们使用`npm`安装`http-server`模块。在您的终端中运行以下命令：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, create a `dist` folder in your application root folder and copy the `index.html`
    page and the `scripts` folder that contain our bundles.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的应用程序根文件夹中创建一个`dist`文件夹，并将`index.html`页面和包含我们的打包文件的`scripts`文件夹复制进去。
- en: '![](img/ed491977-216f-4e7e-8ce1-40ccf419150f.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed491977-216f-4e7e-8ce1-40ccf419150f.png)'
- en: 'For the last step, get into the `dist` folder in your Terminal and run the
    following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，在终端中进入`dist`文件夹，并运行以下命令：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Use the `cd` command to navigate across your folders in your Terminal.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cd`命令在您的终端中导航到您的文件夹。
- en: 'This command will expose some four URLs where the web server is running; copy
    the first URL and open it on your web browser, and you should see your application
    up and running:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将暴露一些四个URL，其中Web服务器正在运行；复制第一个URL并在您的网络浏览器中打开它，您应该会看到您的应用程序正在运行：
- en: '![](img/2f0fc693-35f5-4383-8d6f-69f6809c9e6c.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f0fc693-35f5-4383-8d6f-69f6809c9e6c.png)'
- en: Generating custom resources
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成自定义资源
- en: Aurelia, like many JavaScript frameworks, allows you to create reusable components
    that help you avoid writing duplicated code, reuse your component in multiple
    parts of your app, and also export them as plugins to reuse them in other projects.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia，像许多JavaScript框架一样，允许你创建可重用的组件，这有助于你避免编写重复的代码，在应用程序的多个部分中重用你的组件，并且可以将它们作为插件导出以在其他项目中重用。
- en: 'Aurelia allows you to generate the reusable pieces of code utilizing the following
    templates:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia允许你使用以下模板生成可重用的代码片段：
- en: Components
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Custom elements
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: Custom attributes
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性
- en: Binding-behaviors
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定行为
- en: Value-converters
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换器
- en: 'These templates are all located in our project root folder in the `aurelia_project/generators`
    folder. For example, the following command generates a custom Aurelia element:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板都位于我们的项目根目录中的`aurelia_project/generators`文件夹中。例如，以下命令生成一个自定义Aurelia元素：
- en: '[PRE42]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The source code will be generated in the `src/resources/{type}` folder depending
    on the **type** you selected.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的**类型**，源代码将在`src/resources/{type}`文件夹中生成。
- en: Each type will be discussed in the following chapters, so don't feel bad if
    you don't understand the differences between them. Keep reading my friend! :)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型将在接下来的章节中进行讨论，所以如果你不理解它们之间的区别，请不要感到难过。继续阅读，我的朋友！ :)
- en: World Cup app overview
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界杯应用程序概述
- en: 'Now it is time to talk about our application we will build together. Apart
    from our web application written, of course, in Aurelia, we also need a backend
    service to persist our data. For the backend service, we will be using Node.js
    with the Express framework to build a robust API and MongoDB as our non-relational
    data storage. The following diagram explains our World Cup project architecture:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论我们将一起构建的应用程序了。当然，除了我们用Aurelia编写的Web应用程序外，我们还需要一个后端服务来持久化我们的数据。对于后端服务，我们将使用Node.js和Express框架来构建一个健壮的API，以及MongoDB作为我们的非关系型数据存储。以下图表解释了我们的世界杯项目架构：
- en: '![](img/d3e73934-0c97-4d34-9899-29018c24ebeb.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3e73934-0c97-4d34-9899-29018c24ebeb.png)'
- en: This a very simple architecture; the Aurelia app talks to the Node API directly,
    and the Node API talks to the database, which is a MongoDB database, using a very
    popular open source library called Mongoose. This is getting better; keep reading!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的架构；Aurelia应用程序直接与Node API通信，Node API与数据库通信，该数据库是一个MongoDB数据库，使用一个非常流行的开源库Mongoose。这会变得更好；继续阅读！
- en: Exploring the application features
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索应用程序特性
- en: The app we will develop is the Football World Cup app. We will use an awesome
    UI framework called Materialize, which, by default, will help us create a responsive
    web application, so our users can open this app in their mobile and desktop browser
    with an adaptable user interface.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的应用程序是足球世界杯应用程序。我们将使用一个名为Materialize的出色UI框架，默认情况下，它将帮助我们创建一个响应式Web应用程序，因此我们的用户可以在他们的移动和桌面浏览器中打开这个应用程序，并拥有可适应的用户界面。
- en: 'Although this is a simple application, we will cover the most important concepts
    of Aurelia that you will find in a real production application. We will improve
    this app along with the book. Listed are the features we will develop for this
    app:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的应用程序，但我们将涵盖Aurelia在真实生产应用程序中最重要的一些概念。我们将随着书籍的进展来改进这个应用程序。以下是我们将为这个应用程序开发的特性列表：
- en: Matches explorer
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛资源管理器
- en: Teams explorer
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队资源管理器
- en: News
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新闻
- en: Admin portal
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员门户
- en: Social authentication
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交认证
- en: So, let's start exploring the features that this application delivers to our
    users.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始探索这个应用程序提供给用户的功能。
- en: Matches explorer
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比赛资源管理器
- en: 'This feature is related to the matches in the entire competition. The users
    will be able to perform the following actions:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性与整个竞赛中的比赛相关。用户将能够执行以下操作：
- en: List the Matches activity
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出比赛活动
- en: Create a new Match, which requires admin
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的比赛，需要管理员权限
- en: Listing the matches
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出比赛
- en: 'The user will see the list of matches represented as cards. A calendar is shown
    to the user to navigate and see the matches scheduled per day. The mock-up is
    shown here:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到以卡片形式表示的比赛列表。向用户展示一个日历来导航并查看按天安排的比赛。原型如下所示：
- en: '![](img/c4a4b456-80df-4fd3-83e5-0fd0c82258cd.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4a4b456-80df-4fd3-83e5-0fd0c82258cd.png)'
- en: Creating a new Match
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的比赛
- en: 'To create a new Match, an admin account is required. Once the user is authenticated,
    they can schedule a new Match by selecting the teams and the time. The mock-up
    is shown as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的比赛，需要一个管理员账户。一旦用户认证成功，他们可以通过选择队伍和时间来安排新的比赛。原型如下所示：
- en: '![](img/a030e940-a579-431d-be78-3cb1e848e5fc.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a030e940-a579-431d-be78-3cb1e848e5fc.png)'
- en: Teams explorer
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队资源管理器
- en: 'This feature is related to the matches in the entire competition. The users
    will be able to perform the following actions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能与整个比赛中的比赛相关。用户将能够执行以下操作：
- en: List the Teams
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出团队
- en: Create a new Team, which requires admin
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的团队，这需要管理员权限
- en: Listing the teams
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出团队
- en: 'The user will see the list of teams represented as cards. The mock-up is as
    follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到以卡片形式表示的团队列表。原型如下：
- en: '![](img/229c7f42-2bc3-41b3-a4b5-2d2fd936ee20.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/229c7f42-2bc3-41b3-a4b5-2d2fd936ee20.png)'
- en: Creating a new team
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的团队
- en: 'To create a new Team, an admin account is required. Once the user is authenticated,
    they can create a new team. The mock-up is this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的团队，需要一个管理员账户。一旦用户验证通过，他们就可以创建一个新的团队。原型如下：
- en: '![](img/68d4aa16-d1ac-4a98-870b-dadec78660d2.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68d4aa16-d1ac-4a98-870b-dadec78660d2.png)'
- en: News
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新闻
- en: 'This feature is related to the news. The users will be able to perform the
    following actions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能与新闻相关。用户将能够执行以下操作：
- en: List the News
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出新闻
- en: Create a New item, which requires admin
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，这需要管理员权限
- en: Listing the News
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出新闻
- en: 'The user will see the list of news represented as cards. The mock-up is as
    shown:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到以卡片形式表示的新闻列表。原型如下：
- en: '![](img/813597ca-09d7-45fc-875b-5261b16bf067.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/813597ca-09d7-45fc-875b-5261b16bf067.png)'
- en: Create a New
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的
- en: 'To create a New, an admin account is required. Once the user is authenticated,
    they can create a New. The mock-up is this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的团队，需要一个管理员账户。一旦用户验证通过，他们就可以创建一个新的团队。原型如下：
- en: '![](img/af6d1b9c-108a-42f7-ad5a-fe10ef1307b2.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af6d1b9c-108a-42f7-ad5a-fe10ef1307b2.png)'
- en: Social authentication
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交认证
- en: 'The user will be able to sign in using their Google or Facebook account. The
    mock-up is this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够使用他们的Google或Facebook账户登录。原型如下：
- en: '![](img/3766eb38-8903-4d95-9749-038ad863dba7.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3766eb38-8903-4d95-9749-038ad863dba7.png)'
- en: Now that we have an idea of the application we will develop, let's continue
    creating the initial application project.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对我们的开发应用程序有了想法，让我们继续创建初始应用程序项目。
- en: Creating our app
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'Let''s start creating our application. If you remember our last section about
    the Aurelia CLI, we need to use it again to create a new application, so open
    your favorite Terminal tool and execute the following command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的应用程序。如果您还记得我们关于Aurelia CLI的最后一节，我们需要再次使用它来创建一个新的应用程序，所以打开您最喜欢的终端工具并执行以下命令：
- en: '[PRE43]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Enter the following input in the Terminal:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入以下输入：
- en: Select `3` to define our custom options for this project
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`3`以定义此项目的自定义选项
- en: 'First option: `Which module loader / bundler would you like to use? RequireJS
    (Default)`'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个选项：`您想使用哪个模块加载器/打包器？ RequireJS（默认）`
- en: 'Second option: `What transpiler would you like to use? : Babel (Default)`'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第二个选项：`您想使用哪个转译器？ : Babel（默认）`'
- en: 'Third option: `How would you like to setup your template? : Default` (`No markup
    processing`.)'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第三个选项：`您想如何设置模板？ : 默认（无标记处理。）`'
- en: Fourth option: `What CSS processor would you like to use?` In this case, we
    will choose `Sass` (`3`)
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个选项：`您想使用什么CSS处理器？`在这种情况下，我们将选择`Sass`（`3`）
- en: Fifth option: `Would you like to configure unit testing?` Of course, we will
    mark `Yes (Default)`
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五个选项：`您想配置单元测试吗？`当然，我们将标记为`是（默认）`
- en: Sixth option: `What is your default code editor?` We use WebStorm, but you can
    choose the most familiar to you.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第六个选项：`您的默认代码编辑器是什么？`我们使用WebStorm，但您可以选择您最熟悉的。
- en: 'Now, you will see the main structure of your application on the console:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将在控制台上看到您应用程序的主要结构：
- en: '[PRE44]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, select  `1` to create the project and then install the project dependencies
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择`1`以创建项目并安装项目依赖项
- en: 'This is a custom setup. Our project will be composed with the following features:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义设置。我们的项目将由以下功能组成：
- en: '**RequireJS**: Well known file and module loader, with a good browser support.
    Another option could be SystemJS and Webpack.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RequireJS**：广为人知的文件和模块加载器，具有良好的浏览器支持。另一个选项可以是SystemJS和Webpack。'
- en: '**Babel**: Babel is one of the most used *transpilation* tools nowadays. A
    `transpiler` is a tool that transforms code written in JavaScript ES6 syntax or
    later into ES5 code. Why? Because most of the browsers does not have well supported
    yet the last JavaScript version.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel**：Babel是目前最常用的*转译*工具之一。`转译器`是一种将JavaScript ES6语法或更高版本的代码转换为ES5代码的工具。为什么？因为大多数浏览器还没有很好地支持最新的JavaScript版本。'
- en: '**Markup processing**: It loads our modules and create the final files which
    will be interpreted by the browser. We won''t use a custom markup processing in
    this stage.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记处理**：它加载我们的模块并创建最终文件，这些文件将被浏览器解释。在这个阶段，我们不会使用自定义的标记处理。'
- en: '**SASS**: A nice preprocessor CSS library, we will review it at more detail
    in the next chapter.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SASS**：一个很好的预处理器 CSS 库，我们将在下一章中更详细地回顾它。'
- en: '**Karma**: A JavaScript test library. We will talk about it in more detail
    in the  Chapter 3, *Testing and Debugging*.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：一个 JavaScript 测试库。我们将在第 3 章 *测试和调试* 中更详细地讨论它。'
- en: '**WebStorm**: A very nice IDE for JavaScript developers. It is not free but
    if you have an educational email account from your university or institute, you
    can get a student license for one year.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：一个非常适合 JavaScript 开发的 IDE。虽然它不是免费的，但如果你有来自你大学或机构的官方教育邮箱，你可以获得一年的学生许可证。'
- en: Once everything is done, open the `worldcup-app` folder with your favorite editor.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，用你最喜欢的编辑器打开 `worldcup-app` 文件夹。
- en: We know Webpack is a very awesome module loader, but for learning purposes,
    we prefer to use RequireJS across all this book because is more simple and let
    us explain better how to configure manually  each tool and library we will use
    in this book.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Webpack 是一个非常出色的模块加载器，但出于学习目的，我们更愿意在整个这本书中使用 RequireJS，因为它更简单，并让我们更好地解释如何手动配置我们将在这本书中使用的每个工具和库。
- en: The project structure
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: The Aurelia CLI will generate the source code with its base structure, which
    has everything configured and ready to start writing our application's source
    code.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia CLI 将生成带有其基本结构的源代码，其中所有配置都已就绪，可以开始编写应用程序的源代码。
- en: 'The following screenshot shows the root application folder:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了根应用程序文件夹：
- en: '![](img/66864749-292f-4edf-9ba5-c6aa06196762.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66864749-292f-4edf-9ba5-c6aa06196762.png)'
- en: Let's start talking about the `aurelia_project` folder, which contains the main
    `aurelia.json` configuration file with all the settings about the dependencies,
    blunder, build target, loaders, testing run-time tool such as Karma, testing framework,
    and more. You will modify this file frequently to specify new dependencies our
    application needs to use.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论 `aurelia_project` 文件夹，它包含主要的 `aurelia.json` 配置文件，其中包含所有关于依赖项、错误处理、构建目标、加载器、测试运行时工具（如
    Karma）、测试框架等设置。你将经常修改此文件以指定应用程序需要使用的新依赖项。
- en: 'The next element in the `aurelia_folder` is the `environments` folder, which
    contains three files: `dev.json`, `stage.json`, and `prod.json`. These files contain
    values depending on the environment you are running on. Do you remember the `--env`
    flag in the run option? The CLI will use one of these files to configure our app''s
    environmental values.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`aurelia_folder` 中的下一个元素是 `environments` 文件夹，其中包含三个文件：`dev.json`、`stage.json`
    和 `prod.json`。这些文件包含的值取决于你正在运行的环境。你还记得运行选项中的 `--env` 标志吗？CLI 将使用这些文件之一来配置我们应用程序的环境值。'
- en: The remaining two folders are `generators` and `tasks`. They are used to generate
    Aurelia custom reusable components and to declare gulp tasks, respectively.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个文件夹是 `generators` 和 `tasks`。它们分别用于生成 Aurelia 自定义可重用组件和声明 gulp 任务。
- en: The `scripts` folder contains the bundles generated after we execute the `au
    build` command.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts` 文件夹包含执行 `au build` 命令后生成的捆绑包。'
- en: As you might guess, the `src` folder contains our application source code, followed
    by the `test` folder, which contains our source code to test our project.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`src` 文件夹包含我们的应用程序源代码，接着是 `test` 文件夹，其中包含测试我们项目的源代码。
- en: The Bootstrap process
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导过程
- en: 'Like many JavaScript frameworks such as Angular and React, Aurelia needs a
    place in the `index.html` page to mount the application. This place is known as
    the entry point. Open the `index.html` file, and you should see something similar
    to the following code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多 JavaScript 框架（如 Angular 和 React）一样，Aurelia 需要 `index.html` 页面中的一个位置来挂载应用程序。这个位置被称为入口点。打开
    `index.html` 文件，你应该会看到以下代码类似的内容：
- en: '[PRE45]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Aurelia requires an HTML element to load our application. By default, the application
    is loaded in the `body` element; we know this because this element uses the `aurelia-app`
    attribute, which is used to specify the main JavaScript script file that contains
    all the configuration for our application, and as you note, by default, Aurelia
    is configured to use the `main` file. The following is the content of the `main.js`
    file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia需要一个HTML元素来加载我们的应用程序。默认情况下，应用程序是在`body`元素中加载的；我们知道这一点是因为这个元素使用了`aurelia-app`属性，该属性用于指定包含我们应用程序所有配置的主JavaScript脚本文件，正如你所注意到的，默认情况下，Aurelia被配置为使用`main`文件。以下`main.js`文件的内容：
- en: '[PRE46]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's analyze this file; the first line imports the environment variables from
    the `environment.js` file located in the root folder. When you specify the `--flag`
    `{env}` option, the CLI looks for the `{env}.json` file in the `aurelia_project`
    folder and copies its content into the `environment.js` file.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个文件；第一行从根文件夹中的`environment.js`文件导入环境变量。当您指定`--flag` `{env}`选项时，CLI会在`aurelia_project`文件夹中查找`{env}.json`文件，并将其内容复制到`environment.js`文件中。
- en: This file also exports a single **`configure`** function, which receives as
    a parameter the `aurelia` object that you use to override default configurations
    and add any code you wish before the app is launched. For example, you can tell
    Aurelia that you want to declare components as global (features), configure internationalization
    to manage different languages, and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件还导出单个**`configure`**函数，该函数接收一个参数，即`aurelia`对象，您可以使用它来覆盖默认配置并在应用程序启动之前添加任何代码。例如，您可以告诉Aurelia您希望声明组件为全局（功能），配置国际化以管理不同语言等。
- en: 'Once the `aurelia` object is configured, the last line of code will render
    our application into the root HTML element, which has the `aurelia-app` attribute
    in the `index.html` page. By default, it renders the `app.js` component into the
    root element. Of course, we can override the default values by passing the element
    you wish to render as the first parameter and the HTML element where you wish
    to render the app as a second parameter:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了`aurelia`对象，代码的最后一行将把我们的应用程序渲染到具有`aurelia-app`属性的根HTML元素中，在`index.html`页面中。默认情况下，它将`app.js`组件渲染到根元素中。当然，我们可以通过传递您希望渲染的元素作为第一个参数，以及您希望渲染应用程序的HTML元素作为第二个参数来覆盖默认值：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will be modifying this file along the way; the most important thing to remember
    is that this file is processed before the app is rendered and apart from the `Aurelia.json`
    file, this is the second most important file. The following diagram explains the
    bootstrapping process:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在过程中修改这个文件；需要记住的最重要的事情是，这个文件在应用程序渲染之前被处理，除了`Aurelia.json`文件外，这是第二个最重要的文件。以下图表解释了引导过程：
- en: '![](img/97a04ff3-773c-427b-8129-0b833ccfb369.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97a04ff3-773c-427b-8129-0b833ccfb369.png)'
- en: Now you know how the bootstrapping process works. Let's understand how you can
    create reusable components.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了引导过程是如何工作的。让我们了解如何创建可重用的组件。
- en: Understanding components
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件
- en: In the last section, we saw that Aurelia requires a component to mount as the
    root of our entire application and by default, it was the app component. Now let's
    explore this component.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们了解到Aurelia需要一个组件作为我们整个应用程序的根组件，默认情况下，它是应用程序组件。现在让我们来探索这个组件。
- en: 'A **component** is composed of two files, the first written in JavaScript that
    contains the component''s view model and the second one is the markup template
    written in HTML. They must have the same filename to help the view model resolve
    its view template. The component''s view model is a JavaScript file, which exports
    a class that contains the component''s attributes and functions. For example,
    this is the content of the `app.js` component:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**由两个文件组成，第一个是用JavaScript编写的，包含组件的视图模型，第二个是用HTML编写的标记模板。它们必须具有相同的文件名，以帮助视图模型解析其视图模板。组件的视图模型是一个JavaScript文件，它导出一个包含组件属性和函数的类。例如，这是`app.js`组件的内容：'
- en: '[PRE48]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `App` class declares a constructor that initializes the `message` property.
    Properties can be declared into the `constructor` or can be defined outside of
    it. Consider this example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`类声明了一个构造函数，用于初始化`message`属性。属性可以在`constructor`中声明，也可以在它之外定义。考虑以下示例：'
- en: '[PRE49]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Use the outside property declaration style when you are declaring simple classes
    such as **Plain Old CLR Objects** (**POCO**), which now implements more logic
    than simply get and set its property values.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明简单的类，如 **Plain Old CLR Objects** （**POCO**），现在它实现的功能不仅仅是获取和设置其属性值时，使用外部属性声明风格。
- en: 'To use the properties defined in our `app.js` view model, we need an HTML template
    with the same filename. Open the `app.html` file to see its content:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用在 `app.js` 视图模型中定义的属性，我们需要一个具有相同文件名的 HTML 模板。打开 `app.html` 文件以查看其内容：
- en: '[PRE50]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first thing to note is that the `message` property declared in the view
    model is present, but in order to bind the value, we have to use the `${}` string
    interpolation operator. Finally, when Aurelia renders the component in the web
    page, the `${message}` declaration will be replaced by `'Hello World!'`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，在视图模型中声明的 `message` 属性是存在的，但为了绑定值，我们必须使用 `${}` 字符串插值运算符。最后，当 Aurelia
    在网页中渲染组件时，`${message}` 声明将被 `'Hello World!'` 替换。
- en: 'We can extend our components by adding functions that can be called from the
    template. For example, let''s declare the `changeMessage()` function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加可以从模板中调用的函数来扩展我们的组件。例如，让我们声明 `changeMessage()` 函数：
- en: '[PRE51]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: From the preceding code, you can see how declaring a function is a simple; we
    use the same syntax of the `contructor` declaration. If you want to use the properties
    declared in the `App` class, you have to use the `this` reserved word to access
    any property or function.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以看到声明一个函数是多么简单；我们使用与 `constructor` 声明相同的语法。如果你想使用在 `App` 类中声明的属性，你必须使用
    `this` 保留字来访问任何属性或函数。
- en: 'Now it is time to invoke our `changeMessage` function. First, we will create
    a button in our template in the `app.html` file and declare a trigger to the `click`
    event of the button. Open the `app.html` file and apply the following changes:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调用我们的 `changeMessage` 函数了。首先，我们将在 `app.html` 文件中的模板中创建一个按钮，并声明一个触发器到按钮的
    `click` 事件。打开 `app.html` 文件并应用以下更改：
- en: '[PRE52]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first thing to note here is that we don't use the default HTML `onclick`
    event; instead, we use the `click` event with no `on` at the start of the event
    name. This convention is used only for the Aurelia templating engine. So, we say
    that we want to invoke the `changeMessage()` functions by binding this function
    to the `click` event using the `trigger` binding mechanism.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的第一件事是我们没有使用默认的 HTML `onclick` 事件；相反，我们使用没有 `on` 开头的 `click` 事件。这个约定仅用于
    Aurelia 模板引擎。因此，我们说我们想要通过将此函数绑定到 `click` 事件来调用 `changeMessage()` 函数，使用 `trigger`
    绑定机制。
- en: Launch your app by executing the `au run` command in your Terminal, and test
    this out. When you click on the Change button, you should see how the message
    is changed from `'Hello World!'` to `'World-Cup' App`. The `h1` HTML element is
    changed because we have previously declared and bound the `${message}` property
    into its content.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中执行 `au run` 命令来启动你的应用程序，并测试一下。当你点击“更改”按钮时，你应该看到消息从 `'Hello World!'` 更改为
    `'World-Cup' App'`。`h1` HTML 元素发生了变化，因为我们之前已经将 `${message}` 属性声明并绑定到其内容中。
- en: Binding is a big concept we will cover in next chapters in a more detailed way. So,
    keep reading my friend, it just starting.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是一个我们在下一章中将更详细地讨论的大概念。所以，继续阅读吧，朋友，这才刚刚开始。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how Aurelia is different from other popular frameworks;
    we compared Aurelia to ReactJS and Angular. We saw that Aurelia is more lightweight
    and has better performance, but the most important thing is that Aurelia is based
    on the ECMAScript 6 standard. So, instead of learning a framework, with Aurelia,
    you are learning an International Standard.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Aurelia 与其他流行框架的不同之处；我们将 Aurelia 与 ReactJS 和 Angular 进行了比较。我们看到 Aurelia
    更轻量级，性能更好，但最重要的是，Aurelia 基于 ECMAScript 6 标准。因此，与其学习一个框架，不如使用 Aurelia 学习一个国际标准。
- en: Also, we installed NodeJS and the NPM; these two open source technologies are
    extremely important, because Aurelia requires them in order to set our development
    environment and install our dependencies.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还安装了 NodeJS 和 NPM；这两项开源技术非常重要，因为 Aurelia 需要它们来设置我们的开发环境并安装我们的依赖项。
- en: We explored the Aurelia command-line tool in detail, dived into its capabilities,
    and now you are familiar with it and are able to create, launch, test, and build
    your apps.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细探讨了 Aurelia 命令行工具，深入了解了它的功能，现在你对它已经很熟悉了，并且能够创建、启动、测试和构建你的应用程序。
- en: Finally, we talked about the example application we will build—an awesome FIFA
    World Cup single-page application. You also learned what an Aurelia component
    is and understood the way they split the view model and the template into two
    separate files that have to use the same filename with the `.js` and `.html` extensions,
    respectively.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了我们将要构建的示例应用——一个令人惊叹的 FIFA 世界杯单页应用。你也学习了 Aurelia 组件是什么，并了解了它们如何将视图模型和模板分别拆分为两个单独的文件，这两个文件必须使用相同的文件名，分别带有
    `.js` 和 `.html` 扩展名。
- en: In the next chapter, you will learn how to apply style and color to our application
    by installing and configuring the Google Material Design plugin in our app. Enjoy
    the next chapter!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过在我们的应用中安装和配置 Google Material Design 插件来为我们的应用添加样式和颜色。享受下一章吧！
