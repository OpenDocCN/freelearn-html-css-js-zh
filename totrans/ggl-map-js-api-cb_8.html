<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Mastering the Google Maps JavaScript API through Advanced Recipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Mastering the Google Maps JavaScript API through Advanced Recipes</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding WMS layers to maps</li><li class="listitem" style="list-style-type: disc">Adding Fusion Tables layers to maps</li><li class="listitem" style="list-style-type: disc">Adding CartoDB layers to maps</li><li class="listitem" style="list-style-type: disc">Accessing ArcGIS Server with the Google Maps JavaScript API</li><li class="listitem" style="list-style-type: disc">Accessing GeoServer with the Google Maps JavaScript API</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Introduction</h1></div></div></div><p>The Google Maps JavaScript API may seem like a simple library that only shows basic geo-related features, but there are a lot of capabilities that could be explored. The Google Maps JavaScript API gives developers many foundation classes to build complex solutions for different cases, especially for <a id="id645" class="indexterm"/>
<span class="strong"><strong>Geographical Information Systems</strong></span> (<span class="strong"><strong>GIS</strong></span>).</p><p>The Google Maps JavaScript API has a lot of potential with GIS services and tools. Most of the GIS solutions need base maps and services to support the tool itself and the Google Maps JavaScript API is the best solution with its base maps and services.</p><p>There are different GIS solutions from proprietary software and services to open source ones, such as <a id="id646" class="indexterm"/>Google Fusion Tables,<a id="id647" class="indexterm"/> CartoDB, <a id="id648" class="indexterm"/>ArcGIS Server, or <a id="id649" class="indexterm"/>GeoServer. In this chapter, we will integrate these servers or services with the Google Maps JavaScript API. Some of the GIS service creation processes are skipped due to space constraints. If you need more information, please check other books by <span class="emphasis"><em>Packt Publishing</em></span> to dive into details.</p></div></div>
<div class="section" title="Adding WMS layers to maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Adding WMS layers to maps</h1></div></div></div><p>
<span class="strong"><strong>Web Map Service</strong></span> (<span class="strong"><strong>WMS</strong></span>) is <a id="id650" class="indexterm"/>an <span class="strong"><strong>Open Geospatial Consortium</strong></span> (<span class="strong"><strong>OGC</strong></span>) standard for<a id="id651" class="indexterm"/> publishing <a id="id652" class="indexterm"/>georeferenced map images over the Internet that<a id="id653" class="indexterm"/> are generated by a map server using data from various geospatial sources such as shapefiles or geospatial databases. There are various versions used in WMS services but the most used ones are 1.1.1 or 1.3.0. WMS has two required request types: <code class="literal">GetCapabilities</code> and <code class="literal">GetMap</code>.</p><p>This recipe shows how to add a WMS layer to the Google Maps JavaScript API by extending the <code class="literal">google.maps.OverlayView</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec202"/>Getting ready</h2></div></div></div><p>By now, you should already know how to create a map, so only additional code lines are explained in this recipe.</p><p>You can find the source code at <code class="literal">Chapter 8/ch08_wms_map.html</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec203"/>How to do it…</h2></div></div></div><p>Adding WMS layers to the map is quite easy if you perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a <code class="literal">wms.js</code> file to include in the HTML later. This JavaScript file has a <code class="literal">WMSUntiled</code> class that is written as follows:<div class="informalexample"><pre class="programlisting">function WMSUntiled (map, wmsUntiledOptions) {
  this.map_ = map;
  this.options = wmsUntiledOptions;
  this.div_ = null;
  this.image_ = null;
  this.setMap(map);
}</pre></div></li><li class="listitem">Then, extend our base class by inheriting the <code class="literal">google.maps.OverlayView</code> class:<div class="informalexample"><pre class="programlisting">WMSUntiled.prototype = new google.maps.OverlayView();</pre></div></li><li class="listitem">The next step is to implement three methods of the <code class="literal">OverlayView</code> class.<div class="informalexample"><pre class="programlisting">WMSUntiled.prototype.draw = function() {
  var overlayProjection = this.getProjection();
  var sw = overlayProjection.fromLatLngToDivPixel (this.map_.getBounds ().getSouthWest());
  var ne = overlayProjection.fromLatLngToDivPixel (this.map_.getBounds().getNorthEast());
  var div = this.div_;
  if (this.image_ != null)
    div.removeChild(this.image_);


  // Create an IMG element and attach it to the DIV.
  var img = document.createElement('img');
  img.src = this.prepareWMSUrl();
  img.style.width = '100%';
  img.style.height = '100%';
  img.style.position = 'absolute';
  img.style.opacity = 0.6;
  this.image_ = img;
  div.appendChild(this.image_);

  div.style.left = sw.x + 'px';
  div.style.top = ne.y + 'px';
  div.style.width = (ne.x - sw.x) + 'px';
  div.style.height = (sw.y - ne.y) + 'px';
};

WMSUntiled.prototype.onAdd = function() {
  var that = this;
  var div = document.createElement('div');
  div.style.borderStyle = 'none';
  div.style.borderWidth = '0px';
  div.style.position = 'absolute';

  this.div_ = div;
  this.getPanes().floatPane.appendChild(this.div_);

  google.maps.event.addListener(this.map_, 'dragend', function() {
      that.draw();
  });
};

WMSUntiled.prototype.onRemove = function() {
  this.menuDiv.parentNode.removeChild(this.div_);
  this.div_ = null;
};</pre></div></li><li class="listitem">Finally, add <a id="id654" class="indexterm"/>the following<a id="id655" class="indexterm"/> methods to finish the <code class="literal">WMSUntiled</code> class:<div class="informalexample"><pre class="programlisting">WMSUntiled.prototype.prepareWMSUrl = function() {  
  var baseUrl = this.options.baseUrl;
  baseUrl += 'Service=WMS&amp;request=GetMap&amp;CRS=EPSG:3857&amp;';
  baseUrl += 'version=' + this.options.version;
  baseUrl += '&amp;layers=' + this.options.layers;
  baseUrl += '&amp;styles=' + this.options.styles;
  baseUrl += '&amp;format=' + this.options.format;

  var bounds = this.map_.getBounds();
  var sw = this.toMercator(bounds.getSouthWest());
  var ne = this.toMercator(bounds.getNorthEast());

  var mapDiv = this.map_.getDiv(); 
  baseUrl += '&amp;BBOX=' + sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y;  
  baseUrl += '&amp;width=' + mapDiv.clientWidth + '&amp;height=' + mapDiv.clientHeight;    
  return baseUrl;
};

WMSUntiled.prototype.toMercator = function(coord) {
  var lat = coord.lat();
  var lng = coord.lng();
  if ((Math.abs(lng) &gt; 180 || Math.abs(lat) &gt; 90))
    return;

  var num = lng * 0.017453292519943295;
  var x = 6378137.0 * num;
  var a = lat * 0.017453292519943295;

  var merc_lon = x;
  var merc_lat = 3189068.5 * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));

  return { x: merc_lon, y: merc_lat };
};

WMSUntiled.prototype.changeOpacity = function(opacity) {
  if (opacity &gt;= 0 &amp;&amp; opacity &lt;= 1){
    this.image_.style.opacity = opacity;
  }
};</pre></div></li><li class="listitem">Now this JavaScript class file must be added to the HTML after adding the Google Maps JavaScript API:<div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="lib/wms.js"&gt; 
&lt;/script&gt;</pre></div></li><li class="listitem">After<a id="id656" class="indexterm"/> initializing <a id="id657" class="indexterm"/>the map, we create our WMS options as follows:<div class="informalexample"><pre class="programlisting">var wmsOptions = {
  baseUrl: 'http://demo.cubewerx.com/cubewerx/cubeserv.cgi?',
  layers: 'Foundation.gtopo30',
  version: '1.1.1',
  styles: 'default',
  format: 'image/png'
};</pre></div></li><li class="listitem">At the end, we initialize the WMS layer with the WMS options created in steps 1 to 4:<div class="informalexample"><pre class="programlisting">var wmsLayer = new WMSUntiled(map, wmsOptions);</pre></div></li><li class="listitem">Go to your local URL where your HTML file is stored in your favorite browser and see the result. The following topological map coming from WMS is shown on the satellite base map of Google Maps:<div class="mediaobject"><img src="graphics/8825OT_08_01.jpg" alt="How to do it…"/></div></li></ol></div><p>As you can see in the preceding screenshot, we added a WMS layer to our map.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec204"/>How it works...</h2></div></div></div><p>WMS is a <a id="id658" class="indexterm"/>standard <a id="id659" class="indexterm"/>for serving georeferenced images. The main idea behind WMS is serving the image according to the width/height and bounding box of the map with additional parameters such as projection type, layer names, and return format.</p><p>Most of the WMS classes for the Google Maps JavaScript API around the Web are based on a tiled structure, which is the base for most mapping APIs. This tiled structure gets the bounding box of each tile and sends it to the server. This can be a good usage for user interactivity wherein users only get missing tiles when dragging the map, but there is a problem with map servers. Getting lots of tiles instead of a single image causes a big load on map servers if there isn't a caching mechanism with a high volume of usage.</p><p>In this recipe, we used the untiled structure to get WMS images from the server. This approach is getting one image from the server on each user interaction that can be useful in some cases. There isn't much information about this approach, so we encourage you to read and implement both approaches for your geo-web applications.</p><p>The JavaScript class named <code class="literal">WMSUntiled</code> is created in a different file in order to make the HTML file readable. This class is created with functional style and methods are added to the prototype of the constructor function:</p><div class="informalexample"><pre class="programlisting">function WMSUntiled (map, wmsUntiledOptions) {
  this.map_ = map;
  this.options = wmsUntiledOptions;
  this.div_ = null;
  this.image_ = null;
  this.setMap(map);
};</pre></div><p>The<a id="id660" class="indexterm"/> Google <a id="id661" class="indexterm"/>Maps JavaScript API has a base class to extend in these cases named as <code class="literal">google.maps.OverlayView</code>. The <code class="literal">WMSUntiled</code> class extends this class to create a WMS overlay on top of the map:</p><div class="informalexample"><pre class="programlisting">WMSUntiled.prototype = new google.maps.OverlayView();</pre></div><p>The <code class="literal">OverlayView</code> class<a id="id662" class="indexterm"/> has three methods to implement in order to show the<a id="id663" class="indexterm"/> overlays as <code class="literal">draw()</code>, <code class="literal">onAdd()</code>, and <code class="literal">onRemove()</code>. The <code class="literal">onAdd()</code> <a id="id664" class="indexterm"/>and<a id="id665" class="indexterm"/> <code class="literal">onRemove()</code> methods are called during initialization and removal respectively. The <code class="literal">div</code> element is created and added to the map with the help of the <code class="literal">appendChild</code> function in the <code class="literal">onAdd()</code> method. Also, the <code class="literal">drag</code> event of the map is started to listen and draw the WMS layer on each user drag in this method. The <code class="literal">onRemove()</code> method removes the <code class="literal">div</code> element created earlier:</p><div class="informalexample"><pre class="programlisting">WMSUntiled.prototype.onAdd = function() {
  var that = this;
  var div = document.createElement('div');
  div.style.borderStyle = 'none';
  div.style.borderWidth = '0px';
  div.style.position = 'absolute';

  this.div_ = div;
  this.getPanes().floatPane.appendChild(this.div_);

  google.maps.event.addListener(this.map_, 'dragend', function() {
    that.draw();
  });
};

WMSUntiled.prototype.onRemove = function() {
  this.menuDiv.parentNode.removeChild(this.div_);
  this.div_ = null;
};</pre></div><p>The most important part of the class is the <code class="literal">draw()</code> method. This method creates an <code class="literal">img</code> element and attaches this element to the created <code class="literal">div</code> element in the <code class="literal">onAdd()</code> method. If there is an <code class="literal">img</code> element created before, it is removed from the <code class="literal">div</code> element. The <code class="literal">img</code> source is obtained from another method of the class named <code class="literal">prepareWMSUrl()</code>:</p><div class="informalexample"><pre class="programlisting">var div = this.div_;
if (this.image_ != null)
  div.removeChild(this.image_);
var img = document.createElement('img');
img.src = this.prepareWMSUrl();
img.style.width = '100%';
img.style.height = '100%';
img.style.position = 'absolute';
img.style.opacity = 0.6;
this.image_ = img;
div.appendChild(this.image_);</pre></div><p>We <a id="id666" class="indexterm"/>need <a id="id667" class="indexterm"/>pixel coordinates to place the <code class="literal">div</code> element. We get a projection of the layers in order to locate the <code class="literal">div</code> and <code class="literal">img</code> elements in the right place on the map. The <code class="literal">fromLatLngToDivPixel()</code> method converts the <code class="literal">LatLng</code> coordinates to screen pixels, which are used for placing the <code class="literal">div</code> element in the correct place:</p><div class="informalexample"><pre class="programlisting">var overlayProjection = this.getProjection();
var sw = overlayProjection.fromLatLngToDivPixel (this.map_.getBounds().getSouthWest());
var ne = overlayProjection.fromLatLngToDivPixel (this.map_.getBounds().getNorthEast());</pre></div><p>WMS has a bounding box parameter (<code class="literal">BBOX</code>) that defines the boundaries of a georeferenced image. The <code class="literal">BBOX</code> parameter must be in the same unit defined in the CRS parameter. Google Maps is based on the Web Mercator projection, which is defined as <code class="literal">EPSG:900913</code> or <code class="literal">EPSG:3857</code>. The Google Maps JavaScript API used Web Mercator as a base projection, but gives us the <code class="literal">LatLng</code> objects in geographic projection defined as <code class="literal">EPSG:4326</code>. In order to get the right WMS image on Google Maps, there is a need for transformation of coordinates from <code class="literal">EPSG:4326</code> to <code class="literal">EPSG:3857</code>. This transformation can be done via the <code class="literal">toMercator()</code> method of the class.</p><p>The <code class="literal">prepareWMSUrl()</code> method gets<a id="id668" class="indexterm"/> most of the parameters from the <code class="literal">wmsoptions</code> object and creates a WMS URL to get the georeferenced image. The <code class="literal">BBOX</code> and <code class="literal">width</code>/<code class="literal">height</code> parameters are gathered from the map functions:</p><div class="informalexample"><pre class="programlisting">WMSUntiled.prototype.prepareWMSUrl = function() {
  var baseUrl = this.options.baseUrl;
  baseUrl += 'Service=WMS&amp;request=GetMap&amp;CRS=EPSG:3857&amp;';
  baseUrl += 'version=' + this.options.version;
  baseUrl += '&amp;layers=' + this.options.layers;
  baseUrl += '&amp;styles=' + this.options.styles;
  baseUrl += '&amp;format=' + this.options.format;

  var bounds = this.map_.getBounds();
  var sw = this.toMercator(bounds.getSouthWest());
  var ne = this.toMercator(bounds.getNorthEast());

  var mapDiv = this.map_.getDiv();
  baseUrl += '&amp;BBOX=' + sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y;
  baseUrl += '&amp;width=' + mapDiv.clientWidth + '&amp;height=' + mapDiv.clientHeight;
  return baseUrl;
};</pre></div><p>The <code class="literal">WMSUntiled</code> class handles almost everything. In order to add WMS layers to the Google Maps JavaScript API, you need to define the parameters of WMS layers and create an object from the <code class="literal">WMSUntiled</code> class. Since we give <code class="literal">map</code> as a parameter, there is no need to add the WMS layer to the <code class="literal">map</code> object:</p><div class="informalexample"><pre class="programlisting">var wmsOptions = {
  baseUrl: 'http://demo.cubewerx.com/cubewerx/cubeserv.cgi?',
  layers: 'Foundation.gtopo30',
  version: '1.1.1', 
  styles: 'default',
  format: 'image/png'
};
var wmsLayer = new WMSUntiled(map, wmsOptions);</pre></div><p>There are <a id="id669" class="indexterm"/>lots<a id="id670" class="indexterm"/> of parameters to get WMS from the server, but that is out of the scope of this book. The sample WMS server used in this example cannot be available when you want to use it, so please use your own WMS servers in order to be sure of the availability of the services.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec205"/>There's more…</h2></div></div></div><p>As stated at the beginning of the recipe, we create an overlay class to add WMS layers to the Google Maps JavaScript API without using the tiled structure. This is just a use case for developers. You should check for both tiled and untiled structures for your cases. There is an example use of the tiled structure in the <span class="emphasis"><em>Accessing GeoServer with the Google Maps JavaScript API</em></span> recipe in this chapter.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec206"/> See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple map in a custom DIV element</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Accessing GeoServer with the Google Maps JavaScript API</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Adding Fusion Tables layers to maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Adding Fusion Tables layers to maps</h1></div></div></div><p>Fusion Tables<a id="id671" class="indexterm"/> (<a class="ulink" href="http://tables.googlelabs.com/">http://tables.googlelabs.com/</a>) is an experimental tool provided by Google to store different types of tabular data. Fusion Tables is important for geo developers because it <a id="id672" class="indexterm"/>supports feature types such as points, <a id="id673" class="indexterm"/>polylines, and polygons. There is also support for geocoding of the address, place names, or countries that make Fusion Tables a powerful database for your features. Fusion Tables also has an API so that developers can connect it to different applications. There are some limitations in Fusion Tables but these limitations are enough for most developers.</p><p>The OpenStreetMap POI database can be downloaded via different sources. We downloaded the restaurant POI database of Switzerland in the KML format and imported it into Fusion Tables. There are 7967 points in this table. In this recipe, we will use this table as a sample to help us visualize.</p><p>The map view of the Switzerland POI database of restaurants can be seen using Fusion Tables as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8825OT_08_02.jpg" alt="Adding Fusion Tables layers to maps"/></div><p>This is how we achieve adding a Fusion Tables layer to the map that shows thousands of points without a problem.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec207"/>Getting ready</h2></div></div></div><p>We assume that<a id="id674" class="indexterm"/> you already know how to create a simple map. We <a id="id675" class="indexterm"/>will only cover the code that is needed for adding a Fusion Tables layer.</p><p>You can find the source code at <code class="literal">Chapter 8/ch08_fusion_tables.html</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec208"/>How to do it…</h2></div></div></div><p>If you want to add Fusion Tables layers to the map, you should perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, add the following line for jQuery to simplify our work after the Google Maps JavaScript API is added:<div class="informalexample"><pre class="programlisting">&lt;script src="http://code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">Then, add the following HTML code before the map's DIV element for interactivity with the Fusion Tables layer:<div class="informalexample"><pre class="programlisting">&lt;input type="checkbox" id="status"/&gt;HeatMap Enabled &lt;input type="text" id="query"/&gt; &lt;input type="button" id="search" value="Search"/&gt;&lt;br/&gt;</pre></div></li><li class="listitem">Now, create the Fusion Tables layers and add it to the map after the initialization of the <code class="literal">map</code> object as follows:<div class="informalexample"><pre class="programlisting">var layer = new google.maps.FusionTablesLayer({
  query: {
    select: 'geometry',
    from: '1_1TjGKCfamzW46TfqEBS7rXppOejpa6NK-FsXOg'
  },
  heatmap: {
    enabled: false
  }
});
layer.setMap(map);</pre></div></li><li class="listitem">The next<a id="id676" class="indexterm"/> step is to listen to the <code class="literal">click</code> event of the<a id="id677" class="indexterm"/> checkbox to switch between the normal view and the heat map view:<div class="informalexample"><pre class="programlisting">$('#status').click(function() {
  if (this.checked) {
    layer.setOptions({ 
      heatmap: { enabled: true } });
  }
  else {
    layer.setOptions({
      heatmap: { enabled: false } });
  }
});</pre></div></li><li class="listitem">Add the following lines to listen to the <code class="literal">click</code> event of the <span class="strong"><strong>Search</strong></span> button to filter the Fusion Tables layer according to the value entered in the textbox:<div class="informalexample"><pre class="programlisting">$('#search').click(function() {
  var txtValue = $('#query').val();
  layer.setOptions({query: { 
    select: 'geometry', 
    from: 
    '1_1TjGKCfamzW46TfqEBS7rXppOejpa6NK-FsXOg', 
    where: 'name contains "' + txtValue + '"' } });
});</pre></div></li><li class="listitem">Go to your local URL where your HTML is stored in your favorite browser and click on the map to see the result. If you click on the heat map checkbox, the Fusion Tables layer will change into a heat map. You can also search for the names of restaurants with the <span class="strong"><strong>Search</strong></span> button:<div class="mediaobject"><img src="graphics/8825OT_08_03.jpg" alt="How to do it…"/></div></li></ol></div><p>The<a id="id678" class="indexterm"/> preceding <a id="id679" class="indexterm"/>screenshot is also showing a filtered Fusion Tables layers added to a map.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec209"/>How it works...</h2></div></div></div><p>As stated earlier, Fusion Tables is an experimental tool to use and classes related to Fusion Tables that are under the Google Maps JavaScript API are also experimental according to the documentation. As far as we have used them, both Fusion Tables and classes under Google Maps JavaScript API are stable and can be ready for production environments, but it is at your own risk to use them in your geo-web application.</p><p>By the way, please make sure that your tables do not pass 100,000 rows in order to use them properly, because there is a limitation written in the API.</p><p>Fusion Tables supports the importing of various data types such as CSV, TSV, TXT, or KML with coordinates of geometries. Fusion Tables geometry columns can be in different formats, such as a geometry column in the KML format, address column, or latitude/longitude coordinates in single column or two separate columns. If you have addresses or city names, these columns can also be geocoded in order to be used in your applications. We uploaded a KML file to Fusion Tables gathered from OpenStreetMap that is full of restaurant points with names.</p><p>There is<a id="id680" class="indexterm"/> also <a id="id681" class="indexterm"/>a REST API for Fusion Tables to access and manipulate the data within tables with/without OAuth regardless of the Google Maps JavaScript API.</p><p>There is a <code class="literal">google.maps.FusionTablesLayer</code> class in the Google Maps JavaScript API to access and visualize the data from Fusion Tables. We need the table ID and name of the geometry column to access the Fusion Tables layer in the Google Maps JavaScript API. Remember that your table must be shared as public or unlisted in order to be accessible from the Google Maps JavaScript API. Developers can get the table ID by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>About</strong></span> in the Fusion Tables web interface. The following code block is needed to add Fusion Tables to the Google Maps JavaScript API:</p><div class="informalexample"><pre class="programlisting">var layer = new google.maps.FusionTablesLayer({
  query: {
    select: 'geometry',
    from: '1_1TjGKCfamzW46TfqEBS7rXppOejpa6NK-FsXOg'
  },
  heatmap: {
    enabled: false
  }
});
layer.setMap(map);</pre></div><p>If you want to enable the heat map option at the beginning of the API, you should set the enabled option to <code class="literal">true</code> under the <code class="literal">heatmap</code> parameter. We will switch these parameters with the <code class="literal">checkbox</code> options in our recipe as follows:</p><div class="informalexample"><pre class="programlisting">$('#status').click(function(){
  if (this.checked) {
    layer.setOptions({heatmap: { enabled: true } });
  }
  else {
    layer.setOptions({heatmap: { enabled: false } });
  }
});</pre></div><p>Using heat maps is a good way to summarize the data you have and show where most of the points are gathered. Heat maps are mostly used in various fields in order to show the important places such as most dense crime spots in crime mapping. If users enable the heat map, you will see the following results in the application. The following map shows in red where the restaurant population is crowded:</p><div class="mediaobject"><img src="graphics/8825OT_08_04.jpg" alt="How it works..."/></div><p>Fusion <a id="id682" class="indexterm"/>Tables <a id="id683" class="indexterm"/>also supports filtering rows with SQL-like queries. SQL queries can be added to the <code class="literal">query</code> parameter with the <code class="literal">where</code> field. This can be a starting value or added later to filter the visualized data. In this recipe, we filter our data according to the value entered in the textbox. The following code listens to the <span class="strong"><strong>Search</strong></span> button and when a click occurs, it gets the value of the textbox and set the options of the Fusion Tables layer according to the textbox value. The filtered data is immediately shown on the map:</p><div class="informalexample"><pre class="programlisting">$('#search').click(function() {
  var txtValue = $('#query').val();
  layer.setOptions({ 
  query: { 
    select: 'geometry', 
    from: '1_1TjGKCfamzW46TfqEBS7rXppOejpa6NK-FsXOg', where: 'name contains "' + txtValue + '"' } });
  });</pre></div><p>The <code class="literal">google.maps.FusionTablesLayer</code> class also has the ability to change the style of the map according to filters. You can change the marker type of points, line color of polylines, or fill color of polygons consistent with the values of columns.</p><p>Fusion <a id="id684" class="indexterm"/>Tables<a id="id685" class="indexterm"/> can be a good candidate to store, analyze, and visualize your data if developers know the limitations. Also, developers do not forget that Fusion Tables are still in the experimental stage, so Google can change something in Fusion Tables in the future that can cause your application to stop.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>
<span class="strong"><strong>More about data</strong></span>
</p><p>The data used in this application can be downloaded from <a class="ulink" href="http://poi-osm.tucristal.es/">http://poi-osm.tucristal.es/</a>, which uses OpenStreetMap as a source. The data used in this recipe is available with the code. The data is also available from Fusion Tables as a public share.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec210"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple map in a custom DIV element</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a heat map</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Adding Raster Layers">Chapter 2</a>, <span class="emphasis"><em>Adding Raster Layers</em></span></li></ul></div></div></div>
<div class="section" title="Adding CartoDB layers to maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Adding CartoDB layers to maps</h1></div></div></div><p>CartoDB<a id="id686" class="indexterm"/> is a geospatial database on the cloud that allows for the storage and visualization of data on the Web. Using CartoDB will allow you to quickly create map-based visualizations. According to the CartoDB website (<a class="ulink" href="http://www.cartodb.com">www.cartodb.com</a>), you can use CartoDB in<a id="id687" class="indexterm"/> the following<a id="id688" class="indexterm"/> ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Upload, visualize, and manage your data using the CartoDB dashboard</li><li class="listitem" style="list-style-type: disc">Quickly create and customize maps that you can embed or share via public URL using the map-embedding tool</li><li class="listitem" style="list-style-type: disc">Analyze and integrate data you store on CartoDB into your applications using the SQL API</li><li class="listitem" style="list-style-type: disc">For more advanced integrations of CartoDB maps on your website or application, use <code class="literal">CartoDB.js</code></li></ul></div><p>CartoDB<a id="id689" class="indexterm"/> is<a id="id690" class="indexterm"/> an open source project for which you can fork the code from GitHub and start your own CartoDB instance on your own hardware, but the power of CartoDB is the cloud backend. CartoDB is based on PostgreSQL, PostGIS, and Mapnik, which are the most popular and powerful open source geo tools nowadays.</p><p>There is a free tier for developers to explore the power of CartoDB, which has a limit of up to 5 MB storage and five tables.</p><p>In this recipe, the simplified version of world borders is imported from the CartoDB dashboard to play with. The following screenshots show both the tabular and map view of the world borders. This data will be published on the Google Maps JavaScript API with the help of the <code class="literal">CartoDB.js</code> library:</p><div class="mediaobject"><img src="graphics/8825OT_08_05.jpg" alt="Adding CartoDB layers to maps"/></div><p>And now the map view of the world border is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8825OT_08_06.jpg" alt="Adding CartoDB layers to maps"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec211"/>Getting ready</h2></div></div></div><p>In this <a id="id691" class="indexterm"/>recipe, <a id="id692" class="indexterm"/>we assume you already know how to create a simple map. So, we will only show the extra code lines to add CartoDB layers on top of the Google Maps base maps.</p><p>You can find the source code at <code class="literal">Chapter 8/ch08_cartodb_layer.html</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec212"/>How to do it…</h2></div></div></div><p>If you perform the following steps, you can add CartoDB layers to the map:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, CartoDB-related files are added to the HTML document:<div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/themes/css/cartodb.css" /&gt;
&lt;!--[if lte IE 8]&gt;
&lt;link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/themes/css/cartodb.ie.css" /&gt;
&lt;![endif]--&gt;
&lt;script src="http://libs.cartocdn.com/cartodb.js/v3/cartodb.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">Then, the jQuery file is added after CartoDB files:<div class="informalexample"><pre class="programlisting">&lt;script src="http://code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">The next step is to add a global variable to access from everywhere after the <code class="literal">map</code> variable:<div class="informalexample"><pre class="programlisting">var cartoLayer;</pre></div></li><li class="listitem">After initialization of the map, the following lines are added to define the cartography of the layers. This can be single line string, but it is separated into multiple lines in order to improve readability:<div class="informalexample"><pre class="programlisting">var cartoStyle = '#world_borders { ' + 
  'polygon-fill: #1a9850; ' +
  'polygon-opacity:0.7; ' +
  '} ' +
  '#world_borders [pop2005 &gt; 10000000] { ' +
  'polygon-fill: #8cce8a ' +
  '} ' +
  '#world_borders [pop2005 &gt; 40000000] { ' +
  'polygon-fill: #fed6b0 ' +
  '} ' +
  '#world_borders [pop2005 &gt; 70000000] { ' +
  'polygon-fill: #d73027 ' +
'} ';</pre></div></li><li class="listitem">The<a id="id693" class="indexterm"/> important<a id="id694" class="indexterm"/> part of the code is the initialization of the CartoDB layer as follows:<div class="informalexample"><pre class="programlisting">//Creating CartoDB layer and add it to map.
cartodb.createLayer(map, {
  user_name: 'gmapcookbook',
  type: 'cartodb',
  sublayers: [{
    sql: 'SELECT * FROM world_borders',
    cartocss: cartoStyle,
    interactivity: 'cartodb_id, name, pop2005, area',
  }]
})
.addTo(map)
.done(function(layer) {
  cartoLayer = layer;

  //Enabling popup info window
  cartodb.vis.Vis.addInfowindow(map, layer.getSubLayer(0), ['name', 'pop2005', 'area']);

  //Enabling UTFGrid layer to add interactivity.
  layer.setInteraction(true);
  layer.on('featureOver', function(e, latlng, pos, data) {
    $('#infoDiv').html('&lt;b&gt;Info : &lt;/b&gt;' + data.name + ' (Population : ' + data.pop2005 + ')');
  });
});</pre></div></li><li class="listitem">Now, <a id="id695" class="indexterm"/>add<a id="id696" class="indexterm"/> the following part to listen to the <code class="literal">click</code> event of the <span class="strong"><strong>Search</strong></span> button in order to update the map contents according to the textbox value:<div class="informalexample"><pre class="programlisting">//Listening click event of the search button to filter the //data of map
$('#search').click(function() {
  var txtValue = $('#query').val();
  cartoLayer.setQuery('SELECT * FROM world_borders WHERE name LIKE \'%' + txtValue + '%\'');
  if (txtValue == '') {
   cartoLayer.setCartoCSS(cartoStyle);
  }
  else { cartoLayer.setCartoCSS('#world_borders { polygon-fill: #00000d; polygon-opacity:0.7; }');
  }
});</pre></div></li><li class="listitem">Do not forget to add the following lines before and after the map's <code class="literal">div</code> element:<div class="informalexample"><pre class="programlisting">&lt;input type="text" id="query"/&gt; &lt;input type="button" id="search" value="Search"/&gt;&lt;br/&gt;
&lt;div id="mapDiv"&gt;&lt;/div&gt;
&lt;div id="infoDiv"&gt;--&lt;/div&gt;</pre></div></li><li class="listitem">Go to your local URL where your HTML is stored in your favorite browser and take a look at the CartoDB layer on top of the Google Maps base map. When you move on the map, the bottom line of the map changes according to where your mouse is placed. When you click on the map, you will also see an info window about that country as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8825OT_08_07.jpg" alt="How to do it…"/></div></li></ol></div><p>As a result of this recipe, we can add CartoDB layers to the map, which gets live data from your data source.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec213"/>How it works...</h2></div></div></div><p>As <a id="id697" class="indexterm"/>mentioned <a id="id698" class="indexterm"/>earlier, CartoDB is based on PostGIS and Mapnik technologies, so you can use CartoCSS as a styling language of the layer. CartoCSS is much like CSS with some additional tags to define the cartography. In this recipe, we will define a choropleth cartography according to population values. Using population values seems to be simple for cartography but this is the most easiest way to understand CartoCSS:</p><div class="informalexample"><pre class="programlisting">var cartoStyle = '#world_borders { ' +
    'polygon-fill: #1a9850; ' +
    'polygon-opacity:0.7; ' +
    '} ' +
  '#world_borders [pop2005 &gt; 10000000] { ' +
    'polygon-fill: #8cce8a ' +
    '} ' +
  '#world_borders [pop2005 &gt; 40000000] { ' +
    'polygon-fill: #fed6b0 ' +
    '} ' +
  '#world_borders [pop2005 &gt; 70000000] { ' +
    'polygon-fill: #d73027 ' +
  '} ';</pre></div><p>The <code class="literal">#world_borders</code> layer is the name of the layer defined in the CartoDB dashboard. The <a id="id699" class="indexterm"/>first brackets <a id="id700" class="indexterm"/>include all the features in the layer with a polygon-fill and a polygon-opacity. The second brackets target the features with a population of more than 10 million with a different color. The third brackets and fourth brackets target the features with a population of more than 40 and 70 million respectively with different colors. So, we have four different categories defined in this CartoCSS tag according to the population of countries. Each CartoCSS rule overwrites the one written before.</p><p>Now that we have the cartography of the layer, it is time to create the layer and add it to the map:</p><div class="informalexample"><pre class="programlisting">cartodb.createLayer(map, {
  user_name: 'gmapcookbook',
  type: 'cartodb',
  sublayers: [{
    sql: 'SELECT * FROM world_borders',
    cartocss: cartoStyle,
    interactivity: 'cartodb_id, name, pop2005, area'
  }]
})
.addTo(map)</pre></div><p>We have used chaining methods to create the layer and add it to the map. The following part is explained later. There is a <code class="literal">user_name</code> field to define your CartoDB account. The important part to define the layer is the <code class="literal">sublayers</code> field. You can define more than one layer but we will add only one layer at this time. The JavaScript object within the <code class="literal">sublayers</code> field is very important. The <code class="literal">sql</code> field defines, which features to be shown on the map. You can even write very complex SQL queries here like your own PostGIS database. The <code class="literal">cartocss</code> field is the part where you define the cartography of your layer. This is defined before, so just pass that variable to this field.</p><p>The next field is the <code class="literal">interactivity</code> field. This is important due to the technology behind it called<a id="id701" class="indexterm"/> <span class="strong"><strong>UTFGrid</strong></span>. UTFGrid is a specification for rasterized interaction data. According to MapBox, who introduced this standard, UTFGrid's solution to this problem is to rasterize polygons and points in JSON as a grid of text characters. Each feature is referenced by a distinct character and associated to JSON data by its character code. The result is a cheap, fast lookup that even Internet Explorer 7 can do instantly.</p><p>With UTFGrid, you can <a id="id702" class="indexterm"/>load some attribute data to the client with the loading of layer<a id="id703" class="indexterm"/> tile images and you can show this attribute data while your mouse is moving without sending any requests to the server. This is the quickest way to interact with users and remove the load from servers. You can still get detailed information from the server when it is really needed. Most of the time, users are very happy with this fast data interaction and there is no need to get more information from the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>
<span class="strong"><strong>More about UTFGrid</strong></span>
</p><p>If you are interested in more technical details of UTFGrid, the following web addresses are suggested for further reference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/mapbox/utfgrid-spec">https://github.com/mapbox/utfgrid-spec</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.mapbox.com/developers/utfgrid/">https://www.mapbox.com/developers/utfgrid/</a></li></ul></div></div></div><p>As we have previously covered, there is a field named <code class="literal">interactivity</code>. This should be filled with the column names that will be used for interactivity; it is important to make sure that interactivity is quick for users. So, adding complex text columns to show on interactivity is not advised in order to increase the loading of UTFGrids. Then we add this layer to the map with the chaining method.</p><p>We added the CartoDB layer to the map but there are still missing pieces to activate the interactivity. We add another chaining method to add the necessary functionality as follows:</p><div class="informalexample"><pre class="programlisting">.done(function(layer) {
  cartoLayer = layer;
  //Enabling popup info window
  cartodb.vis.Vis.addInfowindow(map, layer.getSubLayer(0), ['name', 'pop2005', 'area']);
});</pre></div><p>This <code class="literal">done()</code> method is called when the layer is created and added to the map. First, we assign the local variable <code class="literal">layer</code> to the global variable <code class="literal">cartoLayer</code> to manipulate the SQL query of the <code class="literal">layer</code> variable later. Then, we activate the info window with the <code class="literal">cartodb.vis.Vis.addInfoWindow()</code> method. But there are still required code parts for activating UTFGrid, which are given as follows:</p><div class="informalexample"><pre class="programlisting">layer.setInteraction(true);
layer.on('featureOver', function(e, latlng, pos, data) {
  $('#infoDiv').html('&lt;b&gt;Info : &lt;/b&gt;' + data.name + ' (Population : ' + data.pop2005 + ')');
});</pre></div><p>The first line activated the UTFGrid interaction, but we still need to know where and when to show the data. With the <code class="literal">featureOver</code> event of the layer, we catch each mouse move, get the related data from UTFGrid, and show it on the <code class="literal">div</code> element defined. We only show the <code class="literal">name</code> and <code class="literal">pop2005</code> fields of the layer on each mouse move.</p><p>The final <a id="id704" class="indexterm"/>part <a id="id705" class="indexterm"/>of the recipe is to search for the countries by typing their names. This part is like writing the SQL query. On each <code class="literal">click</code> event of the <span class="strong"><strong>Search</strong></span> button, we get the value of the textbox and assign it to a local variable named <code class="literal">txtValue</code>:</p><div class="informalexample"><pre class="programlisting">$('#search').click(function() {
  var txtValue = $('#query').val();
});</pre></div><p>When we have the <code class="literal">txtValue</code> variable, we set the query of the CartoDB layer by using the <code class="literal">setQuery()</code> method:</p><div class="informalexample"><pre class="programlisting">cartoLayer.setQuery('SELECT * FROM world_borders WHERE name LIKE \'%' + txtValue + '%\'');</pre></div><p>If the <code class="literal">txtValue</code> variable is empty, we recover the defined cartography; otherwise, we change the cartography of the layers to a black color to see which countries are selected by using the <code class="literal">setCartoCSS()</code> method:</p><div class="informalexample"><pre class="programlisting">if (txtValue == '') {
  cartoLayer.setCartoCSS(cartoStyle);
}
else {
  cartoLayer.setCartoCSS('#world_borders { polygon-fill: #00000d; polygon-opacity:0.7; }');
}</pre></div><p>The following screenshot is taken after searching countries whose names include <code class="literal">Turk</code>:</p><div class="mediaobject"><img src="graphics/8825OT_08_08.jpg" alt="How it works..."/></div><p>As we<a id="id706" class="indexterm"/> have <a id="id707" class="indexterm"/>seen in this recipe, CartoDB is a complete solution for everyone, from basic map visualization to complex GIS analysis. You can use the complete power of PostGIS behind your geo-web applications.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec214"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple map in a custom DIV element</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span></li></ul></div></div></div>
<div class="section" title="Accessing ArcGIS Server with the Google Maps JavaScript API"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Accessing ArcGIS Server with the Google Maps JavaScript API</h1></div></div></div><p>ArcGIS Server<a id="id708" class="indexterm"/> is the mapping and spatial server developed by ESRI. It is a proprietary software, but the capabilities and integration with desktop software make ArcGIS Server better than other spatial server products. ArcGIS Server is a complete spatial server solution for enterprise corporations or institutions. ArcGIS Server is used for creating and managing GIS web services, applications, and data. ArcGIS Server is typically deployed on-premises within the organization's <span class="strong"><strong>Service-oriented Architecture</strong></span> (<span class="strong"><strong>SOA</strong></span>)<a id="id709" class="indexterm"/> or off-premises in a cloud computing environment.</p><p>ESRI releases <a id="id710" class="indexterm"/>APIs for the ArcGIS <a id="id711" class="indexterm"/>Server to use in multiple platforms, but ESRI does not support the Google Maps JavaScript API v3. There was an extension for the Google Maps JavaScript API v2, but it does not work with the new API. There is an open source library to extend the Google Maps JavaScript API v3 to work with ArcGIS Server.</p><p>In this recipe, we will use the open source library to work with ArcGIS Server. We will add both a tiled and dynamic layer to the Google Maps JavaScript API. We also identify the dynamic layer with mouse clicks and show the underlying information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>
<span class="strong"><strong>More about the open source ArcGIS Server library</strong></span>
</p><p>ArcGIS Server link for the Google Maps JavaScript API v3 is an open source library and can be found the following web address. It is advised to download and check the library at <a class="ulink" href="https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html">https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html</a>.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec215"/>Getting ready</h2></div></div></div><p>This recipe is still using the same map creation process defined in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span>, but there are some additional code blocks to add ArcGIS tiled/dynamic layers and listen for mouse clicks to identify the dynamic layer.</p><p>You can find the source code at <code class="literal">Chapter 8/ch08_arcgis_layer.html</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec216"/>How to do it…</h2></div></div></div><p>The following are the steps we need to access ArcGIS Server with the Google Maps JavaScript API:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, download the ArcGIS Server link for the Google Maps JavaScript API v3 from the following address: <a class="ulink" href="https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html">https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html</a>.</li><li class="listitem">The next step is to add the downloaded library to your HTML file:<div class="informalexample"><pre class="programlisting">&lt;script src="lib/arcgis.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">The jQuery library is also needed in this recipe:<div class="informalexample"><pre class="programlisting">&lt;script src="http://code.jquery.com/jquery1.10.1.min.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">We also need some global variables as follows:<div class="informalexample"><pre class="programlisting">var overlays = [];
var infowindow = null;</pre></div></li><li class="listitem">Now, create a tiled map layer named <code class="literal">tiledMap</code> with an opacity of <code class="literal">0.6</code>:<div class="informalexample"><pre class="programlisting">//Creating a tiled map layer
var topoMapURL = 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer';
var tiledMap = new gmaps.ags.MapType(topoMapURL, {
  name: 'TopoMap',
  opacity: 0.6
});</pre></div></li><li class="listitem">Then, create a dynamic map layer named <code class="literal">dynamicMap</code> with an opacity of <code class="literal">0.8</code>. Also, a copyright control is added to the map:<div class="informalexample"><pre class="programlisting">//Creating a dynamic map layer
var dynamicMapURL = 'http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Census_USA/MapServer';
var copyrightControl = new gmaps.ags.CopyrightControl(map);
var dynamicMap = new gmaps.ags.MapOverlay(dynamicMapURL, {
  opacity: 0.8
});</pre></div></li><li class="listitem">We also<a id="id712" class="indexterm"/> need a map service<a id="id713" class="indexterm"/> for identifying with the same URL used in the dynamic map layer:<div class="informalexample"><pre class="programlisting">//Creating a map service layer
var mapService = new gmaps.ags.MapService(dynamicMapURL);</pre></div></li><li class="listitem">Now, start listening to the <code class="literal">map</code> object for each mouse click event:<div class="informalexample"><pre class="programlisting">//Listening map click event for identifying
google.maps.event.addListener(map, 'click', identify);</pre></div></li><li class="listitem">Let's create the function that is called on each mouse click event:<div class="informalexample"><pre class="programlisting">//Function that is called on each mouse click
function identify(evt) {
  mapService.identify({
    'geometry': evt.latLng,
    'tolerance': 3,
    'layerIds': [5],
    'layerOption': 'all',
    'bounds': map.getBounds(),
    'width': map.getDiv().offsetWidth,
    'height': map.getDiv().offsetHeight
  }, function(results, err) {
    if (err) {
      alert(err.message + err.details.join('\n'));
    } else {
      showResult(results.results, evt.latLng);
    }
  });
}</pre></div></li><li class="listitem">Afterward, <a id="id714" class="indexterm"/>we will show the results in an<a id="id715" class="indexterm"/> info window:<div class="informalexample"><pre class="programlisting">//Function that is showing the result of identify
function showResult(results, position) {
  if (infowindow != null) {
    infowindow.close();
  }

  var info = '&lt;b&gt;State Name : &lt;/b&gt;' + results[0].feature.attributes.STATE_NAME + '&lt;br&gt;&lt;b&gt;2007 Population : &lt;/b&gt;' + results[0].feature.attributes.POP2007;
  infowindow = new google.maps.InfoWindow({
    content: info,
    position: position
  });

  infowindow.open(map);

  removePolygons();

  for (var j=0; j &lt; results[0].geometry.rings.length; j++){
    addPolygon(results[0].geometry.rings[j]);
  }
}</pre></div></li><li class="listitem">Next, we add the function used for showing polygons. This function is used in the previous recipes:<div class="informalexample"><pre class="programlisting">//Function that is used for adding polygons to map.
function addPolygon(areaCoordinates) {
  //First we iterate over the coordinates array to create 
  // new array which includes objects of LatLng class.
  var pointCount = areaCoordinates.length;

  var areaPath = [];
  for (var i=0; i &lt; pointCount; i++) {
    var tempLatLng = new google.maps.LatLng(areaCoordinates[i][1], areaCoordinates[i][0]);
    areaPath.push(tempLatLng);
  }
  //Polygon properties are defined below
  var polygonOptions = {
    paths: areaPath,
    strokeColor: '#FF0000',
    strokeOpacity: 0.9,
    strokeWeight: 3,
    fillColor: '#FFFF00',
    fillOpacity: 0.25
  };

  var polygon = new google.maps.Polygon(polygonOptions);

  //Polygon is set to current map.
  polygon.setMap(map);

  overlays.push(polygon);
}</pre></div></li><li class="listitem">Now, add the<a id="id716" class="indexterm"/> following function <a id="id717" class="indexterm"/>for removing all the polygons:<div class="informalexample"><pre class="programlisting">//Function that is used for removing all polygons
function removePolygons() {
  if (overlays) {
    for (var i = 0; i &lt; overlays.length; i++) {
      overlays[i].setMap(null);
    }
    overlays.length = 0;
  }
}</pre></div></li><li class="listitem">The following code block listens to the checkboxes and switches the visibility of both tiled and dynamic layers:<div class="informalexample"><pre class="programlisting">//Start listening for click event to add/remove tiled map layer
$('#statusTile').click(function(){
  if (this.checked) {
    map.overlayMapTypes.insertAt(0, tiledMap);
  }
  else {
    map.overlayMapTypes.removeAt(0);
  }
});

//Start listening for click event to add/remove dynamic map layer
$('#statusDynamic').click(function(){
  if (this.checked) {
    dynamicMap.setMap(map);
  }
  else {
    dynamicMap.setMap(null);
  }
});</pre></div></li><li class="listitem">The last<a id="id718" class="indexterm"/> step is to add <a id="id719" class="indexterm"/>the necessary HTML tags for checkboxes:<div class="informalexample"><pre class="programlisting">&lt;input type="checkbox" id="statusTile"/&gt;Add Topo Map Overlay &lt;br/&gt;
&lt;input type="checkbox" id="statusDynamic"/&gt;Add Dynamic Map &lt;br/&gt;</pre></div></li><li class="listitem">Go to your local URL where the HTML is stored in your favorite browser and enable <span class="strong"><strong>Add Topo Map Overlay</strong></span> by clicking on the checkbox nearby. The following topological map is shown on the satellite base map:<div class="mediaobject"><img src="graphics/8825OT_08_09.jpg" alt="How to do it…"/></div></li></ol></div><p>Thus, we have successfully created a map that accesses the ArcGIS Server layers with the Google Maps JavaScript API.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec217"/>How it works...</h2></div></div></div><p>ArcGIS <a id="id720" class="indexterm"/>Server has different <a id="id721" class="indexterm"/>capabilities to use with the Google Maps JavaScript API. The library used to access ArcGIS Server in this recipe has almost every method for the REST API of the ArcGIS Server. The library is created on the Google Maps JavaScript API base classes, so using it is not as difficult as expected.</p><p>The service URLs used in this recipe are serving by ESRI, so you can use them for developing purposes without any problems. If you want to use them in a production environment, please contact ESRI to get valid licenses.</p><p>In the first step, we will add a tiled map showing the topology of the world on the satellite base map. With the help of the <code class="literal">gmaps.ags.MapType</code> class, you can easily create a tiled map with a URL to the map service:</p><div class="informalexample"><pre class="programlisting">var topoMapURL = 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer';
var tiledMap = new gmaps.ags.MapType(topoMapURL, {
  name: 'TopoMap',
  opacity: 0.6
});</pre></div><p>Adding and <a id="id722" class="indexterm"/>removing the<a id="id723" class="indexterm"/> tiled map is done in the the same way as we did in <a class="link" href="ch02.html" title="Chapter 2. Adding Raster Layers">Chapter 2</a>, <span class="emphasis"><em>Adding Raster Layers</em></span>. Please get the index of the layer. This index is used when removing the layer from map:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">// Adding layer to the map.</code>
map.overlayMapTypes.insertAt(0, tiledMap);
// Removing layer from the map
map.overlayMapTypes.removeAt(0);</pre></div><p>Creating a dynamic layer is also very easy thanks to the library. The library handles all the code for drawing the dynamic layer. The sample dynamic layer used in this recipe is the CENSUS data layer, which has the demographic information about states, counties, or census blocks of the U.S.:</p><div class="informalexample"><pre class="programlisting">var dynamicMapURL = 'http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Census_USA/MapServer';
var dynamicMap = new gmaps.ags.MapOverlay(dynamicMapURL, {
  opacity: 0.8
});</pre></div><p>The following is the screenshot of the CENSUS layer:</p><div class="mediaobject"><img src="graphics/8825OT_08_10.jpg" alt="How it works..."/></div><p>Adding and <a id="id724" class="indexterm"/>removing the dynamic <a id="id725" class="indexterm"/>layer are the same as overlays because the <code class="literal">gmaps.ags.MapOverlay</code> class is extended from the <code class="literal">google.maps.OverlayView</code> base class:</p><div class="informalexample"><pre class="programlisting">// Adding layer to the map.
dynamicMap.setMap(map);
// Removing layer from the map
dynamicMap.setMap(null);</pre></div><p>Identifying a map layer is a very important task for most geo-web applications. This gives information to users about the layer at known points. To achieve this, we need to define a map service as follows. The <code class="literal">gmaps.ags.MapService</code> class only gets the URL parameters, which are defined for the dynamic layer before:</p><div class="informalexample"><pre class="programlisting">var mapService = new gmaps.ags.MapService(dynamicMapURL);</pre></div><p>When a map <code class="literal">click</code> event occurs, we need to handle it with a function named <code class="literal">identify</code>. This function gets the <code class="literal">latLng</code> object and trigger the <code class="literal">identify</code> method of the <code class="literal">gmaps.ags.MapService</code> class:</p><div class="informalexample"><pre class="programlisting">function identify(evt) {
  mapService.identify({
    'geometry': evt.latLng,
    'tolerance': 3,
    'layerIds': [5],
    'layerOption': 'all',
    'bounds': map.getBounds(),
    'width': map.getDiv().offsetWidth,
    'height': map.getDiv().offsetHeight
  }, function(results, err) {
    if (err) {
        alert(err.message + err.details.join('\n'));
    } else {
        showResult(results.results, evt.latLng);
    }
  });
}</pre></div><p>The <code class="literal">identify</code> method <a id="id726" class="indexterm"/>gets some parameters <a id="id727" class="indexterm"/>as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">geometry</code>: This gets <code class="literal">LatLng</code>, <code class="literal">Polyline</code>, or <code class="literal">Polygon</code> objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tolerance</code>: This is the distance in screen pixels where the mouse is clicked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">layerIds</code>: This array contains layer IDs. The value <code class="literal">5</code> in this recipe defines the state's layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">layerOption</code>: These options can be <code class="literal">top</code>, <code class="literal">visible</code>, or <code class="literal">all</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bounds</code>: This gets an object created from the <code class="literal">LatLngBounds</code> class. This defines the current bounds of the map.</li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>: This is the width of the map <code class="literal">div</code> element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: This is the height of the map <code class="literal">div</code> element.</li></ul></div><p>The return of the function contains an array of features that contains both the attribute and geometry data. The result function can iterate over this array and show the attribute data in an info window. The geometry of each feature can also be shown on the map. The result of the <code class="literal">identify</code> operation is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8825OT_08_11.jpg" alt="How it works..."/></div><a id="id728" class="indexterm"/><p>ArcGIS Server is a powerful tool<a id="id729" class="indexterm"/> to use with the Google Maps JavaScript API if you have the license. There are also other GIS functionalities such as geoprocessing, geocoding, or geometry service, which are not included in this recipe due to the scope, but their usage is no different from the <code class="literal">identify</code> operation.</p><p>The Google Maps JavaScript API is a perfect mapping tool and is powerful with this kind of service and libraries.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec218"/>There's more…</h2></div></div></div><p>In this recipe, we focused on the ArcGIS Server, but ESRI also has an alternative cloud solution named <a id="id730" class="indexterm"/>ArcGIS Online (<a class="ulink" href="http://www.arcgis.com">www.arcgis.com</a>). It is the cloud version of the ArcGIS Server and the usage of its services are almost the same as ArcGIS Server's services.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec219"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple map in a custom DIV element</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding popups to markers or maps</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Adding Vector Layers">Chapter 3</a>, <span class="emphasis"><em>Adding Vector Layers</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding polygons to maps</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Adding Vector Layers">Chapter 3</a>, <span class="emphasis"><em>Adding Vector Layers</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Getting coordinates of a mouse click</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Understanding Google Maps JavaScript API Events">Chapter 5</a>, <span class="emphasis"><em>Understanding Google Maps JavaScript API Events</em></span></li></ul></div></div></div>
<div class="section" title="Accessing GeoServer with the Google Maps JavaScript API"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Accessing GeoServer with the Google Maps JavaScript API</h1></div></div></div><p>GeoServer<a id="id731" class="indexterm"/> is an open source map server written in Java that allows users to share and edit geospatial data. It is one of the popular open source map servers that can publish OGC compliant services such as WMS and WFS. <span class="strong"><strong>Web Map Service</strong></span> (<span class="strong"><strong>WMS</strong></span>) is used for publishing georeferenced images and simple querying. On the other side, <span class="strong"><strong>Web Feature Service</strong></span> (<span class="strong"><strong>WFS</strong></span>) is used for <a id="id732" class="indexterm"/>publishing vector data to any kind of GIS clients. WFS is mostly used for data sharing purposes.</p><p>In this recipe, <a id="id733" class="indexterm"/>we will use one of GeoServer's <a id="id734" class="indexterm"/>standard published service named <code class="literal">topp:states</code> in WMS format. As stated in the <span class="emphasis"><em>Adding WMS layers to maps</em></span> recipe of this chapter, WMS has different request types such as <code class="literal">GetMap</code> or <code class="literal">GetCapabilities</code>. We will also use a <code class="literal">GetFeatureInfo</code> addition to the <code class="literal">GetMap</code> request. This new request gets the information of the point on the map. Also, we used a tiled structure in this recipe to get WMS images in order to make a comparison between the untiled structure in the <span class="emphasis"><em>Adding WMS layers to maps</em></span> recipe and the tiled structure in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec220"/>Getting ready</h2></div></div></div><p>In this recipe, we will use the first recipe defined in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span>, as a template in order to skip the map creation.</p><p>You can find the source code at <code class="literal">Chapter 8/ch08_geoserver.html</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec221"/>How to do it…</h2></div></div></div><p>You can easily access GeoServer with the Google Maps JavaScript API after performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create a <code class="literal">wms-tiled.js</code> file to include in the HTML later. This JavaScript file <a id="id735" class="indexterm"/>has the <code class="literal">WMSTiled</code> <a id="id736" class="indexterm"/>and <code class="literal">WMSFeatureInfo</code> classes. Let's add the <code class="literal">WMSTiled</code> class as follows:<div class="informalexample"><pre class="programlisting">function WMSTiled(wmsTiledOptions) {

  var options = {
    getTileUrl: function(coord, zoom) {
      var proj = map.getProjection();
      var zfactor = Math.pow(2, zoom);

      // get Long Lat coordinates
      var top = proj.fromPointToLatLng(new google.maps.Point(coord.x * 256 / zfactor, coord.y * 256 / zfactor));
      var bot = proj.fromPointToLatLng(new google.maps.Point((coord.x + 1) * 256 / zfactor, (coord.y + 1) * 256 / zfactor));

      //create the Bounding box string
      var ne = toMercator(top);
      var sw = toMercator(bot);
      var bbox = ne.x + ',' + sw.y + ',' + sw.x + ','+ ne.y;

      //base WMS URL
      var url = wmsTiledOptions.url;
      url += '&amp;version=' + wmsTiledOptions.version;
      url += '&amp;request=GetMap';
      url += '&amp;layers=' + wmsTiledOptions.layers;
      url += '&amp;styles=' + wmsTiledOptions.styles;
      url += '&amp;TRANSPARENT=TRUE';
      url += '&amp;SRS=EPSG:3857';
      url += '&amp;BBOX='+ bbox;
      url += '&amp;WIDTH=256';
      url += '&amp;HEIGHT=256';
      url += '&amp;FORMAT=image/png';
      return url;
    },
    tileSize: new google.maps.Size(256, 256),
    isPng: true
  };

  return new google.maps.ImageMapType (options);
}</pre></div></li><li class="listitem">Then, <a id="id737" class="indexterm"/>create<a id="id738" class="indexterm"/> the <code class="literal">WMSFeatureInfo</code> class and its <code class="literal">getUrl</code> method:<div class="informalexample"><pre class="programlisting">function WMSFeatureInfo(mapObj, options) {
  this.map = mapObj;
  this.url = options.url;
  this.version = options.version;
  this.layers = options.layers;
  this.callback = options.callback;    
  this.fixedParams = 'REQUEST=GetFeatureInfo&amp;EXCEPTIONS=application%2Fvnd.ogc.se_xml&amp;SERVICE=WMS&amp;FEATURE_COUNT=50&amp;styles=&amp;srs=EPSG:3857&amp;INFO_FORMAT=text/javascript&amp;format=image%2Fpng';

  this.overlay = new google.maps.OverlayView();
  this.overlay.draw = function() {};
  this.overlay.setMap(this.map);
}

WMSFeatureInfo.prototype.getUrl = function(coord) {
  var pnt = this.overlay.getProjection(). fromLatLngToContainerPixel (coord);
  var mapBounds = this.map.getBounds();
  var ne = mapBounds.getNorthEast();
  var sw = mapBounds.getSouthWest();

  var neMerc = toMercator(ne);
  var swMerc = toMercator(sw);
  var bbox = swMerc.x + ',' + swMerc.y + ',' + neMerc.x + ',' + neMerc.y;

  var rUrl = this.url + this.fixedParams;
  rUrl += '&amp;version=' + this.version;
  rUrl += '&amp;QUERY_LAYERS=' + this.layers + '&amp;Layers=' + this.layers;
  rUrl += '&amp;BBOX=' + bbox;
  rUrl += '&amp;WIDTH=' + this.map.getDiv().clientWidth + '&amp;HEIGHT=' + this.map.getDiv().clientHeight;
  rUrl += '&amp;x=' + Math.round(pnt.x) + '&amp;y=' + Math.round(pnt.y);
  rUrl += '&amp;format_options=callback:' + this.callback;
  return rUrl;
};</pre></div></li><li class="listitem">The last step in the <code class="literal">wms-tiled.js</code> file is to add the <code class="literal">toMercator()</code> method:<div class="informalexample"><pre class="programlisting">function toMercator(coord) {
  var lat = coord.lat();
  var lng = coord.lng();
  if ((Math.abs(lng) &gt; 180 || Math.abs(lat) &gt; 90))
    return;

  var num = lng * 0.017453292519943295;
  var x = 6378137.0 * num;
  var a = lat * 0.017453292519943295;

  var merc_lon = x;
  var merc_lat = 3189068.5 * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));

  return { x: merc_lon, y: merc_lat };
}</pre></div></li><li class="listitem">Now, we <a id="id739" class="indexterm"/>have our<a id="id740" class="indexterm"/> JavaScript class file; add the following line after adding the Google Maps JavaScript API:<div class="informalexample"><pre class="programlisting">&lt;script src="lib/wms-tiled.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">We also need to add a jQuery library to the HTML file:<div class="informalexample"><pre class="programlisting">&lt;script src="http://code.jquery.com/jquery-1.10.1.min.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">Now, create a tiled WMS from the class written in the <code class="literal">wms-tiled.js</code> file:<div class="informalexample"><pre class="programlisting">//Creating a tiled WMS Service and adding it to the map
var tiledWMS = new WMSTiled({
  url: 'http://localhost:8080/geoserver/topp/wms?service=WMS',
  version: '1.1.1',
  layers: 'topp:states',
  styles: ''
});
map.overlayMapTypes.push(tiledWMS);</pre></div></li><li class="listitem">The next step is to create an object from the <code class="literal">WMSFeatureInfo</code> class to be used later in the event listener:<div class="informalexample"><pre class="programlisting">//Creating a WMSFeatureInfo class to get info from map.
var WMSInfoObj = new WMSFeatureInfo(map, {
  url: 'http://localhost:8080/geoserver/topp/wms?',
  version: '1.1.1',
  layers: 'topp:states',
  callback: 'getLayerFeatures'
});</pre></div></li><li class="listitem">The last <a id="id741" class="indexterm"/>step is to listen <a id="id742" class="indexterm"/>to the <code class="literal">click</code> event of the map to get information from the map:<div class="informalexample"><pre class="programlisting">google.maps.event.addListener(map, 'click', function(e){
  //WMS Feature Info URL is prepared by the help of
  //getUrl method of WMSFeatureInfo object created before
  var url = WMSInfoObj.getUrl(e.latLng);
  $.ajax({
    url: url,
    dataType: 'jsonp',
    jsonp: false,
    jsonpCallback: 'getLayerFeatures'
  }).done(function(data) {
    if (infowindow != null) {
      infowindow.close();
    }

    var info = '&lt;b&gt;State Name : &lt;/b&gt;' + data.features[0].properties.STATE_NAME + '&lt;br&gt;&lt;b&gt;Population : &lt;/b&gt;' + data.features[0].properties.SAMP_POP;
    infowindow = new google.maps.InfoWindow({
      content: info,
      position: e.latLng
    });

    infowindow.open(map);
  });
});</pre></div></li><li class="listitem">Go to your local URL where the HTML is stored in your favorite browser and try to click on the map where you want to get info.<div class="mediaobject"><img src="graphics/8825OT_08_12.jpg" alt="How to do it…"/></div></li></ol></div><p>The previous screenshot is the result of the recipe that shows WMS layers created by GeoServer on the Google Maps JavaScript API.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec222"/>How it works...</h2></div></div></div><p>Accessing <a id="id743" class="indexterm"/>GeoServer is not much<a id="id744" class="indexterm"/> different from accessing a WMS server because they share the same standards. With GeoServer, you can publish your data on your own servers with your security standards.</p><p>In this recipe, we installed a fresh GeoServer to our Mac OS X and its sample data is ready for serving WMS and WFS. We used the sample states data of the U.S. on WMS to show the interaction.</p><p>In our case, we are serving HTML files from <code class="literal">localhost</code> on port 80, but GeoServer is working from <code class="literal">localhost</code> on port 8080. This is a problem for our case, because we cannot access GeoServer when getting information due to the cross-site scripting security limitation of HTML. The solution is using a JSONP format to pass over the limitation. GeoServer can give the JSONP format, but you should activate it from the options.</p><p>In the <span class="emphasis"><em>Adding WMS layers to maps</em></span> recipe of this chapter, we used the untiled structure to get WMS images, but this time, we are using the tiled structure to get WMS images. The difference can be seen in the screenshot of untiled and tiled usage of WMS that the abbreviation of states' names occurring more than once on tiled WMS because the geometry of the same state can be seen in different images of tiled WMS. As said, the choice is yours whether it is tiled or untiled according to your geo-web application's needs.</p><p>Creating a tiled structure in WMS is done in exactly the same way as we did in the <span class="emphasis"><em>Adding tile overlays to maps</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Adding Raster Layers">Chapter 2</a>, <span class="emphasis"><em>Adding Raster Layers</em></span>. The important part here is to create the URL for each tile. The <code class="literal">BBOX</code> parameter for each tile is calculated as follows:</p><div class="informalexample"><pre class="programlisting">var proj = map.getProjection();
var zfactor = Math.pow(2, zoom);
// get Long Lat coordinates
var top = proj.fromPointToLatLng(new google.maps.Point(coord.x * 256 / zfactor, coord.y * 256 / zfactor) );
var bot = proj.fromPointToLatLng(new google.maps.Point((coord.x + 1) * 256 / zfactor, (coord.y + 1) * 256 / zfactor));
//create the Bounding box string
var ne = toMercator(top);
var sw = toMercator(bot);
var bbox = ne.x + ',' + sw.y + ',' + sw.x + ',' + ne.y;</pre></div><p>There is a <a id="id745" class="indexterm"/>need for projection <a id="id746" class="indexterm"/>transformation to get tiles that will fit exactly on the Google Maps' base map. Google Maps has a Web Mercator projection so the overlays need to be in this projection.</p><p>One of the other parameters needed for URL is the WMS standard parameter, but be sure about the difference of parameters according to the WMS versions.</p><p>The <code class="literal">SRS</code> parameter used in this recipe is <code class="literal">EPSG:3857</code>, which is the equivalent of <code class="literal">EPSG:900913</code>, <code class="literal">ESRI:102113</code>, or <code class="literal">ESRI:102100</code>. All <code class="literal">SRS</code> parameters mentioned here define the Web Mercator projection systems.</p><p>The <code class="literal">WMSFeatureInfo</code> class is written for creating WMS get info requests. The parameters of the URL are important, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: This is the x coordinate of the mouse in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: This is the y coordinate of the mouse in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>: This is the width of the map <code class="literal">div</code> element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: This is the height of the map <code class="literal">div</code> element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">info_format</code>: This is a string that describes the return format of information. In this case, <code class="literal">Text</code>/<code class="literal">JavaScript</code> is used for getting info in the format of JSONP.</li><li class="listitem" style="list-style-type: disc"><code class="literal">query_layers</code>: This is the comma-separated list of layers to be queried.</li><li class="listitem" style="list-style-type: disc"><code class="literal">layers</code>: This is the comma- separated list of layers to be shown (coming from the <code class="literal">GetMap</code> request).</li><li class="listitem" style="list-style-type: disc"><code class="literal">bbox</code>: This is the bounding box of the map shown.</li><li class="listitem" style="list-style-type: disc"><code class="literal">format_options</code>: This is required for JSONP to define the name of the <code class="literal">callback</code> function. The <code class="literal">callback</code> function's name must be the same as in the jQuery AJAX request to get information without any errors.</li></ul></div><p>The <code class="literal">getUrl</code> method<a id="id747" class="indexterm"/> gets the <code class="literal">LatLng</code> object<a id="id748" class="indexterm"/> as an input, but there is a need for screen coordinates in the <code class="literal">GetFeatureInfo</code> request. We came up with a trick in order to convert <code class="literal">LatLng</code> to screen coordinates in the <code class="literal">getUrl</code> method. In the constructor, we create an overlay with the <code class="literal">google.maps.OverlayView</code> class and use its functions to convert <code class="literal">LatLng</code> to screen coordinates:</p><div class="informalexample"><pre class="programlisting">var pnt = this.overlay.getProjection ().fromLatLngToContainerPixel(coord);
rUrl += '&amp;x=' + Math.round(pnt.x) + '&amp;y=' + Math.round(pnt.y);</pre></div><p>The <code class="literal">google.maps.Projection</code> class has a method named <code class="literal">fromLatLngToPoint()</code> to convert the <code class="literal">LatLng</code> object to screen coordinates but this does not work as it is expected to. This converts the <code class="literal">LatLng</code> coordinates to screen coordinates in world scale, but we need to get the screen coordinates in the map's <code class="literal">div</code> reference. To achieve this, we use the <code class="literal">google.maps.MapCanvasProjection</code> class method named <code class="literal">fromLatLngToContainerPixel()</code>.</p><p>We didn't go into detail with listening to the map <code class="literal">click</code> event and showing popups. Also, we used the <code class="literal">ajax</code> method of jQuery to get a JSONP request, which is also out of the scope of this book. If you want to get details of these topics, please refer to previous recipes of related chapters.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec223"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple map in a custom DIV element</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Google Maps JavaScript API Basics">Chapter 1</a>, <span class="emphasis"><em>Google Maps JavaScript API Basics</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding popups to markers or maps</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Adding Vector Layers">Chapter 3</a>, <span class="emphasis"><em>Adding Vector Layers</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Getting coordinates of a mouse click</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Understanding Google Maps JavaScript API Events">Chapter 5</a>, <span class="emphasis"><em>Understanding Google Maps JavaScript API Events</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding WMS layers to maps</em></span> recipe</li></ul></div></div></div></body></html>