<html><head></head><body>
        

                            
                    <h1 class="header-title">Breaking the Monolith</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul class="listtype-bullet listindent1 list-bullet1">
<li>Organizing your team to embrace microservices</li>
<li>Decomposing by business capability</li>
<li>Identifying bounded contexts</li>
<li>Migrating data in production</li>
<li>Refactoring your monolith</li>
<li>Evolving your monolith into services</li>
<li>Evolving your test suite</li>
<li>Using Docker for local development</li>
<li>Routing requests to services</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>One of the hardest things about microservices is getting started. Many teams have found themselves building features into an ever-growing, hard-to-manage monolithic code base and don't know how to start breaking it apart into more manageable, separately deployable services. The recipes in this chapter will explain how to make the transition from monolith to microservices. Many of the recipes will involve no code whatsoever; instead, they will be focused on architectural design and how best to structure teams to work on microservices.</p>
<p>You'll learn how to begin moving from a single monolithic code base to suites of microservices. You'll also learn how to manage some of the initial challenges when you begin to develop features using this new architectural style.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing your team</h1>
                
            
            
                
<p>Conway's law tells us that organizations will produce designs whose structure is a copy of their communication structure. This often means that the organizational chart of an engineering team will have a profound impact on the structure of the designs of the software it produces. When a new startup begins building software, the team is small—sometimes it is comprised of just one or two engineers. In this setup, engineers work on everything, including frontend and backend systems, as well as operations. Monoliths suit this organizational structure very well, allowing engineers to work on any part of the system at any given time without moving between code bases.</p>
<p>As a team grows, and you start to consider the benefits of microservices, you can consider employing a technique commonly referred to as an the <strong>Inverse Conway Maneuver</strong>. This technique recommends evolving your team and organizational structure to encourage the kind of architectural style you want to see emerge. With regard to microservices, this will usually involve organizing engineers into small teams that you will eventually want to be responsible for a handful of related services. Setting your team up for this structure ahead of time can motivate engineers to build services by limiting communication and decision-making overhead within the team. Simply put, monoliths continue to exist when the cost of adding features as services is greater than the cost of adding a feature to the monolith. Organizing your teams in this way reduces the cost of developing services.</p>
<p>This recipe is aimed at managers and other leaders in companies who have the influence to implement changes to the structure of the organization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p class="mce-root">Re-organizing a team is never a simple task, and there are many non-obvious factors to consider. Factors such as personality, individual strengths and weaknesses, and past histories are outside the scope of this recipe, but they should be considered carefully when making any changes. The steps in this recipe provide one possible way to move a team from being organized around a monolithic code base to being optimized for microservices, but there is no one-size-fits-all recipe for every organization.</p>
<p class="mce-root">Use the following steps as a guide if you think they apply, but otherwise use them for inspiration and to encourage thought and discussion:</p>
<ol>
<li class="p1">Working with other stakeholders in your organization, build out a product roadmap. You may have limited information about the challenges your organization will face in the short term, but do the best you can. It's perfectly natural to be very detailed for short-term items on a roadmap and very general for the longer term.</li>
<li class="p1">Using the product roadmap, try to identify technical capabilities that will be required to help you deliver value to your users. For example, you may be planning to work on a feature that relies heavily on search. You may also have a number of features that rely on content uploading and management. This means that search and uploading are two technical capabilities you know you will need to invest in.</li>
<li class="p1">As you see patterns emerge, try to identify the main functional areas of your application, paying attention to how much work you anticipate will go into each area. Assign higher priorities to the functional areas you anticipate will need a lot of investment in the short to medium term.</li>
<li class="p1">Create new teams, ideally consisting of four to six engineers, who are responsible for one of the functional areas within your application. Start with the functional areas that you anticipate will require the most work over the next quarter or so. These teams can be focused on the backend services or they can be cross-functional teams that include the mobile and web engineers. The benefit of having cross-functional teams is that the team can then deliver the entire vertical component of the application autonomously. The combination of service engineers with engineers consuming their services will also enable more information sharing, and hopefully, empathy.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Discussion</h1>
                
            
            
                
<p>Using this approach, you should end up with small, cohesive, and focused teams responsible for core areas of your application. The nature of teams is that individuals within the team should start to see the benefit of creating separately managed and deployed code bases that they can work in autonomously without the costly overhead of coordinating changes and deployments with other teams. </p>
<p>To help illustrate these steps, imagine your organization builds an image-messaging application. The application allows users to take a photo with their smart phone and send it, along with a message, to a friend in their contacts list. Their friends can also send them photos with messages. A fictional roadmap for this fictional product could involve the need to add support for short videos, photo filters, and support for emojis. You now know that the ability to record, upload, and play videos, the ability to apply photo filters, and the ability to send rich text will be important to your organization. Additionally, you know from experience that users need to register, log in, and maintain a friends list. </p>
<p>Using the preceding example, you may decide to organize engineers into a media team, responsible for uploading, processing and playing, filters, and storage and delivery, a messaging team, responsible for the sending of photo or video messages with associated text, and a users team, responsible for providing reliable authentication, registration, on-boarding, and social features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Decomposing by business capability</h1>
                
            
            
                
<p class="mce-root">In the early stages of product development, monoliths are the best suited to delivering features to users as quickly and simply as possible. This is appropriate, as at this point in a products development you do not have luxury problems of having to scale your teams, code bases or ability to serve customer traffic. Following good design practices, you separate your applications concerns into easy-to-read, modular code patterns. Doing so allows engineers to work on different sections of the code autonomously and limits the possibility of having to untangle complicated merge conflicts when it comes time to merge your branch into the master and deploy your code. </p>
<p>Microservices require you to go a step further than the good design practices you've already been following in your monolith. To organize your small, autonomous teams around microservices, you should consider first identifying the core business capabilities that your application provides. Business capability is a business school term that describes the various ways your organization produces value. For example, your internal order management is responsible for processing customer orders. If you have a social application that allows users to submit user-generated content such as photos, your photo upload system provides a business capability. </p>
<p>When thinking about system design, business capabilities are closely related to the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>) from <strong>object-oriented design</strong> (<strong>OOD</strong>). Microservices are essentially SRP extended to code bases. Thinking about this will help you design appropriately sized microservices. Services should have one primary job and they should do it well. This could be storing and serving images, delivering messages, or creating and authenticating user accounts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Decomposing your monolith by business capability is a process. These steps can be carried out in parallel for each new service you identify a need for, but you may want to start with one service and apply the lessons you learn to subsequent efforts:</p>
<ol>
<li>Identify a business capability that is currently provided by your monolith. This will be the target for our first service. Ideally this business capability is something that has some focus on the roadmap you worked on in the previous recipe and ownership can be given to one of your newly created teams. Let's use our fictional photo messaging service as an example and assume we'll start with the ability to upload and display media as our first identified business capability. This functionality is currently implemented as a single model and controller in your <strong>Ruby on Rails</strong> monolith:</li>
</ol>
<div><img src="img/20a0be37-40db-4825-8f00-684ad75a3153.png" style="width:29.50em;height:13.00em;"/></div>
<ol start="2">
<li>In the preceding screenshot, <strong>AttachmentsController</strong> has four methods (called <strong>actions</strong> in Ruby on Rails lingo), which roughly correspond to the <strong>create, retrieve, update, delete</strong> (<strong>CRUD</strong>) operations you want to perform on an <strong>Attachment</strong> resource. We don't strictly need it, and so will omit the update action. This maps very nicely to a RESTful service, so you can design, implement, and deploy a microservice with the following API:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>POST /attachments</strong><br/><strong>GET /attachments/:id</strong><br/><strong>DELETE /attachments/:id</strong></pre>
<ol start="3">
<li>With the new microservice deployed (migrating data is discussed in a later recipe), you can now begin modifying client code paths to use the new service. You can begin by replacing the code in the <strong>Attachm</strong><strong>entsController</strong> action's methods to make an HTTP request to our new microservice. Techniques for doing this are covered in the <em>Evolving your monolith into services</em> recipe later in this chapter.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying bounded contexts</h1>
                
            
            
                
<p>When designing microservices, a common point of confusion is how big or small a service should be. This confusion can lead engineers to focus on things such as the number of lines of code in a particular service. Lines of code are an awful metric for measuring software; it's much more useful to focus on the role that a service plays, both in terms of the business capability it provides and the domain objects it helps manage. We want to design services that have low coupling with other services, because this limits what we have to change when introducing a new feature in our product or making changes to an existing one. We also want to give services a single responsibility. </p>
<p class="mce-root CDPAlignLeft CDPAlign">When decomposing a monolith, it's often useful to look at the data model when deciding what services to extract. In our fictional image-messaging application, we can imagine the following data model:</p>
<div><img src="img/0a20b515-a676-41c2-a20a-50797c9e1a34.png" style="width:29.92em;height:40.58em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">We have a table for messages, a table for users, and a table for attachments. The <strong>Message</strong> entity has a one-to-many relationship with the <strong>User</strong> entity; every user can have many messages that originate from or are targeted at them, and every message can have multiple attachments. What happens as the application evolves and we add more features? The preceding data model does not include anything about social graphs. Let's imagine that we want a user to be able to follow other users. We'll define the following as a asymmetric relationship, just because user 1 follows user 2, that does not mean that user 2 follows user 1.</p>
<p class="mce-root CDPAlignLeft CDPAlign">There are a number of ways to model this kind of relationship; we'll focus on one of the simplest, which is an adjacency list. Take a look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f253d211-e168-49f1-b637-410ca096db07.png" style="width:41.08em;height:34.83em;"/></p>
<p>We now have an entity, <strong>Followings</strong>, to represent a follow relationship between two users. This works perfectly in our monolith, but introduces a challenge with microservices. If we were to build two new services, one to handle attachments, and another to handle the social graph (two distinct responsibilities), we now have two definitions of the user. This duplication of models is often necessary. The alternative is to have multiple services access and make updates to the same model, which is extremely brittle and can quickly lead to unreliable code.</p>
<p>This is where bounded contexts can help. A bounded context is a term from <strong>Domain-Driven Design</strong> (<strong>DDD</strong>) and it defines the area of a system within which a particular model makes sense. In the preceding example, the social-graph service would have a <strong>User</strong> model whose bounded context would be the users social graph (easy enough). The media service would have a <strong>User</strong> model whose bounded context would be photos and videos. Identifying these bounded contexts is important, especially when deconstructing a monolith—you'll often find that as a monolithic code base grows, the previously discussed business capabilities (uploading and viewing photos and videos, and user relationships) would probably end up sharing the same, bloated <strong>User</strong> model, which will then have to be untangled. This can be a tricky but enlightening and important process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Deciding on how to define bounded contexts within a system can be a rewarding endeavor. The process itself encourages teams to have many interesting discussions about the models in a system and the various interactions that must happen between various systems:</p>
<ol>
<li>Before a team can start to define the bounded contexts it works with, it should first start listing the models that are owned by the parts of the system it works on. For example, the media team will obviously own the <strong>Attachment</strong> model, but it will also need to have information about users, and messages. The <strong>Attachment</strong> model may be entirely maintained within the context of the media teams services, but the others will have to have a well-defined bounded context that can be communicated to other teams if necessary.</li>
<li>Once a team has identified potentially shared models, it's a good idea to have a discussion with other teams that use similar models or the same model.</li>
<li>In those discussions, hammer out the boundaries of the model and decide whether it makes sense to share a model implementation (which in a microservice world would necessitate a service-to-service call) or go their separate ways and develop and maintain separate model implementations. If the choice is made to develop separate model implementations, it'll become important to clearly define the bounded context within which the model applies.</li>
<li>The team should document clear boundaries in terms of teams, specific parts of the application, or specific code bases that should make use of the model.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Migrating data in production</h1>
                
            
            
                
<p>Monolith code bases usually use a primary relational database for persistence. Modern web frameworks are often packaged with <strong>object-relational mapping</strong> (<strong>ORM</strong>), which allows you to define your domain objects using classes that correspond to tables in the database. Instances of these model classes correspond to rows in the table. As monolith code bases grow, it's not uncommon to see additional data stores, such as document or key value stores, be added. </p>
<p>Microservices should not share access with the same database your monolith connects to. Doing so will inevitably cause problems when trying to coordinate data migrations, such as schema changes. Even schema-less stores will cause problems when you change the way data is written in one code base but not how data is read in another code base. For this and other reasons, it's best to have microservices fully manage the data stores they use for persistence.</p>
<p>When transitioning from a monolith to microservices, it's important to have a strategy for how to migrate data. All too often, a team will extract the code for a microservice and leave the data, setting themselves up for future pain. In addition to difficulty managing migrations, a failure in the monolith relational database will now have cascading impacts on services, leading to difficult-to-debug production incidents. </p>
<p>One popular technique for managing large-scale data migrations is to set up dual writing. When your new service is deployed, you'll have two write paths–one from the original monolith code base to its database and one from your new service to its own data store. Make sure that writes go to both of these code paths. You'll now be replicating data from the moment your new service goes into production, allowing you to backfill older data using a script or a similar offline task. Once data is being written to both data stores, you can now modify all of your various read paths. Wherever the code is used to query the monolith database directly, replace the query with a call to your new service. Once all read paths have been modified, remove any write paths that are still writing to the old location. Now you can delete the old data (you have backups, right?). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Migrating data from a monolith database to a new store fronted by a new service, without any impact on availability or consistency, is a difficult but common task when making the transition to microservices. Using our fictional photo-messaging application, we can imagine a scenario where we want to create a new microservice responsible for handling media uploads. In this scenario, we'd follow a common dual-writing pattern:</p>
<ol>
<li>Before writing a new service to handle media uploads, we'll assume that the monolith architecture looks something like the following diagram, where HTTP requests are being handled by the monolith, which presumably reads the multipart/form-encoded content body as a binary object and stores the file in a distributed file store (Amazon's S3 service, for example). Metadata about the file is then written to a database table, called <strong>attachments</strong>, as shown in the following diagram:</li>
</ol>
<div><img src="img/60bd0c1d-4d04-4079-81ea-c976d3d5d6e2.png"/></div>
<p class="mce-root"/>
<ol start="2">
<li>After writing a new service, you now have two write paths. In the write path in the monolith, make a call to your service so that you're replicating the data in the monolith database as well as the database fronted by your new service. You're now duplicating new data and can write a script to backfill older data. Your architecture now looks something like this:</li>
</ol>
<div><img src="img/3bc1de53-10b7-4ef0-b705-2965a33c3efb.png"/></div>
<ol start="3">
<li>Find all read paths in your <strong>Client</strong> and <strong>Monolith</strong> code, and update them to use your new service. All reads will now be going to your service, which will be able to give consistent results.</li>
<li>Find all write paths in your <strong>Client</strong> and <strong>Monolith</strong> code, and update them to use your new service. All reads and writes are now going to your service, and you can safely delete old data and code paths. Your final architecture should look something like the following (we'll discuss edge proxies in later chapters):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/79342aca-e866-4530-a8bf-1efbc114461c.png"/></p>
<p>Using this approach, you'll be able to safely migrate data from a monolith database to a new store created for a new microservice without the need for downtime. It's important not to skip this step; otherwise, you won't truly realize the benefits of microservice architectures (although, arguably, you'll experience all the downsides!). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring your monolith</h1>
                
            
            
                
<p>A common mistake when making the transition to microservices is to ignore the monolith and just build new features as services. This usually happens when a team feels that the monolith has gotten so out of control, and the code so unwieldy, that it would be better to declare bankruptcy and leave it to rot. This can be especially tempting because the idea of building green field code with no legacy baggage sounds a lot nicer than refactoring brittle, legacy code. </p>
<p>Resist the temptation to abandon your monolith. To successfully decompose your monolith by business capability and start evolving it into a set of nicely factored, single-responsibility microservices, you'll need to make sure that your monolith code base is in good shape and is well factored, and well tested. Otherwise, you'll end up with a proliferation of new services that don't model your domain cleanly (because they overlap with functionality in the monolith), and you'll continue to have trouble working with any code that exists in your monolith. Your users won't be happy and your teams' energy will most likely start to decline as the weight of technical debt becomes unbearable. </p>
<p>Instead, take constant, proactive steps to refactor your monolith using good, solid design principles. Excellent books have been written on the subject of refactoring (I recommend <em>Refactoring</em> by Martin Fowler and <em>Working Effectively with Legacy Code</em> by Michael Feathers), but the most important thing to know is that refactoring is never an all-or-nothing effort. Few product teams or companies will have the patience or luxury to wait while an engineering team stops the world and spends time making their code easier to change, and an engineering team that tries this will rarely be successful. Refactoring has to be a constant, steady process. </p>
<p>However your team schedules its work, make sure you're reserving an appropriate time for refactoring. A guiding principle is, whenever you go to make a change, first make the change easy to make, then make the change. Your goal is to make your monolith code easier to work with, easier to understand, and less brittle. You should also be able to develop a robust test suite that will come in handy.</p>
<p>Once your monolith is in better shape, you can start to continuously shrink the monolith as you factor out services. Another aspect of most monolith code bases is serving dynamically generated views and static assets served through browsers. If your monolith is responsible for this, consider moving your web application component into a separately served JavaScript application. This will allow you to shrink your monolith from multiple directions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Refactoring any code base is a process. For monoliths, there are a few techniques that can work quite well. In this example, we'll document the steps that can be taken to make refactoring a Ruby on Rails code base easy:</p>
<ol>
<li class="mce-root">Using the techniques described in previous recipes, identify business capabilities and bounded contexts within your application. Let's focus on the ability to upload pictures and videos. </li>
</ol>
<p> </p>
<ol start="2">
<li>Create a directory called <kbd>app/services</kbd> alongside <kbd>controllers</kbd>, <kbd>models</kbd>, and <kbd>views</kbd>. This directory will hold all of your service objects. Service objects are a pattern used in many Rails applications to factor out a conceptual service into a ruby object that does not inherit any Ruby on Rails functionality. This will make it easier to move the functionality encapsulated within a service object into a separate microservice. There is no one way to structure your service objects. I prefer to have each object represent a service, and move operations I want that service to be responsible for to that service object as methods. </li>
<li>Create a new file called <kbd>attachments_service.rb</kbd> under <kbd>app/services</kbd> and give it the following definition:</li>
</ol>
<pre style="color: black;padding-left: 60px">class AttachmentsService<br/><br/>  def upload<br/>    # ... <br/>  end<br/><br/>  def delete!<br/>    # ...<br/>  end<br/><br/>end</pre>
<ol start="4">
<li>Looking at the source code for the <kbd>AttachmentsController#create</kbd> method in the <kbd>app/controllers/attachments_controller.rb</kbd> file, it currently handles the responsibility for creating the <kbd>Attachment</kbd> instance and uploading the file data to the attachment store, which in this case is an Amazon S3 bucket. This is the functionality that we need to move to the newly created service object:</li>
</ol>
<pre style="color: black;padding-left: 60px"># POST /messages/:message_id/attachments<br/>def create<br/>  message = Message.find_by!(params[:message_id], user_id: <br/>  current_user.id)<br/>  file = StorageBucket.files.create(<br/>    key:  params[:file][:name],<br/>    body: StringIO.new(Base64.decode64(params[:file][:data]),<br/>    'rb'),<br/>    public: true<br/>  )<br/>  attachment = Attachment.new(attachment_params.merge!(message: <br/>  message))<br/>  attachment.url = file.public_url<br/>  attachment.file_name = params[:file][:name]</pre>
<pre style="color: black;padding-left: 60px">  attachment.save<br/>  json_response({ url: attachment.url }, :created)<br/>end</pre>
<ol start="5">
<li>Open the newly created service object in the <kbd>app/services/attachments_service.rb</kbd> file and move the responsibility for uploading the file to the <kbd>AttachmentsService#upload</kbd> method:</li>
</ol>
<pre style="color: black;padding-left: 60px">class AttachmentsService<br/><br/>  def upload(message_id, user_id, file_name, data, media_type)<br/>    message = Message.find_by!(message_id, user_id: user_id)<br/>    file = StorageBucket.files.create(<br/>      key:  file_name,<br/>      body: StringIO.new(Base64.decode64(data), 'rb'),<br/>      public: true<br/>    )<br/>    Attachment.create(<br/>      media_type: media_type,<br/>      file_name:  file_name,<br/>      url:        file.public_url,<br/>      message:    message<br/>    )<br/>  end<br/><br/>  def delete!<br/>  end<br/>end</pre>
<ol start="6">
<li>Now upload the <kbd>AttachmentsController#create</kbd> method in <kbd>app/controllers/attachments_controller.rb</kbd> to use the newly created <kbd>AttachmentsService#upload</kbd> method:</li>
</ol>
<pre style="color: black;padding-left: 60px"># POST /messages/:message_id/attachments<br/>def create<br/>  service = AttachmentService.new<br/>  attachment = service.upload(params[:message_id], current_user.id, <br/>   params[:file][:name], params[:file][:data], <br/>   params[:media_type])<br/>  json_response({ url: attachment.url }, :created)<br/>end</pre>
<ol start="7">
<li>Repeat this process for code in the <kbd>AttachmentsController#destroy</kbd> method, moving the responsibility to the new service object. When you're finished, no code in <kbd>AttachmentsController</kbd> should be interacting with the <kbd>Attachments</kbd> model directly; instead, it should be going through the <kbd>AttachmentsService</kbd> service object.</li>
</ol>
<p>You've now isolated responsibility for the management of attachments to a single service class. This class should encapsulate all of the business logic that will eventually be moved to a new attachment service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Evolving your monolith into services</h1>
                
            
            
                
<p>One of the most complicated aspects of transitioning from a monolith to services can be request routing. In later recipes and chapters, we'll explore the topic of exposing your services to the internet so that the mobile and web client applications can communicate directly with them. For now, however, having your monolith act as a router can serve as a useful intermediary step. </p>
<p>As you break your monolith into small, maintainable microservices, you can replace code paths in your monolith with calls to your services. Depending on the programming language or framework you used to build your monolith, these sections of code can be called controller actions, views, or something else. We'll continue to assume that your monolith was built in the popular Ruby on Rails framework; in which case, we'll be looking at controller actions. We'll also assume that you've begun refactoring your monolith and have created one or more service objects as described in the previous recipe.</p>
<p>It's important when doing this to follow best practices. In later chapters, we'll introduce concepts, such as circuit breakers, that become important when doing service-to-service communication. For now, be mindful that HTTP calls from your monolith to a service could fail, and you should consider how best to handle that kind of situation. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open the service object we created in the previous recipe. We'll modify the service object to be able to call an external microservice responsible for managing attachments. For the sake of simplicity, we'll use an HTTP client that is provided in the Ruby standard library. The service object should be in the <kbd>app/services/attachments_service.rb</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">class AttachmentsService<br/><br/>  BASE_URI = "http://attachment-service.yourorg.example.com/"<br/><br/>  def upload(message_id, user_id, file_name, data, media_type)<br/>    body = {<br/>      user_id: user_id,<br/>      file_name: file_name,<br/>      data: StringIO.new(Base64.decode64(params[:file]<br/>      [:data]), 'rb'),<br/>      message: message_id,<br/>      media_type: media_type<br/>    }.to_json<br/>    uri = URI("#{BASE_URI}attachment")<br/>    headers = { "Content-Type" =&gt; "application/json" }<br/>    Net::HTTP.post(uri, body, headers)<br/>  end<br/><br/>end</pre>
<ol start="2">
<li>Open the <kbd>attachments_controller.rb</kbd> file, located in <kbd>pichat/app/controllers/</kbd>, and look at the following create action. Because of the refactoring work done in the previous chapter, we require only a small change to make the controller work with our new service object:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">class AttachmentsController &lt; ApplicationController<br/>  # POST /messages/:message_id/attachments<br/>  def create<br/>    service = AttachmentService.new<br/>    response = service.upload(params[:message_id], current_user.id,<br/>     params[:file][:name], params[:file][:data], <br/>     params[:media_type])<br/>    json_response(response.body, response.code)<br/>  end<br/>  # ...<br/>end</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Evolving your test suite</h1>
                
            
            
                
<p>Having a good test suite in the first place will help tremendously as you move from a monolith to microservices. Each time you remove functionality from your monolith code base, your tests will need to be updated. It's tempting to replace unit and functional tests in your Rails app with tests that make external network calls to your services, but this approach has a number of downsides. Tests that make external calls will be prone to failures caused by intermittent network connectivity issues and will take an enormous amount of time to run after a while.</p>
<p>Instead of making external network calls, you should modify your monolith tests to stub microservices. Tests that use stubs to represent calls to microservices will be less brittle and will run faster. As long as your microservices satisfy the API contracts you develop, the tests will be reliable indicators of your monolith code base's health. Making backwards-incompatible changes to your microservices is another topic that will be covered in a later recipe. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the <kbd>webmock</kbd> gem for stubbing out external HTTP requests in our tests, so update your monolith gemfile to include the <kbd>webmock</kbd> gem in the test group:</p>
<pre>group :test do<br/>  # ...<br/>  gem 'webmock'<br/>end</pre>
<p>You should also update <kbd>spec/spec_helper.rb</kbd> to disable external network requests. That will keep you honest when writing the rest of your test code:</p>
<pre>require 'webmock/rspec'<br/>WebMock.disable_net_connect!(allow_localhost: false)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now that you have <kbd>webmock</kbd> included in your project, you can start stubbing HTTP requests in your specs. Once again, open <kbd>specs/spec_helper.rb</kbd> and add the following content:</p>
<pre>stub_request(:post, "attachment-service.yourorg.example.com").
  with(body: {media_type: 1}, headers: {"Content-Type" =&gt; /image\/.+/}).
  to_return(body: { foo: bar })</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Docker for local development</h1>
                
            
            
                
<p>As we've discussed, microservices solve a particular set of problems but introduce some new challenges of their own. One challenge that engineers on your team will probably run into is doing local development. With a monolith, there are fewer moving parts that have to be managed—usually, you can get away with just running a database and an application server on your workstation to get work done. As you start to create new microservices, however, the situation gets more complicated. </p>
<p>Containers are a great way to manage this complexity. Docker is a popular, open source software containerization platform. Docker allows you to specify how to run your application as a container—a lightweight standardized unit for deployment. There are plenty of books and online documentation about Docker, so we won't go into too much detail here, just know that a container encapsulates all of the information needed to run your application. As mentioned, a monolith application will often require an application server and a database server at a minimum—these will each run in their own container.</p>
<p><strong>Docker Compose</strong> is a tool for running multicontainer applications. Compose allows you to define your applications containers in a YAML configuration file. Using the information in this file, you can then build and run your application. Compose will manage all of the various services defined in the configuration file in separate containers, allowing you to run a complex system on your workstation for local development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before you can follow the steps in this recipe, you'll need to install the required software:</p>
<ol>
<li>Install Docker. Download the installation package from the Docker website (<a href="https://www.docker.com/docker-mac">https://www.docker.com/docker-mac</a>) and follow the instructions.</li>
<li>Install <kbd>docker-compose</kbd> by executing the following command line on macOS X:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>brew install docker-compose</strong></pre>
<p class="mce-root" style="padding-left: 60px">On Ubuntu Linux, you can execute the following command line:</p>
<pre style="color: black;padding-left: 60px"><strong>apt-get install docker-compose</strong></pre>
<p>With those two packages installed, you'll be ready to follow the steps in this recipe.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>In the root directory of your Rails application, create a single file called <kbd>Dockerfile</kbd> with the following contents:</li>
</ol>
<pre style="color: black;padding-left: 30px"><strong>  FROM ruby:2.3.3</strong><br/><strong>  RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential </strong><br/><strong>  libpq-dev nodejs
  RUN mkdir /pichat
  WORKDIR /pichat
  ADD Gemfile /pichat/Gemfile
  ADD Gemfile.lock /pichat/Gemfile.lock
  RUN bundle install
  ADD . /pichat</strong></pre>
<ol start="2">
<li>Create a file called <kbd>docker-compose.yml</kbd> with the following contents:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>version: '3'</strong><br/><strong>services:</strong><br/><strong>  db:</strong><br/><strong>    image: mysql:5.6.34</strong><br/><strong>    ports:</strong><br/><strong>      - "3306:3306"</strong><br/><strong>    environment:</strong><br/><strong>      MYSQL_ROOT_PASSWORD: root</strong><br/><br/><strong>  app:</strong><br/><strong>    build: .</strong><br/><strong>    environment:</strong><br/><strong>      RAILS_ENV: development</strong><br/><strong>    command: bundle exec rails s -p 3000 -b '0.0.0.0'</strong><br/><strong>    volumes:</strong><br/><strong>      - .:/pichat<br/></strong><strong>    ports:</strong><br/><strong>      - "3000:3000"</strong><br/><strong>    depends_on:</strong><br/><strong>      - db</strong></pre>
<ol start="3">
<li>Start your application by running the <kbd>docker-compose up app</kbd> command. You should be able to access your monolith by entering <kbd>http://localhost:3000/</kbd> in your browser. You can use this approach for new services that you write.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Routing requests to services</h1>
                
            
            
                
<p>In previous recipes, we focused on having your monolith route requests to services. This technique is a good start since it requires no client changes to work. Your clients still make requests to your monolith and your monolith marshals the request to your microservices through its controller actions. At some point, however, to truly benefit from a microservices architecture, you'll want to remove the monolith from the critical path and allow your clients to make requests to your microservices. It's not uncommon for an engineer to expose their organization's first microservice to the internet directly, usually using a different hostname. However, this starts to become unmanageable as you develop more services and need a certain amount of consistency when it comes to monitoring, security, and reliability concerns.</p>
<p>Internet-facing systems face a number of challenges. They need to be able to handle a number of security concerns, rate limiting, periodic spikes in traffic, and so on. Doing this for each service you expose to the public internet will become very expensive, very quickly. Instead, you should consider having a single edge service that supports routing requests from the public internet to internal services. A good edge service should support common features, such as dynamic path rewriting, load shedding, and authentication. Luckily, there are a number of good open source edge service solutions. In this recipe, we'll use a Netflix project called <strong>Zuul</strong>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new Spring Boot service called <kbd>Edge Proxy</kbd> with a main class called <kbd>EdgeProxyApplication</kbd>.</li>
<li>Spring Cloud includes an embedded Zuul proxy. Enable it by adding the <kbd>@EnableZuulProxy</kbd> annotation to your <kbd>EdgeProxyApplication</kbd> class:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br/><br/>@EnableZuulProxy<br/>@SpringBootApplication<br/>public class EdgeProxyApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(EdgeProxyApplication.class, args);<br/>  }<br/><br/>}</pre>
<ol start="3">
<li class="mce-root">Create a file called <kbd>application.properties</kbd> under <kbd>src/main/resources/</kbd> with the following contents:</li>
</ol>
<pre class="mce-root" style="color: black;padding-left: 60px">zuul.routes.media.url=http://localhost:8090<br/>ribbon.eureka.enabled=false<br/>server.port=8080</pre>
<p class="mce-root" style="padding-left: 60px">In the preceding code, it tells <kbd>zuul</kbd> to route requests to <kbd>/media</kbd> to a service running on port <kbd>8090</kbd>. We'll touch on that <kbd>eureka</kbd> option in later chapters when we discuss service discovery, for now just make sure it's set to <kbd>false</kbd>. </p>
<p>At this point, your service should be able to proxy requests to the appropriate service. You've just taken one of the biggest steps toward building a microservices architecture. Congratulations!</p>


            

            
        
    </body></html>