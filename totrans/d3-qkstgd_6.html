<html><head></head><body>
        

                            
                    <h1 class="header-title">Animating SVG Elements to Create an Interactive Pie Chart</h1>
                
            
            
                
<p>In this chapter, we'll be use animation to make our graphs move. This can give your visualizations a more polished and professional feel.</p>
<p>In this section, we will cover the following topics:</p>
<ul>
<li>Creating an ordinal scale</li>
<li>Creating a color scale</li>
<li>Adding paths for each pie segment</li>
<li>Generating an arc creating function</li>
<li>Formatting the data for the arc</li>
<li>Adjusting the position of the pie</li>
<li>Making a donut graph</li>
<li>Removing parts of the pie</li>
</ul>
<p>The complete code for this section can be found at <a href="https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06">https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the application</h1>
                
            
            
                
<p>As always, we'll need an <kbd>index.html</kbd> file to house our SVG code. Let's create the file and add the following code to it:</p>
<div><pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script src="img/d3.v5.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;svg&gt;
            &lt;g&gt;&lt;/g&gt;
        &lt;/svg&gt;
        &lt;script src="img/app.js" charset="utf-8"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Create data/configuration variables</h1>
                
            
            
                
<p>At the bottom of the <kbd>&lt;body&gt;</kbd> tag, we're referencing an <kbd>app.js</kbd> file. Let's create that file and add the following code to it:</p>
<div><pre>var WIDTH = 360;
var HEIGHT = 360;
var radius = Math.min(WIDTH, HEIGHT) / 2;

var dataset = [
    { label: 'Bob', count: 10 },
    { label: 'Sally', count: 20 },
    { label: 'Matt', count: 30 },
    { label: 'Jane', count: 40 }
];
console.log(dataset);</pre></div>
<p>To be sure that it's working and linked up properly, we've added <kbd>console.log(dataset)</kbd> to the bottom. Let's open <kbd>index.html</kbd> in Chrome and view the developer console, to make sure that everything is hooked up the way it should be:</p>
<div><img src="img/614496bf-68b5-46c3-a3f7-8987be6399ac.png" style=""/></div>
<p>Once we're sure that it's working, we can remove <kbd>console.log(dataset)</kbd>;, as follows:</p>
<div><pre>var WIDTH = 360;
var HEIGHT = 360;
var radius = Math.min(WIDTH, HEIGHT) / 2;

var dataset = [
    { label: 'Bob', count: 10 },
    { label: 'Sally', count: 20 },
    { label: 'Matt', count: 30 },
    { label: 'Jane', count: 40 }
];</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an ordinal scale</h1>
                
            
            
                
<p>An ordinal scale maps a discrete value to some other value. A discrete value is something that can't be divided. Previously, we've used values such as numbers that can be divided up and interpolated. Interpolated just means that for any two numbers, we can find other numbers in between them. For instance, given 10 and 5, we can find values between them (6, 8.2, 7, 9.9, and so on). Now, we want to map values that can't be interpolatedâ€”the label properties in our dataset (Bob, Sally, Matt, and Jane). What values lie between Bob and Sally? What about between Bob and Matt? There are none. These are just strings, not numerical values that can be divided up and interpolated.</p>
<p>What we want to do is map these discrete values to other values. The following is an example of how to do this with an ordinal scale. Add the following to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>var mapper = d3.scaleOrdinal();
mapper.range([45, 63, 400]); //list each value for ordinal scales, not just min/max
mapper.domain(['Bob', 'Sally', 'Zagthor']); //list each value for ordinal scales, not just min/max

console.log(mapper('Bob'));
console.log(mapper('Sally'));
console.log(mapper('Zagthor'));</pre></div>
<p>The previous code should produce the following:</p>
<div><img src="img/6119e550-d852-4c66-b6d4-0826bb07ea53.png" style=""/></div>
<p>Note that when you are working with ordinal scales, you'll need to list all of the values for both the domain and range. Even if one set is numerical (in the previous case, the range), you'll still have to list each value. If we just listed the min/max for the range, omitting63, D3 would have no idea what value to map Sally to. After all, how close is Sally to Bob,as a value? How close is Sally to Zagth or, as a value? There's no way to calculate that distance, since they're all strings of text, not numbers.</p>
<p>One thing that's surprising is that you can't invert ordinal scales. Remove the previous three <kbd>console.log()</kbd> statements and temporarily add the following to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>console.log(mapper.invert(45));</pre>
<p>The following will be displayed:</p>
<div><img class="aligncenter size-full wp-image-429 image-border" src="img/3dcec0f1-1823-421c-a200-03442ae29824.png" style=""/></div>
</div>
<p>D3 can only go in one direction: from domain to range. You can now remove the <kbd>console.log()</kbd> statement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the color scale to map labels to colors</h1>
                
            
            
                
<p>Now, we want to map the label properties of our dataset to colors, instead of random numbers, like in the previous section. We can come up with our own color scheme, or we choose one of D3's sets of colors from <a href="https://github.com/d3/d3-scale-chromatic#categorical">https://github.com/d3/d3-scale-chromatic#categorical</a>.<a href="https://github.com/d3/d3-scale-chromatic#categorical"/></p>
<p>If we want to, we can see that these color schemes are just arrays. Temporarily, add the following to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>console.log(d3.schemeCategory10)</pre>
<p>The following content will be displayed:</p>
<div><img src="img/7408b48d-b675-4f6f-8ef1-6ad550d96e00.png"/></div>
</div>
<p>Consequently, we can use a color scheme when setting a range. Replace the previous <kbd>console.log()</kbd> statement with the following:</p>
<div><pre>var colorScale = d3.scaleOrdinal();
colorScale.range(d3.schemeCategory10);</pre></div>
<p>We can generate an array of labels for the domain by using JavaScript's native <kbd>map</kbd> function. Add the following to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>colorScale.domain(dataset.map(function(element){
    return element.label;
}));</pre></div>
<p>The following is our code, so far:</p>
<div><pre>var WIDTH = 360;
var HEIGHT = 360;
var radius = Math.min(WIDTH, HEIGHT) / 2;

var dataset = [
    { label: 'Bob', count: 10 },
    { label: 'Sally', count: 20 },
    { label: 'Matt', count: 30 },
    { label: 'Jane', count: 40 }
];

var colorScale = d3.scaleOrdinal();
colorScale.range(d3.schemeCategory10);
colorScale.domain(dataset.map(function(element){
    return element.label;
}));</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the SVG</h1>
                
            
            
                
<p>The next code block is pretty standard. Add the following code to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>d3.select('svg')
    .attr('width', WIDTH)
    .attr('height', HEIGHT);</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding paths for each pie segment</h1>
                
            
            
                
<p>Let's add path elements for each element in our dataset. Add the following code to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(dataset)
    .enter()
    .append('path')
    .attr('fill', function(d) {
        return colorScale(d.label);
    });</pre></div>
<p>If we examine our elements in the developer tools, we'll see that the paths were added, and each path has a fill value, as determined by <kbd>colorScale(d.label)</kbd>, which is mapping the label of each data object to a color:</p>
<div><img src="img/44c97e7f-30fd-4b1e-9c1d-3382e11fbc2d.png" style=""/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Generating an arc creating function</h1>
                
            
            
                
<p>The paths have fill colors, but no shapes. If you'll recall, the <kbd>&lt;path&gt;</kbd> elements take a <kbd>d=</kbd> attribute, which determines how they're drawn. We want to set up something that will somehow map data to a <kbd>d=</kbd> string, such as the following code (you don't have to add the next code snippet; it's only there for reference):</p>
<div><pre>.attr('d', function(datum){
    //return path string here
})</pre></div>
<p>Fortunately, D3 can generate the anonymous function that we need for the second parameter of <kbd>.attr()</kbd> in the previous code snippet. Add the following to <kbd>app.js</kbd>, just before our previous code for <kbd>var path = d3.select('g').selectAll('path')...</kbd>:</p>
<div><pre>var arc = d3.arc()
    .innerRadius(0) //to make this a donut graph, adjust this value
    .outerRadius(radius);</pre></div>
<p>Let's plug this function into its correct place in our previous <kbd>var path = d3.select('g').selectAll('path')...</kbd> code (it won't work yet, though):</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(dataset)
    .enter()
    .append('path')
    .attr('d', arc) //add this
    .attr('fill', function(d) {
        return colorScale(d.label);
    });</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Formatting the data for the arc</h1>
                
            
            
                
<p>The reason that our <kbd>arc()</kbd> function won't work is the data isn't formatted properly for the function. The arc function that we generated expects the data object to have things like a start angle, an end angle, and so on. Fortunately, D3 can reformat our data so that it will work with our generated <kbd>arc()</kbd> function. To do this, we'll generate a <kbd>pie</kbd> function that will take a dataset and add the necessary attributes to it for the start angle, end angle, and so on. Add the following just before the code for <kbd>var path =d3.select('g').selectAll('path')...</kbd>:</p>
<div><pre>var pie = d3.pie()
    .value(function(d) { return d.count; }) //use the 'count' property each value in the original array to determine how big the piece of pie should be
    .sort(null); //don't sort the values</pre></div>
<p>Our <kbd>pie</kbd> variable is a function that takes an array of values as a parameter and returns an array of objects that are formatted for our <kbd>arc</kbd> function. Temporarily add the following code to the bottom of <kbd>app.js</kbd>, and take a look at the console in Chrome's Developer tools:</p>
<div><pre>console.log(pie(dataset));</pre>
<p>The following content will be displayed:</p>
<div><img class="aligncenter size-full wp-image-432 image-border" src="img/ce1dd5be-eba8-4b98-b307-a240815fa091.png" style=""/></div>
</div>
<p>You can now remove the <kbd>console.log(pie(dataset))</kbd> call. We can use this <kbd>pie()</kbd> function when attaching data to our paths. Adjust the previous <kbd>var path = d3.select('g').selectAll('path')</kbd> code, as follows:</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(pie(dataset)) //adjust this line to reformat data for arc
    .enter()
    .append('path')
    .attr('d', arc)
    .attr('fill', function(d) {
        return colorScale(d.label);
    });</pre></div>
<p>Unfortunately, now, each object from the data array that's been attached to our path elements doesn't have a <kbd>.label</kbd> property, so our code for <kbd>.attr('fill', function(d) {})</kbd>is broken. Fortunately, our data does have a <kbd>.data</kbd> attribute that mirrors what the data looked like before we passed it to the <kbd>pie()</kbd> function. Let's adjust our <kbd>var path = d3.select('g').selectAll('path')</kbd> code to use that code, instead, as follows:</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(pie(dataset))
    .enter()
    .append('path')
    .attr('d', arc)
    .attr('fill', function(d) {
        return colorScale(d.data.label); //use .data property to access <br/>        original data
    });</pre></div>
<p>So far, our code is as follows:</p>
<div><pre>var WIDTH = 360;
var HEIGHT = 360;
var radius = Math.min(WIDTH, HEIGHT) / 2;

var dataset = [
    { label: 'Bob', count: 10 },
    { label: 'Sally', count: 20 },
    { label: 'Matt', count: 30 },
    { label: 'Jane', count: 40 }
];

var mapper = d3.scaleOrdinal();
var colorScale = d3.scaleOrdinal();
colorScale.range(d3.schemeCategory10);
colorScale.domain(dataset.map(function(element){
    return element.label;
}));

d3.select('svg')
    .attr('width', WIDTH)
    .attr('height', HEIGHT);

var arc = d3.arc()
    .innerRadius(0)
    .outerRadius(radius);

var pie = d3.pie()
    .value(function(d) { return d.count; })
    .sort(null);

var path = d3.select('g').selectAll('path')
    .data(pie(dataset))
    .enter()
    .append('path')
    .attr('d', arc)
    .attr('fill', function(d) {
        return colorScale(d.data.label);
    });</pre></div>
<p>The preceding code produces the following result:</p>
<div><img src="img/817b382e-5517-4c82-88e1-63ef00034860.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adjusting the position of the pie</h1>
                
            
            
                
<p>Currently, we can only see the lower-right quarter of the pie graph. This is because the pie starts at (<kbd>0,0</kbd>), but we can move the <kbd>group</kbd> element containing the pie by adjusting our <kbd>d3.select('svg')</kbd> code, as follows:</p>
<div><pre>d3.select('svg')<br/>    .attr('width', WIDTH)<br/>    .attr('height', HEIGHT);<br/>var container = d3.select('g') //add this line and the next:<br/>    .attr('transform', 'translate(' + (WIDTH / 2) + ',' + (HEIGHT / 2) + ')'); //add this line</pre></div>
<p>The pie graph now looks as follows:</p>
<div><img class="aligncenter size-full wp-image-434 image-border" src="img/39092768-e765-496e-a7b7-a452e7c3700b.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a donut graph</h1>
                
            
            
                
<p>If you want the pie to have a hole in the center, just adjust the inner radius of the <kbd>arc()</kbd> function, as follows:</p>
<div><pre>var arc = d3.arc()
    .innerRadius(100) //to make this a donut graph, adjust this value
    .outerRadius(radius);</pre></div>
<p>The graph will now look as follows:</p>
<div><img class="aligncenter size-full wp-image-435 image-border" src="img/c024f1ea-ae2a-4f3a-b0ab-1286566a5108.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing parts of the pie</h1>
                
            
            
                
<p>We want to make it possible to click on a section of the pie to remove it. First, let's add IDs to our data, to make the removal easier. Adjust the <kbd>var dataset</kbd> code at the top of <kbd>app.js</kbd>:</p>
<div><pre>var dataset = [
    { id: 1, label: 'Bob', count: 10 }, //add id property
    { id: 2, label: 'Sally', count: 20 }, //add id property
    { id: 3, label: 'Matt', count: 30 }, //add id property
    { id: 4, label: 'Jane', count: 40 } //add id property
];</pre></div>
<p>Now, let's use those IDs when we map data to paths. Adjust the <kbd>.data()</kbd> portion of our <kbd>var path =d3.select('g').selectAll('path')</kbd>code at the bottom of <kbd>app.js</kbd>, as follows:</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(pie(dataset), function(datum){ //attach datum.data.id to each element
        return datum.data.id
    })</pre></div>
<p>Let's save a record of the current data for each element by adding a <kbd>_current</kbd> property to each element (we'll use this later). Add <kbd>.each(function(d) { this._current = d; });</kbd>to the end of our <kbd>var path =d3.select('g')</kbd> code, at the bottom of <kbd>app.js</kbd>:</p>
<div><pre>var path = d3.select('g').selectAll('path')
    .data(pie(dataset), function(datum){
        return datum.data.id
    })
    .enter()
    .append('path')
    .attr('d', arc)
    .attr('fill', function(d) {
        return colorScale(d.data.label);
    })//watch out! remove the semicolon here
    .each(function(d) { this._current = d; }); //add this</pre></div>
<p>Create the click handler by adding the following code to the bottom of <kbd>app.js</kbd>:</p>
<div><pre>path.on('click', function(clickedDatum, clickedIndex){<br/>});</pre></div>
<p>Remove the selected data from the dataset array, using JavaScript's native <kbd>filter</kbd> function. Adjust the code that we just added, as follows:</p>
<div><pre>path.on('click', function(clickedDatum, clickedIndex){
    dataset = dataset.filter(function(currentDatum, currentIndex){ //new
        return clickedDatum.data.id !== currentDatum.id //new
    }); //new
});</pre></div>
<p>Remove the <kbd>path</kbd> elements from the SVG by adding the following to our click handler function:</p>
<div><pre>path.on('click', function(clickedDatum, clickedIndex){
    dataset = dataset.filter(function(currentDatum, currentIndex){
        return clickedDatum.data.id !== currentDatum.id
    });
    path //new
        .data(pie(dataset), function(datum){ //new
            return datum.data.id //new
        }) //new
        .exit().remove(); //new
});</pre></div>
<p>Now, if we click on the orange segment, we should get the following result:</p>
<div><img class="aligncenter size-full wp-image-436 image-border" src="img/86789fa3-405b-4ffb-9a98-89f744dd1b2c.png" style=""/></div>
<p>Let's close the donut and add a transition. Add the following to the bottom of our click handler. Check out the comments in the following code to see what each line does:</p>
<div><pre>path.on('click', function(clickedDatum, clickedIndex){
    dataset = dataset.filter(function(currentDatum, currentIndex){
        return clickedDatum.data.id !== currentDatum.id
    });
    path
        .data(pie(dataset), function(datum){
            return datum.data.id
        })
        .exit().remove();

    path.transition() //create the transition
        .duration(750) //add how long the transition takes
        .attrTween('d', function(d) { //tween the d attribute
            var interpolate = d3.interpolate(this._current, d); <br/>            //interpolate <br/>            from what the d attribute was and what it is now
            this._current = interpolate(0); //save new value of data
            return function(t) { //re-run the arc function:
                return arc(interpolate(t));
            };
        });
});</pre></div>
<p class="CDPAlignLeft CDPAlign">Now, when we click on the orange segment, the donut closes smoothly, as follows:</p>
<div><img class="aligncenter size-full wp-image-437 image-border" src="img/acd510e8-3252-44b5-bd20-2cdddca0ecce.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we created a pie chart that animates when you remove sections from it. You learned how to generate paths from data, so that you can get different parts of the pie without having to specify the drawing commands directly in the path elements. You also learned how to use animation to make visualizations look more professional. Finally, you learned how to remove sections of the pie and have the other path elements redraw themselves, so that the result will be a full pie.</p>
<p>In the next chapter, we will use D3 to create a graph that visualizes the relationships between various nodes of data.</p>


            

            
        
    </body></html>