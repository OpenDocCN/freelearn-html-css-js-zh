<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Saving Form Data</h1>
<p>The preceding chapter introduced Playwright and SvelteKit routes. The data in our <strong class="source-inline">/birthdays</strong> route was hardcoded. In this chapter, we’ll force the <em class="italic">real</em> implementation of the <strong class="source-inline">load</strong> function by adding the ability to add new birthdays into <span class="No-Break">the system.</span></p>
<p><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em> shows the new form we’ll be building. It is attached to the bottom of the birthday list at the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">birthdays</strong></span><span class="No-Break"> route:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 4.1 – The form for adding a new birthday" height="240" src="image/Figure_4.1_B19611.jpg" width="1052"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The form for adding a new birthday</p>
<p>This chapter covers the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Adding a Playwright test for <span class="No-Break">data input</span></li>
<li>Test-driving a <span class="No-Break">SvelteKit form</span></li>
<li>Test-driving a SvelteKit <span class="No-Break">form action</span></li>
</ul>
<p>By the end of the chapter, you’ll have a good understanding of how to test-drive <span class="No-Break">SvelteKit forms.</span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter04/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter04/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Adding a Playwright test for data input</h1>
<p>Go ahead<a id="_idIndexMarker103"/> and add this test to <strong class="source-inline">tests/birthdays.test.js</strong>. It includes <a id="_idIndexMarker104"/>all the steps required for adding a new birthday to <span class="No-Break">the system:</span></p>
<pre class="source-code">
test('saves a new birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  await page.getByLabel('Name').fill('Persephone');
  await page
    .getByLabel('Date of birth')
    .fill('1985-01-01');
  await page.getByRole('button').click();
  await expect(
    page.getByText('Persephone')
  ).toBeVisible();
});</pre>
<p>After navigating to the <strong class="source-inline">/birthdays</strong> endpoint, it uses the <strong class="source-inline">getByLabel</strong> locator function to find an <strong class="source-inline">input</strong> field that has a <strong class="source-inline">Name</strong> label. This is standard HTML functionality using the <strong class="source-inline">label</strong> and <strong class="source-inline">input</strong> elements, which we’ll see in the <span class="No-Break">next section.</span></p>
<p>We use the <strong class="source-inline">fill</strong> function to enter a value into this field, and then we repeat the process for the <strong class="source-inline">Date of birth</strong> field. Then, we click the button (any button!), and finally, we check that the <strong class="source-inline">Persephone</strong> text appears somewhere on <span class="No-Break">the page.</span></p>
<p>An important distinction to make here is that <strong class="source-inline">getByText</strong> checks page text rather than, say, the values of the <strong class="source-inline">input</strong> fields. So, we can’t just fill in the <strong class="source-inline">Name</strong> field and then watch the expectation <span class="No-Break">magically pass.</span></p>
<p>The intent <a id="_idIndexMarker105"/>of the Playwright test is to show that the following steps <span class="No-Break">are performed:</span></p>
<ol>
<li>The user fills in a name and date <span class="No-Break">of birth.</span></li>
<li>The user presses the <span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break"> button.</span></li>
<li>The system records the birthday in <span class="No-Break">its system.</span></li>
<li>The browser refreshes the page, and the new birthday is displayed as part of the loaded <span class="No-Break">page data.</span></li>
</ol>
<p>With all that <a id="_idIndexMarker106"/>in mind, the process we’ll use to make the test pass is <span class="No-Break">as follows:</span></p>
<ol>
<li>First, we’ll build a new <strong class="source-inline">BirthdayForm</strong> component that displays a basic HTML form with two input fields and <span class="No-Break">a button.</span></li>
<li>Then, we’ll add this to the existing <strong class="source-inline">+page.svelte</strong> file that we built in the <span class="No-Break">preceding chapter.</span></li>
<li>Finally, we’ll add a form action to add this birthday, including introducing a new data structure to hold our birthdays in <span class="No-Break">the server.</span></li>
</ol>
<p>That covers our up-front design, all wrapped up in a Playwright test. Next, we can begin test-driving <span class="No-Break">the form.</span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Test-driving a SvelteKit form</h1>
<p>In <a id="_idIndexMarker107"/>this section, you’ll construct a new component named <strong class="source-inline">BirthdayForm</strong>, together with its test suite. This component is an HTML form that comprises two text fields: <strong class="source-inline">name</strong> and <strong class="source-inline">dob</strong>. Each <strong class="source-inline">input</strong> element has a corresponding <strong class="source-inline">label</strong> element. There’s also a button named <strong class="bold">Save</strong> that submits <span class="No-Break">the form.</span></p>
<p>SvelteKit handles the submission of our form data from the client to the server. We won’t test this behavior in our Vitest test suites, instead leaving it up to the Playwright tests to ensure that all pieces slot <span class="No-Break">together correctly.</span></p>
<p>Follow these <a id="_idIndexMarker108"/>steps to build the <span class="No-Break">new form:</span></p>
<ol>
<li>Create a new file named <strong class="source-inline">src/routes/birthdays/BirthdayForm.test.js</strong> with the following first test. This uses the <strong class="source-inline">queryByRole</strong> query function to find an element with the <strong class="source-inline">form</strong> role on <span class="No-Break">the page:</span><pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import BirthdayForm from './BirthdayForm.svelte';
describe('BirthdayForm', () =&gt; {
  it('displays a form', () =&gt; {
    render(BirthdayForm);
    expect(screen.queryByRole('form')).toBeVisible();
  });
});</pre></li>
<li>Make sure you run the test and watch <span class="No-Break">it fail.</span></li>
<li>Then, create a new file named <strong class="source-inline">src/routes/birthdays/BirthdayForm.svelte</strong> with the <span class="No-Break">following content:</span><pre class="source-code">
&lt;form /&gt;</pre></li>
<li>If you run tests now, you’ll see the test still doesn’t pass. That’s because the <strong class="source-inline">form</strong> role only becomes available once you <em class="italic">name</em> a form. Update the implementation <span class="No-Break">as follows:</span><pre class="source-code">
&lt;form <strong class="bold">name="birthday"</strong> /&gt;</pre></li>
<li>The test <a id="_idIndexMarker109"/>should now pass. Add the next test, as shown in the following code block. This test simply checks that we submit the form via a <strong class="source-inline">POST</strong> request, which is the usual mechanism for submitting new data to <span class="No-Break">the server:</span><pre class="source-code">
it('has a form method of POST', () =&gt; {
  render(BirthdayForm);
  expect(screen.getByRole('form').method).toEqual(
    'post'
  );
});</pre></li>
<li>Make that pass by adding the <strong class="source-inline">method</strong> attribute, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;form <strong class="bold">method="post"</strong> name="birthday" /&gt;</pre></li>
<li>Then, add the third test, as shown in the following <span class="No-Break">code block:</span><pre class="source-code">
it('displays a button to save the form', () =&gt; {
  render(BirthdayForm);
  expect(
    screen.queryByRole('button')
  ).toBeVisible();
});</pre></li>
<li>To make that pass, add an <strong class="source-inline">input</strong> element into the form with a <strong class="source-inline">type</strong> attribute set to <strong class="source-inline">submit</strong>. You can also give it <strong class="source-inline">value</strong> as <strong class="source-inline">Save</strong>, which will be used as the <span class="No-Break">button name:</span><pre class="source-code">
&lt;form method="post" name="birthday"&gt;
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
<li>For the next <a id="_idIndexMarker110"/>test, we will introduce a nested <strong class="source-inline">describe</strong> block called <strong class="source-inline">name field</strong>. We can add a block here for grouping in anticipation of more tests for this field. We’ll be adding some more in <a href="B19611_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Validating </em><span class="No-Break"><em class="italic">Form Data</em></span><span class="No-Break">:</span><pre class="source-code">
describe('name field', () =&gt; {
  it('displays a text field for the contact name', ()
  =&gt; {
    render(BirthdayForm);
    const field = screen.queryByLabelText('Name', {
      selector: 'input[type=text]'
    });
    expect(field).toBeVisible();
    expect(field.name).toEqual('name');
  });
});</pre></li>
</ol>
<p>This test makes use of the <strong class="source-inline">queryByLabelText</strong> function. This is analogous to the <strong class="source-inline">page.getByLabel</strong> function that was used in the <span class="No-Break">Playwright test.</span></p>
<p>There is something else in this <a id="_idIndexMarker111"/>test that is important: the <strong class="bold">cascading style sheets</strong> (<strong class="bold">CSS</strong>) selector of <strong class="source-inline">input[type=text]</strong>. It’s not very clear from the test, but the first expectation in this test checks all of <span class="No-Break">the following:</span></p>
<ul>
<li>That a <strong class="source-inline">label</strong> element exists with the <span class="No-Break"><strong class="source-inline">Name</strong></span><span class="No-Break"> text</span></li>
<li>That an <strong class="source-inline">input</strong> element exists with the <strong class="source-inline">type</strong> attribute set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">text</strong></span></li>
<li>That the <strong class="source-inline">label</strong> element is associated with the <span class="No-Break"><strong class="source-inline">input</strong></span><span class="No-Break"> element</span></li>
</ul>
<p>Part of these<a id="_idIndexMarker112"/> checks come from the selector expression itself. Without an explanation or understanding of the selector syntax, it’s hard to know the intent behind <span class="No-Break">this expectation.</span></p>
<p>There’s also a second expectation in there to check that the <strong class="source-inline">name</strong> attribute is set. This is important so that the SvelteKit form action gets the right named parameters back. We’ll add this parameter, <strong class="source-inline">name</strong>, and in the next test, we’ll add another one <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">dob</strong></span><span class="No-Break">.</span></p>
<p>In <a href="B19611_08.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating Matchers to Simplify Tests</em>, we’ll refactor these expectations to improve <span class="No-Break">their readability.</span></p>
<p>Let’s carry on with the <span class="No-Break">next steps:</span></p>
<ol>
<li>To make the test pass, go ahead and add the <strong class="source-inline">label</strong> and <strong class="source-inline">input</strong> elements, as shown in the following <span class="No-Break">code block:</span><pre class="source-code">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  &lt;label&gt;</strong>
<strong class="bold">    Name</strong>
<strong class="bold">    </strong><strong class="bold">&lt;input type="text" name="name" /&gt;</strong>
<strong class="bold">  &lt;/label&gt;</strong>
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
<li>Now we can repeat the same thing with the <strong class="source-inline">date of </strong><span class="No-Break"><strong class="source-inline">birth</strong></span><span class="No-Break"> field:</span><pre class="source-code">
describe('date of birth field', () =&gt; {
  it('displays a text field for the date of birth', ()
  =&gt; {
    render(BirthdayForm);
    const field = screen.queryByLabelText(
      'Date of birth',
      {
        selector: 'input[type=text]'
      }
    );
    expect(field).toBeVisible();
    expect(field.name).toEqual('dob');
  });
});</pre></li>
<li>To make <a id="_idIndexMarker113"/>that pass, add in a field for the date <span class="No-Break">of birth:</span><pre class="source-code">
&lt;form method="post" name="birthday"&gt;
  &lt;label&gt;
    Name
    &lt;input type="text" name="name" /&gt;
  &lt;/label&gt;
<strong class="bold">  &lt;label&gt;</strong>
<strong class="bold">    Date of birth</strong>
<strong class="bold">    &lt;input type="text" name="dob" /&gt;</strong>
<strong class="bold">  &lt;/label&gt;</strong>
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
</ol>
<p>That completes the <span class="No-Break"><strong class="source-inline">BirthdayForm</strong></span><span class="No-Break"> component.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Adding the form component to the page component</h2>
<p>Next, we’ll add <strong class="source-inline">BirthdayForm</strong> into the<a id="_idIndexMarker114"/> existing<a id="_idIndexMarker115"/> page component for the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">birthdays</strong></span><span class="No-Break"> route:</span></p>
<ol>
<li>Start by adding this test in <strong class="source-inline">src/routes/birthdays/page.test.js</strong>, as shown. We are testing for the presence of <strong class="source-inline">BirthdayForm</strong> simply by checking for an HTML element with the <span class="No-Break"><strong class="source-inline">form</strong></span><span class="No-Break"> role:</span><pre class="source-code">
it('displays a form for adding new birthdays', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(screen.getByRole('form')).toBeVisible();
});</pre></li>
</ol>
<p class="callout-heading">Using previously prepared work to make tests pass</p>
<p class="callout">We <em class="italic">could</em> make this test pass by just adding a new <strong class="source-inline">form</strong> element, but given that we have <strong class="source-inline">form</strong> already prepared in <strong class="source-inline">BirthdayForm</strong>, it makes sense to use that. We’ll see how component mocks can be used to make this test more specific in <a href="B19611_11.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Replacing Behavior with a </em><span class="No-Break"><em class="italic">Side-By-Side Implementation</em></span><span class="No-Break">.</span></p>
<ol>
<li value="2">To make this pass, start by inserting the new <strong class="source-inline">import</strong> statement <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.svelte</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;script&gt;
   import Birthday from './Birthday.svelte';
<strong class="bold">   </strong><strong class="bold">import BirthdayForm from './BirthdayForm.svelte';</strong>
   export let data;
&lt;/script&gt;</pre></li>
<li>Then, add a reference to the <strong class="source-inline">BirthdayForm</strong> component, together with a heading. Since<a id="_idIndexMarker116"/> the heading will remain static data, we don’t need a test for that. Our Vitest tests are for <em class="italic">behavior</em> only – things that <a id="_idIndexMarker117"/>change when props change or <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) <span class="No-Break">events fire:</span><pre class="source-code">
&lt;ol&gt;
  ...
&lt;/ol&gt;
<strong class="bold">&lt;h1&gt;Add a new birthday&lt;/h1&gt;</strong>
<strong class="bold">&lt;div&gt;</strong>
<strong class="bold">  &lt;BirthdayForm /&gt;</strong>
<strong class="bold">&lt;/div&gt;</strong></pre></li>
<li>While <a id="_idIndexMarker118"/>you’re here, you can also update the tag to make sure <strong class="source-inline">div</strong> has the same style as the <span class="No-Break"><strong class="source-inline">li</strong></span><span class="No-Break"> elements:</span><pre class="source-code">
&lt;style&gt;
  ...
  li,
<strong class="bold">  div </strong>{
    ...
  }
&lt;/style&gt;</pre></li>
</ol>
<p>You’ve now learned how to test-drive a form component and how to hook it up to your <strong class="source-inline">page</strong> component. That’s it for the new <strong class="source-inline">BirthdayForm</strong> component, and if you load the dev server now and browse to the <strong class="source-inline">/birthdays</strong> URL, you should see the form displayed on <span class="No-Break">the page.</span></p>
<p>In the next section, we’ll wire up the <strong class="bold">Save</strong> button so that it adds the new birthday data into <span class="No-Break">the system.</span></p>
<h1 id="_idParaDest-67">Test-drivi<a id="_idTextAnchor066"/>ng a SvelteKit form action</h1>
<p>The <strong class="source-inline">form</strong> action<a id="_idIndexMarker119"/> is the thing that SvelteKit calls when the form is submitted. It is defined in the <strong class="source-inline">+page.server.js</strong> file as an object named <strong class="source-inline">actions</strong>. The general form is shown in the following code block. Don’t add this just yet; we’ll come to it <span class="No-Break">later on:</span></p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    // ... do something with data here ...
  }
};</pre>
<p>This is what we’ll test-drive now. There’s a few things <span class="No-Break">to note:</span></p>
<ul>
<li>First, the Vitest unit tests can check the behavior of the <strong class="source-inline">form</strong> action, but it doesn’t check any of the SvelteKit framework code that invokes the action. You’ll recall we took the same approach with the HTML form: we didn’t test the <strong class="source-inline">submit</strong> action since that magic is managed by SvelteKit. For testing the framework integration, we need the <span class="No-Break">Playwright tests.</span></li>
<li>Second, if you take a look at the preceding code sample, the form action has an action parameter with a <strong class="source-inline">formData</strong> function. This returns an item of the <strong class="source-inline">FormData</strong> type, which is a built-in <span class="No-Break">DOM type.</span></li>
<li>If we’re going to test the <strong class="source-inline">form</strong> action, we’ll need a way to build these <span class="No-Break"><strong class="source-inline">FormData</strong></span><span class="No-Break"> objects.</span></li>
</ul>
<p>What we’ll do is create factory methods to generate example objects for use in our tests. After that, we’ll build our form action. However, in order to do that, we’ll need to replace our hardcoded load function with a <span class="No-Break"><em class="italic">real</em></span><span class="No-Break"> implementation.</span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Building a factory for the FormData objects</h2>
<p>Create <a id="_idIndexMarker120"/>a <a id="_idIndexMarker121"/>new file named <strong class="source-inline">src/factories/formDataRequest.js</strong> and add the <span class="No-Break">following function:</span></p>
<pre class="source-code">
const createFormDataFromObject = (obj) =&gt; {
  const formData = new FormData();
  Object.keys(obj).forEach((k) =&gt;
    formData.append(k, obj[k])
  );
  return formData;
};</pre>
<p>This function takes a plain JavaScript object and converts it into a <strong class="source-inline">FormData</strong> object by repeatedly calling the <strong class="source-inline">append</strong> method with each of the <strong class="source-inline">obj</strong> <span class="No-Break">key-value pairs.</span></p>
<p>Next, add the <strong class="source-inline">createFormDataRequest</strong> function, as shown in the following code block. It returns a SvelteKit request object that behaves in the same way that <span class="No-Break">SvelteKit will:</span></p>
<pre class="source-code">
export const createFormDataRequest = (obj) =&gt; ({
  formData: () =&gt;
    new Promise((resolve) =&gt;
      resolve(createFormDataFromObject(obj))
    )
});</pre>
<p>You can now use this within your Vitest tests for the <span class="No-Break">form action.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Building a Vitest test suite for the form action</h2>
<p>Open<a id="_idIndexMarker122"/> the <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong> file <a id="_idIndexMarker123"/>and update <strong class="source-inline">load import</strong> to also import the <span class="No-Break"><strong class="source-inline">actions</strong></span><span class="No-Break"> object:</span></p>
<pre class="source-code">
import { load<strong class="bold">, actions</strong> } from './+page.server.js';</pre>
<p>Just below that, add a new <strong class="source-inline">import</strong> statement for the <strong class="source-inline">createFormDataRequest</strong> factory that you <span class="No-Break">just defined:</span></p>
<pre class="source-code">
import {
  createFormDataRequest
} from 'src/factories/formDataRequest.js';</pre>
<p>Then, at the <a id="_idIndexMarker124"/>bottom of the file, in a new<a id="_idIndexMarker125"/> top-level describe block, add the <span class="No-Break">following test:</span></p>
<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  it('adds a new birthday into the list', async () =&gt; {
    const request = createFormDataRequest({
      name: 'Zeus',
      dob: '2009-02-02'
    });
    await actions.default({ request });
    expect(load().birthdays).toContainEqual(
      expect.objectContaining({
        name: 'Zeus',
        dob: '2009-02-02'
      })
    );
  });
});</pre>
<p>This test builds a request, calls our form action with it, and then uses the <strong class="source-inline">load</strong> function to check that it’s returned successfully. But there’s a difficulty here. Because our <strong class="source-inline">load</strong> function from the preceding chapter had a hardcoded implementation, there’s no way for us to add any new <span class="No-Break">data there.</span></p>
<p>Before we <a id="_idIndexMarker126"/>can make this test pass, we<a id="_idIndexMarker127"/> need to replace our hardcoded <strong class="source-inline">load</strong> function with a version that will then make this test easy <span class="No-Break">to pass.</span></p>
<p class="callout-heading">Skipping tests as part of a TDD workflow</p>
<p class="callout">Sometimes, we write a <em class="italic">Red</em> test and are ready to make it <em class="italic">Green</em>. But the approach to making it <em class="italic">Green</em> involves a whole bunch of refactoring. In these scenarios, it is better to rewind by marking the new <em class="italic">Red</em> test as skipped. Then you can safely refactor while you are on <em class="italic">Green</em>. Once your refactor is complete, un-skip your test, and you’re back on <em class="italic">Red</em>. Now make the test pass given all your refactoring work <span class="No-Break">is done.</span></p>
<p class="callout">Why go through this dance? Because you have the safety of a fully <em class="italic">Green</em> test suite to tell whether your Refactor has been completed correctly <span class="No-Break">or not.</span></p>
<p>Start by skipping the test you just added, <span class="No-Break">like this:</span></p>
<pre class="source-code">
it<strong class="bold">.skip</strong>('adds a new birthday into the list', async () =&gt; {
  ...
});</pre>
<p>Re-run all your tests to check that they are passing, except for the <span class="No-Break">skipped test:</span></p>
<pre class="source-code">
✓ src/routes/birthdays/page.server.test.js (2)
   ✓ /birthdays - load (1)
     ✓ returns a fixture of two items
   ↓ /birthdays - default action (1) [skipped]
     ↓ adds a new birthday into the list [skipped]
...
 Test Files  5 passed (5)
      Tests  15 passed | 1 skipped (16)</pre>
<p>Now in<a id="_idIndexMarker128"/> the <strong class="source-inline">src/routes/birthdays/+page.server.js</strong> file, update the implementation <a id="_idIndexMarker129"/>to read <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const db = [];
const addNew = (item) =&gt; db.push(item);
addNew({ name: 'Hercules', dob: '1994-02-02' });
addNew({ name: 'Athena', dob: '1989-01-01' });
export const load = () =&gt; ({
    birthdays: Array.from(db)
});</pre>
<p>This new implementation gives us an <strong class="source-inline">addNew</strong> function that we can use in our <span class="No-Break">latest test.</span></p>
<p>Re-run all tests and check that they have passed. Then, you can un-skip the latest test and re-run it. You should get a failure, as shown in the <span class="No-Break">following block:</span></p>
<pre class="source-code">
 FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - default action &gt; adds a new birthday into the list
TypeError: Cannot read properties of undefined (reading 'default')
 ❯ src/routes/birthdays/page.server.test.js:22:17
     20|   });
     21|
     22|   await actions.default({ request });</pre>
<p>Okay; we can just add an empty <strong class="source-inline">default</strong> function to get started. Add the following to the bottom of the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.server.js</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
  }
};</pre>
<p>If you run <a id="_idIndexMarker130"/>the tests again, you’ll see <a id="_idIndexMarker131"/>from the failure that all the plumbing seems fine; it’s just that we’re missing the important call to add <span class="No-Break">the birthday:</span></p>
<pre class="source-code">
FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - default action &gt; adds a new birthday into the list
AssertionError: expected [ { name: 'Hercules', …(1) }, …(1) ] to deep equally contain ObjectContaining{ …(3) }
 ❯ src/routes/birthdays/page.server.test.js:24:28
     22|   await actions.default({ request });
     23|
     24|   expect(load().birthdays).toContainEqual(
       |                            ^
     25|    expect.objectContaining({
     26|     name: 'Zeus',
  - Expected  - 4
  + Received  + 10
  - ObjectContaining {
  -   "dob": "2009-02-02",
  -   "name": "Zeus",
  - }"
...</pre>
<p>Finally, make<a id="_idIndexMarker132"/> the test pass by adding the <a id="_idIndexMarker133"/>call to the <strong class="source-inline">addNew</strong> function that <span class="No-Break">already exists:</span></p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
<strong class="bold">    const data = await request.formData();</strong>
<strong class="bold">    addNew({</strong>
<strong class="bold">      name: data.get('name'),</strong>
<strong class="bold">      dob: data.get('dob')</strong>
<strong class="bold">    });</strong>
  }
};</pre>
<p>Re-run your tests; the tests should all be passing now. And if you run the Playwright test, you should find it <span class="No-Break">also passes:</span></p>
<pre class="source-code">
[WebServer]
  ✓  1 test.js:3:1 › index page has expected h1 (499ms)
  ✓  2 birthdays.test.js:3:1 › lists all birthday (507ms)
  ✓  3 birthdays.test.js:13:1 › saves a new birthday (309ms)
  3 passed (5s)</pre>
<p>Now would be a<a id="_idIndexMarker134"/> great time to fire up the <a id="_idIndexMarker135"/>dev server and try the form out <span class="No-Break">for real.</span></p>
<p>You’ve now learned how to test-drive a SvelteKit form action, completing the last stage of work needed to fully test-drive an <span class="No-Break">entire route.</span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Summary</h1>
<p>This chapter has covered how to test-drive SvelteKit forms and form actions using both Playwright end-to-end tests and Vitest <span class="No-Break">unit tests.</span></p>
<p>You have seen how Vitest is useful for testing all the peculiarities of individual Svelte components but isn’t good at testing the framework code of SvelteKit, such as the code that takes an HTML form submit event, builds a server request, and invokes your form action. For that, you need a <span class="No-Break">Playwright test.</span></p>
<p>In the next chapter, you’ll build on this form by adding some server-side <span class="No-Break">form validations.</span></p>
</div>
</div></body></html>