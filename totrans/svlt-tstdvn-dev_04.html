<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Saving Form Data</h1>
<p>The preceding chapter introduced Playwright and SvelteKit routes. The data in our <code>/birthdays</code> route was hardcoded. In this chapter, we’ll force the <em class="italic">real</em> implementation of the <code>load</code> function by adding the ability to add new birthdays into the system.</p>
<p><em class="italic">Figure 4</em><em class="italic">.1</em> shows the new form we’ll be building. It is attached to the bottom of the birthday list at the <code>/</code><code>birthdays</code> route:</p>
<div><div><img alt="Figure 4.1 – The form for adding a new birthday" height="240" src="img/Figure_4.1_B19611.jpg" width="1052"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The form for adding a new birthday</p>
<p>This chapter covers the following key topics:</p>
<ul>
<li>Adding a Playwright test for data input</li>
<li>Test-driving a SvelteKit form</li>
<li>Test-driving a SvelteKit form action</li>
</ul>
<p>By the end of the chapter, you’ll have a good understanding of how to test-drive SvelteKit forms.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter04/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter04/Start</a>.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Adding a Playwright test for data input</h1>
<p>Go ahead<a id="_idIndexMarker103"/> and add this test to <code>tests/birthdays.test.js</code>. It includes <a id="_idIndexMarker104"/>all the steps required for adding a new birthday to the system:</p>
<pre class="source-code">
test('saves a new birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  await page.getByLabel('Name').fill('Persephone');
  await page
    .getByLabel('Date of birth')
    .fill('1985-01-01');
  await page.getByRole('button').click();
  await expect(
    page.getByText('Persephone')
  ).toBeVisible();
});</pre>
<p>After navigating to the <code>/birthdays</code> endpoint, it uses the <code>getByLabel</code> locator function to find an <code>input</code> field that has a <code>Name</code> label. This is standard HTML functionality using the <code>label</code> and <code>input</code> elements, which we’ll see in the next section.</p>
<p>We use the <code>fill</code> function to enter a value into this field, and then we repeat the process for the <code>Date of birth</code> field. Then, we click the button (any button!), and finally, we check that the <code>Persephone</code> text appears somewhere on the page.</p>
<p>An important distinction to make here is that <code>getByText</code> checks page text rather than, say, the values of the <code>input</code> fields. So, we can’t just fill in the <code>Name</code> field and then watch the expectation magically pass.</p>
<p>The intent <a id="_idIndexMarker105"/>of the Playwright test is to show that the following steps are performed:</p>
<ol>
<li>The user fills in a name and date of birth.</li>
<li>The user presses the <strong class="bold">Save</strong> button.</li>
<li>The system records the birthday in its system.</li>
<li>The browser refreshes the page, and the new birthday is displayed as part of the loaded page data.</li>
</ol>
<p>With all that <a id="_idIndexMarker106"/>in mind, the process we’ll use to make the test pass is as follows:</p>
<ol>
<li>First, we’ll build a new <code>BirthdayForm</code> component that displays a basic HTML form with two input fields and a button.</li>
<li>Then, we’ll add this to the existing <code>+page.svelte</code> file that we built in the preceding chapter.</li>
<li>Finally, we’ll add a form action to add this birthday, including introducing a new data structure to hold our birthdays in the server.</li>
</ol>
<p>That covers our up-front design, all wrapped up in a Playwright test. Next, we can begin test-driving the form.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Test-driving a SvelteKit form</h1>
<p>In <a id="_idIndexMarker107"/>this section, you’ll construct a new component named <code>BirthdayForm</code>, together with its test suite. This component is an HTML form that comprises two text fields: <code>name</code> and <code>dob</code>. Each <code>input</code> element has a corresponding <code>label</code> element. There’s also a button named <strong class="bold">Save</strong> that submits the form.</p>
<p>SvelteKit handles the submission of our form data from the client to the server. We won’t test this behavior in our Vitest test suites, instead leaving it up to the Playwright tests to ensure that all pieces slot together correctly.</p>
<p>Follow these <a id="_idIndexMarker108"/>steps to build the new form:</p>
<ol>
<li>Create a new file named <code>src/routes/birthdays/BirthdayForm.test.js</code> with the following first test. This uses the <code>queryByRole</code> query function to find an element with the <code>form</code> role on the page:<pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import BirthdayForm from './BirthdayForm.svelte';
describe('BirthdayForm', () =&gt; {
  it('displays a form', () =&gt; {
    render(BirthdayForm);
    expect(screen.queryByRole('form')).toBeVisible();
  });
});</pre></li>
<li>Make sure you run the test and watch it fail.</li>
<li>Then, create a new file named <code>src/routes/birthdays/BirthdayForm.svelte</code> with the following content:<pre class="source-code">
&lt;form /&gt;</pre></li>
<li>If you run tests now, you’ll see the test still doesn’t pass. That’s because the <code>form</code> role only becomes available once you <em class="italic">name</em> a form. Update the implementation as follows:<pre class="source-code">
&lt;form <strong class="bold">name="birthday"</strong> /&gt;</pre></li>
<li>The test <a id="_idIndexMarker109"/>should now pass. Add the next test, as shown in the following code block. This test simply checks that we submit the form via a <code>POST</code> request, which is the usual mechanism for submitting new data to the server:<pre class="source-code">
it('has a form method of POST', () =&gt; {
  render(BirthdayForm);
  expect(screen.getByRole('form').method).toEqual(
    'post'
  );
});</pre></li>
<li>Make that pass by adding the <code>method</code> attribute, as shown here:<pre class="source-code">
&lt;form <strong class="bold">method="post"</strong> name="birthday" /&gt;</pre></li>
<li>Then, add the third test, as shown in the following code block:<pre class="source-code">
it('displays a button to save the form', () =&gt; {
  render(BirthdayForm);
  expect(
    screen.queryByRole('button')
  ).toBeVisible();
});</pre></li>
<li>To make that pass, add an <code>input</code> element into the form with a <code>type</code> attribute set to <code>submit</code>. You can also give it <code>value</code> as <code>Save</code>, which will be used as the button name:<pre class="source-code">
&lt;form method="post" name="birthday"&gt;
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
<li>For the next <a id="_idIndexMarker110"/>test, we will introduce a nested <code>describe</code> block called <code>name field</code>. We can add a block here for grouping in anticipation of more tests for this field. We’ll be adding some more in <a href="B19611_05.xhtml#_idTextAnchor070"><em class="italic">Chapter 5</em></a>, <em class="italic">Validating </em><em class="italic">Form Data</em>:<pre class="source-code">
describe('name field', () =&gt; {
  it('displays a text field for the contact name', ()
  =&gt; {
    render(BirthdayForm);
    const field = screen.queryByLabelText('Name', {
      selector: 'input[type=text]'
    });
    expect(field).toBeVisible();
    expect(field.name).toEqual('name');
  });
});</pre></li>
</ol>
<p>This test makes use of the <code>queryByLabelText</code> function. This is analogous to the <code>page.getByLabel</code> function that was used in the Playwright test.</p>
<p>There is something else in this <a id="_idIndexMarker111"/>test that is important: the <code>input[type=text]</code>. It’s not very clear from the test, but the first expectation in this test checks all of the following:</p>
<ul>
<li>That a <code>label</code> element exists with the <code>Name</code> text</li>
<li>That an <code>input</code> element exists with the <code>type</code> attribute set to <code>text</code></li>
<li>That the <code>label</code> element is associated with the <code>input</code> element</li>
</ul>
<p>Part of these<a id="_idIndexMarker112"/> checks come from the selector expression itself. Without an explanation or understanding of the selector syntax, it’s hard to know the intent behind this expectation.</p>
<p>There’s also a second expectation in there to check that the <code>name</code> attribute is set. This is important so that the SvelteKit form action gets the right named parameters back. We’ll add this parameter, <code>name</code>, and in the next test, we’ll add another one named <code>dob</code>.</p>
<p>In <a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em>, we’ll refactor these expectations to improve their readability.</p>
<p>Let’s carry on with the next steps:</p>
<ol>
<li>To make the test pass, go ahead and add the <code>label</code> and <code>input</code> elements, as shown in the following code block:<pre class="source-code">
&lt;form method="post" name="birthday"&gt;
<strong class="bold">  &lt;label&gt;</strong>
<strong class="bold">    Name</strong>
<strong class="bold">    </strong><strong class="bold">&lt;input type="text" name="name" /&gt;</strong>
<strong class="bold">  &lt;/label&gt;</strong>
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
<li>Now we can repeat the same thing with the <code>date of </code><code>birth</code> field:<pre class="source-code">
describe('date of birth field', () =&gt; {
  it('displays a text field for the date of birth', ()
  =&gt; {
    render(BirthdayForm);
    const field = screen.queryByLabelText(
      'Date of birth',
      {
        selector: 'input[type=text]'
      }
    );
    expect(field).toBeVisible();
    expect(field.name).toEqual('dob');
  });
});</pre></li>
<li>To make <a id="_idIndexMarker113"/>that pass, add in a field for the date of birth:<pre class="source-code">
&lt;form method="post" name="birthday"&gt;
  &lt;label&gt;
    Name
    &lt;input type="text" name="name" /&gt;
  &lt;/label&gt;
<strong class="bold">  &lt;label&gt;</strong>
<strong class="bold">    Date of birth</strong>
<strong class="bold">    &lt;input type="text" name="dob" /&gt;</strong>
<strong class="bold">  &lt;/label&gt;</strong>
  &lt;input type="submit" value="Save" /&gt;
&lt;/form&gt;</pre></li>
</ol>
<p>That completes the <code>BirthdayForm</code> component.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Adding the form component to the page component</h2>
<p>Next, we’ll add <code>BirthdayForm</code> into the<a id="_idIndexMarker114"/> existing<a id="_idIndexMarker115"/> page component for the <code>/</code><code>birthdays</code> route:</p>
<ol>
<li>Start by adding this test in <code>src/routes/birthdays/page.test.js</code>, as shown. We are testing for the presence of <code>BirthdayForm</code> simply by checking for an HTML element with the <code>form</code> role:<pre class="source-code">
it('displays a form for adding new birthdays', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(screen.getByRole('form')).toBeVisible();
});</pre></li>
</ol>
<p class="callout-heading">Using previously prepared work to make tests pass</p>
<p class="callout">We <em class="italic">could</em> make this test pass by just adding a new <code>form</code> element, but given that we have <code>form</code> already prepared in <code>BirthdayForm</code>, it makes sense to use that. We’ll see how component mocks can be used to make this test more specific in <a href="B19611_11.xhtml#_idTextAnchor127"><em class="italic">Chapter 11</em></a>, <em class="italic">Replacing Behavior with a </em><em class="italic">Side-By-Side Implementation</em>.</p>
<ol>
<li value="2">To make this pass, start by inserting the new <code>import</code> statement into <code>src/routes/birthdays/+page.svelte</code>:<pre class="source-code">
&lt;script&gt;
   import Birthday from './Birthday.svelte';
<strong class="bold">   </strong><strong class="bold">import BirthdayForm from './BirthdayForm.svelte';</strong>
   export let data;
&lt;/script&gt;</pre></li>
<li>Then, add a reference to the <code>BirthdayForm</code> component, together with a heading. Since<a id="_idIndexMarker116"/> the heading will remain static data, we don’t need a test for that. Our Vitest tests are for <em class="italic">behavior</em> only – things that <a id="_idIndexMarker117"/>change when props change or <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) events fire:<pre class="source-code">
&lt;ol&gt;
  ...
&lt;/ol&gt;
<strong class="bold">&lt;h1&gt;Add a new birthday&lt;/h1&gt;</strong>
<strong class="bold">&lt;div&gt;</strong>
<strong class="bold">  &lt;BirthdayForm /&gt;</strong>
<strong class="bold">&lt;/div&gt;</strong></pre></li>
<li>While <a id="_idIndexMarker118"/>you’re here, you can also update the tag to make sure <code>div</code> has the same style as the <code>li</code> elements:<pre class="source-code">
&lt;style&gt;
  ...
  li,
<strong class="bold">  div </strong>{
    ...
  }
&lt;/style&gt;</pre></li>
</ol>
<p>You’ve now learned how to test-drive a form component and how to hook it up to your <code>page</code> component. That’s it for the new <code>BirthdayForm</code> component, and if you load the dev server now and browse to the <code>/birthdays</code> URL, you should see the form displayed on the page.</p>
<p>In the next section, we’ll wire up the <strong class="bold">Save</strong> button so that it adds the new birthday data into the system.</p>
<h1 id="_idParaDest-67">Test-drivi<a id="_idTextAnchor066"/>ng a SvelteKit form action</h1>
<p>The <code>form</code> action<a id="_idIndexMarker119"/> is the thing that SvelteKit calls when the form is submitted. It is defined in the <code>+page.server.js</code> file as an object named <code>actions</code>. The general form is shown in the following code block. Don’t add this just yet; we’ll come to it later on:</p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
    const data = await request.formData();
    // ... do something with data here ...
  }
};</pre>
<p>This is what we’ll test-drive now. There’s a few things to note:</p>
<ul>
<li>First, the Vitest unit tests can check the behavior of the <code>form</code> action, but it doesn’t check any of the SvelteKit framework code that invokes the action. You’ll recall we took the same approach with the HTML form: we didn’t test the <code>submit</code> action since that magic is managed by SvelteKit. For testing the framework integration, we need the Playwright tests.</li>
<li>Second, if you take a look at the preceding code sample, the form action has an action parameter with a <code>formData</code> function. This returns an item of the <code>FormData</code> type, which is a built-in DOM type.</li>
<li>If we’re going to test the <code>form</code> action, we’ll need a way to build these <code>FormData</code> objects.</li>
</ul>
<p>What we’ll do is create factory methods to generate example objects for use in our tests. After that, we’ll build our form action. However, in order to do that, we’ll need to replace our hardcoded load function with a <em class="italic">real</em> implementation.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Building a factory for the FormData objects</h2>
<p>Create <a id="_idIndexMarker120"/>a <a id="_idIndexMarker121"/>new file named <code>src/factories/formDataRequest.js</code> and add the following function:</p>
<pre class="source-code">
const createFormDataFromObject = (obj) =&gt; {
  const formData = new FormData();
  Object.keys(obj).forEach((k) =&gt;
    formData.append(k, obj[k])
  );
  return formData;
};</pre>
<p>This function takes a plain JavaScript object and converts it into a <code>FormData</code> object by repeatedly calling the <code>append</code> method with each of the <code>obj</code> key-value pairs.</p>
<p>Next, add the <code>createFormDataRequest</code> function, as shown in the following code block. It returns a SvelteKit request object that behaves in the same way that SvelteKit will:</p>
<pre class="source-code">
export const createFormDataRequest = (obj) =&gt; ({
  formData: () =&gt;
    new Promise((resolve) =&gt;
      resolve(createFormDataFromObject(obj))
    )
});</pre>
<p>You can now use this within your Vitest tests for the form action.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Building a Vitest test suite for the form action</h2>
<p>Open<a id="_idIndexMarker122"/> the <code>src/routes/birthdays/page.server.test.js</code> file <a id="_idIndexMarker123"/>and update <code>load import</code> to also import the <code>actions</code> object:</p>
<pre class="source-code">
import { load<strong class="bold">, actions</strong> } from './+page.server.js';</pre>
<p>Just below that, add a new <code>import</code> statement for the <code>createFormDataRequest</code> factory that you just defined:</p>
<pre class="source-code">
import {
  createFormDataRequest
} from 'src/factories/formDataRequest.js';</pre>
<p>Then, at the <a id="_idIndexMarker124"/>bottom of the file, in a new<a id="_idIndexMarker125"/> top-level describe block, add the following test:</p>
<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  it('adds a new birthday into the list', async () =&gt; {
    const request = createFormDataRequest({
      name: 'Zeus',
      dob: '2009-02-02'
    });
    await actions.default({ request });
    expect(load().birthdays).toContainEqual(
      expect.objectContaining({
        name: 'Zeus',
        dob: '2009-02-02'
      })
    );
  });
});</pre>
<p>This test builds a request, calls our form action with it, and then uses the <code>load</code> function to check that it’s returned successfully. But there’s a difficulty here. Because our <code>load</code> function from the preceding chapter had a hardcoded implementation, there’s no way for us to add any new data there.</p>
<p>Before we <a id="_idIndexMarker126"/>can make this test pass, we<a id="_idIndexMarker127"/> need to replace our hardcoded <code>load</code> function with a version that will then make this test easy to pass.</p>
<p class="callout-heading">Skipping tests as part of a TDD workflow</p>
<p class="callout">Sometimes, we write a <em class="italic">Red</em> test and are ready to make it <em class="italic">Green</em>. But the approach to making it <em class="italic">Green</em> involves a whole bunch of refactoring. In these scenarios, it is better to rewind by marking the new <em class="italic">Red</em> test as skipped. Then you can safely refactor while you are on <em class="italic">Green</em>. Once your refactor is complete, un-skip your test, and you’re back on <em class="italic">Red</em>. Now make the test pass given all your refactoring work is done.</p>
<p class="callout">Why go through this dance? Because you have the safety of a fully <em class="italic">Green</em> test suite to tell whether your Refactor has been completed correctly or not.</p>
<p>Start by skipping the test you just added, like this:</p>
<pre class="source-code">
it<strong class="bold">.skip</strong>('adds a new birthday into the list', async () =&gt; {
  ...
});</pre>
<p>Re-run all your tests to check that they are passing, except for the skipped test:</p>
<pre class="source-code">
✓ src/routes/birthdays/page.server.test.js (2)
   ✓ /birthdays - load (1)
     ✓ returns a fixture of two items
   ↓ /birthdays - default action (1) [skipped]
     ↓ adds a new birthday into the list [skipped]
...
 Test Files  5 passed (5)
      Tests  15 passed | 1 skipped (16)</pre>
<p>Now in<a id="_idIndexMarker128"/> the <code>src/routes/birthdays/+page.server.js</code> file, update the implementation <a id="_idIndexMarker129"/>to read as follows:</p>
<pre class="source-code">
const db = [];
const addNew = (item) =&gt; db.push(item);
addNew({ name: 'Hercules', dob: '1994-02-02' });
addNew({ name: 'Athena', dob: '1989-01-01' });
export const load = () =&gt; ({
    birthdays: Array.from(db)
});</pre>
<p>This new implementation gives us an <code>addNew</code> function that we can use in our latest test.</p>
<p>Re-run all tests and check that they have passed. Then, you can un-skip the latest test and re-run it. You should get a failure, as shown in the following block:</p>
<pre class="source-code">
 FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - default action &gt; adds a new birthday into the list
TypeError: Cannot read properties of undefined (reading 'default')
 ❯ src/routes/birthdays/page.server.test.js:22:17
     20|   });
     21|
     22|   await actions.default({ request });</pre>
<p>Okay; we can just add an empty <code>default</code> function to get started. Add the following to the bottom of the <code>src/routes/birthdays/+page.server.js</code> file:</p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
  }
};</pre>
<p>If you run <a id="_idIndexMarker130"/>the tests again, you’ll see <a id="_idIndexMarker131"/>from the failure that all the plumbing seems fine; it’s just that we’re missing the important call to add the birthday:</p>
<pre class="source-code">
FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - default action &gt; adds a new birthday into the list
AssertionError: expected [ { name: 'Hercules', …(1) }, …(1) ] to deep equally contain ObjectContaining{ …(3) }
 ❯ src/routes/birthdays/page.server.test.js:24:28
     22|   await actions.default({ request });
     23|
     24|   expect(load().birthdays).toContainEqual(
       |                            ^
     25|    expect.objectContaining({
     26|     name: 'Zeus',
  - Expected  - 4
  + Received  + 10
  - ObjectContaining {
  -   "dob": "2009-02-02",
  -   "name": "Zeus",
  - }"
...</pre>
<p>Finally, make<a id="_idIndexMarker132"/> the test pass by adding the <a id="_idIndexMarker133"/>call to the <code>addNew</code> function that already exists:</p>
<pre class="source-code">
export const actions = {
  default: async ({ request }) =&gt; {
<strong class="bold">    const data = await request.formData();</strong>
<strong class="bold">    addNew({</strong>
<strong class="bold">      name: data.get('name'),</strong>
<strong class="bold">      dob: data.get('dob')</strong>
<strong class="bold">    });</strong>
  }
};</pre>
<p>Re-run your tests; the tests should all be passing now. And if you run the Playwright test, you should find it also passes:</p>
<pre class="source-code">
[WebServer]
  ✓  1 test.js:3:1 › index page has expected h1 (499ms)
  ✓  2 birthdays.test.js:3:1 › lists all birthday (507ms)
  ✓  3 birthdays.test.js:13:1 › saves a new birthday (309ms)
  3 passed (5s)</pre>
<p>Now would be a<a id="_idIndexMarker134"/> great time to fire up the <a id="_idIndexMarker135"/>dev server and try the form out for real.</p>
<p>You’ve now learned how to test-drive a SvelteKit form action, completing the last stage of work needed to fully test-drive an entire route.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Summary</h1>
<p>This chapter has covered how to test-drive SvelteKit forms and form actions using both Playwright end-to-end tests and Vitest unit tests.</p>
<p>You have seen how Vitest is useful for testing all the peculiarities of individual Svelte components but isn’t good at testing the framework code of SvelteKit, such as the code that takes an HTML form submit event, builds a server request, and invokes your form action. For that, you need a Playwright test.</p>
<p>In the next chapter, you’ll build on this form by adding some server-side form validations.</p>
</div>
</div></body></html>