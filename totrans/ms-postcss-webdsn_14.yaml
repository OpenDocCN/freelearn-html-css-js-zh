- en: Chapter 14. Preparing for the Future
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章. 为未来做准备
- en: Mastering CSS is an essential skill—the technology is continually evolving,
    so in order to succeed, we must keep abreast of changes. PostCSS is a great tool
    that allows us to not only use CSS rules of today, but work with rules of the
    future. In this chapter, we'll take a look at some of the CSS syntax that makes
    up what is frequently referred to as CSS4, and how we can provide equivalent support
    using current CSS3 classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 CSS 是一项基本技能——这项技术不断在发展，因此为了成功，我们必须跟上变化的步伐。PostCSS 是一款强大的工具，它不仅允许我们使用今天的 CSS
    规则，还可以处理未来的规则。在本章中，我们将探讨一些构成通常所说的 CSS4 的 CSS 语法，以及我们如何可以使用当前的 CSS3 类提供等效支持。
- en: 'We will cover a number of topics throughout this chapter, which will include
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖多个主题，包括以下内容：
- en: Understanding some of the risks of supporting future CSS standards today
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解支持当前未来 CSS 标准的一些风险
- en: Exploring using `cssnext` to provide support for future CSS syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用 `cssnext` 来提供对未来 CSS 语法的支持
- en: Working with some of the existing plugins to convert CSS4 standards into current
    CSS3 code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与一些现有的插件合作，将 CSS4 标准转换为当前的 CSS3 代码
- en: Examining how we can change existing plugins to add more support for new CSS4
    selectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们如何可以修改现有的插件以增加对新 CSS4 选择器的支持
- en: Let's make a start!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Supporting CSS4 styles today
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持当前的 CSS4 样式
- en: Style sheets have been in existence for over 35 years, with the original version
    of what we now know as CSS dating from the days of SGML in the 1980s.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表已经存在了超过 35 年，我们今天所知道的 CSS 的原始版本可以追溯到 20 世纪 80 年代的 SGML 时代。
- en: We have come a long way since the original CSS standard was released in 1996—over
    the last few years, the standard for CSS4 has been developed, with new features
    such as `:not` or `:matches` pseudo-classes to better target elements, custom
    properties (or variables), and location-based links, such as `local-link`. Over
    the course of the next few pages, we're going to explore a few of these CSS4 features,
    and see how we can introduce support for them using current CSS3 equivalent code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 1996 年最初 CSS 标准发布以来，我们已经走了很长的路——在过去的几年里，CSS4 的标准得到了发展，新增了诸如 `:not` 或 `:matches`
    伪类等新特性，以更好地定位元素，自定义属性（或变量），以及基于位置的链接，如 `local-link`。在接下来的几页中，我们将探讨这些 CSS4 特性，并看看我们如何可以使用当前的
    CSS3 相当代码来引入对这些特性的支持。
- en: 'There is one small thing that we need to clear up first—CSS4…does not exist.
    What? I hear you say. Surely it must, I''ve seen plenty online about it! Yes,
    it is true: CSS4 as a standard does exist, but *not as a single unique entity*.
    Let me explain.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要澄清一个小问题——CSS4…并不存在。什么？你可能会说。当然，它必须存在，我在网上看到过很多关于它的信息！是的，这是真的：CSS4 作为一项标准确实存在，但它并不是一个单一的独立实体。让我来解释。
- en: Previous iterations of CSS have been based around creating a single global standard,
    irrespective of how browser manufacturers decide to support elements that make
    up standard. It's for this reason that we had to rely heavily on vendor prefixes
    for some years, we still do, but most vendors have since removed prefixes from
    many of the more common attributes such as `border-radius` or `box-shadow`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 CSS 版本都是围绕创建一个单一的全局标准来进行的，无论浏览器制造商如何决定支持构成标准的元素。这就是为什么我们不得不在多年里严重依赖供应商前缀，我们仍然在这样做，但大多数供应商已经从许多更常见的属性中移除了前缀，例如
    `border-radius` 或 `box-shadow`。
- en: The key difference here, though, is that a decision was taken to deliver CSS4
    as a series of modules—CSS as a standard has become very heavy, with the resulting
    increase in time required for development becoming unsustainable. This is why
    we will see talk of CSS Modules, such as Custom Properties or Selectors—these
    can evolve as independent standards to a point that we may no longer refer to
    CSS as version X, but just CSS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的关键区别在于，我们决定将 CSS4 作为一系列模块来交付——CSS 作为一项标准已经变得非常庞大，导致开发所需的时间增加变得不可持续。这就是为什么我们会听到有关
    CSS 模块（如自定义属性或选择器）的讨论——这些可以作为独立的标准发展，到一定程度，我们可能不再将 CSS 称为版本 X，而只是 CSS。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any reference to CSS4 within this chapter is purely to identify next generation
    styles we can implement using PostCSS plugins and CSS3 current standards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的任何关于 CSS4 的内容纯粹是为了识别我们可以使用 PostCSS 插件和 CSS3 当前标准实现的下一代样式。
- en: 'Okay, this aside, it''s time to get stuck in: PostCSS offers good support for
    some of the more common elements of we collectively call CSS4\. Let''s take a
    look to see what is available.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，抛开这一点，现在是时候深入研究了：PostCSS 对我们共同称之为 CSS4 的某些更常见元素提供了良好的支持。让我们来看看有哪些可用。
- en: Converting CSS4 styles for use
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换 CSS4 样式以使用
- en: The idea behind basing CSS4 around a series of modules was aimed at making it
    easier (and ultimately quicker) to update each standard; it does mean that modules
    will be in a state of flux, at least for the time being!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CSS4 基于一系列模块的想法是为了使其更容易（并且最终更快）更新每个标准；这确实意味着模块将处于不断变化的状态，至少在目前是这样！
- en: This said, there are some clear styles we can recreate using current CSS3 styles—one
    such example is CSS4 Selectors. Even though it is still in draft at the time of
    writing, a PostCSS plugin is available in the form of `postcss-selector-not` (from
    [https://github.com/postcss/postcss-selector-not](https://github.com/postcss/postcss-selector-not)).
    A sister style that is also available as a PostCSS plugin is `postcss-selector-matches`
    (available from [https://github.com/postcss/postcss-selector-matches](https://github.com/postcss/postcss-selector-matches))—these
    two are intended to replicate the `:not` negation and `:matches` pseudo-selectors
    that are coming as part of the new CSS4 standard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以使用当前的 CSS3 样式重新创建一些明确的样式——CSS4 选择器就是一个例子。尽管在撰写本文时它仍在草案阶段，但有一个名为 `postcss-selector-not`
    的 PostCSS 插件可用（来自 [https://github.com/postcss/postcss-selector-not](https://github.com/postcss/postcss-selector-not)）。另一个也作为
    PostCSS 插件提供的类似样式是 `postcss-selector-matches`（可在 [https://github.com/postcss/postcss-selector-matches](https://github.com/postcss/postcss-selector-matches)
    获取）——这两个插件旨在复制作为新 CSS4 标准一部分的 `:not` 否定和 `:matches` 伪选择器。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on individual CSS4 selectors, take a look at the full list
    available at [http://css4-selectors.com/selectors/](http://css4-selectors.com/selectors/).
    This will also give you an indication of available browser support—this list will
    be updated with changes as selectors are ratified for use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于个别 CSS4 选择器的信息，请查看在 [http://css4-selectors.com/selectors/](http://css4-selectors.com/selectors/)
    提供的完整列表。这也会给你一个关于可用浏览器支持的指示——随着选择器的批准使用，此列表将随着变化而更新。
- en: 'Looking further afield, there are a small handful of plugins that provide support
    for upcoming CSS4 standards—in addition to the `:matches` and `:not` plugins,
    we can use any of the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从更远的角度来看，有一些插件提供了对即将到来的 CSS4 标准的支持——除了 `:matches` 和 `:not` 插件之外，我们还可以使用以下任何一种：
- en: '| Name of plugin | Purpose of plugin |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 插件名称 | 插件用途 |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mq4-hover-shim` | Currently in beta, this plugin provides limited support
    for the Media Queries Level 4 hover media feature—it is available from [https://github.com/twbs/mq4-hover-shim](https://github.com/twbs/mq4-hover-shim).
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `mq4-hover-shim` | 目前处于测试版，此插件为 Media Queries Level 4 hover 媒体功能提供有限支持——可在
    [https://github.com/twbs/mq4-hover-shim](https://github.com/twbs/mq4-hover-shim)
    获取。 |'
- en: '| `host` | Working with the Shadow DOM? If you need to make `:host` selectors
    work properly with pseudo-classes, then this plugin is for you—the source is available
    at [https://github.com/vitkarpov/postcss-host](https://github.com/vitkarpov/postcss-host).
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `host` | 如果你在使用 Shadow DOM，并且需要让 `:host` 选择器与伪类正常工作，那么这个插件就是为你准备的——源代码可在
    [https://github.com/vitkarpov/postcss-host](https://github.com/vitkarpov/postcss-host)
    获取。 |'
- en: '| `pseudo-class-any-link` | How many times have you had to add pseudo-selectors
    such as `:link` or `:visited` to your code? This PostCSS plugin fixes that—we
    can now use the proposed `:any-link` pseudo-class in CSS.Head over to [https://github.com/jonathantneal/postcss-pseudo-class-any-link](https://github.com/jonathantneal/postcss-pseudo-class-any-link)
    for more details. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `pseudo-class-any-link` | 你有多少次需要在代码中添加伪选择器，如 `:link` 或 `:visited`？这个 PostCSS
    插件解决了这个问题——我们现在可以在 CSS 中使用提议的 `:any-link` 伪类。详情请访问 [https://github.com/jonathantneal/postcss-pseudo-class-any-link](https://github.com/jonathantneal/postcss-pseudo-class-any-link)。
    |'
- en: '| `postcss-initial` | The PostCSS Initial plugin resets a specified property''s
    value to what it was initially set in code (and not by the browser). For more
    details, head over to [https://github.com/maximkoretskiy/postcss-initial](https://github.com/maximkoretskiy/postcss-initial).
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-initial` | PostCSS Initial 插件将指定属性的值重置为其在代码中最初设置的值（而不是浏览器设置的）。更多详情请访问
    [https://github.com/maximkoretskiy/postcss-initial](https://github.com/maximkoretskiy/postcss-initial)。
    |'
- en: '| `font-variant` | This plugin transforms `font-variant` settings to the equivalent
    `font-feature-settings value`—it is designed for special cases, when it is not
    possible to reproduce using normal means, for example, a slashed zero to differentiate
    between a 0 and an O—the former equates to zero.The source for the plugin is available
    at [https://github.com/postcss/postcss-font-variant](https://github.com/postcss/postcss-font-variant).
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `font-variant` | 此插件将 `font-variant` 设置转换为等效的 `font-feature-settings` 值——它用于特殊案例，当无法使用常规方式复制时，例如，用斜杠区分
    0 和 O——前者等同于零。此插件的源代码可在 [https://github.com/postcss/postcss-font-variant](https://github.com/postcss/postcss-font-variant)
    获取。|'
- en: '| `postcss-input-range` | This plugin allows us to style input range elements.
    We need to provide unprefixed CSS styles, and the plugin will automatically handle
    support for all of the various prefixes required to allow this element to be styled
    across different browsers.The source for this plugin can be downloaded from [https://github.com/jonathantneal/postcss-input-range](https://github.com/jonathantneal/postcss-input-range).
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-input-range` | 此插件允许我们样式化输入范围元素。我们需要提供无前缀的 CSS 样式，该插件将自动处理所有必要的各种前缀，以允许在不同浏览器中对该元素进行样式化。此插件的源代码可以从
    [https://github.com/jonathantneal/postcss-input-range](https://github.com/jonathantneal/postcss-input-range)
    下载。|'
- en: 'Okay, let''s move on: I feel a demo coming! Let''s take a look at using the
    `postcss-selector-matches` property, to see how we can use it in action.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续：我感觉要来一个演示了！让我们看看如何使用 `postcss-selector-matches` 属性，看看我们如何在实际操作中使用它。
- en: Validating e-mail addresses
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证电子邮件地址
- en: How many times have you come across e-mail submissions from your site, where
    you aren't 100% sure your visitors have left a valid e-mail address?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次遇到过来自你网站的电子邮件提交，你并不完全确定你的访客是否留下了一个有效的电子邮件地址？
- en: If we leave aside exact numbers, it goes without saying that any requests submitted
    from any website must have a valid e-mail address; with the plethora of top level
    domains that are now available, it's even more critical that they be valid!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不考虑确切数字，那么不言而喻，任何来自任何网站的请求都必须有一个有效的电子邮件地址；现在可用的顶级域名如此之多，它们的有效性就更加重要了！
- en: To help with this, we can use the `:invalid` and `:valid` attributes to style
    `<input>` fields—whilst they may not be able to tell if `.design` is a valid TLD
    (and yes, it is), they can at least cope with the basics of ensuring that you
    have a TLD present, an `@` symbol, and the name of a recipient.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助做到这一点，我们可以使用 `:invalid` 和 `:valid` 属性来样式化 `<input>` 字段——虽然它们可能无法判断 `.design`
    是否是一个有效的顶级域名（是的，它是），但它们至少可以处理确保你有一个顶级域名、一个 `@` 符号和一个收件人名称的基本要求。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can perform a test in your browser to gauge support for these and other
    CSS4 selectors—check out the CSS4 Selectors site, at [http://css4-selectors.com/](http://css4-selectors.com/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器中执行测试，以评估对这些和其他 CSS4 选择器的支持——查看 CSS4 选择器网站，在 [http://css4-selectors.com/](http://css4-selectors.com/)。
- en: 'Let''s knock up a simple example using the `postcss-selectors-matches` plugin
    for PostCSS, to see how we can style such fields:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来演示如何使用 PostCSS 的 `postcss-selectors-matches` 插件，看看我们如何对这些字段进行样式化：
- en: We'll start as always by firing up a Node.js command prompt session, then changing
    the working folder to our project area.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样启动一个 Node.js 命令提示符会话，然后更改工作目录到我们的项目区域。
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，输入以下命令，然后按 *Enter* 键：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Keep the window open, we will need it shortly. If all is well, we should see
    this appear:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持窗口打开，我们很快就会用到它。如果一切顺利，我们应该会看到以下内容出现：
- en: '![Validating e-mail addresses](img/BO5194_14_01.jpg)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证电子邮件地址](img/BO5194_14_01.jpg)'
- en: Next, extract a copy of the `T69 - matches pseudo-selector` folder from the
    code download that accompanies this book, and save it to the root of our project
    area.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从本书附带的代码下载中提取 `T69 - matches 伪选择器` 文件夹的副本，并将其保存到项目区域的根目录。
- en: Copy `matches – pre-compile.css` from the `css`—completed version folder within
    `T69 - matches pseudo-selector`, and save it to the `src` folder at the root of
    our project area.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `T69 - matches 伪选择器` 文件夹中的 `css`—completed 版本文件夹复制 `matches – pre-compile.css`，并将其保存到项目区域的根目录下的
    `src` 文件夹中。
- en: Copy the `gulpfile.js` and `package.json` files from the `T69 - matches pseudo-selector`
    folder to the root of our project area, and rename it `matches.css`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `T69 - matches 伪选择器` 文件夹中的 `gulpfile.js` 和 `package.json` 文件复制到项目区域的根目录，并将其重命名为
    `matches.css`
- en: Revert to the Node.js command prompt session from earlier, then at the prompt
    enter `gulp` and press *Enter*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到之前使用的 Node.js 命令提示符会话，然后在提示符中输入 `gulp` 并按 *Enter* 键。
- en: If all is well, PostCSS will go away and compile our code into valid CSS—we
    should see the now familiar files appear in the `dest` folder.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，PostCSS 将消失并编译我们的代码为有效的 CSS——我们应该在 `dest` 文件夹中看到现在熟悉的文件。
- en: Copy the contents of this `dest` folder to the `css` folder underneath `T69
    - matches pseudo-selector`, then try previewing the `matches.html` file in a browser.
    If all is well, we should see something akin to this:![Validating e-mail addresses](img/BO5194_14_02.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此 `dest` 文件夹的内容复制到 `T69 - matches 伪选择器` 下面的 `css` 文件夹中，然后在浏览器中尝试预览 `matches.html`
    文件。如果一切顺利，我们应该看到类似这样的内容：![验证电子邮件地址](img/BO5194_14_02.jpg)
- en: 'It''s a simple demo, and yes, somewhat contrived. At this level, it wouldn''t
    be necessary to use `:matches`, as it ends up generating more code than is necessary!
    But it does show how easy it is to apply the technique, and have it provide valid
    CSS, as in the case of our example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的演示，是的，有些人为设计。在这个层面上，使用 `:matches` 并不是必要的，因为它最终生成的代码比必要的还要多！但它确实展示了应用这项技术是多么容易，并且能够提供有效的
    CSS，就像我们例子中的那样：
- en: '![Validating e-mail addresses](img/BO5194_14_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![验证电子邮件地址](img/BO5194_14_03.jpg)'
- en: 'Okay, let''s change tack: we will stay with the range theme for our next demo,
    but this time look at a more stylish example, where we can really go to town on
    transforming the appearance of our selected element.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们改变一下方向：在下一个演示中，我们将继续使用范围主题，但这次我们将看看一个更时尚的例子，我们可以真正地大显身手，改变我们选择元素的外观。
- en: The range input element is one that has been traditionally hard to style, more
    often than not, we may end up resorting to using jQuery UI to change its appearance!
    Not so with CSS4—we can use a series of new CSS attributes to apply styles, without
    the use of any additional libraries. Let's take a look at this in more detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 范围输入元素是传统上难以样式的元素，很多时候，我们可能不得不求助于 jQuery UI 来改变其外观！但在 CSS4 中不是这样——我们可以使用一系列新的
    CSS 属性来应用样式，而不需要使用任何额外的库。让我们更详细地看看这一点。
- en: Supporting the new range input
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持新的范围输入
- en: A quick question, how many times have you had to create a site where you needed
    to choose a value, say from 1 to 100? Or pick a specific opacity of color, from
    almost transparent to completely opaque?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的问题，你有多少次需要创建一个网站，其中需要选择一个值，比如说从 1 到 100？或者选择特定颜色的不透明度，从几乎透明到完全不透明？
- en: Okay, perhaps they're an odd couple of questions to ask, but the eagle-eyed
    should spot that I am of course referring to using sliders, which we can adjust
    to select a specific value. There are different ways to add these to a page, but
    which in the main will require some help to style, perhaps the most recognizable
    tool being jQuery UI!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，也许这些问题问得有些奇怪，但细心的读者应该能注意到我当然是在指使用滑块，我们可以调整它们来选择特定的值。有几种方法可以将这些添加到页面中，但主要还是需要一些帮助来设置样式，最容易被识别的工具可能是
    jQuery UI！
- en: 'This is fine if we need to use jQuery UI in our pages to provide other functionality,
    but what if we only needed it for the slider? It''s a bit of overkill—thankfully,
    we can fix that with the use of the `postcss-input-range` plugin, available from
    [https://github.com/jonathantneal/postcss-input-range](https://github.com/jonathantneal/postcss-input-range).
    It''s time for that demo, so let''s knock up a quick example of how one can be
    styled to represent a progress bar:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在页面中使用 jQuery UI 来提供其他功能，这当然是可以的，但如果我们只需要它来使用滑块呢？这有点大材小用——幸运的是，我们可以通过使用
    `postcss-input-range` 插件来解决这个问题，该插件可以从 [https://github.com/jonathantneal/postcss-input-range](https://github.com/jonathantneal/postcss-input-range)
    获取。现在是时候进行演示了，让我们快速举一个例子，看看如何将一个滑块样式化以表示进度条：
- en: We'll start by installing the `postcss-input-range` plugin, for this, go ahead
    and fire up a Node.js command prompt, then change the working folder to our project
    area.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装 `postcss-input-range` 插件，为此，请启动 Node.js 命令提示符，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, enter the following command, then press *Enter*:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，然后按 *Enter*：
- en: '[PRE1]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If all is well, we should see something akin to this screenshot:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到类似这样的截图：
- en: '![Supporting the new range input](img/BO5194_14_04.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![支持新的范围输入](img/BO5194_14_04.jpg)'
- en: Next, extract a copy of the `T70 - using range input` folder from the code download
    that accompanies this book. Go ahead and save it in our project area.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从本书附带的代码下载中提取 `T70 - 使用范围输入` 文件夹的副本。然后将其保存到我们的项目区域中。
- en: In the `css` folder of `T70 - using range input`, copy the `range – pre-compile.css`
    file to the `src` folder of our project area, and rename it `range.css`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `T70 - 使用范围输入` 的 `css` 文件夹中，将 `range – pre-compile.css` 文件复制到我们的项目区域的 `src`
    文件夹中，并将其重命名为 `range.css`。
- en: Copy the `gulpfile.js` and `package.json` files from the `T70 - using range
    input` folder to the root of our project area.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `T70 - 使用范围输入` 文件夹中的 `gulpfile.js` 和 `package.json` 文件复制到我们项目区域的根目录。
- en: Revert to the Node.js command prompt window, then at the prompt enter `gulp`
    and press *Enter*.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符窗口，然后在提示符下输入 `gulp` 并按 *Enter* 键。
- en: Gulp will now run our compilation process, if all is well, we should see the
    now familiar style sheet files appear in the `dest` folder, along with a map file
    in the maps subfolder. Copy these to the `css` folder under `T70 - using range
    input`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，Gulp 将运行我们的编译过程，现在熟悉的样式表文件应该会出现在 `dest` 文件夹中，同时 maps 子文件夹中也会有一个映射文件。将这些文件复制到
    `T70 - 使用范围输入` 下的 `css` 文件夹中。
- en: If all is well, we should see something akin to this screenshot when previewing
    the results in a browser:![Supporting the new range input](img/BO5194_14_05.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们在浏览器中预览结果时应看到类似下面的截图：![支持新的范围输入](img/BO5194_14_05.jpg)
- en: There is nothing complicated in this demo, even though we've only scratched
    the surface of what is possible when styling the range element—for example, we
    can add datalists to define certain values to scroll through, such as specific
    times of the day.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只是触及了为范围元素添加样式的可能性的表面，但这个演示并没有什么复杂的地方——例如，我们可以添加 datalists 来定义可以滚动浏览的特定值，比如一天中的特定时间。
- en: Browser support is still limited, but for an idea of what is possible, check
    out [http://demo.agektmr.com/datalist/](http://demo.agektmr.com/datalist/); the
    CSS guru Chris Coyier also has a couple of articles on the use of range inputs
    on his site at [http://www.css-tricks.com](http://www.css-tricks.com).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持仍然有限，但为了了解可能实现的功能，请查看 [http://demo.agektmr.com/datalist/](http://demo.agektmr.com/datalist/)；CSS
    大师 Chris Coyier 在他的网站上也有几篇关于范围输入使用的文章，网址为 [http://www.css-tricks.com](http://www.css-tricks.com)。
- en: 'The real magic in our demo appears when we take a look at the compiled code—one
    of the key elements for styling a range input is the `range-thumb` attribute,
    which is the knob we use to select a value on the slider. Here are two examples
    of how our code now looks, with support added for Firefox:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示中的真正魔法出现在我们查看编译后的代码时——为范围输入元素添加样式的关键元素之一是 `range-thumb` 属性，这是我们用来在滑块上选择值的旋钮。以下是我们的代码现在看起来像样的两个示例，增加了对
    Firefox 的支持：
- en: '![Supporting the new range input](img/BO5194_14_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![支持新的范围输入](img/BO5194_14_06.jpg)'
- en: 'This has support for Internet Explorer (which has been superseded by Edge):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这支持了 Internet Explorer（已被 Edge 取代）：
- en: '![Supporting the new range input](img/BO5194_14_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![支持新的范围输入](img/BO5194_14_07.jpg)'
- en: When using this plugin, we don't have to worry about adding vendor prefixes—our
    original code contains just the unprefixed versions; the relevant prefixes will
    be added at compilation, until such time as they are no longer needed for styling
    our input element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此插件时，我们不必担心添加供应商前缀——我们的原始代码只包含未加前缀的版本；相关的供应商前缀将在编译时添加，直到它们不再需要用于样式化我们的输入元素。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you would like help with styling the new range input element, then check
    out [http://danielstern.ca/range.css/](http://danielstern.ca/range.css/)—it's
    a useful tool!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助为新范围输入元素添加样式，请查看 [http://danielstern.ca/range.css/](http://danielstern.ca/range.css/)——这是一个有用的工具！
- en: Over the course of the last two demos, we've briefly scratched the surface of
    what is possible when using PostCSS—we've used the same format of Gulp task file
    to incorporate support for each plugin, which when run, has produced the requisite
    CSS style sheet for each demo. Nothing outrageous here, right? After all, it's
    followed the same principles we covered earlier, such as one plugin for one task…or
    can we do better?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两个演示过程中，我们简要地触及了使用 PostCSS 时可能实现的功能——我们使用了相同的 Gulp 任务文件格式来集成每个插件的支持，运行后为每个演示生成了必要的
    CSS 样式表。这里并没有什么过分的，对吧？毕竟，它遵循了我们之前提到的相同原则，比如一个插件对应一个任务……或者我们能做得更好吗？
- en: Yes, by now you should know that I always like to go one better if I can. Remember
    how I said it is preferable to create tasks in our runner that worked on a one-to-one
    basis? Was each task in our (Gulp) file related to a specific plugin? Well, as
    someone once said, rules are meant to be broken—it's time to throw out the rulebook,
    and consider a different approach, at least for future syntax…
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，到现在你应该知道，如果可能的话，我总是喜欢做得更好。记得我曾经说过，创建任务时最好是一对一的吗？我们（Gulp）文件中的每个任务是否都与特定的插件相关？嗯，正如有人曾经说过，规则是为了被打破的——是时候扔掉规则手册，考虑一种不同的方法了，至少对于未来的语法来说是这样……
- en: Supporting future syntax with cssnext
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cssnext 支持未来语法
- en: A key part of supporting CSS4 is the constant state of flux that we must deal
    with, until such time as modules have been standardized. If we maintained our
    current approach, it would entail constant updates of any plugins we decided to
    use that relate to CSS4 attributes—this is clearly not sustainable!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 支持CSS4的一个关键部分是我们必须处理的不断变化的状态，直到模块被标准化。如果我们保持当前的方法，它将涉及不断更新我们决定使用的任何与CSS4属性相关的插件——这显然是不可持续的！
- en: Instead, we can use a single plugin pack, in this case `cssnext`, to manage
    support for a range of new features. The beauty, though, is that all of the features
    are enabled by default, and will only kick in when needed in the code. There will
    of course come a time when new features are supported natively, at this point,
    we can simply discard the compilation process without impacting the final result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用单个插件包，在这种情况下是`cssnext`，来管理对一系列新特性的支持。然而，美中不足的是，所有特性默认都是启用的，并且只有在代码需要时才会激活。当然，将来会有新特性被原生支持的时候，到那时，我们只需简单地丢弃编译过程，而不会影响最终结果。
- en: It's worth taking the time to get to know `cssnext`—let's dive in and take a
    look in more detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间了解`cssnext`是值得的——让我们深入探讨并更详细地查看。
- en: Creating a site template with cssnext
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cssnext创建一个站点模板
- en: The `cssnext` plugin is one of those exceptions to our guideline of one plugin
    per task; we call it using the plugin name, but in reality, it will perform a
    number of transformations at the same time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`cssnext`插件是我们指南中每个任务一个插件的例外之一；我们通过插件名称调用它，但实际上，它将同时执行多个转换。'
- en: The plugin is available from [http://cssnext.io/](http://cssnext.io/). It is
    worth noting that an older version exists; we're using the newer version in this
    demo. The `cssnext` plugin was originally a complete system in its own right,
    before PostCSS became as popular as it is now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '该插件可在[http://cssnext.io/](http://cssnext.io/)获取。值得注意的是，存在一个较旧的版本；我们在本演示中使用的是较新版本。`cssnext`插件最初是一个完整的系统，在PostCSS变得像现在这样流行之前。 '
- en: The plugin contained options which didn't really belong to a plugin focused
    on the future of CSS, so the developers rewrote it to make `cssnext` simpler.
    At the same time, it was designed to be integrated into PostCSS, where we can
    use it at the same time as other plugins within our processor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件包含了一些实际上并不属于专注于CSS未来的插件的选项，因此开发者重新编写了它，使`cssnext`更简单。同时，它被设计成可以集成到PostCSS中，在那里我们可以在处理器中的其他插件的同时使用它。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The plugin even has its own playground, which we can use to test if changes
    will produce the desired effect—check it out at [http://cssnext.io/playground/](http://cssnext.io/playground/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件甚至有自己的游乐场，我们可以用它来测试更改是否会产生预期的效果——在[http://cssnext.io/playground/](http://cssnext.io/playground/)查看。
- en: Let's explore this plugin in more detail—we'll begin by installing it, before
    setting up code for our next demo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探索这个插件——我们将从安装它开始，然后再为我们的下一个演示设置代码。
- en: Setting up our demo
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的演示
- en: 'For this next demo, we''re going to set up a basic template that can be used
    for a site—it''s not going to win any awards for style, but the aim here is to
    explore how easy it is to make the changes, not become top billing at the next
    awards ceremony! Let''s dive in and take a look at what we need to do:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的演示中，我们将设置一个基本的模板，它可以用于网站——它不会在风格上赢得任何奖项，但这里的目的是探索进行更改有多容易，而不是在下一个颁奖典礼上成为焦点！让我们深入探讨我们需要做什么：
- en: We'll start by firing up a Node.js command prompt session then changing the
    working folder to the root of our project area.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先启动一个Node.js命令提示符会话，然后更改工作文件夹到我们项目区域的根目录。
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，然后按*Enter*键：
- en: '[PRE2]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If all is well, we should see something akin to this screenshot:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该会看到类似下面的截图：
- en: '![Setting up our demo](img/BO5194_14_08.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置我们的演示](img/BO5194_14_08.jpg)'
- en: Next, go ahead and extract a copy of the `T71 - working with cssnext` folder
    from the code download that accompanies this book—save it to the root of our project
    area.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从本书附带的代码下载中提取`T71 - working with cssnext`文件夹的副本——将其保存到我们项目区域的根目录。
- en: From the `T71 - working with cssnext` folder, save copies of the *styles.css*
    file to the `src` folder at the root of our project area, then `package.json`
    and `gulpfile.js` to the root of our project area.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`T71 - working with cssnext`文件夹中，将`styles.css`文件的副本保存到我们项目区域根目录下的`src`文件夹，然后将`package.json`和`gulpfile.js`保存到我们项目区域的根目录。
- en: Revert to the prompt we had open, then enter `gulp` and press `Enter`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回我们打开的提示符，然后输入`gulp`并按`Enter`键。
- en: Gulp will go away and compile our file, when it has completed, we will see the
    now familiar files appear in the `dest` folder at the root of our project area.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Gulp完成编译后，我们将看到现在熟悉的文件出现在我们项目区域根目录下的`dest`文件夹中。
- en: Copy the contents of the `dest` folder at the root of our project area to the
    `css` folder within `T71 - working with cssnext` folder at the root of our project
    area.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们项目区域根目录下`dest`文件夹的内容复制到`T71 - working with cssnext`文件夹根目录下的`css`文件夹中。
- en: Go ahead and preview `sitepage.html` from within the `T71 - working with cssnext`
    folder in a browser—if all is well, we should see something akin to this screenshot:![Setting
    up our demo](img/BO5194_14_09.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中预览`T71 - working with cssnext`文件夹内的`sitepage.html`——如果一切顺利，我们应该看到类似于这个截图的内容：![设置我们的演示](img/BO5194_14_09.jpg)
- en: 'We''ve now seen the template for our site—there are several places where we
    have made changes to take advantage of the power of `cssnext`. For this, go ahead
    and open up a copy of the file `stylescss` from within the `css` folder of `T71
    - working with cssnext` folder that we saved to our project area—let''s explore
    what changes have been made:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到了我们网站的模板——有几个地方我们进行了修改，以利用`cssnext`的强大功能。为此，请打开我们保存到项目区域的`T71 - working
    with cssnext`文件夹中的`css`文件夹内的`stylescss`文件的副本——让我们看看都做了哪些修改：
- en: '**Autoprefixer**: The plugin covers support for providing vendor prefixes for
    any future styles; any in the base file have been removed, and will be added during
    compilation.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Autoprefixer**：该插件涵盖了为任何未来样式提供供应商前缀的支持；在基础文件中的任何前缀都已移除，将在编译期间添加。'
- en: '**Media query ranges / custom queries**: Instead of using the existing format,
    which isn''t always clear, we can begin to use `>=` or `<=` to better express
    the range that we''re applying as part of our query. At the same time, we can
    use a custom query to define preset ranges at the top of our file, which can be
    used throughout the style sheet.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体查询范围/自定义查询**：我们不再使用现有的格式，该格式并不总是清晰，我们可以开始使用`>=`或`<=`来更好地表达我们查询中应用的范围。同时，我们可以使用自定义查询在文件顶部定义预设范围，这些范围可以在整个样式表中使用。'
- en: '**Nesting**: Fans of existing preprocessors such as SASS or Less will be familiar
    with the nesting principle; put simply, this allows us to nest styles inside each
    other. We can then adjust the selectors used for these rules, so that when compiled,
    each rule is transformed into valid CSS.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**：熟悉现有预处理器（如SASS或Less）的粉丝会对嵌套原则很熟悉；简单来说，这允许我们将样式嵌套在彼此内部。然后我们可以调整这些规则所使用的选择器，以便在编译时，每个规则都转换为有效的CSS。'
- en: '**Custom selectors**: Staying with the preprocessor theme, we can create custom
    values at the top of our code, and apply them as appropriate throughout.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义选择器**：继续讨论预处理器主题，我们可以在代码顶部创建自定义值，并适当地应用它们。'
- en: '**#rrggbbaa colors**: Traditionally, hex colors have been expressed as either
    three or six digit values; using `cssnext`, we can expand them to either four
    or eight digit values. The `cssnext` plugin will transpile them into standard
    RGBA values, with equivalent HEX values provided as a fallback mechanism.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#rrggbbaa 颜色**：传统上，十六进制颜色以三位或六位数字值表示；使用`cssnext`，我们可以将它们扩展到四位或八位数字值。`cssnext`插件将它们转换为标准的RGBA值，并提供等效的HEX值作为后备机制。'
- en: '**rem units**: Traditionally, developers have used pixel values to apply sizes
    to elements or fonts. Pixel values don''t respect user settings in a browser,
    so may not resize as expected. To work around this, `em` units were introduced;
    the math behind calculating `em` values was simplified with the introduction of
    rem units. Today, some developers argue that pixel values should reign supreme;
    the `cssnext` plugin provides both pixel and rem units, which can be used where
    supported by browsers.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rem 单位**：传统上，开发者使用像素值来应用元素或字体的大小。像素值不尊重浏览器中的用户设置，因此可能不会按预期缩放。为了解决这个问题，引入了`em`单位；随着`rem`单位的引入，计算`em`值的数学变得简单。今天，一些开发者认为像素值应该占主导地位；`cssnext`插件提供了像素和rem单位，可以在浏览器支持的地方使用。'
- en: 'At first thought, you might expect to have to include a number of plugins,
    or a detailed configuration object; not so! Instead, all we need in our Gulp task
    file is this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 初步思考，你可能认为需要包含多个插件或详细的配置对象；并非如此！相反，我们只需要在我们的Gulp任务文件中包含这个：
- en: '![Setting up our demo](img/BO5194_14_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的演示](img/BO5194_14_10.jpg)'
- en: I've always been a keen fan of keeping things simple—the `cssnext` plugin is
    a perfect example! Whilst we may need to update the plugin regularly to keep abreast
    of changes, we don't need to change our Gulp file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直热衷于保持事情简单——`cssnext` 插件就是完美的例子！虽然我们可能需要定期更新插件以跟上变化，但我们不需要更改我们的 Gulp 文件。
- en: 'The plugin will simply transform those styles it finds that are supported by
    the plugin, and leave alone any not covered by the plugin. The beauty of this
    is that we can either let it run as is, or if we want disable functionality that
    is no longer needed, then we simply disable it within the configuration object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 插件将简单地转换它找到的受插件支持的样式，并保留任何未受插件覆盖的样式。这种美在于我们可以让它按原样运行，或者如果我们想禁用不再需要的功能，我们只需在配置对象中禁用它：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To prove that the changes we made work, we''ve turned our (non-responsive)
    template from this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们做出的更改是有效的，我们将我们的（非响应式）模板从这样：
- en: '![Setting up our demo](img/BO5194_14_11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的演示](img/BO5194_14_11.jpg)'
- en: '…to this view, where our content clearly fits the smaller screen better:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: …到这个视图，我们的内容显然更适合较小的屏幕：
- en: '![Setting up our demo](img/BO5194_14_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的演示](img/BO5194_14_12.jpg)'
- en: Even though it's only a small part of the changes made, is directly responsible
    for making our template responsive, it goes to show that incorporating `cssnext`
    into our processes is easier than you might think!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是所做的更改的一小部分，但它直接负责使我们的模板响应式，这也表明将 `cssnext` 纳入我们的流程比我们想象的要容易得多！
- en: 'Okay, let''s move on: we''re going to take a look at a couple more plugins,
    but with a twist. We''ll first look at using a plugin to provide support for a
    new color being introduced as part of CSS4, before using it as a basis for fixing
    a keyword issue that should have been fixed a long time ago!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们继续：我们将探讨几个额外的插件，但会有一些变化。我们首先将查看使用一个插件来支持 CSS4 中引入的新颜色，然后再用它作为修复一个本应很久以前就应解决的问题的基础！
- en: Creating plugins to provide extra CSS4 support
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建插件以提供额外的 CSS4 支持
- en: Throughout the course of this chapter, we've covered a number of plugins that
    handle support for the upcoming CSS4 standards, and explored how we can use the
    `cssnext` plugin pack to manage the transition to using these new styles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们介绍了许多处理即将推出的 CSS4 标准支持的插件，并探讨了如何使用 `cssnext` 插件包来管理过渡到使用这些新样式。
- en: There is more out there that we can do—the great thing about PostCSS is that
    we can absolutely write our own plugins to help bolster support for CSS4 attributes.
    To help prove this, over the next few pages we'll work our way through fixing
    some issues in CSS, and altering an existing CSS4 color plugin to add support
    for a different color; we'll start with adding a little color to our next demo,
    if you pardon the pun!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做更多的事情——PostCSS 的好处在于我们可以绝对编写自己的插件来帮助增强对 CSS4 属性的支持。为了证明这一点，在接下来的几页中，我们将解决一些
    CSS 中的问题，并修改现有的 CSS4 颜色插件以添加对另一种颜色的支持；如果允许我打趣一下，我们将从给下一个演示添加一点颜色开始！
- en: Adding future color support to CSS
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 CSS 添加未来颜色支持
- en: '*"She made it to six. For almost twelve hours, she was six…"*'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '“她活到了六岁。在将近十二个小时里，她六岁了……” '
- en: There is something of a poignant twist to this next demo—the color `rebeccapurple`,
    which forms the basis for this next exercise, came about as a tribute to Eric
    Meyer's daughter, Rebecca, who passed away on her sixth birthday in June 2014,
    due to cancer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个演示有一个相当感人的转折——这个 `rebeccapurple` 颜色，是下一个练习的基础，它是为了纪念埃里克·迈耶的女儿丽贝卡，她在 2014
    年 6 月六岁生日那天因癌症去世。
- en: As anyone who spends any time developing CSS styles will know, Eric has been
    a major advocate of web standards, and in particular CSS—it is often said that
    one would be hard pushed not to read a book about CSS during their development
    that had not been written by Eric! The community proposed the addition of `rebeccapurple`
    as a color in Rebecca's memory (it was her favorite color), and in recognition
    of Eric's contribution. It was announced by the CSS Working Group that the change
    had been approved, to be added as part of the upcoming CSS4 standard.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何花时间开发 CSS 样式的人都知道，埃里克一直是网络标准的坚定倡导者，特别是 CSS——经常有人说，在他们的开发过程中，很难找到一本不是埃里克写的关于
    CSS 的书！社区提议添加 `rebeccapurple` 作为一种颜色以纪念丽贝卡（这是她最喜欢的颜色），并为了表彰埃里克的贡献。CSS 工作组宣布这一变更已被批准，并将作为即将推出的
    CSS4 标准的一部分添加。
- en: To help support the change for browsers that have not yet caught up, the developer
    Maxime Thirouin created a PostCSS plugin to transform the `rebeccapurple` color
    to the more compatible format of `rgb(102, 51, 153)`—the source for this plugin
    is available at [https://github.com/postcss/postcss-color-rebeccapurple](https://github.com/postcss/postcss-color-rebeccapurple).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助支持尚未跟上变化的浏览器，开发者 Maxime Thirouin 创建了一个 PostCSS 插件，将 `rebeccapurple` 颜色转换为更兼容的格式
    `rgb(102, 51, 153)`——该插件的源代码可在 [https://github.com/postcss/postcss-color-rebeccapurple](https://github.com/postcss/postcss-color-rebeccapurple)
    获取。
- en: 'Let''s take a look at the plugin in more detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个插件：
- en: We'll start by installing the `postcss-color-rebeccapurple` plugin, so go ahead
    and fire up a Node.js command prompt, and change the working folder to our project
    root.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装 `postcss-color-rebeccapurple` 插件，所以请打开 Node.js 命令提示符，并将工作文件夹更改为我们的项目根目录。
- en: 'At the prompt, go ahead and enter the following command:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，输入以下命令：
- en: '[PRE4]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then press *Enter*—if all is well, we should see something akin to this screenshot:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后按 *Enter* 键——如果一切顺利，我们应该能看到类似下面的截图：
- en: '![Adding future color support to CSS](img/BO5194_14_13.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加 CSS 的未来颜色支持](img/BO5194_14_13.jpg)'
- en: Keep the window open—we'll need it shortly.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持窗口打开——我们很快就会用到它。
- en: Next, go ahead and extract a copy of the `T72 - adding rebeccapurple color`
    folder from the code download that accompanies this book—save the folder to the
    root of our project area.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从本书附带的代码下载中提取 `T72 - adding rebeccapurple color` 文件夹的副本，并将其保存到我们项目区域的根目录。
- en: Copy the `styles – pre-compile.css` from within the `T72 - adding rebeccapurple
    color` folder to the root `src` folder of our project area, and rename as `styles.css`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `T72 - adding rebeccapurple color` 文件夹中的 `styles – pre-compile.css` 复制到我们项目区域的根
    `src` 文件夹中，并将其重命名为 `styles.css`
- en: Copy the `gulpfile.js` and `package.json` files from the `T72 - adding rebeccapurple
    color` folder to the root of our project area.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `T72 - adding rebeccapurple color` 文件夹中的 `gulpfile.js` 和 `package.json` 文件复制到我们项目区域的根目录。
- en: Revert to the Node.js command prompt session, then enter `gulp` at the prompt
    and press *Enter*.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符会话，然后在提示符中输入 `gulp` 并按 *Enter* 键。
- en: When compilation has finished, copy the contents of the `dest` folder from the
    root of our project area to the `css` folder under `T72 - adding rebeccapurple
    color`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，将项目区域根目录下的 `dest` 文件夹的内容复制到 `T72 - adding rebeccapurple color` 下的 `css`
    文件夹。
- en: Try previewing the results—if all is well, we should see this simple box, which
    has been backfilled with the color `rebeccapurple`:![Adding future color support
    to CSS](img/BO5194_14_14.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览结果——如果一切顺利，我们应该能看到这个简单的盒子，它已经被填充了颜色 `rebeccapurple`：![添加 CSS 的未来颜色支持](img/BO5194_14_14.jpg)
- en: 'To prove it works, have a look at the `.css` file from within the `css` folder
    under `T72 - adding rebeccapurple color`—we should see the compiled RGB value
    within:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明它的工作，查看 `T72 - adding rebeccapurple color` 下的 `css` 文件夹中的 `.css` 文件——我们应该能看到其中的编译
    RGB 值。
- en: '![Adding future color support to CSS](img/BO5194_14_15.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![添加 CSS 的未来颜色支持](img/BO5194_14_15.jpg)'
- en: We can also validate this with a quick check using a site such as *ColorHexa.com*—check
    out [http://www.colorhexa.com/663399](http://www.colorhexa.com/663399); searching
    for `rebecca purple` will show the same page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用像 *ColorHexa.com* 这样的网站进行快速检查来验证这一点——查看 [http://www.colorhexa.com/663399](http://www.colorhexa.com/663399)；搜索
    `rebecca purple` 将显示相同的页面。
- en: There is a perfect opportunity here—I believe that there is always something
    good that can come from something tragic. Leaving aside the *raison d'être* for
    this plugin, we can use it as a basis for adding support for additional colors
    from the CSS4 Color Module standard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完美的机会——我相信，从悲剧中总会产生一些好的东西。抛开这个插件的 *raison d'être*，我们可以将其作为添加 CSS4 颜色模块标准中其他颜色支持的基础。
- en: 'The changes we need to make are relatively straightforward, and can easily
    form the basis for a new plugin. Let''s take a look at what''s involved; for this
    demo we will use `burlywood`, which is a light shade of brown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做出的更改相对简单，可以轻松地成为新插件的基础。让我们看看涉及的内容；对于这个演示，我们将使用 `burlywood`，这是一种浅棕色：
- en: 'We''ll start by editing our CSS file—open up `styles.css` in the `src` folder
    under the root of our project area and change the highlighted line as indicated:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先编辑我们的 CSS 文件——打开项目区域根目录下的 `src` 文件夹中的 `styles.css`，并按指示更改高亮行：
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to update the `rebeccapurple` plugin file to change existing
    color references to use the new color—we''ll start with the initial declaration:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`rebeccapurple`插件文件，将现有的颜色引用更改为使用新颜色——我们将从初始声明开始：
- en: '[PRE6]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The plugin `index.js` file can be found within the `node_modules\postcss-color-rebeccapurple\`
    folder.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`index.js`插件文件可以在`node_modules\postcss-color-rebeccapurple\`文件夹中找到。'
- en: 'We then need to change the check made in the code that changes each instance
    of the color:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来需要更改代码中更改颜色实例的检查：
- en: '[PRE7]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For now, go ahead and save the file—yes, the plugin name doesn't represent the
    color, but this is only a test, so it won't matter.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，请继续保存文件——是的，插件名称并不代表颜色，但这只是一个测试，所以这不会有什么影响。
- en: Fire up a Node.js command prompt, then change the working folder to our project
    area. At the prompt, enter `gulp` then press *Enter*.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Node.js命令提示符，然后更改工作文件夹到我们的项目区域。在提示符中输入`gulp`然后按*Enter*。
- en: Copy the contents of the root `dest` folder to the `css` folder in the `T73
    - adding support for new color` folder.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根目录`dest`文件夹的内容复制到“T73 - 添加对新颜色支持”文件夹中的`css`文件夹。
- en: Run `testpage.html`—if all is well, we can see the compiled RGB value within,
    as before:![Adding future color support to CSS](img/BO5194_14_16.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`testpage.html`——如果一切顺利，我们可以在其中看到之前编译的RGB值：![添加对CSS未来颜色的支持](img/BO5194_14_16.jpg)
- en: Try re-running the `testpage.html` file from within the `T73 - adding support
    for new color` folder; we should see the change in color (and yes, it's definitely
    not purple!):![Adding future color support to CSS](img/BO5194_14_17.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从“T73 - 添加对新颜色支持”文件夹中重新运行`testpage.html`文件；我们应该看到颜色的变化（而且，它绝对不是紫色！）![添加对CSS未来颜色的支持](img/BO5194_14_17.jpg)
- en: 'We can verify that the color displayed is indeed `burleywood`, using the same
    principle as before. This time check out [http://www.colorhexa.com/deb887](http://www.colorhexa.com/deb887),
    which clearly shows the HEX and RGB values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与之前相同的原则来验证显示的颜色确实是`burleywood`。这次查看[http://www.colorhexa.com/deb887](http://www.colorhexa.com/deb887)，它清楚地显示了HEX和RGB值：
- en: '![Adding future color support to CSS](img/BO5194_14_18.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![添加对CSS未来颜色的支持](img/BO5194_14_18.jpg)'
- en: 'All that remains for you now is to convert this into a plugin. This should
    be easy to do: try taking a copy of the existing `rebeccapurple` plugin, then
    performing a search and replace with the color of your choice. It''s not perfect,
    but will give you a head start—the next part will be to use what we learnt back
    in [Chapter 8](ch08.html "Chapter 8. Creating PostCSS Plugins"), *Creating PostCSS
    Plugins*, to turn it into a fully-fledged plugin available in the NPM repository.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下要做的就是将其转换为插件。这应该很容易做到：尝试复制现有的`rebeccapurple`插件，然后使用您选择的颜色进行搜索和替换。它并不完美，但会给你一个良好的开端——下一部分将是使用我们在[第8章](ch08.html
    "第8章。创建PostCSS插件")中学到的知识，将其转变为一个可在NPM存储库中使用的完整插件。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To get a list of the CSS4 Module colors, have a look on Google—there are plenty
    of links; try this as a start: [https://github.com/segundofdez/css4-colors/blob/master/less/colors.less](https://github.com/segundofdez/css4-colors/blob/master/less/colors.less).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取CSS4模块颜色的列表，请在Google上查看——有很多链接；从这里开始尝试：[https://github.com/segundofdez/css4-colors/blob/master/less/colors.less](https://github.com/segundofdez/css4-colors/blob/master/less/colors.less)。
- en: 'Okay, time to change focus: although this chapter is meant to be about looking
    forward, we''re going to change direction and look backwards for a moment.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是时候改变焦点了：尽管本章旨在展望未来，但我们将改变方向，暂时回顾一下。
- en: The reason for this? A number of mistakes in the design of CSS have been acknowledged
    by the CSS Working Group. A PostCSS plugin by Jonathan Neal provides a short-term
    fix for a number of these issues—some which could well be fixed properly in a
    future version of CSS!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是什么？CSS设计中的许多错误已被CSS工作组认可。乔纳森·尼尔（Jonathan Neal）的一个PostCSS插件为这些问题的短期修复提供了解决方案——其中一些问题可能在CSS的将来版本中得到正确修复！
- en: Going back in time
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾过去
- en: When developing code, I'm a great fan of only developing for modern browsers
    as a rule—ideally *n-1*, or current plus one previous version. In the main, this
    isn't an issue for the likes of Firefox or Chrome, but it's a different story
    for IE. Where possible, older versions of IE will very likely be left by the wayside…but
    that's another story!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，我非常喜欢只针对现代浏览器进行开发，作为一条规则——理想情况下是*n-1*，即当前版本加上上一个版本。在主要方面，这对Firefox或Chrome来说不是问题，但对于IE来说则不同。在可能的情况下，旧版本的IE可能会被遗弃……但这又是另一个故事了！
- en: The one exception we can make though is not around browser support, but trying
    to correct some issues with attribute naming. The CSS Working Group have acknowledged
    that some of the attribute names weren't defined correctly when they were released—you
    can see a complete list at [https://wiki.csswg.org/ideas/mistakes](https://wiki.csswg.org/ideas/mistakes),
    which is regularly updated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的一个例外不是关于浏览器支持，而是尝试纠正一些属性命名的问题。CSS工作组已经承认，在发布时一些属性名称定义不正确——您可以在[https://wiki.csswg.org/ideas/mistakes](https://wiki.csswg.org/ideas/mistakes)上看到完整的列表，该列表会定期更新。
- en: To help with this, and as a precursor to the second demo in this section, we're
    going to install the Time Machine plugin for PostCSS (hence the title of this
    section!). This provides a short-term fix for some of the bugs in CSS. We will
    then use this as inspiration to design a quick and dirty plugin to fix another
    bug that is listed on the CSSWG site, but which is not fixed by the Time Machine
    plugin.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，并且作为本节第二个演示的先导，我们将安装PostCSS的Time Machine插件（因此本节的标题是“Time Machine！”）。这为CSS中的一些错误提供了一种短期解决方案。然后我们将以此为契机，设计一个快速且实用的插件来修复CSSWG网站上列出的另一个错误，但这个错误并没有被Time
    Machine插件修复。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source for this plugin is available from [https://github.com/jonathantneal/postcss-time-machine](https://github.com/jonathantneal/postcss-time-machine).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件的源代码可在[https://github.com/jonathantneal/postcss-time-machine](https://github.com/jonathantneal/postcss-time-machine)获取。
- en: For this demo, we will reuse the simple demo created to display the `rebeccapurple`
    color from *Adding future color support to CSS*. The compiled results from that
    demo use an RGBA function—the CSSWG have stated that RGBA should not exist, and
    instead the alpha channel should have been added as the fourth channel for the
    `RGB()` function. We'll fix that as part of our demo—the plugin will allow us
    to write what was intended, whilst compiling it to code that can be understood
    by any browser.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将重用为显示`rebeccapurple`颜色而创建的简单演示。该演示的编译结果使用RGBA函数——CSSWG已经声明RGBA不应该存在，而alpha通道应该作为`RGB()`函数的第四通道添加。我们将作为演示的一部分修复这个问题——插件将允许我们编写预期的代码，同时将其编译成任何浏览器都能理解的代码。
- en: 'Let''s make a start on installing the plugin for use in our demo:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装用于演示的插件：
- en: We'll start by installing the plugin, so go ahead and fire up a Node.js command
    prompt session, then change the working folder to our project area.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装插件，所以请启动一个Node.js命令提示符会话，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, enter this command and press *Enter*:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下输入以下命令并按*Enter*键：
- en: '[PRE8]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If all is well, we should see something akin to this screenshot—keep the session
    open, as we will need it shortly:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到类似于这个截图的内容——保持会话开启，因为我们很快就会需要它：
- en: '![Going back in time](img/BO5194_14_19.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![回到过去](img/BO5194_14_19.jpg)'
- en: Next, go ahead and extract a copy of the `T74 - going back in time` folder from
    the code download that accompanies this book—save the folder to the root of our
    project area.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从本书附带的代码下载中提取`T74 - going back in time`文件夹的副本——将文件夹保存到我们项目区域的根目录。
- en: Copy the `styles – pre-compile.css` from within the `T74 - going back in time`
    folder to the root `src` folder of our project area, and rename it `styles.css`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`T74 - going back in time`文件夹内的`styles – pre-compile.css`复制到我们项目区域的根`src`文件夹，并将其重命名为`styles.css`。
- en: Copy the `gulpfile.js` and `package.json` files from the same `T74 - going back
    in time` folder to the root folder of our project area.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gulpfile.js`和`package.json`文件从同一`T74 - going back in time`文件夹复制到我们项目区域的根文件夹。
- en: Revert to the Node.js command prompt, then at the prompt, enter `gulp` and press
    *Enter*.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Node.js命令提示符，然后在提示符下输入`gulp`并按*Enter*键。
- en: If all is well, we should see our usual compiled files appear in the `dest`
    folder—copy these to the `css` folder under `T74 - going back in time`.![Going
    back in time](img/BO5194_14_20.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在`dest`文件夹中看到我们通常的编译文件——将这些文件复制到`T74 - going back in time`下的`css`文件夹。![回到过去](img/BO5194_14_20.jpg)
- en: 'At this point, try previewing the results of our demo, if all is well, we should
    see the same box as before, but this time with a slightly lighter shade of `rebecca
    purple` as its color:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，尝试预览我们演示的结果，如果一切顺利，我们应该看到之前相同的盒子，但这次颜色稍微浅一点的`rebecca purple`：
- en: 'If we take a look at the CSS styles though, the keen-eyed may spot something—how
    come we''re using `194` as our alpha value, yet the code shows `0.8`? The answer
    is simple: this plugin was designed to use `0` to `255` for each value, including
    the alpha channel. Simply divide `194` by `255`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看CSS样式，细心的读者可能会注意到——为什么我们使用 `194` 作为我们的alpha值，而代码中显示的是 `0.8`？答案是简单的：这个插件被设计为使用
    `0` 到 `255` 的每个值，包括alpha通道。只需将 `194` 除以 `255`：
- en: '![Going back in time](img/BO5194_14_21.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![回到过去](img/BO5194_14_21.jpg)'
- en: 'The answer is `0.8`. Okay, you will actually get something like `0.76078`,
    but if we round up to one decimal place, this will become `0.8`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 `0.8`。好吧，你实际上会得到类似 `0.76078` 的东西，但如果我们四舍五入到一位小数，这将变成 `0.8`：
- en: '![Going back in time](img/BO5194_14_22.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![回到过去](img/BO5194_14_22.jpg)'
- en: 'Now, before we continue, there is something we should consider: the practical
    application of this plugin. It''s not meant to pour cold water on a nice idea,
    but adoption may take a little time—developers in a team will be used to writing
    styles that include functions such as `rgba()`, `background-blend-mode`, or `hsla()`,
    so it may take some time to change the mindset!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续之前，我们应该考虑一些事情：这个插件的实际应用。这并不是要浇灭一个美好的想法，但采用可能需要一点时间——团队中的开发者已经习惯了编写包含
    `rgba()`、`background-blend-mode` 或 `hsla()` 等函数的样式，因此改变思维模式可能需要一些时间！
- en: This said, it is a useful fix if we want to adhere to the intended standards,
    and can manage the change of mindset to not type function names that we may have
    been doing for some time. We can even take things a step further and create our
    own plugin—Time Machine doesn't include fixes for all of the attributes, so let's
    take a look at creating one to manage the bug that surrounds the `background-blend-mode`
    attribute in CSS.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果我们想遵守预期的标准，并且能够管理改变思维模式，不输入我们可能已经做了很长时间的函数名，这是一个有用的修复。我们甚至可以更进一步，创建我们自己的插件——时间机器并没有为所有属性提供修复，所以让我们看看如何创建一个来管理围绕CSS中
    `background-blend-mode` 属性的bug。
- en: Creating our own plugin
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的插件
- en: One of the attributes not fixed by the Time Machine plugin is the `background-blend-mode`
    function—this is normally used to calculate the final color pixel when layers
    overlap each other.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 时间机器插件没有固定的一个属性是 `background-blend-mode` 函数——这个函数通常用于计算当图层重叠时最终的像素颜色。
- en: The bug that was introduced relates to the name—the **CSS Working Group** (**CSSWG**)
    have acknowledged that all blend-mode variants should be written without -mode
    in the name, so that in our case, background-blend-mode would be written as `background-blend`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的bug与名称有关——**CSS工作组**（**CSSWG**）已经承认所有混合模式变体应该在不包含 -mode 的名称中书写，因此在我们的情况下，`background-blend-mode`
    应该写成 `background-blend`。
- en: It's an easy fix to make, here's a perfect opportunity for you to try creating
    your own plugin! We're going to take a different route at this point—time for
    some audience participation, so to speak!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复，这是一个完美的机会让你尝试创建你自己的插件！现在我们将采取不同的路线——是时候一些观众参与，换句话说！
- en: 'To help you along the way, it''s worth taking another look at [Chapter 8](ch08.html
    "Chapter 8. Creating PostCSS Plugins"), *Creating PostCSS Plugins*; when creating
    the plugin, we can use this code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你，值得再次查看[第8章](ch08.html "第8章。创建PostCSS插件")，*创建PostCSS插件*；在创建插件时，我们可以使用以下代码：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Most of this code is boilerplate, but the key to making this work is this excerpt:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分是样板代码，但使它工作关键的是以下摘录：
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In a nutshell, we parse each CSS rule in turn—if any contain background-blend,
    we simply replace each instance with background-blend-mode.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们依次解析每个CSS规则——如果其中包含 `background-blend`，我们就简单地将其每个实例替换为 `background-blend-mode`。
- en: 'To prove it works, we can use the following code to test if our plugin works:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明它的工作，我们可以使用以下代码来测试我们的插件是否工作：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If all is well, we should get something akin to this screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该得到类似以下截图的结果：
- en: '![Creating our own plugin](img/BO5194_14_23.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的插件](img/BO5194_14_23.jpg)'
- en: 'If you get stuck, then a completed version is available in the code download
    that accompanies this book; a quick peek in the `T75 - back in time change` folder
    for `styles – pre-compile.css` will show this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了困难，那么这本书附带的代码下载中有一个完整的版本；快速查看 `T75 - back in time change` 文件夹中的 `styles
    – pre-compile.css` 文件将显示这一点：
- en: '![Creating our own plugin](img/BO5194_14_24.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的插件](img/BO5194_14_24.jpg)'
- en: 'When compiled, we can clearly see it shows the version we will be used to seeing:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，我们可以清楚地看到它显示了我们将习惯看到的版本：
- en: '![Creating our own plugin](img/BO5194_14_25.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的插件](img/BO5194_14_25.jpg)'
- en: It's a quick and dirty plugin, which will likely need a little more development
    before putting it into production use—for example, it caters purely for background-blend-mode,
    whereas we should support any attribute that contains blend-mode within the name!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速且简单的插件，在投入生产使用之前可能需要更多的开发——例如，它仅针对 background-blend-mode，而我们应该支持任何名称中包含
    blend-mode 的属性！
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Creating CSS styles opens up a world of possibilities: we are only limited
    by what we must support! Throughout the course of this chapter, we''ve explored
    some of the possible options we can use when working with the newer CSS4 styles—let''s
    take a moment to review what we have learnt.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 CSS 样式打开了一个充满可能性的世界：我们受限于我们必须支持的内容！在本章的整个过程中，我们探索了一些在使用较新的 CSS4 样式时我们可以使用的可能选项——让我们花点时间回顾一下我们已经学到的内容。
- en: We kicked off with a quick introduction to what we know as CSS4—we then moved
    on to explore some of the plugins that cater for supporting newer styles with
    more compatible CSS equivalent code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对 CSS4 的快速介绍开始——然后转向探索一些插件，这些插件通过提供更兼容的 CSS 等效代码来支持更新的样式。
- en: Up next came a simple demo that explored some of the new CSS4 pseudo-classes,
    and how we might use them in a (theoretical) context. We then moved onto something
    more practical, in the form of styling the new range input using just CSS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简单的演示，探索了一些新的 CSS4 伪类，以及我们如何在（理论上的）环境中使用它们。然后我们转向更实际的内容，仅使用 CSS 来样式化新的范围输入。
- en: Moving swiftly on, we then took a look at the cssnext plugin pack, which provides
    an abstract layer for supporting CSS4; we saw how easy it is to implement, and
    that we can easily switch off functionality if it is no longer needed in our projects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 快速前进，我们接下来查看 cssnext 插件包，它为支持 CSS4 提供了一个抽象层；我们看到了实现它是多么容易，并且我们可以轻松地关闭在项目中不再需要的功能。
- en: Our next demo came in the form of working with color—we used the `rebeccapurple`
    plugin to show firstly how easy it is to add support for one of the new colors
    within CSS4, then to modify it to provide support for other colors as needed in
    our projects. We then rounded out the chapter with a look back in time at some
    of the mistakes made when CSS was released, and how (with a little imagination),
    we might provide a temporary workaround until such time as these mistakes are
    fixed in a future version of CSS.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的演示是关于处理颜色——我们使用了 `rebeccapurple` 插件，首先展示了在 CSS4 中添加对新颜色支持是多么容易，然后修改它以提供在我们项目中需要支持的其他颜色的支持。然后我们通过回顾
    CSS 发布时的一些错误来结束本章，以及（通过一点想象力），我们可能提供临时的解决方案，直到这些错误在未来版本的 CSS 中得到修复。
- en: We've now come to the end of the book - I hope you've enjoyed our journey through
    the world of PostCSS, and that hopefully this book will help improve your skills
    as a future developer or user of PostCSS.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了本书的结尾——我希望你喜欢我们穿越 PostCSS 世界的旅程，并且希望这本书能帮助你作为一个未来的开发者或 PostCSS 的用户提高技能。
