- en: Chapter 6. Point Clouds and Postprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a point cloud based on a geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a point cloud from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring individual points in a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling individual points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving individual points of a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploding a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the basic postprocessing pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom postprocessing steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving WebGL output to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js has support for many different types of geometries and objects. In
    this chapter, we'll show you a number of recipes that use the `THREE.PointCloud`
    object. With this object, you can create a point cloud where the individual vertices
    are rendered instead of the complete mesh. You have all kinds of different styling
    options available for the points, and you can even move the individual points
    around to create very interesting-looking (and realistic) animations and simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a point cloud based on a geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting feature of Three.js is that it also allows you to create point
    clouds. A point cloud isn't rendered as a solid geometry, but all the individual
    vertices are rendered as single points. In this recipe, we'll show you how to
    create such a point cloud based on an already existing geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no additional steps required to start with this recipe. For the example
    we use in this recipe, however, we use an external model as the basis for our
    point cloud. We also use a camera control object, `THREE.OrbitControls`, to make
    navigation around the example easier. If you want to use the camera control object
    yourself, you need to add the following JavaScript libraries to the scene (besides
    the standard Three.js one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The external model we use is also provided with the sources in this book and
    can be found in the `assets/models/cow` folder. To see what the result of this
    recipe can look like, we provided an example that shows you a point cloud that
    was created based on an existing geometry (`06.01-create-point-cloud-from-geometry.html`).You
    will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in this screenshot, we've loaded a cow geometry and created a
    point cloud based on it. You can, of course, use any geometry you want, but especially
    complex models look really great when rendered as a point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a point cloud isn''t that different from creating a simple `THREE.Mesh`
    object. The following section explains the steps you should take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need in this approach is `THREE.Geometry`. You can use
    either one of the standard geometries or load an external one. For this recipe,
    we''ll load an external one (the cow we mentioned in the *Getting ready* section
    of this recipe):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we load the external model, so we have geometry on which
    we can base the point cloud.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we create the point cloud, we first have to tell Three.js what we want
    the point cloud to look like. For this, we create `THREE.PointCloudMaterial`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This material defines what each point will look like. Most of the properties
    are pretty self-explanatory. The interesting one here is the `blending` property.
    By setting the `blending` property to `THREE.AdditiveBlending`, you get the nice
    glow effect you can see in the screenshot at the beginning of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we have `THREE.Geometry` and `THREE.PointCloudMaterial`; with
    these two objects, we can create the point cloud:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we pass in `THREE.Geometry` and `THREE.PointCloudMaterial` to
    create `THREE.PointCloud`. On the created point cloud, we set two additional properties
    to `true`. The `sizeAttenuation` property makes sure that the size of a point
    also depends on the distance from the camera. So, points farther away look smaller.
    The `sortPoints` property makes sure that when you use transparent points, as
    we do in this recipe, they are rendered correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step to perform is to add the created `THREE.PointCloud` object to
    the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, Three.js will render the point cloud just like it does any other 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create `THREE.PointCloud`, Three.js creates a point for each vertex
    of the provided `THREE.Geometry` object. No other information in `THREE.Geometry`
    is used. Internally, for `THREE.WebGLRenderer`, it directly uses `GL_POINTS`,
    which is a WebGL primitive, to render the individual points (refer to [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml)
    for more information). Then, using a custom fragment shader, it styles these points.
    The result is that when you use `THREE.WebGLRenderer`, you can easily render millions
    of points while maintaining great performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Points are a great way to represent all kinds of different effects. For some
    interesting applications of points, you can look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One million points rendered on WebGL: [http://soulwire.github.io/WebGL-GPU-Particles/](http://soulwire.github.io/WebGL-GPU-Particles/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Morphing from one geometry to another using a point cloud: [http://oos.moxiecode.com/js_webgl/particles_morph/index.html](http://oos.moxiecode.com/js_webgl/particles_morph/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we have a number of recipes that deal with points that are
    closely related to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a point cloud from scratch* recipe, we create a point cloud
    from a custom-created geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Styling individual points* recipe, we show you how you can style the
    individual points of a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Moving individual points of a point cloud* and *Exploding a point cloud*
    recipes, we show you how you can move the points around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a point cloud from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to create a point cloud, you can pass in an existing geometry
    and base the point cloud on it. In this recipe, we'll show you how you can create
    `THREE.Geometry` from scratch and create a point cloud from it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we don''t require any additional JavaScript libraries and
    we don''t need to load external models, as we create our geometry from scratch.
    You can look at the geometry we created by opening `06.02-create-point-system-from-scratch.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll explain how to create this custom geometry and use
    it together with `THREE.PointCloud`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps are pretty much the same as shown in the *Creating a point cloud
    based on a geometry* recipe, except that first, we need to create our own custom
    geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom geometry is fairly easy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from this code snippet, you first need to instantiate `THREE.Geometry`
    and then create `THREE.Vector3` instances and push them to the vertices property
    of geometry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a geometry, we just need `THREE.PointCloudMaterial`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use this material together with the geometry to create `THREE.PointCloud` and
    add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you've already looked at the *Creating a point cloud based on a geometry*
    recipe, you'll notice that most of the steps are the same. The only difference
    between these two recipes is how you create the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an explanation on how this works, look at the *How it works…* section from
    the *Creating a point cloud based on a geometry* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we showed how you could render 3D formulas with Three.js. With the setup
    from this recipe, you can also create 3D formulas that are visualized as point
    clouds. For instance, the following screenshot shows you a 3D formula from [Chapter
    2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*, rendered
    as a point cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/1182OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can very easily create great-looking point clouds this way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of recipes in this chapter that are related to this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a point cloud based on a geometry* recipe, we use an existing
    geometry to create a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Styling individual points* recipe, we show you how you can style the
    individual points of a point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Moving individual points of a point cloud* and *Exploding a point cloud*
    recipes, we show you how you can move the points around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring the individual points in a point cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a point cloud, every point has the same color and style, as
    every point uses the same `THREE.PointCloudMaterial` object. There is, however,
    a way to add color to the individual points.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no need for any additional steps to run this recipe. We''ll create
    a custom geometry, just like we did in the *Creating a point cloud from scratch*
    recipe, and this time, we color each individual point. The result of this recipe
    can be seen by opening `06.03-color-individual-points-in-point-system.html` in
    your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we've colored the individual points in various shades of red.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish individual colored points, we need to set one additional property
    when we create `THREE.Geometry`. The following steps show you how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the geometry. When we create the individual vertices,
    we can also inform Three.js about the color that we want to use for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we create a random color and push it to the `geometry.colors`
    array. At the end of these two loops, we will have 10000 vertices in the `vertices`
    array and 10000 colors in the `colors` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can create `THREE.PointCloudMaterial` and use it together with the
    geometry to create `THREE.PointCloud`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To use the colors we created in step 1, we need to set the `vertexColors` property
    of `THREE.PointCloudMaterial` to `true`. In this code snippet, we also load a
    texture and assign it to the `map` property. We use individual colors, so there
    is no need to set the `color` property on the material we need to set color on
    `THREE.Geometry`, which we show in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you''ve already looked at the example shown in the *Getting ready* section
    of this recipe, you''ll notice that the colors of the points change. We can easily
    do this by just changing the color in the `colors` array of the geometry in the
    render loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you change the colors, you need to set the `colorsNeedUpdate` property
    to `true` so that Three.js knows that the colors of the points need to be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js uses WebGL to render individual points. For this, Three.js uses vertex
    shaders and fragment shaders (see the previous chapter for more recipes on this).
    To color the individual points, Three.js passes the information into the fragment
    shader used to determine the output color. The corresponding piece of shader code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `psColor` variable is the one that is passed from the colors array of `THREE.Geometry`
    to the shader used to color the points.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coloring an individual point in Three.js is very simple and straightforward.
    However, if you want to change more properties of the points, such as the opacity
    or the size, you can't do that with standard Three.js. In the *Styling individual
    points* recipe, we'll show you how you can create a custom shader to also change
    these properties of the points within a point cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're interested in adding animation to the points in the point cloud, you
    can look at the *Moving individual points of a point cloud* and *Exploding a point
    cloud* recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling individual points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the standard Three.js functionality, you can't style the individual points
    of a point cloud. You can change their color, as we've shown in the *Coloring
    the individual points in a point cloud* recipe, but it isn't possible to change
    a point's size or opacity. In this recipe, we'll show you how to create a custom
    vertex and fragment shader, which allow you to change the color, opacity, and
    size of the individual points of a point cloud and that you can also easily extend
    to add more properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no external libraries used in this recipe. We''ll just extend the
    basic Three.js functionality by creating our own custom shaders. To see the shaders
    in action, open the `06.04-style-individual-points-in-point-system-with-custom-shader.html`
    example in your browser. You will see something similar to the following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in this screenshot, the size, color, and opacity of the individual
    points differ.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the steps that you need to take to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start simple and first create the geometry from which we''ll create
    the point cloud:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we create `THREE.Geometry` from scratch and generate 10,000
    vertices. As we want to change the color, size, and opacity of the individual
    vertices, we also generate values for these properties for each of the 10,000
    vertices. The colors are stored in the `geometry.colors` array as this is the
    standard Three.js functionality. We store the size in the `pSize` array and the
    opacity in the `pOpacity` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got a geometry and a couple of arrays containing the expected
    size and opacity for the individual vertices, let''s define the material for the
    point cloud:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of using the standard `THREE.PointCloudMaterial` object, we use `THREE.ShaderMaterial`.
    The `transparent` and `blending` are properties standard material properties and
    behave as you'd expect. We'll explain the other properties in the upcoming steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In step 2, the material referenced the attributes variable. In this step, we''ll
    configure this variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `attributes` object contains two properties. The first one points to the
    array that contains the sizes of the vertices and the second one points to the
    array that contains the opacity values. The `f` value for type means that it is
    an array of floats. As we reference this attribute from our shader material, we
    can access the individual values in our shaders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In step 2, we also defined some uniforms. The `uniforms` object are also passed
    into the shader but are the same for all vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we reuse the standard uniforms Three.js uses in its shaders and use it
    to further configure the shaders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Looking back at step 2, the only two properties we need to define are the actual
    shaders: `document.getElementById(''pointVertexShader'').text` and `document.getElementById(''pointFragmentShader'').text`.
    Let''s start with the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A vertex shader is used to determine the position and the size of a vertex.
    In this shader, we set the size of the vertex and the point and use the `pSize`
    attribute in the calculation. This way, we can control the size of the individual
    pixel. We also copy the value of `color` and `pOpacity` to a `varying` value so
    that we can access it from our fragment shader in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far, the size of the point could be configured directly from Three.js. Now,
    let''s look at the fragment shader and do the same for the color and opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fragment shader is only a small program. What we do here is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We first set the color of the fragment (the point) to the color defined on the
    material (`psColor`), and the opacity is set to the point-specific opacity (`vOpacity`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we apply the provided texture (`map`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we multiply the color value(`gl_Fragcolor`) with the point specific
    color(`vcolor`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we''ve configured the material and created the specific shaders.
    Now, we can just create the point cloud and add it to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this last step, you're done.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, as this isn't a standard Three.js functionality, we need to
    take some additional steps to accomplish our goals.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we've already explained a bit how the styling of individual
    points works. The main thing to remember here is that under the hood, Three.js
    creates vertex and fragment shaders for rendering. If there is a functionality
    you want that can't be configured in the standard shaders, you can use `THREE.ShaderMaterial`
    to create your own custom implementations. You can still use Three.js to create
    your geometries and handle all the WebGL initialization stuff but use your own
    shader implementations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this setup, you've got a basic skeleton to create your own custom shader
    based on point clouds. You can now easily add more functionalities, other configuration
    options, and more by just adding to this setup.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you just want to color an individual point, you can refer to the *Coloring
    the individual points in a point cloud* recipe, and if you're interested in adding
    animation to the points in the point cloud, you can refer to the *Moving individual
    points of a point cloud* and *Exploding a point cloud* recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a couple of other recipes that use vertex and fragment shaders.
    In this chapter, you can find the *Creating custom postprocessing steps* recipe,
    which uses a shader as a postprocessing effect. In [Chapter 5](ch05.html "Chapter 5. Lights
    and Custom Shaders"), *Light and Custom Shaders*, we have the *Creating a custom
    vertex shader* recipe, which uses a custom vertex shader to alter the shape of
    a geometry, and the *Creating a custom fragment shader* recipe, which colors 3D
    objects using a custom fragment shader implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving individual points of a point cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a point cloud from a geometry, the position of the points is
    based on the vertices from the provided geometry. The result is a point cloud
    where the individual points don't move. In this recipe, we show you how you can
    move the individual points of a point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we require a point cloud that contains some points. You can
    create your own one (as we explained in the *Creating a point cloud from scratch*
    and *Creating a point cloud from an existing geometry* recipes). We will use the
    point cloud we created in the *Styling individual points* recipe. As always, we''ve
    provided an example where you can see the final result of this recipe. Open `06.05-move-individual-points.html`
    in your browser, and you''ll see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you open this in your browser, you'll see all the points being moved around
    the screen. In the following section, we'll explain how you can do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create moving points, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you've got a point cloud with a geometry. Look at the *Creating a
    point cloud from scratch* and *Creating a point cloud based on a geometry* recipes
    to learn how to create such a point cloud. In this recipe, we assume the point
    cloud can be referenced through the `ps` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to update the position of the individual points of the point
    cloud. We do that by updating the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `render` loop, we access geometry through the `ps` variable. Next, we
    change the `y` position (`v.y`) of each point based on the value of the step variable.
    By increasing the step value in each render loop, we create the animation you
    can see when you look at the example for this recipe. Finally, we need to tell
    Three.js that the positions of the vertices in the geometry have changed by setting
    `geometry.verticesNeedUpdate` to `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we also change the colors of each point, so to inform Three.js
    about these changes, we also set `geometry.colorsNeedUpdate` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works in a very simple way. A point cloud is created based on the
    position of the vertices of `THREE.Geometry` by simply changing the position of
    the vertices around which we can move the points.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we changed the position of the vertices in a very simple way.
    We just changed the *y* value of the vertex. In the *Exploding a point cloud*
    recipe, we show you an approach where the position of a vertex is changed based
    on its normal vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploding a point cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create many interesting effects with point clouds. You can, for instance,
    create water, smoke, and cloud effects. In this recipe, we show you another interesting
    effect you can create with points. We'll show you how you can explode a point
    cloud where each point's path is based on its normal vector.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, there aren''t any steps that need to be taken before we start
    looking at the recipe. We''ve provided an example where you can see the resulting
    explosion in action. Open the `06.06-explode-geometry.html` example in your browser
    and you''ll see a screen that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the **implode** button, the points will move to the middle of
    the screen; if you click on **explode**, they'll move outwards. With the **speed**
    property, you can set the speed at which the points will move.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To accomplish this effect, you only need to perform a couple of small steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create the geometry. For the best effect,
    we use a geometry with lots of vertices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we don't just create the geometry; we also add a `velocity`
    parameter to each of the vertices, which we set to a random value. We do this
    to make sure not all the points explode at the same speed (which would have the
    same effect as just scaling the geometry).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can create the point cloud:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is just a standard point cloud based on the geometry we created in step
    1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the introduction to the recipe, we mentioned that we wanted to explode the
    points based on their normal vector. So, before we start rendering the scene and
    updating the position of the individual points, we first need to calculate the
    normal of each vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We won't explain this code snippet in detail, but what we do here is that we
    calculate the normal vector of each vertex based on the normal vectors of the
    faces the particular vector is part of. The final normal vector is stored in the
    `avgVertexNormals` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we look at a helper function that we''ll call from the `render` loop
    in the next step. This function determines the new position of each vertex based
    on the velocity function we defined in step 1 and the normal vector we calculated
    in step 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `control.scale` variable is set through GUI and determines the speed at
    which our geometry expands, and the `dir` property is based on whether we want
    to move the points outwards or inwards. The `verticesNeedUpdate` property is required
    to inform Three.js about these changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now all that is left to do is call the explode function from the `render` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we've used a standard geometry; you can, of course, also use
    an externally loaded model.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more](img/1182OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot, for instance, shows you an exploding model of a cow.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another recipe that deals with animation and moving individual points around
    can be found in the *Moving individual points of a point cloud* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the basic postprocessing pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides rendering a scene in 3D, Three.js also allows you to add postprocessing
    effects to the final output. With postprocessing, you can take the final rendered
    2D image and apply all different kinds of filters to it. You could, for instance,
    add specific blurring effects, sharpen specific colors, and much more. In this
    recipe, we'll show you how to set up a postprocessing pipeline in Three.js, which
    you can use to add effects to the final rendered scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with postprocessing in Three.js, you need to include a number of additional
    JavaScript files from the Three.js distribution. For this recipe, the following
    JavaScript files should be added to your HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate how postprocessing works, we''ll apply the dot-screen effect
    to a Three.js scene. For this effect, we require one additional JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also provided an example that shows you the final result of this recipe.
    You can view this by opening `06.07-setup-basic-post-processing-pipeline.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, you can see that we've rendered a scene with a large number
    of cubes and applied an effect to render it as a series of dots.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up a postprocessing pipeline only takes a couple of small steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a postprocessing pipeline, we need something called a composer. We''ll
    use this composer in the `render` loop to create the final output. The first thing
    we need for that is a new global variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to instantiate a composer as a new instance of `THREE.EffectComposer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass in `THREE.WebGLRenderer`, which we would normally use to render the
    scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to define the steps that the composer will execute. These steps
    are executed sequentially and we can use them to apply multiple effects to the
    scene. The first step we always need to take is to render the scene. For this,
    we use `THREE.RenderPass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A render pass renders a scene object using the provided camera and renderer
    we configured in step 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve rendered the scene, we can apply a postprocessing effect. For
    this recipe, we use `THREE.DotScreenShader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we create a postprocessing step (`THREE.ShaderPass`),
    add it to the composer (`composer.addPass(effect)`), and tell the effect composer
    to render the output of this step to screen by setting `renderToScreen` to `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step we need to take is to alter the render loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we now use the `composer` object we created in step 2 to render
    the final output instead of `THREE.WebGLRenderer`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, we've only used a single postprocessing step, but you can use
    as many steps as you want. You just have to remember that in the final step, you
    set the `renderToScreen` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a couple of recipes, we've already explained that Three.js uses WebGL shaders
    to render the 3D scenes. `THREE.EffectComposer` uses the same approach. Each of
    the steps you add run a simple vertex and fragment shader on the output from the
    previous step. In the *Creating custom postprocessing steps* recipe, we'll dive
    into more detail and create a custom postprocessing step ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js provides a large number of standard shaders and steps you can use
    in `THREE.EffectComposer`. For a complete overview of the possible shaders and
    standard steps, look at the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing](https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing):
    This directory contains all the standard postprocessing steps you can use with
    `THREE.EffectComposer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders):
    Three.js provides the `THREE.ShaderPass` postprocessing step, which allows you
    to directly use WebGL shaders. On this page, you can find a large number of shaders
    that can be used with the `THREE.ShaderPass` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Three.js provides a large number of standard shaders and postprocessing
    steps, you can also easily create your own. In the *Creating custom postprocessing
    steps* recipe, we show you how to create a custom vertex and fragment shader that
    works with `THREE`.`EffectComposer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom postprocessing steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Setting up the basic postprocessing pipeline* recipe, we showed you
    how you can use `THREE.EffectComposer` to add postprocessing effects to a rendered
    Three.js scene. In this recipe, we'll explain how you can create custom processing
    steps that you can use with `THREE.EffectComposer`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses `THREE.EffectComposer`, so we need to load some additional
    JavaScript files with the correct objects. For this, you need to add the following
    at the top of your HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we''ll create a postprocessing effect that converts the output
    using a mosaic effect. You can look at the final result by opening `06.08-create-custom-post-processing-step.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might not recognize this, but what you're seeing is a large number of cubes
    that are rotating.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create this effect by using a custom fragment shader. The following steps
    explain how to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to create `THREE.EffectComposer` and configure the steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far, we have only added the render step (`THREE.RenderPass`), which renders
    the scene and allows us to add additional postprocessing effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use custom shaders, we''ll need to use the `THREE.ShaderPass` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass in `customShader` as an argument to `THREE.ShaderPass`. This `customShader`
    object contains the configuration of our custom shader. The `uniforms` objects
    are the variables we pass into our custom shader, and `vertexShader` and `fragmentShader`
    point to our shader programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s first look at `vertexShader` from step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple vertex shader that doesn't change anything related to the output.
    The only thing to notice in this shader code is that we pass the coordinate that
    we're working on (`uv`, which is automatically passed in by Three.js) to the fragment
    shader as a `varying` value with the `texCoord` name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step is to look at the fragment shader from step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a rather large shader program and explaining the details is a bit out
    of scope for this recipe. In short, what happens is that this shader looks at
    the color of the surrounding pixels and based on that, it determines how to draw
    this pixel. The important item to notice here is `uniform sampler2D tDiffuse`
    at the top of the code. This is the output of the previous render step passed
    into the shader as a 2D texture. Using `tDiffuse` in the calculations, we can
    change the output that is rendered on screen. If we don't want to apply an effect,
    we would just use `vec4 color = texture2D(tDiffuse, texCoord)` to set the output
    color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to update the `render` loop to use composer instead of renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing shaders is difficult work; a setup like this, however, makes it a lot
    easier to create your own custom shaders. Just replace the fragment shader from
    step 4 with your own implementation and you can start experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we've used `THREE.EffectComposer` together with `THREE.RenderPass`
    to render the scene. If we add more steps to `THREE.EffectComposer`, we can access
    the current rendering directly from our shader by accessing the `tDiffuse` texture.
    This way, we can easily add all kinds of effects by just writing a shader that
    uses the `tDiffuse` texture as its input.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write shaders, you can pretty much create whatever you want. Getting
    started with shaders, however, can be rather difficult. A good example of some
    shaders that apply a specific effect can be found at [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).
    The shader we used in this recipe was also adopted from the `hexagonpixalte.js`
    shader that you can find in the `src/filters/fun/hexagonalpixelate.js` folder
    in the mentioned GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can also look at the sources of the effects that are provided by Three.js.
    You can access them directly from GitHub at [https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and
    Custom Shaders*, we''ve also created two custom shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a custom vertex shader* recipe, we explain the steps you need
    to take to set up a custom vertex shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Creating a custom fragment shader* recipe, we explain the steps you
    need to take to set up a custom fragment shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving WebGL output to disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book we've created some very beautiful visualizations so far. The trouble
    with this, however, is that it's difficult to save the output of your rendering
    as an image. In this recipe, we'll show you how you can create a normal image
    from a WebGL-rendered scene, which can be saved to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There isn''t much to do in order to get ready for this recipe. We''ll be using
    standard HTML5 features, which you can apply not just to Three.js-based outputs,
    but to any HTML5 canvas element. We''ve prepared a very simple example page, where
    you test the result of this recipe. For this, open the `06.09-save-webgl-output.html`
    example in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this page, you'll see a single Three.js scene. If you hit the *p* key, the
    current state will be saved as a new image, which you can then download normally.
    Note that in the preceding screenshot, we've zoomed out of the page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we only need to take a couple of simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is register an event listener for key presses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whenever a key is pressed, the `copyCanvas` function will be called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s look at the `copyCanvas` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do here is check which key was pressed. If the *p* key was
    pressed, we'll continue. Next, we take the image data from the canvas with the
    `toDataURL()` function. The final step we need to take is to create a new `img`
    element, assign the data (`imgData`), and add it to the document.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This would work for non-WebGL canvas elements. However, if you work with WebGL,
    we need to take one additional step. We need to instantiate `THREE.WebGLRenderer`
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we don't do this, you'll only see a black screen in the output and not the
    actual WebGL output. Note, though, that this does have an adverse impact on performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In HTML5, it is possible to describe a file or any other resource using a URL
    starting with data. So, instead of fetching resources in multiple HTTP requests,
    these resources could be included directly in the HTML document. The canvas element
    allows you to copy its contents as a URL that complies with this scheme. In this
    recipe, we use this data URL to create a new `img` element, which can be saved
    like a normal image.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dive into the details of the data URL scheme, you can look at
    the RFC (Request For Comments) that describes this scheme at [http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397).
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the most recent version of Chrome and Firefox, you can also save the output
    of an HTML canvas element by right-clicking and selecting **Save Image As**. Besides
    using the standard browser functionality, it is also possible to directly start
    the download of the image. If you use the following piece of code instead of creating
    and adding a new image, the browser will automatically download the canvas as
    an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, If you''ve got an animation that you want to save as a movie, you
    can do that as well. You can find instructions on how to do this at: [http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets)'
  prefs: []
  type: TYPE_NORMAL
