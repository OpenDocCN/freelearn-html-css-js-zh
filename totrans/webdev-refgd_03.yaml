- en: Chapter 3. CSS Concepts and Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cascading Style Sheet** (**CSS**) is the preferred way to style HTML. HTML
    has a style element and a global style attribute. These make it very easy to write
    unmaintainable HTML. For example, let''s imagine that we have 10 elements on an
    HTML page for which we want the font color to be red. We create a `span` element
    to wrap the text that has the font color red, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Later, if we decide to change the color to blue, we will have to change 10 instances
    of that element and then multiply this by the number of pages we have used the
    `span` element on. This is completely unmaintainable.
  prefs: []
  type: TYPE_NORMAL
- en: This is where CSS comes in. We can target specific elements/groups of elements
    to which we wish to apply a specific style. CSS allows us to define these styles,
    easily update them, and change them from one place to another.
  prefs: []
  type: TYPE_NORMAL
- en: This book will focus on the most used CSS selectors, units, rules, functions,
    and properties from CSS1, CSS2.1, and CSS3\. For the most part, these should all
    work in any browser, but there are exceptions. A great rule of thumb is that newer
    browsers will have fewer issues.
  prefs: []
  type: TYPE_NORMAL
- en: We will get started with a quick overview of the different types of basic selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Basic selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A selector represents a structure. This representation is then used in a CSS
    rule to determine what elements are selected to be styled by this rule. CSS style
    rules apply in the form of a waterfall effect. Each rule that is matched is also
    passed on to each of its children, matched and applied based on the weight of
    the selector. This section will only focus on the most basic of selectors.
  prefs: []
  type: TYPE_NORMAL
- en: The basic selectors are either type selectors, universal selectors, attribute
    selectors, class selectors, ID selectors, or pseudo-classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All CSS selectors are case-insensitive. Selectors can also be grouped together
    to share rules. To group selectors, you just have to split them with commas. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the following is the same as the preceding declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The simple selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following selectors are all the simple selectors for CSS.
  prefs: []
  type: TYPE_NORMAL
- en: The type selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `type` selectors selects based on the element name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `E` is the element name and `ns` is a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the simplest way to select elements—using their name. For the most part,
    when using just HTML, you not need to worry about the namespace, as all of the
    HTML elements are in the default namespace. An asterisk can be used to specify
    all namespaces, for example, `*|Element`.
  prefs: []
  type: TYPE_NORMAL
- en: When this selector is used, it will match all of the elements in the document.
    For example, if you have fifteen `h2` elements and use a single `h2` element,
    then this rule will match all fifteen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of the `type` selector. The first code sets all the
    `h1` elements'' font color to red. The next code applies red as the background
    color for all `p` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The universal selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asterisk (`*`) represents any and all qualified elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ns` is a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is essentially a wildcard selector. It will match every element. This is
    `true` even when used with other selectors. For example, `*.my-class` and `.my-class`
    are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use it as a single selector to match every element, it is most
    useful when used with other selectors. Following along with our preceding example,
    we may want to select any element that is a descendant of an `article` element.
    This selector is very explicit and easy to read, take a look at the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example. The first example uses attribute selectors to select any
    elements with `hreflang` in English, and the second example will select all elements
    in the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The attribute selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These selectors will match against attributes of an element. There are seven
    different types of attribute selector and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These selectors are usually preceded by a type selector or universal selector.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This selector is a way to use a regular expression syntax in a selector rule.
    Each of the selectors will act differently based on the use, so they are listed
    with the differences here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[attribute]`: This matches an element that has the `[attribute]` attribute,
    irrespective of the value of the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=]`: The value has to be an exact match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[~=]`: This is used when the attribute takes a list of values. One of the
    values in the list must match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[|=]`: This attribute must either be an exact match or the value must begin
    with the value followed immediately by a `-`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^=]`: This attribute matches the value that has this prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[$=]`: This attribute matches the value that has this suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[*=]`: This attribute matches any substring of the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to really show the difference between these is to use some examples.
    We will look at the `lang` and `href` attributes. The examples will be in the
    same order in which they were introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the HTML file that the examples will be selecting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following, we should have all the spans with a `lang` attribute with
    a black background, Spanish will be grey, German will be red, English will be
    blue, anchor elements that have `https` attribute will be yellow, any PDFs will
    be red, and any anchor to Google will be green. Here are the preceding styles
    described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The class selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This selector will match the HTML elements based on the class attribute of the
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most commonly used selector. Selecting based on the `class` attribute
    allows you to style elements in an orthogonal manner. Classes can be applied to
    many different elements and we can style each of those elements in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: The `class` selector can be stacked so that both classes will have to be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some HTML with different elements that have a class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS to style the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the `red` class is applied to an element, it will change the color of the
    text to red. The compound green and black will only select elements that have
    both classes defined.
  prefs: []
  type: TYPE_NORMAL
- en: The ID selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selector will match based on the `ID` attribute of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ID` attribute should be unique for the document, so the `ID` selector should
    only ever target one element. This is in contrast to the `class` selector, which
    can be used to select multiple elements. As an example, you can use a `class`
    selector to make every image on your page have a certain amount of margin and
    have a rule that specifically targets just your logo to have a different amount
    of margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example CSS rule that targets an ID of a logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Combinators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combinators are used to select more complex structures. They can help target
    specific elements or groups of elements that would be difficult to target otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Descendant combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This selector specifies that an element must be contained by another element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The combinator is the whitespace character. We are explicitly defining it here
    so that it is clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two or more statements used in this selector can be any valid selector statement.
    For example, the first could be a `class` selector followed by a `type` selector.
    The distance between the selectors does not matter. Each intermediate element
    will not have to be listed for the selector to work.
  prefs: []
  type: TYPE_NORMAL
- en: The combinator can be stacked. Each statement will have a whitespace character
    around it. This list of selectors does not need to be all inclusive, but for the
    selector to match the hierarchy, it does need to exist.
  prefs: []
  type: TYPE_NORMAL
- en: This selector is best used when you only want to style elements in certain situations.
    The following example highlights this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first example, we will target images that are in an ordered list with
    the ID of presidents and give them a red border. Here is its HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example that demonstrates that there can be many elements between
    selectors. Here is the very arbitrary HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is an example of a multiple selector hierarchy, which has the
    following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The child combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selector targets a specific child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is very similar to the descendant combinatory except for the fact that
    this only targets a child relationship. The second selector must be a direct descendant
    of the parent directly contained by the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will only target the first span in this HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule that only sets the first span''s color to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The adjacent sibling combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selector targets elements that are next to each other in the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two elements must have the same parent, and the first element must be immediately
    followed by the second.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example that highlights how the selector works. Only the second span
    will have the rule applied. The final span's preceding sibling is not another
    span so it is not matched by the selector. Here is the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**CSS**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The general sibling combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selector targets any element that has the same parent and follows the
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is similar to the adjacent sibling combinatory; in that, both elements
    need the same parent. The difference is that the two elements can be separated
    by other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows that both the second and third spans will be
    targeted even though there is an `em` element between them. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The selector specificity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is not a selector rule like the others in this section. An element can
    be targeted by multiple rules, so how do you know which rule takes precedence?
    This is where specificity comes in. You can calculate which rule will be applied.
    Here is how it is calculated. Keep in mind that an inline style will trump any
    selector specificity:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of `ID` selectors in the selector is denoted by `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of `class` selectors, `attribute` selectors, and pseudo-classes in
    the selector is denoted by `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of `type` selectors and pseudo-elements in the selector is denoted
    by `c`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `universal` selectors are ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The numbers are then concatenated together. The larger the value, the more
    precedence the rule has. Let''s look at some selector examples. The examples will
    be composed of the selector and then the calculated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`h1`: `a=0` `b=0` `c=1`, `001` or `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1 span`: `a=0` `b=0` `c=2`, `002` or `2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1 p > span`: `a=0` `b=0` `c=3`, `003` or `3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1 *[lang="en"]`: `a=0` `b=1` `c=1`, `011` or `11`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1 p span.green`: `a=0` `b=1` `c=3`, `013` or `13`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1 p.example span.green`: `a=0` `b=2` `c=3`, `023` or `23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#title`: `a=1` `b=0` `c=0`, `100`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h1#title`: `a=1` `b=0` `c=1`, `101`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest way to think about this is that each grouping (`a`, `b`, or `c`)
    should be a smaller group of elements to choose from. This means that each step
    has more weight. For example, there can be many instances of `h1` on a page. So,
    just selecting `h1` is a little ambiguous. Next, we can add a `class`, `attribute`,
    or pseudo-class selector. This should be a subset of the instances of `h1`. Next,
    we can search by ID. This carries the most weight because there should only be
    one in the entire document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example HTML that has three headings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule that will target each heading differently. The first rule
    targets all the elements, but it has the lowest specificity, the next rule is
    in the middle, and the last rule only targets one element. In the following example,
    `/* */` denotes text that is a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Pseudo-classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pseudo-classes are selectors that use information that is outside of the document
    tree. The information that is not in the attributes of the element. This information
    can change between visits or even during the visit. Pseudo-classes always have
    a colon followed by the name of the pseudo-class.
  prefs: []
  type: TYPE_NORMAL
- en: The link pseudo-classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two mutually exclusive link pseudo-classes, namely, `:link` and `:visited`.
  prefs: []
  type: TYPE_NORMAL
- en: :link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This selects links that have not been visited. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This pseudo-class exists on any anchor element that has not been visited. The
    browser may decide to switch a link back after some time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example along with the `:visited` pseudo-class. Here is its HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. We can make an assumption that you have visited Google, so
    the link would likely be green in color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: :visited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This selects links that have been visited. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This pseudo-class exists on any anchor element that has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example along with the `:link` pseudo-class. Here is its HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. We can make the same assumption that you have visited Google,
    so the first link should be red and the second link will be green in color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: User action pseudo-classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These classes take effect based on actions of the user. These selectors are
    not mutually exclusive, and an element can have several matches at once.
  prefs: []
  type: TYPE_NORMAL
- en: :active
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is used when the element is being activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The :`active` selector is most commonly used when the mouse button is pressed
    but not released. This style can be superseded by the other user actions or link
    pseudo-classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The link will turn green while you are clicking on it. Here is its CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: :focus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This selector targets the element that has to be focused on. The syntax is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An element is considered to have focus when it accepts keyboard input. For example,
    a text input element that you have either tabbed to or have clicked inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a text input example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This also highlights the fact that you can use a pseudo-class,
    which allows use of more complex selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: :hover
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This selector targets the elements when a user hovers their mouse over an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is used when a user has their cursor hovering over an element. Some browsers
    (a great example being mobile touch devices, such as mobile phones) may not implement
    this pseudo-class, as there is no way to determine whether a user is hovering
    over an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The text in the span will be red in color when hovered over. Here is its CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The structural selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These selectors allow you to select elements based on the document tree; this
    is very difficult or impossible to do with other selectors. This only selects
    nodes that are elements and does not include text that is not inside an element.
    The numbering is `1-` based indexing.
  prefs: []
  type: TYPE_NORMAL
- en: :first-child
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets an element that is the first child of another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the same as `:nth-child(1)`. This selector is straightforward, the first
    child of the element type this is applied to will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will only select the first paragraph element. Here
    is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This will change the text of the first paragraph red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: :first-of-type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets the first element type that is a child of another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:first-of-type` attribute is different from `:first-child` because it will
    not select the element unless it is the first child. This is the same as `:nth-of-type(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will target the first paragraph element even though
    it is not the first child. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: :last-child
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets an element that is the last child of another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the same as `:nth-last-child(1)`. This selector is straightforward,
    the last child of the element type this is applied to will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will only select the last paragraph element. Here is
    the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This will change the color of the second and first paragraph
    red. This selector works because even on the most basic of pages, the `p` element
    is a child of the `body` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: :last-of-type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets the last element type that is a child of another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:last-of-type` attribute is different from `:last-child` because it will
    not select the element unless it is the first `last-child` attribute. This is
    the same as `:nth-last-of-type(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will target the last paragraph element. Here is its
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: :nth-child()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will divide all of the child elements and select them based on where they
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This selector has a parameter that is very expressive in what you can select.
    This also means that it is more complex than most other CSS rules. Here is the
    technical specification of the parameter. This selects elements based on its preceding
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter can be split into two parts: part `a` Part `b`. The part `a`
    is an integer that is followed by the character `n`. Part `b` has an optional
    plus or minus sign followed by an integer. The parameter also accepts two keywords:
    even and odd. Consider *2n+1* for example.'
  prefs: []
  type: TYPE_NORMAL
- en: This is much easier to understand when you look at it this way. The first part,
    `an`, is what the children are divided by. The `2n` value would make groups of
    two elements and `3n` value would make groups of three elements, and so on. The
    next part `+1` will then select that element in the grouping. *2n+1* would select
    every odd item row because it is targeting the first element in every grouping
    of two elements. *2n+0* or *2n+2* would select every even item row. The first
    part, part `a`, can be omitted, and then it would just select the *n*th child
    out of the entire group. For example, *:nth-child(5)* would only select the fifth
    child and no other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table rows are a great example of using this selector, so we will target every
    odd row. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: :nth-last-child
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will target the nth element from the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This selector counts the succeeding elements. The counting logic is the same
    as it is for `:nth-child`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a table. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The first CSS rule will change the color of every other row to red, but because
    it counts from the end, the first and third row will be selected. The second CSS
    rule will only target the last row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section `:nth-child`.
  prefs: []
  type: TYPE_NORMAL
- en: :nth-last-of-type and :nth-of-type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This selects elements based on their type and where they exist in the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like all the other *n*th selectors, this one uses the same logic as `:nth-child`.
    The difference nth-of-type being that `:nth-last-of-type` only groups by elements
    of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses paragraphs and spans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This rule will only target the paragraphs and make the odd
    ones red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section `:nth-child`.
  prefs: []
  type: TYPE_NORMAL
- en: :only-child
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets an element that has no siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will match when the `:only-child` attribute is the only child of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with two tables, where one has multiple rows and the other
    has only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS to target the only row in the second table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: :only-of-type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets when there is only one of this element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will only match when there are no other siblings of the same type under
    a parent element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses arbitrary divisions to create a structure where
    one paragraph element is the only one of its type. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS rule that will only target the first paragraph''s element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are pseudo-classes that can be used to target the state of input elements
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: :checked
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This attribute targets the checked radio button or checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any element that can be toggled on or off can use this selector. As of now,
    these are radio buttons, checkboxes, and options in a selective list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with a `checkbox` and a `label` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a CSS rule that will target the label only when the checkbox is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: :default
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets the default element from many similar elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use this selector to help define the default element from a group of elements.
    In a form, this would be the default button or the initially selected option from
    a `select` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This will only target the submit input as it is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: :disabled and :enabled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These will target elements based on their enabled state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a disabled attribute that is available on interactive elements. Using
    `:disabled` will target elements where the `:disabled` attribute is present and
    `:enabled` will do the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some HTML with two inputs out of which one is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The disabled input will have its text color set as red and
    the other as green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: :empty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets elements that have no children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This targets nodes without any children. Children can be any other element including
    text nodes. This means that even one space will count as a child. However, comments
    will not count as children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with three `div` tags. The first is empty, the next has
    text, and the final one has one space in it. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. Only the first div will have a red background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: :in-range and :out-of-range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These selectors target elements that have a range limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some elements now have range limitations that can be applied. When the value
    is outside of this range, the `:out-of-range` selector will target it, and when
    the value is within the range, `:in-range` will target it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses an input that is the number type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The first input will have red text because it is beyond the
    maximum range and the second will have green text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: :invalid and :valid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `:invalid` and `:valid` attribute targets an element based on the validity
    of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain input elements have data validity, a great example being the e-mail
    element. The selectors select based on whether the data is valid or not. You should
    note that some elements are always valid, for example, a text input, and some
    elements will never be targeted by these selectors, for example, a `div` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with an e-mail input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The first input will be green as it is valid and the other
    will be red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: :not or negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `:not` attribute negates a selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:not` parameter must be a simple selector and will target the elements
    where the `:not` parameter is not `true`. This selector does not add to specificity
    of the rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. Only the first paragraph will be targeted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: :optional and :required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `:optional` and `:required` attributes target elements that are either optional
    or required, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is used for any input element that is required or optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that has two inputs—one that is required and one that is
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The required input will have red text and the optional input
    will have green text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: :lang()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `:lang()` attribute targets based on the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This selector works differently to the attribute selector; in that, this will
    target all elements that are in a specific language even if they are not explicitly
    defined. The attribute selector will only target elements that have a `lang` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with a `span` element that does not have a `lang` attribute,
    but it is the child of the body which does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The first rule will match the element, but the second will
    not match anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Pseudo-elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are selectors that go beyond what is specified in the document. The selectors
    select things that may not even be elements in the document. Pseudo-elements are
    not considered part of a simple selector. This means that you cannot use a pseudo-element
    as part of the `:not()` selector. Finally, only one pseudo-element can be present
    per selector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that all of the pseudo-elements start with a double colon (`::`). This
    was introduced in CSS3 to help differentiate between pseudo-classes that have
    a single colon (`:`). This is important because in CSS2, pseudo-elements only
    had the single colon. For the most part, you should use the double colon.
  prefs: []
  type: TYPE_NORMAL
- en: ::before and ::after
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are used to insert generated content before or after the selected element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will insert content into the document based on the selector. Whether the
    content is placed before or after the element targeted depends on the pseudo-element
    used. Refer to the *Generated content* section to see what you can insert.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example that uses both `::before` and `::after`. This will create
    a turkey sandwich. Here is the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS that will put a slice of bread before and after the turkey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Generated content*'
  prefs: []
  type: TYPE_NORMAL
- en: ::first-letter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets the first letter of an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will select the first letter of an element as long as it does not have
    any other content before it, for example an `img` element before a character would
    make `::first-letter` not select the first character. Any punctuation that either
    precedes or follows the first letter would be included with the first letter.
    This will select any character, including not just letters but also numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This only applies to block-like containers such as block, `list-item`, `table-cell`,
    `table-caption`, and `inline-block` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `::first-letter` pseudo-element will only match if the first letter is on
    the first formatted line. If there is a line break before the first letter appears,
    it will not be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, which will not select the first letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The T in This will be two times the font size of all the other
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: ::first-line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `::first-line` attribute targets the first line of an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will target the first formatted line of a block-like container such as
    a `block box`, `inline-block`, `table-caption`, or `table-cell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, with the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. This will make the first line, whatever it may be, red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: ::selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This targets text highlighted by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pseudo-element allows you to style any text that is highlighted by the
    user. This pseudo-element does not exist in CSS3, but it is part of the next version.
    Most browsers will still honor this pseudo-element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. When the text is selected, the text will be white on a red
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Generated content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a selector, but is used with the pseudo-elements `::before` and
    `::after`. There are only certain types of content that you can generate. Here
    is a rundown.
  prefs: []
  type: TYPE_NORMAL
- en: content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the content that will be placed either before or after elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following are the parameters and their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`: This parameter does not generate any content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal`: This is the default parameter and is the same as none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<string>`: This is any string text content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<uri>`: This will map to a resource, for example, an image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<counter>`: This can be used as either the `counter()` or `counters()` function
    to put a counter before or after each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open-quote` and `close-quote`: This is used with the quotes generated content
    property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-open-quote` and `no-close-quote`: This does not add content, but increments
    or decrements the nesting level of quotes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attr(x)`:This returns the value of the attribute of the element this is targeting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property is used to add content to the document. The output is controlled
    by the value used. The values can be combined to create more complex content.
  prefs: []
  type: TYPE_NORMAL
- en: A new line can be inserted with the characters `\A`. Just remember that HTML
    will ignore a line break by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples. These will demonstrate how to use many of the content
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the CSS. The `h1` elements will have the word "`chapter`" along with
    a number before each. The `h2` element will have a line break in its content.
    Finally, the `blockquote` will have an opening quote and a closing quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Quotation marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quotation marks specify which characters are used as open and close quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<string> <string>`: These are pairs of characters that will represent an open
    and close quote. You can use this multiple times to create levels of quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use this property to set which quotation marks are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that has a nested quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The quotation marks are completely arbitrary. Here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
