<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Extending JavaScript and ECMAScript 6</h1></div></div></div><p>ECMA 262 is a standard that defines the core features of the JavaScript language. The language that is defined by this standard is called <strong>ECMAScript</strong>. JavaScript is an implementation of <a class="indexterm" id="id2377"/>ECMAScript. It runs in web browsers at the client end, while Node.js runs at the server end. ECMAScript 6 was released in June 2015. ES6 is a major update from ES5, which was released in 2009.</p><p>A complete <a class="indexterm" id="id2378"/>language specifications draft of ES6 language specifications can be obtained from <a class="ulink" href="https://people.mozilla.org/~jorendorff/es6-draft.html">https://people.mozilla.org/~jorendorff/es6-draft.html</a>.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Compatibility and goals</h1></div></div></div><p>The ES6 <a class="indexterm" id="id2379"/>compatibility chart shows which features of ES6 are supported in the current browsers. It also links all listed features to their specification guides.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>It should be noted that some of the features might not be under compliance with their exact specifications. While working in Chrome, don't forget to enable the Experimental JavaScript flags.</p></div></div><div><img alt="Compatibility and goals" src="img/B03289_10_01.jpg"/><div><p>Reference: Use ECMAScript 6 Today</p></div></div><p>ECMA6 script <a class="indexterm" id="id2380"/>has the following major goals:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default exports</li><li class="listitem" style="list-style-type: disc">Static structure of modules</li><li class="listitem" style="list-style-type: disc">Support for asynchronous and synchronous loading</li><li class="listitem" style="list-style-type: disc">Used for dependencies between modules</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec75"/>JavaScript subset and extensions</h1></div></div></div><p>Subsets are <a class="indexterm" id="id2381"/>mostly defined for security purposes; scripts written using secure language subsets can be executed safely even if its source is untrusted, for instance, an ad server. Some of these subsets will be described later.</p><p>As JavaScript continued to evolve and allowed explicit extensions, newer versions were released. Many of the features were standardized. These extensions are compatible with modern browsers such as Firefox and Chrome. However, the implementation of non-standard extensions may require an external compiler because these features are being updated in major JavaScript engines now.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec474"/>JavaScript subsets</h2></div></div></div><p>As stated earlier, for <a class="indexterm" id="id2382"/>execution security of untrusted code, we use subsets in JavaScript. For example, when we have a credit card checking script in which a credit card number is sent to a remote server, then for this type of information security, we use subset. By defining a subset, we check the behavior of a program that we have strictly not allowed. So, it means that we use subsets for a certain amount of code, and the other part of the code is omitted.</p><p>There are two goals of a JavaScript subset:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The subset construct should be added to maximize coverage use of JavaScript constructs</li><li class="listitem" style="list-style-type: disc">It is used to extend analysis to accommodate changes</li></ul></div><p>These subset are defined for every reason.</p><p>
<strong>The good parts</strong>: This <a class="indexterm" id="id2383"/>is a subset that is part of the language used for the best and the worthy part of the script. The main goal of this subset is it purifies and simplifies code, and makes the script easier and more understandable. The good parts subset does not have an <code class="literal">eval()</code> function. It also eliminates the <code class="literal">continue</code> and <code class="literal">with</code> statements. It does not include function definition statements, and only defines function using the function definition expression. Using a function definition statement, it defines a function, and then, after defining the function, it does not use the function definition statement.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>In subset curly brackets, we have a body of loops and conditional statements. If there is a single statement in the body, then it would not allow the brackets to be omitted.</p></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec706"/>Secure subsets</h3></div></div></div><p>There are various <a class="indexterm" id="id2384"/>implementations of secure subsets. Some of <a class="indexterm" id="id2385"/>them are briefly described here.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec528"/>ADsafe</h4></div></div></div><p>
<strong>ADsafe</strong> (<a class="ulink" href="http://www.adsafe.org/">http://www.adsafe.org/</a>) was one of the first presented security subjects. It was proposed and <a class="indexterm" id="id2386"/>created by Douglas Crockford. ADsafe uses tools such <strong>asJSLint</strong> (<a class="ulink" href="http://www.jslint.com/">http://www.jslint.com/</a>) to verify the unsafe code. It enforces good programming practices, so the likelihood of unsecure code executing correctly is much <a class="indexterm" id="id2387"/>higher. It <a class="indexterm" id="id2388"/>blocks the script from accessing the global variables or accessing the DOM directly. Instead, it allows the script to access the ADsafe object, which provides access to a secure API and indirect access to the DOM elements. ADsafe does not alter scripts and has no impact on its functionality. It enables us to determine quickly whether the script is safe to be placed on a page. It also works as a base that helps in the development of other secure subsets.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec529"/>Dojox</h4></div></div></div><p>The <strong>dojox.secure</strong> tool (<a class="ulink" href="https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html">https://dojotoolkit.org/reference-guide/1.10/dojox/secure.html</a>) is a security subset inspired from ADsafe. It is an extension of the <strong>Dojo</strong> <a class="indexterm" id="id2389"/>toolkit (<a class="ulink" href="http://dojotoolkit.org">http://dojotoolkit.org</a>) and <a class="indexterm" id="id2390"/>was developed by Kris Zyp. It is <a class="indexterm" id="id2391"/>fully packed with components that ensure safe execution and loading <a class="indexterm" id="id2392"/>of untrusted code, content, ads, and widgets from a different domain. It provides a sandbox environment and limited DOM elements for interaction:</p><div><img alt="Dojox" src="img/B03289_10_02.jpg"/></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec530"/>Caja</h4></div></div></div><p>
<strong>Caja</strong> (<a class="ulink" href="https://developers.google.com/caja/">https://developers.google.com/caja/</a>) is an open source secure subset powered by Google. Caja (which means "<strong>box</strong>" in Spanish) further defines two subsets:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Cajita</strong> (which <a class="indexterm" id="id2393"/>means "<strong>small box</strong>" in Spanish) is a narrow subset just like <a class="indexterm" id="id2394"/>ADsafe and dojox.secure</li><li class="listitem" style="list-style-type: disc"><strong>Valija</strong> (which means "<strong>suitcase</strong>" in Spanish) is a broader subset and is much more similar to <a class="indexterm" id="id2395"/>ECMAScript in strict mode (with the <code class="literal">eval()</code> method <a class="indexterm" id="id2396"/>removed)</li></ul></div><p>Caja is a compiler tool that transforms third-party content such as HTML, CSS, and JS into secure code, which is then easy to embed in a website.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec531"/>FBJS</h4></div></div></div><p>
<strong>FBJS</strong> (<a class="ulink" href="https://github.com/facebook/fbjs">https://github.com/facebook/fbjs</a>) is a JavaScript secure subset used by Facebook. It allows <a class="indexterm" id="id2397"/>untrusted code to be executed in a secure environment. It <a class="indexterm" id="id2398"/>transforms code to ensure security. During the transformation, all top-level identifiers are renamed by adding the module-specific prefix. Adding module specific prefix prevents querying any global identifiers. For example, you are developing an app having the <code class="literal">xyz123</code> ID, and there is a <code class="literal">foo()</code> function in the code. It will eventually become <code class="literal">xyz123_foo()</code>. Even <a class="indexterm" id="id2399"/>function calls to <code class="literal">eval()</code> are redirected to a non-existent function.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec532"/>Microsoft's web sandbox</h4></div></div></div><p>Microsoft's <strong>Web Sandbox</strong> (<a class="ulink" href="http://www.websandbox.org/">http://www.websandbox.org/</a>) defines a broad secure subset of <a class="indexterm" id="id2400"/>JavaScript, HTML, and CSS. Sandbox implements <a class="indexterm" id="id2401"/>host virtualization to provide security and extensibility. The untrusted code is executed in a virtual machine instead of running directly in a browser. A virtual machine quarantines the untrusted code, which prevents it from interacting with the elements outside the virtual machine. Let's take a look at the following block diagram:</p><div><img alt="Microsoft's web sandbox" src="img/B03289_10_03.jpg"/><div><p>Microsoft's Web Sandbox</p></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec475"/>JavaScript extensions</h2></div></div></div><p>Lots of new and useful <a class="indexterm" id="id2402"/>features have been coded. They will be standardized with the release of ES6. ES6 was set to be officially released in June 2015. However, many of the features and extensions are already available on Firefox and Chrome (Experimental JavaScript flag has to be turned <em>on</em> in order to access some of the ES6 features). We will discuss the major features in the rest of the chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec476"/>Const</h2></div></div></div><p>It works like <a class="indexterm" id="id2403"/>variable keyword <code class="literal">var</code>. For declaring a constant, we use the word <code class="literal">const</code>. In order to use assignment we must declare constant.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>Values declared with the const  can not be redeclared, redefined or reinitialized. JavaScript provide 8 constants through math object. One of them is PI. we can not reinitialize PI using const.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec477"/>Let</h2></div></div></div><p>The <code class="literal">Let</code> keyword is <a class="indexterm" id="id2404"/>used for the block scoping of variables. The variables are declared at the start of the code instead of at the start of functions:</p><div><pre class="programlisting">var name = "john";
console.log(name);</pre></div><p>In the preceding example, the name <code class="literal">john</code> is the value of name logged in console. The declarations in JavaScript are moved to the top. The position of the variables declared or initialized in the scope of the function does not matter, and they will be hoisted to the top by default. JavaScript's default conduct is to move variable declarations to the top.</p><p>Hoisting is JavaScript's default behavior to move variable declarations to the top.</p><p>Variables in JavaScript are function scoped. This means, variables are available throughout the function, even if they are declared in a nested code block. Here is a short example in which we will log the output in the console of our client, that is, Chrome, Firefox, and so on:</p><div><pre class="programlisting">var name = "john";
(function () {
  // var name = undefined;
  if (!name)
  { var name = "jane"; }
  console.log(name); // "jane"
}());</pre></div><p>From the preceding example, the value of name used to log-in into the console is <code class="literal">jane</code>.</p><p>ES6 handles this issue with let. Let is very much like <code class="literal">var</code>. The only difference is that <code class="literal">let</code> is block scoped, and <code class="literal">var</code> is function scoped. We can rewrite the previous example using let, as shown here:</p><div><pre class="programlisting">var name = "john";
(function () {
  // var name = undefined;
  if (!name) {
    let name = "jane";
  }
  console.log(name); // "john"
}());</pre></div><p>Notice that although the value of name is <code class="literal">jane</code> inside the function, using the <code class="literal">let</code> keyword sets its scope to global and the value of name defaults to <code class="literal">john</code>. Hence, <code class="literal">john</code> is logged in the client's console.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>If we declare a variable as a constant, assign it some value, use the same constant somewhere else that changes its value, then its new value will be ignored. Like <a class="indexterm" id="id2405"/>variables, we can add constants anywhere in our script without breaking our code.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec478"/>Destructuring assignment</h2></div></div></div><p>We can assign <a class="indexterm" id="id2406"/>multiple values to the variables in a function using one command.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec479"/>For each</h2></div></div></div><p>The iteration of property <a class="indexterm" id="id2407"/>value is done using this loop. The iteration of property name is done.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec480"/>Iterator</h2></div></div></div><p>The object for the <a class="indexterm" id="id2408"/>next method is returned. The object that is returned has <code class="literal">_iterator_</code> property. The iterator is used for <code class="literal">iteratable</code> objects.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec481"/>Generators</h2></div></div></div><p>The generation of <a class="indexterm" id="id2409"/>object is done here. A generated object is returned whenever a function invokes the <code class="literal">this</code> method. The <code class="literal">yield</code> keyword is used. The current execution of the function is specified by the generated object.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec482"/>Array</h2></div></div></div><p>The <code class="literal">iteratable</code> objects <a class="indexterm" id="id2410"/>with the same values in the array are shorthanded by the use of array.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec483"/>Generator expression</h2></div></div></div><p>The functions are <a class="indexterm" id="id2411"/>shorthanded for multiple <code class="literal">try-catch</code> expressions. The thing that is returned is the generated object wrapped in <code class="literal">{}</code> and not in <code class="literal">[]</code>. We use this for multiple values to variables in the function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Scoped variables and constants</h1></div></div></div><p>When we <a class="indexterm" id="id2412"/>declare a variable, then it has a local scope and a global scope. We can define a variable anywhere in our script. When we declare a variable in JavaScript, we can assign a value to it at the time of declaration or later. Here is an example:</p><div><pre class="programlisting">_xyz123; // variable declared without assigning a value to it
varabc = "Star"; //variable declared while assigning a value to it</pre></div><p>In JavaScript, a variable is defined by a dollar sign the same as in query. In JavaScript, we create variables dynamically using the <code class="literal">var</code> keyword. Every variable has a name and a value associated with it. These values can be of any type, such as <code class="literal">number</code>, <code class="literal">array</code>, <code class="literal">string</code>, and so on. A variable name could be a combination of characters and numbers. Here is an example:</p><div><pre class="programlisting">(a==undefined){
a=5}</pre></div><p>A variable that is <a class="indexterm" id="id2413"/>declared outside a function is a <strong>global variable</strong> having a global scope. This means that it can be accessed from anywhere within a script.</p><p>We can also <a class="indexterm" id="id2414"/>declare a variable constant with the <code class="literal">const</code> keyword. A constant variable value is constant.</p><p>Constants can be defined using the <code class="literal">const</code> keyword as shown here:</p><div><pre class="programlisting">Const a=5;</pre></div><div><div><h3 class="title"><a id="note54"/>Note</h3><p>The <code class="literal">const</code> and <code class="literal">let</code> keywords work in a similar way that they both are block scoped. However, in the case of <code class="literal">const</code>, values cannot be redeclared, redefined, or reinitialized. In short, const values are read-only.</p></div></div><p>Here is a working example:</p><div><pre class="programlisting">const PI = 3.14159265359;

console.log("value of PI = " + PI); //value of PI = 3.14159265359

PI = 3.1415; //&lt;------- Can not re-assign value to PI

console.log("value of PI = " + PI); //value of PI = 3.14159265359

const PI = 2.0312; //&lt;------- Can not re-initialize value of PI

console.log("value of PI = " + PI); //Uncaught TypeError: Identifier 'PI' has already been declared

var PI = 9.2144; //&lt;------- Can not re-declare value of PI

console.log("value of PI = " + PI); //Uncaught TypeError: Identifier 'PI' has already been declared.</pre></div><p>The <code class="literal">class</code> <a class="indexterm" id="id2415"/>variables are declared in the class but not within methods of any class, whereas the local variable exits within the methods of any class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Shorthand functions</h1></div></div></div><p>Shorthand function, also known as <strong>expression closure</strong>, is a technique to use simple <a class="indexterm" id="id2416"/>functions in JavaScript. It is used to omit a function's curly <a class="indexterm" id="id2417"/>brackets in the event; it returns a <code class="literal">true</code> or <code class="literal">false</code> statement. Similarly, if you omit the <code class="literal">return</code> keyword, it would also send you the exact same result.</p><p>The expression will be evaluated quickly after the argument list in your script by omitting the curly brackets and the <code class="literal">return</code> keyword.</p><p>Here is an example:</p><div><pre class="programlisting">Let student=function(a)
A+1, yes
Function()
True,no</pre></div><p>This behaves similarly like functions. They are defined with curly brackets and a <code class="literal">return</code> statement. This is very useful when we want to pass a function as an argument to a function.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Multiple catch clauses</h1></div></div></div><p>In <a class="indexterm" id="id2418"/>JavaScript, <code class="literal">try/catch</code> statements are use to handle exceptions present in the <code class="literal">try</code> code blocks.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec484"/>The try clause</h2></div></div></div><p>In the <code class="literal">try</code> <a class="indexterm" id="id2419"/>block, the statements to be evaluated are executed.</p><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>If you want to <a class="indexterm" id="id2420"/>deliberately throw an exception, we would use the <code class="literal">throw</code> statement. This will abort the execution of the remaining statements, and the control will move to the <code class="literal">catch</code> block.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec485"/>The catch clause</h2></div></div></div><p>After checking <a class="indexterm" id="id2421"/>and encountering an error in the statements in the <code class="literal">try</code> block, the exception block is called. If the exception encountered is the same as the exception handled in the <code class="literal">catch</code> block, then the control immediately shifts to the <code class="literal">catch</code> block, and the statements within the <code class="literal">catch</code> block are executed.</p><p>The statements presented <a class="indexterm" id="id2422"/>after the erroneous statement will <em>not</em> be executed, unless there is a <code class="literal">return</code> statement in the <code class="literal">finally</code> block.</p><div><div><h3 class="title"><a id="tip43"/>Tip</h3><p>A good practice is to use a conditional catch clause first if we anticipate that any exception will occur. An unconditional catch clause is placed last to handle all the remaining exceptions:</p><div><pre class="programlisting">try {
  demotrycatchfunction(); // may throw any type of exceptions
}
catch (e) {
  if (e instanceofReferenceError) {
    // statements to handle ReferenceErrorexceptions
  } else if (e instanceofSyntaxError
) {
  // statements to handle SyntaxError exceptions
  }
  else if (e instanceofEvalError) {
    // statements to handle EvalError exceptions
  }
  else {
    // statements to handle any unspecified exceptions
    logMyError(e); // pass the exception object to the error handler
  }
}</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec486"/>The finally clause</h2></div></div></div><p>This block <a class="indexterm" id="id2423"/>will execute statements present within at end, whether an <a class="indexterm" id="id2424"/>exception has occurred or not. The statements in a <code class="literal">finally</code> block execute irrespective of whether an error occurred. The <code class="literal">finally</code> block generally contains code that must be executed regardless of anything. Hence, we generally release resources and close connection inside a <code class="literal">finally</code> block. The syntax for writing a simple <code class="literal">try-catch-finally</code> block is as follows:</p><div><pre class="programlisting">try {
  //try code - This is the Code block to try
}
catch(error) {
  //catch code – This is the Code block that handle errors
}
finally {
  //finally code - This is the Code block to be executed regardless of try catch results
}</pre></div><p>We can also write <a class="indexterm" id="id2425"/>this with a nested <code class="literal">catch</code> blocks like this:</p><div><pre class="programlisting">try {
  //do something
}
catch (Exception e) {
  try {
    //do something with little likeliness of output
  }
  catch (Exception ex) {
    try {
      //do the minimum acceptable
    }
    catch (Exception e1) {
      //More try catches?
    }
  }
}</pre></div><p>Here is an <a class="indexterm" id="id2426"/>example showing the working of multiple <code class="literal">catch</code> clauses:</p><div><pre class="programlisting">functionCheckEligibility(Age) {
  var result;
  try { //try block
    if (Age &lt; 16 { //condition to be tested
    throw new Error("Children below the age of 16 are not allowed. Parent Supervision needed!"); //incase of false result, an error will be raised
    }
  result = age;
  }
  catch (e) { //catch block
    console.log(e.toString()); //error is converted to string and logged into the console
    throw e; //Uncaught Error
  }
  finally { // finally block - It will run in the end regardless of the try, catch results
    console.log("Age doesn't matter!"); 
  }

  return result;
};</pre></div><p>Let's pass 14 as the <a class="indexterm" id="id2427"/>argument to the function, as shown here:</p><div><pre class="programlisting">CheckEligibility(14);</pre></div><p>The output will be as follows:</p><div><pre class="programlisting">Children below the age of 16 are not allowed. Parent Supervision needed!</pre></div><div><div><h3 class="title"><a id="note55"/>Note</h3><p>In <code class="literal">try-catch</code> statements, we must have at least one <code class="literal">finally</code> or <code class="literal">try-catch</code> block. <code class="literal">Try</code> doesn't necessarily need a <code class="literal">catch</code> clause. If a <code class="literal">try</code> statement does not contain at least one <code class="literal">catch</code> block, it must contain a <code class="literal">finally</code> block. The possible exception handling clauses with <code class="literal">try-catch-finally</code> are the <code class="literal">try-catch</code>, <code class="literal">try-finally</code>, or <code class="literal">try-catch-finally</code> clauses.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>E4X – ECMAScript for XML</h1></div></div></div><p>It is an <a class="indexterm" id="id2428"/>extension in JavaScript for support of XML extension with <a class="indexterm" id="id2429"/>JavaScript. By using E4x, it provides easy access for XML document by the DOM interface. It is a server-side technology used in <strong>Rhino</strong> and <strong>SpiderMonkey</strong> <a class="indexterm" id="id2430"/>because these are powerful extensions by all browsers.</p><p>Before E4X, it was <a class="indexterm" id="id2431"/>very difficult and time consuming for reading and writing in XML. In JavaScript, E$X provides XML document as a XML object, which represents XML fragments as a <code class="literal">xmlList</code>. E4X supports special kinds of XML objects. This technique is used in client-side programming.</p><p>Here is an example:</p><div><pre class="programlisting">varstudent=&lt;student&gt;
&lt;studentInfo&gt;
&lt;name&gt;Ali&lt;/name&gt;&lt;/studentInfo&gt;
&lt;/student&gt;</pre></div><p>If we enter this <a class="indexterm" id="id2432"/>XML into our JavaScript code, the E4X interpreter will handle it as an XML object in your script.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>ECMAScript 6 features</h1></div></div></div><p>ECMAScript 6, otherwise called <strong>ECMAScript 2015</strong>, is the most recent form of the ECMAScript <a class="indexterm" id="id2433"/>standard. ES6 is an important upgrade to the language, and the <a class="indexterm" id="id2434"/>first update to language since the release of ES5.1 in June 2011</p><p>A few of the new features of ES6 are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arrow functions</li><li class="listitem" style="list-style-type: disc">Classes</li><li class="listitem" style="list-style-type: disc">Enhanced object literals</li><li class="listitem" style="list-style-type: disc">Destructuring assignment</li><li class="listitem" style="list-style-type: disc">Extended parameter handling</li><li class="listitem" style="list-style-type: disc">Generator</li><li class="listitem" style="list-style-type: disc">Modules</li><li class="listitem" style="list-style-type: disc">Proxy</li></ul></div><p>We will look at all these functions in the upcoming sections.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec487"/>Arrow functions</h2></div></div></div><p>Arrow functions are <a class="indexterm" id="id2435"/>also known as <strong>fat arrow functions</strong>. It is a function and is similar to what we use in C#, Java, and Coffee Script. Statements and <a class="indexterm" id="id2436"/>expression bodies are supported by arrows. The lexical <a class="indexterm" id="id2437"/>of arrows is similar to its surrounding code. This is not the case in functions.</p><p>As the name suggests, arrow functions use a shorter syntax, an arrow (<code class="literal">=&gt;</code>), for definition and in syntax.</p><p>For example, look at the following example:</p><div><pre class="programlisting">// An empty arrow function returns undefined
let empty =()=&gt;{};

(()=&gt;"pine")()// returns "pine"

var simple = a =&gt; a &gt;20?20: a;
simple(20);// 20
simple(10);// 10

let max =(a, b)=&gt; a &gt; b ?a : b;

// Easy array filtering, mapping, ...

varsampleArray=[7,4,1,0,3,5,11];
var sum =sampleArray.reduce((a, b)=&gt; a + b);// The answer is 29
var even =sampleArray.filter(v =&gt; v %2==0);// The answer is [4, 0]
var odd =sampleArray.filter(v =&gt; v %2!=0);// The answer is [7, 1, 3, 5, 11]
var double =sampleArray.map(v =&gt; v *2);// The answer is[14, 8, 2, 0, 6, 10, 22]</pre></div><p>An arrow function expression or a fat arrow function are shorter in syntax when compared with function expressions. Arrow function is used to bind the value of this. (It does not binds its own <code class="literal">arguments</code>, <code class="literal">super</code>, <code class="literal">this</code> or <code class="literal">new.target</code>). Arrow functions are anonymous.</p><p>The <code class="literal">yield</code> keyword is <a class="indexterm" id="id2438"/>used to <code class="literal">pause</code> and <code class="literal">resume</code> a generator function (<code class="literal">function*</code> function keyword with an asterisk defines a <code class="literal">generator</code> function that returns a <code class="literal">Generator</code> object).</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec488"/>Classes</h2></div></div></div><p>ES6 classes' <a class="indexterm" id="id2439"/>syntax is simpler and easier than that of area syntactical sugar <a class="indexterm" id="id2440"/>over the prototype-based object-oriented pattern. It is a syntactical sugar. One-time declaration makes class patterns easier to use and simplifies the use of class patterns. Classes support constructors, instance, prototype-based inheritance, static methods, and super calls.</p><p>Here is an example <a class="indexterm" id="id2441"/>of writing a class in ES6 and ES5:</p><div><pre class="programlisting">//ES5
functionsomeES5Class(fname, age) { // standard way to create an object prototype i.e. constructor function
  this.fname = fname;
  this.age = age;
}

someES5Class.prototype.sayName = function() { //prototype property enables us to add new functions to an existing prototype
  console.log(this.fname);
}

someES5Class.prototype.sayAge = function() { //prototype property enables us to add new functions to an existing prototype
  console.log(this.age);
}

varmyInstance = new someES5Class('Talha', 25); //new keyword is used with a constructor function to create new objects from the same prototype
myInstance.sayName(); //the new method can then be called as a regular member
myInstance.sayAge();

/*Output:
Talha
25*/

//ES6
classsomeES6Class { // ES6 class
  constructor(fname, age) { // a constructor is defined with default parameters
    this.fname = fname;
    this.age = age;
  }

  sayName() { //functions can be added to the class
    console.log(this.fname);
  }

  sayAge() { //functions can be added to the class
    console.log(this.age);
  }
}

varmyInstance = new someES6Class('Talha', 25); //new keyword is used to create new objects from the class
myInstance.sayName(); //functions are the class members and can be called directly
myInstance.sayAge();
/*Output:
Talha
25*/</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec489"/>Enhanced object literals</h2></div></div></div><p>Object literals <a class="indexterm" id="id2442"/>is one of the most popular patterns of JavaScript. JSON is based on object literals. The reason for its popularity is that it provides a very <a class="indexterm" id="id2443"/>quick, short, and neat way to do <code class="literal">key:value</code> assignments, define methods, evaluate expressions, and make super calls. ES6 has extended the object literal syntax in various ways. This makes them more useful. Two types of extensions for object literals are explained here.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec707"/>Property initializer shorthand</h3></div></div></div><p>Earlier in <a class="indexterm" id="id2444"/>ECMAScript 5, object literals were a comma-separated collection of <code class="literal">name:value</code> pairs. There was a likelihood of duplication while property values were being initialized.</p><p>Here is an example:</p><div><pre class="programlisting">functioncreateStudent(StudentID, name, class) {
  return {
    StudentID: StudentID,
    name: name,
    class: class,
  };
}</pre></div><p>In the preceding example, the <code class="literal">createStudent()</code> function creates a <code class="literal">student</code> object whose <code class="literal">name</code> and <code class="literal">class</code> properties are similar to the function parameters. This results in duplication of <code class="literal">name</code> and <code class="literal">class</code> properties, even though both behave differently.</p><p>To correct this, the initializer shorthand property was introduced in ECMAScript 6. This removed all the likelihood of duplication between property names and local variables.</p><p>For instance, <code class="literal">createStudent()</code> can be revised as follows:</p><div><pre class="programlisting">functioncreateStudent(StudentID, name, class) {
  return {
    StudentID,
    name,
    class,
  };
}</pre></div><p>In the event that property name will be the same as property estimation, you can simply incorporate property name without colon and value.</p><p>If the property of an object literal has no value, the JavaScript engine searches for a variable with a similar name in the surrounding. If the search procedure is successful, the value is assigned to the same party name in object literals.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec708"/>Method initializer shorthand</h3></div></div></div><p>With <a class="indexterm" id="id2445"/>the advent of ECMAScript 6, many things improved, making the work of a web developer simpler. The syntax of writing methods in object literals improved to a great extent. Earlier, in ECMAScript 5, we needed to specify a name and write the complete function definition then and there.</p><p>Here is an example:</p><div><pre class="programlisting">varcustomer = {
  name: "Samantha",
  logName: function() {
    console.log(this.name);
  }
};</pre></div><p>With <a class="indexterm" id="id2446"/>ECMAScript 6, the syntax became easier to code. Colon and function keywords have been removed. The same example can be rewritten as follows:</p><div><pre class="programlisting">varcustomer = {
  name: "Samantha",
  logName() {
    console.log(this.name);
  }
};
person.logName();varobject = {
  // __prototype__
  __prototype__: theProtoTypeObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return "x " + super.toString();
  },
  // Dynamic property names
  [ 'property_' + (() =&gt; 20)() ]: 20
};</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec490"/>Template strings</h2></div></div></div><p>Template strings <a class="indexterm" id="id2447"/>amplify ECMAScript with syntactic <a class="indexterm" id="id2448"/>sugar to build string. This component is like string introduction highlights in Perl, Python, and so on. You can likewise add a tag to permit redid string development, staying away from and counteracting infusion assaults or building complex information structures from string substance. They also enable us to create <strong>domain-specific </strong><a class="indexterm" id="id2449"/>
<strong>languages</strong> (<strong>DSLs</strong>) to deal with content in a safe way.</p><p>Instead of adding more extending functionality to JavaScript strings, template strings provide a total new approach for string interpolation.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec709"/>Basics</h3></div></div></div><a class="indexterm" id="id2450"/><p>The simplest format of a template string is as follows:</p><div><pre class="programlisting">literal${substitution_variable}literal</pre></div><p>This is the most basic form of template strings which performs substitutions.</p><p>Template strings are enclosed within backticks (<code class="literal">`</code>) instead of single or double quotes. Here is an example:</p><div><pre class="programlisting">letbasic_string = `Kung Fu Panda`;

console.log(basic_string);               // "Kung Fu Panda"
console.log(typeofbasic_string);        // "string"
console.log(basic_string.length);        // 13</pre></div><p>In this example, a <code class="literal">basic_string</code> variable contains a simple JavaScript string. The template string syntax is only used to create the string value, which is then assigned to <code class="literal">basic_string</code>.</p><p>If there is a need to use a backtick in string, then you can escape it using a backslash (<code class="literal">\</code>):</p><div><pre class="programlisting">letbasic_string = `\`Kung Fu\` Panda.`;      // `Kung Fu' Panda</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec710"/>Multiline strings</h3></div></div></div><p>In this type of <a class="indexterm" id="id2451"/>string, we can add multiple lines in a single line of code. To insert a new line in a string, we have to include <code class="literal">\n</code> within the string manually, as follows:</p><div><pre class="programlisting">letmultiline_string = "Kung Fu Panda, \n\
Releasing in 2016";

console.log(multiline_string);</pre></div><p>The output of this is:</p><div><pre class="programlisting">Kung Fu Panda
Releasing in 2016</pre></div><p>We need to be careful regarding the whitespaces, as whitespaces within backticks are considered to be part of the string. All whitespaces before the second line are considered to be part of the string.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec491"/>Destructuring assignment</h2></div></div></div><p>In JavaScript, <em>destructuring</em> means pattern matching. In ES6, we can do efficient pattern matching <a class="indexterm" id="id2452"/>in objects and arrays. Earlier, this was a long and complicated task. Here are some working examples written in a client console.</p><p>Fetching data from objects and arrays is very common in JavaScript. Object properties are usually stored in local variables for instant access. Let's take a look at the following code snippet:</p><div><pre class="programlisting">var settings = {
  replay: true,
  save: false
};

// later

varlocalReplay = options.replay,
localSave = options.save;</pre></div><p>ES6 made this easier <a class="indexterm" id="id2453"/>by introducing destructuring assignments, which goes through an object or an array and stores specified values in the local variables. It allows binding using pattern matching for objects and arrays.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec711"/>Array destructuring</h3></div></div></div><p>All variables <a class="indexterm" id="id2454"/>can be initialized and swapped at once instead of the conventional way of creating a temporary variable:</p><div><pre class="programlisting">var [ first, last ] = ["one", "hundred"] // initialize
console.log(first + " to " + last); // one to hundred

[first, last] = [last, first] // variable swapping
console.log(first + " to " + last); // hundred to one</pre></div><p>Multiple values from a function are returned with ease using array destructuring. We don't have to wrap around an object. To skip variables, you can leave the position of the array element blank:</p><div><pre class="programlisting">function dob() {
  return [29, "November", 1990, "Thursday"];
}
var [date, month, year, day] = dob();
console.log("My date of birth is on " + date + " " + month); // My date of birth is on 29 November</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec712"/>Object destructuring</h3></div></div></div><p>Due to <a class="indexterm" id="id2455"/>destructuring, variables can also be initialized from an object that is returned from a function even with deeply nested objects.</p><p>Destructuring enables variables to be initialized from an object that is returned by a function having deeply nested objects. Just like Array destructuring, we can skip the ones not needed. Here's <a class="indexterm" id="id2456"/>the working snippet:</p><div><pre class="programlisting">function dob() {
  return {
    date: 29,
    month: "November",
    year: 1990,
    time: {
      hour: 12, // nested
      minute: 35,
      meridian: "AM"
    }
  };
}

var { date: d, month: m, time : { hour: h, meridian: p } } = dob();
// h is the nested property while year and minute is skipped

console.log("I was born on " + d + " " + m + " at " + h + " " + p); // I was born on 29 November at 12 AM</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec492"/>Extended parameter handling</h2></div></div></div><p>Functions <a class="indexterm" id="id2457"/>are an important and fundamental part of any language. ES6 has introduced a number of incremental improvements in functions. This makes them less error prone and more powerful.</p><p>Functions allow any <a class="indexterm" id="id2458"/>number of parameters to be passed irrespective of the number of parameters in the function definition. There are three types of these parameters that could be passed to functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default</li><li class="listitem" style="list-style-type: disc">Rest</li><li class="listitem" style="list-style-type: disc">Spread</li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec713"/>Default parameter</h3></div></div></div><p>ES6 lets us set <a class="indexterm" id="id2459"/>default parameters. A parameter with a default value is considered optional. It binds trailing parameters to an array:</p><div><pre class="programlisting">function multiply(x, y) {
  y = typeofy !== 'undefined' ?  y : 1;

  returnx*y;
}

multiply(10);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec714"/>Rest parameter</h3></div></div></div><p>Rest parameters <a class="indexterm" id="id2460"/>replace the need for arguments and addresses common cases more directly. Rest parameters are indicated by three dots (<code class="literal">…</code>) preceding a parameter.</p><p>Here is an example showing the rest parameter:</p><div><pre class="programlisting">//Rest Parameter
function sum(…nums) {
  var result = 0;
  nums.forEach(function(number) {
    result += number;
  });
  return result;
}
console.log(sum(1)); // 1
console.log(sum(1, 2, 3)); // 6 </pre></div><p>The named parameter becomes an array containing the rest of the parameters. Adding more than one named argument may cause syntax error.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec715"/>Spread operator</h3></div></div></div><p>Spread operator is <a class="indexterm" id="id2461"/>very similar to the rest parameter, but it allows us to split the array to individual arguments, which are then passed to the function as separate arguments.</p><p>Here is an example showing the spread operator:</p><div><pre class="programlisting">//Spread Operator
functionsum2(a, b, c) {
  return a + b + c;
}
varargs = [1, 2];
console.log(sum(…args, …args, 3)); // 6</pre></div><p>Here is an example showing the usage of default, rest, and spread parameters:</p><div><pre class="programlisting">function sum() {
  return ;
}
console.log(sum(
(1, 2)
//Spread Operator

//Rest Parameter
//Default Parameter Values
//Default Parameter Values
functioninc(num, increment = 1) {
  returnnum + increment;
}
console.log(inc(2, 2)); // 4
console.log(inc(4)); // 5</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec493"/>Bindings</h2></div></div></div><p>The <code class="literal">let</code> <a class="indexterm" id="id2462"/>keyword is a new <code class="literal">var</code>. The declaration syntax for the <code class="literal">let</code> <a class="indexterm" id="id2463"/>keyword is the same as for <code class="literal">var</code>. You can basically replace <code class="literal">var</code> with <code class="literal">let</code> to declare a variable but keep its scope to the current code:</p><div><pre class="programlisting">functiongetCuisine(condition) {

  if (condition) {
    letcuisine = "Mediterranean";

    // other code

    returncuisine;
  }
  else {

    // cuisine does not exist here

    return null;
  }

  // cuisine does not exist here
}</pre></div><p>Variables defined using <code class="literal">const</code> are considered to be constants, so the value cannot be changed once <a class="indexterm" id="id2464"/>set. For this reason, every <code class="literal">const</code> variable has to be initialized:</p><div><pre class="programlisting">// Valid constant
const ITEMS = 10;

// Syntax error: missing initialization
const ITEM;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec494"/>Iterators and the for...of operator</h2></div></div></div><p>We use <a class="indexterm" id="id2465"/>iterators to allow customization of an object's iteration <a class="indexterm" id="id2466"/>method/behavior, such as CLRIE numerable or Java Iterable. Generalize the <code class="literal">for..in</code> operator to custom iterator-based iteration with <code class="literal">for..of</code>. Iterators are an important feature of ECMAScript 6. When used in combination with new array methods and new types of collections (for example, sets and maps), iterators <a class="indexterm" id="id2467"/>become even more important for the efficient processing of data.</p><p>Fibonacci numbers, <a class="indexterm" id="id2468"/>or the Fibonacci arrangement, are the numbers in the accompanying whole number succession:</p><div><pre class="programlisting">let fibonacci = {
  [Symbol.iterator]() {
    let x = 0, y = 1;
    return {
      next() {
        [x, y] = [y, x + y];
        return { done: false, value: y }
      }
    }
  }
}

for (vari of fibonacci) {
  // truncate the sequence at 3000
  if (i&gt; 3000)
  break;
  console.log(i);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec495"/>Generators</h2></div></div></div><p>Custom iterators are a useful<a class="indexterm" id="id2469"/> tool but it requires careful programming so that it can maintain its internal state explicitly. ES6 introduced generators which<a class="indexterm" id="id2470"/> provide a powerful alternative. Generator allows us to create an iteration algorithm by writing a single function. This single function is able to maintain its own state.</p><p>A <code class="literal">generator</code> is a function that returns an iterator. The <code class="literal">generator</code> functions are denoted by embedding an asterisk (<code class="literal">*</code>) after the function keyword. A normal function becomes a generator if it contains a yield expression and uses <code class="literal">function*</code> syntax.</p><div><div><h3 class="title"><a id="tip44"/>Tip</h3><p>It doesn't matter whether there is space between the <code class="literal">function</code> keyword and the asterisk.</p></div></div><p>The <code class="literal">yield</code> keyword is utilized within the generators function to indicate the qualities that the iterator must return when the <code class="literal">next()</code> method is called. So, in the event that you need to return unique values for each progressive call to <code class="literal">next()</code>:</p><p>We can convert the <a class="indexterm" id="id2471"/>previous iterator example to use a generator, as shown here:</p><div><pre class="programlisting">let fibonacci = {
  *[Symbol.iterator]() {
    let prex = 0, cury = 1
    for (;;) {
      [ prex, cury ] = [ cury, prex+curv ] = [
        yield cury
    }
  }
}

for (let ni of fibonacci) {
  if (ni&gt; 3000)
  break
  console.log(ni)
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec496"/>Better Unicode support</h2></div></div></div><p>ES6 supports <a class="indexterm" id="id2472"/>Unicode, including new Unicode literal form in strings, new <code class="literal">RegExp u</code> mode to handle code points, as well as new APIs to process strings at the 21-bit code points level. These updates enable us to create global apps in JavaScript. ECMAScript 6 enforces encoding of strings in UTF.</p><p>The supported Unicode examples are as follows:</p><div><pre class="programlisting">// same as ECMAScript 5
"▯".length == 2

// new RegExpbehaviour, opt-in 'u'
"▯".match(/./u)[0].length == 2

// new form
"\u{1D306}"=="▯"=="\uD834\uDF06"

// new String ops
"▯".codePointAt(0) == 0x20BB7

// for-of iterates code points
for(var c of "▯") {
  console.log(c);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec497"/>Modules</h2></div></div></div><p>ECMAScript 6 <a class="indexterm" id="id2473"/>enables us to export and import symbols to and from modules <a class="indexterm" id="id2474"/>without polluting the global namespace. It provides added support for modules for component definition. Runtime behavior is defined by a host-defined default loader. It is an implicitly asynchronous model; no code is executed until the necessary modules are available and processed:</p><div><pre class="programlisting">export function sum(x, y, {
  return x + y
}

console.log("4π = " + math.sum(math.pi, math.pi, math.pi, math.pi));

console.log("2π = " + sum(pi, pi));</pre></div><p>Some additional features include export default and export <code class="literal">*</code>, as shown in the following code snippet:</p><div><pre class="programlisting">exportvar e = 2.71828182846;

export default function(x) {
  returnMath.log(x);
}
console.log("2π = " + ln(e)*pi*2);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec498"/>Module loaders</h2></div></div></div><p>Module <a class="indexterm" id="id2475"/>loaders are used primarily to resolve module specifiers, loading modules, and so on. They are responsible for downloading the required modules and <a class="indexterm" id="id2476"/>binding them asynchronously. This brings to light the dependencies of a client script. The constructor is <code class="literal">Reflect.Loader</code>.</p><p>Module loaders support:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Compilation hooks</li><li class="listitem" style="list-style-type: disc">Nested virtualization</li><li class="listitem" style="list-style-type: disc">Dynamic loading</li><li class="listitem" style="list-style-type: disc">Global namespace isolation</li><li class="listitem" style="list-style-type: disc">State <a class="indexterm" id="id2477"/>isolation</li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec716"/>Loader methods</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">System.module(source, options?)</code>: This is used to assess the JavaScript code in source to a <a class="indexterm" id="id2478"/>module (which is delivered and returned non-concurrently by means of a guarantee)</li><li class="listitem" style="list-style-type: disc"><code class="literal">System.set(name, module)</code>: This is used for the registration of the module created by System.module()</li><li class="listitem" style="list-style-type: disc"><code class="literal">System.define(name, source, options?)</code>: This is used to assess the module code in source and registers the outcome</li></ul></div><p>We can configure the default module loader, and new loaders can be constructed to evaluate and load code in isolated or constrained contexts:</p><div><pre class="programlisting">System.import('libraries/math').then(function(mx) {
  console.log("π = " + (mx.pi));
});

// Create execution sandboxes – new Loaders
var loader = new Loader({
  global: fixup(window)
});
loader.eval("console.log('live to code!');");

// Directly manipulate module cache
System.get('jquery');
System.set('jquery', Module({$: $}));</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec499"/>Collections</h2></div></div></div><p>
<strong>Collections</strong> are <a class="indexterm" id="id2479"/>used to create unique values collections of any type in JavaScript. In a collection of values, you can also add and remove values. There is <a class="indexterm" id="id2480"/>no direct access to values in collection, and these are of array type.</p><p>In ECMAscript 6, collections are a new efficient way to store data. JavaScript arrays are similar to other programming language arrays with index. By use of these arrays, you can pull double and triple data and also stack data. There are many new types of collections in JavaScript. Here are some examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sets</li><li class="listitem" style="list-style-type: disc">Maps</li><li class="listitem" style="list-style-type: disc">WeakMap</li><li class="listitem" style="list-style-type: disc">WeakSet</li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec717"/>Sets</h3></div></div></div><p>A <code class="literal">set</code> has a unique <a class="indexterm" id="id2481"/>collection of values. The unique values of a set are also of object reference types. Values in sets cannot be duplicated. Before you access values from a <code class="literal">set</code>, you need to check whether the values are present or not.</p><p>We can add values in a <code class="literal">set</code> and also check the size of values in a set. Here is an example:</p><div><pre class="programlisting">Var students=new set();
Students.add(10);
Students.add("Ali");</pre></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec718"/>Maps</h3></div></div></div><p>A <code class="literal">map</code> object is a <a class="indexterm" id="id2482"/>
<code class="literal">key/value</code> map. Any value in <code class="literal">map</code> may be used as a key or a value. Elements can iterate in a <code class="literal">map</code> in an insertion order, and it returns an array of a value or a key. There are two properties of <code class="literal">map</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Map.length</code>: Returns the number of elements in a <code class="literal">map</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Map.prototype</code>: The <code class="literal">Map.prototype</code> property represents the prototype for the <code class="literal">map</code> constructor</li></ul></div><p>Here are some of the methods of the <code class="literal">map</code> object.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec533"/>Map.prototype.clear()</h4></div></div></div><p>The <a class="indexterm" id="id2483"/>
<code class="literal">clear()</code> method removes all elements from a <code class="literal">map</code> object.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec12"/>Returns</h5></div></div></div><p>It returns nothing.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec13"/>Parameter</h5></div></div></div><p>There is no input parameter.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec14"/>Description</h5></div></div></div><p>After using this function, everything that we have initialized on map will be erased. The function has no parameter and returns nothing as it wipes out everything.</p><p>Here is an example of this method:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("pine","apple");
myMap.set(1,"apple");

myMap.size;// 2
myMap.has("cone");// will return false

myMap.has("pine")// will return true</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec534"/>Map.prototype.delete()</h4></div></div></div><p>The <code class="literal">delete()</code> method <a class="indexterm" id="id2484"/>removes the specified element from a <code class="literal">Map</code> object.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec15"/>Returns</h5></div></div></div><p>It returns <code class="literal">true</code> if a component in the map object existed and has been evacuated. It returns false if the component does not exist.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec16"/>Parameter</h5></div></div></div><p>A key is required. The key here is basically the element to be removed.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec17"/>Description</h5></div></div></div><p>This is different from <code class="literal">map.prototype.clear()</code> as it clearly removes a specific element instead of deleting every element on the map. We pass a key (the element to be deleted), and the function returns <code class="literal">true</code> or <code class="literal">false</code>, depending on the key.</p><p>Here is an example of this method:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("pine","apple");

myMap.delete("apple");// Returns true. Successfully removed.
myMap.has("apple");// Returns false. The "apple" element is no longer present.</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec535"/>Map.prototype.entries()</h4></div></div></div><p>This function is used to <a class="indexterm" id="id2485"/>tell us about the key and value of elements on map.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec18"/>Returns</h5></div></div></div><p>It returns a new <code class="literal">iterator</code> object that contains a key and a value for every element on the map.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec19"/>Parameter</h5></div></div></div><p>There are no input parameters.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec20"/>Description</h5></div></div></div><p>This function is utilized for letting us know about the key and value of components on map.</p><p>Here is an <a class="indexterm" id="id2486"/>example of this method:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("0","pine");
myMap.set(1,"apple");
myMap.set({},"cone");

varmapIter=myMap.entries();

console.log(mapIter.next().value);// ["0", "pine"]
console.log(mapIter.next().value);// [1, "apple"]
console.log(mapIter.next().value);// [Object, "cone"]</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec536"/>Map.prototype.forEach()</h4></div></div></div><p>The <code class="literal">forEach</code> <a class="indexterm" id="id2487"/>method executes the given callback once to every key/value pair in the map object.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec21"/>Returns</h5></div></div></div><p>It returns nothing.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec22"/>Parameter</h5></div></div></div><p>There are three parameters: the element <code class="literal">value</code>, element <code class="literal">key</code>, and the <code class="literal">map</code> object being traversed.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec23"/>Description</h5></div></div></div><p>The <code class="literal">forEach</code> strategy executes the given callback once to every key of the guide that really exists. It is not conjured for keys that have been erased. Nonetheless, it is executed for values that are available; however, they have the value defined.</p><p>Here is an example of this method:</p><div><pre class="programlisting">functionlogMapElements(value, key, map) {
  console.log("m["+ key +"] = "+ value);
}
Map([["foo",3],["apple",{}],["cone", undefined]]).forEach(logMapElements);
// logs:
// "m[pine] = 3"
// "m[apple] = [object Object]"
// "m[cone] = undefined"</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec537"/>Map.prototype.get()</h4></div></div></div><p>A specific <a class="indexterm" id="id2488"/>element from the map is returned using the <code class="literal">get()</code> method.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec24"/>Returns</h5></div></div></div><p>It returns the key that is used as a parameter (only if it is found in map); or else, it returns an error message.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec25"/>Parameter</h5></div></div></div><p>It requires a key that is to be returned from the map.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec26"/>Description</h5></div></div></div><p>We input a key that we want to find in the map, and the function returns it. It is used when we want to get the value of an element.</p><p>Here is an <a class="indexterm" id="id2489"/>example of this method:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("apple","pine");

myMap.get("apple");// Returns "apple".
myMap.get("cone");// Returns undefined.</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec538"/>Map.prototype.has()</h4></div></div></div><p>The function <a class="indexterm" id="id2490"/>returns <code class="literal">true</code> (Boolean value) if the element exists and <code class="literal">false</code> if it does not.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec27"/>Returns</h5></div></div></div><p>It returns <code class="literal">true</code> if a component with the specified key exists in the <code class="literal">map</code> object. If not found, it returns <code class="literal">false</code>.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec28"/>Parameter</h5></div></div></div><p>A key is required.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec29"/>Description</h5></div></div></div><p>We pass a key in the function to check whether a certain element exists in the map or not. If the element exists, <code class="literal">true</code> is returned; otherwise, <code class="literal">false</code> is returned.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("apple","pine");

myMap.has("apple");// returns true
myMap.has("cone");// returns false</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec539"/>Map.prototype.keys()</h4></div></div></div><p>It returns keys <a class="indexterm" id="id2491"/>for every element in the map.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec30"/>Returns</h5></div></div></div><p>It returns a new object that contains the keys of all elements on the map.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec31"/>Parameter</h5></div></div></div><p>There is no input parameter.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec32"/>Description</h5></div></div></div><p>The <code class="literal">keys()</code> strategy gives back another <code class="literal">iterator</code> object that contains the keys for every component in the <code class="literal">map</code> object in the insertion order.</p><p>An example <a class="indexterm" id="id2492"/>of this method is shown here:</p><div><pre class="programlisting">varmyMap=newMap();
myMap.set("0","pine");
myMap.set(1,"apple");
myMap.set({},"cone");

varmapIter=myMap.keys();

console.log(mapIter.next().value);// "0"
console.log(mapIter.next().value);// 1
console.log(mapIter.next().value);// Object</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec540"/>Map.prototype.set()</h4></div></div></div><p>This is the <a class="indexterm" id="id2493"/>procedure to add a new element on map.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec33"/>Returns</h5></div></div></div><p>It returns the <code class="literal">map</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec34"/>Parameter</h5></div></div></div><p>This is the key of the element to be added on map.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec35"/>Description</h5></div></div></div><p>The <code class="literal">set()</code> strategy includes another component with a predetermined key and value to a <code class="literal">map</code> object.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">varmyMap=newMap();

// Add new elements to the map
myMap.set("apple","pine");
myMap.set(1,"pineapple");

// Update an element in the map
myMap.set("apple","custard");</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec541"/>Map.prototype.values()</h4></div></div></div><p>This is the method to get a new object containing values of each element.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec36"/>Returns</h5></div></div></div><p>It returns an <a class="indexterm" id="id2494"/>object that has values of all components on map.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec37"/>Parameter</h5></div></div></div><p>There is no input parameter.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec38"/>Description</h5></div></div></div><p>The <code class="literal">values()</code> technique gives back another <code class="literal">iterator</code> object that contains the values for every component in the <code class="literal">map</code> object in the insertion manner.</p><p>Here is an example of this method:</p><div><pre class="programlisting">varmyMap = new Map();

varkeyObj = {},
keyFunc = function () {},
keyString = "This is a sample string";

// setting the values
myMap.set(keyString, "value associated to 'This is a sample string'");
myMap.set(keyObj, "value associated to a keyObj");
myMap.set(keyFunc, "value associated to a keyFunc");

myMap.size; // 3

// getting the values
myMap.get(keyString);    // "value associated to 'This is a sample string'"
myMap.get(keyObj);       // "value associated to a keyObj"
myMap.get(keyFunc);      // "value associated to a keyFunc"

myMap.get("a string");   // "value associated to 'This is a sample string'"
// because keyString === 'a string'
myMap.get({});           // undefined, because keyObj !== {}
myMap.get(function() {}) // undefined, because keyFunc !== function () {}</pre></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec719"/>WeakMap</h3></div></div></div><p>It is the same as <a class="indexterm" id="id2495"/>map, but there is some difference in it. It only accepts objects <a class="indexterm" id="id2496"/>as keys. Primitive data types are not allowed in <code class="literal">WeakMap</code>. There is no garbage collection in a <code class="literal">WeakMap</code> because it doesn't reference to an object acting like a key. As a result of these differences, there is no method to access keys in <code class="literal">WeakMap</code>.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Keys in <code class="literal">WeakMap</code> are not enumerable, which means that there is no method to give you a list of keys. There is size property available in <code class="literal">WeakMap</code>.</p></div></div><p>Here is an <a class="indexterm" id="id2497"/>example:</p><div><pre class="programlisting">varmyWeakMap1 = new WeakMap(),
myWeakMap2 = new WeakMap(),
varo1 = {},
o2 = function(){},
o3 = window;

myWeakMap1.set(o1, 37);
myWeakMap1.set(o2, "pineapple");
myWeakMap2.set(o1, o2); 
myWeakMap2.set(o3, undefined);
myWeakMap2.set(myWeakMap1, myWeakMap2);

myWeakMap1.get(o2); // "pineapple"
myWeakMap2.get(o2); // undefined, because there is no value for o2 on myWeakMap2
myWeakMap2.get(o3); // undefined, because that is the set value

myWeakMap1.has(o2); // will return true
myWeakMap2.has(o2); // will return false
myWeakMap2.has(o3); // will return true

myWeakMap1.has(o1); // will return true
myWeakMap1.delete(o1);
myWeakMap1.has(o1); // will return false</pre></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec542"/>WeakMap.prototype.clear()</h4></div></div></div><p>This is used to <a class="indexterm" id="id2498"/>remove all elements from the <code class="literal">WeakMap</code>. This is obsolete now, but is, however, still used in a few browsers.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec39"/>Returns</h5></div></div></div><p>It returns the key of the element to be removed from the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec40"/>Parameters</h5></div></div></div><p>This is t key of the element to be removed from the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec41"/>Description</h5></div></div></div><p>Here is an example:</p><div><pre class="programlisting">varwm = new WeakMap();
varobject = {};

wm.set(object, "pine");
wm.set(window, "apple");

wm.has(object); // will return true
wm.has(window); // will return true

wm.clear();

wm.has(object)  // will return false
wm.has(window)  // will return false</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec543"/>WeakMap.prototype.delete()</h4></div></div></div><p>This method is <a class="indexterm" id="id2499"/>used to remove a specific object from <code class="literal">WeakMap</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec42"/>Returns</h5></div></div></div><p>It returns <code class="literal">true</code> if an element in the <code class="literal">WeakMap</code> object has been removed successfully.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec43"/>Parameters</h5></div></div></div><p>This is the key of the element to remove from the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec44"/>Description</h5></div></div></div><p>The <code class="literal">delete()</code> method removes the specified element from a <code class="literal">WeakMap</code> object.</p><p>Here is an example:</p><div><pre class="programlisting">varwm = new WeakMap();
wm.set(window, "pineapple");

wm.delete(window); // Returns true. Successfully removed.

wm.has(window);    // Returns false. The window object is no longer in the WeakMap.</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec544"/>WeakMap.prototype.get()</h4></div></div></div><p>This method is <a class="indexterm" id="id2500"/>used to retrieve a specific object from <code class="literal">WeakMap</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec45"/>Returns</h5></div></div></div><p>It returns the element associated with the specified key or is undefined if the key can't be found in the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec46"/>Parameters </h5></div></div></div><p>This is the key of the element to return from the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec47"/>Description</h5></div></div></div><p>The key of the <a class="indexterm" id="id2501"/>element to return from the <code class="literal">WeakMap</code> object.</p><p>Here is an example:</p><div><pre class="programlisting">varwm = new WeakMap();
wm.set(window, "pine");

wm.get(window); // Returns "pine".
wm.get("apple");  // Returns undefined.</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec545"/>WeakMap.prototype.has()</h4></div></div></div><p>This method <a class="indexterm" id="id2502"/>is used to check whether the specified object exists in <code class="literal">WeakMap</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec48"/>Returns</h5></div></div></div><p>It returns <code class="literal">true</code> if an element with the specified key exists in the <code class="literal">WeakMap</code> object; otherwise it returns <code class="literal">false</code>.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec49"/>Parameters</h5></div></div></div><p>It is the key of the element to test for presence in the <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec50"/>Description</h5></div></div></div><p>The <code class="literal">has()</code> method returns a Boolean indicating whether an element with the specified key exists in the <code class="literal">WeakMap</code> object or not.</p><p>Here is an example:</p><div><pre class="programlisting">varwm = new WeakMap();
wm.set(window, "pine");

wm.has(window); // returns true
wm.has("apple");  // returns false</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec546"/>WeakMap.prototype.set()</h4></div></div></div><p>This method is <a class="indexterm" id="id2503"/>used to add an object to a specific location.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec51"/>Returns</h5></div></div></div><p>The <code class="literal">WeakMap</code> object.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec52"/>Parameters</h5></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Key</code>: The key of the element to add to the <code class="literal">WeakMap</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">Value</code>: The value of the element to add to the <code class="literal">WeakMap</code> object</li></ul></div></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec53"/>Description</h5></div></div></div><p>The <code class="literal">set()</code> method <a class="indexterm" id="id2504"/>adds a new element with a specified key and value to a <code class="literal">WeakMap</code> object.</p><p>Here is an example:</p><div><pre class="programlisting">varwm = new WeakMap();
varobject = {};

// Add new elements to the WeakMap
wm.set(object, "pine").set(window, "apple"); // chainable

// Update an element in the WeakMap
wm.set(object, "cone");</pre></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec720"/>Weakset</h3></div></div></div><p>This is a collection of <a class="indexterm" id="id2505"/>objects that don't stop its elements from being garbage <a class="indexterm" id="id2506"/>collected. There is no looping, iteration, and learning in <code class="literal">WeakSet</code>. It has three methods.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec547"/>WeakSet.prototype.add(someValue)</h4></div></div></div><p>This method <a class="indexterm" id="id2507"/>appends a new object at the end of the <code class="literal">WeakSet</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec54"/>Returns</h5></div></div></div><p>The <code class="literal">WeakSet.prototype.add(someValue)</code> method returns Nothing</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec55"/>Parameter</h5></div></div></div><p>The object to add to the <code class="literal">WeakSet</code> collection.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec56"/>Description</h5></div></div></div><p>The <code class="literal">add()</code> method appends a new object to the end of a <code class="literal">WeakSet</code> object.</p><p>An example of this method is as follows:</p><div><pre class="programlisting">varmyWeakSet=newWeakSet();

myWeakSet.add(window);// add the window object to the WeakSet created above

myWeakSet.has(window);// will return true</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec548"/>WeakSet.prototype.delete(someValue)</h4></div></div></div><p>This method removes the specified object from <code class="literal">WeakSet</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec57"/>Returns</h5></div></div></div><p>Returns <code class="literal">true</code> if the <a class="indexterm" id="id2508"/>value is found in <code class="literal">WeakSet</code> and is deleted. Returns <code class="literal">false</code> if the value is not found.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec58"/>Parameter</h5></div></div></div><p>The value to be deleted is sent as a parameter.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec59"/>Description</h5></div></div></div><p>The <code class="literal">delete()</code> strategy expels the predefined element from a <code class="literal">WeakSet</code> object. It is used while we need to delete some element from <code class="literal">WeakSet</code>.</p><p>An example of this method is as follows:</p><div><pre class="programlisting">varmyWeakSet=newWeakSet();
varmyObject={};

myWeakSet.add(window);

myWeakSet.delete(myObject);// Will return false
myWeakSet.delete(window);// Will return true.

myWeakSet.has(window);// Will return false.</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec549"/>WeakSet.prototype.has(someValue)</h4></div></div></div><p>This <a class="indexterm" id="id2509"/>method will return <code class="literal">true</code> if the object exists in <code class="literal">WeakSet</code>; otherwise, <code class="literal">false</code> is returned.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec60"/>Returns</h5></div></div></div><p>It returns <code class="literal">true</code> if a component with the predefined value exists in the <code class="literal">WeakSet</code> object; otherwise, it returns <code class="literal">false</code>.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec61"/>Parameter</h5></div></div></div><p>Requires a value that is to be searched.</p></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec62"/>Description</h5></div></div></div><p>The <code class="literal">has()</code> technique gives back a Boolean demonstrating whether an item exists in <code class="literal">WeakSet</code> or not.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">varws=newWeakSet();
varobject={};
ws.add(window);

mySet.has(window);  // will return true
mySet.has(object);  // will return false</pre></div><p>It has only arbitrary values. References of objects are held in a weak manner in a <code class="literal">WeakSet</code> object. They can also be garbage collectors. In <code class="literal">WeakSet</code>, there is no list of current objects because of the garbage collector. These objects are not enumerable.</p><p>Here is <a class="indexterm" id="id2510"/>an example:</p><div><pre class="programlisting">// Sets
varmySet = new Set();
mySet.add("apple").add("candy");
mySet.size === 2;
mySet.has("hello") === false;

// Maps
varmyMap = new Map();
myMap.set("boy", 27);
myMap.set(f, 25);
myMap.get(f) == 25;

// Weak Maps
varmyWeakMap = new WeakMap();
myWeakMap.set(s, { extra: 99 });
myWeakMap.size === undefined

// Weak Sets
varmyWeakSet = new WeakSet();
myWeakSet.add({ data: 99 });</pre></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec500"/>Proxies</h2></div></div></div><p>Proxies enable <a class="indexterm" id="id2511"/>object creation with a wide range of behaviors available to <a class="indexterm" id="id2512"/>host objects. They can be used for object<a class="indexterm" id="id2513"/> virtualization, interception, logging/profiling, and so on. Proxies provide developers with an unprecedented<a class="indexterm" id="id2514"/> control over objects and unlimited possibilities to define new interaction patterns.</p><p>Here is an example:</p><div><pre class="programlisting">vartargetObject = {};
varhandlerObject = {
  get: function (receiver, book) {
    return `Title, ${name}!`;
  }
};

varproxyObject = new Proxy(target, handler);
proxyObject.world === 'Lahore!';

// Proxying a function object
vartargetObject = function () { return 'Target, I am'; };
varhandlerObject = {
  apply: function (receiver, ...args) {
    return 'Le proxy';
  }
};

var p = new Proxy(target, handler);
p() === 'Le proxy';</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec501"/>Symbols</h2></div></div></div><p>A symbol is a unique type which can be used as an identifier for object properties. The symbol object is an implicit object wrapper for the symbol primitive data type.</p><p>Here is how you can create a new primitive symbol:</p><div><pre class="programlisting">var symb = Symbol(); </pre></div><p>OR</p><div><pre class="programlisting">var symb = Symbol('abc');</pre></div><p>The preceding code creates two new symbols. <code class="literal">Symbol('abc')</code> does not force converts <code class="literal">abc</code> into an object but creates a new separate object.</p><div><pre class="programlisting">Symbol('abc') === Symbol('abc'); //false</pre></div><p>Using <code class="literal">Symbol()</code> with new keyword will throw a type error.</p><div><pre class="programlisting">var symb = new Symbol(); // TypeError</pre></div><p>This prevents creation of an explicit Symbol wrapper object instead of a new symbol value. Creating an explicit wrapper object around primitive data types were only supported until ES5. However, existing primitive wrapper objects like new Boolean, new <code class="literal">String</code> and new <code class="literal">Number</code> can still be created for legacy reasons.</p><p>And if it is necessary to create Symbol wrapper object, you can use the <code class="literal">Object()</code> function:</p><div><pre class="programlisting">var symb = Symbol("abc");
typeof symb;     // "symbol" 
var symbObj = Object(symb);
typeof symbObj;  // "object"</pre></div><p>The <code class="literal">Object.getOwnPropertySymbols()</code> method returns an array of symbols and lets you find symbol properties on a given object.</p><p>Here is an example:</p><div><pre class="programlisting">varSomeClass = (function() {

  var key = Symbol("key");

  functionSomeClass(privateData) {
    this[key] = privateData;
  }

  SomeClass.prototype = {
    doStuff: function() {
      ... this[key] ...
    }
  };

  returnSomeClass;
})();

var c = new SomeClass("bye")
c["key"] === undefined</pre></div><div><div><h3 class="title"><a id="note57"/>Note</h3><p>The ECMAScript 6 standard uses a special notation to indicate symbols, prefixing the identifier with <code class="literal">@@</code>, such as <code class="literal">@@create</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec502"/>Subclassable built-ins</h2></div></div></div><p>In ECMAScript <a class="indexterm" id="id2515"/>6, built-ins such as Date, Array, and <a class="indexterm" id="id2516"/>DOM elements can be subclassed. Object construction for a function named <code class="literal">Ctor</code> now uses two phases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call <code class="literal">Ctor[@@create]</code> to allocate the object and install any special behavior</li><li class="listitem" style="list-style-type: disc">Invoke constructor on new instance to initialize it</li></ul></div><p>The known <code class="literal">@@create</code> symbol is available via <code class="literal">Symbol.create</code>. Built-ins now expose their <code class="literal">@@create</code> <a class="indexterm" id="id2517"/>syntax explicitly.</p><p>Here is an example:</p><div><pre class="programlisting">// Pseudo-code of Array
classSomeArray {
  constructor(...args) { /* ... */ }
  static [Symbol.create]() {

  }
}

// User code of Array subclass
classSomeArray extends Array {
  constructor(...args) { super(...args); }
}

// Two-phase 'new':
// 1) Call @@create to allocate object
// 2) Invoke constructor on new instance
vararr = new SomeArray();
arr[1] = 123;
arr.length == 1</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec503"/>Promises</h2></div></div></div><p>ECMAScript <a class="indexterm" id="id2518"/>6 introduced promises. It is a library used for asynchronous <a class="indexterm" id="id2519"/>programming. It is a first-class representation of a value that may be made available in the future. Many existing JavaScript libraries already use promises.</p><p>Some of the methods for promises in ES6 are mentioned here.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec721"/>Promise.All()</h3></div></div></div><p>This method <a class="indexterm" id="id2520"/>returns a promise that is resolved once all the promises in the <a class="indexterm" id="id2521"/>iterable argument have been resolved. In the case of a rejection, it returns with the reason of the first-passed promise that was rejected.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec550"/>Returns</h4></div></div></div><p>The <code class="literal">Promise.All()</code> method returns nothing.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec551"/>Parameter</h4></div></div></div><p>An <code class="literal">iterable</code> object, such as an array.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec552"/>Description</h4></div></div></div><p>Promises returns result as an array of values. If any value in the array is not a promise, then it is converted using Promise.resolve. If any of the passed in promises rejects, then all promise are rejected and the reason of rejection of a promise is returned. It discards all other promise whether they have been resolved or not. If an empty array is passed, then this method resolves immediately.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">varprom1 = 6000;
varprom2 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, "Here");
}); 

Promise.all([prom1, prom2]).then(function(values) {
  console.log(values); // [6000, "Here"]
});</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec722"/>Promise.prototype.catch()</h3></div></div></div><p>This <a class="indexterm" id="id2522"/>method is used only in cases where objects are rejected. It works the same as <code class="literal">promise.prototype.then()</code>.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec553"/>Returns</h4></div></div></div><p>The <code class="literal">promise.prototype.catch()</code> method returns nothing.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec554"/>Parameter</h4></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>One rejected</strong>: A function called when the <code class="literal">promise</code> is rejected. This function has one argument, the rejection reason.</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec555"/>Description</h4></div></div></div><p>The <code class="literal">catch()</code> technique gives back a <code class="literal">promise</code> and manages rejected cases. It behave similar as calling <code class="literal">Promise.prototype.then(undefined, onRejected)</code>.</p><p>An example of this method is as follows:</p><div><pre class="programlisting">varprom1= new Promise(function(resolve, reject) {
  resolve('This was Successful!!');
});

prom1.then(function(value) {
  console.log(value); // "This was Successful!!"
  throw 'oh, no!';
}).catch(function(e) {
  console.log(e); // "Error found"
}).then(function() {
  console.log('Catch Done!');
}, function () {
  console.log('Not fired due to the catch');
});</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec723"/>Promise.resolve(value)</h3></div></div></div><p>This method <a class="indexterm" id="id2523"/>returns a <code class="literal">promise</code> object that is resolved by the specified value. If the value is associated to a then method, the returned promise will move to the then method, adopting its final state. Otherwise, the returned promise will be fulfilled with the specified value.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec556"/>Returns</h4></div></div></div><p>The <code class="literal">promise</code> object that is resolved with the given value.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec557"/>Parameter</h4></div></div></div><p>Let's take a look at the following parameters and their use:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onFulfilled</code>: A <code class="literal">function</code> called when the <code class="literal">Promise</code> is fulfilled</li><li class="listitem" style="list-style-type: disc"><code class="literal">onRejected</code>: A <code class="literal">function</code> called when the <code class="literal">promise</code> is rejected</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec558"/>Description</h4></div></div></div><p>The <code class="literal">Promise.resolve(value)</code> system gives back a <code class="literal">Promise</code> question that is determined with the given quality. On the off chance that the quality is a then able (that is, has a then technique), the returned promise will <em>follow</em> that then able, adopting its possible state.</p><p>The <code class="literal">then()</code> technique gives back a <code class="literal">Promise</code>. It takes two contentions: callback capacities for the achievement and disappointment instances of the <code class="literal">Promise</code>.</p><div><div><div><div><h5 class="title"><a id="ch11lvl5sec63"/>Using the then method</h5></div></div></div><p>An example of this method is as follows:</p><div><pre class="programlisting">varprom1=newPromise(function(resolve, reject) {
  resolve("This was a Success!");
  // or
  // reject ("Error Found Try Again!");
});

prom1.then(function(value) {
  console.log(value);//This was a Success!
},function(reason){
  console.log(reason);// Error Found Try Again!
});</pre></div></div><div><div><div><div><h5 class="title"><a id="ch11lvl5sec64"/>Chaining</h5></div></div></div><p>As the <code class="literal">then()</code> method returns a <code class="literal">Promise</code>, you can easily chain <code class="literal">then</code> calls:</p><div><pre class="programlisting">varp2=newPromise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value);// 1
  return value +1;
}).then(function(value) {
  console.log(value);// 2
});

p2.then(function(value) {
  console.log(value);// 1
});</pre></div><p>You can also use chaining to implement one function with a Promise-based API on top of another such function:</p><div><pre class="programlisting">functionfetch_current_data() {
  returnfetch("current-data.json").then((response)=&gt; {
    if(response.headers.get("content-type")!="application/json") {
      thrownewTypeError();
    }
    var j =response.json();
    // maybe do something with j
    return j;// fulfillment value given to user of
    // fetch_current_data().then()
  });
}</pre></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec724"/>Promise.reject(value)</h3></div></div></div><p>This <a class="indexterm" id="id2524"/>function returns a promise object that is rejected because of the passed value/reason.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec559"/>Returns</h4></div></div></div><p>The <code class="literal">Promise.reject()</code> method returns a simple output telling the reason for rejection.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec560"/>Parameter</h4></div></div></div><p>Reason why this promise is rejected.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec561"/>Description</h4></div></div></div><p>The static <code class="literal">Promise.reject()</code> function capacity gives back a <code class="literal">Promise</code> that is rejected. For troubleshooting purposes and specific mistake finding, it is helpful to make the reason an instance of error.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">Promise.reject("Testing Promise reject").then(function(reason) {
  // not called
},function(reason) {
  console.log(reason);// "Testing Promise reject"
});

Promise.reject(newError("fail")).then(function(error) {
  // not called
},function(error) {
  console.log(error);// Stacktrace
});</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec725"/>Promise.race(value)</h3></div></div></div><p>This <a class="indexterm" id="id2525"/>function returns a promise that is resolved or rejected the same way as the promises passed in iterable, with the value or reason from that promise.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec562"/>Returns</h4></div></div></div><p>The <code class="literal">Promise.race()</code> function returns a promise.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec563"/>Parameter</h4></div></div></div><p>An <code class="literal">iterable</code> object, such as an array.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec564"/>Description</h4></div></div></div><p>The <code class="literal">race</code> function gives back a <code class="literal">Promise</code> that is settled the same route as the initially passed <code class="literal">Promise</code> to settle. It determines or rejects, whichever happens first.</p><p>An example of this method is as follows:</p><div><pre class="programlisting">varmyPromise1=newPromise(function(resolve, reject) {
  setTimeout(resolve,800,"first");
});
varmyPromise2=newPromise(function(resolve, reject) {
  setTimeout(resolve,300,"second");
});

Promise.race([myPromise1,myPromise2]).then(function(value) {
  console.log(value);// "second"
  // Both resolve, but myPromise2 is faster
});</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec504"/>Core math library APIs</h2></div></div></div><p>ECMAScript 6 has made several new extensions to the prebuilt libraries, including core <code class="literal">Math</code> libraries, <code class="literal">arrays</code>, <code class="literal">string</code> <code class="literal">helpers</code>, and <code class="literal">Object.assign</code> for copying. These new methods help in <a class="indexterm" id="id2526"/>speeding up the execution process, hence resulting in enhancing the performance of applications that may perform <a class="indexterm" id="id2527"/>calculations and string manipulation. It also improves the speed of applications that must perform many calculations and string manipulations.</p><p>Numerous new library increases, including core Math libraries, array conversion helpers, string helpers, and <code class="literal">Object.assign</code> for copying. An example of using the Core Math Library APIs is as follows:</p><div><pre class="programlisting">Number.EPSILON
Number.isInteger(Infinity) // will return false
Number.isNaN("NaN") // will return false

Math.acosh(3) // 1.762747174039086
Math.hypot(3, 4) // 5
Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2

"Neptune".includes("cd") // This will return false
"Mars".repeat(4) // This will be "MarsMarsMarsMars"

Array.from(document.querySelectorAll('*')) // Returns a real Array
Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior
[0, 0, 0].fill(2, 1) // [0,2,2]
[24, 14, 23, 57, 89, 75, 33].find(x =&gt; x == 33) // 33
[24, 14, 23, 57, 89, 75, 33].findIndex(x =&gt; x == 14) // 1
[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2]
["x", "y", "z"].entries() // iterator [0, "x"], [1,"y"], [2,"z"]
["x", "y", "z"].keys() // iterator 0, 1, 2</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec505"/>Binary and octal literals</h2></div></div></div><p>ECMAScript 6 introduced binary and octal literal notations, for binary (b) and octal (o). Both these notations are a <a class="indexterm" id="id2528"/>little similar to hexadecimal literal <a class="indexterm" id="id2529"/>notation for prepending 0x or 0X to a value.</p><p>The new octal literal format begins with <code class="literal">0o</code> or <code class="literal">0O</code>, while the new binary literal format begins with <code class="literal">0b</code> or <code class="literal">0B</code>. Each literal type must be followed by one or more digits; 0-7 for octal and 0-1 for binary. Here's an example:</p><div><pre class="programlisting">// ECMAScript 6
varvalue11 = 0o65;      // 53 in decimal
varvalue22 = 0b100;     // 4 in decimal

0b111110111 === 503 // will return true
0o767 === 503 // will return true</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec506"/>Reflect API</h2></div></div></div><p>The <code class="literal">reflect</code> <a class="indexterm" id="id2530"/>object is a single object that contains functions related to the reflection API. As the name suggests, it is merely a reflection of the objects so that one can observe them closely, regardless of who the object was created by. The <code class="literal">reflect</code> object is not a <code class="literal">function</code> object. It does not have a <code class="literal">constructor</code> method. It cannot be invoked as a function, because it does not have a <code class="literal">call</code> method.</p><p>Reflect API is known to be the inverse of Proxy API.</p><p>Here is a list of methods a <code class="literal">reflect</code> object has.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec726"/>Reflect.get(target, prop, [receiver])</h3></div></div></div><p>This <a class="indexterm" id="id2531"/>method allows you to get the property of an object. This method is similar to property accessors syntax (<code class="literal">object[propertyKey]</code>).</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec565"/>Returns</h4></div></div></div><p>The <code class="literal">reflect</code> object returns the value of property.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec566"/>Parameter</h4></div></div></div><p>The parameters are target objects on which to get property, the name of property, and the value.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec567"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.get()</code> method works like getting a property from an object (<code class="literal">target[propertyKey]</code>) as a function.</p><p>An <a class="indexterm" id="id2532"/>example of the get method is as follows:</p><div><pre class="programlisting">// Object
varobject={a:4,b:5};
Reflect.get(object,"b");// 5

// Array
Reflect.get(["first","second"],1);// "second", since array starts with 0 index

// Proxy with a get handler
var x ={p:9};
varobject=newProxy(x, {
  get(a,b,c){returnb +"meow";}
});
Reflect.get(object,"woof");// "woofbar"</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec727"/>Reflect.set(target, prop, value, [receiver])</h3></div></div></div><p>This <a class="indexterm" id="id2533"/>method allows you to set a property of an object. This method is also similar to property accessor syntax.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec568"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.set(target, prop, value, [receiver]</code> returns a Boolean value indicating whether property was successful or not.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec569"/>Parameter</h4></div></div></div><p>Parameters are target objects, name of the property, the value to set, and the receiver.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec570"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.set()</code> strategy works like setting a property on an item.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">// Object
varobject={};
Reflect.set(object,"property","value");// will return true
object.property;// "value"

// Array
vararr=["cow","cow","cow"];
Reflect.set(arr,1,"goat");// will return true
arr[1];// "goat"

// It can truncate an array.
Reflect.set(arr,"length",1);// will return true
arr;// ["goat"];

// With just one argument, propertyKey and value are "undefined".
varobject={};
Reflect.set(object);// will return true
Reflect.getOwnPropertyDescriptor(object,"undefined");
// { value: undefined, writable: true, enumerable: true, configurable: true }</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec728"/>Reflect.has(target, prop)</h3></div></div></div><p>This <a class="indexterm" id="id2534"/>method allows you to check whether an object holds a specific property. This method is similar to the in operator.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec571"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.has(target, prop)</code> returns a Boolean value indicating whether the target has a property or not.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec572"/>Parameter</h4></div></div></div><p>The target object and the property key (name of property to check) is passed.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec573"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.has()</code> technique works like the in operator as a function.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">Reflect.has({a:0},"a");// will return true
Reflect.has({a:0},"b");// will return false

// returns true for properties in the prototype chain
Reflect.has({a:0},"toString");

// Proxy with .has() handler method
object=newProxy({}, {
  has(s,d){returns.startsWith("cat");}
});
Reflect.has(object,"catastrophe");// will return true
Reflect.has(object,"camel");// will return false</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec729"/>Reflect.apply(target, receiver, args)</h3></div></div></div><p>This <a class="indexterm" id="id2535"/>method is used to call a target function with a specified set of arguments.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec574"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.apply(target, receiver, args)</code> method returns nothing.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec575"/>Parameter</h4></div></div></div><p>Target function to call. <code class="literal">thisArgument</code> and <code class="literal">ArgumentList</code> is passed as parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec576"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.apply()</code> technique calls an objective function with specified arguments.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">Reflect.apply(Math.floor, undefined,[3.999]);
// 3;

Reflect.apply(String.fromCharCode, undefined,[80, 97, 107, 105, 115, 116, 97, 110]);
// "Pakistan"

Reflect.apply("".charAt,"stars",[2]);
// "a"</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec730"/>Reflect.construct(target, args)</h3></div></div></div><p>This <a class="indexterm" id="id2536"/>method allows you to call a <code class="literal">constructor</code> function with multiple arguments. It is just like calling new function (…args).</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec577"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.construct(target, args)</code> returns nothing.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec578"/>Parameter</h4></div></div></div><p>The target function to be called, an argument list, and the new target (constructor to be used) are parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec579"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.construct</code> method permits you to conjure a constructor with a variable number of contentions (which would likewise be conceivable utilizing the spread operator consolidated with the new operator).</p><p>An example of this method is shown here:</p><p>Using <code class="literal">Reflect.construct()</code>:</p><div><pre class="programlisting">var d =Reflect.construct(Date,[2015,1,5]);
dinstanceofDate;// will return true
d.getFullYear();// 2015</pre></div><p>Using <a class="indexterm" id="id2537"/>
<code class="literal">newTarget</code>:</p><div><pre class="programlisting">functionmyConstructor(){}
var result =Reflect.construct(Array,[],myConstructor);

Reflect.getPrototypeOf(result);// myConstructor.prototype
Array.isArray(result);// will return true</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec731"/>Reflect.getOwnPropertyDescriptor(target, prop)</h3></div></div></div><p>This <a class="indexterm" id="id2538"/>method is just like <code class="literal">Object.getOwnPropertyDescriptor()</code>. This method returns a property descriptor of a specific property if it exists on an object; otherwise, undefined is returned. The only difference between these two is the way non-object targets are handled.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec580"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.getOwnPropertyDescriptor(target, prop)</code> method returns a property descriptor object.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec581"/>Parameter</h4></div></div></div><p>The target object in which to look for property, and property key (name of the property to be applied) are the parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec582"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.getOwnPropertyDescriptor</code> system gives back a property descriptor of the given property in the event that it exists on the object, indistinct something else undefined is returned if property does not exists. The main contrast to <code class="literal">Object.getOwnPropertyDescriptor()</code> is the manner by which non-object targets are taken care of.</p><p>An example of this method is shown here:</p><p>Using <code class="literal">Reflect.getOwnPropertyDescriptor()</code>:</p><div><pre class="programlisting">Reflect.getOwnPropertyDescriptor({a:"bye"},"a");
// {value: "bye", writable: true, enumerable: true, configurable: true}

Reflect.getOwnPropertyDescriptor({x:"bye"},"y");
// undefined

Reflect.getOwnPropertyDescriptor([],"length");
// {value: 0, writable: true, enumerable: false, configurable: false}</pre></div><p>Difference to <code class="literal">Object.getOwnPropertyDescriptor()</code>:</p><p>If the <a class="indexterm" id="id2539"/>first argument to this method is not an object (a primitive), then it will cause a <code class="literal">TypeError</code>. With <code class="literal">Object.getOwnPropertyDescriptor</code>, a non-object first argument will be coerced to an object at first:</p><div><pre class="programlisting">Reflect.getOwnPropertyDescriptor("woof",0);
// TypeError: "woof" is not non-null object

Object.getOwnPropertyDescriptor("dummy",0);
// { value: "d", writable: false, enumerable: true, configurable: false }</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec732"/>Reflect.defineProperty(target, prop, desc)</h3></div></div></div><p>This <a class="indexterm" id="id2540"/>method is similar <code class="literal">toObject.defineProperty()</code>. This method allows us to modify the property of an object. The <code class="literal">Object.defineProperty()</code> method returns an object or returns a type error if the property is not defined successfully. The <code class="literal">Reflect.defineProperty()</code> method returns <code class="literal">true</code> if the property was defined successfully. Otherwise, it returns <code class="literal">false</code>.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec583"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.defineProperty(target, prop, desc)</code> method returns a Boolean demonstrating regardless of whether the property was effectively characterized.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec584"/>Parameter</h4></div></div></div><p>Target object, property key, and attributes are the parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec585"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.defineProperty</code> technique permits the exact expansion to or change of a property on an object. For more subtle elements, see the <code class="literal">Object.defineProperty</code>, which is comparative. <code class="literal">Object.defineProperty</code> gives back the objects or tosses <code class="literal">TypeError</code> if the property has not been effectively characterized. <code class="literal">Reflect.defineProperty</code>, then again, essentially gives back a Boolean demonstrating regardless of whether the property was effectively characterized.</p><p>An example of this method is shown here:</p><p>Using <code class="literal">Reflect.defineProperty()</code>:</p><div><pre class="programlisting">http://haseeb.deeurl.com/client-demos/everydayadvice/v3/={};
Reflect.defineProperty(object,"x",{value:7});// will return true
object.x;// 7</pre></div><p>Checking if property definition has been successful:</p><p>With <a class="indexterm" id="id2541"/>
<code class="literal">Object.defineProperty</code>, which returns an object if successful or throws a <code class="literal">TypeError</code> otherwise, you would use a <code class="literal">try...catch</code> block to catch any error that occurred while defining a property. As <code class="literal">Reflect.defineProperty</code> returns a Boolean success status, you can just use an <code class="literal">if...else</code> block here:</p><div><pre class="programlisting">if(Reflect.defineProperty(target, property, attributes)) {
  // will return success
}
else{
  // will return failure
}</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec733"/>Reflect.getPrototypeOf(target)</h3></div></div></div><p>This <a class="indexterm" id="id2542"/>method returns a prototype of the specified object. It is similar to the <code class="literal">Object.getPrototypeOf()</code> method.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec586"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.getPrototypeOf(target)</code> method returns the prototype of object or null.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec587"/>Parameter</h4></div></div></div><p>The target object for which we need the prototype is passed as a parameter.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec588"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.getPrototypeOf()</code> method is the same technique as <code class="literal">Object.getPrototypeOf()</code>. It gives back the model (that is, the estimation of the inside <code class="literal">[[Prototype]]</code> property) of the predetermined item.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">Reflect.getPrototypeOf({});// Object.prototype
Reflect.getPrototypeOf(Object.prototype);// will return null
Reflect.getPrototypeOf(Object.create(null));// will return null</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec734"/>Reflect.setPrototypeOf(target, newProto)</h3></div></div></div><p>This <a class="indexterm" id="id2543"/>method sets the prototype of object to another object or to null. This method is the same as the <code class="literal">Object.setPrototypeOf()</code> method.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec589"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.setPrototypeOf(target, newProto)</code> method returns a Boolean showing regardless of whether the model was effectively set.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec590"/>Parameter</h4></div></div></div><p>The target object and prototype are parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec591"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.setPrototypeOf</code> method changes the prototype (that is, the value of the internal <code class="literal">[[Prototype]]</code> property) of the specified object.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">Reflect.setPrototypeOf({},Object.prototype);// will return true
Reflect.setPrototypeOf({},null);// will return true

Reflect.setPrototypeOf(Object.freeze({}),null);// will return false

var target ={};
varprototype=Object.create(target);
Reflect.setPrototypeOf(target,prototype);// will return false</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec735"/>Reflect.deleteProperty(target, prop)</h3></div></div></div><p>This <a class="indexterm" id="id2544"/>method is used to delete properties from an object. This method is similar to the delete operator as a function.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec592"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.deleteProperty(target, prop)</code> method returns a Boolean value telling us whether the property is deleted or not.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec593"/>Parameter</h4></div></div></div><p>The target object and the name of the property to be deleted are parameters.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec594"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.deleteProperty</code> method permits you to erase a property on an object. It returns boolean value indicating if the property was successfully removed or not, regardless of whether the property was effectively characterized. It is almost similar to the non-strict delete operator.</p><p>An example <a class="indexterm" id="id2545"/>of this method is shown here:</p><div><pre class="programlisting">varobject={a:11,b:12};
Reflect.deleteProperty(object,"a");// will return true
object;// { y: 12 }

vararr=[11,12,13,14,15];
Reflect.deleteProperty(arr,"3");// will return true
arr;// [11, 12, 13, , 15]

// Returns true if no such property exists
Reflect.deleteProperty({},"bar");// will return true

// Returns false if a property is unconfigurable
Reflect.deleteProperty(Object.freeze({bar:1}),"bar");// will return false</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec736"/>Reflect.enumerate(target)</h3></div></div></div><p>This <a class="indexterm" id="id2546"/>method returns an iterator with enumerable own and inherited properties of the target object.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec595"/>Returns</h4></div></div></div><p>Returns an iterator with the enumerable own and acquired properties of the objective object.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec596"/>Parameter</h4></div></div></div><p>Target object on which to get property is passed in the function.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec597"/>Description</h4></div></div></div><p>The <code class="literal">Reflect.enumerate()</code> method returns an iterator with the enumerable own and inherited properties of the target object.</p><p>An example <a class="indexterm" id="id2547"/>of this method is shown here:</p><div><pre class="programlisting">varobject={a:98,b:99};

for(var name ofReflect.enumerate(object)) {
  console.log(name);
}
// logs "a" and "b"</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec737"/>Reflect.preventExtensions(target)</h3></div></div></div><p>This is the <a class="indexterm" id="id2548"/>same method as <code class="literal">Object.preventExtensions()</code>. It prevents us from adding more properties (extensions) to an object.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec598"/>Returns</h4></div></div></div><p>Returns a Boolean demonstrating regardless of whether the objective was effectively set to forestall expansions.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec599"/>Parameter</h4></div></div></div><p>Target object on which we have to prevent extensions.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec600"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.preventExtensions()</code> method keeps new properties from always being added to an object (that is, counteracts future augmentations to the item). It is like <code class="literal">Object.preventExtensions()</code>, yet with a few contrasts.</p><p>An example of this method is as follows:</p><div><pre class="programlisting">varblank={};
Reflect.isExtensible(blank);// === will return true

Reflect.preventExtensions(blank);
Reflect.isExtensible(blank);// === will return false</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec738"/>Reflect.isExtensible(target)</h3></div></div></div><p>This <a class="indexterm" id="id2549"/>method allows us to check whether new properties can be added to an object or whether the object is extensible or not. This method is similar to the <code class="literal">Object.isExtensible()</code> method.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec601"/>Returns</h4></div></div></div><p>A Boolean value indicating whether the target is extensible or not.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec602"/>Parameter</h4></div></div></div><p>The target object that has to be checked for its extensibility.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec603"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.isExtensible()</code> technique figures out whether an item is extensible (whether it can have new properties added to it). It is like <code class="literal">Object.isExtensible()</code>, yet with a few contrasts.</p><p>An example of this method is shown here:</p><div><pre class="programlisting">var blank ={};
Reflect.isExtensible(blank);</pre></div><p>The preceding function will return <code class="literal">true</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec739"/>Reflect.ownKeys(target)</h3></div></div></div><p>This <a class="indexterm" id="id2550"/>method returns the object's own property keys.</p><div><div><div><div><h4 class="title"><a id="ch11lvl4sec604"/>Returns</h4></div></div></div><p>The <code class="literal">Reflect.ownKeys(target)</code> method returns an array of target objects.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec605"/>Parameter</h4></div></div></div><p>Target object from where to get keys.</p></div><div><div><div><div><h4 class="title"><a id="ch11lvl4sec606"/>Description</h4></div></div></div><p>The static <code class="literal">Reflect.set()</code> strategy works like setting a property on an object.</p><p>Here is an example of this method:</p><div><pre class="programlisting">Reflect.ownKeys({a:5,b:6,c:7});
Reflect.ownKeys([]);

varsymbol=Symbol.for("dirt");
varsymbolb=Symbol.for("sky");
varobject={[symbol]:0,"string":0,"99":0,"4":0,
[symbolb]:0,"100":0,"-7":0,"second string":0};
Reflect.ownKeys(object);</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec507"/>Tail calls</h2></div></div></div><p>Calls in tail position <a class="indexterm" id="id2551"/>won't be able to grow the stack without any limits. It helps in making recursive algorithms safe and secure in the safe of unbounded inputs.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec740"/>Example</h3></div></div></div><p>The following function <a class="indexterm" id="id2552"/>produces a factorial of any number passed to it. There is a tail call in the end of the function which recalls the function. Previously, we used to get a stackoverflow error, but ES6 is safe for handling arbitrary inputs.</p><p>If the output is out of range, it will simply display infinity:</p><div><pre class="programlisting">function factorial(n, acc) {
 'use strict';
 if (n &lt;= 1) return acc;
 return factorial(n - 1, n * acc);
}
console.log(factorial(5, 1)); //120
console.log(factorial(200, 1)); //Infinity

// Stack overflow in most implementations today,
// but safe on arbitrary inputs in ES6
console.log(factorial(10000000, 1));</pre></div></div></div></div></body></html>