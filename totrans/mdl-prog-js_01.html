<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. What Are Modules and Their Advantages?</h1></div></div></div><p>In this very first chapter, I will provide you with an overview of the modular design approach in application development as it relates to JavaScript applications.</p><p>I will also mention parallels between the modular style of application architecture and the real-life examples of this conceptual design.</p><p>Hopefully, as you read along, you'll be able to relate to at least some aspects of the modular design approach and start to see why this style of organizing your code can be extremely beneficial. </p><p>The main objective of this chapter is to create a familiar context for you, and to get you started on thinking the modular way as you create and organize your code. Soon, you will see that this approach can organically grow into a well-defined application architecture methodology.</p><p>We will start the chapter with a brief discussion on how we can organize our code based on specialization. Then we will look at how we can define modules based on the functionality that they provide.</p><p>The topics that are covered in this chapter are: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The simple rule to creating modules</li><li class="listitem" style="list-style-type: disc">A real life example of modules</li><li class="listitem" style="list-style-type: disc">A look at a non-modular example</li><li class="listitem" style="list-style-type: disc">Re-factoring into a more modular approach</li><li class="listitem" style="list-style-type: disc">Designing in a modular way</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Prelude to modular programming </h1></div></div></div><p>Many years ago, when I was taking my first computer programming course at college, I found myself having having difficulty organizing organizing my code into functions and classes. I always wondered what kind of criteria I needed to keep in mind to qualify a chunk of code to belong to a function or to a class or a subclass. When should I break down one function into multiple<a id="id0" class="indexterm"/> functions or a class into multiple classes?</p><p>Of course, there were some rules and guidelines that I was familiar with such as "a function should not be too long or should not do too many things; a class should be a blueprint of a data type" and so on. However, such rules and guidelines seemed abstract to me and I wanted to find a rule that was precise and applicable in all situations.</p><p>As I became more knowledgeable in programming concepts and gained more experience in application design, I was able to write more sophisticated code and organize my code better into functions and classes.</p><p>However, while my code was organized into well-defined functions and classes, such functions and classes still seemed scattered in different parts of the application. When I needed to make modifications to one piece of the application, I would be concerned about the impact that the change would have on other pieces and the functionality of the application as a whole.</p><p>As my applications grew larger and became more complex, the impact of the  changes and enhancements became even more pronounced. There were more things things that could adversely affect the application if the application pieces were not designed properly.</p><p>Browser-based applications were particularly vulnerable to such impacts as different parts of the application could be manipulating the same element in the browser, which would produce unexpected behaviors and effects in other parts of the application. </p><p>On the other hand, making small changes to the application was a challenge on its own, as finding the best place to make such small changes was not always very obvious. Each piece of the application could be performing many different activities from manipulation DOM to writing to cookie to making AJAX calls.</p><p>What if I could make one part of the application responsible for only one type of functionality?  What if only one part of the application was responsible for all cookie-related functionality? What if only one piece would make AJAX calls to the server and provide the other pieces of the application with the returned data?</p><p>As we design functions and classes to specialize in doing very specific tasks, we can also bundle such functions and classes together to act as a specialized piece of the application responsible for providing one particular functionality. The key point here is to create specialized code packages. </p><p>This would mean that changes in how we read and write to cookies would only take place in the package that is responsible for cookie operations and such changes would have no impact on how AJAX calls are made to the server.</p><p>If we organize<a id="id1" class="indexterm"/> our code into specialized packages, (or modules as we will call them) we can easily achieve this goal of separation of concerns and responsibilities among our application pieces.</p><p>But before we can organize our code into modules, we need to see how we decide that a chunk of code should be a module.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The simple rule for creating modules</h1></div></div></div><p>I need to emphasize on<a id="id2" class="indexterm"/> the fact that modular programming is not some magical and mystical design concept and pattern that is hard to grasp and even harder to implement. It is really just a practical approach to organizing our code in such a way that each chunk of code only does a very specific and specialized task. </p><p>The idea is that each module is a loosely coupled piece of the application, a building block that, along with other pieces (and other modules), creates an ecosystem, that is your application.</p><p>So here is the simple rule for creating modules: "If a piece of your application provides a specialized functionality, it can be made into a module that can also be reused in other applications."</p><p>I mentioned previously that I was looking for a "precise" rule to help me organize my application code but as my experience has shown, there is no such precise rule other than what I mentioned above, which is in fact not a rule but a guideline. And as a guideline, there is flexibility in what can be considered a module or not. This can be best decided both at the design time and as the application evolves since the application needs can change over time.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>A real-life example of modules</h1></div></div></div><p>Let's <a id="id3" class="indexterm"/>consider a familiar modular system. You are most likely reading this book in a place that has electricity and there are many electric outlets in the walls surrounding you. This system enables you to plug in various electrical devices into the outlets and each one of these devices is designed to do a very specific task.</p><p>Consider the electrical devices that are plugged into some of these outlets: microwaves, electric kettles, washers, dryers, and so on.</p><p>None of these devices care if they are plugged into the electrical outlet in your house or your neighbor's house. They are designed to do their specific task and functionality when they are plugged in and when the power is on, regardless of whose house they are in.</p><p>Our<a id="id4" class="indexterm"/> application modules should follow the same philosophy. This means, regardless of where in the application they are plugged in and even regardless of what application they are plugged into, they should do their specific task and only their specific task.</p><p>Also, in exactly the same way that an electrical device can easily be unplugged from the wall outlet, a code module should be designed in such a way that it can easily be decoupled and removed from your application.</p><p>Furthermore, as the removal of one electrical device has no impact on the functionality of other devices that are plugged into your electrical system, the removal of a code module or a series of code modules from your application should not have any effect on the functionality of the other parts of your application.</p><p>This decoupling should also have no effect on the application as a whole, other than perhaps just losing the specific functionality that was provided by that particular module or group of modules in your application.</p><p>In this book, we will explore how creating modules will help in designing better specialized code pieces that can easily be plugged into and unplugged from our applications. We will also see how modular architecture provides for a more robust and flexible application as a whole.</p><p>We will discover how this kind of architectural approach leads to huge advantages in many aspects of our application fundamentals such as code usability, maintainability, testability, and many more.</p><p>I hope now you are curious enough to at least consider modular programming in general and JavaScript modular programming in particular as a possible approach for your future application design.</p><p>In further chapters, we will apply the same principles that we discussed regarding electrical outlets and appliances to our code modules, in both the design and implementation phases.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>A look at a non-modular example</h1></div></div></div><p>Let's consider <a id="id5" class="indexterm"/>an extremely simple example and see how<a id="id6" class="indexterm"/> the (somehow) <strong>specialized</strong> modular approach differs from a non-modular one.</p><p>We start by writing a couple of functions in the traditional way, as following:</p><div><pre class="programlisting">function doAddition(num1, num2){
  return num1 + num2;
}

function doSubtraction(num1, num2){
  var result = null;
  if(num1 &gt; num2){
  result = num1 - num2;

  }else{
    result = num2 - num1; 
  }
  return result;
}

console.log(doAddition(3,2)); // displays 5

console.log(doSubtraction(3,2)); // displays 1</pre></div><p>As you<a id="id7" class="indexterm"/> can see in the above code, we have two independent functions for doing simple additions and subtractions and there is no relation between the two, other than the fact that they both operate on the two passed-in numbers (numeric values).</p><p>If we had implemented these functions in an application and were to do the identical operations in a different application, we most likely would either rewrite the same functions in that application from scratch or we would copy/paste the code from this application into the other one.</p><p>What if we now decided to also do multiplication, division, and other related calculations in our application using the same approach? </p><p>Well, one way would be to just continue writing independent functions as above and add them to our application. This approach could work and would get the job done, but probably not in the best way, since as the code grows it will become more disorganized and chaotic.</p><p>By using this approach, not only would we be polluting the global namespace with a bunch of global functions that could possibly collide with other global functions of the same name. We would also end up with scattered pieces of code that had not been packaged together based on their functionality and specialization.</p><p>If all such functions do mathematical calculations of one kind or another and that is the commonality that they all have, how about if <a id="id8" class="indexterm"/>we create a <strong>package</strong> (module) that specializes in mathematical calculations?</p><p>This would allow us to have a specialized package that regardless of the application that it is hosted in, would always provide the same specialized functionality.</p><p>Let's even imagine a step further and assume that we created this package in a separate JavaScript file that can be added as an independent module to any application.</p><p>Even<a id="id9" class="indexterm"/> better, how about if this module only would get added (requested from the server, in the case of a client side web application) to the application at runtime, and only when needed?</p><p>This type of implementation would give us the ability to load chunks, pieces, or modules of the code when needed at runtime and then unload them when the application does not need them anymore. This would enable us to cut down on the footprint of our application on the client side while providing all the necessary functionality as needed and on demand.</p><p>Such an approach can also be very useful on mobile devices which have limited bandwidth and resources to be leveraged.</p><p>Rest assured that I do intend to explore all such possibilities with you in the later chapters of this book.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Re-factoring to a more modularized approach</h1></div></div></div><p>Let's consider <a id="id10" class="indexterm"/>re-factoring the two functions that we looked at previously and putting them together in a more specialized package (class or module) called, <code class="literal">CalculationHandler</code>, as shown below:</p><div><pre class="programlisting">function CalculationHandler(){
  CalculationHandler.result = null;
}

CalculationHandler.doAddition = function(num1, num2){
  return num1 + num2;
};

CalculationHandler.doSubtraction = function(num1, num2){

  if(num1 &gt; num2){
    CalculationHandler.result = num1 - num2;

  }else{
    CalculationHandler.result = num2 - num1; 
  }
  return CalculationHandler.result;

};

console.log(CalculationHandler.doAddition(3,2)); // displays 5
console.log(CalculationHandler.doSubtraction(3,2)); // displays 1</pre></div><p>As you can see in this "module" (and I use the term loosely here; you will see why in later chapters), I <a id="id11" class="indexterm"/>am using a function object and adding properties (methods) to this object. This methods do specialized tasks related to the overall functionality of the object (module), such as addition and subtraction.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>
<strong>A note about our module here</strong>
</p><p>If you are more experienced in JavaScript programming, you are probably thinking that the way I have created this module is probably not the best way to create a real module in JavaScript, and you are right! But for now, the big idea here is that any piece of code that does a specialized task can be tagged as a module, for the most part.</p></div></div><p>However, there are certainly better ways to write more robust and extensible modules in JavaScript. For instance, creating a module can be accomplished much better by using the <strong>Module Design Pattern</strong>, which<a id="id12" class="indexterm"/> we will get to explore a lot further in later chapters of this book.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Designing in a modular way</h1></div></div></div><p>In the early <a id="id13" class="indexterm"/>stages of designing an application, one of the most important steps is to decide on the functionality that the application needs to provide. This of course, is based on the overall purpose of the application and the type of application that you are designing.</p><p>Based on such requirements, in the design phase, you should try to break down the overall functionality (the big picture) of the application into smaller and specialized pieces. Then, you can determine if such pieces already exist, either in the form of third-party libraries or the code that you have already written for a different application.</p><p>If you already have your own chunks of reusable code designed in a modular fashion (most third-party libraries are designed in such a way too), it would be much easier and quicker to connect these pieces together and use them in your new application. This would be the same as putting various Lego blocks together to create a play structure.</p><p>This type of approach is<a id="id14" class="indexterm"/> very important and fits quite well within an <strong>Agile</strong> development environment. This enables you to work on well defined, specialized modules as you need them and as new application requirements are defined. Also, as you create your code based on modules, you are able to prevent tight coupling among your application pieces.</p><p>On the other hand, this approach allows different developers to work on different pieces (modules) of the same application, independently of each other. Another advantage is that modules can be tested separately and in different environments before being added to the application.</p><p>In time <a id="id15" class="indexterm"/>and with more experience in modular application design and implementation, you will become better at deciding how to distinguish and design your modules. However, it is not realistic to think you can come up with the complete list of all the modules that you could ever need in your application, in the first attempt.</p><p>That is because applications evolve and requirements change over time. You may need to create new modules, or modify current ones, or decide to use a different module or library altogether to accommodate such changes in the requirements.</p><p>The key advantage of modular design is the flexibility that is provides. Dealing with all the situations mentioned above is a lot easier and requires a lot less effort in a modular architecture. It will also mitigate the impact that adding, removing, or modifying a module could possibly have on the application as a whole.</p><p>In the following chapters, you will see how we can create simple and complex modules and how they will be added to our application as loosely coupled pieces.</p><p>You will also see how we can load such modules dynamically and on demand when we need them in our application.</p><p>So, let's get ready for an exciting journey into our future application design, using modular architecture.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we tried to get an overview of the concepts behind modular programming in general and how such concepts can be used in JavaScript applications in particular.</p><p>We saw that this approach is essentially based on creating packages of specialized code that do very specific tasks.</p><p>We also made parallels between how modules are designed in real life and our application modules, so that we can translate the similarities into our own application design approach.</p><p>While the term "module" can be used to refer to different things in the code, we will take this terminology to refer to a certain style of programming and architecture in our JavaScript application design approach in later chapters.</p><p>However, before we completely dive into the more technical aspects of JavaScript modular programming, it is a good idea to review the fundamentals of object-oriented programming in JavaScript in the next chapter. This will allow us to establish a solid foundation for more technical chapters as we move forward.</p></div></body></html>