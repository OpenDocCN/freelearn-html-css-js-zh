<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Building a Chat Application</h1></div></div></div><p>We have gone through the basic concepts of Opa and now it's time to build a real web application. In this chapter we will build a chat application. The application offers one chat room. The users <a id="id290" class="indexterm"/>who connect to the application will join the chat room automatically and can start discussing immediately. For simplicity, we supply a <a id="id291" class="indexterm"/>random username when a user joins. The source code for this application can be found at <a class="ulink" href="https://github.com/winbomb/opapackt">https://github.com/winbomb/opapackt</a>.</p><p>The following is a screenshot of our chat application:</p><div><img src="img/3749OS_09_01.jpg" alt="Building a Chat Application"/></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec42"/>Creating a project</h1></div></div></div><p>To begin <a id="id292" class="indexterm"/>developing our chat application, we need to create an Opa project using the following Opa command:</p><div><pre class="programlisting">
<strong>opa create chat</strong>
</pre></div><p>This command will create an empty Opa project. Also, it will generate the required directories and files automatically with the structure as shown in the following screenshot:</p><div><img src="img/3749OS_09_02.jpg" alt="Creating a project"/></div><p>Let's have a brief look at what these source code files<a id="id293" class="indexterm"/> do:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">controller.opa</code>: This <a id="id294" class="indexterm"/>file <a id="id295" class="indexterm"/>serves as the entry point of the chat application; we start the web server in <code class="literal">controller.opa</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">view.opa</code>: This <a id="id296" class="indexterm"/>file serves as an<a id="id297" class="indexterm"/> user interface</li><li class="listitem" style="list-style-type: disc"><code class="literal">model.opa</code>: This<a id="id298" class="indexterm"/> is the model <a id="id299" class="indexterm"/>of the chat application; it defines the message, network, and the chat room</li><li class="listitem" style="list-style-type: disc"><code class="literal">style.css</code>: This<a id="id300" class="indexterm"/> is an external<a id="id301" class="indexterm"/> stylesheet file</li><li class="listitem" style="list-style-type: disc"><code class="literal">Makefile</code>: This<a id="id302" class="indexterm"/> file is<a id="id303" class="indexterm"/> used to build an application</li></ul></div><p>As we do not need database support in the chat application, we can remove <code class="literal">--import-package stdlib.database.mongo</code> from the FLAG option in <code class="literal">Makefile</code>. Type <code class="literal">make</code> and <code class="literal">make run</code> to run the empty application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec43"/>Launching the web server</h1></div></div></div><p>Let's begin <a id="id304" class="indexterm"/>with <code class="literal">controller.opa</code>, the entry point of our chat application where we launch the web server. We have already discussed the function <code class="literal">Server.start</code> in the <em>Server module</em> section of <a class="link" href="ch03.html" title="Chapter 3. Developing Web Applications">Chapter 3</a>, <em>Developing Web Applications</em>. In our chat application, we will use a handlers group to handle users requests.</p><div><pre class="programlisting">Server.start(Server.http, [
  {resources: @static_resource_directory("resources")},
  {register: [{css:["/resources/css/style.css"]}]},
  {title:"Opa Chat", page: View.page }
])</pre></div><p>So, what exactly are the arguments that we are passing to the <code class="literal">Server.start</code> function?</p><p>The line <code class="literal">{resources: @static_resource_direcotry("resources")}</code> registers a resource handler and will serve resource files in the <code class="literal">resources</code> directory.</p><p>Next, the line <code class="literal">{register: [{css:["/resources/css/style.css"]}]}</code> registers an external CSS file—<code class="literal">style.css</code>. This permits us to use styles in the <code class="literal">style.css</code> application scope.</p><p>Finally, the line <code class="literal">{title:"Opa Chat", page: View.page}</code> registers a single page handler<a id="id305" class="indexterm"/> that will dispatch all other requests to the function <code class="literal">View.page</code>.</p><p>The server uses the default configuration <code class="literal">Server.http</code> and will run on port 8080.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec44"/>Designing user interface</h1></div></div></div><p>When the<a id="id306" class="indexterm"/> application starts, all the requests (except requests for resources)<a id="id307" class="indexterm"/> will be distributed to the function <code class="literal">View.page</code>, which displays the chat page on the browser. Let's take a look at the view part; we define a module named <code class="literal">View</code> in <code class="literal">view.opa</code>.</p><div><pre class="programlisting">import stdlib.themes.bootstrap.css
module View {
  function page(){
    user = Random.string(8)
    &lt;div id=#title class="navbar navbar-inverse navbar-fixed-top"&gt;
      &lt;div class=navbar-inner&gt;
        &lt;div id=#logo /&gt; 
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=#conversation class=container-fluid
      onready={function(_){Model.join(updatemsg)}} /&gt;
    &lt;div id=#footer class="navbar navbar-fixed-bottom"&gt;
      &lt;div class=input-append&gt;
        &lt;input type=text id=#entry class=input-xxlarge
          onnewline={broadcast(user)}/&gt;
        &lt;button class="btn btn-primary" 
          onclick={broadcast(user)}&gt;Post&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  }
  ...
}</pre></div><p>The module<a id="id308" class="indexterm"/> <code class="literal">View</code> contains functions to display the page on <a id="id309" class="indexterm"/>the browser. In the first line, <code class="literal">import stdlib.themes.bootstrap.css</code>, we import Bootstrap styles.</p><p>This permits us to use Bootstrap markup in our code, such as <code class="literal">navbar</code>, <code class="literal">navbar-fix-top</code>, and <code class="literal">btn-primary</code>. We also registered an external <code class="literal">style.css</code> file so we can use styles in <code class="literal">style.css</code> such as <code class="literal">conversation</code> and <code class="literal">footer</code>.</p><p>As we can see, this code in the function page follows almost the same syntax as HTML. As discussed in the <em>XHTML</em> section of <a class="link" href="ch03.html" title="Chapter 3. Developing Web Applications">Chapter 3</a>, <em>Developing Web Applications</em>, we can use HTML freely in the Opa code, the HTML values having a predefined type <code class="literal">xhtml</code> in Opa.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec45"/>Building application logic</h1></div></div></div><p>A chat application<a id="id310" class="indexterm"/> is all about exchanging messages between users, so we need to define a message type. We can find its definition in the first line of <code class="literal">model.opa</code>:</p><div><pre class="programlisting">type message = {string user, string text}</pre></div><p>It's a very simple type with two fields. The <code class="literal">user</code> field represents the author of the message, and the <code class="literal">text</code> field represents the content of the message.</p><p>Now that we have the definition of a message, we need a way to pass the messages between different clients. As mentioned in <a class="link" href="ch05.html" title="Chapter 5. Communicating between Client and Server">Chapter 5</a>, <em>Communicating between Client and Server</em>, Opa provides three ways for communicating between clients and servers: session, cell, and network. <a id="id311" class="indexterm"/>Session is for one-way asynchronous communication; cell is a special case of session and is for two-way synchronous communication; and network is for broadcasting messages to all observers. Network is the right choice for our purpose:</p><div><pre class="programlisting">server private Network.network(message) room = Network.empty();</pre></div><p>This code fragment defines an empty network named <code class="literal">room</code>. The type of the network is <code class="literal">Network.network(message)</code>, which means it is a network used to transmit data of the type <code class="literal">message</code>. The keyword <code class="literal">private</code> indicates that it cannot be accessed from other modules and the keyword <code class="literal">server</code> instructs Opa to implement this network on the server and not on the client.</p><p>We could also have used <code class="literal">Network.cloud(key)</code> to create a clouded network. This type of network will be automatically shared between multiple servers if the application is executed with the <code class="literal">cloud</code> option (for example, <code class="literal">./chat.js --cloud</code>). When one or several servers invoke <code class="literal">Network.cloud(key)</code> with the same value key, only one network is actually created on one of the participating servers (chosen arbitrarily), and the network will be shared between servers.</p><p>Now that we have our network, the next step is to add the clients to our network and broadcast messages to the clients. Therefore, we need two new functions:</p><div><pre class="programlisting">  function register(callback) {
    Network.add_callback(callback,room);
  }
  @async function broadcast(message) {
    Network.broadcast(message, room);
  }</pre></div><p>The function <code class="literal">register</code>
<a id="id312" class="indexterm"/> registers a callback function to a given network. This registered function will be invoked whenever a new message arrives.</p><p>The function <a id="id313" class="indexterm"/>
<code class="literal">broadcast</code> broadcasts <a id="id314" class="indexterm"/>messages to all the clients belonging to a given network. Note that the order in which clients receive the message is unspecified.</p><p>The complete code of <code class="literal">model.opa</code> is as follows:</p><div><pre class="programlisting">type message = {string user, string text}
module Model {
  server private Network.network(message) room = Network.empty();
  @async function broadcast(message) {
    Network.broadcast(message, room);
  }
  function register(callback) {
    Network.add_callback(callback,room);
  }
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Broadcasting and receiving messages</h1></div></div></div><p>What is left for us to do is to connect the model and the view. There are two distinct functions that we need to accomplish.</p><p>We must broadcast the current user's message when the <strong>Post</strong> button is clicked on or when <em>Enter</em> is pressed in the text field. We must also display new messages as they arrive.</p><p>Let's first have a look at how we broadcast the user's message when they press <em>Enter</em>:</p><div><pre class="programlisting">&lt;button class="btn btn-primary"
onclick={broadcast(user)}&gt;Post&lt;/button&gt;
...
function broadcast(user)(_){
  text = Dom.get_value(#entry);
  Model.broadcast(~{user, text});
  Dom.clear_value(#entry);
}</pre></div><p>When the user presses <em>Enter</em>, the <code class="literal">broadcast</code> function will be invoked. In this function, we first get the user's input using <code class="literal">Dom.get_value</code>, and then we broadcast the message in the second line by<a id="id315" class="indexterm"/> calling the <code class="literal">broadcast</code> method in the module <code class="literal">Model</code>. Finally, we clear the content of the input field. That's all it takes to broadcast the message to all the connected clients. Now let's review how we process new message arrivals. We have already mentioned the function <code class="literal">Model.register</code> in <code class="literal">model.opa</code>. Recall that it registers a callback function to the network. Consider the following code found in <code class="literal">view.opa</code>:</p><div><pre class="programlisting">&lt;div id=#conversation class=container-fluid
  onready={function(_){Model.register(updatemsg)}} /&gt;</pre></div><p>When the div <code class="literal">#conversation</code> is ready, it invokes <code class="literal">Model.register</code> to register the callback function <code class="literal">updatemsg</code>, which will be called whenever a new message arrives:</p><div><pre class="programlisting">function updatemsg(msg){
  line = &lt;div class="row-fluid line"&gt;
         &lt;div class="span1 userpic" /&gt;
         &lt;div class="span2 user"&gt;{msg.user}:&lt;/&gt;
         &lt;div class="span9 message"&gt;{msg.text}&lt;/&gt;
         &lt;/div&gt;;
  #conversation =+ line;
  Dom.scroll_to_bottom(#conversation);
}</pre></div><p>In the function <code class="literal">updatemsg</code>, we first construct an HTML fragment representing the message we have received. <a id="id316" class="indexterm"/>Then, we append a line to the end of the <code class="literal">Dom</code> element with the id <code class="literal">conversation</code>. Note that we are using the shortcut syntax <code class="literal">=+</code>. Finally, we use the function <code class="literal">Dom.scroll_to_bottom</code> to scroll the content to the bottom.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we have built a real web application in Opa. The application uses concepts and methods we have discussed in the previous chapters. First, we reviewed how to create an Opa project and how to start the web server. Then, we used the Bootstrap markup and customized styles to build the chat page in the module <code class="literal">View</code>.</p><p>Subsequently, we defined the chat message and the chat room in the module <code class="literal">Model</code>. Finally, we put them together to create the chat application.</p></div></body></html>