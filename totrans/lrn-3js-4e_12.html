<html><head></head><body>
		<div><h1 id="_idParaDest-213" class="chapter-number"><a id="_idTextAnchor212"/>12</h1>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>Adding Physics and Sounds to Your Scene</h1>
			<p>In this chapter, we’ll look at Rapier, another library you can use to extend the basic functionality of Three.js. Rapier is a library that allows you to introduce physics into your 3D scene. By physics, we mean that your objects are subject to gravity – they can collide with one another, can be moved by applying impulses, and can be constrained in their movement by different types of joints. Besides physics, we’ll also look at how Three.js can help you with adding spatial sounds to your scene.</p>
			<p>In this chapter, we’ll discuss the following topics:</p>
			<ul>
				<li>Creating a Rapier scene where your objects are subject to gravity and can collide with one another</li>
				<li>Showing how to change the friction and restitution (bounciness) of the objects in the scene</li>
				<li>Explaining the various shapes supported by Rapier and how to use them</li>
				<li>Showing how to create compound shapes by combining simple shapes</li>
				<li>Showing how a height field allows you to simulate a complex shape</li>
				<li>Limiting the movement of an object by using joints to connect them to other objects</li>
				<li>Adding sound sources to your scene, whose sound volume and direction are based on the distance to the camera</li>
			</ul>
			<p class="callout-heading">Available physics engines</p>
			<p class="callout">There are a number of different open source JavaScript physics engines available. Most of them are not under active development though. Rapier, however, is under active development. Rapier is written in Rust and is cross-compiled to JavaScript, so you can use it in the browser. Should you choose to use any of the other libraries out there, the information in this chapter will still be useful since most of the libraries use the same approach as demonstrated in this chapter. Therefore, while the implementation and classes and functions used might be different, the concepts and setup shown in this chapter will, for the most part, be applicable regardless of the physics library you choose.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Creating a basic Three.js scene with Rapier</h1>
			<p>To get started, we <a id="_idIndexMarker1126"/>created a very basic scene in which a cube drops down<a id="_idIndexMarker1127"/> and hits a plane. You can see this <a id="_idIndexMarker1128"/>example by looking at the <code>physics-setup.html</code> example:</p>
			<div><div><img src="img/Figure_12.1_B18726.jpg" alt="Figure 12.1 – Simple Rapier physics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Simple Rapier physics</p>
			<p>When you open this example, you’ll see the cube slowly drop down, hit the corner of the gray horizontal plane, and bounce off it. We could have accomplished this without using a physics engine<a id="_idIndexMarker1129"/> by updating the position and rotation of the<a id="_idIndexMarker1130"/> cube and programming how it <a id="_idIndexMarker1131"/>should react. This is, however, rather difficult to do since we need to know exactly when it hits, where it hits, and how the cube should spin away after the hit. With Rapier, we just have to configure the physical world, and Rapier will calculate exactly what happens to the objects in the scene.</p>
			<p>Before we can configure our models to use the Rapier engine, we need to install Rapier in our project (we’ve already done this, so you don’t have to do this if you’re experimenting with the examples provided in this book):</p>
			<pre class="source-code">
$ yarn add @dimforge/rapier3d</pre>
			<p>Once added, we <a id="_idIndexMarker1132"/>need to import Rapier into our project. This is done slightly<a id="_idIndexMarker1133"/> differently than the normal imports we’ve seen because Rapier needs to load additional WebAssembly resources. This is<a id="_idIndexMarker1134"/> needed since the Rapier library is developed in the Rust language, and compiled into WebAssembly so it can also be used on the web. To use Rapier, we need to wrap our script like this:</p>
			<pre class="source-code">
import * as THREE from 'three'
import { RigidBodyType } from '@dimforge/rapier3d'
// maybe other imports
import('@dimforge/rapier3d').then((RAPIER) =&gt; {
  // the code
}</pre>
			<p>This last import statement will load the Rapier library asynchronously and calls the callback when all the data has been loaded and parsed. In the rest of the code, you can just call into the <code>RAPIER</code> object to access the Rapier-specific functionality.</p>
			<p>To set up a scene with Rapier, we need to do a few things:</p>
			<ol>
				<li>Create a Rapier <code>World</code>. This defines the physical world that we’re simulating and allows us to define the gravity that will be applied to objects in this world.</li>
				<li>For each object you want to simulate with Rapier, you’ve got to define a <code>RigidBodyDesc</code>. This defines the position and rotation of an object in the scene (as well as some other properties). By adding this description to the <code>World</code> instance, you get back a <code>RigidBody</code>.</li>
				<li>Next, you can tell Rapier the shape of the object you’re adding by creating a <code>ColliderDesc</code> object. This will tell Rapier that your object is a cube, sphere, cone, or another shape; how large it is; how much friction it has with regard to other objects; and how bouncy it is. This<a id="_idIndexMarker1135"/> description is then combined with the previously created <code>RigidBody</code> to create a <code>Collider</code> instance.</li>
				<li>In our animation <a id="_idIndexMarker1136"/>loop, we can now call <code>world.step()</code>, which makes<a id="_idIndexMarker1137"/> Rapier calculate all the new positions and rotations of the <code>RigidBody</code> objects that it is aware of.</li>
			</ol>
			<p class="callout-heading">Online Rapier documentation</p>
			<p class="callout">In this book, we’ll look at various properties of Rapier. We won’t explore the full set of features provided by <a id="_idIndexMarker1138"/>Rapier since that could fill a book in itself. More information on Rapier can be found here: <a href="https://rapier.rs/docs/">https://rapier.rs/docs/</a>.</p>
			<p>Let’s walk through<a id="_idIndexMarker1139"/> these steps and see how you combine this with the Three.js objects you’re already familiar with.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Setting up the world and creating the descriptions</h2>
			<p>The first thing we<a id="_idIndexMarker1140"/> need to do is create the <code>World</code> we’re simulating with:</p>
			<pre class="source-code">
const gravity = { x: 0.0, y: -9.81, z: 0.0 }
const world = new RAPIER.World(gravity)</pre>
			<p>This is straightforward code in which we create a <code>World</code> that has a gravity of <code>-9.81</code> on the <em class="italic">y</em>-axis. This is similar to the gravity on Earth.</p>
			<p>Next, let’s define the Three.js object we saw in our example: a cube that falls and the floor that it hits:</p>
			<pre class="source-code">
const floor = new THREE.Mesh(
  new THREE.BoxGeometry(5, 0.25, 5),
  new THREE.MeshStandardMaterial({color: 0xdddddd})
)
floor.position.set(2.5, 0, 2.5)
const sampleMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
)
sampleMesh.position.set(0, 4, 0)
scene.add(floor)
scene.add(sampleMesh)</pre>
			<p>Nothing new here. We just <a id="_idIndexMarker1141"/>define two <code>THREE.Mesh</code> objects and position the <code>sampleMesh</code> instance, the cube, above the corner of the <code>floor</code> surface. Next, we need to create the <code>RigidBodyDesc</code> and <code>ColliderDesc</code> objects, which represent the <code>THREE.Mesh</code> objects in the world of Rapier. We’ll start with the simple one, the floor:</p>
			<pre class="source-code">
const floorBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Fixed)
const floorBody = world.createRigidBody(floorBodyDesc)
floorBody.setTranslation({ x: 2.5, y: 0, z: 2.5 })
const floorColliderDesc = RAPIER.ColliderDesc.cuboid
  (2.5, 0.125, 2.5)
world.createCollider(floorColliderDesc, floorBody)</pre>
			<p>Here, first, we create a <code>RigidBodyDesc</code> with a single parameter, <code>RigidBodyType.Fixed</code>. A fixed rigid body means that Rapier isn’t allowed to change the position or the rotation of this object, so this object won’t be affected by gravity or moved around when another object hits it. By calling <code>world.createRigidBody</code>, we add it to the <code>world</code> known by Rapier so that Rapier can take this object into account when doing its calculations. Then, we use <code>setTranslation</code> to put <code>RigidBody</code> into the same position as our Three.js floor. The <code>setTranslation</code> function takes an optional extra parameter called <code>wakeUp</code>. If <code>RigidBody</code> is sleeping (what can happen if it hasn’t moved for a long time), passing in <code>true</code> for the <code>wakeUp</code> property makes sure that Rapier will take <code>RigidBody</code> into account when determining the new positions of all the objects that it is aware of.</p>
			<p>We still need to define <a id="_idIndexMarker1142"/>the shape of this object so that Rapier can tell when it collides with another object. For this, we use the <code>Rapier.ColliderDesc.cuboid</code> function in which we specify the shape. For the <code>cuboid</code> function, Rapier expects the shape to be defined by a half-width, a half-height, and a half-depth. The final step to take is to add this collider to the world and connect it to the floor. For this, we use the <code>world.createCollider</code> function.</p>
			<p>At this point, we have defined <code>floor</code> in the Rapier world, which corresponds to the floor in our Three.js scene. Now, we define the cube that will fall in the same way:</p>
			<pre class="source-code">
Const rigidBodyDesc = new RAPIER.RigidBodyDesc
(RigidBodyType.Dynamic)
    .setTranslation(0, 4, 0)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.cuboid
  (0.5, 0.5, 0.5)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setRestitution(1)</pre>
			<p>This code fragment is similar to the previous one – we just create the relevant objects for Rapier that correspond to the objects in our Three.js scene. The main change here is that we used a <code>RigidBodyType.Dynamic</code> instance. This means that this object can be completely managed by <a id="_idIndexMarker1143"/>Rapier. Rapier can change its position or its translation.</p>
			<p class="callout-heading">Additional rigid body types provided by Rapier</p>
			<p class="callout">Besides the <code>Dynamic</code> and the <code>Fixed</code> rigid body types, Rapier also provides a <code>KinematicPositionBased</code> type, for <a id="_idIndexMarker1144"/>managing the position of an object, or a <code>KinematicVelocityBased</code> type, for managing the velocity of an object ourselves. More information on this can be found here: <a href="https://rapier.rs/docs/user_guides/javascript/rigid_bodies">https://rapier.rs/docs/user_guides/javascript/rigid_bodies</a>.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Rendering the scene and simulating the world</h2>
			<p>What is left to do is<a id="_idIndexMarker1145"/> render the Three.js object, simulate the world, and make sure that the positions of the objects managed by Rapier correspond to the position of the Three.js meshes:</p>
			<pre class="source-code">
  const animate = (renderer, scene, camera) =&gt; {
    // basic animation loop
    requestAnimationFrame(() =&gt; animate(renderer, scene,
      camera))
    renderer.render(scene, camera)
    world.step()
    // copy over the position from Rapier to Three.js
    const rigidBodyPosition = rigidBody.translation()
    sampleMesh.position.set(
      rigidBodyPosition.x,
      rigidBodyPosition.y,
      rigidBodyPosition.z)
    // copy over the rotation from Rapier to Three.js
    const rigidBodyRotation = rigidBody.rotation()
    sampleMesh.rotation.setFromQuaternion(
      new THREE.Quaternion(rigidBodyRotation.x,
        rigidBodyRotation.y, rigidBodyRotation.z,
          rigidBodyRotation.w)
    )
  }</pre>
			<p>In our render loop, we have the normal Three.js elements to make sure we render this each step using <code>requestAnimationFrame</code>. Besides that, we call the <code>world.step()</code> function to trigger a calculation in Rapier. This will update the position and rotation of all the objects<a id="_idIndexMarker1146"/> that it knows of. Next, we need to make sure that these newly calculated positions are also reflected by the Three.js objects. To do this, we just get the current position of an object in the Rapier world (<code>rigidBody.translation()</code>) and set the position of the Three.js mesh to the result of that function. For the rotation, we do the same, by calling <code>rotation()</code> on <code>rigidBody</code> first, and then applying that rotation to our Three.js mesh. Rapier works with quaternions for defining rotations, so we need to make this conversion before we can apply that rotation to the Three.js mesh.</p>
			<p>And that’s all you need to do. All the examples in the following sections use this same approach:</p>
			<ul>
				<li>Setting up the Three.js scene</li>
				<li>Setting up a similar set of objects in the Rapier world</li>
				<li>Making sure that after each <code>step</code>, the location and rotation of both the Three.js scene and the Rapier world align again</li>
			</ul>
			<p>In the next section, we’ll expand on this example, and we’ll show you more about how objects interact with each other when they collide in the Rapier world.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Simulating dominos in Rapier</h1>
			<p>The following example is <a id="_idIndexMarker1147"/>built upon the same core concepts we looked at in the <em class="italic">Setting up the world and creating the descriptions</em> section. The example<a id="_idIndexMarker1148"/> can be viewed by opening up the <code>dominos.html</code> example:</p>
			<div><div><img src="img/Figure_12.2_B18726.jpg" alt="Figure 12.2 – Dominos standing still when no gravity is present"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Dominos standing still when no gravity is present</p>
			<p>Here, you can see that we’ve created a simple floor on which many dominos are positioned. If you look closely, you can see that the first instance of these dominos is tilted a little bit. If we enable gravity on the <em class="italic">y</em>-axis using the menu on the right, you’ll see that the first dominos falls, hits the next one, and so on until all the dominos have been knocked down:</p>
			<div><div><img src="img/Figure_12.3_B18726.jpg" alt="Figure 12.3 – Dominos falling down after the first one is toppled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Dominos falling down after the first one is toppled</p>
			<p>Creating this with Rapier is really straightforward. We just need to create the Three.js objects that represent<a id="_idIndexMarker1149"/> the dominos, create the relevant Rapier <code>RigidBody</code> and <code>Collider</code> elements, and make sure the changes to the Rapier <a id="_idIndexMarker1150"/>objects are reflected by the Three.js objects.</p>
			<p>First, let’s have a quick look at how we create the Three.js dominos:</p>
			<pre class="source-code">
const createDominos = () =&gt; {
    const getPoints = () =&gt; {
      const points = []
      const r = 2.8; const cX = 0; const cY = 0
      let circleOffset = 0
      for (let i = 0; i &lt; 1200; i += 6 + circleOffset) {
        circleOffset = 1.5 * (i / 360)
        const x = (r / 1440) * (1440 - i) * Math.cos(i *
          (Math.PI / 180)) + cX
        const z = (r / 1440) * (1440 - i) * Math.sin(i *
          (Math.PI / 180)) + cY
        const y = 0
        points.push(new THREE.Vector3(x, y, z))
      }
      return points
    }
    const stones = new Group()
    stones.name = 'dominos'
    const points = getPoints()
    points.forEach((point, index) =&gt; {
      const colors = [0x66ff00, 0x6600ff]
      const stoneGeom = new THREE.BoxGeometry
        (0.05, 0.5, 0.2)
      const stone = new THREE.Mesh(
        stoneGeom,
        new THREE.MeshStandardMaterial({color: colors[index
        % colors.length], transparent: true, opacity: 0.8})
      )
      stone.position.copy(point)
      stone.lookAt(new THREE.Vector3(0, 0, 0))
      stones.add(stone)
    })
    return stones
  }</pre>
			<p>In this code fragment, we determine the position of the dominos with the <code>getPoints</code> function. This function returns a list of <code>THREE.Vector3</code> objects that represent the position of the individual stones. Each stone is placed along a spiral outward from the center. Next, these <code>points</code> are used to create a number of <code>THREE.BoxGeometry</code> objects at the same locations. To<a id="_idIndexMarker1151"/> make sure the dominos are oriented correctly, we use the <code>lookAt</code> function to have them ‘look at’ the center of the circle. All the dominos <a id="_idIndexMarker1152"/>are added to a <code>THREE.Group</code> object, which we then add to a <code>THREE.Scene</code> instance (this is not shown in the code fragment).</p>
			<p>Now that we have our set of <code>THREE.Mesh</code> objects, we can create the corresponding set of Rapier objects:</p>
			<pre class="source-code">
const rapierDomino = (mesh) =&gt; {
  const stonePosition = mesh.position
  const stoneRotationQuaternion = new THREE.Quaternion().
    setFromEuler(mesh.rotation)
  const dominoBodyDescription = new RAPIER.RigidBodyDesc
    (RigidBodyType.Dynamic)
    .setTranslation(stonePosition.x, stonePosition.y,
      stonePosition.z)
    .setRotation(stoneRotationQuaternion))
    .setCanSleep(false)
    .setCcdEnabled(false)
  const dominoRigidBody = world.createRigidBody
    (dominoBodyDescription)
  const geometryParameters = mesh.geometry.parameters
  const dominoColliderDesc = RAPIER.ColliderDesc.cuboid(
    geometryParameters.width / 2,
    geometryParameters.height / 2,
    geometryParameters.depth / 2
  )
  const dominoCollider = world.createCollider
    (dominoColliderDesc, dominoRigidBody)
  mesh.userData.rigidBody = dominoRigidBody
  mesh.userData.collider = dominoCollider
}</pre>
			<p>This code will look familiar to the code in <em class="italic">Setting up the world and creating the descriptions</em> section. Here, we take the position and rotation of the passed-in <code>THREE.Mesh</code> instance <a id="_idIndexMarker1153"/>and use that information to create the relevant Rapier objects. To <a id="_idIndexMarker1154"/>make sure we can access the <code>dominoCollider</code> and <code>dominoRigidBody</code> instances in the render loop, we add them to the <code>userData</code> property of the passed-in mesh.</p>
			<p>The final step here is to update the <code>THREE.Mesh</code> objects in the render loop:</p>
			<pre class="source-code">
  const animate = (renderer, scene, camera) =&gt; {
    requestAnimationFrame(() =&gt; animate(renderer, scene,
      camera))
    renderer.render(scene, camera)
    world.step()
    const dominosGroup = scene.getObjectByName('dominos')
    dominosGroup.children.forEach((domino) =&gt; {
      const dominoRigidBody = domino.userData.rigidBody
      const position = dominoRigidBody.translation()
      const rotation = dominoRigidBody.rotation()
      domino.position.set(position.x, position.y,
        position.z)
      domino.rotation.setFromQuaternion(new
        THREE.Quaternion(rotation.x, rotation.y,
          rotation.z, rotation.w))
    })
  }</pre>
			<p>In each loop, we tell Rapier to calculate the next state of the world (<code>world.step</code>), and for each domino (which are <code>children</code> of the <code>THREE.Group</code> named <code>dominos</code>), we update the position and rotation of the <code>THREE.Mesh</code> instance based on the <code>RigidBody</code> object stored in that mesh’s <code>userdata</code> information.</p>
			<p>Before we move on to <a id="_idIndexMarker1155"/>the most important properties provided by a collider, we’ll have a quick look at how gravity affects this scene. When you open this example, with<a id="_idIndexMarker1156"/> the help of the menu on the right, you can change the gravity of the world. You can use this to experiment with how the dominos respond to different gravity settings. For instance, the following example shows the situation where, after all the dominos have fallen, we increased the gravity along the <em class="italic">x</em>-axis and <em class="italic">z</em>-axis:</p>
			<div><div><img src="img/Figure_12.4_B18726.jpg" alt="Figure 12.4 – Dominos with different gravity settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Dominos with different gravity settings</p>
			<p>In the next section, we’ll <a id="_idIndexMarker1157"/>show the effect that setting the friction and restitution has on<a id="_idIndexMarker1158"/> the Rapier objects.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Working with restitution and friction</h1>
			<p>In the next <a id="_idIndexMarker1159"/>example, we’ll look a bit closer at the <code>restitution</code> and <code>friction</code> properties <a id="_idIndexMarker1160"/>of the <code>Collider</code> provided by Rapier.</p>
			<p><code>restitution</code> is the property that defines how much energy an object keeps after it collides with another object. You can look at it a bit like bounciness. A tennis ball has high restitution, while a brick has low restitution.</p>
			<p><code>friction</code> defines how easily an object glides on top of another object. Objects with high friction slow down quickly when moving on top of another object, while objects with low friction can easily glide. Something such as ice has low friction, while sandpaper has high<a id="_idIndexMarker1161"/> friction.</p>
			<p>We can set these <a id="_idIndexMarker1162"/>properties during the construction of the <code>RAPIER.ColliderDesc</code> object or set it afterward when we’ve already created the collider using the <code>(world.createCollider(...)</code> function. Before we look at the code, we’ll have a look at the example. For the <code>colliders-properties.html</code> example, you’ll see a big box into which you can drop shapes:</p>
			<div><div><img src="img/Figure_12.5_B18726.jpg" alt="Figure 12.5 – Empty box to drop shapes into"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Empty box to drop shapes into</p>
			<p>With the menu on the right, you can drop in sphere and cube shapes, and set the friction and restitution for the added objects. For the first scenario, we’ll add a large number of cubes with high friction.</p>
			<div><div><img src="img/Figure_12.6_B18726.jpg" alt="Figure 12.6 – Box with cubes with high friction"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Box with cubes with high friction</p>
			<p>What you see here is<a id="_idIndexMarker1163"/> that even though the box is moving around its axis, the <a id="_idIndexMarker1164"/>cubes barely move around. This is because the cubes themselves have very high friction. If you try this with low friction, you’ll see that the boxes will slide around in the bottom of the box.</p>
			<p>To set the friction, all you have to do is this:</p>
			<pre class="source-code">
const rigidBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setFriction(0.5)</pre>
			<p>Rapier provides one more way of controlling friction and that is by setting the combine rule using the <code>setFrictionCombineRule</code> function. This tells Rapier how to combine the friction of the two objects that have collided (in our example, the bottom of the box and<a id="_idIndexMarker1165"/> the cube). With <a id="_idIndexMarker1166"/>Rapier, you can set this to the following values:</p>
			<ul>
				<li><code>CoefficientCombineRule.Average</code>: The average of the two coefficients is used</li>
				<li><code>CoefficientCombineRule.Min</code>: The minimum among the two coefficients is used</li>
				<li><code>CoefficientCombineRule.Multiply</code>: The product of the two coefficients is used</li>
				<li><code>CoefficientCombineRule.Max</code>: The maximum among the two coefficients is used</li>
			</ul>
			<p>To explore how <code>restitution</code> works, we can use this same example (<code>colliders-properties.html</code>):</p>
			<div><div><img src="img/Figure_12.7_B18726.jpg" alt="Figure 12.7 – Box with spheres with high restitution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Box with spheres with high restitution</p>
			<p>Here, we’ve increased the restitution of the spheres. The result is that they now bounce around in the box <a id="_idIndexMarker1167"/>when added or when they hit a wall. To set the restitution, you <a id="_idIndexMarker1168"/>use the same approach as for the friction:</p>
			<pre class="source-code">
const rigidBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setRestitution(0.9)</pre>
			<p>Rapier also allows you to set how the <code>restitution</code> property of the objects that hit each other is calculated. You can use the same values but this time, you use the <code>setRestitutionCombineRule</code> function.</p>
			<p>The <code>Collider</code> has additional <a id="_idIndexMarker1169"/>properties you can use to fine-tune how the collider interacts<a id="_idIndexMarker1170"/> with the Rapier view of the world, and what happens when objects collide. Rapier itself provides very good documentation for this. Specifically for the colliders, you can find that documentation here: <a href="https://rapier.rs/docs/user_guides/javascript/colliders#restitution">https://rapier.rs/docs/user_guides/javascript/colliders#restitution</a>.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Rapier-supported shapes</h1>
			<p>Rapier provides a number of shapes you can <a id="_idIndexMarker1171"/>use to wrap your geometries. In this section, we’ll walk you through all the available Rapier shapes and demonstrate these meshes through an example. Note that to use these shapes you need to call <code>RAPIER.ColliderDesc.roundCuboid</code>, <code>RAPIER.ColliderDesc.ball</code>, and so on.</p>
			<p>Rapier provides 3D shapes and 2D shapes. We’ll only look at the 3D shapes provided by Rapier:</p>
			<ul>
				<li><code>ball</code>: A ball shape, configured by setting the radius of the ball</li>
				<li><code>capsule</code>: A capsule shape, defined by the half-height of the capsule and its radius</li>
				<li><code>cuboid</code>: A simple cube shape defined by passing in the half-width, half-height, and half-depth of the shape</li>
				<li><code>heightfield</code>: A height field is a shape for which each provided value defines the height of a 3D plane</li>
				<li><code>cylinder</code>: A cylinder shape defined by the half-height and the radius of the cylinder</li>
				<li><code>cone</code>: A cone shape defined by the half-height and the radius of the bottom of the cylinder</li>
				<li><code>convexHull</code>: A convex hull is the smallest shape that encompasses all the passed-in points</li>
				<li><code>convexMesh</code>: A convex mesh also takes a number of points, but it is assumed that these points already form a convex hull, so Rapier won’t make any calculations to determine the smaller shape</li>
			</ul>
			<p>Besides these shapes, Rapier also provides an additional rounded variant for a few of these shapes: <code>roundCuboid</code>, <code>roundCylinder</code>, <code>roundCone</code>, <code>roundConvexHull</code>, and <code>roundConvexMesh</code>.</p>
			<p>We’ve provided another example in which you can what these shapes look like and how they interact when they <a id="_idIndexMarker1172"/>collide with each other. Open up the <code>shapes.html</code> example to see this in action:</p>
			<div><div><img src="img/Figure_12.8_B18726.jpg" alt="Figure 12.8 – Shapes on top of a heightfield object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Shapes on top of a heightfield object</p>
			<p>When you open this example, you’ll see an empty <code>heightfield</code> object. With the menu on the right, you can add different shapes and they’ll collide with each other and with the <code>heightfield</code> instance. Once again, you can set the specific <code>restitution</code> and <code>friction</code> values for the objects you’re adding. Since we’ve already explained in the previous sections how to add the shape in Rapier and make sure the corresponding shapes in Three.js are updated, we won’t go into detail here on how to create the shapes from the previous list. For the code, look at the <code>shapes.js</code> file in the sources for this chapter.</p>
			<p>One final note before we move on to the section on joints – when we want to depict simple shapes (for example, balls or cubes), the way that Rapier defines this model and the way Three.js defines it are pretty much the same. Therefore, when this kind of object collides with <a id="_idIndexMarker1173"/>another object, it will look correct. When we have more complex shapes, as, in this example, with a <code>heightmap</code> instance, there can be slight differences in how Three.js interprets and interpolates these points to a <code>heightmap</code> instance, and how Rapier does so. You can see this for yourself by looking at the <code>shapes.html</code> example, adding a lot of different shapes, and then looking at the underside of the <code>heightfield</code>:</p>
			<div><div><img src="img/Figure_12.9_B18726.jpg" alt="Figure 12.9 – Bottom of the heightfield"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Bottom of the heightfield</p>
			<p>What you can see here is that we can see small parts of the different objects poking through the <code>heightmap</code>. The reason is that Rapier has a different way of determining the exact shape of the <code>heightmap</code> than Three.js. In other words, Rapier thinks that the <code>heightmap</code> looks slightly different than<a id="_idIndexMarker1174"/> Three.js does. Therefore, when it determines where specific shapes are when they collide, it can result in small details such as this. However, by tuning the sizes or creating simpler objects, this can easily be circumvented.</p>
			<p>So far, we’ve looked at gravity and collisions. Rapier also provides a way to limit the movement and rotation of rigid bodies. We’ll explain how Rapier does this by using joints.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>Using joints to limit the movement of objects</h1>
			<p>Up until now, we’ve seen some basic physics in <a id="_idIndexMarker1175"/>action. We’ve seen how various shapes respond to gravity, friction, and restitution, and how this affects collision. Rapier also provides advanced constructs that allow you to limit the movement of your objects. In Rapier, these objects are called joints. The<a id="_idIndexMarker1176"/> following list gives an overview of the joints that are available in Rapier:</p>
			<ul>
				<li><strong class="bold">Fixed joint</strong>: A fixed joint makes sure that two bodies don’t move relative to one another. This means that the <a id="_idIndexMarker1177"/>distance and rotation between these two objects<a id="_idIndexMarker1178"/> will always be the same.</li>
				<li><strong class="bold">Spherical joint</strong>: A spherical joint <a id="_idIndexMarker1179"/>makes sure that the distance between two bodies<a id="_idIndexMarker1180"/> stays the same. The bodies, however, can move around one another on all three axes.</li>
				<li><strong class="bold">Revolute joint</strong>: With this joint, the <a id="_idIndexMarker1181"/>distance between the two bodies stays the same, and they are<a id="_idIndexMarker1182"/> allowed to rotate on a single axis – for instance, a steering wheel, which can only rotate around a single axis.</li>
				<li><strong class="bold">Prismatic joint</strong>: Similar to the<a id="_idIndexMarker1183"/> revolute joint but this time, the rotations between the<a id="_idIndexMarker1184"/> objects are fixed, and the objects can move on a single axis. This causes a sliding effect – for example, such as a lift moving upward.</li>
			</ul>
			<p>In the following sections, we’ll explore these joints and see them in action in the examples.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Connecting two objects with a fixed joint</h2>
			<p>The simplest of joints is <a id="_idIndexMarker1185"/>a fixed joint. With this joint, you can connect two objects, and they’ll stay at the same distance and orientation that is specified when this joint is created.</p>
			<p>This is shown in the <code>fixed-joint.html</code> example:</p>
			<div><div><img src="img/Figure_12.10_B18726.jpg" alt="Figure 12.10 – A fixed joint connecting two joints"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – A fixed joint connecting two joints</p>
			<p>As you can see in this example, the two cubes move as one. This happens because they are connected by a fixed <a id="_idIndexMarker1186"/>joint. To set this up, we first have to create the two <code>RigidBody</code> objects and the two <code>Collider</code> objects, as we’ve already seen in the previous sections. The next thing we need to do is connect these two objects. For this, we first need to define <code>JointData</code>:</p>
			<pre class="source-code">
  let params = RAPIER.JointData.fixed(
    { x: 0.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },
    { x: 2.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 }
  )</pre>
			<p>This means that we connect the first object at the position of <code>{ x: 0.0, y: 0.0, z: 0.0 }</code> (its center) to the second object, which is positioned at <code>{ x: 2.0, y: 0.0, z: 0.0 }</code>, where the first object is rotated with a quaternion of <code>{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }</code> and the second object is rotated the same amount –  <code>{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }</code>. The only thing that we need to do now is tell the Rapier <code>world</code> about this joint and which <code>RigidBody</code> objects it applies to:</p>
			<pre class="source-code">
world.createImpulseJoint(params, rigidBody1, rigidBody2,
  true)</pre>
			<p>The last property here defines whether the <code>RigidBody</code> should wake up because of this joint. A <code>RigidBody</code> can<a id="_idIndexMarker1187"/> be put to sleep when it hasn’t moved for a couple of seconds. For joints, it is usually best to just set this to <code>true</code> since this makes sure that if one of the <code>RigidBody</code> objects to which we attach the joint is sleeping, <code>RigidBody</code> will wake up.</p>
			<p>Another great way of seeing this joint in action is by using the following parameters:</p>
			<pre class="source-code">
  let params = RAPIER.JointData.fixed(
    { x: 0.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },
    { x: 2.0, y: 2.0, z: 2.0 },
    { w: 0.3, x: 1, y: 1, z: 1 }
  )</pre>
			<p>This will cause the two cubes to get caught on the floor in the center of the scene:</p>
			<div><div><img src="img/Figure_12.11_B18726.jpg" alt="Figure 12.11 – A fixed joint connecting two cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – A fixed joint connecting two cubes</p>
			<p>Next on our list is the <a id="_idIndexMarker1188"/>spherical joint.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Connecting objects with a spherical joint</h2>
			<p>A spherical joint allows two <a id="_idIndexMarker1189"/>objects to freely move around one another while keeping the same distance between these objects. This can be used for ragdoll effects or, as we did in this example, creating a chain (<code>sphere-joint.html</code>):</p>
			<div><div><img src="img/Figure_12.12_B18726.jpg" alt="Figure 12.12 – Multiple spheres connected by a spherical joint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Multiple spheres connected by a spherical joint</p>
			<p>As you can see in this example, we’ve connected a large number of spheres to create a chain of spheres. When these spheres hit the cylinder in the middle, they’ll wrap around and slowly glide off this <a id="_idIndexMarker1190"/>cylinder. You can see that while the orientation between these spheres changes based on their collisions, the absolute distance between the spheres stays the same. So, to set up this example, we’ve created a number of spheres with <code>RigidBody</code> and <code>Collider</code>, similar to the previous examples. For each set of two spheres, we also create a joint like this:</p>
			<pre class="source-code">
  const createChain = (beads) =&gt; {
    for (let i = 1; i &lt; beads.length; i++) {
      const previousBead = beads[i - 1].userData.rigidBody
      const thisBead = beads[i].userData.rigidBody
      const positionPrevious = beads[i - 1].position
      const positionNext = beads[i].position
      const xOffset = Math.abs(positionNext.x –
        positionPrevious.x)
      const params = RAPIER.JointData.spherical(
        { x: 0, y: 0, z: 0 },
        { x: xOffset, y: 0, z: 0 }
        )
      world.createImpulseJoint(params, thisBead,
        previousBead, true)
    }
  }</pre>
			<p>You can see that we create a joint using <code>RAPIER.JointData.spherical</code>. The parameters here define<a id="_idIndexMarker1191"/> the position of the first object, <code>{ x: 0, y: 0, z: 0 }</code>, and the relative position of the second object, <code>{ x: xOffset, y: 0, z: 0 }</code>. We do this for all the objects and add the joints to the rapier world using <code>world.createImpulseJoint(params, thisBead, </code><code>previousBead, true)</code>.</p>
			<p>The result is that we’ve got a chain of spheres that is connected using these spherical joints.</p>
			<p>The next joint, the revolute joint, allows us to restrict the movement of two objects by specifying a single axis around which an object is allowed to rotate in relation to another object.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Limiting rotation with a revolute joint</h2>
			<p>With a revolute joint, it is<a id="_idIndexMarker1192"/> easy to create gear, wheel, and fan-like constructs that rotate around a single axis. The easiest way to explain this is by looking at the <code>revolute-joint.html</code> example:</p>
			<div><div><img src="img/Figure_12.13_B18726.jpg" alt="Figure 12.13 – A cube before it is dropped on a rotating bar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – A cube before it is dropped on a rotating bar</p>
			<p>In <em class="italic">Figure 12</em><em class="italic">.13</em>, you can see a purple cube hovering above a green bar. When you enable gravity in the <code>y</code> direction, the cube will drop on top of the green bar. The center of this green bar is connected to the fixed cube in the middle using a revolute joint. The result is that this green bar will now slowly rotate because of the weight of the purple cube:</p>
			<div><div><img src="img/Figure_12.14_B18726.jpg" alt="Figure 12.14 – The bar responding to the weight on one end"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – The bar responding to the weight on one end</p>
			<p>For a revolute joint to <a id="_idIndexMarker1193"/>work, we once again need two rigid bodies. The Rapier part of the gray cube is defined like this:</p>
			<pre class="source-code">
const bodyDesc = new RAPIER.RigidBodyDesc(RigidBodyType.Fixed)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid(0.5, 0.5, 0.5)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>This means, that this <code>RigidBody</code> will always be in the same location regardless of any forces exerted on it. The green bar is defined like this:</p>
			<pre class="source-code">
Const bodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
  .setCanSleep(false)
  .setTranslation(-1, 0, 0)
  .setAngularDamping(0.1)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid(0.25, 0.05,
  2)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>Nothing special here, but we <a id="_idIndexMarker1194"/>have introduced a new property could <code>angularDamping</code>. With angular damping, Rapier will slowly decrease the rotation speed of a <code>RigidBody</code>. In our example, this means that the bar will slowly stop rotating after a while.</p>
			<p>And the box that we’re dropping looks like this:</p>
			<pre class="source-code">
Const bodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
  .setCanSleep(false)
  .setTranslation(-1, 1, 1)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid
  (0.1, 0.1, 0.1)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>So, at this point, we have defined <code>RigidBody</code>. Now, we can connect the fixed box with the green bar:</p>
			<pre class="source-code">
const params = RAPIER.JointData.revolute(
  { x: 0.0, y: 0, z: 0 },
  { x: 1.0, y: 0, z: 0 },
  { x: 1, y: 0, z: 0 }
)
let joint = world.createImpulseJoint(params, fixedCubeBody,
  greenBarBody, true)</pre>
			<p>The first two parameters determine the position at which the two rigid bodies are connected (following the same idea as with the fixed joint). The last parameter defines the vector at which the bodies<a id="_idIndexMarker1195"/> can rotate in relation to one another. Since our first <code>RigidBody</code> is fixed, only the green bar can rotate.</p>
			<p>The last joint type supported by Rapier is the prismatic joint.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Limiting movement to a single axis with a prismatic joint</h2>
			<p>The prismatic joint limits the<a id="_idIndexMarker1196"/> movement of an object to a single axis. This is demonstrated in the following example (<code>prismatic.html</code>), where the movement of the reddish cube is limited to a single axis:</p>
			<div><div><img src="img/Figure_12.15_B18726.jpg" alt="Figure 12.15 – Red cube is limited to one axis"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – Red cube is limited to one axis</p>
			<p>In this example, we throw a cube at the green bar with the revolute joint from the previous example. This <a id="_idIndexMarker1197"/>will cause the green bar to spin around its <em class="italic">y</em>-axis at the center and hit the reddish cube. This cube is limited to movement along a single axis, and you’ll see it moving along that axis.</p>
			<p>To create the joint for this example, we used the following piece of code:</p>
			<pre class="source-code">
const prismaticParams = RAPIER.JointData.prismatic(
  { x: 0.0, y: 0.0, z: 0 },
  { x: 0.0, y: 0.0, z: 3 },
  { x: 1, y: 0, z: 0 }
)
prismaticParams.limits = [-2, 2]
prismaticParams.limitsEnabled = true
world.createImpulseJoint(prismaticParams, fixedCubeBody,
  redCubeBody, true)</pre>
			<p>We once again define the position (<code>{ x: 0.0, y: 0.0, z: 0 }</code>) of <code>fixedCubeBody</code> first, which<a id="_idIndexMarker1198"/> defines the object we’re moving in relation to. Then, we define the position of our cube – <code>{ x: 0.0, y: 0.0, z: 3 }</code>. Finally, we define the axis along which our object is allowed to move. In this case, we defined <code>{ x: 1, y: 0, z: 0 }</code>, which means it is allowed to move along its <em class="italic">x</em>-axis.</p>
			<p class="callout-heading">Using joint motors to move objects around their allowed axis</p>
			<p class="callout">Spherical, revolute, and prismatic joints also support something called motors. With motors, you can move a rigid body along its allowed axis. We haven’t shown this in these examples but by using motors, you can add gears that move around automatically or create a car where you move the wheels using revolute joints with the help of a motor. For more information on motors, see the relevant section of the Rapier documentation here: <a href="https://rapier.rs/docs/user_guides/javascript/joints#joint-motors">https://rapier.rs/docs/user_guides/javascript/joints#joint-motors</a>.</p>
			<p>As we mentioned in the <em class="italic">Creating a basic Three.js scene with Rapier</em> section, we’ve only scratched the surface of what is possible with Rapier. Rapier is an extensive library with many features that allow fine-tuning and should provide support for most cases in which you might need a physics engine. The library is actively being developed, and the online documentation is very good.</p>
			<p>With the examples in this chapter and the online documentation, you should be able to integrate Rapier into your own scenes even for the features not explained in this chapter.</p>
			<p>We’ve mainly looked at 3D models and how to render them in Three.js. However, Three.js also provides support for 3D sounds. In the next section, we’ll show you an example of how you can add directional sound to a Three.js scene.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Adding sound sources to your scene</h1>
			<p>Having discussed several relevant topics by now, we have a lot of the ingredients in place to create beautiful scenes, games, and other 3D visualizations. What we haven’t shown, however, is how to<a id="_idIndexMarker1199"/> add sounds to your Three.js scene. In this section, we’ll look at two Three.js objects that allow you to add sources of sound to your scene. This is especially interesting since these sound sources respond to the position of the camera:</p>
			<ul>
				<li>The distance between the sound source and the camera determines the volume of the sound source</li>
				<li>The positions of the left-hand side and the right-hand side of the camera determine the sound volume of the left-hand side speaker and the right-hand side speaker, respectively</li>
			</ul>
			<p>The best way to explain this is to see this in action. Open up the <code>audio.html</code> example in your browser, and you’ll see a scene from <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Animations and Moving </em><em class="italic">the Camera</em>:</p>
			<div><div><img src="img/Figure_12.16_B18726.jpg" alt="Figure 12.16 – A scene with audio elements"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – A scene with audio elements</p>
			<p>This example uses the first-person controls we saw in <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, so you can use the arrow keys in combination with the mouse to move around the scene. Since browsers don’t support starting audio automatically anymore, first, hit the <code>enableSounds</code> button in the menu on the right to turn on the sounds. When you do this, you’ll hear water coming from somewhere nearby – and you’ll be able to hear some cows and some sheep in the distance.</p>
			<p>The water sounds come from the water wheel behind your starting position, the sounds from the sheep come<a id="_idIndexMarker1200"/> from the flock of sheep to the right, and the cow sounds are centered on the two oxen pulling the plow. If you use the controls to move around the scene, you’ll notice that the sounds change based on where you are – the nearer you get to the sheep, the better you’ll hear them, and as you move to the left, the sounds of the oxen will be louder. This is something called positional audio, where the <a id="_idIndexMarker1201"/>volume and direction are used to determine how to play the sounds.</p>
			<p>Accomplishing this only takes a small amount of code. The first thing we need to do is define a <code>THREE.AudioListener</code> object and add it to <code>THREE.PerspectiveCamera</code>:</p>
			<pre class="source-code">
const listener = new THREE.AudioListener(); camera.add(listener1);</pre>
			<p>Next, we need to create a <code>THREE.Mesh</code> (or a <code>THREE.Object3D</code>) instance and add a <code>THREE.PositionalAudio</code> object to that mesh. This will determine the source location of this specific sound:</p>
			<pre class="source-code">
const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1,
  1), new THREE.MeshNormalMaterial({ visible: false }))
mesh1.position.set(-4, -2, 10)
scene.add(mesh1)
const posSound1 = new THREE.PositionalAudio(listener)
const audioLoader = new THREE.AudioLoader()
audioLoader.load('/assets/sounds/water.mp3', function
  (buffer) {
posSound1.setBuffer(buffer)
posSound1.setRefDistance(1)
posSound1.setRolloffFactor(3)
posSound1.setLoop(true)
mesh1.add(posSound3)</pre>
			<p>As you can see from this code snippet, we first create a standard <code>THREE.Mesh</code> instance. Next, we create a <code>THREE.PositionalAudio</code> object, which we connect to the <code>THREE.AudioListener</code> object that we created earlier. Finally, we add the audio and configure some properties, which <a id="_idIndexMarker1202"/>define how the sound is played and how it behaves:</p>
			<ul>
				<li><code>setRefDistance</code>: This determines the distance from the object at which the sound will be reduced in volume.</li>
				<li><code>setLoop</code>: By default, a sound is played once. By setting this property to <code>true</code>, the sound loops.</li>
				<li><code>setRolloffFactor</code>: This determines how quickly the volume decreases as you move away from the sound source.</li>
			</ul>
			<p>Internally, Three.js uses the Web Audio API (<a href="http://webaudio.github.io/web-audio-api/">http://webaudio.github.io/web-audio-api/</a>) to play the sound and determine the correct volume. Not all browsers support this specification. The best support currently is from Chrome and Firefox.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Summary</h1>
			<p>In this chapter, we explored how you can extend the basic 3D functionality of Three.js by adding physics. For this, we used the Rapier library, which allows you to add gravity to your scene and objects, have objects interact with each other and bounce when they collide, and use joints to limit the movement of objects relative to each other.</p>
			<p>Besides that, we also showed you how Three.js supports 3D sounds. We created a scene where you added positional sound using the <code>THREE.PositionalAudio</code> and <code>THREE.AudioListener</code> objects.</p>
			<p>Even though we’ve now covered all of the core functionalities provided by Three.js, there are two more chapters dedicated to exploring some external tools and libraries that you can use together with Three.js. In the next chapter, we’ll dive into Blender and see how we can use Blender’s functionality, such as baking shadows, editing UV maps, and exchanging models between Blender and Three.js.</p>
		</div>
	</body></html>