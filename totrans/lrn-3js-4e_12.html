<html><head></head><body>
		<div id="_idContainer280">
			<h1 id="_idParaDest-213" class="chapter-number"><a id="_idTextAnchor212"/>12</h1>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>Adding Physics and Sounds to Your Scene</h1>
			<p>In this chapter, we’ll look at Rapier, another library you can use to extend the basic functionality of Three.js. Rapier is a library that allows you to introduce physics into your 3D scene. By physics, we mean that your objects are subject to gravity – they can collide with one another, can be moved by applying impulses, and can be constrained in their movement by different types of joints. Besides physics, we’ll also look at how Three.js can help you with adding spatial sounds to <span class="No-Break">your scene.</span></p>
			<p>In this chapter, we’ll discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating a Rapier scene where your objects are subject to gravity and can collide with <span class="No-Break">one another</span></li>
				<li>Showing how to change the friction and restitution (bounciness) of the objects in <span class="No-Break">the scene</span></li>
				<li>Explaining the various shapes supported by Rapier and how to <span class="No-Break">use them</span></li>
				<li>Showing how to create compound shapes by combining <span class="No-Break">simple shapes</span></li>
				<li>Showing how a height field allows you to simulate a <span class="No-Break">complex shape</span></li>
				<li>Limiting the movement of an object by using joints to connect them to <span class="No-Break">other objects</span></li>
				<li>Adding sound sources to your scene, whose sound volume and direction are based on the distance to <span class="No-Break">the camera</span></li>
			</ul>
			<p class="callout-heading">Available physics engines</p>
			<p class="callout">There are a number of different open source JavaScript physics engines available. Most of them are not under active development though. Rapier, however, is under active development. Rapier is written in Rust and is cross-compiled to JavaScript, so you can use it in the browser. Should you choose to use any of the other libraries out there, the information in this chapter will still be useful since most of the libraries use the same approach as demonstrated in this chapter. Therefore, while the implementation and classes and functions used might be different, the concepts and setup shown in this chapter will, for the most part, be applicable regardless of the physics library <span class="No-Break">you choose.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Creating a basic Three.js scene with Rapier</h1>
			<p>To get started, we <a id="_idIndexMarker1126"/>created a very basic scene in which a cube drops down<a id="_idIndexMarker1127"/> and hits a plane. You can see this <a id="_idIndexMarker1128"/>example by looking at the <span class="No-Break"><strong class="source-inline">physics-setup.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/Figure_12.1_B18726.jpg" alt="Figure 12.1 – Simple Rapier physics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Simple Rapier physics</p>
			<p>When you open this example, you’ll see the cube slowly drop down, hit the corner of the gray horizontal plane, and bounce off it. We could have accomplished this without using a physics engine<a id="_idIndexMarker1129"/> by updating the position and rotation of the<a id="_idIndexMarker1130"/> cube and programming how it <a id="_idIndexMarker1131"/>should react. This is, however, rather difficult to do since we need to know exactly when it hits, where it hits, and how the cube should spin away after the hit. With Rapier, we just have to configure the physical world, and Rapier will calculate exactly what happens to the objects in <span class="No-Break">the scene.</span></p>
			<p>Before we can configure our models to use the Rapier engine, we need to install Rapier in our project (we’ve already done this, so you don’t have to do this if you’re experimenting with the examples provided in <span class="No-Break">this book):</span></p>
			<pre class="source-code">
$ yarn add @dimforge/rapier3d</pre>
			<p>Once added, we <a id="_idIndexMarker1132"/>need to import Rapier into our project. This is done slightly<a id="_idIndexMarker1133"/> differently than the normal imports we’ve seen because Rapier needs to load additional WebAssembly resources. This is<a id="_idIndexMarker1134"/> needed since the Rapier library is developed in the Rust language, and compiled into WebAssembly so it can also be used on the web. To use Rapier, we need to wrap our script <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import * as THREE from 'three'
import { RigidBodyType } from '@dimforge/rapier3d'
// maybe other imports
import('@dimforge/rapier3d').then((RAPIER) =&gt; {
  // the code
}</pre>
			<p>This last import statement will load the Rapier library asynchronously and calls the callback when all the data has been loaded and parsed. In the rest of the code, you can just call into the <strong class="source-inline">RAPIER</strong> object to access the <span class="No-Break">Rapier-specific functionality.</span></p>
			<p>To set up a scene with Rapier, we need to do a <span class="No-Break">few things:</span></p>
			<ol>
				<li>Create a Rapier <strong class="source-inline">World</strong>. This defines the physical world that we’re simulating and allows us to define the gravity that will be applied to objects in <span class="No-Break">this world.</span></li>
				<li>For each object you want to simulate with Rapier, you’ve got to define a <strong class="source-inline">RigidBodyDesc</strong>. This defines the position and rotation of an object in the scene (as well as some other properties). By adding this description to the <strong class="source-inline">World</strong> instance, you get back <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">RigidBody</strong></span><span class="No-Break">.</span></li>
				<li>Next, you can tell Rapier the shape of the object you’re adding by creating a <strong class="source-inline">ColliderDesc</strong> object. This will tell Rapier that your object is a cube, sphere, cone, or another shape; how large it is; how much friction it has with regard to other objects; and how bouncy it is. This<a id="_idIndexMarker1135"/> description is then combined with the previously created <strong class="source-inline">RigidBody</strong> to create a <span class="No-Break"><strong class="source-inline">Collider</strong></span><span class="No-Break"> instance.</span></li>
				<li>In our animation <a id="_idIndexMarker1136"/>loop, we can now call <strong class="source-inline">world.step()</strong>, which makes<a id="_idIndexMarker1137"/> Rapier calculate all the new positions and rotations of the <strong class="source-inline">RigidBody</strong> objects that it is <span class="No-Break">aware of.</span></li>
			</ol>
			<p class="callout-heading">Online Rapier documentation</p>
			<p class="callout">In this book, we’ll look at various properties of Rapier. We won’t explore the full set of features provided by <a id="_idIndexMarker1138"/>Rapier since that could fill a book in itself. More information on Rapier can be found <span class="No-Break">here: </span><a href="https://rapier.rs/docs/"><span class="No-Break">https://rapier.rs/docs/</span></a><span class="No-Break">.</span></p>
			<p>Let’s walk through<a id="_idIndexMarker1139"/> these steps and see how you combine this with the Three.js objects you’re already <span class="No-Break">familiar with.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Setting up the world and creating the descriptions</h2>
			<p>The first thing we<a id="_idIndexMarker1140"/> need to do is create the <strong class="source-inline">World</strong> we’re <span class="No-Break">simulating with:</span></p>
			<pre class="source-code">
const gravity = { x: 0.0, y: -9.81, z: 0.0 }
const world = new RAPIER.World(gravity)</pre>
			<p>This is straightforward code in which we create a <strong class="source-inline">World</strong> that has a gravity of <strong class="source-inline">-9.81</strong> on the <em class="italic">y</em>-axis. This is similar to the gravity <span class="No-Break">on Earth.</span></p>
			<p>Next, let’s define the Three.js object we saw in our example: a cube that falls and the floor that <span class="No-Break">it hits:</span></p>
			<pre class="source-code">
const floor = new THREE.Mesh(
  new THREE.BoxGeometry(5, 0.25, 5),
  new THREE.MeshStandardMaterial({color: 0xdddddd})
)
floor.position.set(2.5, 0, 2.5)
const sampleMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshNormalMaterial()
)
sampleMesh.position.set(0, 4, 0)
scene.add(floor)
scene.add(sampleMesh)</pre>
			<p>Nothing new here. We just <a id="_idIndexMarker1141"/>define two <strong class="source-inline">THREE.Mesh</strong> objects and position the <strong class="source-inline">sampleMesh</strong> instance, the cube, above the corner of the <strong class="source-inline">floor</strong> surface. Next, we need to create the <strong class="source-inline">RigidBodyDesc</strong> and <strong class="source-inline">ColliderDesc</strong> objects, which represent the <strong class="source-inline">THREE.Mesh</strong> objects in the world of Rapier. We’ll start with the simple one, <span class="No-Break">the floor:</span></p>
			<pre class="source-code">
const floorBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Fixed)
const floorBody = world.createRigidBody(floorBodyDesc)
floorBody.setTranslation({ x: 2.5, y: 0, z: 2.5 })
const floorColliderDesc = RAPIER.ColliderDesc.cuboid
  (2.5, 0.125, 2.5)
world.createCollider(floorColliderDesc, floorBody)</pre>
			<p>Here, first, we create a <strong class="source-inline">RigidBodyDesc</strong> with a single parameter, <strong class="source-inline">RigidBodyType.Fixed</strong>. A fixed rigid body means that Rapier isn’t allowed to change the position or the rotation of this object, so this object won’t be affected by gravity or moved around when another object hits it. By calling <strong class="source-inline">world.createRigidBody</strong>, we add it to the <strong class="source-inline">world</strong> known by Rapier so that Rapier can take this object into account when doing its calculations. Then, we use <strong class="source-inline">setTranslation</strong> to put <strong class="source-inline">RigidBody</strong> into the same position as our Three.js floor. The <strong class="source-inline">setTranslation</strong> function takes an optional extra parameter called <strong class="source-inline">wakeUp</strong>. If <strong class="source-inline">RigidBody</strong> is sleeping (what can happen if it hasn’t moved for a long time), passing in <strong class="source-inline">true</strong> for the <strong class="source-inline">wakeUp</strong> property makes sure that Rapier will take <strong class="source-inline">RigidBody</strong> into account when determining the new positions of all the objects that it is <span class="No-Break">aware of.</span></p>
			<p>We still need to define <a id="_idIndexMarker1142"/>the shape of this object so that Rapier can tell when it collides with another object. For this, we use the <strong class="source-inline">Rapier.ColliderDesc.cuboid</strong> function in which we specify the shape. For the <strong class="source-inline">cuboid</strong> function, Rapier expects the shape to be defined by a half-width, a half-height, and a half-depth. The final step to take is to add this collider to the world and connect it to the floor. For this, we use the <span class="No-Break"><strong class="source-inline">world.createCollider</strong></span><span class="No-Break"> function.</span></p>
			<p>At this point, we have defined <strong class="source-inline">floor</strong> in the Rapier world, which corresponds to the floor in our Three.js scene. Now, we define the cube that will fall in the <span class="No-Break">same way:</span></p>
			<pre class="source-code">
Const rigidBodyDesc = new RAPIER.RigidBodyDesc
(RigidBodyType.Dynamic)
    .setTranslation(0, 4, 0)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.cuboid
  (0.5, 0.5, 0.5)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setRestitution(1)</pre>
			<p>This code fragment is similar to the previous one – we just create the relevant objects for Rapier that correspond to the objects in our Three.js scene. The main change here is that we used a <strong class="source-inline">RigidBodyType.Dynamic</strong> instance. This means that this object can be completely managed by <a id="_idIndexMarker1143"/>Rapier. Rapier can change its position or <span class="No-Break">its translation.</span></p>
			<p class="callout-heading">Additional rigid body types provided by Rapier</p>
			<p class="callout">Besides the <strong class="source-inline">Dynamic</strong> and the <strong class="source-inline">Fixed</strong> rigid body types, Rapier also provides a <strong class="source-inline">KinematicPositionBased</strong> type, for <a id="_idIndexMarker1144"/>managing the position of an object, or a <strong class="source-inline">KinematicVelocityBased</strong> type, for managing the velocity of an object ourselves. More information on this can be found <span class="No-Break">here: </span><a href="https://rapier.rs/docs/user_guides/javascript/rigid_bodies"><span class="No-Break">https://rapier.rs/docs/user_guides/javascript/rigid_bodies</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Rendering the scene and simulating the world</h2>
			<p>What is left to do is<a id="_idIndexMarker1145"/> render the Three.js object, simulate the world, and make sure that the positions of the objects managed by Rapier correspond to the position of the <span class="No-Break">Three.js meshes:</span></p>
			<pre class="source-code">
  const animate = (renderer, scene, camera) =&gt; {
    // basic animation loop
    requestAnimationFrame(() =&gt; animate(renderer, scene,
      camera))
    renderer.render(scene, camera)
    world.step()
    // copy over the position from Rapier to Three.js
    const rigidBodyPosition = rigidBody.translation()
    sampleMesh.position.set(
      rigidBodyPosition.x,
      rigidBodyPosition.y,
      rigidBodyPosition.z)
    // copy over the rotation from Rapier to Three.js
    const rigidBodyRotation = rigidBody.rotation()
    sampleMesh.rotation.setFromQuaternion(
      new THREE.Quaternion(rigidBodyRotation.x,
        rigidBodyRotation.y, rigidBodyRotation.z,
          rigidBodyRotation.w)
    )
  }</pre>
			<p>In our render loop, we have the normal Three.js elements to make sure we render this each step using <strong class="source-inline">requestAnimationFrame</strong>. Besides that, we call the <strong class="source-inline">world.step()</strong> function to trigger a calculation in Rapier. This will update the position and rotation of all the objects<a id="_idIndexMarker1146"/> that it knows of. Next, we need to make sure that these newly calculated positions are also reflected by the Three.js objects. To do this, we just get the current position of an object in the Rapier world (<strong class="source-inline">rigidBody.translation()</strong>) and set the position of the Three.js mesh to the result of that function. For the rotation, we do the same, by calling <strong class="source-inline">rotation()</strong> on <strong class="source-inline">rigidBody</strong> first, and then applying that rotation to our Three.js mesh. Rapier works with quaternions for defining rotations, so we need to make this conversion before we can apply that rotation to the <span class="No-Break">Three.js mesh.</span></p>
			<p>And that’s all you need to do. All the examples in the following sections use this <span class="No-Break">same approach:</span></p>
			<ul>
				<li>Setting up the <span class="No-Break">Three.js scene</span></li>
				<li>Setting up a similar set of objects in the <span class="No-Break">Rapier world</span></li>
				<li>Making sure that after each <strong class="source-inline">step</strong>, the location and rotation of both the Three.js scene and the Rapier world <span class="No-Break">align again</span></li>
			</ul>
			<p>In the next section, we’ll expand on this example, and we’ll show you more about how objects interact with each other when they collide in the <span class="No-Break">Rapier world.</span></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Simulating dominos in Rapier</h1>
			<p>The following example is <a id="_idIndexMarker1147"/>built upon the same core concepts we looked at in the <em class="italic">Setting up the world and creating the descriptions</em> section. The example<a id="_idIndexMarker1148"/> can be viewed by opening up the <span class="No-Break"><strong class="source-inline">dominos.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/Figure_12.2_B18726.jpg" alt="Figure 12.2 – Dominos standing still when no gravity is present"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Dominos standing still when no gravity is present</p>
			<p>Here, you can see that we’ve created a simple floor on which many dominos are positioned. If you look closely, you can see that the first instance of these dominos is tilted a little bit. If we enable gravity on the <em class="italic">y</em>-axis using the menu on the right, you’ll see that the first dominos falls, hits the next one, and so on until all the dominos have been <span class="No-Break">knocked down:</span></p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/Figure_12.3_B18726.jpg" alt="Figure 12.3 – Dominos falling down after the first one is toppled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Dominos falling down after the first one is toppled</p>
			<p>Creating this with Rapier is really straightforward. We just need to create the Three.js objects that represent<a id="_idIndexMarker1149"/> the dominos, create the relevant Rapier <strong class="source-inline">RigidBody</strong> and <strong class="source-inline">Collider</strong> elements, and make sure the changes to the Rapier <a id="_idIndexMarker1150"/>objects are reflected by the <span class="No-Break">Three.js objects.</span></p>
			<p>First, let’s have a quick look at how we create the <span class="No-Break">Three.js dominos:</span></p>
			<pre class="source-code">
const createDominos = () =&gt; {
    const getPoints = () =&gt; {
      const points = []
      const r = 2.8; const cX = 0; const cY = 0
      let circleOffset = 0
      for (let i = 0; i &lt; 1200; i += 6 + circleOffset) {
        circleOffset = 1.5 * (i / 360)
        const x = (r / 1440) * (1440 - i) * Math.cos(i *
          (Math.PI / 180)) + cX
        const z = (r / 1440) * (1440 - i) * Math.sin(i *
          (Math.PI / 180)) + cY
        const y = 0
        points.push(new THREE.Vector3(x, y, z))
      }
      return points
    }
    const stones = new Group()
    stones.name = 'dominos'
    const points = getPoints()
    points.forEach((point, index) =&gt; {
      const colors = [0x66ff00, 0x6600ff]
      const stoneGeom = new THREE.BoxGeometry
        (0.05, 0.5, 0.2)
      const stone = new THREE.Mesh(
        stoneGeom,
        new THREE.MeshStandardMaterial({color: colors[index
        % colors.length], transparent: true, opacity: 0.8})
      )
      stone.position.copy(point)
      stone.lookAt(new THREE.Vector3(0, 0, 0))
      stones.add(stone)
    })
    return stones
  }</pre>
			<p>In this code fragment, we determine the position of the dominos with the <strong class="source-inline">getPoints</strong> function. This function returns a list of <strong class="source-inline">THREE.Vector3</strong> objects that represent the position of the individual stones. Each stone is placed along a spiral outward from the center. Next, these <strong class="source-inline">points</strong> are used to create a number of <strong class="source-inline">THREE.BoxGeometry</strong> objects at the same locations. To<a id="_idIndexMarker1151"/> make sure the dominos are oriented correctly, we use the <strong class="source-inline">lookAt</strong> function to have them ‘look at’ the center of the circle. All the dominos <a id="_idIndexMarker1152"/>are added to a <strong class="source-inline">THREE.Group</strong> object, which we then add to a <strong class="source-inline">THREE.Scene</strong> instance (this is not shown in the <span class="No-Break">code fragment).</span></p>
			<p>Now that we have our set of <strong class="source-inline">THREE.Mesh</strong> objects, we can create the corresponding set of <span class="No-Break">Rapier objects:</span></p>
			<pre class="source-code">
const rapierDomino = (mesh) =&gt; {
  const stonePosition = mesh.position
  const stoneRotationQuaternion = new THREE.Quaternion().
    setFromEuler(mesh.rotation)
  const dominoBodyDescription = new RAPIER.RigidBodyDesc
    (RigidBodyType.Dynamic)
    .setTranslation(stonePosition.x, stonePosition.y,
      stonePosition.z)
    .setRotation(stoneRotationQuaternion))
    .setCanSleep(false)
    .setCcdEnabled(false)
  const dominoRigidBody = world.createRigidBody
    (dominoBodyDescription)
  const geometryParameters = mesh.geometry.parameters
  const dominoColliderDesc = RAPIER.ColliderDesc.cuboid(
    geometryParameters.width / 2,
    geometryParameters.height / 2,
    geometryParameters.depth / 2
  )
  const dominoCollider = world.createCollider
    (dominoColliderDesc, dominoRigidBody)
  mesh.userData.rigidBody = dominoRigidBody
  mesh.userData.collider = dominoCollider
}</pre>
			<p>This code will look familiar to the code in <em class="italic">Setting up the world and creating the descriptions</em> section. Here, we take the position and rotation of the passed-in <strong class="source-inline">THREE.Mesh</strong> instance <a id="_idIndexMarker1153"/>and use that information to create the relevant Rapier objects. To <a id="_idIndexMarker1154"/>make sure we can access the <strong class="source-inline">dominoCollider</strong> and <strong class="source-inline">dominoRigidBody</strong> instances in the render loop, we add them to the <strong class="source-inline">userData</strong> property of the <span class="No-Break">passed-in mesh.</span></p>
			<p>The final step here is to update the <strong class="source-inline">THREE.Mesh</strong> objects in the <span class="No-Break">render loop:</span></p>
			<pre class="source-code">
  const animate = (renderer, scene, camera) =&gt; {
    requestAnimationFrame(() =&gt; animate(renderer, scene,
      camera))
    renderer.render(scene, camera)
    world.step()
    const dominosGroup = scene.getObjectByName('dominos')
    dominosGroup.children.forEach((domino) =&gt; {
      const dominoRigidBody = domino.userData.rigidBody
      const position = dominoRigidBody.translation()
      const rotation = dominoRigidBody.rotation()
      domino.position.set(position.x, position.y,
        position.z)
      domino.rotation.setFromQuaternion(new
        THREE.Quaternion(rotation.x, rotation.y,
          rotation.z, rotation.w))
    })
  }</pre>
			<p>In each loop, we tell Rapier to calculate the next state of the world (<strong class="source-inline">world.step</strong>), and for each domino (which are <strong class="source-inline">children</strong> of the <strong class="source-inline">THREE.Group</strong> named <strong class="source-inline">dominos</strong>), we update the position and rotation of the <strong class="source-inline">THREE.Mesh</strong> instance based on the <strong class="source-inline">RigidBody</strong> object stored in that mesh’s <span class="No-Break"><strong class="source-inline">userdata</strong></span><span class="No-Break"> information.</span></p>
			<p>Before we move on to <a id="_idIndexMarker1155"/>the most important properties provided by a collider, we’ll have a quick look at how gravity affects this scene. When you open this example, with<a id="_idIndexMarker1156"/> the help of the menu on the right, you can change the gravity of the world. You can use this to experiment with how the dominos respond to different gravity settings. For instance, the following example shows the situation where, after all the dominos have fallen, we increased the gravity along the <em class="italic">x</em>-axis <span class="No-Break">and </span><span class="No-Break"><em class="italic">z</em></span><span class="No-Break">-axis:</span></p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/Figure_12.4_B18726.jpg" alt="Figure 12.4 – Dominos with different gravity settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Dominos with different gravity settings</p>
			<p>In the next section, we’ll <a id="_idIndexMarker1157"/>show the effect that setting the friction and restitution has on<a id="_idIndexMarker1158"/> the <span class="No-Break">Rapier objects.</span></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Working with restitution and friction</h1>
			<p>In the next <a id="_idIndexMarker1159"/>example, we’ll look a bit closer at the <strong class="source-inline">restitution</strong> and <strong class="source-inline">friction</strong> properties <a id="_idIndexMarker1160"/>of the <strong class="source-inline">Collider</strong> provided <span class="No-Break">by Rapier.</span></p>
			<p><strong class="source-inline">restitution</strong> is the property that defines how much energy an object keeps after it collides with another object. You can look at it a bit like bounciness. A tennis ball has high restitution, while a brick has <span class="No-Break">low restitution.</span></p>
			<p><strong class="source-inline">friction</strong> defines how easily an object glides on top of another object. Objects with high friction slow down quickly when moving on top of another object, while objects with low friction can easily glide. Something such as ice has low friction, while sandpaper has <span class="No-Break">high</span><span class="No-Break"><a id="_idIndexMarker1161"/></span><span class="No-Break"> friction.</span></p>
			<p>We can set these <a id="_idIndexMarker1162"/>properties during the construction of the <strong class="source-inline">RAPIER.ColliderDesc</strong> object or set it afterward when we’ve already created the collider using the <strong class="source-inline">(world.createCollider(...)</strong> function. Before we look at the code, we’ll have a look at the example. For the <strong class="source-inline">colliders-properties.html</strong> example, you’ll see a big box into which you can <span class="No-Break">drop shapes:</span></p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/Figure_12.5_B18726.jpg" alt="Figure 12.5 – Empty box to drop shapes into"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Empty box to drop shapes into</p>
			<p>With the menu on the right, you can drop in sphere and cube shapes, and set the friction and restitution for the added objects. For the first scenario, we’ll add a large number of cubes with <span class="No-Break">high friction.</span></p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/Figure_12.6_B18726.jpg" alt="Figure 12.6 – Box with cubes with high friction"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Box with cubes with high friction</p>
			<p>What you see here is<a id="_idIndexMarker1163"/> that even though the box is moving around its axis, the <a id="_idIndexMarker1164"/>cubes barely move around. This is because the cubes themselves have very high friction. If you try this with low friction, you’ll see that the boxes will slide around in the bottom of <span class="No-Break">the box.</span></p>
			<p>To set the friction, all you have to do <span class="No-Break">is this:</span></p>
			<pre class="source-code">
const rigidBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setFriction(0.5)</pre>
			<p>Rapier provides one more way of controlling friction and that is by setting the combine rule using the <strong class="source-inline">setFrictionCombineRule</strong> function. This tells Rapier how to combine the friction of the two objects that have collided (in our example, the bottom of the box and<a id="_idIndexMarker1165"/> the cube). With <a id="_idIndexMarker1166"/>Rapier, you can set this to the <span class="No-Break">following values:</span></p>
			<ul>
				<li><strong class="source-inline">CoefficientCombineRule.Average</strong>: The average of the two coefficients <span class="No-Break">is used</span></li>
				<li><strong class="source-inline">CoefficientCombineRule.Min</strong>: The minimum among the two coefficients <span class="No-Break">is used</span></li>
				<li><strong class="source-inline">CoefficientCombineRule.Multiply</strong>: The product of the two coefficients <span class="No-Break">is used</span></li>
				<li><strong class="source-inline">CoefficientCombineRule.Max</strong>: The maximum among the two coefficients <span class="No-Break">is used</span></li>
			</ul>
			<p>To explore how <strong class="source-inline">restitution</strong> works, we can use this same <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">colliders-properties.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/Figure_12.7_B18726.jpg" alt="Figure 12.7 – Box with spheres with high restitution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Box with spheres with high restitution</p>
			<p>Here, we’ve increased the restitution of the spheres. The result is that they now bounce around in the box <a id="_idIndexMarker1167"/>when added or when they hit a wall. To set the restitution, you <a id="_idIndexMarker1168"/>use the same approach as for <span class="No-Break">the friction:</span></p>
			<pre class="source-code">
const rigidBodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
const rigidBody = world.createRigidBody(rigidBodyDesc)
const rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)
const rigidBodyCollider = world.createCollider
  (rigidBodyColliderDesc, rigidBody)
rigidBodyCollider.setRestitution(0.9)</pre>
			<p>Rapier also allows you to set how the <strong class="source-inline">restitution</strong> property of the objects that hit each other is calculated. You can use the same values but this time, you use the <span class="No-Break"><strong class="source-inline">setRestitutionCombineRule</strong></span><span class="No-Break"> function.</span></p>
			<p>The <strong class="source-inline">Collider</strong> has additional <a id="_idIndexMarker1169"/>properties you can use to fine-tune how the collider interacts<a id="_idIndexMarker1170"/> with the Rapier view of the world, and what happens when objects collide. Rapier itself provides very good documentation for this. Specifically for the colliders, you can find that documentation <span class="No-Break">here: </span><a href="https://rapier.rs/docs/user_guides/javascript/colliders#restitution"><span class="No-Break">https://rapier.rs/docs/user_guides/javascript/colliders#restitution</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Rapier-supported shapes</h1>
			<p>Rapier provides a number of shapes you can <a id="_idIndexMarker1171"/>use to wrap your geometries. In this section, we’ll walk you through all the available Rapier shapes and demonstrate these meshes through an example. Note that to use these shapes you need to call <strong class="source-inline">RAPIER.ColliderDesc.roundCuboid</strong>, <strong class="source-inline">RAPIER.ColliderDesc.ball</strong>, and <span class="No-Break">so on.</span></p>
			<p>Rapier provides 3D shapes and 2D shapes. We’ll only look at the 3D shapes provided <span class="No-Break">by Rapier:</span></p>
			<ul>
				<li><strong class="source-inline">ball</strong>: A ball shape, configured by setting the radius of <span class="No-Break">the ball</span></li>
				<li><strong class="source-inline">capsule</strong>: A capsule shape, defined by the half-height of the capsule and <span class="No-Break">its radius</span></li>
				<li><strong class="source-inline">cuboid</strong>: A simple cube shape defined by passing in the half-width, half-height, and half-depth of <span class="No-Break">the shape</span></li>
				<li><strong class="source-inline">heightfield</strong>: A height field is a shape for which each provided value defines the height of a <span class="No-Break">3D plane</span></li>
				<li><strong class="source-inline">cylinder</strong>: A cylinder shape defined by the half-height and the radius of <span class="No-Break">the cylinder</span></li>
				<li><strong class="source-inline">cone</strong>: A cone shape defined by the half-height and the radius of the bottom of <span class="No-Break">the cylinder</span></li>
				<li><strong class="source-inline">convexHull</strong>: A convex hull is the smallest shape that encompasses all the <span class="No-Break">passed-in points</span></li>
				<li><strong class="source-inline">convexMesh</strong>: A convex mesh also takes a number of points, but it is assumed that these points already form a convex hull, so Rapier won’t make any calculations to determine the <span class="No-Break">smaller shape</span></li>
			</ul>
			<p>Besides these shapes, Rapier also provides an additional rounded variant for a few of these shapes: <strong class="source-inline">roundCuboid</strong>, <strong class="source-inline">roundCylinder</strong>, <strong class="source-inline">roundCone</strong>, <strong class="source-inline">roundConvexHull</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">roundConvexMesh</strong></span><span class="No-Break">.</span></p>
			<p>We’ve provided another example in which you can what these shapes look like and how they interact when they <a id="_idIndexMarker1172"/>collide with each other. Open up the <strong class="source-inline">shapes.html</strong> example to see this <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/Figure_12.8_B18726.jpg" alt="Figure 12.8 – Shapes on top of a heightfield object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Shapes on top of a heightfield object</p>
			<p>When you open this example, you’ll see an empty <strong class="source-inline">heightfield</strong> object. With the menu on the right, you can add different shapes and they’ll collide with each other and with the <strong class="source-inline">heightfield</strong> instance. Once again, you can set the specific <strong class="source-inline">restitution</strong> and <strong class="source-inline">friction</strong> values for the objects you’re adding. Since we’ve already explained in the previous sections how to add the shape in Rapier and make sure the corresponding shapes in Three.js are updated, we won’t go into detail here on how to create the shapes from the previous list. For the code, look at the <strong class="source-inline">shapes.js</strong> file in the sources for <span class="No-Break">this chapter.</span></p>
			<p>One final note before we move on to the section on joints – when we want to depict simple shapes (for example, balls or cubes), the way that Rapier defines this model and the way Three.js defines it are pretty much the same. Therefore, when this kind of object collides with <a id="_idIndexMarker1173"/>another object, it will look correct. When we have more complex shapes, as, in this example, with a <strong class="source-inline">heightmap</strong> instance, there can be slight differences in how Three.js interprets and interpolates these points to a <strong class="source-inline">heightmap</strong> instance, and how Rapier does so. You can see this for yourself by looking at the <strong class="source-inline">shapes.html</strong> example, adding a lot of different shapes, and then looking at the underside of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">heightfield</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/Figure_12.9_B18726.jpg" alt="Figure 12.9 – Bottom of the heightfield"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Bottom of the heightfield</p>
			<p>What you can see here is that we can see small parts of the different objects poking through the <strong class="source-inline">heightmap</strong>. The reason is that Rapier has a different way of determining the exact shape of the <strong class="source-inline">heightmap</strong> than Three.js. In other words, Rapier thinks that the <strong class="source-inline">heightmap</strong> looks slightly different than<a id="_idIndexMarker1174"/> Three.js does. Therefore, when it determines where specific shapes are when they collide, it can result in small details such as this. However, by tuning the sizes or creating simpler objects, this can easily <span class="No-Break">be circumvented.</span></p>
			<p>So far, we’ve looked at gravity and collisions. Rapier also provides a way to limit the movement and rotation of rigid bodies. We’ll explain how Rapier does this by <span class="No-Break">using joints.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>Using joints to limit the movement of objects</h1>
			<p>Up until now, we’ve seen some basic physics in <a id="_idIndexMarker1175"/>action. We’ve seen how various shapes respond to gravity, friction, and restitution, and how this affects collision. Rapier also provides advanced constructs that allow you to limit the movement of your objects. In Rapier, these objects are called joints. The<a id="_idIndexMarker1176"/> following list gives an overview of the joints that are available <span class="No-Break">in Rapier:</span></p>
			<ul>
				<li><strong class="bold">Fixed joint</strong>: A fixed joint makes sure that two bodies don’t move relative to one another. This means that the <a id="_idIndexMarker1177"/>distance and rotation between these two objects<a id="_idIndexMarker1178"/> will always be <span class="No-Break">the same.</span></li>
				<li><strong class="bold">Spherical joint</strong>: A spherical joint <a id="_idIndexMarker1179"/>makes sure that the distance between two bodies<a id="_idIndexMarker1180"/> stays the same. The bodies, however, can move around one another on all <span class="No-Break">three axes.</span></li>
				<li><strong class="bold">Revolute joint</strong>: With this joint, the <a id="_idIndexMarker1181"/>distance between the two bodies stays the same, and they are<a id="_idIndexMarker1182"/> allowed to rotate on a single axis – for instance, a steering wheel, which can only rotate around a <span class="No-Break">single axis.</span></li>
				<li><strong class="bold">Prismatic joint</strong>: Similar to the<a id="_idIndexMarker1183"/> revolute joint but this time, the rotations between the<a id="_idIndexMarker1184"/> objects are fixed, and the objects can move on a single axis. This causes a sliding effect – for example, such as a lift <span class="No-Break">moving upward.</span></li>
			</ul>
			<p>In the following sections, we’ll explore these joints and see them in action in <span class="No-Break">the examples.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Connecting two objects with a fixed joint</h2>
			<p>The simplest of joints is <a id="_idIndexMarker1185"/>a fixed joint. With this joint, you can connect two objects, and they’ll stay at the same distance and orientation that is specified when this joint <span class="No-Break">is created.</span></p>
			<p>This is shown in the <span class="No-Break"><strong class="source-inline">fixed-joint.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/Figure_12.10_B18726.jpg" alt="Figure 12.10 – A fixed joint connecting two joints"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – A fixed joint connecting two joints</p>
			<p>As you can see in this example, the two cubes move as one. This happens because they are connected by a fixed <a id="_idIndexMarker1186"/>joint. To set this up, we first have to create the two <strong class="source-inline">RigidBody</strong> objects and the two <strong class="source-inline">Collider</strong> objects, as we’ve already seen in the previous sections. The next thing we need to do is connect these two objects. For this, we first need to <span class="No-Break">define </span><span class="No-Break"><strong class="source-inline">JointData</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  let params = RAPIER.JointData.fixed(
    { x: 0.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },
    { x: 2.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 }
  )</pre>
			<p>This means that we connect the first object at the position of <strong class="source-inline">{ x: 0.0, y: 0.0, z: 0.0 }</strong> (its center) to the second object, which is positioned at <strong class="source-inline">{ x: 2.0, y: 0.0, z: 0.0 }</strong>, where the first object is rotated with a quaternion of <strong class="source-inline">{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }</strong> and the second object is rotated the same amount –  <strong class="source-inline">{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }</strong>. The only thing that we need to do now is tell the Rapier <strong class="source-inline">world</strong> about this joint and which <strong class="source-inline">RigidBody</strong> objects it <span class="No-Break">applies to:</span></p>
			<pre class="source-code">
world.createImpulseJoint(params, rigidBody1, rigidBody2,
  true)</pre>
			<p>The last property here defines whether the <strong class="source-inline">RigidBody</strong> should wake up because of this joint. A <strong class="source-inline">RigidBody</strong> can<a id="_idIndexMarker1187"/> be put to sleep when it hasn’t moved for a couple of seconds. For joints, it is usually best to just set this to <strong class="source-inline">true</strong> since this makes sure that if one of the <strong class="source-inline">RigidBody</strong> objects to which we attach the joint is sleeping, <strong class="source-inline">RigidBody</strong> will <span class="No-Break">wake up.</span></p>
			<p>Another great way of seeing this joint in action is by using the <span class="No-Break">following parameters:</span></p>
			<pre class="source-code">
  let params = RAPIER.JointData.fixed(
    { x: 0.0, y: 0.0, z: 0.0 },
    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },
    { x: 2.0, y: 2.0, z: 2.0 },
    { w: 0.3, x: 1, y: 1, z: 1 }
  )</pre>
			<p>This will cause the two cubes to get caught on the floor in the center of <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/Figure_12.11_B18726.jpg" alt="Figure 12.11 – A fixed joint connecting two cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – A fixed joint connecting two cubes</p>
			<p>Next on our list is the <a id="_idIndexMarker1188"/><span class="No-Break">spherical joint.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Connecting objects with a spherical joint</h2>
			<p>A spherical joint allows two <a id="_idIndexMarker1189"/>objects to freely move around one another while keeping the same distance between these objects. This can be used for ragdoll effects or, as we did in this example, creating a <span class="No-Break">chain (</span><span class="No-Break"><strong class="source-inline">sphere-joint.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/Figure_12.12_B18726.jpg" alt="Figure 12.12 – Multiple spheres connected by a spherical joint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Multiple spheres connected by a spherical joint</p>
			<p>As you can see in this example, we’ve connected a large number of spheres to create a chain of spheres. When these spheres hit the cylinder in the middle, they’ll wrap around and slowly glide off this <a id="_idIndexMarker1190"/>cylinder. You can see that while the orientation between these spheres changes based on their collisions, the absolute distance between the spheres stays the same. So, to set up this example, we’ve created a number of spheres with <strong class="source-inline">RigidBody</strong> and <strong class="source-inline">Collider</strong>, similar to the previous examples. For each set of two spheres, we also create a joint <span class="No-Break">like this:</span></p>
			<pre class="source-code">
  const createChain = (beads) =&gt; {
    for (let i = 1; i &lt; beads.length; i++) {
      const previousBead = beads[i - 1].userData.rigidBody
      const thisBead = beads[i].userData.rigidBody
      const positionPrevious = beads[i - 1].position
      const positionNext = beads[i].position
      const xOffset = Math.abs(positionNext.x –
        positionPrevious.x)
      const params = RAPIER.JointData.spherical(
        { x: 0, y: 0, z: 0 },
        { x: xOffset, y: 0, z: 0 }
        )
      world.createImpulseJoint(params, thisBead,
        previousBead, true)
    }
  }</pre>
			<p>You can see that we create a joint using <strong class="source-inline">RAPIER.JointData.spherical</strong>. The parameters here define<a id="_idIndexMarker1191"/> the position of the first object, <strong class="source-inline">{ x: 0, y: 0, z: 0 }</strong>, and the relative position of the second object, <strong class="source-inline">{ x: xOffset, y: 0, z: 0 }</strong>. We do this for all the objects and add the joints to the rapier world using <strong class="source-inline">world.createImpulseJoint(params, thisBead, </strong><span class="No-Break"><strong class="source-inline">previousBead, true)</strong></span><span class="No-Break">.</span></p>
			<p>The result is that we’ve got a chain of spheres that is connected using these <span class="No-Break">spherical joints.</span></p>
			<p>The next joint, the revolute joint, allows us to restrict the movement of two objects by specifying a single axis around which an object is allowed to rotate in relation to <span class="No-Break">another object.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Limiting rotation with a revolute joint</h2>
			<p>With a revolute joint, it is<a id="_idIndexMarker1192"/> easy to create gear, wheel, and fan-like constructs that rotate around a single axis. The easiest way to explain this is by looking at the <span class="No-Break"><strong class="source-inline">revolute-joint.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="image/Figure_12.13_B18726.jpg" alt="Figure 12.13 – A cube before it is dropped on a rotating bar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – A cube before it is dropped on a rotating bar</p>
			<p>In <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.13</em>, you can see a purple cube hovering above a green bar. When you enable gravity in the <strong class="source-inline">y</strong> direction, the cube will drop on top of the green bar. The center of this green bar is connected to the fixed cube in the middle using a revolute joint. The result is that this green bar will now slowly rotate because of the weight of the <span class="No-Break">purple cube:</span></p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="image/Figure_12.14_B18726.jpg" alt="Figure 12.14 – The bar responding to the weight on one end"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – The bar responding to the weight on one end</p>
			<p>For a revolute joint to <a id="_idIndexMarker1193"/>work, we once again need two rigid bodies. The Rapier part of the gray cube is defined <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const bodyDesc = new RAPIER.RigidBodyDesc(RigidBodyType.Fixed)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid(0.5, 0.5, 0.5)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>This means, that this <strong class="source-inline">RigidBody</strong> will always be in the same location regardless of any forces exerted on it. The green bar is defined <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Const bodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
  .setCanSleep(false)
  .setTranslation(-1, 0, 0)
  .setAngularDamping(0.1)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid(0.25, 0.05,
  2)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>Nothing special here, but we <a id="_idIndexMarker1194"/>have introduced a new property could <strong class="source-inline">angularDamping</strong>. With angular damping, Rapier will slowly decrease the rotation speed of a <strong class="source-inline">RigidBody</strong>. In our example, this means that the bar will slowly stop rotating after <span class="No-Break">a while.</span></p>
			<p>And the box that we’re dropping looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Const bodyDesc = new RAPIER.RigidBodyDesc
  (RigidBodyType.Dynamic)
  .setCanSleep(false)
  .setTranslation(-1, 1, 1)
const body = world.createRigidBody(bodyDesc)
const colliderDesc = RAPIER.ColliderDesc.cuboid
  (0.1, 0.1, 0.1)
const collider = world.createCollider(colliderDesc, body)</pre>
			<p>So, at this point, we have defined <strong class="source-inline">RigidBody</strong>. Now, we can connect the fixed box with the <span class="No-Break">green bar:</span></p>
			<pre class="source-code">
const params = RAPIER.JointData.revolute(
  { x: 0.0, y: 0, z: 0 },
  { x: 1.0, y: 0, z: 0 },
  { x: 1, y: 0, z: 0 }
)
let joint = world.createImpulseJoint(params, fixedCubeBody,
  greenBarBody, true)</pre>
			<p>The first two parameters determine the position at which the two rigid bodies are connected (following the same idea as with the fixed joint). The last parameter defines the vector at which the bodies<a id="_idIndexMarker1195"/> can rotate in relation to one another. Since our first <strong class="source-inline">RigidBody</strong> is fixed, only the green bar <span class="No-Break">can rotate.</span></p>
			<p>The last joint type supported by Rapier is the <span class="No-Break">prismatic joint.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Limiting movement to a single axis with a prismatic joint</h2>
			<p>The prismatic joint limits the<a id="_idIndexMarker1196"/> movement of an object to a single axis. This is demonstrated in the following example (<strong class="source-inline">prismatic.html</strong>), where the movement of the reddish cube is limited to a <span class="No-Break">single axis:</span></p>
			<div>
				<div id="_idContainer278" class="IMG---Figure">
					<img src="image/Figure_12.15_B18726.jpg" alt="Figure 12.15 – Red cube is limited to one axis"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – Red cube is limited to one axis</p>
			<p>In this example, we throw a cube at the green bar with the revolute joint from the previous example. This <a id="_idIndexMarker1197"/>will cause the green bar to spin around its <em class="italic">y</em>-axis at the center and hit the reddish cube. This cube is limited to movement along a single axis, and you’ll see it moving along <span class="No-Break">that axis.</span></p>
			<p>To create the joint for this example, we used the following piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const prismaticParams = RAPIER.JointData.prismatic(
  { x: 0.0, y: 0.0, z: 0 },
  { x: 0.0, y: 0.0, z: 3 },
  { x: 1, y: 0, z: 0 }
)
prismaticParams.limits = [-2, 2]
prismaticParams.limitsEnabled = true
world.createImpulseJoint(prismaticParams, fixedCubeBody,
  redCubeBody, true)</pre>
			<p>We once again define the position (<strong class="source-inline">{ x: 0.0, y: 0.0, z: 0 }</strong>) of <strong class="source-inline">fixedCubeBody</strong> first, which<a id="_idIndexMarker1198"/> defines the object we’re moving in relation to. Then, we define the position of our cube – <strong class="source-inline">{ x: 0.0, y: 0.0, z: 3 }</strong>. Finally, we define the axis along which our object is allowed to move. In this case, we defined <strong class="source-inline">{ x: 1, y: 0, z: 0 }</strong>, which means it is allowed to move along <span class="No-Break">its </span><span class="No-Break"><em class="italic">x</em></span><span class="No-Break">-axis.</span></p>
			<p class="callout-heading">Using joint motors to move objects around their allowed axis</p>
			<p class="callout">Spherical, revolute, and prismatic joints also support something called motors. With motors, you can move a rigid body along its allowed axis. We haven’t shown this in these examples but by using motors, you can add gears that move around automatically or create a car where you move the wheels using revolute joints with the help of a motor. For more information on motors, see the relevant section of the Rapier documentation <span class="No-Break">here: </span><a href="https://rapier.rs/docs/user_guides/javascript/joints#joint-motors"><span class="No-Break">https://rapier.rs/docs/user_guides/javascript/joints#joint-motors</span></a><span class="No-Break">.</span></p>
			<p>As we mentioned in the <em class="italic">Creating a basic Three.js scene with Rapier</em> section, we’ve only scratched the surface of what is possible with Rapier. Rapier is an extensive library with many features that allow fine-tuning and should provide support for most cases in which you might need a physics engine. The library is actively being developed, and the online documentation is <span class="No-Break">very good.</span></p>
			<p>With the examples in this chapter and the online documentation, you should be able to integrate Rapier into your own scenes even for the features not explained in <span class="No-Break">this chapter.</span></p>
			<p>We’ve mainly looked at 3D models and how to render them in Three.js. However, Three.js also provides support for 3D sounds. In the next section, we’ll show you an example of how you can add directional sound to a <span class="No-Break">Three.js scene.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Adding sound sources to your scene</h1>
			<p>Having discussed several relevant topics by now, we have a lot of the ingredients in place to create beautiful scenes, games, and other 3D visualizations. What we haven’t shown, however, is how to<a id="_idIndexMarker1199"/> add sounds to your Three.js scene. In this section, we’ll look at two Three.js objects that allow you to add sources of sound to your scene. This is especially interesting since these sound sources respond to the position of <span class="No-Break">the camera:</span></p>
			<ul>
				<li>The distance between the sound source and the camera determines the volume of the <span class="No-Break">sound source</span></li>
				<li>The positions of the left-hand side and the right-hand side of the camera determine the sound volume of the left-hand side speaker and the right-hand side <span class="No-Break">speaker, respectively</span></li>
			</ul>
			<p>The best way to explain this is to see this in action. Open up the <strong class="source-inline">audio.html</strong> example in your browser, and you’ll see a scene from <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Animations and Moving </em><span class="No-Break"><em class="italic">the Camera</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/Figure_12.16_B18726.jpg" alt="Figure 12.16 – A scene with audio elements"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – A scene with audio elements</p>
			<p>This example uses the first-person controls we saw in <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, so you can use the arrow keys in combination with the mouse to move around the scene. Since browsers don’t support starting audio automatically anymore, first, hit the <strong class="source-inline">enableSounds</strong> button in the menu on the right to turn on the sounds. When you do this, you’ll hear water coming from somewhere nearby – and you’ll be able to hear some cows and some sheep in <span class="No-Break">the distance.</span></p>
			<p>The water sounds come from the water wheel behind your starting position, the sounds from the sheep come<a id="_idIndexMarker1200"/> from the flock of sheep to the right, and the cow sounds are centered on the two oxen pulling the plow. If you use the controls to move around the scene, you’ll notice that the sounds change based on where you are – the nearer you get to the sheep, the better you’ll hear them, and as you move to the left, the sounds of the oxen will be louder. This is something called positional audio, where the <a id="_idIndexMarker1201"/>volume and direction are used to determine how to play <span class="No-Break">the sounds.</span></p>
			<p>Accomplishing this only takes a small amount of code. The first thing we need to do is define a <strong class="source-inline">THREE.AudioListener</strong> object and add it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">THREE.PerspectiveCamera</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const listener = new THREE.AudioListener(); camera.add(listener1);</pre>
			<p>Next, we need to create a <strong class="source-inline">THREE.Mesh</strong> (or a <strong class="source-inline">THREE.Object3D</strong>) instance and add a <strong class="source-inline">THREE.PositionalAudio</strong> object to that mesh. This will determine the source location of this <span class="No-Break">specific sound:</span></p>
			<pre class="source-code">
const mesh1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1,
  1), new THREE.MeshNormalMaterial({ visible: false }))
mesh1.position.set(-4, -2, 10)
scene.add(mesh1)
const posSound1 = new THREE.PositionalAudio(listener)
const audioLoader = new THREE.AudioLoader()
audioLoader.load('/assets/sounds/water.mp3', function
  (buffer) {
posSound1.setBuffer(buffer)
posSound1.setRefDistance(1)
posSound1.setRolloffFactor(3)
posSound1.setLoop(true)
mesh1.add(posSound3)</pre>
			<p>As you can see from this code snippet, we first create a standard <strong class="source-inline">THREE.Mesh</strong> instance. Next, we create a <strong class="source-inline">THREE.PositionalAudio</strong> object, which we connect to the <strong class="source-inline">THREE.AudioListener</strong> object that we created earlier. Finally, we add the audio and configure some properties, which <a id="_idIndexMarker1202"/>define how the sound is played and how <span class="No-Break">it behaves:</span></p>
			<ul>
				<li><strong class="source-inline">setRefDistance</strong>: This determines the distance from the object at which the sound will be reduced <span class="No-Break">in volume.</span></li>
				<li><strong class="source-inline">setLoop</strong>: By default, a sound is played once. By setting this property to <strong class="source-inline">true</strong>, the <span class="No-Break">sound loops.</span></li>
				<li><strong class="source-inline">setRolloffFactor</strong>: This determines how quickly the volume decreases as you move away from the <span class="No-Break">sound source.</span></li>
			</ul>
			<p>Internally, Three.js uses the Web Audio API (<a href="http://webaudio.github.io/web-audio-api/">http://webaudio.github.io/web-audio-api/</a>) to play the sound and determine the correct volume. Not all browsers support this specification. The best support currently is from Chrome <span class="No-Break">and Firefox.</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Summary</h1>
			<p>In this chapter, we explored how you can extend the basic 3D functionality of Three.js by adding physics. For this, we used the Rapier library, which allows you to add gravity to your scene and objects, have objects interact with each other and bounce when they collide, and use joints to limit the movement of objects relative to <span class="No-Break">each other.</span></p>
			<p>Besides that, we also showed you how Three.js supports 3D sounds. We created a scene where you added positional sound using the <strong class="source-inline">THREE.PositionalAudio</strong> and <span class="No-Break"><strong class="source-inline">THREE.AudioListener</strong></span><span class="No-Break"> objects.</span></p>
			<p>Even though we’ve now covered all of the core functionalities provided by Three.js, there are two more chapters dedicated to exploring some external tools and libraries that you can use together with Three.js. In the next chapter, we’ll dive into Blender and see how we can use Blender’s functionality, such as baking shadows, editing UV maps, and exchanging models between Blender <span class="No-Break">and Three.js.</span></p>
		</div>
	</body></html>