- en: Chapter 7. Organizing Backbone Applications – Structure, Optimize, and Deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters of this book, we looked at the individual components
    of Backbone.js and learned about several good practices that help create a better
    application. However, Backbone itself doesn't provide any application structure
    or guidance on how to organize the application source code. This makes it quite
    difficult for beginner-level programmers to understand how to create a folder
    structure, add proper namespaces, load script files in the appropriate order,
    and follow patterns to create a robust app architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every Backbone.js developer, at some point of time, faces this issue.
    You can find many articles (check the blog links on application architecture in
    [Appendix A](apa.html "Appendix A. Books, Tutorials, and References"), *Books,
    Tutorials, and References*) on the Web where developers have described how they
    tried to structure their Backbone code base. But that again makes the task difficult
    because you may need to choose a particular solution from a number of different
    opinions and understand whether that is the best solution or not. In this chapter,
    we will look at a step-by-step process on how to organize the structure for both
    small- and large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Application directory structure**: Code organization is crucial in order
    to start developing a nontrivial JavaScript application. This section illustrates
    a boilerplate directory structure that may help you to conceptualize your application
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous module definition**: Rather than stacking a number of JavaScript
    files in your HTML file, **Asynchronous Module Definition** (**AMD**) helps in
    defining modules and loading its dependencies asynchronously in a subtle way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application architecture**: This section provides a complete step-by-step
    guide on the patterns and best practices that you should follow in your application
    architecture to make it flexible and maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the application directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code organization in a filesystem plays an important role in application development.
    It provides solutions to several problems such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the separation of concern for views, models, collections, and routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a clear entry point to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper namespacing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The directory structure that we are going to propose here is not something
    that will work universally for every application. As JavaScript doesn''t provide
    an inherent code organization mechanism, there is no single pattern that is best
    for all the applications; it solely depends on the situation. You are free to
    use the following structure, and lots of developers use it for their projects
    without any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application directory structure](img/3576OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We kept all of the static assets inside the `assets` folder. You can add more
    folders if you have other types of static resources. The templates are stored
    in a separate directory that matches the `views` folder structure. We will load
    these templates dynamically as needed and optimize them later to create a single
    file with all the templates (refer to [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    for more details). The `main.js` file is the entry point of the application. You
    will see its usage in the following section when we will discuss working with
    AMD. The `app.js` file holds the application class that acts as the topmost parent
    class of the application. All the utility files such as `utility.js` or `helper.js`,
    which mostly contain the helper methods, sit in the `util` folder. The `test`
    folder is the main directory in which all the test scripts are stored. The `config`
    and `mixin` folders are there to store the config and reusable mixin files respectively.
    This file structure is basic and can work as the boilerplate of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another pattern that became popular for large and complex applications
    recently—the modular approach. In this case, we divide the complete application
    into multiple small modules; each module will add a specific functionality to
    the app. We will look into it later in this chapter, but we can discuss the file
    structure of this pattern here. A module consists of its own views, models, and
    collections. You can have one `templates` folder for each module and place that
    module''s templates separately in that folder, or you can leave it as it is as
    a single `templates` folder for the complete project. We will go for the latter;
    the `app` folder will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application directory structure](img/3576OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is no separate `models`, `collections`, or `views` folder;
    instead, there is a `modules` directory that includes all the modules of the application.
    Each module contains a `main.js` file that works as the starting point of that
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how will you benefit by using such a modular pattern over the directory
    structure? Actually this is not just a change in the directory structure, but
    a completely new application architecture. We noticed that beginner-level developers,
    who are not very familiar with the module patterns, find it difficult to start
    with this structure—probably because it''s a new concept. However, once you start
    using it, you will realize that it is quite easy to work with and flexible too.
    The advantages of using such structures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The modules are generally independent of each other. So, you can re-use one
    module elsewhere with minimum changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules generally do not communicate with each other directly; they use
    a common medium to communicate. So, you can change or delete one module while
    the others stay untouched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code base becomes modular and more flexible as each module encapsulates
    their functionality. For example, a `User` module performs all of the user-related
    functions; no other part of your application will handle any user-related job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous structure is not the only way to make the app modular. There are
    several other concepts and you can choose any of them as per your requirements.
    For example, I often use the AuraJS directory structure (the `TodoMVC` app from
    [https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc)) while
    working with this framework. It is similar yet different and useful. So, if you
    are aware of multiple such directory structures and do not know which one to choose,
    go for the one that we mentioned previously. There is no harm in following a standard
    structure; it is better than going for an unstructured project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Asynchronous Module Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned to add all our script files in HTML files within `SCRIPT`
    tags. The browser loads these files synchronously and hence we always need to
    ensure that if one file has a dependency over another file, the latter should
    always be loaded prior to the former. Since all of the references to these dependencies
    are made via global variables, these dependencies must be loaded in the proper
    order, and a developer must take care of them before he adds a new script file
    to the application. Although this process works just fine, it may become difficult
    to manage large applications as too many dependencies will overlap. AMD provides
    a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: AMD is a mechanism used to define a module such that the module and its dependencies
    can be asynchronously loaded. So, multiple AMD modules can be loaded in parallel,
    and once the last dependent module is loaded, the main module will execute. In
    addition, AMD omits the use of global variables by encapsulating the module definition,
    and provides a way to load multiple modules into one file and obviates the need
    for explicit namespacing.
  prefs: []
  type: TYPE_NORMAL
- en: Presently, the most popular script loader that supports AMD is Require.js ([http://requirejs.org](http://requirejs.org)).
    It provides an implementation of the module patterns and allows us to create a
    centrally-managed dependency mapping using its map configuration. Discussing Require.js
    in detail is beyond the scope of this chapter. So, if you want to get a complete
    overview of the concept, we recommend you visit their website first before proceeding
    to the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Require.js to your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `require.js` loads all the modules of your application, it is the only
    file that you need to include in your `index.html` file. Add the following script
    tag within the `HEAD` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `data-main` attribute specifies the JavaScript file that will act as the
    starting point of the application. In this case, it is our `main.js` file. Once
    the `require.js` file is loaded, it looks into the `data-main` attribute's entry
    point and loads that script. We are going to add the entire `require.js` configuration
    to this file along with all of the libraries and their dependencies. You do not
    need to add a `.js` extension to any file as RequireJS automatically appends that.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to add all the library files in the RequireJS config option, along
    with their paths and dependencies, to the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `require.config()` method in the `data-main` entry file and pass
    a configuration object with a set of properties to it. There are quite a number
    of properties that can go as config options, but we will discuss only those that
    are the most important at this point. You can find a complete list in the `require.js`
    API ([http://requirejs.org/docs/api.html](http://requirejs.org/docs/api.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`baseUrl`: This config defines the root path so you do not need to include
    it every time in your file paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paths`: This config specifies the shortcut alias of each file and the paths
    to the files are given relative to `baseUrl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shim`: This config should be used only for the non-AMD files, that is, the
    scripts that do not already call the `define()` method. It will not work properly
    for AMD files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: This config is the global variable name of that module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deps`: This config is an array of dependencies that must be loaded first before
    the respective module loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to look for the AMD-enabled version of the library files if you want
    to use them directly. Otherwise, you have to go via the `shim` option.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RequireJS provides two important methods—`define()` and `require()`, which
    facilitate module definition and dependency loading respectively. The `define()`
    method takes an optional module ID, an optional array that includes the dependencies
    that this module may require, and a function that gets executed in order to instantiate
    the module. The most basic module definition of a Backbone model will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this model can be used in another file just as the other dependencies.
    The interesting thing is that RequireJS makes sure that a particular file is loaded
    only once, irrespective of how many times you include it in several files. Now,
    let''s create a `Users` collection and use our `User` model there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is pretty simple, right? Also, notice that we loaded the dependencies in
    a pattern other than what we used for our model definition. This pattern is called
    the `Sugar` syntax and it utilizes the `require()` method to load the dependencies.
    You can use either of the syntaxes with your module definitions. When there are
    lots of dependencies, using the `Sugar` syntax makes it easier to organize the
    dependency variables rather than just putting them as arguments of a function.
  prefs: []
  type: TYPE_NORMAL
- en: So, with AMD, you can define all of your files in the same way. The script dependencies
    are loaded as we saw previously, and the text dependencies can be loaded using
    the `text` plugin ([https://github.com/requirejs/text](https://github.com/requirejs/text))
    of RequireJS. We already discussed this thoroughly in [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    when we loaded the external template files using this plugin. In the following
    section, we are going to see how we can initiate a complete application architecture
    using these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essential premise at the heart of Backbone has always been to try and discover
    the minimal set of data-structuring (Models and Collections) and user interface
    (Views and URLs) primitives that are useful when building web applications with
    JavaScript.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jeremy Ashkenas, creator of Backbone.js, Underscore.js, and CoffeeScript
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As Jeremy mentioned, Backbone.js has no intention, at least in the near future,
    to raise its bar to provide application architecture. Backbone will continue to
    be a lightweight tool to produce the minimal features required for web development.
    So, should we blame Backbone.js for not including such functionality even though
    there is a huge demand for this in the developer community? Certainly not! Backbone.js
    only yields the set of components that are necessary to create the backbone of
    an application and gives us complete freedom to build the app architecture in
    whichever way we want.
  prefs: []
  type: TYPE_NORMAL
- en: If working on a significantly large JavaScript application, remember to dedicate
    sufficient time to planning the underlying architecture that makes the most sense.
    It's often more complex than you may initially imagine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Addy Osmani, author of Patterns For Large-Scale JavaScript Application Architecture
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, as we start digging into more detail on creating an application architecture,
    we are not going to talk about trivial applications or something similar to a
    to-do-list app. Rather, we will investigate how to structure a medium- or large-level
    application. After discussions with a number of developers, we found that the
    main issue they face here is that there are several methodologies the online blog
    posts and tutorials offer to structure an application. While most of these tutorials
    talk about good practices, it becomes difficult to choose exactly one from them.
    Keeping that in mind, we will explore a number of steps that you should follow
    to make your app robust and maintainable in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a project directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the first step towards creating a solid app architecture. We have already
    discussed this in detail in the previous sections. If you are comfortable using
    another directory layout, go ahead with it. The directory structure will not matter
    much if the rest of your application is organized properly.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code with AMD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use RequireJS for our project. As discussed earlier, it comes with
    a bunch of facilities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a lot of script tags in one HTML file and managing all of the dependencies
    on your own may work for a medium-level project, but will gradually fail for a
    large-level project. Such a project may have thousands of lines of code; managing
    a code base of that size requires small modules to be defined in each individual
    file. With RequireJS, you do not need to worry about how many files you have—you
    just know that if the standard is followed properly, it is bound to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global namespace is never touched and you can freely give the best names
    to something that matches with it the most.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the RequireJS modules is a lot easier than other approaches because
    you know what the dependencies and path to each of them are in every module definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `r.js`, an optimization tool for RequireJS that minifies all the
    JavaScript and CSS files, to create the production-ready build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a Backbone app, there must be a centralized object that will hold together
    all the components of the application. In a simple application, most people generally
    just make the main router work as the central object. But that will surely not
    work for a large application and you need an `Application` object that should
    work as the parent component. This object should have a method (mostly `init()`)
    that will work as the entry point to your application and initialize the main
    router along with the Backbone history. In addition, either your `Application`
    class should extend `Backbone.Events` or it should include a property that points
    to an instance of the `Backbone.Events` class. The benefit of doing this is that
    the `app` or `Backbone.Events` instance can act as a central event aggregator,
    and you can trigger application-level events on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very basic `Application` class will look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Application` is a simple class with an `init()` method and a `PubSub` instance.
    The `init()` method acts as the starting point of the application and `PubSub`
    works as the application-level event manager. You can add more functionality to
    the `Application` class, such as starting and stopping modules and adding a region
    manager for view layout management. It is advisable to keep this class as short
    as you can.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the module pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We often see that intermediate-level developers find it a bit confusing to initially
    use a module-based architecture. It can be a little difficult for them to make
    the transition from a simple MVC architecture to a modular MVC architecture. While
    the points we are discussing in this chapter are valid for both these architectures,
    we should always prefer to use a modular concept in nontrivial applications for
    better maintainability and organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the directory structure section, we saw how the module consists of a `main.js`
    file, its views, models, and collections all together. The `main.js` file will
    define the module and have different methods to manage the other components of
    that module. It works as the starting point of the module. A simple `main.js`
    file will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the responsibility of this file is to initiate the module and
    manage the components of that module. We have to make sure that it handles only
    parent-level tasks; it shouldn't contain a method that one of its views should
    ideally have.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is not very complex, but you need to set it up properly in order
    to use it for a large application. You can even go for an existing app and module
    setup and integrate it with your Backbone app. For instance, Marionette provides
    an application infrastructure for Backbone apps. You can use its inbuilt `Application`
    and `Module` classes to structure your application. It also provides a general-purpose
    `Controller` class—something that doesn't come with the Backbone library but can
    be used as a mediator to provide generic methods and work as a common medium among
    the modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use AuraJS ([https://github.com/aurajs/aura](https://github.com/aurajs/aura)),
    a framework-agonistic event-driven architecture developed by Addy Osmani ([http://addyosmani.com](http://addyosmani.com))
    and many others; it works quite well with Backbone.js. A thorough discussion on
    AuraJS is beyond the scope of this book, but you can grab a lot of useful information
    about it from its documentation and examples ([https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc)).
    It is an excellent boilerplate tool that gives your app a kick-start and we highly
    recommend it, especially if you are not using the Marionette application infrastructure.
    The following are a few benefits of using AuraJS; they may help you choose this
    framework for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: AuraJS is framework-agnostic. Though it works great with Backbone.js, you can
    use it for your JavaScript module architecture even if you aren't using Backbone.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It utilizes the module pattern, application-level and module-level communication
    using the facade (sandbox) and mediator patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It abstracts away the utility libraries that you use (such as templating and
    DOM manipulation) so you can swap alternatives anytime you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing objects and module communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important ways to keep the application code maintainable is
    to reduce the tight coupling between modules and objects. If you are following
    the module pattern, you should never let one module communicate with another directly.
    Loose coupling adds a level of restriction in your code, and a change in one module
    will never enforce a change in the rest of the application. Moreover, it lets
    you re-use the same modules elsewhere. But how can we communicate if there is
    no direct relationship? The two important patterns we use in this case are the
    observer and mediator patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Using the observer/PubSub pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The PubSub pattern is nothing but the event dispatcher concept that we discussed
    in [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"),
    *Working with Events, Sync, and Storage*. It works as a messaging channel between
    the object (publisher) that fires the event and another object (subscriber) that
    receives the notification.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the observer/PubSub pattern](img/3576OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We mentioned earlier that we can have an application-level event aggregator
    as a property of the `Application` object. This event aggregator can work as the
    common channel via which the other modules can communicate, and that too without
    interacting directly.
  prefs: []
  type: TYPE_NORMAL
- en: Even at the module-level, you may need a common event dispatcher only for that
    module; the views, models, and collections of that module can use it to communicate
    with each other. However, publishing too many events via a dispatcher sometimes
    makes it difficult to manage them and you must be careful enough to understand
    which events you should publish via a generic dispatcher and which ones you should
    fire on a certain component only. Anyhow, this pattern is one of the best tools
    to design a decoupled system, and you should always have one ready for use in
    your module-based application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mediator pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, you may find that too many relationships exist between the modules
    of your app, and you need a central point of control that will help manage all
    the communication. This centralized system is called the mediator; it works as
    a *shared subject* between a set of modules and promotes loose coupling by not
    referring to the modules explicitly. All the modules will have a reference to
    this mediator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mediator pattern is somewhat similar to the observer pattern, but it doesn''t
    work as a broadcasting system. It includes a set of methods that are accessible
    to all modules that share this mediator. A mediator can be a simple object with
    a number of required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any module can access any method of this mediator.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *A mediator is best applied when two or more objects have an indirect
    working relationship, and business logic or workflow needs to dictate the interactions
    and coordination of these objects.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Addy Osmani* |'
  prefs: []
  type: TYPE_TB
- en: 'The concept of a mediator will get more clear once we look at a simple example.
    Assume that we have two modules: `User` and `Event`. The `User` module has a `getUserDetails()`
    method to retrieve a user''s details based on the user ID. The `Event` module
    has a `loadEvents()` method whose job it is to load all the events near the user''s
    current location. Now, getting the currently logged-in user''s ID or current location
    is a functionality that isn''t particularly module-specific, and it is better
    to keep it in a `Mediator` instance. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just pass the `Mediator` instance in both the module definitions
    and place the reusable and shared methods inside the mediator so that they can
    be accessed from any module. This is a basic example; we hope that it conveys
    the idea of using a mediator. In a complete application level, a mediator may
    take care of a lot of its functionality. Using a mediator without knowing its
    proper use is not a good idea—let''s look at the pros and cons of using a mediator
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The biggest advantage of using the mediator pattern is that it enforces the
    communication channel between modules to change from many-to-many to many-to-one.
    So, the modules will not communicate directly with each other but via the `mediator`
    object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It omits the tight coupling between modules and thus reduces the architectural
    complexity in large applications.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main drawback of this pattern is that it can introduce a single point of
    failure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating back and forth via a mediator may sometimes result in a performance
    hit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyhow, both these patterns—observer and mediator, if you have noticed already,
    are one of the simplest to implement. If used properly, they can become the best
    resources for organizing and maintaining your application. It is not a big deal
    to use them; you can implement these concepts even in small- and medium-level
    applications. Whenever you feel the need for module or component communication,
    a mediator or PubSub pattern can become handy.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding view management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone views are very lightweight components, and you need to add some custom
    functions to handle event binding, proper layout, data integration, and life cycle
    management in almost every app. So, it is always preferable to have a base view
    that will handle this common functionality; all other views will extend from it.
    For this purpose, we recommend you choose MarionetteJS, which provides three extremely
    useful view classes: `ItemView`, `CollectionView`, and `CompositeView`. These
    classes, along with Marionette''s base `View` class, facilitate the most important
    boilerplate functionality that one may need to use for his/her app views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more important aspects of view management: the layout manager
    and the template handler. We discussed both these topics in detail in [Chapter
    2](ch02.html "Chapter 2. Working with Views"), *Working with Views*. In a large
    application, a single page consists of multiple views and a major task involves
    creating, switching, and destroying these views. While you can always handle this
    layout management yourself, an existing robust layout manager will help you to
    maintain these views and clean up the memory. You can choose either the `Backbone.LayoutManager`
    plugin or the `Marionette.RegionManager` extension for this job. Both of them
    provide similar functionality and are well-accepted in the developer community.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For templates, we advise you to observe the following important points for
    a large application:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Handlebars instead of Underscore's template engine, although there is no
    restriction in choosing other template engines. Just make sure that you do not
    evaluate JavaScript code in your template—this increases the complexity, as we
    discussed in [Chapter 2](ch02.html "Chapter 2. Working with Views"), *Working
    with Views*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your view templates in separate and individual files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always precompile your templates. A number of processes that we discussed in
    [Chapter 2](ch02.html "Chapter 2. Working with Views"), *Working with Views*,
    [Appendix B](apb.html "Appendix B. Precompiling Templates on the Server Side"),
    *Precompiling Templates on the Server Side*, and [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    describe how you should precompile your templates and load them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding other important features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are few more things that you need to take care of while developing complex
    apps. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple routers**: It''s always preferable to have multiple routers compared
    to a gigantic router class. We discussed the concept of subrouters in [Chapter
    5](ch05.html "Chapter 5. Routing Best Practices and Subrouting"), *Routing Best
    Practices and Subrouting*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility methods**: Each application needs a set of utility methods that are
    generic and can be used by any component of the application. You should always
    have one or more than one `Utility` class depending on the requirements, and these
    classes should take care of all the common utility methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM handling**: The more you interact with the DOM in your views, the more
    difficult will it be to maintain in the later stage. Always try to reduce direct
    DOM manipulation as much as you can.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handler**: Keep a generic error/exception handler ready; it should
    work as a single point for the errors/warnings and display messages to the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**: In single-page large applications, memory leak is a
    real point of concern. So, you must be very much careful about not initiating
    global variables, cleaning up references when they are not in use, and unbinding
    events when the related element or component is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dealt with one of the most important topics of Backbone.js-based
    application development. At the framework level, learning Backbone is quite easy
    and developers get a complete grasp over it in a very short period of time. Developing
    simple applications with a few pages never seems to be an issue. But when it comes
    to a large complex application, laying out the architecture becomes quite confusing,
    with what to include and what not to. In this chapter, we tried to discuss every
    point associated with the app's architecture and mentioned when and why you should
    use a particular pattern. Moreover, most of these patterns are applied to a number
    of large applications with success. So, you can adopt these concepts without any
    hesitation.
  prefs: []
  type: TYPE_NORMAL
- en: Until this chapter, we talked about almost everything related to Backbone.js
    application development. However, no project is complete without proper testing,
    and that is what we are going to learn in our next and final chapter, [Chapter
    8](ch08.html "Chapter 8. Unit Test, Stub, Spy, and Mock Your App"), *Unit Test,
    Stub, Spy, and Mock Your App*.
  prefs: []
  type: TYPE_NORMAL
